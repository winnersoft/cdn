/**
 * 
 */

/*
 * 시트동작에 필요한 상수
 */
    var DATA_TABLE = 0; // 시트 제거 (분석시트에서 사용)
    var COL_TABLE = 1; // 시트 제거 (분석시트에서 사용)
    var ROW_TABLE = 2; // 시트 제거 (분석시트에서 사용)
    var FIX_TABLE = 3; // 시트 제거 (분석시트에서 사용)
//    var ROW_TABLE_RIGHT = 4;
//    var FIX_TABLE_RIGHT = 5;
//    var BOTTOM_TABLE_CENTER = 6;
//    var BOTTOM_TABLE_LEFT = 7;
//    var BOTTOM_TABLE_RIGHT = 8;
    
    // 셀타입설정에 필요한 상수
    var CELLTYPE_DATE       = 0; // 날자 : 93 년월일, 92 년월, 91 년
    var CELLTYPE_EDIT       = 1;
    var CELLTYPE_INTEGER    = 3;
    var CELLTYPE_MASK       = 4; 
    var CELLTYPE_TIME       = 6; //시간 12, 24 시 , 시분초 입력 선택
    var CELLTYPE_BUTTON     = 7;
    var CELLTYPE_COMBOBOX   = 8;
    var CELLTYPE_PICTURE    = 9; /**@ 메뉴얼에 Rock 으로 구현하도록 표시 */
    var CELLTYPE_CHECKBOX   = 10;
    var CELLTYPE_NUMBER     = 13;
    var CELLTYPE_PERCENT    = 14; // 퍼센트

	// 추가 셀 타입(차중훈)
	var CELLTYPE_LINK		= 15;
    
    /**@ 추가할 셀 타입 **/
    var CELLTYPE_ICON    = 2; // 아이콘
    var CELLTYPE_BAR    = 5; // Bar
    var CELLTYPE_SIGNAL    = 11; // Signal
    var CELLTYPE_PASSWORD    = 12; // PassWord
    var CELLTYPE_STATICTEXT = 5; // 시트 제거 (분석시트에서 사용)
    var CELLTYPE_OWNERDRAWN = 11;  // 시트 제거 (분석시트에서 사용) 
    var CELLTYPE_CURRENCY   = 12;  // 시트 제거 (분석시트에서 사용)
    var CELLTYPE_FLOAT      = 13;  // 시트 제거 (분석시트에서 사용)
    
    // 줄,열번호환산에 필요한 상수
    var CONV_LOGICAL_SHEET = 1;
    var CONV_LOGICAL_HARD  = 2;
    var CONV_SHEET_LOGICAL = 3;
    var CONV_SHEET_HARD    = 4;
    var CONV_HARD_LOGICAL  = 5;
    var CONV_HARD_SHEET    = 6;
    
    // 시트타입 구분에 사용하는 변수
    var SHEETTYPE_DATASHEET = 1;
    var SHEETTYPE_LISTSHEET = 2;
    
    // 시트채우기 모드
    var SHEETMODE_SETCELL = 1;
    var SHEETMODE_SETDATA = 2;
    
    // 시트 탭키 동작모드
    var SHEET_TAB_TONEXTCELL = 1;
    var SHEET_TAB_TONEXTCTRL = 0;
    
    var SHEET_NEED_UODATE = true;
    var SHEET_NEED_NOT_UODATE = false;
    
    var SHEET_ALIGN_LEFT = 0;
    var SHEET_ALIGN_RIGHT = 1;
    var SHEET_ALIGN_CENTER = 2;
    
    var SHEET_VALIGN_MIDDLE = 0;
    var SHEET_VALIGN_BASELINE = 1;
    var SHEET_VALIGN_BOTTOM = 2;
    var SHEET_VALIGN_TOP = 3;
    
    var SHEET_PERCENT_CEIL = 1;
    var SHEET_PERCENT_FLOOR = 2;
    var SHEET_PERCENT_ROUND = 3;
    
    var SHEET_TIME_FORMAT_12HR_DISPLAY_HOUR  = "hh";
    var SHEET_TIME_FORMAT_12HR_DISPLAY_MINS  = "hhMM";
    var SHEET_TIME_FORMAT_12HR_DISPLAY_SCNDS = "hhMMss";
    var SHEET_TIME_FORMAT_24HR_DISPLAY_HOUR  = "HH";
    var SHEET_TIME_FORMAT_24HR_DISPLAY_MINS  = "HHMM";
    var SHEET_TIME_FORMAT_24HR_DISPLAY_SCNDS = "HHMMss";
    
    var SHEET_DATE_CHECK_FORMAT_YYYYMMDD = 0;        // 년월일
    var SHEET_DATE_CHECK_FORMAT_YYYYMM = 1;          // 년월
    var SHEET_DATE_CHECK_FORMAT_YYYY = 2;            // 년도
    var SHEET_DATE_CHECK_FORMAT_YYYYMMDDHHNNSS =3;   // 년월일시분초
    var SHEET_DATE_CHECK_FORMAT_YYYYMMDDHHNN = 4;    // 년월일시분
    var SHEET_DATE_CHECK_FORMAT_YYYYMMDDHH = 5;      // 년월일시
    var SHEET_DATE_CHECK_FORMAT_HHNNSS = 6;          // 시분초
    var SHEET_DATE_CHECK_FORMAT_HHNN = 7;            // 시분
    var SHEET_DATE_CHECK_FORMAT_HH = 8;              // 시
    
    // 시트 선택 타입(차중훈)
	var SHEET_SELECT_NONE = 0;						 // 셀 선택 안함
	var SHEET_SELECT_CELL = 1;						 // 셀 선택
	var SHEET_SELECT_ROW = 2;						 // 행 선택
   
    // Sort 에 필요한 상수
    var SHEET_SORT_ORDER_ASCENDING  = true;          // 오름차순 정렬
    var SHEET_SORT_ORDER_DESCENDING = false;         // 내림차순 정렬
    var SHEET_SORT_COLUMN_ID = "";                   // 정렬 기준이 되는 칼럼명 
    var SHEET_SORT_ORDER = "ASC";                    // 현재 정렬작업의 정렬차순
     
    var SHEET_RESET_DATA = false;					// 렌더링에서 데이터만 변경처리
    var SHEET_RESET_DESIGN = true;					// 렌더링에서 시트 디자인만 변경처리
    
    var ARRAY_ESCAPING_FROM_STRINGS = [",", ":", ";", "&", "%", "?"];
    var ARRAY_ESCAPING_TO_STRINGS   = ["<COMMA>", "<COLON>", "<SEMICOLON>", "<AMP>", "<PERCENT>", "<QUESTION>"];

    var SHEET_MERGE_UNFIXED = 0;
    var SHEET_MERGE_NEED_NOT = 1;
    var SHEET_MERGE_NEED = 2;

    var SHEET_CELL_MERGE_NOT = 0;
    var SHEET_CELL_MERGE_ALWAYS = 1;
    var SHEET_CELL_MERGE_RESTRICT = 2;

    
    // 표시형식 반올림
    var DISPAY_FORMAT_ROUND = 0;
    var DISPAY_FORMAT_CEIL = 1;
    var DISPAY_FORMAT_FLOOR = 2;
    
    // 체크타입
    var CEHCK_TYPE_NONE = 0;
    var CEHCK_TYPE_FORMULA = 1;
    var CEHCK_TYPE_YYYY = 2;
    var CEHCK_TYPE_YM = 3;
    var CEHCK_TYPE_YMD = 4;
    var CEHCK_TYPE_RESINUM = 5;
    var CEHCK_TYPE_TAXNUM = 6;
    var CEHCK_TYPE_POSTNUM = 7;
    var CEHCK_TYPE_AMOUNT = 9;
    var CEHCK_TYPE_NUMBER = 10;
    var CEHCK_TYPE_IMEMODE = 11;
    var CEHCK_TYPE_ENGLNUM = 12;
    var CEHCK_TYPE_BARCODE = 13;
    var CEHCK_TYPE_PASSWORD = 14;
    
    var OBJECT_DATA_RESET_BY_SETDATASET    = "setDataSet";
    var OBJECT_DATA_RESET_BY_APPENDDATASET = "appendDataSet";
    var OBJECT_DATA_RESET_BY_REMOVEDATASET = "removeDataSet";
    var OBJECT_DATA_RESET_BY_CLEAR         = "clear";
    var OBJECT_DATA_RESET_BY_CHANGESEQ     = "changeSeq";
    var OBJECT_DATA_RESET_BY_LOADDATA      = "loadData";
    var OBJECT_DATA_RESET_BY_SORT          = "sort";
    
    // 브라우저 체크
    var userAgent = navigator.userAgent.toLowerCase();
    var Browser = {
    		ie : /trident/.test(userAgent),
    		firefox : /firefox/.test(userAgent),
    		chrome : /chrome/.test(userAgent),
    		opera : /opera/.test(userAgent),
    		safari : /safari/.test(userAgent) && !/chrome/.test(userAgent),
    		mac : /mac/.test(userAgent)
    	};
    
    
    /*******************************************************************************
        전역상수 
    *******************************************************************************/
        
        var USER_BROWSER_NAME = navigator.appName.toLowerCase();  // ex:"microsoft internet explorer", "Netscape"
        var USER_BROWSER_VER  = parseFloat(navigator.appVersion);
//        var IS_IE9_OR_LOWER_VERSION = ( navigator.appName.toLowerCase().indexOf("microsoft") >= 0 && 
//                                        (navigator.appVersion.indexOf("MSIE 7") > 0 || 
//                                         navigator.appVersion.indexOf("MSIE 8") > 0 ||
//                                         navigator.appVersion.indexOf("MSIE 9") > 0));
        var IS_IE9_OR_LOWER_VERSION = (navigator.appVersion.indexOf("MSIE 7") >= 0
        								|| navigator.appVersion.indexOf("MSIE 8") >= 0
        								|| navigator.appVersion.indexOf("MSIE 9") >= 0);
        		
    /*
     * Tree 동작에 필요한 상수
     */
        var tvwTreeLines = 0;
        var tvwRootLines = 1;
        
        var tvwFirst = 0;
        var tvwLast = 1;
        var tvwNext = 2;
        var tvwPrevious = 3;
        var tvwChild = 4;
        
        // 트리에 필요한 그림상수 변수
        var PLUS_NORMAL   = 0;
        var PLUS_BOTTOM   = 1;
        var MINUS_NORMAL  = 2;
        var MINUS_BOTTOM  = 3;
        var FOLDER_NORMAL = 4;
        var FOLDER_OPEN   = 5;
        var JOIN_NORMAL   = 6;
        var JOIN_BOTTOM   = 7;
        var LINE_BLANK    = 8;
        var EMPTY_ICON    = 9;
        var PAGE_ICON     = 10;

        // CROSS SHEET에 필요한 상수    
        // 선긋기에 필요한 상수 
        var RCTYPE_ISCOL = 1;
        var RCTYPE_ISROW = 1;
        var FONT_WIDTH   = 7; // 폰트 한바이트당 크기
        
        // 보이기 숨기기 구분
        var ACTION_SHOW = 1;
        var ACTION_HIDE = 2;
        
/*
        // 트리에 필요한 상수
        var icons = new Array(6);
        icons[PLUS_NORMAL]       = new Image();
        icons[PLUS_NORMAL].src   = CONTEXT_ROOT + "/winnersoft/images/tree/plus.gif";
        icons[PLUS_BOTTOM]       = new Image();
        icons[PLUS_BOTTOM].src   = CONTEXT_ROOT + "/winnersoft/images/tree/plusbottom.gif";
        icons[MINUS_NORMAL]      = new Image();
        icons[MINUS_NORMAL].src  = CONTEXT_ROOT + "/winnersoft/images/tree/minus.gif";
        icons[MINUS_BOTTOM]      = new Image();
        icons[MINUS_BOTTOM].src  = CONTEXT_ROOT + "/winnersoft/images/tree/minusbottom.gif";
        icons[FOLDER_NORMAL]     = new Image();
        icons[FOLDER_NORMAL].src = CONTEXT_ROOT + "/winnersoft/images/tree/folder.gif";
        icons[FOLDER_OPEN]       = new Image();
        icons[FOLDER_OPEN].src   = CONTEXT_ROOT + "/winnersoft/images/tree/folderopen.gif";
        icons[JOIN_NORMAL]       = new Image();
        icons[JOIN_NORMAL].src   = CONTEXT_ROOT + "/winnersoft/images/tree/join.gif";
        icons[JOIN_BOTTOM]       = new Image();
        icons[JOIN_BOTTOM].src   = CONTEXT_ROOT + "/winnersoft/images/tree/joinbottom.gif";
        icons[LINE_BLANK]        = new Image();
        icons[LINE_BLANK].src    = CONTEXT_ROOT + "/winnersoft/images/tree/line.gif";
        icons[EMPTY_ICON]        = new Image();
        icons[EMPTY_ICON].src    = CONTEXT_ROOT + "/winnersoft/images/tree/empty.gif";
        icons[PAGE_ICON]         = new Image();
        icons[PAGE_ICON].src     = CONTEXT_ROOT + "/winnersoft/images/tree/page.gif";
*/
        
        // 쿼리 데이터 타입
        var SQL_TYPE_NULL          = 0   ;
        var SQL_TYPE_CHAR          = 1   ;
        var SQL_TYPE_NUMERIC       = 2   ;
        var SQL_TYPE_DECIMAL       = 3   ;
        var SQL_TYPE_INTEGER       = 4   ;
        var SQL_TYPE_SMALLINT      = 5   ;
        var SQL_TYPE_FLOAT         = 6   ;
        var SQL_TYPE_REAL          = 7   ;
        var SQL_TYPE_DOUBLE        = 8   ;
        var SQL_TYPE_LONGVARCHAR   = -1  ;
        var SQL_TYPE_BINARY        = -2  ;
        var SQL_TYPE_VARBINARY     = -3  ;
        var SQL_TYPE_LONGVARBINARY = -4  ;
        var SQL_TYPE_BIGINT        = -5  ;
        var SQL_TYPE_TINYINT       = -6  ;
        var SQL_TYPE_BIT           = -7  ;
        var SQL_TYPE_VARCHAR       = 12  ;
        var SQL_TYPE_BOOLEAN       = 16  ;
        var SQL_TYPE_DATALINK      = 70  ;
        var SQL_TYPE_DATE          = 91  ;
        var SQL_TYPE_TIME          = 92  ;
        var SQL_TYPE_TIMESTAMP     = 93  ;
        var SQL_TYPE_OTHER         = 1111;
        var SQL_TYPE_JAVA_OBJECT   = 2000;
        var SQL_TYPE_DISTINCT      = 2001;
        var SQL_TYPE_STRUCT        = 2002;
        var SQL_TYPE_ARRAY         = 2003;
        var SQL_TYPE_BLOB          = 2004;
        var SQL_TYPE_CLOB          = 2005;
        var SQL_TYPE_REF           = 2006;

        // 가저오기중 시트채우기 실행중구분 : 시트갱신시 콘트롤 매번 시퀀스 바꿔가며 갱신 방지
        var FILLSTATE_NONE = 0;
    	var FILLSTATE_SHEET = 1;
    	var fillState = FILLSTATE_NONE;

    	
        // 리스트박스 상수 선언부
        var LISTBOX_TYPE_OLDSINGSELECT = 0;
        var LISTBOX_TYPE_SINGSELECT    = 1;
        var LISTBOX_TYPE_MULTISELECT   = 2;
        var LISTBOX_TYPE_CHECKSELECT   = 3;
        var LISTBOX_TYPE_DATASELECT    = 4;
        
        // 시트채우기 모드
        var DATALISTBOX_SETITEM = 1;
        var DATALISTBOX_SETDATA = 2;
        
        // 데이터 저장 구분
        var LISTBOX_SAVE_SINGLE = 0;
        var LISTBOX_SAVE_MULTI  = 1;
        
        // ===== Timer Start  ====
    	var TIMER_DISPLAY_NONE = 0;			// 표시 없음
    	var TIMER_DISPLAY_USERTEXT = 1;		// 산식결과
    	var TIMER_DISPLAY_IMAGEURL = 2;		// 이미지
    	var TIMER_DISPLAY_TIMELEFT = 3;		// 남은시간 표시
    	var TIMER_DISPLAY_CURRTIME = 4;		// 현재시간 표시
        // =====  Timer End   ====
/**
 * @description	미결
 * @param		{Number}	pValue
 * @param		{Number}	pValue1
 * @returns		{Undefined}
 * @example		미결
 */
function alert2(pValue, pValue1) {
	if (navigator.userLanguage == "ko") {
		alert(pValue);
	} else {
		alert(pValue1);
	}
};

/**
 * @description	미결
 * @param		{String}	pStr
 * @returns		{Boolean}
 * @example		미결
 */
function CheckNumeric(pStr) {
	var wStr = "" + pStr;
	var Pos = 0;
	var wChar = ' ';
	var wHiponCount = 0;
	var wDotCount = 0;

	for (Pos = 0; Pos < wStr.length; ++Pos) {
		wChar = wStr.charAt(Pos);
		if (wChar < '0' || wChar > '9')
			continue;

		if (wChar == ".") {
			wDotCount++;
			if (wDotCount > 1) {
				return false;
			}
		}
		if (wChar == "-") {
			wHiponCount++;
			if (wHiponCount > 1) {
				return false;
			} else if (wHiponCount == 1 && wDotCount > 0) {
				return false;
			}
		}
	}
	return true;
};

/**
 * @description	미결
 * @param		{String}	pStr
 * @returns		{Boolean}
 * @example		미결
 */
function CheckAlpabetic(pStr) {
	var wStr = "" + pStr;
	var Pos = 0;
	var wChar = ' ';

	for (Pos = 0; Pos < wStr.length; ++Pos) {
		wChar = wStr.charAt(Pos);
		if ((wChar < 'A' || wChar > 'Z') && (wChar < 'a' || wChar > 'z'))
			return false;
	}
	return true;
};

/**
 * @description	미결
 * @param		{String}	pStr
 * @returns		{Boolean}
 * @example		미결
 */
function CheckDate(pStr) {
	var wStr = pStr;
	
//	var wArr = wStr.split("-"); // 먼저 하이폰 문자열을 없엔다
//	wStr = wArr.join("");
//	
//	for (var i = 0; i < wStr.length; ++i) { // 숫자만 가능하다
//		if (wStr[i] < "0" || (wStr[i]) > "9")
//			return false;
//	}
	
	//체크할 값이 문자열이 아닌 경우 문자열로 변환
	wStr = (typeof wStr == "string") ? wStr : ("" + wStr);
	//일반적으로 날짜 표시형식으로 사용되는 '.', '/', '-' 제거
	wStr = wStr.replace(/[-./]/g, "");
	
	// 길이가 8자 이어야 한다
	if( wStr.length != 8 )		return false;
	
	//숫자만 가능
	if( !/^[0-9]+$/.test(wStr) )return false;

	//년도 체크
	var wYY = parseFloat(1 * wStr.substring(0, 4));
	if( wYY < 1900 )			return false;
	
	//월 체크
	var wMM = parseFloat(1 * wStr.substring(4, 6));
	if( wMM < 1 || wMM > 12 )	return false;
	
	//일자범위 체크
	var wDD = parseFloat(1 * wStr.substring(6, 8));
	
	if( wDD < 01 || wDD > 31 )	return false;
	
	switch (wMM) {
	case 4:
	case 6:
	case 9:
	case 11:
		if( wDD > 30 )			return false;
		break;
	case 2:
		if( wYY % 4 == 0 && wDD > 29 )	return false;	//윤달 체크
		if( wYY % 4 != 0 && wDD > 28 )	return false;
		break;
	}
	
	return true;
};

/**
 * @description	미결
 * @param		{String}	pStr
 * @returns		{Boolean}
 * @example		미결
 */
function CheckMonth(pStr) {
	var wStr = pStr;
	
//	var wArr = wStr.split("-"); // 먼저 하이폰 문자열을 없엔다
//	wStr = wArr.join("");
//	
//	for(var i = 0; i < wStr.length; ++i) { // 숫자만 가능하다
//		if (wStr[i] < "0" || (wStr[i]) > "9")
//			return false;
//	}
	
	//체크할 값이 문자열이 아닌 경우 문자열로 변환
	wStr = (typeof wStr == "string") ? wStr : ("" + wStr);
	//일반적으로 날짜 표시형식으로 사용되는 '.', '/', '-' 제거
	wStr = wStr.replace(/[-./]/g, "");
	
	//길이가 6자 이어야 한다
	if( wStr.length != 6 )		return false;
	
	//숫자만 가능
	if( !/^[0-9]+$/.test(wStr) )	return false;
	
	//년도 체크
	var wYY = parseFloat(1 * wStr.substring(0, 4));
	if( wYY < 1900 )			return false;
	
	//월 체크
	var wMM = parseFloat(1 * wStr.substring(4, 6));
	if( wMM < 1 || wMM > 12 )	return false;
	
	return true;
};

/**
 * @description	미결
 * @param		{String}	pStr
 * @returns		{Boolean}
 * @example		미결
 */
function CheckYear(pStr) {
	var str = pStr || "0";
	
	if( parseInt(str) < 1997 || parseInt(str) > 2020 )
		return false;
	
	return true;
};
/**
 * @description	미결
 * @param		{String}	pStr
 * @returns		{Boolean}
 * @example		미결
 */
function CheckTime(pStr) {
	var wStr = pStr;

	var wArr = wStr.split(":"); // 먼저 콜론 문자열을 없엔다
	wStr = wArr.join("");

	if (wStr.length != 4) // 길이가 4자 이어야 한다
		return false;

	for (var i = 0; i < wStr.length; ++i) { // 숫자만 가능하다
		if (wStr[i] < "0" || (wStr[i]) > "9")
			return false;
	}

	var wHH = parseFloat(1 * wStr.substring(0, 2));
	if (wHH < 0 || wHH > 23) // 시간체크
		return false;

	var wMN = parseFloat(1 * wStr.substring(2, 4));
	if (wMN < 0 || wMN > 59) // 분체크
		return false;
	return true;
};
/**
 * @description	미결
 * @param		{String}	pStr
 * @returns		{String}
 * @example		미결
 */
// 한글은 입력할 수 없습니다 를 표시하기 위해
function hasHangul(pStr) {
	var pattern = /^[a-zA-Z0-9\-_.@\s%`~!#$\^&\*\(\)\+='",:;\|?\/<>\[\]\{\}\\]+$/;
	return !pattern.test(pStr);
};

/**
 * @description	미결
 * @param 		{number}	pStr
 * @return		{Object}
 * @example		미결
 */
function isAlNum(pStr) {
	var pattern = /^[A-Za-z0-9]+$/;
	return pattern.test(pStr);
};
/**
 * @description	미결
 * @param 		{String}	pStr
 * @return		{Object}
 * @example		미결
 */
function isAlpha(pStr) {
	var pattern = /^[a-zA-Z]+$/;
	return pattern.test(pStr);
};
/**
 * @description	미결
 * @param 		{number}	pStr
 * @return		{Object}
 * @example		미결
 */
function isDigit(pStr) {
	var pattern = /^[0-9]+$/;
	return pattern.test(pStr);
};
/**
 * @description	미결
 * @param 		{Object}	pStr
 * @return		{Object}
 * @example		미결
 */
function IsDigit(pStr) {
	return isDigit(pStr);
};
/**
 * @description	미결
 * @param 		{String}	varObj
 * @return		{Object}
 * @example		미결
 */
function isValidObject(varObj) {
	return (varObj != null && typeof varObj != "undefined");
	
//	if (typeof varObj != "undefined") {
//		return true;
//	}
//	return true;
};

/**
 * @description	미결
 * @param		{String}	s
 * @returns		{Boolean}
 * @example		미결
 */
function IsResidentNumber(s){
	var wStr = s;
	
//	wStr = wStr.split("-").join("").split(" ").join("");
	
	//입력 파라메터가 문자열이 아닌 경우 문자열로 형변환
	wStr = (typeof wStr == "string") ? wStr : ("" + wStr);
	//주민등록번호에서 '-'을 제거
	wStr = wStr.replace(/[-]/, "");

	//자리수 체크
	if( wStr.length != 13 )		return false;
	//'-'을 지웠으므로 숫자만 남아있어야 함
	if( /^[0-9].$/.test(wStr) )	return false;
	
	//주민등록번호 검사
	var target1 = parseInt(wStr.substring(0, 1)) * 2;
	target1 = target1 + parseInt(wStr.substring(1, 2)) * 3;
	target1 = target1 + parseInt(wStr.substring(2, 3)) * 4;
	target1 = target1 + parseInt(wStr.substring(3, 4)) * 5;
	target1 = target1 + parseInt(wStr.substring(4, 5)) * 6;
	target1 = target1 + parseInt(wStr.substring(5, 6)) * 7;
	target1 = target1 + parseInt(wStr.substring(6, 7)) * 8;
	target1 = target1 + parseInt(wStr.substring(7, 8)) * 9;
	target1 = target1 + parseInt(wStr.substring(8, 9)) * 2;
	target1 = target1 + parseInt(wStr.substring(9, 10)) * 3;
	target1 = target1 + parseInt(wStr.substring(10, 11)) * 4;
	target1 = target1 + parseInt(wStr.substring(11, 12)) * 5;

	var target2 = parseInt(target1 / 11);
	var target3 = target2 * 11;

	target1 = target1 - target3;
	target1 = 11 - target1;
	target1 = target1 % 10;
	
	//검사결과 체크
	if( parseInt(wStr.substring(12)) != target1 )
		return false;
	
	return true;
};

/**
 * @description	미결
 * @param		{String}	s
 * @returns		{Boolean}
 * @example		미결
 */
function IsTaxNumber(s) {
//	s = s.replaceWord("-", "");
//	s = s.replaceWord(" ", "");
//
//	if (!CheckNumeric(s))
//		return false;
//	if (s.length != 10)
//		return false;
	
	var wStr = s;
	
	//입력 파라메터가 문자열이 아닌 경우 문자열로 형변환
	wStr = (typeof wStr == "string") ? wStr : ("" + wStr);
	//'-'과 공백 문자 제거
	wStr = wStr.replace(/[- ]/g, "");
	
	//'-'과 공백 문자를 지웠으므로 숫자만 남아있어야 함
	if( /^[0-9]+$/.test(wStr) )	return false;
	//자리수 체크
	if( wStr.length != 10 )		return false;
	
	//사업자등록번호 검사
	var v = (1 * (parseInt(wStr.substring(0, 1)))) % 10;
	v = v + (3 * (parseInt(wStr.substring(1, 2)))) % 10;
	v = v + (7 * (parseInt(wStr.substring(2, 3)))) % 10;
	v = v + (1 * (parseInt(wStr.substring(3, 4)))) % 10;
	v = v + (3 * (parseInt(wStr.substring(4, 5)))) % 10;
	v = v + (7 * (parseInt(wStr.substring(5, 6)))) % 10;
	v = v + (1 * (parseInt(wStr.substring(6, 7)))) % 10;
	v = v + (3 * (parseInt(wStr.substring(7, 8)))) % 10;
	v = v + parseInt((5 * (parseInt(wStr.substring(8, 9)))) / 10);
	v = v + (5 * (parseInt(wStr.substring(8, 9)))) % 10;
	v = parseInt(v / 10) * 10 - (v % 10);
	v = v % 10;

	if( parseInt(wStr.substring(9, 10)) != v )
		return false;
	
	return true;
};
/**
 * @description	미결
 * @param		{Number}	pKeyCode
 * @returns		{Boolean}
 * @example		미결
 */
function checkKeyAbs(pKeyCode) {

	if (pKeyCode == 13)
		return true; // 엔터
	if (pKeyCode >= 48 && pKeyCode <= 57)
		return true; // 키보드 상단 숫자
	if (pKeyCode >= 96 && pKeyCode <= 105)
		return true; // 숫자키보드 숫자
	if (pKeyCode == 189 || pKeyCode == 189)
		return true; // 마이너스
	if (pKeyCode == 107)
		return true; // 플러스
	if (pKeyCode == 16)
		return true; // 쉬프트
	if (pKeyCode == 8)
		return true; // 백스페이스
	if (pKeyCode == 37)
		return true; // 왼쪽방향키
	if (pKeyCode == 39)
		return true; // 오른쪽방향키
	if (pKeyCode == 46)
		return true; // Del키
	if (pKeyCode == 144)
		return true; // NumLock키

	return false;
};

/**
 * @description	미결
 * @param		{Number}	pKeyCode
 * @returns		{Boolean}
 * @example		미결
 */
function checkKeyInt(pKeyCode) {

	if (pKeyCode == 13)
		return true; // 엔터
	if (pKeyCode >= 48 && pKeyCode <= 57)
		return true; // 키보드 상단 숫자
	// if (pKeyCode>=96 && pKeyCode<=105) return true; //숫자키보드 숫자
	if (pKeyCode == 189 || pKeyCode == 189)
		return true; // 마이너스
	if (pKeyCode == 107)
		return true; // 플러스
	if (pKeyCode == 16)
		return true; // 쉬프트
	if (pKeyCode == 8)
		return true; // 백스페이스
	if (pKeyCode == 37)
		return true; // 왼쪽방향키
	if (pKeyCode == 39)
		return true; // 오른쪽방향키
	if (pKeyCode == 46)
		return true; // Del키
	if (pKeyCode == 144)
		return true; // NumLock키

	return false;
};

/**
 * @description	미결
 * @param		{Number}	pKeyCode
 * @returns		{Boolean}
 * @example		미결
 */
function checkKeyFloat(pKeyCode) {

	if (pKeyCode == 13)
		return true; // 엔터
	if (pKeyCode >= 48 && pKeyCode <= 57)
		return true; // 키보드 상단 숫자
	if (pKeyCode >= 96 && pKeyCode <= 105)
		return true; // 숫자키보드 숫자
	if (pKeyCode == 189 || pKeyCode == 189)
		return true; // 마이너스
	if (pKeyCode == 107)
		return true; // 플러스
	if (pKeyCode == 190)
		return true; // 점
	if (pKeyCode == 16)
		return true; // 쉬프트
	if (pKeyCode == 8)
		return true; // 백스페이스
	if (pKeyCode == 37)
		return true; // 왼쪽방향키
	if (pKeyCode == 39)
		return true; // 오른쪽방향키
	if (pKeyCode == 46)
		return true; // Del키
	if (pKeyCode == 144)
		return true; // NumLock키
	// if (pKeyCode==188 return true; //콤마
	
	return false;
};

/**
 * @description	미결
 * @param		{String}	pString
 * @param		{Number}	pLength
 * @returns		{String}
 * @example		미결
 */
function left(pString, pLength) {
	var wString = pString;
	var wReturn = wString.substring(0, pLength);
	
	wString = null;
	
	return wReturn;
};

/**
 * @description	미결
 * @param		{String}	pString
 * @param		{Number}	pLength
 * @returns		{String}
 * @example		미결
 */
function right(pString, pLength) {
	var wString = pString;
	var wlength = wString.length;
	var wReturn = wString.substring(wlength - pLength, wlength);
	
	wString = null;
	
	return wReturn;
};
/**
 * @description	미결
 * @param 		{String}	strString
 * @param		{String}	nIndex
 * @param		{number}	nSize
 * @return		{Object}
 * @example		미결
 */
function midB(strString, nIndex, nSize) { // nIndex는 1부터 시작
	var ndx = 0;
	var lastNdx = nIndex + nSize;
	var wReturn = "";

	var ndx0 = 0;
	var ndx1 = strString.length;

	for (var i = 0; i < this.length; i++) {
		ndx += (this.charCodeAt(i) > 127 ? 2 : 1);

		// 처음 시작점을 만나는 곳의 시작 인덱스 기록
		if (ndx0 == 0 && ndx >= nIndex)
			ndx0 = ndx;
		// 끝 인덱스를 벗어났으면 빠져나가고
		if (ndx >= lastNdx)
			break;

		// 이미 시작되었고 빠져 나가지 않은 상태이면 끝 인덱스 계속 기록
		if (ndx0 > 0)
			ndx1 = ndx;
	}

	return strString.substring(ndx0, ndx1);
};

/**
 * @description	미결
 * @param		{String}	pStr
 * @returns		{String}
 * @example		미결
 */
function trim(pStr) {
	var wStr = pStr;
	var StartPoint;
	var EndPoint;
	var Pos;

	StartPoint = -1;
	for (Pos = 0; Pos < wStr.length; ++Pos) {
		if (wStr.charAt(Pos) != " ") {
			StartPoint = Pos;
			break;
		}
	}

	if (StartPoint == -1)
		return "";

	for (Pos = wStr.length - 1; Pos >= 0; --Pos) {
		EndPoint = Pos;
		if (wStr.charAt(Pos) != " ")
			break;
	}
	return wStr.substring(StartPoint, EndPoint + 1);
};

/**
 * @description	미결
 * @param		{String}	pStr
 * @returns		{String}
 * @example		미결
 */
function RemoveBlank(pStr) {
	var wStr = pStr;
	var wArr = wStr.split(" "); // 먼저 스페이스 문자열을 없엔다

	wStr = wArr.join("");
	return wStr;
};

/**
 * @description	미결
 * @param		{String}	pExpression
 * @param		{String}	pFind
 * @param		{String}	pReplacement
 * @returns		{String}
 * @example		미결
 */
function replace(pExpression, pFind, pReplacement) {
	var wStr = pExpression;

	var wArr = wStr.split(pFind); // 먼저 찾을 문자열로 나눈다
	wStr = wArr.join(pReplacement);

	return wStr;
};
/**
 * @description	미결
 * @param 		{String}	strString
 * @param		{String}	strPadChar
 * @param		{number}	nCount
 * @return		{Object}
 * @example		미결
 */
function lPad(strString, strPadChar, nCount) {
	var len = (strString + "").length;
	var str = "";
	for (var i = len; i < nCount; i++)
		str += strPadChar;

	return str + strString;
};
/**
 * @description	미결
 * @param 		{String}	strString
 * @param		{String}	strPadChar
 * @param		{number}	nCount
 * @return		{Object}
 * @example		미결
 */
function rPad(strString, strPadChar, nCount) {
	var len = (strString +"").length;
	var str = "";
	for (var i = len; i < nCount; i++)
		str += strPadChar;

	return strString + str;
};

function RPad(strString, strPadChar, nCount) {
	return rPad(strString, strPadChar, nCount);
};

function Rpad(strString, strPadChar, nCount) {
	return rPad(strString, strPadChar, nCount);
};
/**
 * @description	미결
 * @param		{String}	pStr
 * @return		{number}
 * @example		미결
 */
function byteLength(pStr) {
	return pStr.byteLength();
};

/**
 * @description	미결
 * @param		{Number}	pValue
 * @param		{Number}	pLen
 * @returns		{Boolean}
 * @example		미결
 */
function IsRightLen(pValue, pLen) {
	var len = 0;
	var cnt;

	for (cnt = 0; cnt < pValue.length; cnt++) {
		len += 1;
		if (pValue.charCodeAt(cnt) > 255)
			len += 1;
	}

	if (len > pLen) {
		return false;
	} else {
		return true;
	}
};
/**
 * @description	미결
 * @param		{String}	n
 * @param		{number}	digits
 * @return		{number}
 * @example		미결
 */
function leadingZeros(n, digits) {
	var zero = '';
	
	n = "" + n;
	
	if( n.length < digits ){
		for( i = 0; i < digits - n.length; i++ )
			zero += '0';
	}
	
	return zero + n;
};

function inSplit() {
	/* [사용법]
	 * inSplit("team1,manager,acsh,dtsh,cmsh", ",", "manager")
	 * inSplit("team1,manager,acsh,dtsh,cmsh", ",", "manager|acsh", "|")
	 * inSplit("team1,manager,acsh,dtsh,cmsh", ",", ["manager","acsh"])
	 * inSplit(["team1","manager","acsh","dtsh","cmsh"], "manager")
	 * inSplit(["team1","manager","acsh","dtsh","cmsh"], "manager,acsh", ",")
	 * inSplit(["team1","manager","acsh","dtsh","cmsh"], ["manager","acsh"])
	 * */
	var args = Array.prototype.slice.call(arguments);
	var argCnt = args.length;
	var target = null;	var targetSeperator = null;
	var keyVal = null;	var keyValSeperator = null;
	var isValidArg = true;
	
	try{
		if( argCnt < 2 ){
			isValidArg = false;
		}
		else{
			target = args[0];			
			
			if( typeof target == "string" ){
				targetSeperator = args[1];
				
				switch(argCnt){
				case 3: keyVal = args[2]; break;
				case 4:	keyVal = args[2]; keyValSeperator = args[3]; break;
				default: isValidArg = false;
				}
			}
			else if( target instanceof Array ){
				switch(argCnt){
				case 2: keyVal = args[1]; break;
				case 3: keyVal = args[1]; keyValSeperator = args[2]; break;
				default: isValidArg = false;
				}
			}
			else
				isValidArg = false;
		}
		// 예외처리
		if( !isValidArg ){
			//함수 인자 오류 메세지 출력
			try{ keyVal.clear(); } catch(e){} keyVal = null; keyValSeperator = null;
			try{ target.clear(); } catch(e){} target = null; targetSeperator = null; args = null;
			return isValidArg;
		}
		
		var keyValSize = 0;
		var isExist = false;
		var i = 0;
		
		if( typeof target == "string" ){
			target = target.split(targetSeperator);
		}
		if( !(keyVal instanceof Array) ){
			if( typeof keyVal == "string" && typeof keyValSeperator != "undefined" )
				keyVal = keyVal.split(keyValSeperator);
			else
				keyVal = [keyVal];
		}
		
		for(i = 0, keyValSize = keyVal.length; i < keyValSize; i++)
			isExist = (target.indexOf(keyVal[i]) >= 0);
	}
	catch(e){
		isExist = false;
	}
	
	//메모리 해제
	try{ keyVal.clear(); } catch(e){} keyVal = null; keyValSeperator = null;
	try{ target.clear(); } catch(e){} target = null; targetSeperator = null; args = null;
	
	return isExist;
};

/**
 * @description	미결
 * @returns		{String}
 * @example		미결
 */
String.prototype.startsWith = function() {
	var wTarget = arguments[0];
	var wReturn = this.substring(0, wTarget.length) == wTarget;
	return wReturn;
};

/**
 * @description	미결
 * @returns		{String}
 * @example		미결
 */
String.prototype.endsWith = function() {
	var wTarget = arguments[0];
	var wReturn = this.substring(this.length - wTarget.length) == wTarget;
	return wReturn;
};

/**
 * @description	미결
 * @returns		{Object}
 * @example		미결
 */
// trim함수 만들기
String.prototype.trim = function() {
	return this.replace(/(^\s*)|(\s*$)/g, "");
};

/**
 * @description	미결
 * @returns		{Object}
 * @example		미결
 */
String.prototype.ltrim = function() {
	return this.replace(/(^\s*)/g, "");
};

/**
 * @description	미결
 * @returns		{Object}
 * @example		미결
 */
String.prototype.rtrim = function() {
	return this.replace(/(\s*$)/g, "");
};

/**
 * @description	미결
 * @returns		{Number}
 * @example		미결
 */
String.prototype.byteLength = function() {
	var cnt = 0;
	for (var i = 0; i < this.length; i++) {
		if (this.charCodeAt(i) > 127)
			cnt += 2;
		else
			cnt++;
	}
	return cnt;
};

/**
 * @description	미결
 * @returns		{Object}
 * @example		미결
 */
String.prototype.num = function() {
	return (this.trim().replace(/[^0-9]/g, ""));
};

/**
 * @description	미결
 * @returns		{Object}
 * @example		미결
 */
String.prototype.money = function() {
	var num = this.trim();
	while ((/(-?[0-9]+)([0-9]{3})/).test(num)) {
		num = num.replace((/(-?[0-9]+)([0-9]{3})/), "$1,$2");
	}
	return num;
};

/**
 * @description	미결
 * @param		{Number}	rowNum
 * @returns		{Boolean}
 * @example		미결
 */
String.prototype.isBlank = function() {
	var str = this.trim();
	for (var i = 0; i < str.length; i++) {
		if ((str.charAt(i) != "\t") && (str.charAt(i) != "\n")
				&& (str.charAt(i) != "\r")) {
			return false;
		}
	}
	return true;
};

/**
 * @description	미결
 * @param		{String}	pattern
 * @returns		{String}
 * @example		미결
 */
String.prototype.remove = function(pattern) {
	if (pattern == null)
		return this;

	var regExp = new RegExp(pattern, "g");

	return this.replace(regExp, "");
};

/**
 * @description	미결
 * @returns		{Object}
 * @example		미결
 */
String.prototype.isNum = function() {

	return (/^(\d|-)?(\d|,)*\.?\d*$/).test(this.remove(arguments[0]));
};

/**
 * @description	미결
 * @returns		{Boolean}
 * @example		미결
 */
String.prototype.isEng = function() {
	return (/^[a-zA-Z]+$/).test(this.remove(arguments[0])) ? true : false;
};

/**
 * @description	미결
 * @returns		{Boolean}
 * @example		미결
 */
String.prototype.isEngNum = function() {
	return (/^[0-9a-zA-Z]+$/).test(this.remove(arguments[0])) ? true : false;
};

/**
 * @description	미결
 * @returns		{String}
 * @example		미결
 */
String.prototype.isNumEng = function() {
	return this.isEngNum(arguments[0]);
};

/**
 * @description	미결
 * @returns		{Boolean}
 * @example		미결
 */
String.prototype.isUserid = function() {
	return (/^[a-zA-z]{1}[0-9a-zA-Z]+$/).test(this.remove(arguments[0])) ? true : false;
};

/**
 * @description	미결
 * @returns		{Boolean}
 * @example		미결
 */
String.prototype.isCorpnum = function() {
	var arg = arguments[0] || "";

	var regExp = new RegExp("^[0-9]{6}" + arg + "[0-9]{7}$", "g");
	// if(this.match(regExp) == null) return false;
	if (regExp.test(this))
		return false;

	var corpnum = this.remove("-");
	var num = [ 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2 ];
	var sum = 0;
	var last = parseInt(corpnum.charAt(12));
	for (var i = 0; i < 12; i++) {
		sum += parseInt(corpnum.charAt(i)) * num[i];
	}
	
	return ((10 - sum % 10) % 10 == last) ? true : false;
};

/**
 * @description	미결
 * @returns		{Object}
 * @example		미결
 */
String.prototype.isEmail = function() {
	return (/\w+([-+.]\w+)*@\w+([-.]\w+)*\.[a-zA-Z]{2,4}$/).test(this.trim());
};

/**
 * @description	미결
 * @returns		{Object}
 * @example		미결
 */
String.prototype.isPhone = function() {
	var arg = arguments[0] || "";
	var regExp = new RegExp("^(02|0[3-9]{1}[0-9]{1})" + arg
			+ "[1-9]{1}[0-9]{2,3}" + arg + "[0-9]{4}$", "g");

	return regExp.test(this);
};

/**
 * @description	미결
 * @returns		{Object}
 * @example		미결
 */
String.prototype.isMobile = function() {
	var arg = arguments[0] ? arguments[0] : "";
	var regExp = new RegExp("^01[016789]" + arg + "[1-9]{1}[0-9]{2,3}" + arg + "[0-9]{4}$", "g");

	return regExp.test(this);
};

/**
 * @description	미결
 * @param		{Number}	len
 * @returns		{String}
 * @example		미결
 */
String.prototype.cut = function(len) {
	var str = this;
	var l = 0;
	for (var i = 0; i < str.length; i++) {
		l += (str.charCodeAt(i) > 128) ? 2 : 1;
		if (l > len)
			return str.substring(0, i) + "...";
	}
	return str;
};

/**
 * @description	미결
 * @returns		{String}
 * @example		미결
 */
String.prototype.bytes = function() {
	var str = this;
	var l = 0;
	for (var i = 0; i < str.length; i++)
		l += (str.charCodeAt(i) > 128) ? 2 : 1;
	return l;
};

/**
 * @description	미결
 * @param		{String}	pattern
 * @param		{String}	toWord
 * @returns		{Object}
 * @example		미결
 */
String.prototype.replaceWord = function(pattern, toWord) {
	var wMask = pattern || "";
	var wToWord = toWord || "";

	wMask = wMask.replace(/\\/g, "<XXXxxx>");
	wMask = wMask.replace(/\+/g, "\\+");
	wMask = wMask.replace(/\$/g, "\\$");
	wMask = wMask.replace(/\^/g, "\\^");
	wMask = wMask.replace(/\./g, "\\.");
	wMask = wMask.replace(/\(/g, "\\(");
	wMask = wMask.replace(/\)/g, "\\)");
	wMask = wMask.replace(/\[/g, "\\[");
	wMask = wMask.replace(/\]/g, "\\]");
	wMask = wMask.replace(/\{/g, "\\{");
	wMask = wMask.replace(/\}/g, "\\}");
	wMask = wMask.replace(/\*/g, "\\*");
	wMask = wMask.replace(/\?/g, "\\?");
	wMask = wMask.replace(/<XXXxxx>/g, "\\\\");

	var re = new RegExp(wMask, "g");

	return this.replace(re, wToWord);
};

/**
 * @description	미결
 * @returns		{Object}
 * @example		미결
 */
String.prototype.toRegExpMask = function() {
	var wMask = this + "";

	wMask = wMask.replace(/\\/g, "<XXXxxx>");
	wMask = wMask.replace(/\+/g, "\\+");
	wMask = wMask.replace(/\$/g, "\\$");
	wMask = wMask.replace(/\^/g, "\\^");
	wMask = wMask.replace(/\./g, "\\.");
	wMask = wMask.replace(/\(/g, "\\(");
	wMask = wMask.replace(/\[/g, "\\[");
	wMask = wMask.replace(/\]/g, "\\]");
	wMask = wMask.replace(/\{/g, "\\{");
	wMask = wMask.replace(/\}/g, "\\}");
	wMask = wMask.replace(/\*/g, "\\*");
	wMask = wMask.replace(/\?/g, "\\?");
	wMask = wMask.replace(/<XXXxxx>/g, "\\\\");

	return wMask;
};

/**
 * @description	미결
 * @param		{String}	pattern
 * @returns		{Object}
 * @example		미결
 */
String.prototype.matchWord = function(pattern) {
	var regExp = new RegExp(pattern.toRegExpMask(), "g");
	return (regExp.test(this));
};

/**
 * @description	미결
 * @param		{String}	pattern
 * @returns		{String}
 * @example		미결
 */
String.prototype.mask = function(pattern) {
	return mask(this, pattern);
};

/**
 * @description	미결
 * @param		{String}	o
 * @returns		{STring}
 * @example		미결
 */
function isString(o) {
	return Object.prototype.toString.call(o) == '[object String]';
};

/**
 * @description	미결
 * @returns		{String}
 * @example		미결
 */
Number.prototype.trim = function() {
	return (this + "").trim();
};

/**
 * @description	미결
 * @returns		{String}
 * @example		미결
 */
Number.prototype.length = function() {
	return (this + "").length;
};

/**
 * @description	미결
 * @param		start
 * @param		end
 * @returns		{String}
 * @example		미결
 */
Number.prototype.substring = function(start, end) {
	var wStr = this + "";
	if (end == undefined)
		end = wStr.length;
	return wStr.substring(start, end);
};

/**
 * @description	미결
 * @param		nIndex
 * @param		nSize
 * @returns		{String}
 * @example		미결
 */
Number.prototype.substr = function(nIndex, nSize) {
	var strString = this + "";

	var ndx = 0;
	var lastNdx = nIndex + nSize;
	var wReturn = "";

	var ndx0 = 0;
	var ndx1 = strString.length;

	for (var i = 0; i < this.length; i++) {
		ndx += (this.charCodeAt(i) > 127 ? 2 : 1);

		// 처음 시작점을 만나는 곳의 시작 인덱스 기록
		if (ndx0 == 0 && ndx >= nIndex)
			ndx0 = ndx;
		// 끝 인덱스를 벗어났으면 빠져나가고
		if (ndx >= lastNdx)
			break;

		// 이미 시작되었고 빠져 나가지 않은 상태이면 끝 인덱스 계속 기록
		if (ndx0 > 0)
			ndx1 = ndx;
	}

	return strString.substring(ndx0, ndx1);
};

/**
 * @description	미결
 * @param		pattern
 * @param		toWord
 * @returns		{String}
 * @example		미결
 */
Number.prototype.replace = function(pattern, toWord) {
	return (this + "").replace(pattern, toWord);
};

/**
 * @description	미결
 * @returns		{Void}
 * @example		미결
 */
Array.prototype.Clear = function() {
	return this.clear();
};

/**
 * @description	미결
 * @returns		{Void}
 * @example		미결
 */
Array.prototype.clear = function() {
	for(var i = this.length - 1; i >= 0; i--){
		if( this[i] != null && this[i].Clear ) this[i].Clear();
		this[i] = null;
		this.pop();
	}
	
	return;
};

/**
 * @description	미결
 * @param		pArray
 * @returns		{Boolean}
 * @example		미결
 */
Array.prototype.EqualTo = function(pArray) {
	if (this.length != pArray.length)
		return false;

	var wReturn = true;
	for (var i = 0; i < this.length; i++) {
		wReturn = wReturn && (this[i] == pArray[i]);
	}

	return wReturn;
};

if (!Array.prototype.indexOf) {
	Array.prototype.indexOf = function(elt /* , from */) {
		var wReturn = -1;
		var from = Number(arguments[1]) || 0;

		for (var i = from; i < this.length; i++) {
			if (this[i] === elt) {
				wReturn = i;
				break;
			}
		}
		return wReturn;
	};
}

/**
 * @description	미결
 * @param		keyStr
 * @returns		{Boolean}
 * @example		미결
 */
Array.prototype.hasKey = function(keyStr) {
	var wReturn = false;
	for ( var key in this) {
		if (key == keyStr) {
			wReturn = true;
			break;
		}
	}
	return wReturn;
};

/**
 * @description	미결
 * @param		{String}	o
 * @returns		{String}
 * @example		미결
 */
function isArray(o) {
	return Object.prototype.toString.call(o) == '[object Array]';
};

/**
 * @description	미결
 * @param		{String}	pArray1
 * @param		{String}	pArray2
 * @returns		{Boolean}
 * @example		미결
 */
// 둘중 작은 배열의 길이를 기준으로 비교한다
function compareArray(pArray1, pArray2) {
	var length = (pArray1.length < pArray2.length ? pArray1.length
			: pArray2.length);
	var wReturn = 0;
	for (var i = 0; i < length; i++) {
		if (pArray1[i] == pArray2[i]) {
			continue;
		} else if (pArray1[i] > pArray2[i]) {
			wReturn = 1;
			break;
		} else if (pArray1[i] < pArray2[i]) {
			wReturn = -1;
			break;
		}
	}

	return wReturn;
};

/**
 * @description	미결
 * @param		{String}	parentArray
 * @param		{String}	pArray
 * @returns		{String}
 * @example		미결
 */
// 사용방법
// searchArray(배열의 상위배열, 찿을배열, 시작인덱스, 끝인덱스
function searchArray(parentArray, pArray) {
	var lastIndex = parentArray.length - 1;
	if (lastIndex < 0) return null;
	
	if (compareArray(parentArray[lastIndex], pArray) == 0) {
		return parentArray[lastIndex];
	}
	if (compareArray(parentArray[0], pArray) == 0) {
		return parentArray[0];
	}

	return searchSubarray(parentArray, pArray, 1, parentArray.length - 2);
};

/**
 * @description	미결
 * @param		{String}	parentArray
 * @param		{String}	pArray
 * @param		{Number}	startIndex
 * @param		{Number}	lastIndex
 * @returns		{String}
 * @example		미결
 */
function searchSubarray(parentArray, pArray, startIndex, lastIndex) {
	// startIndex > lastIndex 이면 무한루핑을 방지 한다
	if (startIndex > lastIndex)
		return null;

	var index = Math.floor((lastIndex - startIndex) / 2) + startIndex;
	var compareResult = compareArray(parentArray[index], pArray);

	if (compareResult < 0) { // 앞에 것이 크면
		return searchSubarray(parentArray, pArray, index + 1, lastIndex);
	} else if (compareResult > 0) {
		return searchSubarray(parentArray, pArray, startIndex, index - 1);
	}

	return parentArray[index];
};
/**
 * @description	미결
 * @param		{String}	arr
 * @return		{number}
 * @example		미결
 */
function getAssociativeArrayLength(arr) {
	var key = null;
	var cnt = 0;

	if( !(arr instanceof Array) )
		return -1;

	for(key in arr){
		if( typeof arr[key] == "function" ) continue;
		cnt++;
	}
	
	key = null;
	
	return cnt;
};

/**
 * @description	미결
 * @param		{String}	pValue
 * @param		{String}	formatStr
 * @returns		{String}
 * @example		미결
 */
function mask(pValue, formatStr, formatRound) {
	if( typeof format == "function" ){
		return format("" + pValue, formatStr, formatRound);
	}

	var wIsNumeric = false;
	var wReturn = "";
	var wDigitPos = 0;

	if (typeof (pValue) == "number") {
		pValue = "" + pValue;
	}

	if (pValue == "")
		return "";

	if (formatStr.length > 1
			&& (formatStr.substring(formatStr.length - 1, formatStr.length) == "0"
					|| formatStr.substring(formatStr.length - 1,
							formatStr.length) == "#" || formatStr.substring(
					formatStr.length - 1, formatStr.length) == "%")) {
		wIsNumeric = true;
	}

	// 숫자인 경우 소수점이하 자릿수를 맞추어 준다. 이상태에서 소숫점 을 없애준다
	if (wIsNumeric) {
		// 포멧 소수점의 위치
		var dotPosOfFormat = formatStr.indexOf(".");
		// 포멧 소수점이후 자릿수
		var countAfterDotOfFormat = (dotPosOfFormat < 0 ? 0 : formatStr.length
				- dotPosOfFormat - 1);

		var dotPosOfValue = pValue.indexOf(".");
		var countAfterDotOfValue = pValue.length - dotPosOfValue - 1;

		// 퍼센트
		if (formatStr.substr(formatStr.length - 1, formatStr.length) == "%")
			countAfterDotOfFormat += -1;

		if (countAfterDotOfFormat > 0) {
			var num = parseFloat(pValue);
			var n = num.toFixed(countAfterDotOfFormat);

			pValue = "" + n;
			var formatLength = formatStr.length;

			for (var i = 0; i < countAfterDotOfFormat; i++) {
				if (formatStr.charAt(formatLength - 1 - i) == '#'
						&& pValue.charAt(pValue.length - 1) == '0') {
					pValue = pValue.substring(0, pValue.length - 1);
					formatStr = formatStr.substring(0, formatStr.length - 1);
				} else {
					break;
				}
			}

			if (pValue.charAt(pValue.length - 1) == '.') {
				pValue = pValue.substring(0, pValue.length - 1);
				formatStr = formatStr.substring(0, formatStr.length - 1);
			}
		} else {
			var num = parseFloat(pValue);
			var n = num.toFixed();

			pValue = "" + n;
		}

		pValue = pValue.replace(/\./g, "");

		// 소수점이하 자리가 맞은 상태에서 아래 로직 동작

		wDigitPos = pValue.length - 1;
		for (var i = formatStr.length - 1; i >= 0; i--) {
			if (formatStr.charAt(i) == "0") {
				if (wDigitPos >= 0) {
					wReturn = pValue.charAt(wDigitPos) + wReturn;
				} else {
					wReturn = "0" + wReturn;
				}
				wDigitPos--;
			} else if (formatStr.charAt(i) == "#") {
				if (wDigitPos >= 0) {
					wReturn = pValue.charAt(wDigitPos) + wReturn;
				}
				wDigitPos--;
			} else if (formatStr.charAt(i) == ".") {
				if (wDigitPos >= 0) {
					wReturn = "." + wReturn;
				}
			} else if (formatStr.charAt(i) == ",") {
				if (wDigitPos >= 0) {
					if (pValue.charAt(wDigitPos) != '-')
						wReturn = "," + wReturn;
				}
			} else if (formatStr.charAt(i) == "+") {
				wReturn = "+" + wReturn;
			} else if (formatStr.charAt(i) == "-") {
				wReturn = "-" + wReturn;
			} else if (formatStr.charAt(i) == "/") {
				wReturn = "/" + wReturn;
			} else if (formatStr.charAt(i) == "$") {
				wReturn = "$" + wReturn;
			} else if (formatStr.charAt(i) == "%") {
				wReturn = wReturn + "%";
			} else {
				wReturn = formatStr.charAt(i) + wReturn;
			}
		}

		if (wDigitPos >= 0) {
			wReturn = pValue.substring(0, wDigitPos + 1) + wReturn;
		}
		// 표시형식이 .으로 끝난경우 제거해준다
		if (wReturn.charAt(wReturn.length - 1) == ".") {
			wReturn = wReturn.substring(0, wReturn.length - 1);
		}

		var pattern = /^[-#,.]+$/;
		if (wReturn == "0" && pattern.test(formatStr))
			wReturn = "";

	} else {
		wDigitPos = 0;
		for (var i = 0; i < formatStr.length; i++) {
			if (formatStr.charAt(i) == "@") {
				if (wDigitPos >= 0) {
					wReturn += pValue.charAt(wDigitPos);
				} else {
					wReturn += " ";
				}
				wDigitPos++;
			} else if (formatStr.charAt(i) == "&") {
				if (wDigitPos >= 0) {
					wReturn += pValue.charAt(wDigitPos);
				}
				wDigitPos++;
			} else {
				wReturn += formatStr.charAt(i);
			}
		}
		if (wDigitPos < pValue.length) {
			wReturn += pValue.substring(0, wDigitPos);
		}
	}

	return wReturn;
};

/**
 * @description	미결
 * @param		{String}	pValue
 * @param		{String}	format
 * @returns		{String}	
 * @example		미결
 */
function maskIn(pValue, format) {
	var wIsNumeric = false;
	var wReturn = "";
	var wDigitPos = 0;
	if (typeof (pValue) == "number") {
		pValue = "" + pValue;
	}
	if (pValue == "")
		return "";

	if (format.length > 1
			&& (format.substring(format.length - 1, format.length) == "0" || format
					.substring(format.length - 1, format.length) == "#")) {
		wIsNumeric = true;
	}

	if (wIsNumeric) {
		wDigitPos = pValue.length - 1;
		for (var i = format.length - 1; i >= 0; i--) {
			if (format.charAt(i) == "0") {
				if (wDigitPos >= 0) {
					wReturn = pValue.charAt(wDigitPos) + wReturn;
				} else {
					wReturn = "0" + wReturn;
				}
				wDigitPos--;
			} else if (format.charAt(i) == "#") {
				if (wDigitPos >= 0) {
					wReturn = pValue.charAt(wDigitPos) + wReturn;
				}
				wDigitPos--;
			} else if (format.charAt(i) == ".") {
				if (wDigitPos >= 0) {
					wReturn = "." + wReturn;
				}
			} else if (format.charAt(i) == ",") {
				if (wDigitPos >= 0) {
					if (pValue.charAt(wDigitPos) != '-')
						wReturn = "," + wReturn;
				}
			} else if (format.charAt(i) == "+") {
				wReturn = "+" + wReturn;
			} else if (format.charAt(i) == "-") {
				wReturn = "-" + wReturn;
			} else if (format.charAt(i) == "/") {
				wReturn = "/" + wReturn;
			} else if (format.charAt(i) == "$") {
				wReturn = "$" + wReturn;
			} else {
				wReturn = format.charAt(i) + wReturn;
			}
			if (wDigitPos < 0)
				break;
		}

		if (wDigitPos >= 0) {
			wReturn = pValue.substring(0, wDigitPos) + wReturn;
		}

	} else {
		wDigitPos = 0;
		for (var i = 0; i < format.length; i++) {
			if (format.charAt(i) == "@") {
				if (wDigitPos >= 0) {
					wReturn += pValue.charAt(wDigitPos);
				} else {
					wReturn += " ";
				}
				wDigitPos++;
			} else if (format.charAt(i) == "&") {
				if (wDigitPos >= 0) {
					wReturn += pValue.charAt(wDigitPos);
				}
				wDigitPos++;
			} else {
				wReturn += format.charAt(i);
			}
			if (wDigitPos >= pValue.length)
				break;
		}
		if (wDigitPos < pValue.length) {
			wReturn += pValue.substring(0, wDigitPos);
		}
	}
	return wReturn;
};
/**
 * @description	미결
 * @param 		{number}	num
 * @param		{number}	underDecimalCount
 * @return		{Object}
 * @example		미결
 */
function numFormat(num, underDecimalCount) {
	var str = "" + num;
	
	str += (str.indexOf(".") < 0 ? "." : "") + "00000000000000000000000000000000000000000000000000000000000000";
	
	var lastNdx = str.indexOf(".") + ((typeof underDecimalCount != "undefined") ? underDecimalCount + 1 : 0);

	return str.substring(0, lastNdx);
};

/**
 * @description	미결
 * @param		{String}	pValue
 * @param		{String}	formatStr
 * @returns		{String}
 * @example		미결
 */
//날짜타입 포멧 함수 (지홍 추가)
function calendarMask(pValue, formatStr) {
	if (formatStr == null || formatStr == undefined)
		formatStr = "";

	// 숫자타입이 아닌경우 숫자만 추출한다.
	if (typeof (pValue) == "number") {
		pValue = "" + pValue;
	} else {
		var numArr = pValue.match(/\d+/g);
		var numArrLength = numArr.length;
		pValue = "";
		for (var i = 0; i < numArrLength; i++) {
			pValue += numArr[i];
		}
	}
	// 빈값일 경우 리턴
	if (pValue == "")
		return "";

	formatStr = formatStr.toLowerCase();
	var wReturn = formatStr;

	var Y = formatStr.match(/y+/g);
	var M = formatStr.match(/m+/g);
	var D = formatStr.match(/d+/g);
	var A = formatStr.match(/a+/g);
	var year = pValue.substring(0, 4);
	var month = pValue.substring(4, 6);
	var day = pValue.substring(6, 8);
	var value = "";
	var replaceValue = "";

	var EngMonth = {
			'01mmmm' : "January", '02mmmm' : "February", '03mmmm' : "March", '04mmmm' : "Aprill", '05mmmm' : "May", '06mmmm' : "June", '07mmmm' : "July", '08mmmm' : "August", '09mmmm' : "September", '10mmmm' : "October", '11mmmm' : "November", '12mmmm' : "December",
			'01mmm' : "Jan", '02mmm' : "Feb", '03mmm' : "Mar", '04mmm' : "Apr", '05mmm' : "May", '06mmm' : "Jun", '07mmm' : "Jul", '08mmm' : "Aug", '09mmm' : "Sep", '10mmm' : "Oct", '11mmm' : "Nov", '12mmm' : "Dec",
			'01mmmmm' : "J", '02mmmmm' : "F", '03mmmmm' : "M", '04mmmmm' : "A", '05mmmmm' : "M", '06mmmmm' : "J", '07mmmmm' : "J", '08mmmmm' : "A", '09mmmmm' : "S", '10mmmmm' : "O", '11mmmmm' : "N", '12mmmmm' : "D"
	};
	var EngWeek = {
			'0dddd' : "Sunday", '1dddd' : "Monday", '2dddd' : "Tuesday", '3dddd' : "Wenesday", '4dddd' : "Thursday", '5dddd' : "Friday", '6dddd' : "Saturday",
			'0ddd' : "Sun", '1ddd' : "Mon", '2ddd' : "Tue", '3ddd' : "Wen", '4ddd' : "Thu", '5ddd' : "Fri", '6ddd' : "Sat"
	};
	var HanWeek = { 
			'0aaaa' : "일요일", '1aaaa' : "월요일", '2aaaa' : "화요일", '3aaaa' : "수요일", '4aaaa' : "목요일", '5aaaa' : "금요일", '6aaaa' : "토요일",
			'0aaa' : "일", '1aaa' : "월", '2aaa' : "화", '3aaa' : "수", '4aaa' : "목", '5aaa' : "금", '6aaa' : "토"
	};

	// year 치환
	for (var i = 0; i < (Y != null ? Y.length : 0); i++) {
		if (Y[i].length > 2)
			wReturn = wReturn.replace(/y+/, year);
		else if (Y[i].length > 0)
			wReturn = wReturn.replace(/y+/, year.substring(2, 4));
	}
	// month 치환
	for (var i = 0; i < (M != null ? M.length : 0); i++) {
		value = M[i];
		if (M[i].length > 5)
			M[i] = "mmmm";
		if (M[i].length > 2) {
			wReturn = wReturn.replace(value, month == "" ? "" : EngMonth[month
					+ M[i]]);
		} else if (M[i].length > 0) {
			replaceValue = month;
			if (M[i].length == 1)
				replaceValue = month * 1;
			wReturn = wReturn.replace(value, replaceValue);
		}
	}
	// day 치환
	for (var i = 0; i < (D != null ? D.length : 0); i++) {
		value = D[i];
		if (D[i].length > 3)
			D[i] = "dddd";
		if (D[i].length > 2) {
			var date = new Date(year, month - 1, day);
			wReturn = wReturn.replace(value, day == "" ? "" : EngWeek[date
					.getDay()
					+ D[i]]);
		} else if (D[i].length > 0) {
			replaceValue = day;
			if (D[i].length == 1)
				replaceValue = day * 1;
			wReturn = wReturn.replace(value, replaceValue);
		}
	}
	// aaa 치환
	for (var i = 0; i < (A != null ? A.length : 0); i++) {
		value = A[i];
		if (A[i].length > 3)
			A[i] = "aaaa";
		if (A[i].length > 2) {
			var date = new Date(year, month - 1, day);
			wReturn = wReturn.replace(value, day == "" ? "" : HanWeek[date
					.getDay()
					+ A[i]]);
		}
	}

	return wReturn;
};

/**
 * @description	미결
 * @param		{String}	pValue
 * @param		{Object}	pMask
 * @returns		{String}	
 * @example		미결
 */
function restoreDateFormatValue(pValue, pMask) {
	pMask = pMask.replace(/-/g, "");
	pMask = pMask.replace(/,/g, "");
	pMask = pMask.replace(/:/g, "");
	pMask = pMask.replace(/\+/g, "");
	pMask = pMask.replace(/\*/g, "");
	pMask = pMask.replace(/\?/g, "");
	pMask = pMask.replace(/\./g, "");
	pMask = pMask.replace(/\//g, "");
	pMask = pMask.replace(/\|/g, "");
	pMask = pMask.replace(/\(/g, "");
	pMask = pMask.replace(/\)/g, "");
	pMask = pMask.replace(/\{/g, "");
	pMask = pMask.replace(/\}/g, "");
	pMask = pMask.replace(/\[/g, "");
	pMask = pMask.replace(/\]/g, "");
	
	if (pMask.indexOf("YYYY") >= 0)
		pMask = pMask.replace(/YYYY/g, "");
	if (pMask.indexOf("YY") >= 0)
		pMask = pMask.replace(/YY/g, "");
	if (pMask.indexOf("MM") >= 0)
		pMask = pMask.replace(/MM/g, "");
	if (pMask.indexOf("mm") >= 0)
		pMask = pMask.replace(/mm/g, "");
	if (pMask.indexOf("DD") >= 0)
		pMask = pMask.replace(/DD/g, "");
	if (pMask.indexOf("dd") >= 0)
		pMask = pMask.replace(/dd/g, "");
	if (pMask.indexOf("Hh") >= 0)
		pMask = pMask.replace(/Hh/g, "");
	if (pMask.indexOf("hh") >= 0)
		pMask = pMask.replace(/hh/g, "");
	if (pMask.indexOf("Nn") >= 0)
		pMask = pMask.replace(/Nn/g, "");
	if (pMask.indexOf("nn") >= 0)
		pMask = pMask.replace(/nn/g, "");
	if (pMask.indexOf("Ss") >= 0)
		pMask = pMask.replace(/Ss/g, "");
	if (pMask.indexOf("ss") >= 0)
		pMask = pMask.replace(/ss/g, "");
	if (pMask.indexOf("WK") >= 0)
		pValue = pValue.replace(/[월화수목금토일]요일/g, "");
	if (pMask.indexOf("wk") >= 0)
		pValue = pValue.replace(/[월화수목금토일]/g, "");

	var ch = null;

	for(var i = 0; i < pMask.length; i++, ch = null){
		ch = pMask.charAt(i);
		eval("pValue = \"" + pValue + "\".replace( /" + ch + "/g, \"\")");
	}

	return pValue;
};

/**
 * @description	미결
 * @param		{String}	pStart
 * @param		{Number}	pAddCount
 * @returns		{String}	
 * @example		미결
 */
function dayAdd(pStart, pAddCount) {
	var wTemp = pStart.replace(/\-/g, "");
	
	var wYear = parseInt(wTemp.substring(0, 4), 10);
	var wMonth = parseInt(wTemp.substring(4, 6), 10) - 1;
	var wDate = parseInt(wTemp.substring(6, 8), 10);

	var d = new Date(wYear, wMonth, wDate);
	// var numb=Date.parse(d);
	d.setTime(d.getTime() + (pAddCount * 1000 * 60 * 60 * 24));

	var wReturn = ""
			+ d.getFullYear()
			+ (d.getMonth() < 9 ? "0" + (d.getMonth() + 1) : (d.getMonth() + 1)
					+ '')
			+ (d.getDate() < 10 ? "0" + d.getDate() : d.getDate() + '');

	return wReturn;
};

/**
 * 입력된 날자에 OffSet 으로 지정된 만큼의 날짜를 더하는 함수
 * 
 * AddDate(date); AddDate(date,nOffSet);
 * 
 * @param date
 *            'yyyyMMdd' 형태로 표현된 날자.
 * @param nOffSet
 *            날짜로부터 증가 감소값. 지정하지 않으면 [Default Value = 1] 로 적용
 * @return (String)
 */
function addDate(date, nOffSet) { // Mi: AddDate
	if (nOffSet == undefined)
		nOffSet = 1;

	if (date.length == 7) {
		date = date.substring(0, 7) + "0" + date.substring(7);
	}

	return dayAdd(date, nOffSet);
};

/**
 * @description	미결
 * @param		{String}	yyyymm
 * @param		{Number}	x
 * @returns		{String}	
 * @example		미결
 */
function monthAdd(yyyymm, x) {
	if (typeof yyyymm == "undefined" || yyyymm == "")
		return "";

	yyyymm = yyyymm.replace(/[-/]/g, "");

	if (!(yyyymm.match(/^[0-9]*$/))) {
		// alert("날짜는 숫자와 -, / 만 허용됩니다.");
		return "";
	}

	if (isNaN(x * 1)) {
		// alert("날짜 연산이 불가능한 값입니다.");
		return "";
	}

	var stdYear = "";
	var stdMonth = "";
	var stdDay = "";

	if ((yyyymm + "").trim().length == 6) {
		stdYear = (yyyymm + "").substring(0, 4);
		stdMonth = (yyyymm + "").substring(4, 6);
		stdDay = "01";
	} else if ((yyyymm + "").trim().length == 8) {
		stdYear = (yyyymm + "").substring(0, 4);
		stdMonth = (yyyymm + "").substring(4, 6);
		stdDay = (yyyymm + "").substring(6, 8);
	} else {
		// alert("년월일 또는 년월 형식으로만 계산이 가능합니다.");
		return "";
	}

	var dt = new Date(stdYear * 1, ((stdMonth * 1) - 1) + x, stdDay * 1);
	var resYear = dt.getFullYear();
	var resMonth = dt.getMonth() + 1;
	resMonth = (resMonth < 10) ? "0" + resMonth : resMonth;

	return resYear + "" + resMonth;
};

/**
 * 입력된 날자에 OffSet 으로 지정된 만큼의 달을 더하는 Basic API 입니다.
 * 
 * AddMonth(pStart); AddMonth(date,nOffSet);
 * 
 * @param pStart
 *            'yyyyMMdd' 형태로 표현된 날자.
 * @param nOffSet
 *            날짜로부터 증가 감소값. 지정하지 않으면 [Default Value = 1] 로 적용
 * @return (String)
 */
function addMonth(pStart, nOffSet) { // Mi: AddMonth
	if (nOffSet == undefined)
		nOffSet = 1;

	var wTemp = pStart.replace(/\-/g, "");
	if (wTemp.length == 7) {
		wTemp = wTemp.substring(0, 7) + "0" + wTemp.substring(7);
	}

	var wYear = parseInt(wTemp.substring(0, 4), 10);
	var wMonth = parseInt(wTemp.substring(4, 6), 10);
	var wDate = parseInt(wTemp.substring(6, 8), 10);

	// wYear += parseInt((wMonth + nOffSet) / 12);
	// wMonth += (wMonth + nOffSet) % 12;
	//	
	// var wDate0 = lastDay(wYear, wMonth);
	// wDate = (wDate > wDate0 ? wDate0 : wDate);
	//	
	// return "" + wYear + (wMonth < 10 ? "0" : "") + wMonth + (wDate < 10 ? "0"
	// : "") + wDate;

	var wYearOff = parseInt(nOffSet / 12);
	var wMonthOff = parseInt(nOffSet % 12);

	wYear = wYear + wYearOff;
	wMonth = wMonth + wMonthOff;
	
	var lastDay = (new Date(wYear, wMonth, 0)).getDate();
	wDate = (wDate < lastDay) ? wDate : lastDay;

	var resultDate = new Date(wYear, wMonth - 1, wDate);
	
	wYear = resultDate.getFullYear() * 1;
	wMonth = (resultDate.getMonth() + 1) * 1;
	wDate = resultDate.getDate() * 1;

	return "" + (wYear) + ((wMonth < 10) ? "0" + wMonth : wMonth)
			+ ((wDate < 10) ? "0" + wDate : wDate);
};

/**
 * @description	미결
 * @param		{Number}	pDay
 * @returns		{String}
 * @example		미결
 */
function DateString(pDay) {
	var wDate = pDay;
	var wYear= wDate.getFullYear();
	var wMonth = wDate.getMonth() + 1;
	var wDay = wDate.getDate();

	var rtnStr = "" + wYear;

	if (wMonth < 10) {
		rtnStr = rtnStr + "0" + wMonth;
	} else {
		rtnStr = rtnStr + wMonth;
	}
	if (wDay < 10) {
		rtnStr = rtnStr + "0" + wDay;
	} else {
		rtnStr = rtnStr + wDay;
	}

	return rtnStr;
};

/**
 * @description	미결
 * @param		{Number}	pDay
 * @returns		{String}
 * @example		미결
 */
function TimeString(pDay) {
	var wDate = pDay;
	var wHour = wDate.getHours();
	var wMinute = wDate.getMinutes();
	var wSecond = wDate.getSeconds();

	var rtnStr = "";

	if (wHour < 10) {
		rtnStr = rtnStr + "0" + wHour;
	} else {
		rtnStr = rtnStr + wHour;
	}
	if (wMinute < 10) {
		rtnStr = rtnStr + "0" + wMinute;
	} else {
		rtnStr = rtnStr + wMinute;
	}
	if (wSecond < 10) {
		rtnStr = rtnStr + "0" + wSecond;
	} else {
		rtnStr = rtnStr + wSecond;
	}

	return rtnStr;
};
/**
 * @description	미결
 * @return		{number}
 * @example		미결
 */
function getDate() {
	var d = new Date();
	var s = ""
			//년도(4자리) + 월(2자리) + 일(2자리)
			+ leadingZeros(d.getFullYear(), 4) + leadingZeros(d.getMonth() + 1, 2) + leadingZeros(d.getDate(), 2)
			//시,시간(2자리) + 분(2자리) + 초(2자리)
			+ leadingZeros(d.getHours(), 2) + leadingZeros(d.getMinutes(), 2) + leadingZeros(d.getSeconds(), 2);
	d = null; //메모리 해제
	
	return s;
};

/**
 * @description	미결
 * @return		{number}
 * @example		미결
 */
function now() {
	var nowDate = new Date();
	var now = "";
	now += nowDate.getFullYear() + "";
	now += ((nowDate.getMonth() + 1) < 10 ? "0" : "")
			+ (nowDate.getMonth() + 1);
	now += (nowDate.getDate() < 10 ? "0" : "") + nowDate.getDate();
	now += (nowDate.getHours() < 10 ? "0" : "") + nowDate.getHours();
	now += (nowDate.getMinutes() < 10 ? "0" : "") + nowDate.getMinutes();
	now += (nowDate.getSeconds() < 10 ? "0" : "") + nowDate.getSeconds();

	return now;
};

/**
 * 입력된 날자에 OffSet 으로 지정된 만큼의 달을 더하는 Basic API 입니다.
 * 
 * DateTime(nYear,nMonth,nDay);
 * DateTime(nYear,nMonth,nDay,nHour,nMinute,nSecond); DateTime(strDate);
 * DateTime(dDate);
 * 
 * @return (Date)
 */
function dataTime() {
	var args = Array.prototype.slice.call(arguments);
	
	if (args.length.length == 6) {
		return new Date(parseInt(args[0]), parseInt(args[1]), parseInt(args[2]), parseInt(args[3]), parseInt(args[4]), parseInt(args[5]), 0);
	} else if (args.length.length == 3) {
		return new Date(parseInt(args[0]), parseInt(args[1]), parseInt(args[2]));
	} else if (args.length.length == 1) {
		if (args[0] instanceof String) {
			var str = args[0].replace(/\-/g, "");
			
			var yyyy = (str.length > 0 ? parseInt(str.substring(0, 4)) : 0);
			var mm = (str.length > 0 ? parseInt(str.substring(4, 6)) : 0);
			var dd = (str.length > 0 ? parseInt(str.substring(6, 8)) : 0);
			var hh = (str.length > 0 ? parseInt(str.substring(8, 10)) : 0);
			var nn = (str.length > 0 ? parseInt(str.substring(10, 12)) : 0);
			var ss = (str.length > 0 ? parseInt(str.substring(12, 14)) : 0);
			
			str = null;

			return new Date(yyyy, mm, dd, hh, nn, ss, 0);

		} else if (args[0] instanceof Number) { // 숫자인 경우 1900년 1월1일 0시 이후의 일수를 더한다
			var days = args[0];
			var wDate = new Date("0000-01-01");
			
			wDate.setDate(wDate.getDate() + days)

			return wDate;
		}
	}
	
	return new Date();
};

/**
 * @description	미결
 * @param		{Number}	pintYY
 * @param		{Number}	pintMM
 * @returns		{Number}	
 * @example		미결
 */
function lastDay(pintYY, pintMM){
	return (new Date(pintYY, pintMM, 0)).getDate();
};
/**
 * @description	미결
 * @param 		{number}	str
 * @return		{number}
 * @example		미결
 */
function getDay(str) {
	var wTemp = str.replace(/\-/g, "");
	
	var yyyy = (wTemp.length >= 4 ? parseInt(wTemp.substring(0, 4)) : 0);
	var mm = (wTemp.length >= 6 ? parseInt(wTemp.substring(4, 6)) - 1 : 0);
	var dd = (wTemp.length >= 8 ? parseInt(wTemp.substring(6, 8)) : 0);
	var hh = (wTemp.length >= 10 ? parseInt(wTemp.substring(8, 10)) : 0);
	var nn = (wTemp.length >= 12 ? parseInt(wTemp.substring(10, 12)) : 0);
	var ss = (wTemp.length >= 14 ? parseInt(wTemp.substring(12, 14)) : 0);
	
	return new Date(yyyy, mm, dd, hh, nn, ss, 0).getDay();
};

/**
 * @description	미결
 * @param		{String}	date
 * @param		{String}	isFull
 * @returns		{String}	
 * @example		미결
 */
function getWeekCharacter(date, isFull){
	if ((date + "").trim().length < 8)
		return "";

	date = date.replace(/\-/g, "");
	isFull = (isFull + "").toUpperCase();
	var year = date.substring(0, 4) * 1;
	var month = (date.substring(4, 6) * 1) - 1;
	var day = date.substring(6, 8) * 1;
	var dt = new Date(year, month, day);
	var week = "";

	switch (dt.getDay()) {
	case 0:
		week = (isFull == "S") ? "일" : "일요일";
		break;
	case 1:
		week = (isFull == "S") ? "월" : "월요일";
		break;
	case 2:
		week = (isFull == "S") ? "화" : "화요일";
		break;
	case 3:
		week = (isFull == "S") ? "수" : "수요일";
		break;
	case 4:
		week = (isFull == "S") ? "목" : "목요일";
		break;
	case 5:
		week = (isFull == "S") ? "금" : "금요일";
		break;
	case 6:
		week = (isFull == "S") ? "토" : "토요일";
		break;
	default:
		week = "";
	}

	return week;
};

/**
 * @description	미결
 * @param		{Object}	target
 * @param		{String}	arrFromStrings
 * @param		{String}	arrToStrings
 * @returns		{String}	
 * @example		미결
 */
function escapeCharacter(target, arrFromStrings, arrToStrings) {
	var wReturn = ""+target;
	for (var i = 0; i < arrFromStrings.length; i++) {
		if (wReturn.indexOf(arrFromStrings[i]))
			wReturn = wReturn.replaceWord(arrFromStrings[i], arrToStrings[i]);
	}
	return wReturn;

};

/**
 * @description	미결
 * @param 		{number}	millisecond
 * @return	 	{String}
 * @example		미결
 */
function timeEncodeString(millisecond) {
	var scnds = millisecond || (new Date()).getTime();
	var strs = [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "Q", "W",
			"E", "R", "T", "Y", "U", "I", "O", "P", "A", "S", "D", "F", "G",
			"H", "J", "K", "L", "Z", "X", "C", "V", "B", "N", "M" ];
	var dgit = strs.length;
	var wReturn = "";

	while (scnds > 0) {
		wReturn += strs[scnds % dgit];
		scnds = Math.floor(scnds / dgit);
	}
	
	while (wReturn.length < 8)
		wReturn += "0";
	
	if (wReturn.length > 8)
		wReturn = wReturn.substring(0, 8);

	return "[" + wReturn + "_)";
};

/**
 * @description	미결
 * @param 		{String}	text
 * @return 		{Object}
 * @example		미결
 */
function timeDecodeString(text) {
	return (text.length > 11 && text.startsWith("[") && text.indexOf("_)") >= 0 ? text.substring(11) : text);
};
/**
 * @description	미결
 * @param 		{String}	text
 * @return 		{Object}
 * @example		미결
 */
function hasTimeEncodeString(text) {
	return (text.length > 11 && text.startsWith("[") && text.indexOf("_)") == 9);
};

/**
 * @description	미결
 * @param 		{Object}	tagObject
 * @return 		{Object}
 * @example		미결
 */
function getComputedStyleSize(tagObject) {
	return (window.getComputedStyle(tagObject) ? window.getComputedStyle(tagObject) : tagObject.style);
};

/**
 * @description	미결
 * @param 		{Object}	tagObject
 * @return 		{Object}
 * @example		미결
 */
function getStyle(tagObject) {
	return getComputedStyleSize(tagObject);
};

function getStyleProp(el, prop){
	if( getComputedStyle !== 'undefined' ){
		return getComputedStyle(el, null).getPropertyValue(prop);
	}
	else{
		return el.currentStyle[prop];
	}
	
	return null;
};

/**
 * @description	미결
 * @param		{Object}	em
 * @param 		{Object}	tagObject
 * @return 		{number}
 * @example		미결
 */
function getItemIndex(em, tagName) {
	var index = -1;
	var parentEm = em.parentNode;
	
	if( parentEm.hasChildNodes() ){
		for (var i = 0; i < parentEm.childNodes.length; i++) {
			var wEm = parentEm.childNodes[i];
			if (wEm.tagName == undefined)
				continue;

			if (wEm.tagName.toUpperCase() == tagName.toUpperCase())
				index++;
			if (em == wEm)
				break;
		}
	}

	return index;
};

// 화면상 객체의 위치 찾기
/*
 * 사용방법 : var obj = getBoundsObject(btn); alert(obj.top + ' ' + obj.left + ' ' +
 * obj.width + ' ' + obj.height);
 */
/**
 * @description	미결
 * @param 		{Object}	obj
 * @return 		{Object}
 * @example		미결
 */
function getBoundsObject(obj) {
	/*
	 * var locations = new Object();
	 * if (obj != null && obj != undefined) { if (obj.getBoundingClientRect) {
	 * //IE, FF3 var rect = obj.getBoundingClientRect(); locations.left =
	 * rect.left + (document.documentElement.scrollLeft ||
	 * document.body.scrollLeft); locations.top = rect.top +
	 * (document.documentElement.scrollTop || document.body.scrollTop);
	 * locations.width = rect.right - rect.left; locations.height = rect.bottom -
	 * rect.top + 1; } else if (document.getBoxObjectFor) { // gecko 엔진 기반 FF3제외
	 * var boxObjectFor = document.getBoxObjectFor(obj); locations.left =
	 * boxObjectFor.x; locations.top = boxObjectFor.y; locations.width =
	 * boxObjectFor.width; locations.height = boxObjectFor.height; } else {
	 * locations.left = obj.offsetLeft; locations.top = obj.offsetTop;
	 * locations.width = obj.offsetWidth; locations.height = obj.offsetHeight +
	 * 3;
	 * 
	 * var parent = obj.offsetParent;
	 * 
	 * if (parent != obj) { while (parent) { locations.left +=
	 * parent.offsetLeft; locations.top += parent.offsetTop; parent =
	 * parent.offsetParent; } }
	 *  // 오페라와 사파리의 'absolute' postion의 경우 body의 offsetTop을 잘못 계산 보정 var ua =
	 * navigator.userAgent.toLowerCase();
	 * 
	 * if (ua.indexOf('opera') != -1 || (ua.indexOf('safari') != -1 &&
	 * getStyle(obj, 'position') == 'absolute')) { locations.top -=
	 * document.body.offsetTop; }
	 *  } return locations; }
	 */
	
	var locations = {};

	if (obj != null && obj != undefined) {
		var rect = obj.getBoundingClientRect();

		locations.left = rect.left + (document.documentElement.scrollLeft || document.body.scrollLeft);
		locations.top = rect.top + (document.documentElement.scrollTop || document.body.scrollTop);
		locations.width = rect.right - rect.left;
		locations.height = rect.bottom - rect.top;
		
		rect = null;
	}

	return locations;
};

function getOffsetLeft(elem){
	var offsetLeft = 0;
	
	do{	if( !isNaN(elem.offsetLeft) ){
			offsetLeft += elem.offsetLeft;
		}
	}while(elem = elem.offsetParent);
	
	return offsetLeft;
};

function getOffsetTop(elem){
	var offsetTop = 0;

	do{	if( !isNaN(elem.offsetTop) ){
			offsetTop += elem.offsetTop;
		}
	}while(elem = elem.offsetParent);

	return offsetTop;
};

/**
 * @description	미결
 * @param 		{String}	where
 * @param 		{Object}	obj
 * @param 		{String}	insertHtml
 * @example		미결
 */
function insertAdjacentElement(where, obj, insertHtml) {
	// var range = document.createRange();
	// var docFragmentToInsert = range.createContextualFragment (insertHtml);
	var docFragmentToInsert = insertHtml;

	switch (where) {
	case "beforeBegin":
		obj.parentNode.insertBefore(docFragmentToInsert, obj);
		break;
	case "afterBegin":
		obj.insertBefore(docFragmentToInsert, obj.firstChild);
		break;
	case "beforeEnd":
		obj.appendChild(docFragmentToInsert);
		break;
	case "afterEnd":
		if (obj.nextSibling)
			obj.parentNode.insertBefore(docFragmentToInsert, obj.nextSibling);
		else
			obj.parentNode.appendChild(docFragmentToInsert);
		break;
	}
};

/**
 * @description	미결
 * @param		{object}	tagObject
 * @returns		{Undefined}	
 * @example		미결
 */
function removeTag(tagObject) {
	if (tagObject.parentNode)
		tagObject.parentNode.removeChild(tagObject);
};
/**
 * @description	미결
 * @return		{number}
 * @example		미결
 */
function decode() {
	var args = Array.prototype.slice.call(arguments);
	var retVal = null;

	if (args.length < 3)
		return retVal;

	var stdVal = args[0];
	var argsLength = args.length;
	for (var i = 1; i < argsLength - 1; i = i + 2) {
		if (args[i] === stdVal)
			return args[i + 1];
	}

	if ((argsLength - 1) % 2 == 1) {
		retVal = args[args.length - 1];
	}

	return retVal;
};

/**
 * @description	미결
 * @param 		{String}	strSize
 * @return 		{String}
 * @example		미결
 */
function parseIntSize(strSize) {
	if (strSize.length > 2 && strSize.substring(strSize.length - 2, strSize.length) == "px") {
		strSize = strSize.substring(0, strSize.length - 2);
	} else if (strSize.length > 2 && strSize.substring(strSize.length - 2, strSize.length) == "pt") {
		strSize = strSize.substring(0, strSize.length - 2);
	}
	
	return parseInt(strSize);
};
/**
 * @description	미결
 * @param 		{number}	varDate
 * @return		{number}
 * @example		미결
 */
function parseDateTime(varDate) {
	var wDate = null;
	if (typeof varDate === "string") {
		// wDate = getDay(varDate);
		varDate = varDate.replace(/[/-\s:]/g, "");
		
		var yyyy = (varDate.length >= 4 ? parseInt(varDate.substring(0, 4)) : 0);
		var mm = (varDate.length >= 6 ? parseInt(varDate.substring(4, 6)) - 1 : 0);
		var dd = (varDate.length >= 8 ? parseInt(varDate.substring(6, 8)) : 0);
		var hh = (varDate.length >= 10 ? parseInt(varDate.substring(8, 10)) : 0);
		var nn = (varDate.length >= 12 ? parseInt(varDate.substring(10, 12)) : 0);
		var ss = (varDate.length >= 14 ? parseInt(varDate.substring(12, 14)) : 0);
		
		wDate = new Date(yyyy, mm, dd, hh, nn, ss, 0);
	} else if (typeof varDate === "number") {
		if (varDate > 10000000 && varDate < 99999999) {
			wDate = getDay("" + varDate);
		} else {
			wDate = new Date("0000-01-01")
			wDate.setDate(wDate.getDate() + varDate)
		}
	}
	
	return wDate;
};

//사용방법 makeEventHandler("Sheet_1", "ColChange", "colNumFrom", "colNumTo");
/**
 * @description	미결
 * @param		{String}	control
 * @param		{String}	eventName
 * @return		{void}
 * @example		미결
 */
function makeEventHandler(control, eventName) {
	// functionname : [makeEventHandler]

	var strHungarian_EventName = eventName;
	var strLowerCase_EventName = eventName.toLowerCase();
	var strParamBuffer = "";

	var args = Array.prototype.slice.call(arguments);

	try {
		if (typeof DataSet == "function" && control instanceof DataSet) {
			control.controlId = control.id;
		}
	} catch (e) {
	}

	for (var i = 2; i < args.length; i++) {
		strParamBuffer += (i == 2 ? "" : ", ") + args[i];
	}
	control["has" + strHungarian_EventName + "Event"] = false;
	control["fnc" + strHungarian_EventName + "Event"] = null;

	try {
		if (eval(control.controlId
				+ (eventName.substring(0, 3).toUpperCase() == "CAN" ? "_"
						: "_on") + strLowerCase_EventName))

			control["has" + strHungarian_EventName + "Event"] = true;

	} catch (e) {
	}
	if (control["has" + strHungarian_EventName + "Event"]) {
		control["fnc" + strHungarian_EventName + "Event"] = eval(control.controlId
				+ (eventName.substring(0, 3).toUpperCase() == "CAN" ? "_"
						: "_on") + strLowerCase_EventName);
	}

	return;
};

if( typeof Math.trunc == "undefined" ){
	Math.trunc = function(value) {
		return ((value + "").replace(/,/g, "").match(/^\d*/) * 1);
	};
};

//정규식 문자열 ESCAPE
//예: var regex= new RegExp(RegExp.escape("[Munees]waran"));
if(typeof RegExp.escape == "undefined"){
	RegExp.escape = function(str) {
		var specials = [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\' ];
		
		if (!arguments.callee.sRE) {
			arguments.callee.sRE = new RegExp('(\\' + specials.join('|\\') + ')', 'gim');
		}
		
		return str.replace(arguments.callee.sRE, '\\$1');
	};
};

if( typeof Object.equals == "undefined" ){
	Object.equals = function(x, y) {
		if( x === y ) return true;
		
		if( !(x instanceof Object) || !(y instanceof Object) )
			return false;
		
		if( x.constructor !== y.constructor )
			return false;
		
		var p = null;
		
		for(p in x){
			if( !x.hasOwnProperty(p) )
				continue;
			if( !y.hasOwnProperty(p) )
				return false;
			if( x[p] === y[p] )
				continue;
			if( !Object.equals(x[p], y[p]) )
				return false;
		}
		
		for(p in y){
			if( y.hasOwnProperty(p) && !x.hasOwnProperty(p) )
				return false;
		}
		
		return true;
	};
};

if (typeof Object.assign != 'function') {
	  // Must be writable: true, enumerable: false, configurable: true
	  Object.defineProperty(Object, "assign", {
	    value: function assign(target, varArgs) { // .length of function is 2
	      'use strict';
	      if (target == null) { // TypeError if undefined or null
	        throw new TypeError('Cannot convert undefined or null to object');
	      }

	      var to = Object(target);

	      for (var index = 1; index < arguments.length; index++) {
	        var nextSource = arguments[index];

	        if (nextSource != null) { // Skip over if undefined or null
	          for (var nextKey in nextSource) {
	            // Avoid bugs when hasOwnProperty is shadowed
	            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
	              to[nextKey] = nextSource[nextKey];
	            }
	          }
	        }
	      }
	      return to;
	    },
	    writable: true,
	    configurable: true
	  });
	}
function cloneJSon(){
	return Object.assign({}, src);
};

/**
 * @description	미결
 * @return		{Object}
 * @example		미결
 */
function getContextPath() {
	var offset = location.href.indexOf(location.host) + location.host.length;
	var ctxPath = location.href.substring(offset, location.href.indexOf('/', offset + 1));
	
	return ctxPath;
};
/**
 * @description	미결
 * @param		{String}	paramKey
 * @param		{String}	isSearchParent
 * @return		{boolean}
 * @example		미결
 */
function IsExistVar(paramKey, isSearchParent) {
	var key = "";

	// 현재 창에서 파라메터 검사
	for (key in parameters) {
		if (typeof (parameters[key]) == "function")
			continue;
		// 파라메처 찾음
		if (key == paramKey)
			return true;
	}

	// 부모까지 검사
	if (isSearchParent) {
		var wd = null;
		// window.opener 검사
		wd = window.opener;
		while (wd != null) {
			var wdParameters = wd.parameters;
			// 파라메터 검사
			for (key in wdParameters) {
				if (typeof (wdParameters[key]) == "function")
					continue;
				// 파라메터 찾음
				if (key == paramKey)
					return true;
			}
			// 파라메터를 찾지 못한 경우 부모의 부모창을 다시 검사
			wd = wd.opener;
		}
		// window.parent 검사
		wd = window.parent;
		while (wd != null) {
			var wdParameters = wd.parameters;
			// 파라메터 검사
			for (key in wdParameters) {
				if (typeof (wdParameters[key]) == "function")
					continue;
				// 파라메터 찾음
				if (key == paramKey)
					return true;
			}
			// 부모와 자신 window 객체가 같다면 검사 안 함
			if (wd === wd.parent)
				break;
			// 파라메터를 찾지 못한 경우 부모의 부모창을 다시 검사
			else
				wd = wd.parent;
		}
	}

	// 리턴 : true(파라메터 존재함) / false(파라메터 존재하지 않음)
	return false;
};

/**
 * @description	미결
 * @param		{Number}	pWidth
 * @param		{Number}	pHeight
 * @param		{String}	pURL
 * @param		{String}	pName
 * @returns		{Void}
 * @example		미결
 */
function showDialogBox(pWidth, pHeight, pURL, pName) {
	var wTop = null;
	var wLeft = null;
	var WinCondition = null;
	
	wLeft = (self.screen.availWidth - 10 - pWidth) / 2;
	wTop = (self.screen.availHeight - 50 - pHeight) / 2;
	WinCondition = "toolbar=no," + "status=yes," + "alwaysRaised=yes," + "resizable=no," + "scrollbars=no,"
				 + "top=" + wTop + "px," + "left=" + wLeft + "px," + "width=" + pWidth + "px," + "height="+ pHeight + "px";
	
	open(pURL, pName + (new Date()).valueOf(), WinCondition);
	
	return;
};

function golink(em) {
	if (em.value == "") return;
	
	top.callForm(em.value, em.options[em.selectedIndex].text, em.options[em.selectedIndex].getAttribute("menuid"));
	
	em.value = "";
};

function callForm(systemFormID, title) {
	var url = "FlexForm_" + systemFormID + "_Load.do?t=" + encodeURI(encodeURIComponent(title));
	
	self.location.href = url;
};

function GetURLParameter(sParam) {
    var sPageURL = window.location.search.substring(1);
    var sURLVariables = sPageURL.split('&');
    for (var i = 0; i < sURLVariables.length; i++) {
        var sParameterName = sURLVariables[i].split('=');
        if (sParameterName[0] == sParam) {
            return sParameterName[1];
        }
    }
};

function loadScript(url, callback) {
	var script = document.createElement("script");
	script.type = "text/javascript";
	
	if(script.readyState) {
		if(script.readyState == 'loaded' || script.readyState == 'complete') {
			script.onreadystatechange = null;
			callback();
		}
	} else {
		script.onload = function() {
			callback();
		}
	}
	
	script.src = url;
	document.getElementsByTagName('head')[0].appendChild(script);
};var BrowserDetect = {
	init: function () {
		this.browser = this.searchString(this.dataBrowser) || "An unknown browser";
		this.version = this.searchVersion(navigator.userAgent)
			|| this.searchVersion(navigator.appVersion)
			|| "an unknown version";
		this.OS = this.searchString(this.dataOS) || "an unknown OS";
	},
	searchString: function (data) {
		for (var i=0;i<data.length;i++)	{
			var dataString = data[i].string;
			var dataProp = data[i].prop;
			this.versionSearchString = data[i].versionSearch || data[i].identity;
			if (dataString) {
				if (dataString.indexOf(data[i].subString) != -1)
					return data[i].identity;
			}
			else if (dataProp)
				return data[i].identity;
		}
		return true;
	},
	searchVersion: function (dataString) {
		var index = dataString.indexOf(this.versionSearchString);
		if (index == -1) return 0.0;
		return parseFloat(dataString.substring(index+this.versionSearchString.length+1));
	},
	dataBrowser: [
  		{
			string: navigator.userAgent,
			subString: "Trident",
			identity: "Explorer",
			versionSearch: " rv"
		},
		{
			string: navigator.userAgent,
			subString: "Edge",
			identity: "Explorer",
			versionSearch: " Edge"
		},
		{
			string: navigator.userAgent,
			subString: "Chrome",
			identity: "Chrome"
		},
		{ 	string: navigator.userAgent,
			subString: "OmniWeb",
			versionSearch: "OmniWeb/",
			identity: "OmniWeb"
		},
		{
			string: navigator.vendor,
			subString: "Apple",
			identity: "Safari",
			versionSearch: "Version"
		},
		{
			string: navigator.userAgent,
			subString: "Opera",
			prop: window.opera,
			identity: "Opera",
			versionSearch: "Version"
		},
		{
			string: navigator.vendor,
			subString: "iCab",
			identity: "iCab"
		},
		{
			string: navigator.vendor,
			subString: "KDE",
			identity: "Konqueror"
		},
		{
			string: navigator.userAgent,
			subString: "Firefox",
			identity: "Firefox"
		},
		{
			string: navigator.vendor,
			subString: "Camino",
			identity: "Camino"
		},
		{		// for newer Netscapes (6+)
			string: navigator.userAgent,
			subString: "Netscape",
			identity: "Netscape"
		},
		{
			string: navigator.userAgent,
			subString: "MSIE",
			identity: "Explorer",
			versionSearch: "MSIE"
		},
		{
			string: navigator.userAgent,
			subString: "Gecko",
			identity: "Mozilla",
			versionSearch: "rv"
		},
		{ 		// for older Netscapes (4-)
			string: navigator.userAgent,
			subString: "Mozilla",
			identity: "Netscape",
			versionSearch: "Mozilla"
		}
	],
	dataOS : [
		{
			string: navigator.platform,
			subString: "Win",
			identity: "Windows"
		},
		{
			string: navigator.platform,
			subString: "Mac",
			identity: "Mac"
		},
		{
			   string: navigator.userAgent,
			   subString: "iPhone",
			   identity: "iPhone/iPod"
	    },
		{
			string: navigator.platform,
			subString: "Linux",
			identity: "Linux"
		}
	]

};

var browserDetect = BrowserDetect;
browserDetect.init();

var isMobile = {
	    Android: function() {
	        return navigator.userAgent.match(/Android/i);
	    },
	    BlackBerry: function() {
	        return navigator.userAgent.match(/BlackBerry/i);
	    },
	    iOS: function() {
	        return navigator.userAgent.match(/iPhone|iPad|iPod/i);
	    },
	    Opera: function() {
	        return navigator.userAgent.match(/Opera Mini/i);
	    },
	    Windows: function() {
	        return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);
	    },
	    any: function() {
	        return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());
	    }
};    // 강제로 ASYNC가 일어날 상황
    var AJAX_ASYNCMODE_BYFORCE  = true;
    var AJAX_ASYNCMODE_RELEASE = false;
    var syncModeByForce = AJAX_ASYNCMODE_RELEASE;

    var request_aborted = false;
    /**
     * @description	미결
     * @returns 	{boolean}
     * @example		미결
     */
    function newXMLHttpRequest() {
	    var xmlreq = false;
	    if (window.XMLHttpRequest) {
	        xmlreq = new XMLHttpRequest();
	    } else if (window.ActiveXObject) {
	        try {
	            xmlreq = new ActiveXObject("Msxml2.XMLHTTP");
	        } catch (e1) {
	            try {
	                xmlreq = new ActiveXObject("Microsoft.XMLHTTP");
	            } catch (e2) {
	            }
	        }
	    }
	     
	    return xmlreq;
	};

	/**
	 * @description	미결
	 * @param 		{number}	req
	 * @param 		{Object}	pObject
	 * @param 		{Object}	pFlag
	 * @returns 	{undefined}
	 * @example		미결
	 */
    function getReadyStateHandler(req, pObject, pFlag) {

  	  return function () {
  		  
  		if (req == null || req == undefined) return;
  		
  		progressMessage(req.readyState);

  		if (req.readyState == 4) {
  	    	//hideAjaxBox();
            if (request_aborted){
            	var message = getText("message_ajax_105", "서버와의 통신이 원활하지 않습니다. \r\n 다시 시도해 주세요.");
            	pObject.parseData(null, message, pFlag);
            	request_aborted = false;
            	//if (parseFloat(navigator.appVersion.substring(navigator.appVersion.indexOf("MSIE")+5)) >= 8) req.abort();
            	
            	req.onreadystatechange = null;
            	req = null;
            	pObject = null;
            	pFlag = null;
            	
            	
            	hideAjaxBox();
                return;
            }
  	        if (req.status == 200) {
  	        	
  	            var wInfo = req.responseText;
  	            //window.clipboardData.setData("Text", wInfo);

                if (wInfo.trim().length == 0){
                	var message = getText("message_ajax_001", "서버에서 조회할 데이터가 없습니다.");
                	pObject.parseData(null, message, pFlag);
                	//if (parseFloat(navigator.appVersion.substring(navigator.appVersion.indexOf("MSIE")+5)) >= 8) req.abort();
                	
                	req.onreadystatechange = null;
                	req = null;
                	pObject = null;
                	pFlag = null;
                	
                	hideAjaxBox();
                    return;
                }
                
                if (pFlag.substring(0,4).toLowerCase() == "text"){
    				pObject.parseData(wInfo, null, pFlag);
                	
                } else {
                	try {
     				   var jsonActionObject =  eval( "(" + wInfo + ")" );
   				       pObject.parseData(jsonActionObject, null, pFlag);
                	} catch (e){
                		//alert("임시테스팅 메시지입니다. \n 테스트기간: 2/21~2/25\n\n" + wInfo);
                	}
               }
               //if (parseFloat(navigator.appVersion.substring(navigator.appVersion.indexOf("MSIE")+5)) >= 8) req.abort();

  	        } else {
            	var message = getAjaxStatusMessage(req.status);
            	
            	pObject.parseData(null, message);
  	        }
        	
        	if (BrowserDetect.browser == "Explorer" && BrowserDetect.version <= 6){
        		// 통과
        	} else {
        		req.onreadystatechange = null;
    	    	req = null;
    	    	pObject = null;
    	    	pFlag = null;
        	};

  	    	hideAjaxBox();
  	    }
  	  };
  	};
  	
  	/**
  	 * @description	미결
  	 * @param 		{Object}	pMethod
  	 * @param 		{Object}	pURL
  	 * @param 		{Object}	pQueryString
  	 * @param 		{Object}	pObject
  	 * @param 		{Object}	pFlag
  	 * @param 		{number}	pTimeout
  	 * @return		{void}
  	 * @example		미결
  	 */
	function ajaxCall(pMethod, pURL, pQueryString, pObject, pFlag, pTimeout) {
		
		// 강제 SYNC 모드이면 
		if (syncModeByForce == AJAX_ASYNCMODE_BYFORCE){
			ajaxCallSync(pMethod, pURL, pQueryString, pObject, pFlag, pTimeout)
			return;
		}
		
		// 여기에 메시지 박스를 넣는 것으로 통일한다 
		showAjaxBox("자료를 조회하는 중입니다.", 0);
		
		if (pTimeout == undefined) pTimeout = 10;
	    var xmlHttp = newXMLHttpRequest();
	    
	    var handlerFunction = getReadyStateHandler(xmlHttp, pObject, pFlag);
	    xmlHttp.onreadystatechange = handlerFunction;
	    
	    try {
	        if(pMethod=='GET'){
	                 xmlHttp.open(pMethod, pURL + "?" + pQueryString, true);
	                 if (parseFloat(navigator.appVersion.substring(navigator.appVersion.indexOf("MSIE")+5)) >= 8) {
	         	       	xmlHttp.timeout = pTimeout * 1000;
	         	       	xmlHttp.ontimeout = function() {
	         	       		request_aborted = true; this.abort();
	         	       	    pObject = null;
	         	       	    //xmlHttp = null;
	         	        };
	                 }
	                 xmlHttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded; charset=UTF-8");
	                 /*xmlHttp.setRequestHeader("Content-length", pQueryString.length);
	                 xmlHttp.setRequestHeader("Connection", "close");*/
	                 xmlHttp.send(null);
	                 
	         } else if(pMethod=='POST')  {
	                 xmlHttp.open(pMethod, pURL, true);
	                 if (parseFloat(navigator.appVersion.substring(navigator.appVersion.indexOf("MSIE")+5)) >= 8) {
	         	       	xmlHttp.timeout = pTimeout * 1000;
	         	       	xmlHttp.ontimeout = function() {
	         	       		request_aborted = true; this.abort();
	         	       	    this.onreadystatechange = null;
	         	       	    pObject = null;
	         	       	    //xmlHttp = null;
	         	        }
	                 }
	                 if (parseFloat(navigator.appVersion.substring(navigator.appVersion.indexOf("MSIE")+5)) >= 9) {
		            	 xmlHttp.setRequestHeader("X-UA-Compatible", "IE=EmulateIE8");
		            	 xmlHttp.setRequestHeader("Cache-Control", "no-store, no-cache, must-revalidate");
		            	 xmlHttp.setRequestHeader("Pragma", "no-cache");
		            	 xmlHttp.setRequestHeader("expires", "-1");
		             }
	                 xmlHttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded; charset=UTF-8");
	                 /*xmlHttp.setRequestHeader("Content-length", pQueryString.length);
	                 xmlHttp.setRequestHeader("Connection", "close");*/
	                 xmlHttp.send(pQueryString);
	         }
	    } catch(e) {
  	    	hideAjaxBox();
	        alert(e);
	    }
		pObject = null;
		xmlHttp = null;

		return;
	};
	
	/**
	 * @description	미결
	 * @param		{Object}	pMethod
	 * @param		{Object}	pURL
	 * @param		{Object}	pQueryString
	 * @param		{Object}	pObject
	 * @param		{Object}	pFlag
	 * @param		{number}	pTimeout
	 * @return		{void}
	 * @example		미결
	 */
	function ajaxCallSync(pMethod, pURL, pQueryString, pObject, pFlag, pTimeout) {
		// 여기에 메시지 박스를 넣는 것으로 통일한다 
		showAjaxBox("자료를 조회하는 중입니다.", 0);

		if (pTimeout == undefined) pTimeout = 10;
        var xmlHttp = newXMLHttpRequest();
        
        var handlerFunction = getReadyStateHandler(xmlHttp, pObject, pFlag);
            if(pMethod=='GET'){
                try {
                    if(BrowserDetect.browser != "Firefox"){
                        xmlHttp.onreadystatechange = handlerFunction;
                    }
                    
                    xmlHttp.open(pMethod, pURL + "?" + pQueryString, false);
                    if (parseFloat(navigator.appVersion.substring(navigator.appVersion.indexOf("MSIE")+5)) >= 8) {
		            	xmlHttp.timeout = pTimeout * 1000;
		            	xmlHttp.ontimeout = function() {
		            		request_aborted = true; this.abort();
	         	       	    this.onreadystatechange = null;
	         	       	    pObject = null;
	         	       	    //xmlHttp = null;
		                };
		            }
                    xmlHttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded; charset=UTF-8");
                    /*xmlHttp.setRequestHeader("Content-length", pQueryString.length);
                    xmlHttp.setRequestHeader("Connection", "close");*/
                    xmlHttp.send(null);
                    if(BrowserDetect.browser == "Firefox"){
                        handlerFunction();
                    }
                } catch(e) {
                   alert(e);
                }
            } else if(pMethod=='POST')  {
                try {
                    if(BrowserDetect.browser != "Firefox"){
                        xmlHttp.onreadystatechange = handlerFunction;
                    }
                    
                    xmlHttp.open(pMethod, pURL, false);
                     if (parseFloat(navigator.appVersion.substring(navigator.appVersion.indexOf("MSIE")+5)) >= 9) {
                         xmlHttp.setRequestHeader("X-UA-Compatible", "IE=EmulateIE8");
                         xmlHttp.setRequestHeader("Cache-Control", "no-store, no-cache, must-revalidate");
                         xmlHttp.setRequestHeader("Pragma", "no-cache");
                         xmlHttp.setRequestHeader("expires", "-1");
                     }
                     if (parseFloat(navigator.appVersion.substring(navigator.appVersion.indexOf("MSIE")+5)) >= 8) {
		            	 xmlHttp.timeout = pTimeout * 1000;
		            	 xmlHttp.ontimeout = function() {
		            		 request_aborted = true; this.abort();
		         	       	    this.onreadystatechange = null;
		         	       	    pObject = null;
		         	       	    //xmlHttp = null;
		            	 };
		             }
                     xmlHttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded; charset=UTF-8");
                     /*xmlHttp.setRequestHeader("Content-length", pQueryString.length);
                     xmlHttp.setRequestHeader("Connection", "close");*/
                     xmlHttp.send(pQueryString);
                     
                     if(BrowserDetect.browser == "Firefox"){
                         handlerFunction();
                     }
                 } catch(e) {
                       alert(e);
                 }
            }
            
     return;
};

/*
* 
* 
*/

var ajaxBoxCallingCount = 0;
var NEED_COUNT_UP = true;
var NEED_NOT_COUNT_UP = false;

/**
 * @description 미결
 * @param 		{String}	ment
 * @param 		{Number}	delayTime
 * @param 		{Number}	countUp
 * @return		{void}
 * @example		미결
 */
function showAjaxBox(ment, delayTime, countUp){  // countUp: ajaxBoxCallingCount을 증가
    if (delayTime == undefined) delayTime = 0;

    if (countUp == undefined) {
        countUp = NEED_COUNT_UP;
    } else if (typeof(countUp) == "boolean" && countUp == true) {
        countUp = NEED_COUNT_UP;
    } else if (typeof(countUp) == "Number" && countUp != 0) {
        countUp = NEED_COUNT_UP;
    } 

    if(countUp == NEED_COUNT_UP) {
    	ajaxBoxCallingCount++;
    }
    showProgressBar(ment);
    // setTimeout(function(){showProgressBar(ment);}, delayTime);

    //inProcess = true; // setTimeout가 뒤늦게 호출되었을 때, 보일지 구분
    return;
};

/**
 * @description	미결
 * @param 		{String}	ment
 * @return		{undefined}
 * @example		미결
 */
function showProgressBar(ment){
//   if (!inProcess) return;
   
//   debug.enable = true;
//   debug.print("======================================================");
//   debug.printStackTrace();

//   document.getElementsByName("ajaxBox")[0].style.display = "block";
   try {   
		//항상 화면 중앙에 나타나도록 한다
	   var yp=document.body.scrollTop;
	   var xp=document.body.scrollLeft;
	
	   var ws = 0;
	   var hs = 0;
	   
	   if( typeof( window.innerWidth ) == 'number' ) {
	       //Non-IE
	       ws = window.innerWidth;
	       hs = window.innerHeight;
	   } else if( document.documentElement && ( document.documentElement.clientWidth || document.documentElement.clientHeight ) ) {
	       //IE 6+ in 'standards compliant mode'
	       ws = document.documentElement.clientWidth;
	       hs = document.documentElement.clientHeight;
	   } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
	       //IE 4 compatible
	       ws = document.body.clientWidth;
	       hs = document.body.clientHeight;
	   }
	   
	   var ajaxBox = document.getElementById("ajaxBox");
	   var ajaxBoxMent = document.getElementById("ajaxBoxMent");
	   if (ajaxBoxMent.getElementsByTagName("DIV").length == 0){
		   ajaxBoxMent.innerHTML = "<DIV style='text-align:center;'>.</DIV>" +
		   						   "<img src='"+ getContextPath() + "/winnersoft/images/progressbar.gif'/>" +
		   						   "<BR/><span onclick='javascript:cancelJob();' onmouseover='this.style.fontWeight=\"bold\";this.style.color=\"#4169E1\"' onmouseout='this.style.color=\"#aaaaaa\"' style='font-size:12px;font-weight:bold;cursor:pointer;color:#aaaaaa'></span>";
	   }
	   
	   // 만약 구버전에서 ajaxBoxMent가 ajaxBox내에 있으면 다음으로 뺀다
	   if (ajaxBoxMent.parentNode == ajaxBox){
		   ajaxBox.removeChild(ajaxBoxMent);
		   ajaxBox.insertAdjacentElement('afterEnd', ajaxBoxMent);
	   }
	   
	   if(!ment) ment = getText("message_ajax_002", "잠시만 기다려 주세요");
	   ajaxBoxMent.getElementsByTagName("DIV")[0].innerText = ment;
		   
	   ajaxBox.style.position = "absolute";
	   ajaxBox.style.display = "block";
	   ajaxBox.style.zIndex = 20000;
	   ajaxBox.style.top = 0;
	   ajaxBox.style.left = 0;
	   ajaxBox.style.width = ws +'px';
//	   ajaxBox.style.height = hs-205 +'px';
	   ajaxBox.style.height = hs +'px';
	   ajaxBox.style.marginLeft = "-15px";
//	   ajaxBox.style.width = "100%";//ws +'px';
//	   ajaxBox.style.height = "100%";//hs +'px';
	   
	   ajaxBoxMent.style.position = "absolute";
	   ajaxBoxMent.style.display = "block";
	   ajaxBoxMent.style.zIndex = 20001;
//	   ajaxBoxMent.style.top = yp+(hs/2)-75-102 +'px';   // 파이어폭스, 크롬에서는  'px' 를 붙여줘야한다
	   ajaxBoxMent.style.top = yp+(hs/2)-71 +'px';   // 파이어폭스, 크롬에서는  'px' 를 붙여줘야한다
//	   ajaxBoxMent.style.top = yp+(hs/2)-75 +'px';   // 파이어폭스, 크롬에서는  'px' 를 붙여줘야한다
//	   ajaxBoxMent.style.left = xp+(ws/2)-75 +'px';	 	  
	   ajaxBoxMent.style.left = xp+(ws/2)-50 +'px';	 	  
	   
	   /*var compStyle = ajaxBoxMent.currentStyle ? ajaxBoxMent.currentStyle : getComputedStyle(ajaxBoxMent, null);
	   var wHeight = (compStyle != null &&  compStyle.height.length > 0 ? parseIntSize(compStyle.height) : 70);
	   var wWidth = (compStyle != null &&  compStyle.width.length > 0 ? parseIntSize(compStyle.width) : 400);

	   ajaxBoxMent.style.top  = yp + ((hs - wHeight)/2) +'px'; 
	   ajaxBoxMent.style.left = xp + ((ws - wWidth)/2) +'px';	 	    */
   
   } catch(e){
	   
	   alert(e);
	   
   }
};

/**
 * @description	미결
 * @param		{number}	countUp
 * @return		{void}
 * @example		미결
 */
function hideAjaxBox(countUp){
	
	if(countUp == undefined || typeof(countUp) != "boolean" ) {
		countUp = NEED_COUNT_UP;
	} 
	if (countUp == NEED_COUNT_UP) ajaxBoxCallingCount--;
	
    if (ajaxBoxCallingCount > 0) {
    	return;
    }
    
    hideAjaxBox_timer();
    //setTimeout(function(){hideAjaxBox_timer();}, 0);
    
    return;
};

/**
 * description	미결
 * return		{undefined}
 * example		미결
 */
function hideAjaxBox_timer(){
/*
	debug.enable = true;
	var busy = jobControler.busy;
	busy = busy || objectManager.busy;
	
	for (var wKey in batchWorks){
    	if (batchWorks[wKey] instanceof Function) continue;
    	busy = busy || batchWorks[wKey].busy;
    }
	for (var i = 0; i < charts.length; i++) {
		busy = busy || charts[i].busy;
	}
	for (var i = 0; i < crosssheets.length; i++) {
		busy = busy || crosssheets[i].busy;
	}
	for (var i = 0; i < pictures.length; i++) {
		busy = busy || pictures[i].busy;
	}
	for (var i = 0; i < reports.length; i++) {
		busy = busy || reports[i].busy;
	}
		
	if (busy) return;
 * */    
    
    
    
    document.getElementsByName("ajaxBox")[0].style.display = "none";
    document.getElementsByName("ajaxBoxMent")[0].style.display = "none";
    
   //inProcess = false;
};

//이벤트를 호출한다 (첫번째는 이벤트 함수명, 그다음들은 인수명)
/**
 * @description	미결
 * @return		{void}
 * @example		미결
 */
function callEvent(){
	var functionName =  arguments[0]; 
	
	var functionString =  functionName + "("; 
    for (var i = 1; i < arguments.length; i++)
    {
	   if (i > 1) functionString += ",";
	   
	   if (typeof(arguments[i]) == "string"){
		   functionString += "'" + arguments[i].replaceWord("\"", "").replaceWord("\n", "\\n").replaceWord("\'","\\\'") + "'";
	   } else {
		   functionString += arguments[i];
	   }
    }
    functionString +=  ")";

	var checkFunction = false;
	try {
    	if (eval(functionName)) checkFunction = true;
   } catch(e){}
    
   if (checkFunction){
   	eval(functionString);
   }
	    
    return;
};


/**
 * @description	미결
 * @param 		{String}	status
 * @returns 	{String}
 * @example		미결
 */
function getAjaxStatusMessage(status){
	var errInfo = "";

	if (status == 0) {
        errInfo = getText("message_ajax_0", "서버와의 통신이 원활하지 않습니다.\n서버와의 연결을 확인해 주세요.");
    } else if (status == 401) {
        errInfo = getText("message_ajax_401", "오류번호:401\n 권한이 없습니다.");
    } else if (status == 403) {
        errInfo = getText("message_ajax_403", "오류번호:403\n 접근이 금지되었습니다.");
    } else if (status == 404) {
        errInfo = getText("message_ajax_404", "오류번호:404\n URL주소가 잘못되었습니다. 서버가 응답하지 못합니다.."); 
    } else if (status == 301) {
        errInfo = getText("message_ajax_301", "오류번호:301\n URL주소가 영구적으로 변경되었습니다."); 
    } else if (status == 302) {
        errInfo = getText("message_ajax_302", "오류번호:302\n 주소는 맞지만 다른 서버의 URL/URI를 호출 할 수는 없습니다.");
    } else if (status == 305) {
        errInfo = getText("message_ajax_305", "오류번호:305\n 리소스에 접근하기 위하여는 프록시를 설정하여야 합니다.");
    } else if (status == 12001) {
        errInfo = getText("message_ajax_12001", "오류번호:ERROR_INTERNET_OUT_OF_HANDLES\n No more handles could be generated at this time.");	
    } else if (status == 12002) {
        errInfo = getText("message_ajax_12002", "오류번호:ERROR_INTERNET_TIMEOUT\n The request has timed out.");	
    } else if (status == 12003) {
        errInfo = getText("message_ajax_12003", "오류번호:ERROR_INTERNET_EXTENDED_ERROR\n An extended error was returned from the server.");	
    } else if (status == 12004) {
        errInfo = getText("message_ajax_12004", "오류번호:ERROR_INTERNET_INTERNAL_ERROR\n An internal error has occurred.");	
    } else if (status == 12005) {
        errInfo = getText("message_ajax_12005", "오류번호:ERROR_INTERNET_INVALID_URL\n The URL is invalid.");	
    } else if (status == 12006) {
        errInfo = getText("message_ajax_12006", "오류번호:ERROR_INTERNET_UNRECOGNIZED_SCHEME\n The URL scheme could not be recognized or is not supported.");	
    } else if (status == 12007) {
        errInfo = getText("message_ajax_12007", "오류번호:ERROR_INTERNET_NAME_NOT_RESOLVED\n The server name could not be resolved.");	
    } else if (status == 12008) {
        errInfo = getText("message_ajax_12008", "오류번호:ERROR_INTERNET_PROTOCOL_NOT_FOUND\n The requested protocol could not be located.");	
    } else if (status == 12009) {
        errInfo = getText("message_ajax_12009", "오류번호:ERROR_INTERNET_INVALID_OPTION\n A request to InternetQueryOption or InternetSetOption specified an invalid option value.");	
    } else if (status == 12010) {
        errInfo = getText("message_ajax_12010", "오류번호:ERROR_INTERNET_BAD_OPTION_LENGTH\n The length of an option supplied to InternetQueryOption or InternetSetOption is incorrect for the type of option specified.");	
    } else if (status == 12011) {
        errInfo = getText("message_ajax_12011", "오류번호:ERROR_INTERNET_OPTION_NOT_SETTABLE\n The request option cannot be set, only queried.");	
    } else if (status == 12012) {
        errInfo = getText("message_ajax_12012", "오류번호:ERROR_INTERNET_SHUTDOWN\n The Win32 Internet function support is being shut down or unloaded.");	
    } else if (status == 12013) {
        errInfo = getText("message_ajax_12013", "오류번호:ERROR_INTERNET_INCORRECT_USER_NAME\n The request to connect and log on to an FTP server could not be completed because the supplied user name is incorrect.");	
    } else if (status == 12014) {
    	errInfo = getText("message_ajax_12014", "오류번호:ERROR_INTERNET_INCORRECT_PASSWORD\n The request to connect and log on to an FTP server could not be completed because the supplied password is incorrect.");	
    } else if (status == 12015) {
        errInfo = getText("message_ajax_12015", "오류번호:ERROR_INTERNET_LOGIN_FAILURE\n The request to connect to and log on to an FTP server failed.");	
    } else if (status == 12016) {
        errInfo = getText("message_ajax_12016", "오류번호:ERROR_INTERNET_INVALID_OPERATION\n The requested operation is invalid.");	
    } else if (status == 12017) {
        errInfo = getText("message_ajax_12017", "오류번호:ERROR_INTERNET_OPERATION_CANCELLED\n The operation was canceled, usually because the handle on which the request was operating was closed before the operation completed.");	
    } else if (status == 12018) {
        errInfo = getText("message_ajax_12018", "오류번호:ERROR_INTERNET_INCORRECT_HANDLE_TYPE\n The type of handle supplied is incorrect for this operation.");	
    } else if (status == 12019) {
        errInfo = getText("message_ajax_12019", "오류번호:ERROR_INTERNET_INCORRECT_HANDLE_STATE\n The requested operation cannot be carried out because the handle supplied is not in the correct state.");	
    } else if (status == 12020) {
        errInfo = getText("message_ajax_12020", "오류번호:ERROR_INTERNET_NOT_PROXY_REQUEST\n The request cannot be made via a proxy.");	
    } else if (status == 12021) {
        errInfo = getText("message_ajax_12021", "오류번호:ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND\n A required registry value could not be located.");	
    } else if (status == 12022) {
        errInfo = getText("message_ajax_12022", "오류번호:ERROR_INTERNET_BAD_REGISTRY_PARAMETER\n A required registry value was located but is an incorrect type or has an invalid value.");	
    } else if (status == 12023) {
        errInfo = getText("message_ajax_12023", "오류번호:ERROR_INTERNET_NO_DIRECT_ACCESS\n Direct network access cannot be made at this time.");	
   	} else if (status == 12024) {
        errInfo = getText("message_ajax_12024", "오류번호:ERROR_INTERNET_NO_CONTEXT\n An asynchronous request could not be made because a zero context value was supplied.");	
   	} else if (status == 12025) {
        errInfo = getText("message_ajax_12025", "오류번호:ERROR_INTERNET_NO_CALLBACK\n An asynchronous request could not be made because a callback function has not been set.");	
   	} else if (status == 12026) {
        errInfo = getText("message_ajax_12026", "오류번호:ERROR_INTERNET_REQUEST_PENDING\n The required operation could not be completed because one or more requests are pending.");	
   	} else if (status == 12027) {
        errInfo = getText("message_ajax_12027", "오류번호:ERROR_INTERNET_INCORRECT_FORMAT\n The format of the request is invalid.");	
   	} else if (status == 12028) {
        errInfo = getText("message_ajax_12028", "오류번호:ERROR_INTERNET_ITEM_NOT_FOUND\n The requested item could not be located.");	
   	} else if (status == 12029) {
        errInfo = getText("message_ajax_12029", "오류번호:ERROR_INTERNET_CANNOT_CONNECT\n The attempt to connect to the server failed.");	
   	} else if (status == 12030) {
        errInfo = getText("message_ajax_12030", "오류번호:ERROR_INTERNET_CONNECTION_ABORTED\n The connection with the server has been terminated.");	
   	} else if (status == 12031) {
        errInfo = getText("message_ajax_12031", "오류번호:ERROR_INTERNET_CONNECTION_RESET\n The connection with the server has been reset.");	
   	} else if (status == 12032) {
        errInfo = getText("message_ajax_12032", "오류번호:ERROR_INTERNET_FORCE_RETRY\n Calls for the Win32 Internet function to redo the request.");	
   	} else if (status == 12033) {
        errInfo = getText("message_ajax_12033", "오류번호:ERROR_INTERNET_INVALID_PROXY_REQUEST\n The request to the proxy was invalid.");	
   	} else if (status == 12036) {
        errInfo = getText("message_ajax_12036", "오류번호:ERROR_INTERNET_HANDLE_EXISTS\n The request failed because the handle already exists.");	
   	} else if (status == 12037) {
   		errInfo = getText("message_ajax_12037", "오류번호:ERROR_INTERNET_SEC_CERT_DATE_INVALID\n SSL certificate date that was received from the server is bad. The certificate is expired.");	
   	} else if (status == 12038) {
   		errInfo = getText("message_ajax_12038", "오류번호:ERROR_INTERNET_SEC_CERT_CN_INVALID\n SSL certificate common name (host name field) is incorrect.");	
   	} else if (status == 12039) {
   		errInfo = getText("message_ajax_12039", "오류번호:ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR\n The application is moving from a non-SSL to an SSL connection because of a redirect.");	
   	} else if (status == 12040) {
   		errInfo = getText("message_ajax_12040", "오류번호:ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR\n The application is moving from an SSL to an non-SSL connection because of a redirect.");	
   	} else if (status == 12041) {
   		errInfo = getText("message_ajax_12041", "오류번호:ERROR_INTERNET_MIXED_SECURITY\n Indicates that the content is not entirely secure.");	
   	} else if (status == 12042) {
   		errInfo = getText("message_ajax_12042", "오류번호:ERROR_INTERNET_CHG_POST_IS_NON_SECURE\n The application is posting and attempting to change multiple lines of text on a server that is not secure.");	
   	} else if (status == 12043) {
   		errInfo = getText("message_ajax_12043", "오류번호:ERROR_INTERNET_POST_IS_NON_SECURE\n The application is posting data to a server that is not secure.");	
   	} else if (status == 12110) {
   		errInfo = getText("message_ajax_12110", "오류번호:ERROR_FTP_TRANSFER_IN_PROGRESS\n The requested operation cannot be made on the FTP session handle because an operation is already in progress.");	
   	} else if (status == 12111) {
   		errInfo = getText("message_ajax_12111", "오류번호:ERROR_FTP_DROPPED\n The FTP operation was not completed because the session was aborted.");	
   	} else if (status == 12150) {
   		errInfo = getText("message_ajax_12150", "오류번호:ERROR_HTTP_HEADER_NOT_FOUND\n The requested header could not be located.");	
   	} else if (status == 12151) {
   		errInfo = getText("message_ajax_12151", "오류번호:ERROR_HTTP_DOWNLEVEL_SERVER\n The server did not return any headers.");	
   	} else if (status == 12152) {
   		errInfo = getText("message_ajax_12152", "오류번호:ERROR_HTTP_INVALID_SERVER_RESPONSE\n The server response could not be parsed.");	
   	} else if (status == 12153) {
   		errInfo = getText("message_ajax_12153", "오류번호:ERROR_HTTP_INVALID_HEADER\n The supplied header is invalid.");	
   	} else if (status == 12154) {
   		errInfo = getText("message_ajax_12154", "오류번호:ERROR_HTTP_INVALID_QUERY_REQUEST\n The request made to HttpQueryInfo is invalid.");	
   	} else if (status == 12155) {
   		errInfo = getText("message_ajax_12155", "오류번호:ERROR_HTTP_HEADER_ALREADY_EXISTS\n The header could not be added because it already exists.");	
    } else if (status == 12156) {
    	errInfo = getText("message_ajax_12156", "오류번호:ERROR_HTTP_REDIRECT_FAILED\n The redirection failed because either the scheme changed or all attempts made to redirect failed");	
    } else {
    	errInfo = getText("message_ajax_999", "알 수 없는 오류\n 오류번호 : {0}", "" + status);
    }  
    return errInfo;
};



/* *****************************************************************************
*  XMLHttpIRequest : 아이프레임을 통한  리퀘스트 
* *****************************************************************************/
/**
 * @description	미결
 * @return		{undefined}
 * @example		미결
 */
function XMLHttpIRequest() {   
	
	this.name = "";
	this.parentNode = document.getElementById("IFrameLayer"); 
    this.method = "";
    this.url = "";
    this.queryString = "";
    
    this.contentType = "";
    this.contentLength = "";
    this.connection = "";
    this.async = true;
    
    this.responseText = "";
    this.readyState = 0;
    this.status = 0;
    
    this.onreadystatechange = null;

	// 이름을 먼저 만든다
    var name = ""; var i = 0;
    name = "IJAX_" + i;
    while(document.getElementsByName(name).length > 0){
    	name = "IJAX_" + (++i);
    }
	this.name = name;

    var iframe = document.createElement("iframe");  
    iframe.name = iframe.id = name;
    this.parentNode.appendChild(iframe);  


    iframe.doc = null;  
    if(iframe.contentDocument) iframe.doc = iframe.contentDocument;           // Firefox, Opera  
    else if(iframe.contentWindow) iframe.doc = iframe.contentWindow.document; // Internet Explorer  
    else if(iframe.document) iframe.doc = iframe.document;                    // Others?  
    if(iframe.doc == null)  
       throw getText("message_ajax_003", "문서가 발견되지 않았습니다. IFrame을 만들기 전에 DOM에 DIV(parent element)를 추가하세요"); 

    iframe.doc.open();  
    iframe.doc.close(); 
    
    this.iframe = iframe;
	
	this.open = function(pMethod, pURL, async){
    	// functionname : [XMLHttpIRequest.open]

    	this.method = pMethod;
    	
    	//페이지명에 "_Text"를 붙여서 스트럿츠가 부별하게 해준다.
    	var wUrl = pURL.substring(0,pURL.lastIndexOf(".")) + "_Text" + pURL.substring(pURL.lastIndexOf("."));

        this.async = async;
        if (this.method == "GET"){
            if (pURL.indexOf("?") == 0){
        	    this.url = pURL;
        	    this.queryString = "";
    	    } else {
        	    this.url = pURL.split("\?")[0];
        	    this.queryString = pURL.split("\?")[1];
    	    }

   		    return;
        } else {
        	this.url = pURL;
        	this.queryString = "";
    		return;
        }
        
        
    };
    
    //xmlHttp.setRequestHeader("Content-type", "text/plain; charset=UTF-8");
    this.setRequestHeader = function(headerName, HeaderValue){
    	// functionname : [XMLHttpIRequest.setRequestHeader]
    	if (headerName == "Content-type"){
    		this.contentType = HeaderValue;
    	} else if (headerName == "Content-length"){
    		this.contentLength = HeaderValue;
    	} else if (headerName == "Connection"){
    		this.connection = HeaderValue;
    	} 
    };
    this.send = function(pQueryString){
    	// functionname : [XMLHttpIRequest.send]
    	
    	var iframe = this.iframe;
    	
    	var iframe = this.iframe;
    	iframe.parentObject = this;
        iframe.onload = function(){
        	// functionname : [XMLHttpIRequest.onload]
        	
                this.parentObject.readyState = 4;
                this.parentObject.status = 200;
                this.parentObject.responseText = this.contentDocument.body.innerText;
                this.parentObject.onreadystatechange();
        };
        
        iframe.onreadystatechange = function(){
        	// functionname : [XMLHttpIRequest.onreadystatechange]
        	
	        if (this.readyState == 'complete') {
                this.parentObject.readyState = 4;
                this.parentObject.status = 200;
                this.parentObject.responseText = this.contentWindow.document.body.innerText;
                this.parentObject.onreadystatechange();
            }
        };

        if (this.method == "GET"){
        
        	if (pQueryString == null || pQueryString.trim().length == 0){
        		iframe.src = this.url;
        	} else {
        		iframe.src = this.url + "?" + pQueryString;
        	}
    	} else {
    	
            var frm = iframe.doc.createElement("form");  
            iframe.doc.body.appendChild(frm);  
            
            frm.method = this.method;
            frm.name   = frm.id ="frmbjax" ;
            frm.action = this.url;
            frm.enctype= this.contentType;

            var arrQueryInfos = parseQueryString(pQueryString);
            
            for (var i = 0; i < arrQueryInfos.length; i++){
        	    var QueryInfo = arrQueryInfos[i];
            	
                var wControl = iframe.doc.createElement("input");
                wControl.type = "hidden";  
                wControl.id   = wControl.name = QueryInfo.varName;
                wControl.value = QueryInfo.value;
                frm.appendChild(wControl);
            }
            
            this.frm = frm;
            
    		this.frm.submit();
    	}
    };
 };

 /**
  * @description	미결
  * @param			{String}	str
  * @return			{undefined}
  * @example		미결
  */
 function queryInfo(str){
	 var arrStr = str.split("=");
	 this.varName = arrStr[0];
	 this.value = decodeURIComponent(arrStr[1]);
 };
 
 /**
  * @description	미결
  * @param			{String}	query
  * @return			{String}
  * @example		미결
  */
 function parseQueryString(query){
	 var arrReturn = [];
	 var wQueryElements = query.split("&");
	 
	 var seq = 0;
	 for (var i = 0; i < wQueryElements.length; i++){
		 if (wQueryElements[i].trim().length == 0) continue;
		 if (wQueryElements[i].indexOf("=") == 0) continue;
		 
		 arrReturn[seq++] = new queryInfo(wQueryElements[i]);
	 }
	 
	 return arrReturn;
 };

 /**
  * @description	미결
  * @param 			{String}	readyState
  * @return			{undefined}
  * @example		미결
  */
function progressMessage(readyState){
   if (readyState == 1) {
	   showAjaxBox(getText("message_ajax_101", "서버에 연결중입니다."), 0, NEED_NOT_COUNT_UP);
   } else if (readyState == 2) {
	   showAjaxBox(getText("message_ajax_102", "데이터 요청이 시작되었습니다."), 0, NEED_NOT_COUNT_UP);
   } else if (readyState == 3) {
	   showAjaxBox(getText("message_ajax_103", "수신 중, 서버가 응답을 보내는 중임."), 0, NEED_NOT_COUNT_UP);
   } else if (readyState == 4) {
	   showAjaxBox(getText("message_ajax_104", "수신완료. 자료를 해석중입니다."), 0, NEED_NOT_COUNT_UP);
   } 
};	 


//로케일 메시지 =================================================================================
//사용방법 1(메시지만):         alert(getText("message_ajax_01"));  
//사용방법 2(메시지, 디폴트):  alert(getText("message_ajax_011", "no message"));
//사용방법 3(메시지, 디폴트, 문자열):  alert(getText("message_ajax_01", "{0} message", "XXX"));
//사용방법 4(메시지, 디폴트, 배열):  alert(getText("message_ajax_02", "no message", ["XXX", 2]));
//-----------------------------------------------------------------------------------------------
/**
 * @description	미결
 * @param		{Object}	key
 * @param		{Object}	defaultMsg
 * @param		{number}	params
 * @return		{String}
 * @example		미결
 */
function getText(key, defaultMsg, params){
	var wReturn = "";
	var msgObjectDefined = false;
    try {
    	wReturn = msgObject[key];
    	msgObjectDefined = true;
    } catch (e){}
    
	if (!msgObjectDefined || wReturn == undefined || wReturn == null || wReturn.length==0){
		if (defaultMsg != undefined && defaultMsg.length > 0){
			wReturn = defaultMsg;
		} else {
			wReturn = "";
		}
	}
	if (params != undefined){
		if (isArray(params)){
			for(var i = 0; i < params.length; i++){
				wReturn = wReturn.replaceWord("{" + i + "}", "" + params[i]);
			} 
		} else if (isString(params)){
			wReturn = wReturn.replaceWord("{0}", params);
			
		} else {
			wReturn = wReturn.replaceWord("{0}", "" + params);
			
		} 
	}
	
	return wReturn;
};

/*
 * NumberFormat 1.5.3
 * v1.5.3 - 29-September-2004
 * v1.5.2 - 27-August-2004
 * v1.5.1 - 13-February-2004
 * v1.5.0 - 20-December-2002
 * v1.0.3 - 23-March-2002
 * v1.0.2 - 13-March-2002
 * v1.0.1 - 20-July-2001
 * v1.0.0 - 13-April-2000
 * http://www.mredkj.com
 */
  
/*
 * NumberFormat -The constructor
 * num - The number to be formatted.
 *  Also refer to setNumber
 * inputDecimal - (Optional) The decimal character for the input
 *  Also refer to setInputDecimal
 */
 
/**
 * @description 미결
 * @param		{number}	pNum
 * @return		{string}
 * @example		미결
 */
function RateFormat(pNum){

	var num = new NumberFormat();
	num.setInputDecimal('.');
	num.setNumber(pNum); 
	num.setPlaces('2');
	num.setCurrencyValue('$');
	num.setCurrency(false);
	num.setCurrencyPosition(num.LEFT_OUTSIDE);
	num.setNegativeFormat(num.LEFT_DASH);
	num.setNegativeRed(false);
	num.setSeparators(true, ',', ',');
	return num.toFormatted();

};
/**
 * @description 미결
 * @param		{number}	pNum
 * @return		{string}
 * @example		미결
 */
function AmountFormat(pNum){

	var num = new NumberFormat();
	num.setInputDecimal('.');
	num.setNumber(pNum); 
	num.setPlaces('0');
	num.setCurrencyValue('\\');
	num.setCurrency(false);
	num.setCurrencyPosition(num.LEFT_OUTSIDE);
	num.setNegativeFormat(num.LEFT_DASH);
	num.setNegativeRed(false);
	num.setSeparators(true, ',', ',');
	
	return num.toFormatted();

};
 

/**
 * @description 미결
 * @param		{number}	Num
 * @param		{String}	inputDecimal
 * @return		{string}
 * @example		미결
 */
function NumberFormat(num, inputDecimal)
{
	// constants
	this.COMMA = ',';
	this.PERIOD = '.';
	this.DASH = '-'; // v1.5.0 - new - used internally
	this.LEFT_PAREN = '('; // v1.5.0 - new - used internally
	this.RIGHT_PAREN = ')'; // v1.5.0 - new - used internally
	this.LEFT_OUTSIDE = 0; // v1.5.0 - new - currency
	this.LEFT_INSIDE = 1;  // v1.5.0 - new - currency
	this.RIGHT_INSIDE = 2;  // v1.5.0 - new - currency
	this.RIGHT_OUTSIDE = 3;  // v1.5.0 - new - currency
	this.LEFT_DASH = 0; // v1.5.0 - new - negative
	this.RIGHT_DASH = 1; // v1.5.0 - new - negative
	this.PARENTHESIS = 2; // v1.5.0 - new - negative
	this.NO_ROUNDING = -1; // v1.5.1 - new

	// member variables
	this.num;
	this.numOriginal;
	this.hasSeparators = false;  // v1.5.0 - new
	this.separatorValue;  // v1.5.0 - new
	this.inputDecimalValue; // v1.5.0 - new
	this.decimalValue;  // v1.5.0 - new
	this.negativeFormat; // v1.5.0 - new
	this.negativeRed; // v1.5.0 - new
	this.hasCurrency;  // v1.5.0 - modified
	this.currencyPosition;  // v1.5.0 - new
	this.currencyValue;  // v1.5.0 - modified
	this.places;
	this.roundToPlaces; // v1.5.1 - new

	// external methods
	this.setNumber = setNumberNF;
	this.toUnformatted = toUnformattedNF;
	this.setInputDecimal = setInputDecimalNF; // v1.5.0 - new
	this.setSeparators = setSeparatorsNF; // v1.5.0 - new - for separators and decimals
	this.setCommas = setCommasNF;
	this.setNegativeFormat = setNegativeFormatNF; // v1.5.0 - new
	this.setNegativeRed = setNegativeRedNF; // v1.5.0 - new
	this.setCurrency = setCurrencyNF;
	this.setCurrencyPrefix = setCurrencyPrefixNF;
	this.setCurrencyValue = setCurrencyValueNF; // v1.5.0 - new - setCurrencyPrefix uses this
	this.setCurrencyPosition = setCurrencyPositionNF; // v1.5.0 - new - setCurrencyPrefix uses this
	this.setPlaces = setPlacesNF;
	this.toFormatted = toFormattedNF;
	this.toPercentage = toPercentageNF;
	this.getOriginal = getOriginalNF;
	this.moveDecimalRight = moveDecimalRightNF;
	this.moveDecimalLeft = moveDecimalLeftNF;

	// internal methods
	this.getRounded = getRoundedNF;
	this.preserveZeros = preserveZerosNF;
	this.justNumber = justNumberNF;
	this.expandExponential = expandExponentialNF;
	this.getZeros = getZerosNF;
	this.moveDecimalAsString = moveDecimalAsStringNF;
	this.moveDecimal = moveDecimalNF;
	this.addSeparators = addSeparatorsNF;

	// setup defaults
	if (inputDecimal == null) {
		this.setNumber(num, this.PERIOD);
	} else {
		this.setNumber(num, inputDecimal); // v.1.5.1 - new
	}
	this.setCommas(true);
	this.setNegativeFormat(this.LEFT_DASH); // v1.5.0 - new
	this.setNegativeRed(false); // v1.5.0 - new
	this.setCurrency(false); // v1.5.1 - false by default
	this.setCurrencyPrefix('$');
	this.setPlaces(2);
};

/*
 * setInputDecimal
 * val - The decimal value for the input.
 *
 * v1.5.0 - new
 */
/**
 * @description	미결
 * @param		{String}	val
 * @return		{undefined}
 * @example		미결
 */
function setInputDecimalNF(val)
{
	this.inputDecimalValue = val;
};

/*
 * setNumber - Sets the number
 * num - The number to be formatted
 * inputDecimal - (Optional) The decimal character for the input
 *  Also refer to setInputDecimal
 * 
 * If there is a non-period decimal format for the input,
 * setInputDecimal should be called before calling setNumber.
 *
 * v1.5.0 - modified
 */
/**
 * @description 미결
 * @param		{number}	Num
 * @param		{String}	inputDecimal
 * @return		{undefined}
 * @example		미결
 */
function setNumberNF(num, inputDecimal)
{
	if (inputDecimal != null) {
		this.setInputDecimal(inputDecimal); // v.1.5.1 - new
	}
	
	this.numOriginal = num;
	this.num = this.justNumber(num);
};

/*
 * toUnformatted - Returns the number as just a number.
 * If the original value was '100,000', then this method will return the number 100000
 * v1.0.2 - Modified comments, because this method no longer returns the original value.
 */
/**
 * @description 미결
 * @return		{number}
 * @example		미결
 */
function toUnformattedNF()
{
	return (this.num);
};

/*
 * getOriginal - Returns the number as it was passed in, which may include non-number characters.
 * This function is new in v1.0.2
 */
/**
 * @description 미결
 * @return		{number}
 * @example		미결
 */
function getOriginalNF()
{
	return (this.numOriginal);
};

/*
 * setNegativeFormat - How to format a negative number.
 * 
 * format - The format. Use one of the following constants.
 * LEFT_DASH   example: -1000
 * RIGHT_DASH  example: 1000-
 * PARENTHESIS example: (1000)
 *
 * v1.5.0 - new
 */
/**
 * @description 미결
 * @param		{String}	format
 * @return		{undefined}
 * @example		미결
 */
function setNegativeFormatNF(format)
{
	this.negativeFormat = format;
};

/*
 * setNegativeRed - Format the number red if it's negative.
 * 
 * isRed - true, to format the number red if negative, black if positive;
 *  false, for it to always be black font.
 *
 * v1.5.0 - new
 */
/**
 * @description 미결
 * @param		{String}	isRed
 * @return		{undefined}
 * @example		미결
 */
function setNegativeRedNF(isRed)
{
	this.negativeRed = isRed;
};

/*
 * setSeparators - One purpose of this method is to set a
 *  switch that indicates if there should be separators between groups of numbers.
 *  Also, can use it to set the values for the separator and decimal.
 *  For example, in the value 1,000.00
 *   The comma (,) is the separator and the period (.) is the decimal.
 *
 * Both separator or decimal are not required.
 * The separator and decimal cannot be the same value. If they are, decimal with be changed.
 * Can use the following constants (via the instantiated object) for separator or decimal:
 *  COMMA
 *  PERIOD
 * 
 * isC - true, if there should be separators; false, if there should be no separators
 * separator - the value of the separator.
 * decimal - the value of the decimal.
 *
 * v1.5.0 - new
 */
/**
 * @description 미결
 * @param		{String}	isC
 * @param		{String}	separator
 * @param		{String}	decimal
 * @return		{undefined}
 * @example		미결
 */
function setSeparatorsNF(isC, separator, decimal)
{
	this.hasSeparators = isC;
	
	// Make sure a separator was passed in
	if (separator == null) separator = this.COMMA;
	
	// Make sure a decimal was passed in
	if (decimal == null) decimal = this.PERIOD;
	
	// Additionally, make sure the values aren't the same.
	//  When the separator and decimal both are periods, make the decimal a comma.
	//  When the separator and decimal both are any other value, make the decimal a period.
	if (separator == decimal) {
		this.decimalValue = (decimal == this.PERIOD) ? this.COMMA : this.PERIOD;
	} else {
		this.decimalValue = decimal;
	}
	
	// Since the decimal value changes if decimal and separator are the same,
	// the separator value can keep its setting.
	this.separatorValue = separator;
};

/*
 * setCommas - Sets a switch that indicates if there should be commas.
 * The separator value is set to a comma and the decimal value is set to a period.
 * isC - true, if the number should be formatted with separators (commas); false, if no separators
 *
 * v1.5.0 - modified
 */
/**
 * @description 미결
 * @param		{String}	isC
 * @return		{undefined}
 * @example		미결
 */
function setCommasNF(isC)
{
	this.setSeparators(isC, this.COMMA, this.PERIOD);
};

/*
 * setCurrency - Sets a switch that indicates if should be displayed as currency
 * isC - true, if should be currency; false, if not currency
 */
/**
 * @description 미결
 * @param		{String}	isC
 * @return		{undefined}
 * @example		미결
 */
function setCurrencyNF(isC)
{
	this.hasCurrency = isC;
};

/*
 * setCurrencyPrefix - Sets the symbol for currency.
 * val - The symbol
 */
/**
 * @description 미결
 * @param		{String}	val
 * @return		{undefined}
 * @example		미결
 */
function setCurrencyValueNF(val)
{
	this.currencyValue = val;
};

/*
 * setCurrencyPrefix - Sets the symbol for currency.
 * The symbol will show up on the left of the numbers and outside a negative sign.
 * cp - The symbol
 *
 * v1.5.0 - modified - This now calls setCurrencyValue and setCurrencyPosition(this.LEFT_OUTSIDE)
 */
/**
 * @description 미결
 * @param		{String}	cp
 * @return		{undefined}
 * @example		미결
 */
function setCurrencyPrefixNF(cp)
{
	this.setCurrencyValue(cp);
	this.setCurrencyPosition(this.LEFT_OUTSIDE);
};

/*
 * setCurrencyPosition - Sets the position for currency,
 *  which includes position relative to the numbers and negative sign.
 * cp - The position. Use one of the following constants.
 *  This method does not automatically put the negative sign at the left or right.
 *  They are left by default, and would need to be set right with setNegativeFormat.
 *	LEFT_OUTSIDE  example: $-1.00
 *	LEFT_INSIDE   example: -$1.00
 *	RIGHT_INSIDE  example: 1.00$-
 *	RIGHT_OUTSIDE example: 1.00-$
 *
 * v1.5.0 - new
 */
/**
 * @description 미결
 * @param		{String}	cp
 * @return		{undefined}
 * @example		미결
 */
function setCurrencyPositionNF(cp)
{
	this.currencyPosition = cp;
};

/*
 * setPlaces - Sets the precision of decimal places
 * p - The number of places.
 *  -1 or the constant NO_ROUNDING turns off rounding to a set number of places.
 *  Any other number of places less than or equal to zero is considered zero.
 *
 * v1.5.1 - modified
 */
/**
 * @description 미결
 * @param		{String}	p
 * @return		{undefined}
 * @example		미결
 */
function setPlacesNF(p)
{
	this.roundToPlaces = !(p == this.NO_ROUNDING); // v1.5.1
	this.places = (p < 0) ? 0 : p; // v1.5.1 - Don't leave negatives.
};

/*
 * v1.5.2 - new
 *
 * addSeparators
 * The value to be formatted shouldn't have any formatting already.
 *
 * nStr - A number or number as a string
 * inD - Input decimal (string value). Example: '.'
 * outD - Output decimal (string value). Example: '.'
 * sep - Output separator (string value). Example: ','
 */
/**
 * @description 미결
 * @param		{String}	nStr
 * @param		{String}	inD
 * @param		{String}	outD
 * @param		{String}	sep
 * @return		{Object}
 * @example		미결
 */
function addSeparatorsNF(nStr, inD, outD, sep)
{
	nStr += '';
	var dpos = nStr.indexOf(inD);
	var nStrEnd = '';
	if (dpos != -1) {
		nStrEnd = outD + nStr.substring(dpos + 1, nStr.length);
		nStr = nStr.substring(0, dpos);
	}
	var rgx = /(\d+)(\d{3})/;
	while (rgx.test(nStr)) {
		nStr = nStr.replace(rgx, '$1' + sep + '$2');
	}
	return nStr + nStrEnd;
};

/*
 * toFormatted - Returns the number formatted according to the settings (a string)
 *
 * v1.5.0 - modified
 * v1.5.1 - modified
 */
/**
 * @description 미결
 * @return		{Object}
 * @example		미결
 */
function toFormattedNF()
{	
	var pos;
	var nNum = this.num; // v1.0.1 - number as a number
	var nStr;            // v1.0.1 - number as a string
	var splitString = new Array(2);   // v1.5.0
	
	// round decimal places - modified v1.5.1
	// Note: Take away negative temporarily with Math.abs
	if (this.roundToPlaces) {
		nNum = this.getRounded(nNum);
		nStr = this.preserveZeros(Math.abs(nNum)); // this step makes nNum into a string. v1.0.1 Math.abs
	} else {
		nStr = this.expandExponential(Math.abs(nNum)); // expandExponential is called in preserveZeros, so call it here too
	}
	
	// v1.5.3 - lost the if in 1.5.2, so putting it back
	if (this.hasSeparators) {
		// v1.5.2
		// Note that the argument being passed in for inD is this.PERIOD
		//  That's because the toFormatted method is working with an unformatted number
		nStr = this.addSeparators(nStr, this.PERIOD, this.decimalValue, this.separatorValue);
	}
	
	// negative and currency
	// $[c0] -[n0] $[c1] -[n1] #.#[nStr] -[n2] $[c2] -[n3] $[c3]
	var c0 = '';
	var n0 = '';
	var c1 = '';
	var n1 = '';
	var n2 = '';
	var c2 = '';
	var n3 = '';
	var c3 = '';
	var negSignL = (this.negativeFormat == this.PARENTHESIS) ? this.LEFT_PAREN : this.DASH;
	var negSignR = (this.negativeFormat == this.PARENTHESIS) ? this.RIGHT_PAREN : this.DASH;
		
	if (this.currencyPosition == this.LEFT_OUTSIDE) {
		// add currency sign in front, outside of any negative. example: $-1.00	
		if (nNum < 0) {
			if (this.negativeFormat == this.LEFT_DASH || this.negativeFormat == this.PARENTHESIS) n1 = negSignL;
			if (this.negativeFormat == this.RIGHT_DASH || this.negativeFormat == this.PARENTHESIS) n2 = negSignR;
		}
		if (this.hasCurrency) c0 = this.currencyValue;
	} else if (this.currencyPosition == this.LEFT_INSIDE) {
		// add currency sign in front, inside of any negative. example: -$1.00
		if (nNum < 0) {
			if (this.negativeFormat == this.LEFT_DASH || this.negativeFormat == this.PARENTHESIS) n0 = negSignL;
			if (this.negativeFormat == this.RIGHT_DASH || this.negativeFormat == this.PARENTHESIS) n3 = negSignR;
		}
		if (this.hasCurrency) c1 = this.currencyValue;
	}
	else if (this.currencyPosition == this.RIGHT_INSIDE) {
		// add currency sign at the end, inside of any negative. example: 1.00$-
		if (nNum < 0) {
			if (this.negativeFormat == this.LEFT_DASH || this.negativeFormat == this.PARENTHESIS) n0 = negSignL;
			if (this.negativeFormat == this.RIGHT_DASH || this.negativeFormat == this.PARENTHESIS) n3 = negSignR;
		}
		if (this.hasCurrency) c2 = this.currencyValue;
	}
	else if (this.currencyPosition == this.RIGHT_OUTSIDE) {
		// add currency sign at the end, outside of any negative. example: 1.00-$
		if (nNum < 0) {
			if (this.negativeFormat == this.LEFT_DASH || this.negativeFormat == this.PARENTHESIS) n1 = negSignL;
			if (this.negativeFormat == this.RIGHT_DASH || this.negativeFormat == this.PARENTHESIS) n2 = negSignR;
		}
		if (this.hasCurrency) c3 = this.currencyValue;
	}

	nStr = c0 + n0 + c1 + n1 + nStr + n2 + c2 + n3 + c3;
	
	// negative red
	if (this.negativeRed && nNum < 0) {
		nStr = '<font color="red">' + nStr + '</font>';
	}

	return (nStr);
};

/*
 * toPercentage - Format the current number as a percentage.
 * This is separate from most of the regular formatting settings.
 * The exception is the number of decimal places.
 * If a number is 0.123 it will be formatted as 12.3%
 *
 * !! This is an initial version, so it doesn't use many settings.
 * !! should use some of the formatting settings that toFormatted uses.
 * !! probably won't want to use settings like currency.
 *
 * v1.5.0 - new
 */
/**
 * @description 미결
 * @return		{number}
 * @example		미결
 */
function toPercentageNF()
{
	nNum = this.num * 100;
	
	// round decimal places
	nNum = this.getRounded(nNum);
	
	return nNum + '%';
};

/*
 * Return concatenated zeros as a string. Used to pad a number.
 * It might be extra if already have many decimal places
 * but is needed if the number doesn't have enough decimals. 
 */
/**
 * @description 미결
 * @param		{String}	places
 * @return		{Object}
 * @example		미결
 */
function getZerosNF(places)
{
		var extraZ = '';
		var i;
		for (i=0; i<places; i++) {
			extraZ += '0';
		}
		return extraZ;
};

/*
 * Takes a number that JavaScript expresses in notational format
 * and makes it the full number (as a string).
 * e.g. Makes -1e-21 into -0.000000000000000000001
 *
 * If the value passed in is not a number (as determined by isNaN),
 * this function just returns the original value.
 *
 * Exponential number formats can include 1e21 1e+21 1e-21
 *  where 1e21 and 1e+21 are the same thing.
 *
 * If an exponential number is evaluated by JavaScript,
 * it will change 12.34e-9 to 1.234e-8,
 * which is a benefit to this method, because
 * it prevents extra zeros that occur for certain numbers
 * when using moveDecimalAsString
 *
 * Returns a string.
 *
 * v1.5.1 - new
 */
/**
 * @description 미결
 * @param		{String}	origVal
 * @return		{String}
 * @example		미결
 */
function expandExponentialNF(origVal)
{
	if (isNaN(origVal)) return origVal;

	var newVal = parseFloat(origVal) + ''; // parseFloat to let JavaScript evaluate number
	var eLoc = newVal.toLowerCase().indexOf('e');

	if (eLoc != -1) {
		var plusLoc = newVal.toLowerCase().indexOf('+');
		var negLoc = newVal.toLowerCase().indexOf('-', eLoc); // search for - after the e
		var justNumber = newVal.substring(0, eLoc);
		
		if (negLoc != -1) {
			// shift decimal to the left
			var places = newVal.substring(negLoc + 1, newVal.length);
			justNumber = this.moveDecimalAsString(justNumber, true, parseInt(places));
		} else {
			// shift decimal to the right
			// Check if there's a plus sign, and if not refer to where the e is.
			// This is to account for either formatting 1e21 or 1e+21
			if (plusLoc == -1) plusLoc = eLoc;
			var places = newVal.substring(plusLoc + 1, newVal.length);
			justNumber = this.moveDecimalAsString(justNumber, false, parseInt(places));
		}
		
		newVal = justNumber;
	}

	return newVal;
};

/*
 * Move decimal right.
 * Returns a number.
 *
 * v1.5.1 - new
 */
/**
 * @description 미결
 * @param		{String}	val
 * @param		{String}	places
 * @return		{String}
 * @example		미결
 */
function moveDecimalRightNF(val, places)
{
	var newVal = '';
	
	if (places == null) {
		newVal = this.moveDecimal(val, false);
	} else {
		newVal = this.moveDecimal(val, false, places);
	}
	
	return newVal;
};

/*
 * Move decimal left.
 * Returns a number.
 *
 * v1.5.1 - new
 */
/**
 * @description 미결
 * @param		{String}	val
 * @param		{String}	places
 * @return		{String}
 * @example		미결
 */
function moveDecimalLeftNF(val, places)
{
	var newVal = '';
	
	if (places == null) {
		newVal = this.moveDecimal(val, true);
	} else {
		newVal = this.moveDecimal(val, true, places);
	}
	
	return newVal;
};

/*
 * moveDecimalAsString
 * This is used by moveDecimal, and does not run parseFloat on the return value.
 * 
 * Normally a decimal place is moved by multiplying by powers of 10
 * Multiplication and division in JavaScript can result in floating point limitations.
 * So use this method to move a decimal place left or right.
 *
 * Parameters:
 * val - The value to be shifted. Can be a number or a string,
 *  but don't include special characters. It should evaluate to a number.
 * left - If true, then move decimal left. If false, move right.
 * places - (optional) If not included, then use the objects this.places
 *  The purpose is so this method can be used independent of the state of the object.
 *
 * The regular expressions:
 * re1
 * Pad with zeros in case there aren't enough numbers to cover the spaces shift.
 * A left shift pads to the left, and a right shift pads to the right.
 * Can't just concatenate. There might be a negative sign or the value could be an exponential.
 *
 * re2
 * Switch the decimal.
 * Need the first [0-9]+ to force the search to start rightmost.
 * The \.? and [0-9]{} criteria are the pieces that will be switched
 *
 * Other notes:
 * This method works on exponential numbers, e.g. 1.7e-12
 * because the regular expressions only modify the number and decimal parts.
 *
 * Mozilla can't handle [0-9]{0} in the regular expression.
 *  Fix: Since nothing changes when the decimal is shifted zero places, return the original value.
 *
 * IE is incorrect if exponential ends in .
 *  e.g. -8500000000000000000000. should be -8.5e+21
 *  IE counts it as -8.5e+22
 *	Fix: Replace trailing period, if there is one, using replace(/\.$/, '').
 *
 * Netscape 4.74 cannot handle a leading - in the string being searched for the re2 expressions.
 *  e.g. /([0-9]*)(\.?)([0-9]{2})/ should match everything in -100.00 except the -
 *  but it matches nothing using Netscape 4.74.
 *  It might be a combination of the * ? special characters.
 *  Fix: (-?) was added to each of the re2 expressions to look for - one or zero times.
 *
 * Returns a string.
 *
 * v1.5.1 - new
 * v1.5.2 - modified
 */
/**
 * @description 미결
 * @param		{String}	val
 * @param		{String}	left
 * @param		{String}	places
 * @return		{String}
 * @example		미결
 */
function moveDecimalAsStringNF(val, left, places)
{
	var spaces = (arguments.length < 3) ? this.places : places;
	if (spaces <= 0) return val; // to avoid Mozilla limitation
			
	var newVal = val + '';
	var extraZ = this.getZeros(spaces);
	var re1 = new RegExp('([0-9.]+)');
	if (left) {
		newVal = newVal.replace(re1, extraZ + '$1');
		var re2 = new RegExp('(-?)([0-9]*)([0-9]{' + spaces + '})(\\.?)');		
		newVal = newVal.replace(re2, '$1$2.$3');
	} else {
		var reArray = re1.exec(newVal); // v1.5.2
		if (reArray != null) {
			newVal = newVal.substring(0,reArray.index) + reArray[1] + extraZ + newVal.substring(reArray.index + reArray[0].length); // v1.5.2
		}
		var re2 = new RegExp('(-?)([0-9]*)(\\.?)([0-9]{' + spaces + '})');
		newVal = newVal.replace(re2, '$1$2$4.');
	}
	newVal = newVal.replace(/\.$/, ''); // to avoid IE flaw
	
	return newVal;
};

/*
 * moveDecimal
 * Refer to notes in moveDecimalAsString
 * parseFloat is called here to clear away the padded zeros.
 *
 * Returns a number.
 *
 * v1.5.1 - new
 */
/**
 * @description 미결
 * @param		{String}	val
 * @param		{String}	left
 * @param		{String}	places
 * @return		{Number}
 * @example		미결
 */
function moveDecimalNF(val, left, places)
{
	var newVal = '';
	
	if (places == null) {
		newVal = this.moveDecimalAsString(val, left);
	} else {
		newVal = this.moveDecimalAsString(val, left, places);
	}
	
	return parseFloat(newVal);
};

/*
 * getRounded - Used internally to round a value
 * val - The number to be rounded
 * 
 *  To round to a certain decimal precision,
 *  all that should need to be done is
 *  multiply by a power of 10, round, then divide by the same power of 10.
 *  However, occasional numbers don't get exact results in most browsers.
 *  e.g. 0.295 multiplied by 10 yields 2.9499999999999997 instead of 2.95
 *  Instead of adjusting the incorrect multiplication,
 *  this function uses string manipulation to shift the decimal.
 *
 * Returns a number.
 *
 * v1.5.1 - modified
 */
/**
 * @description 미결
 * @param		{String}	val
 * @return		{String}
 * @example		미결
 */
function getRoundedNF(val)
{
	val = this.moveDecimalRight(val);
	val = Math.round(val);
	val = this.moveDecimalLeft(val);
	
	return val;
};

/*
 * preserveZeros - Used internally to make the number a string
 * 	that preserves zeros at the end of the number
 * val - The number
 */
/**
 * @description 미결
 * @param		{String}	val
 * @return		{String}
 * @example		미결
 */
function preserveZerosNF(val)
{
	var i;

	// make a string - to preserve the zeros at the end
	val = this.expandExponential(val);
	
	if (this.places <= 0) return val; // leave now. no zeros are necessary - v1.0.1 less than or equal
	
	var decimalPos = val.indexOf('.');
	if (decimalPos == -1) {
		val += '.';
		for (i=0; i<this.places; i++) {
			val += '0';
		}
	} else {
		var actualDecimals = (val.length - 1) - decimalPos;
		var difference = this.places - actualDecimals;
		for (i=0; i<difference; i++) {
			val += '0';
		}
	}
	
	return val;
};

/*
 * justNumber - Used internally to parse the value into a floating point number.
 * Replace all characters that are not 0-9, a decimal point, or a negative sign.
 *
 *  A number can be entered using special notation.
 *  For example, the following is a valid number: 0.0314E+2
 *
 * v1.0.2 - new
 * v1.5.0 - modified
 * v1.5.1 - modified
 * v1.5.2 - modified
 */
/**
 * @description 미결
 * @param		{String}	val
 * @return		{String}
 * @example		미결
 */
function justNumberNF(val)
{
	newVal = val + '';
	
	var isPercentage = false;
	
	// check for percentage
	// v1.5.0
	if (newVal.indexOf('%') != -1) {
		newVal = newVal.replace(/\%/g, '');
		isPercentage = true; // mark a flag
	}
		
	// Replace everything but digits - + ( ) e E
	var re = new RegExp('[^\\' + this.inputDecimalValue + '\\d\\-\\+\\(\\)eE]', 'g');	// v1.5.2	
	newVal = newVal.replace(re, '');
	// Replace the first decimal with a period and the rest with blank
	// The regular expression will only break if a special character
	//  is used as the inputDecimalValue
	//  e.g. \ but not .
	var tempRe = new RegExp('[' + this.inputDecimalValue + ']', 'g');
	var treArray = tempRe.exec(newVal); // v1.5.2
	if (treArray != null) {
	  var tempRight = newVal.substring(treArray.index + treArray[0].length); // v1.5.2
		newVal = newVal.substring(0,treArray.index) + this.PERIOD + tempRight.replace(tempRe, ''); // v1.5.2
	}
	
	// If negative, get it in -n format
	if (newVal.charAt(newVal.length - 1) == this.DASH ) {
		newVal = newVal.substring(0, newVal.length - 1);
		newVal = '-' + newVal;
	}
	else if (newVal.charAt(0) == this.LEFT_PAREN
	 && newVal.charAt(newVal.length - 1) == this.RIGHT_PAREN) {
		newVal = newVal.substring(1, newVal.length - 1);
		newVal = '-' + newVal;
	}
	
	newVal = parseFloat(newVal);
	
	if (!isFinite(newVal)) {
		newVal = 0;
  }
	
	// now that it's a number, adjust for percentage, if applicable.
  // example. if the number was formatted 24%, then move decimal left to get 0.24
  // v1.5.0 - updated v1.5.1
  if (isPercentage) {
  	newVal = this.moveDecimalLeft(newVal, 2);
  }
		
	return newVal;
};
    // CALC ?? ????? ?????                 
    var ArrFunctions = ["TIMEDIFF",
                     "DAYDIFF", "REPLACE", "WEEKDAY", "SORTDSC",  
                     "DAYADD", "ISNULL", "FORMER", "DAYSOF", "FORMAT",  
                     "INSTR", "ROUND", "FLOOR", "RIGHT", "MONTH", 
                     "FMONY", "FMONM", "COUNT", "RTRIM", "LTRIM",
                     "UCASE", "LCASE", "SPACE",
                     "KLEN", "LENB", "YEAR", "TRIM", "LEFT", 
                     "CEIL" ,"SORT", "TOPN", "LOWN",       
                     "AVG", "MAX", "MIN", "SUM", "ABS", "MOD", 
                     "MID", "VAL", "STR", "DAY", "LEN", "IIF", "NOW", "INT"
                     ];
    var FUNCTION_COUNT = 46;
    var ArrOperaters = ["^",  "*",  "/",  "\\", "MOD", 
                     "%",  "+",  "-",  "+",  "-", 
                     "&",  "<=", "=<", ">=", "=>", 
                     "<>", "!=", "=",  "<",  ">",
                     "BITAND", "BITOR", "LIKE", "NOT", "AND", "OR"];
                     
    var OPERATER_COUNT = 26;
    // LOGIC?? ????? ?????                 
  	var ArrTypes = ["SMALLINT","INTEGER","MONEY","FLOAT","CHAR","TEXT","DATETIME"];

  	/**
  	 * @class	EasyCalc
  	 * @constructor	
  	 * @description	미결
  	 * @param	{object}	pVariables
  	 * @return	{undefined}
  	 * @example	미결
  	 */
function EXOLogic(pVariables)
{
  	this.State = "";
	
  	this.ArrVNames = [];
  	this.ArrVTypes = [];
  	this.ArrVValues = [];
  	this.ArrVScope = [];
  	
  	this.ArrStringValues = [];
  	
  	// 산식 길이별 결과값 모음, 각 산식은 다시 신식을 키로하는 맵이 들어간다
  	this.arrResults = [];
  	
  	var wArrVariables = pVariables.split(";");

  	for (var i = 0; i < wArrVariables.length; i++){
  	  if (wArrVariables[i].trim().length == 0) break;
  	   
  	  var wArrInfo = wArrVariables[i].split(":");
  	  this.ArrVNames[i] = wArrInfo[0].toUpperCase();
  	  this.ArrVTypes[i] = wArrInfo[1].toUpperCase();
  	  this.ArrVValues[i] = wArrInfo[2];
  	  this.ArrVScope [i]= "0";
  	}
  	
  	wArrVariables.Clear();
  	
};
/**
 * @description	미결
 * @param	{object}	pStatement
 * @return  {string}
 * @example	미결
 */
    EXOLogic.prototype.ExecuteLogic = function(pStatement)
    {
        // functionname : [EXOLogic.ExecuteLogic]

    	var wStatement = pStatement + "";
		var wReturn = "";
    	
		// 산식결과값을 기록한다
		var lengthKey = "" + pStatement.length;
		if (!this.arrResults.hasKey(lengthKey)){
			this.arrResults[lengthKey] = [];
		} else {
			var arrResults1 = this.arrResults[lengthKey];
			if (arrResults1.hasKey(pStatement)){
				return arrResults1[pStatement];
			}			
			
		}

		// ????????? ???. 
    	wStatement = decomment(wStatement);
    
    	// ??????? ???? ???? , ??ı? ????? ?????? ??????. 
    	wStatement = this.Str2Temp(wStatement).trim();

    	wStatement = wStatement.replace(/\r\n/g," ").replace(/\t/g," ");
    	while(wStatement.indexOf(" ;") >= 0) wStatement=wStatement.replace(/\s;/g, ";");
    	while(wStatement.indexOf(";;") >= 0) wStatement=wStatement.replace(/;;/g, ";");
    	
    	// ?????? ?м???? ??? ?????????? ?????? ?????? ?????? ???
    	wStatement = wStatement.toUpperCase();
   	    wStatement = this.Statement2Variable(wStatement);

    	// ????????? ??????. 
		var wActionTag = [0];
    	wReturn =  this.ResultOfExecute(wStatement, wActionTag);
		
		this.ArrVNames.Clear();
		this.ArrVTypes.Clear();
		this.ArrVValues.Clear();
		this.ArrVScope.Clear();
		this.ArrStringValues.Clear();
		
		// 산식결과값을 기록한다
		var lengthKey = "" + pStatement.length;
		if (this.arrResults.hasKey()){
			this.arrResults[lengthKey] = [];
		}
		this.arrResults[lengthKey][pStatement] = wReturn;

		return wReturn;
    };
  	
    /**
     * @description	미결
     * @param	{object}	pStatement
     * @param	{object}	pActionTag
     * @return  {object}
     * @example	미결
     */   
    EXOLogic.prototype.ResultOfExecute = function(pStatement, pActionTag)
    {
        // functionname : [EXOLogic.ResultOfExecute]

    	var wStatement = pStatement + ""; 
    	
    	var w_nPoint = 0; var w_nSPoint = 0; 
    	var  w_nEPoint = 0;
    	
    	var wLogicUnit = ""; var wReturn = ""; 
    	var wLeft = ""; var wRight = "";
    	
    	
        wStatement = wStatement.trim();
		var wLength = [wStatement.length];
		
        if (!wStatement.endsWith(";")) wStatement = wStatement + ";";

    	while (true){
    		var wIsSimpleStatement = true;
            var wCutPos = new Array(99);
            
    		// IF ?????? ????? ?????? ??????. ?????? 
    		if (wStatement.startsWith("IF ")) {
    			if (this.IsIfLoop(wStatement, wLength, wCutPos)){
    				wIsSimpleStatement = false;
    				wLogicUnit = wStatement.substring(0, wLength[0]).trim();
                    
                    if (wLogicUnit.endsWith(";")) 
                        wLogicUnit = wLogicUnit.substring(0, wLogicUnit.length - 1);
    
    				wReturn = this.ResultOfIf(wLogicUnit, wCutPos, pActionTag);

    				if (pActionTag[0] == 1 || pActionTag[0] == 2) break;
    			}
    		
    		// FOR?????? ????? ?????? ??????.(??????) 
    		} else if (wStatement.startsWith("FOR ")){
    			if (this.IsForLoop(wStatement, wLength, wCutPos)){
    				wIsSimpleStatement = false;
    				wLogicUnit = wStatement.substring(0, wLength[0]).trim();
                    
                    if (wLogicUnit.endsWith(";")) 
                        wLogicUnit = wLogicUnit.substring(0, wLogicUnit.length - 1);
    
    				wReturn = this.ResultOfFor(wLogicUnit, wCutPos);
    			}
    		
    		// WHILE?????? ????? ?????? ??????.(??????) 
    		} else if (wStatement.startsWith("WHILE ")) {
    			if (this.IsWhileLoop(wStatement, wLength, wCutPos)){
    				wIsSimpleStatement = false;
    				wLogicUnit = wStatement.substring(0, wLength[0]).trim();
                    
                    if (wLogicUnit.endsWith(";")) 
                        wLogicUnit = wLogicUnit.substring(0, wLogicUnit.length - 1);
    				wReturn = this.ResultOfWhile(wLogicUnit, wCutPos);
    			}
    		}
    
    		// ??????д????? ??????? ( ":=" ?? ?¿쿬??)
    		if (wIsSimpleStatement) {
    			w_nPoint = wStatement.indexOf(";");					// ????????? ????? ?????? 
    			if (w_nPoint == -1) break;							// ??????? ????????? ?????? ?????? 
    
    			wLogicUnit = wStatement.substring(0, w_nPoint).trim();		// ??????? ?????. 
    			if (wLogicUnit.length > 0){					        // ????? ?????? ????????? ??? 
    				w_nPoint = wLogicUnit.indexOf(":=");			// ??????? ??? ??? o?? 
    				if (w_nPoint != -1) {
    					w_nSPoint = w_nPoint + 2;
    					w_nEPoint = wLogicUnit.length;
    
    					wLeft = wLogicUnit.substring(0, w_nPoint).trim();
    					wRight = wLogicUnit.substring(w_nSPoint, w_nEPoint).trim();

    					wReturn = this.CalcFormula(wRight);
    					this.SetVariable(wLeft, wReturn);
    				
    				} else if (wLogicUnit == "CONTINUE") {
    					pActionTag[0] = 1;
    
    				} else if (wLogicUnit == "BREAK") {
    					pActionTag[0] =  2;
    
    				} else {                                         // ??????? ??? ????? o?? 
    					wReturn = this.CalcFormula(wLogicUnit);
    				}
    			} else {
    				wReturn = "";
    			}
    
    		}
    		if (wIsSimpleStatement) {
    			wStatement = replaceFirstOne(wStatement, wLogicUnit + ";", "").trim();
    		} else {
   			wStatement = replaceFirstOne(wStatement, wLogicUnit, "").trim();
    		}
            
            // ????? ??????? ?????? ??????. 
    		if (wStatement.length == 0 || wStatement == ";" ) break;
    	}
    	return wReturn;
    };
    
    /* =============================================================
    	IF  ?????? ???? : IF ... THEN ( ... ) ELSE ( ...) -> ...???? ???μ????? ?????.
    	????? IF??           : If ...THEN ...ELSE ...;  -> ...???? ?ĸ? ???????. 
       =============================================================*/
    /**
     * @description	미결
     * @param	{object}	pStatement
     * @param	{number}	pLength
     * @param	{object}	pArrCutPos
     * @return  {boolean}
     * @example	미결
     */
    EXOLogic.prototype.IsIfLoop = function(pStatement, pLength, pArrCutPos)
    {
        // functionname : [EXOLogic.IsIfLoop]

    	var wStart = 0; var wPosition = 0; var wPosition1 = 0;
    	
    	// ????? ???????? ???? ???? 
    	wStart = pStatement.indexOf("IF ");
    	var w_bCompleted = false;
    	var wReturn = true;
    	var w_nArrNum = 0;
    
    	// ???? ??| ????? THEN?? a?´?. 
    	// ????????? IF?? THEN??????? IF?? ????? ?????. ????? ????? ?????? ??? ???? ???. 
    	// ??? ????? THEN ???? ???? ???? ??? ????? ?????????Ŀ? a?? ?? 
    	while (true){
    		pArrCutPos[++w_nArrNum] = wStart + 3;
    
    		wPosition = pStatement.indexOf(" THEN", wStart);
    		wPosition1= pStatement.indexOf("(", wStart);
    				wIsSimpleStatement = false;
    		
    		while (wPosition1 >= 0 && wPosition > wPosition1){
    			wPosition1 = endOfBracket(pStatement, wPosition1);
    			wPosition = pStatement.indexOf(" THEN", wPosition1);
    			wPosition1= pStatement.indexOf("(",wPosition1);
    		}
    		
    		pArrCutPos[++w_nArrNum] = wPosition - 1;
    
    		//THEN ?????? ????? ?????? "IF ????"???. 
    		wPosition = findNext(pStatement, "(", wPosition + 5);
    		if (wPosition == -1) {
    			wReturn = false;
    			break;
    		}
    		pArrCutPos[++w_nArrNum] = wPosition + 1;
    		// THEN ?? ????? ?????? ?????? a?´? 
    		wPosition = endOfBracket(pStatement, wPosition);
    		pArrCutPos[++w_nArrNum] = wPosition - 1;
    
    		// ?? ?????? ELSE ???? ??????. ?????? ??? ?????. 
    		// ELSE ???  IF ?? ????? ?????? ?????? "("?? a?? ??????? ?????? ????? 
    		// ?????? ??? IF ???? ?????? ????. 
    		wPosition1 = wPosition + 1;
    		wPosition = pStatement.indexOf(" ELSE", wPosition);
   		
    		if (wPosition == -1) {
    			pLength[0] = wPosition1;
    			w_bCompleted = true;
    		} else {
    			wPosition += 5;


    			wPosition1 = findNext(pStatement, "IF ", wPosition);
    			if (wPosition1 == -1){
    				wPosition1 = findNext(pStatement, "(", wPosition);
    				if (wPosition == -1) {
    					w_bCompleted = true;
    					wReturn = false;
    					break;
    				}
    				pArrCutPos[++w_nArrNum] = wPosition1 + 1;
    
    				wPosition = endOfBracket(pStatement, wPosition1);
    				pArrCutPos[++w_nArrNum] = wPosition - 1;
    
    				pLength[0] = wPosition +1;
    				w_bCompleted = true;
    
    			} else {
    				wStart = wPosition1;
    			}
    		}
			
    		if (w_bCompleted) break;

    	}
    
    	pArrCutPos[0] = w_nArrNum;
    	return wReturn;
    };
    
    /* ==========================================================
    	For???? ???? :  
    		FOR X = 1 TO 31 STEP 1  ( ... )
    		FROM?? TO?? ?????? ?????? ?????????? ??????? STEP????? 
    		???? ???????? ???. STEP???? ???? ??????? ?????????. 
    		LOOP????? CONTINUE?? BREAK????? ???????. 
       ==========================================================*/
    /**
     * @description	미결
     * @param	{object}	pStatement
     * @param	{number}	pLength
     * @param	{object}	pArrCutPos
     * @return  {boolean}
     * @example	미결
     */
    EXOLogic.prototype.IsForLoop = function(pStatement, pLength, pArrCutPos)
    {
        // functionname : [EXOLogic.IsForLoop]

    	// ????? ???????? ???? ???? 
    	var w_nStart = pStatement.indexOf("FOR ");
    	var w_nArrNum = 0;
    	var w_bReturn = true;
    
    	// ???? ??| ????? TO?? a?´?. 
    	pArrCutPos[++w_nArrNum] = w_nStart + 4;
    
    	var w_nPosition = pStatement.indexOf(" TO ", w_nStart);
    	if (w_nPosition == -1) {
    		return false;
    	}
    
    	pArrCutPos[++w_nArrNum] = w_nPosition - 1;
    
    	//  STEP?? ????? a?´?. 
    	pArrCutPos[++w_nArrNum] = w_nPosition + 4;
    
    	w_nPosition = pStatement.indexOf(" STEP ", w_nPosition);
    	pArrCutPos[++w_nArrNum] = w_nPosition - 1;
    
    	// "(" ?? ????? a?´?. 
    	pArrCutPos[++w_nArrNum] = w_nPosition + 6;
    
    	w_nPosition = pStatement.indexOf("(", w_nPosition);
    	pArrCutPos[++w_nArrNum] = w_nPosition - 1;
    
    	//??????? ")"?? ????? a?´?. 
    	pArrCutPos[++w_nArrNum] = w_nPosition + 1;
    	w_nPosition = endOfBracket(pStatement, w_nPosition);
    	pLength[0] = w_nPosition - w_nStart + 1;
    	pArrCutPos[++w_nArrNum] = w_nPosition - 1;
    
    	pArrCutPos[0] = w_nArrNum;
    
    	return w_bReturn;
    };
    
    /* ==========================================================
    	While???? ???? :
    		WHILE ( ... ) ( ... )
    		LOOP????? CONTINUE?? BREAK????? ???????. 
       ==========================================================*/
    /**
     * @description	미결
     * @param	{object}	pStatement
     * @param	{number}	pLength
     * @param	{object}	pCutPos
     * @return  {boolean}
     * @example	미결
     */
    EXOLogic.prototype.IsWhileLoop = function(pStatement, pLength, pCutPos)
    {
        // functionname : [EXOLogic.IsWhileLoop]

    	// ????? ???????? ???? ???? 
    	var w_nStart = pStatement.indexOf("WHILE ");
    	var w_nArrNum = 0;
    	var w_bReturn = true;
    
    	// ???? ??| ????? "("?? a?´?. 
    	var w_nPosition = pStatement.indexOf("(", w_nStart);
    	if (w_nPosition == -1) {
    		return false;
    	}
    
    	//??????? ")"?? ????? a?´?. 
    	pCutPos[++w_nArrNum] = w_nPosition + 1;
    	w_nPosition = endOfBracket(pStatement, w_nPosition);
    	pCutPos[++w_nArrNum] = w_nPosition - 1;
    
    	// ???? ?????? ?????? ????? "("?? a?´?. 
    	w_nPosition = pStatement.indexOf("(", w_nPosition);
    	if (w_nPosition == -1) {
    		return false;
    	}
    
    	//??????? ")"?? ????? a?´?. 
    	pCutPos[++w_nArrNum] = w_nPosition + 1;
    	w_nPosition = endOfBracket(pStatement, w_nPosition);
    	pLength[0] = w_nPosition - w_nStart +1;
    	pCutPos[++w_nArrNum] = w_nPosition - 1;
    
    	pCutPos[0] = w_nArrNum;
    
    	return w_bReturn;
    };
    
    /* ==========================================================
       p_nCutPos???? 0?? ?迭 ???? , 
       [???? ????, ??, True?? ???? ??]?? ??? ??????? 
       ???????? False?? ???? ?????? ??????. 
       ==========================================================*/
    /**
     * @description	미결
     * @param	{object}	pStatement
     * @param	{object}	pCutPos
     * @param	{object}	pActionTag
     * @return  {string}
     * @example	미결
     */
    EXOLogic.prototype.ResultOfIf = function(pStatement, pCutPos, pActionTag)
    {
        // functionname : [EXOLogic.ResultOfIf]

    	var wReturn = "";
    	var wCount = pCutPos[0];
    	var wArrNum = 0;
    
    	pActionTag[0] = 0;
    	while (wArrNum < wCount){
    		var wPosition1 = pCutPos[++wArrNum];
    		var wPosition2 = pCutPos[++wArrNum];
    		var wStatement = pStatement.substring(wPosition1, wPosition2 + 1);
			
    		var wTemp = this.CalcFormula(wStatement);
    		if (wTemp != "0"){
    			wPosition1 = pCutPos[++wArrNum];
    			wPosition2 = pCutPos[++wArrNum];
    
    			wStatement = pStatement.substring(wPosition1, wPosition2 + 1);
				
    			wReturn = this.ResultOfExecute(wStatement, pActionTag);
    			break;
    
    		} else {
    			if (wArrNum == wCount - 2){				// False???? ??? ??? 
    					wReturn = "";
    					break;
    			} else if (wArrNum == wCount - 4){      //False???? ??? ??? 
    				wArrNum += 2;
    				wPosition1 = pCutPos[++wArrNum];
    				wPosition2 = pCutPos[++wArrNum];
    
    				wStatement = pStatement.substring(wPosition1, wPosition2 + 1);


    				wReturn = this.ResultOfExecute(wStatement, pActionTag);
    				break;
    
    			} else {
    				wArrNum += 2;
    			}
    		}
    	}
    
    	return wReturn;
    };
    
    /**
     * @description	미결
     * @param	{object}	pStatement
     * @param	{object}	pCutPos
     * @return  {string}
     * @example	미결
     */
    EXOLogic.prototype.ResultOfFor = function(pStatement, pCutPos)
    {
        // functionname : [EXOLogic.ResultOfFor]

    	var wReturn = ""; 
    	var w_nCount = pCutPos[0];
    	var wArrNum = 0;
    	var wActionTag = [0];
    
    	// ???? ???? ??????? ??????. 
    	var wPosition1 = pCutPos[++wArrNum];
    	var wPosition2 = pCutPos[++wArrNum];
    	var wStatement = pStatement.substring(wPosition1, wPosition2 + 1);
    
    	wPosition1 = wStatement.indexOf("=");
    	var wCritVName = wStatement.substring(0,wPosition1).trim();
    
    	wStatement = wStatement.substring(wPosition1 + 1).trim();


    	if (!isNumeric(wStatement)){
    		wStatement = this.CalcFormula(wStatement);
    	}

    	var wStartVal = val(wStatement);
    	// TO ?????? ?????? 
    	wPosition1 = pCutPos[++wArrNum];
    	wPosition2 = pCutPos[++wArrNum];
    	wStatement = pStatement.substring(wPosition1, wPosition2 + 1);
    
    	if (!isNumeric(wStatement)){
    		wStatement = this.CalcFormula(wStatement);
    	}
    	var w_dblEndVal = val(wStatement);
    
    	// STEP?????? ??????. 
    	wPosition1 = pCutPos[++wArrNum];
    	wPosition2 = pCutPos[++wArrNum];
    	wStatement = pStatement.substring(wPosition1, wPosition2).trim();
    	var w_dblStepVal = val(wStatement);
    
    	// ?????? ??????. 
    	wPosition1 = pCutPos[++wArrNum];
    	wPosition2 = pCutPos[++wArrNum];
    	wStatement = pStatement.substring(wPosition1, wPosition2).trim();
    
    	// ?????? ???? ?????? ???????. 
    	var w_dblVVar = wStartVal;
    	this.SetVariable(wCritVName, w_dblVVar + "");

    	while (true){
    		if (w_dblStepVal >= 0.0){
    			if (w_dblVVar > w_dblEndVal) break;
    		} else {
    			if (w_dblVVar < w_dblEndVal) break;
    		}
    
    		wReturn = this.ResultOfExecute(wStatement, wActionTag);

    		if (wActionTag[0] == 2) break;  //???? Continue(1)?? ????????? ?????? ???????? ?????. 
    
    		w_dblVVar += w_dblStepVal;
    		this.SetVariable(wCritVName, w_dblVVar + "");
    	}
    
    	return wReturn;
    };
    
    /**
     * @description	미결
     * @param	{object}	pStatement
     * @param	{object}	pCutPos
     * @return  {string}
     * @example	미결
     */
    EXOLogic.prototype.ResultOfWhile = function (pStatement, pCutPos)
    {
        // functionname : [EXOLogic.ResultOfWhile]

    	var wReturn = "";
    	var w_nCount = pCutPos[0];
    	var wArrNum = 0;
    	var wActionTag = [0];
    	
    	// ???? ???? ??????? ??????. 
    	var wPosition1 = pCutPos[++wArrNum];
    	var wPosition2 = pCutPos[++wArrNum];
    	var wCritStatement = pStatement.substring(wPosition1, wPosition2 + 1);
    
    	wPosition1 = pCutPos[++wArrNum];
    	wPosition2 = pCutPos[++wArrNum];
    	var wStatement = pStatement.substring(wPosition1, wPosition2 + 1);
    
    	// ?????? ???? ?????? ???????. 
    	var wRsltStatement = this.ResultOfExecute(wCritStatement, wActionTag);
    	while (wRsltStatement != "0"){
    		wReturn = this.ResultOfExecute(wStatement, wActionTag);
    		if (wActionTag[0] == 2) break;  //???? Continue(1)?? ????????? ?????? ???????? ?????. 
    		
    		wRsltStatement = this.ResultOfExecute(wCritStatement, wActionTag);
    	}
    
    	return wReturn;
    };
	
    /**
     * @description	미결
     * @param	{object}	pStatement
     * @return  {string}
     * @example	미결
     */
    EXOLogic.prototype.CalcFormula = function(pStatement)
    {
        // functionname : [EXOLogic.CalcFormula]

    	var wReturn = pStatement + "";
    	wReturn = this.Temp2ClacStr(this.ReplaceVariable(wReturn));
    
    	if (!isNumeric(wReturn)){
	        var wCalculator = new EXOCalculator();
    		wReturn = wCalculator.CalcuratedResult(wReturn);
    	}
    	return wReturn;
    };
    
    /**
     * @description	미결
     * @param	{object}	pStatement
     * @return  {string}
     * @example	미결
     */
    EXOLogic.prototype.Statement2Variable = function(pStatement)
    {
        // functionname : [EXOLogic.Statement2Variable]

    	var wStatement = pStatement + "";
    	while (wStatement.indexOf("GLOBAL  ") >= 0) {
    		wStatement = wStatement.replaceWord("GLOBAL  ","GLOBAL ");
    	}
    
    	for (var j = 0; j <= 1; j++){     // 0:?? ???? 1: ???????? 
    		for (i = 0; i < ArrTypes.length; i++){
    			var wType = ArrTypes[i];
    
    			var wPosition = 0;
    			while (true) {
    			    var wSearchName = (j == 0 ? "GLOBAL " + wType : wType) + " ";

    				wPosition = wStatement.indexOf(wSearchName, wPosition);
    				if (wPosition == -1) break;
    
    				var wSPosition = wPosition + wSearchName.length;
    
    				// ?????? ??????? ??????. 
    				wPosition1 = wStatement.indexOf(":= ", wSPosition);
    				wPosition2 = wStatement.indexOf(";", wSPosition);
    				
    				wPosition = (wPosition1 > 0 ? wPosition1 : wPosition2);
    
    				if (wPosition < 0) 
    					wPosition	= wStatement.length;
    
    				var wEPosition = wPosition - 1;
    
    				// ???????? ??????? 
    				var wName = wStatement.substring(wSPosition, wEPosition + 1).trim();
    
    				// ?????? ??????. 
    				this.AddVariable(wType, wName, j);
    			}
    			// ????θ? ??? ???????.
    			wStatement = wStatement.replaceWord(wSearchName, "");
    		}
    	}
        
    	return wStatement;
    };
    
    /**
     * @description	미결
     * @param	{string}	pType
     * @param	{string}	pName
     * @param	{object}	pScope
     * @return  {void}
     * @example	미결
     */
    EXOLogic.prototype.AddVariable = function(pType, pName, pScope)
    {
        // functionname : [EXOLogic.AddVariable]

    	// length????? ??????? ?????? ???? ?þ???
    	var wVariablesIndex = this.ArrVTypes.length; 

        this.ArrVTypes[wVariablesIndex] = pType;
    	this.ArrVNames[wVariablesIndex] = pName;
    	this.ArrVValues[wVariablesIndex] = "";
    	this.ArrVScope[wVariablesIndex] = pScope + "";

    	return;
    };
    
    /**
     * @description	미결
     * @param	{string}	pName
     * @param	{string}	pValue
     * @return  {string}
     * @example	미결
     */
    EXOLogic.prototype.SetVariable = function(pName, pValue)
    {
        // functionname : [EXOLogic.SetVariable]

    	var wFound = false;
    	var wVariablesIndex = -1;
    	
    	for (var i = 0; i < this.ArrVNames.length; i++){
    		if (pName == this.ArrVNames[i]){
    			wVariablesIndex = i;
    			wFound = true;
    			break;
    		}
    	}
    
    	if (!wFound) {
    	    this.State = getText("message_easycalc_001", "Error raised from EasyMaker Logic Engine's \"SetVariable\" routine \n \"{0}\" variable is not correct \n", [pName]);
    	} else {
    		this.ArrVValues[wVariablesIndex] = pValue;
    	}
    
    	return;
    };
    
    /*
    EXOLogic.prototype.GetVariable = function(pName)
    {
        // functionname : [EXOLogic.GetVariable]

    	var w_bFound = false;
    	var wRerurn = "";
    	var wVariablesIndex = -1;
    	
    	for (var i = 0; i < this.ArrVNames.length; i++){
    		if (pName == this.ArrVNames[i]){
    				wVariablesIndex = i;
    				w_bFound = true;
    				break;
    		}
    	}
    
    	if (!w_bFound) {
    	    this.State = "Error raised from EasyMaker Logic Engine's \"GetVaiable\" routine \r\n"
    	          + pName + " variable is not correct \r\n";
    	} else {
    		wRerurn = this.ArrVValues[wVariablesIndex];
    	}
    
    	return wRerurn;
    }
    */
    
    /**
     * @description	미결
     * @param	{object}	pStatement
     * @return  {string}
     * @example	미결
     */
    EXOLogic.prototype.ReplaceVariable = function(pStatement)
    {
        // functionname : [EXOLogic.ReplaceVariable]

    	var wStatement = pStatement + "";
    	if (isNumeric(wStatement) || pStatement == "#")
    		return wStatement;
    	
    	for (wLength = 30; wLength > 0; wLength--){
    		for (i = this.ArrVNames.length - 1; i >= 0; i--){
    			if (wLength == this.ArrVNames[i].length){
    			    var wName = this.ArrVNames[i];
    				var wType = this.ArrVTypes[i];
    				var wValue = this.ArrVValues[i];
    
    				if (wType == "CHAR" || wType == "TEXT") {
    				    wValue = "\"" + wValue + "\"";
    				}
    
    				wStatement = wStatement.replaceWord(wName, wValue);
    			}
    		}
    	}
    	return wStatement;
    };
    
    /*
    EXOLogic.prototype.GetVariableInfo = function()
    {
        // functionname : [EXOLogic.GetVariableInfo]

    	var wReturn = "";
    	for (i = this.ArrVNames.length - 1; i >= 0; i--){
    		if (this.ArrVScope[i] != "0") continue;
            wReturn += this.ArrVTypes[i] + ":" + this.ArrVNames[i] + ":" + this.ArrVValues[i] + ";";
    	}
    	return wReturn;
    };
    */
    
    /**
     * @description	미결
     * @param	{object}	pStatement
     * @return  {string}
     * @example	미결
     */
	EXOLogic.prototype.Str2Temp = function(pStatement)
	{
        // functionname : [EXOLogic.Str2Temp]

		var wStatement = pStatement + "";
		if (pStatement.indexOf("\"") == 0) return wStatement;
	
		this.ArrStringValues = [];
		
		var wArrStringValues = cutString(pStatement, "\"", "\"");
		
		for (var i = 0; i < wArrStringValues.length ; i++){
  		    this.ArrStringValues[i + 1] = wArrStringValues[i];
 			
 			var wTemp = "\"" + wArrStringValues[i] + "\"";
 			var wTemp1 = "STR_" + (i + 1);
 			wStatement = replaceFirstOne(wStatement, wTemp, wTemp1);
		}
			
		return wStatement;
	};
    
	/**
     * @description	미결
     * @param	{object}	pStatement
     * @return  {string}
     * @example	미결
     */ 
    EXOLogic.prototype.Temp2ClacStr = function(pStatement)
    {
        // functionname : [EXOLogic.Temp2ClacStr]

 		var wStatement = pStatement + "";

		for(var i = this.ArrStringValues.length - 1; i > 0; i--){
			var wTemp = "STR_" + i;
			wStatement = wStatement.replaceWord(wTemp, "\"" + this.ArrStringValues[i] + "\"");
	
			if (wStatement.indexOf("STR_") == -1) break;
		}
		return wStatement;
    };
    
    /**
    *     @description	미결
    *     @param	{object}	pStatement
    *     @param	{object}	pPosition
    *     @return	{number}
    *     @example	미결
    */
    function endOfBracket(pStatement, pPosition)
    {
    	var wReturn = 0;
    	var wLevel = 0;
    	var wBitStart = pPosition + 1;
    	var wBitEnd = 0;
    	var wCompleted = false;
    
    	if (pStatement.indexOf(")", pPosition + 1) == -1) return -1;
    
    	while(!wCompleted){
    		wBitEnd = pStatement.indexOf(")", wBitStart);
    		wBitStart = pStatement.indexOf("(", wBitStart);
    		
    		if (wBitStart == -1){
    			if (wLevel == 0) {
    				wCompleted = true;
    				wReturn = wBitEnd;
    			} else {
    				wBitStart = wBitEnd + 1;
    				wLevel--;
    			}
    		} else {
    			if (wBitStart > wBitEnd) {
    				if (wLevel == 0) {
    					wReturn = wBitEnd;
    					wCompleted = true;
    				} else {
    					wBitStart = wBitEnd + 1;
    					wLevel--;
    				}
    			} else {
    				wBitStart ++;
    				wLevel ++;
    			}
    		}
    	}
    
    	return wReturn;
    };
    
    /**
     * @class	EasyCalc
     * @constructor
     */	
function EXOCalculator() {
    this.State = "";
    this.StringValues = [];
    this.StringCount = 0;
};
/**
*     @description	미결
*     @return	{number}
*     @example	미결
*/
    EXOCalculator.prototype.test = function(){
        // functionname : [EXOCalculator.test]

	    //return Min("11","3","4","5","6","7","89","9","10","11");
	    return minOf(11,3,4,5,6,7,89,9,10,11);
    };
    
    /**
    *     @description	미결
    *     @param	{object}	pFormula
    *     @return	{string}
    *     @example	미결
    */
    EXOCalculator.prototype.CalcuratedResult = function(pFormula){
        // functionname : [EXOCalculator.CalcuratedResult]

        if (pFormula.length == 0) return "";
                           
        var wFormula = this.Str2Temp(pFormula);
        wFormula = decomment(wFormula); //??????? ???? 
        wFormula = wFormula.replace(/\r\n/g," ").toUpperCase(); //?????? ???? 
        
        var w_haveCondition = (wFormula.indexOf("IF ") != -1 && wFormula.indexOf(" THEN") != -1);
        if (!w_haveCondition){                 //??????? ???. 
            wFormula = this.Calcurate(wFormula);

        } else {
    	    var trueStatement = ""; 
    	    var falseStatement = "";
	        var wlCompleted = false;
    	    
            while (!wlCompleted){
                var IfPosition = wFormula.indexOf("IF ");
                var ThenPosition = wFormula.indexOf(" THEN");
	            var ElsePosition = 0;
                var wLength = wFormula.length;

                var CritStatement = wFormula.substring(IfPosition + 3, ThenPosition + 1);
                if (wFormula.indexOf(" ELSE") != -1){
                    ElsePosition = wFormula.indexOf(" ELSE");
                    var wPoint = minOf(ElsePosition - 1, wLength); 
                    trueStatement = wFormula.substring(ThenPosition + 5, wPoint + 2);
                    falseStatement = wFormula.substring(ElsePosition + 5, wLength);
                } else {
                    trueStatement = wFormula.substring(ThenPosition + 5, wLength);
                    falseStatement = "0";
                }

                var wWorkBuff = this.Calcurate(CritStatement);
                if (wWorkBuff == "-1"){
                        wFormula = this.Calcurate(trueStatement);
                        wlCompleted = true;
                } else if (falseStatement.indexOf("IF ") == -1 && 
                           falseStatement.indexOf(" THEN") == -1){
                        wFormula = this.Calcurate(falseStatement);
                        wlCompleted = true;
                } else {
                        wFormula = falseStatement;
                }
            }
        }
        wFormula = this.Temp2Str(wFormula);
        this.StringValues.Clear();
	
	    return wFormula;
	};
	
	/**
     * @description	미결
     * @param	{object}	pFormula
     * @return  {object}
     * @example	미결
     */
    EXOCalculator.prototype.Calcurate = function(pFormula)
	{
        // functionname : [EXOCalculator.Calcurate]

	
        var wFormula = pFormula.trim();
        while (wFormula.indexOf(" (") >= 0)
        	wFormula = wFormula.replace(/ \(/g, "(");
        
       //????? ????? ?????? ??? ?????? ??????? ???? ??u??? 
        var p1 = 0; var p2 = 0;
        while (wFormula.indexOf("(") != -1){
            var wlReplaced = false;
            var p = wFormula.indexOf('(');
            var p1 = 0; 
            var p2 = 0;

            while(p != -1){
                p1 = p;
                p2 = wFormula.indexOf(')', p1);
                p = wFormula.indexOf('(', p1 + 1);
                if (p > p2) break;
            }

            for (var i = 0; i < FUNCTION_COUNT; i++){
                var wFunc = ArrFunctions[i];
                var wLength = wFunc.length;

                if (p1 >= wLength){
                    if (wFunc == wFormula.substring(p1- wLength, p1)){
                        var wOpTarget = wFormula.substring(p1 - wLength, p2 + 1);
                        var wTempResult = this.FuncOperate(wOpTarget);
                        wFormula = replaceFirstOne(wFormula, wOpTarget, wTempResult);

                        wlReplaced = true;
                        break;
                    }
                }
            }

            if (!wlReplaced){
                var wOpTarget = wFormula.substring(p1, p2 + 1);
                var wLength = wOpTarget.length;
                var wOpObject = wOpTarget.substring(1, wLength - 1);

                var wTempResult = this.MultiOperate(wOpObject);

                wFormula =replaceFirstOne(wFormula, wOpTarget, wTempResult);
            }
        }

        wFormula = wFormula.trim();

        if (!wFormula.isNum()){
            var wlCompleted = false;
            if (wFormula.startsWith("STR_"))
                wlCompleted = wFormula.substring(4).isNum();
            if (!wlCompleted) 
                wFormula = this.MultiOperate(wFormula);
        }

	    return wFormula;
	};
	
	/**
     * @description	미결
     * @param	{object}	pFormula
     * @return  {string}
     * @example	미결
     */
    EXOCalculator.prototype.MultiOperate = function(pFormula)
	{
        // functionname : [EXOCalculator.MultiOperate]

        if (pFormula.isNum()) return pFormula;
        if (pFormula.startsWith("STR_") && pFormula.substring(4).isNum()) return pFormula;

        var wFormula = pFormula.replaceWord(" ", "");
        if (wFormula.indexOf("NOT") != -1){
            wFormula = wFormula.replaceWord("NOT"," NOT ");
        }
        if (wFormula.indexOf("TRUE") != -1){
            wFormula = wFormula.replaceWord("TRUE", "-1");
        }
        if (wFormula.indexOf("FALSE") != -1){
            wFormula = wFormula.replaceWord("FALSE", "0");
        }
        
        var wBitStart = 0; var wBitEnd = 0;
        var wFound = false; 

        for (var OperateNum = 0; OperateNum < OPERATER_COUNT; OperateNum++){
            var Operater = ArrOperaters[OperateNum];

            var wIsAddSub = (Operater == "+" || Operater == "-");
            var StartPos = 1;
            var OperaterPos = wFormula.indexOf(Operater, StartPos);
            while (OperaterPos >= 0){
                if (wIsAddSub && isSign(wFormula, OperaterPos)){
                        StartPos = OperaterPos + 1;
                        OperaterPos = wFormula.indexOf(Operater, StartPos);
                        continue;
                }

                wFound = false;
                for (var i = OperaterPos - 1; i >= 0 ; i--){
                    wBitStart = 0;
                    if (wFormula.charAt(i) >= '0' && wFormula.charAt(i) <= '9') continue;
                    if (wFormula.charAt(i) == '+' || wFormula.charAt(i) == '-'){
                        if (wIsAddSub){
                            wBitStart = i;
                            break;
                        } else if (!isSign(wFormula, i)){
                            wBitStart = i + 1;
                            break;
                        }
                    }
                    
                    for (var j = 0; j < OPERATER_COUNT; j++){
                        var wTempOp = ArrOperaters[j];
                        if (wFormula.charAt(i) != wTempOp.charAt(0)) continue;
                        if (wTempOp.charAt(0) == '+' || wTempOp.charAt(0) == '-') continue;

                        var wTempLength = wTempOp.length;
                        if (wFormula.substring(i).startsWith(wTempOp)){
                            wBitStart = i + wTempLength;
                            wFound = true;
                            break;
                        }
                    }
                    if (wFound) break;
                }

                var wLength = wFormula.length;

                wFound = false;
                for (var i = OperaterPos + Operater.length; i < wLength; i++){
                    wBitEnd = wLength - 1;
                    if (wFormula.charAt(i) >= '0' && wFormula.charAt(i) <= '9') continue;

                    for (var j = 0; j < OPERATER_COUNT; j++){
                        var wTempOp = ArrOperaters[j];
                        if (wFormula.charAt(i) != wTempOp.charAt(0)) continue;
                        if ((wTempOp.charAt(0) == '+' || wTempOp.charAt(0) == '-') && 
                            isSign(wFormula, i)) continue;

                        if (wFormula.substring(i).startsWith(wTempOp)){
                            wBitEnd = i - 1;
                            wFound = true;
                            break;
                        }
                    }
                    if (wFound) break;
                }
                var OperateTaget = wFormula.substring(wBitStart, wBitEnd + 1);
                if (Operater != "NOT") 
                    OperateTaget = OperateTaget.trim();

                StartPos = wFormula.indexOf(OperateTaget); 
                var wTemp = this.BaseOperate(OperateTaget, Operater);
                wFormula = replaceFirstOne(wFormula, OperateTaget, wTemp);

                if (wFormula.indexOf("+-") != -1){
                    wFormula = wFormula.replace(/\+\-/g, "-");
                }
                if (wFormula.indexOf("--") != -1){
                    wFormula = wFormula.replace(/\-\-/g, "-");
                }
                OperaterPos = wFormula.indexOf(Operater, StartPos);
                if (OperaterPos == -1 && (wFormula.charAt(0) == '+' || wFormula.charAt(0) == '-'))
                    OperaterPos = wFormula.indexOf(Operater, 1);
            }
        }
        if (wFormula.charAt(0) == '+'){
            wFormula = wFormula.substring(1);
        }
	
	    return wFormula;
	    
	};
	
	/**
     * @description	미결
     * @param	{object}	pFormula
     * @param	{string}	pOprater
     * @return  {string}
     * @example	미결
     */
    EXOCalculator.prototype.BaseOperate = function(pFormula, pOprater)
	{
        // functionname : [EXOCalculator.BaseOperate]

	    if (pFormula.indexOf(pOprater, 1) == -1) return pFormula;
	    
	    var  wReturn = "";
	    
        var wFormula = (pOprater != "NOT" ? pFormula.trim() : pFormula);
        var OperaterPosition = wFormula.indexOf(pOprater, 1);
        
        var s1 = wFormula.substring(0, OperaterPosition).trim();
        var s2 = wFormula.substring(OperaterPosition + pOprater.length).trim();
        if (s1.startsWith("+")) s1 = s1.substring(1);
        if (s2.startsWith("+")) s2 = s2.substring(1);

        if (pOprater.charAt(0) == '&' || 
            s1.startsWith("STR_") || s2.startsWith("STR_")){
            if (pOprater.charAt(0) == '+') pOprater = "&";
            wReturn = this.StringOperate(s1, s2, pOprater);

        } else {
            var v1 = (s1.length != 0 ? parseFloat(1 * s1) : 0.0);
            var v2 = (s2.length != 0 ? parseFloat(1 * s2) : 0.0);
            if (pOprater.charAt(0) == '+'){
                    wReturn = fncPlus(s1, s2);
            } else if (pOprater.charAt(0) == '-'){
                    wReturn = fncMinus(s1, s2);
            } else if (pOprater.charAt(0) == '*'){
                    wReturn = fncMultiply(s1, s2);
            } else if (pOprater.charAt(0) == '/'){
                    if (v1 != 0.0 && v2 != 0.0){
                        wReturn = fncDivide(s1, s2, 8, true);
                    } else {
                        wReturn = "0";
                    }
            } else if (pOprater.charAt(0) == '%'){
                    if (v1 != 0.0 && v2 != 0.0){
                        wReturn = fncMod(s1, s2, 0);
                    } else {
                        wReturn = s1;
                    }
            } else if (pOprater.charAt(0) == '^'){
            	wReturn = "1";
            	for(var i = 1; i <= parseInt(v2, 10);i++)
                    wReturn = fncMultiply(wReturn, s1);
                    
            } else if (pOprater.charAt(0) == '\\'){
                    if (v1 != 0.0 && v2 != 0.0){
                        wReturn = fncDivide(s1, s2, 8, true);
                    } else {
                        wReturn = "0";
                    }
                    wReturn = floor(wReturn, 1) + '';
                    
            } else if (pOprater == "MOD"){
                    if (v1 != 0.0 && v2 != 0.0){
                        wReturn = fncMod(s1, s2, 0);
                    } else {
                        wReturn = s1;
                    }
            } else if (pOprater == "BITAND"){
                    wReturn = (parseInt(v1, 10) & parseInt(v2, 10)) + '';
            } else if (pOprater == "BITOR"){
                    wReturn = (parseInt(v1, 10) | parseInt(v2, 10)) + '';
            } else if (pOprater == "<="){
            	    if (fncEqual(s1, s2)){ 
            	        wReturn = "-1";
            	    } else if (fncLarger(s2, s1)){
            	        wReturn = "-1";
            	    } else {
            	        wReturn = "0";
            	    }
            } else if (pOprater == ">="){
            	    if (fncEqual(s1, s2)){ 
            	        wReturn = "-1";
            	    } else if (fncLarger(s1, s2)){
            	        wReturn = "-1";
            	    } else {
            	        wReturn = "0";
            	    }
            } else if (pOprater == "<>"){
                    wReturn = ChangeStrB2I(!fncEqual(s1, s2));
            } else if (pOprater == "!="){
                    wReturn = ChangeStrB2I(!fncEqual(s1, s2));
            } else if (pOprater.charAt(0) == '='){
                    wReturn = ChangeStrB2I(fncEqual(s1, s2));
            } else if (pOprater.charAt(0) == '<'){
            	    wReturn = (fncLarger(s2, s1) ? "-1" : "0");
            } else if (pOprater.charAt(0) == '>'){
            	    wReturn = (fncLarger(s1, s2) ? "-1" : "0");
            } else if (pOprater == "AND"){
                    wReturn = ChangeStrB2I(v1 != 0 && v2 != 0);
            } else if (pOprater == "NOT"){
                    wReturn = ChangeStrB2I(v2 == 0);
            } else if (pOprater == "OR"){
                    wReturn = ChangeStrB2I(v1 != 0 || v2 != 0);
            }
        }

        wReturn=wReturn.toUpperCase();
        if ((pOprater.charAt(0) == '+' || pOprater.charAt(0) == '-') && 
                    wReturn.charAt(0) != '-'){
            wReturn = "+" + wReturn;
        }

	    return wReturn;
	};
	
	/**
     * @description	미결
     * @param	{object}	pFormula
     * @param	{object}	pFormula2
     * @param	{object}	pOperater
     * @return  {string}
     * @example	미결
     */
    EXOCalculator.prototype.StringOperate = function(pFormula1, pFormula2, pOperater)
	{
        // functionname : [EXOCalculator.StringOperate]

	    var wIsBoolType = true;
	    var wBooleanResult = false;
	
	    var wReturn = "";
	
        var wString1 = "";
        var wString2 = "";

        // ???? ????? ???? ?????? ??????
        pFormula1 = pFormula1.trim();
        if (pFormula1.startsWith("STR_")){
            wString1 = this.StringValues[parseInt(pFormula1.substring(4),10)];
        } else {
            wString1 = pFormula1;
        }

        pFormula2 = pFormula2.trim();
        if (pFormula2.startsWith("STR_")){
            wString2 = this.StringValues[parseInt(pFormula2.substring(4), 10)];
        } else {
            wString2 = pFormula2;
        }
        if (pOperater.charAt(0) == '&'){
            wReturn = this.TempString(wString1 + wString2);
            wIsBoolType = false;
        } else if (pOperater.startsWith("<=")){
            wBooleanResult = (wString1 <= wString2);
        } else if (pOperater.startsWith(">=")){
            wBooleanResult = (wString1 >= wString2);
        } else if (pOperater.startsWith("<>")){
            wBooleanResult = (wString1 != wString2);
        } else if (pOperater.charAt(0) == '='){
            wBooleanResult = (wString1 == wString2);
        } else if (pOperater.charAt(0) == '<'){
            wBooleanResult = (wString1 < wString2);
        } else if (pOperater.charAt(0) == '>'){
            wBooleanResult = (wString1 > wString2);
        } else if (pOperater.substring(0,4) == "LIKE"){
            wBooleanResult = checkLike(wString2, wString1);
        }

        if (wIsBoolType){
        	wReturn = (wBooleanResult? "-1" : "0");
        }
	
	    return wReturn;
	
	};
    
	/**
     * @description	미결
     * @param	{object}	pFormula
     * @return  {string}
     * @example	미결
     */
    EXOCalculator.prototype.FuncOperate = function(pFormula)
	{
        // functionname : [EXOCalculator.FuncOperate]

        var wReturn = null;
        
        var wTemp = null; var wTemp1 = null;
        var wIntTemp = 0; var wIntTemp1 = 0;

        var wFormula = pFormula.replace(" ","");
        
        // ????κ? ?????
        var wPoint = wFormula.indexOf("(");
        var wFunction = wFormula.substring(0, wPoint).trim();

        wTemp = wFormula.substring(wPoint + 1);
        wTemp1 = wTemp.substring(0, wTemp.indexOf(")"));

        var wHaveString = (wTemp1.indexOf("STR_") != -1);
        var wArrParam = wTemp1.split(",");
        var wCount = wArrParam.length;
        
        // IIF의 처리
        if (wFunction == "IIF"){
        	wArrParam[0] = this.MultiOperate(wArrParam[0] + "");
        	wArrParam[1] = this.MultiOperate(wArrParam[1] + "");
        	wArrParam[2] = this.MultiOperate(wArrParam[2] + "");
        }
        // ????? ?????? ??????
		for(var i = 0; i < wCount; i++){
		    if (wArrParam[i].indexOf("STR_") >= 0){
		        wArrParam[i] = this.Array2String(wArrParam, i);
		    } else {
		        wArrParam[i] = val(wArrParam[i] + "");
		    }
        }
        // ??????? 
        if (wFunction == "SUM"){
            wReturn = sumOf(wArrParam); 
        } else if (wFunction == "AVG"){
            wReturn = avgOf(wArrParam); 
        
        } else if (wFunction == "MAX"){
            if (wHaveString){
                wReturn = this.TempString(maxOf(wArrParam)); 
            } else {
                wReturn = maxOf(wArrParam); 
            }
        } else if (wFunction == "MIN"){
            if (wHaveString){
                wReturn = this.TempString(minOf(wArrParam)); 
            } else {
                wReturn = minOf(wArrParam); 
            }

        } else if (wFunction == "ABS"){
            wReturn = abs(wArrParam[0]); 

        } else if (wFunction == "MOD"){
            wReturn = fncMod(wArrParam[0], wArrParam[1], 0); 

        } else if (wFunction == "ROUND"){
        	wIntTemp = parseInt(wArrParam[1], 10);
            wReturn = round(wArrParam[0], wIntTemp);

        } else if (wFunction == "CEIL"){
        	wIntTemp = parseInt(wArrParam[1], 10);
            wReturn = ceil(wArrParam[0], wIntTemp);

        } else if (wFunction == "INT"){
            wReturn = floor(wArrParam[0], 0);
            
        } else if (wFunction == "FLOOR"){
        	wIntTemp = parseInt(wArrParam[1],10);
            wReturn = floor(wArrParam[0], wIntTemp);

        } else if (wFunction == "COUNT"){
            wReturn = wCount + '';

        } else if (wFunction == "LEN"){
            wReturn = wArrParam[0].length + '';

        } else if (wFunction == "KLEN" || wFunction == "LENB"){
            wReturn = wArrParam[0].bytes() + '';

        } else if (wFunction == "INSTR"){
            var wBooleanTemp = false;
            if (wCount >=4){
                wBooleanTemp = (parseInt(wArrParam[3], 10) != 0);
            }

            wIntTemp = parseInt(wArrParam[0], 10) - 1;
            if (wIntTemp < 0) wIntTemp = 0;

            wTemp = wArrParam[0];
            wTemp1 = wArrParam[1];

            if (isDBCSPoint(wTemp, wIntTemp) != 0) wIntTemp++;

            wIntTemp = instrB(wTemp, wTemp1, wIntTemp, wBooleanTemp);

            wReturn = wIntTemp + '';

        } else if (wFunction == "REPLACE"){

            wIntTemp = 1; wIntTemp1 = 99999999;
            var wBooleanTemp = false;
            
            if (wCount >= 4)
                wIntTemp = parseInt(wArrParam[3], 10) - 1; // ReplaceNN????? 0?? ????? ???? ???? 
            if (wCount >= 5)
                wIntTemp1 = parseInt(wArrParam[4], 10);
            if (wCount >= 6)
                wBooleanTemp = (parseInt(wArrParam[5], 10) != 0);

            wReturn = this.TempString(replaceNN(wArrParam[0], wArrParam[1], wArrParam[2], wIntTemp, wIntTemp1, wBooleanTemp));

        } else if (wFunction == "MID"){
            wIntTemp  = parseInt(wArrParam[1],10);
            wIntTemp1 = (wCount == 3 ? parseInt(wArrParam[2], 10) : 1);

            wTemp = wArrParam[0];
            if (isDBCSPoint(wTemp, wIntTemp - 1) == 2){
                wIntTemp++; // wIntTemp1--;
            }
            wTemp1 = midB(wTemp, wIntTemp, wIntTemp1);

            wReturn = this.TempString(wTemp1);

        } else if (wFunction == "LEFT"){
            wIntTemp = parseInt(wArrParam[1], 10);

            wTemp = wArrParam[0];
            wTemp1 = leftB(wTemp, wIntTemp);

            wReturn = this.TempString(wTemp1);

        } else if (wFunction == "RIGHT"){
            wIntTemp = parseInt(wArrParam[1], 10);
            wTemp = wArrParam[0];

            wPoint = wTemp.length - wIntTemp ;
            wTemp1 = rightB(wTemp, wIntTemp);

            wReturn = this.TempString(wTemp1);

        } else if (wFunction == "SPACE"){
            wIntTemp = parseInt(wArrParam[0], 10);
            wReturn = this.TempString(repeatString(' ',wIntTemp));

        } else if (wFunction == "UCASE"){
            wReturn = this.TempString(wArrParam[0].toUpperCase());

        } else if (wFunction == "LCASE"){
            wReturn = this.TempString(wArrParam[0].toLowerCase());

        } else if (wFunction == "TRIM"){
            wReturn = this.TempString(wArrParam[0].trim());

        } else if (wFunction == "LTRIM"){
            wReturn = this.TempString(LTrim(wArrParam[0]));
            
        } else if (wFunction == "RTRIM"){
            wReturn = this.TempString(RTrim(wArrParam[0]));

        } else if (wFunction == "VAL"){
            wReturn = val(wArrParam[0]) + "";
            
        } else if (wFunction == "STR"){
            wReturn = this.TempString(wArrParam[0]);
            
        } else if (wFunction == "ISNULL"){
            wTemp = wArrParam[0];
            wReturn =  (wTemp == "\"\"" || wTemp == "") ? "-1" : "0";

        } else if (wFunction == "YEAR"){
            wReturn = wArrParam[0].substring(0, 4);
            
        } else if (wFunction == "MONTH"){
            wTemp = wArrParam[0].replace(/\-/g, "").substring(4, 6);
            wReturn = numberFormat(wTemp, "#0");
            
        } else if (wFunction == "DAY"){
            wTemp1 = wArrParam[0].replace(/\-/g, "").substring(wTemp1.length - 2);
            wReturn = numberFormat(wTemp, "#0");

        } else if (wFunction == "FMONY"){
            var wYM = wArrParam[0].replace(/\-/g, "");
            
            var wYY = parseInt(wYM.substring(0, 4), 10);
            var wMM = parseInt(wYM.substring(4, 6), 10);

            if (wMM == 1)  wYY--;

            wReturn = this.TempString(numberFormat(wYY, "0000"));

        } else if (wFunction == "FMONM"){
            var wYM = wArrParam[0].replace(/\-/g, "");
            
            var wYY = parseInt(wYM.substring(0, 4), 10);
            var wMM = parseInt(wYM.substring(4, 6), 10);
            
            wMM--;
            

            if (wMM == 0) wMM = 12;

            wReturn = this.TempString(numberFormat(wMM, "0000"));

        } else if (wFunction == "DAYDIFF"){
            wReturn = dayDiff(wArrParam[0], wArrParam[1]) + "";

        } else if (wFunction == "TIMEDIFF"){
            wReturn = timeDiff(wArrParam[0], wArrParam[1]) + "";
            wReturn = clearBehindZero(wReturn);

        } else if (wFunction == "DAYADD"){
            wIntTemp = parseInt(wArrParam[1],10);
            wTemp = dayAdd(wArrParam[0], wIntTemp);
            wReturn = this.TempString(wTemp);

        } else if (wFunction == "DAYSOF"){
            if (wCount == 2){
                wIntTemp  = parseInt(wArrParam[0], 10);
                wIntTemp1 = parseInt(wArrParam[1], 10);

            } else {
                wTemp = wArrParam[0].replace(/\-/g, "");
                wIntTemp = parseInt(wTemp.substring(4), 10);
                wIntTemp1 = parseInt(wTemp.substring(4, 6), 10);
            }
            wReturn = daysOf(wIntTemp, wIntTemp1) + "";

        } else if (wFunction == "WEEKDAY"){
            wReturn = weekDayOf(wArrParam[0]) + "";

        } else if (wFunction == "NOW"){
            wReturn = this.TempString(Now());

        } else if (wFunction == "IIF"){
            wIntTemp = parseInt(wArrParam[0], 10);
            if (wIntTemp == -1){
                wReturn = wArrParam[1];
            } else {
                wReturn = wArrParam[2];
            } 

        } else if (wFunction == "FORMAT"){
            wReturn = this.TempString(format(wArrParam[0], wArrParam[1]));

        } else if (wFunction == "SORT"){
            if (!wHaveString) {
                wReturn = this.TempString(func_SortASC_Num(wArrParam));
            } else {
                wReturn = this.TempString(func_SortASC_Str(wArrParam));
            }

        } else if (wFunction == "SORTDSC"){
            if (!wHaveString) {
                wReturn = this.TempString(func_SortDSC_Num(wArrParam));
            } else {
                wReturn = this.TempString(func_SortDSC_Str(wArrParam));
            }

        } else if (wFunction == "TOPN"){
		
            if (wHaveString) {
                wReturn = this.TempString(func_TopN_Str(wArrParam));
            } else {
                wReturn = this.TempString(func_TopN_Num(wArrParam));
            }

        } else if (wFunction == "LOWN"){
            if (wHaveString) {
                wReturn = this.TempString(func_LowN_Str(wArrParam));
            } else {
                wReturn = this.TempString(func_LowN_Num(wArrParam));
            }

        } else {
            wReturn = "" ;
        }
	
	    //????? ???????. 
	    return wReturn;
	
	};
	
	/**
     * @description	미결
     * @param	{object}	pFormula
     * @return  {object}
     * @example	미결
     */
    EXOCalculator.prototype.Str2Temp = function(pFormula)
	{
        // functionname : [EXOCalculator.Str2Temp]

        if (pFormula.indexOf("\"") == -1) return pFormula;
        
        var wFormula = pFormula;

		this.ArrStringValues = cutString(pFormula, "\"", "\"");
		this.StringCount = this.ArrStringValues.length;

		if (this.ArrStringValues[this.ArrStringValues.length - 1].length == 0) this.StringCount--;
		for (var i = 0; i < this.StringCount ; i++){
  		    this.StringValues[i + 1] = this.ArrStringValues[i];
 			wFormula = replaceFirstOne(wFormula, "\"" + this.ArrStringValues[i] + "\"", "STR_" + (i + 1));
		}
	
		return wFormula;
	};
	
	/**
     * @description	미결
     * @param	{object}	pFormula
     * @return  {string}
     * @example	미결
     */
    EXOCalculator.prototype.Temp2Str = function(pFormula)
	{
        // functionname : [EXOCalculator.Temp2Str]

		if (pFormula.indexOf("STR_") == -1) return pFormula;
		
		var wFormula = pFormula || "";
		for(var i = this.StringCount; i > 0; i--){
			wFormula = wFormula.replaceWord("STR_" + i, this.StringValues[i]);
			if (wFormula.indexOf("STR_") == -1) break;
		}
		return wFormula;
	};
	
	/**
     * @description	미결
     * @param	{string}	pString
     * @return  {string}
     * @example	미결
     */
    EXOCalculator.prototype.TempString = function(pString)
	{
        // functionname : [EXOCalculator.TempString]

		this.StringValues[++this.StringCount] = pString;
		return  "STR_" + (this.StringCount);
	};
	
	/**
     * @description	미결
     * @param	{object}	pArray
     * @param	{number}	pIndex
     * @return  {object}
     * @example	미결
     */
	EXOCalculator.prototype.Array2String = function(pArray, pIndex)
	{
        // functionname : [EXOCalculator.Array2String]

		if (pArray[pIndex].length == 0) return "";
		return this.Temp2Str(this.MultiOperate(pArray[pIndex]));
	};
	
	/**
	*     @description	미결
	*     @param	{object}	pFormula
	*     @return	{string}
	*     @example	미결
	*/
	function decomment(pFormula)
	{
		var wFormula = pFormula;
	
		if (wFormula.indexOf("//") != -1){
			wFormula = wFormula + "\r\n";
			wFormula = removeString(wFormula, "//", "\r\n");
		}
	
		if (wFormula.indexOf("/*") != -1 && 
			wFormula.indexOf("*/") != -1){
			wFormula = removeString(wFormula, "/*", "*/");
		}
	
		return wFormula;
	};
	
	/**
	*     @description	미결
	*     @param	{object}	pArrParam
	*     @return	{string}
	*     @example	미결
	*/
	function func_TopN_Str(pArrParam)
	{
		if (pArrParam <= 1) return "";
		
		var wReturn = "";
		var wStringLen = 0;
	
		var wUpperBound = pArrParam.length - 1;
	 	var wIntTemp = parseInt(pArrParam[0], 10);
	
		var wArrTemp = new Array(wUpperBound); //String
	
		for (var i = 0; i < wUpperBound; i++){
	  		wArrTemp[i] = pArrParam[i + 1];
		}
	
		wArrTemp.sort(compare);
		
		var j = 0;
		for (var i = wUpperBound - 1; i >= wUpperBound - wIntTemp ; i--){
			if (j++ > 0) wReturn += ",";
			wReturn += wArrTemp[i];
		}
		
	 	wArrTemp = null;
	 	
		return wReturn;
	};
	
	/**
	*     @description	미결
	*     @param	{object}	pArrParam
	*     @return	{string}
	*     @example	미결
	*/
	function func_LowN_Str(pArrParam)
	{
		if (pArrParam <= 1) return "";

		var wReturn = "";
		var wStringLen = 0;
		
	 	var wIntTemp = parseInt(pArrParam[0], 10);
	
		var wUpperBound = pArrParam.length - 1;
		var wArrTemp = new Array(wUpperBound);
		for (var i = 0; i < wUpperBound; i++){
	  		wArrTemp[i] = pArrParam[i + 1];
		}
	
		wArrTemp.sort(compare);
		
	    var j = 0;
		for (var i = 0; i <= wIntTemp - 1; i++){
			if (j++ > 0) wReturn += ",";
			wReturn += wArrTemp[i];
		}
		wArrTemp = null;
		
		return wReturn;
	
	};
	
	/**
	*     @description	미결
	*     @param	{object}	pArrParam
	*     @return	{string}
	*     @example	미결
	*/
	function func_TopN_Num(pArrParam)
	{
		if (pArrParam <= 1) return "";

		var wReturn = "";
		
	 	var wIntTemp = parseInt(pArrParam[0], 10);
	
		var wUpperBound = pArrParam.length - 1;
		var wArr_dbl = [];
	
		for (var i = 0; i < wUpperBound ; i++){
			wArr_dbl[i] = val(pArrParam[i + 1]);
		}
	
		wArr_dbl.sort(compare);
	
		var j = 0;
		for (var i = wUpperBound - 1; i >= wUpperBound - wIntTemp; i--){
			if (j++ > 0) wReturn += ",";
			wReturn += clearBehindZero((wArr_dbl[i]) + '');
		}
		
		return wReturn;
	};
	
	/**
	*     @description	미결
	*     @param	{object}	pArrParam
	*     @return	{string}
	*     @example	미결
	*/
	function func_LowN_Num(pArrParam)
	{
		if (pArrParam <= 1) return "";

		var wReturn = "";
		
	 	var wIntTemp = parseInt(pArrParam[0], 10);
	
		var wUpperBound = pArrParam.length - 1;
		var wArr_dbl = new Array(wUpperBound);
	
		for (var i = 0; i<= wUpperBound - 1; i++){
			wArr_dbl[i] = val(pArrParam[i + 1]);
		}
	
		wArr_dbl.sort(compare);
	
	    var j = 0;
		for (var i = 0; i <= wIntTemp - 1;i++){
	   	    if (j++ > 0) wReturn += ",";
			wReturn += clearBehindZero((wArr_dbl[i]) + '');
		}
	
		return wReturn;
	
	};
	
	/**
	*     @description	미결
	*     @param	{object}	pArrParam
	*     @return	{string}
	*     @example	미결
	*/
	function func_SortASC_Num(pArrParam)
	{
		if (pArrParam <= 1) return "";
	
		var wUpperBound = pArrParam.length - 1;
		var wArr_dbl = new Array(wUpperBound + 1);
	
		for (var i = 0; i <= wUpperBound; i++){
			wArr_dbl[i] = val(pArrParam[i]);
		}
	
		wArr_dbl.sort(compare);
	    
		var wReturn = "";
		for (var i = 0; i <= wUpperBound; i++){
			if (i > 0) wReturn += ",";
			wReturn += clearBehindZero((wArr_dbl[i]) + '');
		}
	
		return wReturn;
	
	};
	
	/**
	*     @description	미결
	*     @param	{object}	pArrParam
	*     @return	{string}
	*     @example	미결
	*/
	function func_SortDSC_Num(pArrParam)
	{
		if (pArrParam <= 1) return "";

		var wUpperBound = pArrParam.length - 1;
		var wArr_dbl = new Array(wUpperBound + 1);
	
		for (var i = 0; i <= wUpperBound; i++){
			wArr_dbl[i] = val(pArrParam[i]);
		}

		wArr_dbl.sort(compare);
	
		var wReturn = "";
		for (var i = wUpperBound; i >= 0; i--){
			wReturn += clearBehindZero(wArr_dbl[i] + "");
			if (i > 0) wReturn += ",";
		}
	
		return wReturn;
	
	};
	
	/**
	*     @description	미결
	*     @param	{object}	pArrParam
	*     @return	{string}
	*     @example	미결
	*/
	function func_SortDSC_Str(pArrParam)
	{
		if (pArrParam <= 1) return "";

		var wUpperBound = pArrParam.length - 1;
		
		var wArrTemp = new Array(wUpperBound + 1);
	
		for (var i = 0; i <= wUpperBound; i++){
	  		wArrTemp[i] = pArrParam[i];
		}
	
		wArrTemp.sort(compare);
	
		var wReturn = "";
		for (var i = wUpperBound; i >= 0; i--){
			wReturn += wArrTemp[i];
			if (i > 0) wReturn += ",";
		}
		wArrTemp = null;
		
		return wReturn;
	};
	
	/**
	*     @description	미결
	*     @param	{object}	pArrParam
	*     @return	{string}
	*     @example	미결
	*/
	function func_SortASC_Str(pArrParam)
	{
		if (pArrParam <= 1) return "";

		var wUpperBound = pArrParam.length - 1;
		var wArrTemp = new Array(wUpperBound + 1);
	
		for (var i = 0; i <= wUpperBound; i++){
	  		wArrTemp[i] = pArrParam[i];
		}
	
		wArrTemp.sort(compare);
	
		var wReturn = "";
		for (var i = 0; i <= wUpperBound; i++){
			wReturn += wArrTemp[i];
			if (i < wUpperBound) wReturn += ",";
		}
		wArrTemp = null;
		
		return wReturn;
	};
	
	// Sort?? ???????
	/**
	*     @description	미결
	*     @param	{number}	a
	*     @param	{number}	b
	*     @return	{boolean}
	*     @example	미결
	*/
	function compare(a, b){
	    return a < b ? -1 : 
            a == b ? 0 : 1;

	};
	
	/**
	*     @description	미결
	*     @param	{number}	a
	*     @param	{number}	b
	*     @return	{boolean}
	*     @example	미결
	*/
	function compareKey(a, b){
	    return a.key < b.key ? -1 : 
            a.key == b.key ? 0 : 1;

	};

    // ?δ??????
    /* ---- ???? ????? ????? ???? ????? ---- */
	/**
	*     @description	미결
	*     @param	{string}	pChar
	*     @param	{number}	pCount
	*     @return	{string}
	*     @example	미결
	*/
	function repeatString(pChar, pCount){
        var wReturn = "";
        for (var i = 0; i < pCount; i++) wReturn += pChar;
        
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pStrNum
	*     @return	{string}
	*     @example	미결
	*/
   function clearFrontZero(pStrNum){
	    var wStrNum = "" + pStrNum;
        var wReturn = "0";
		
        // ????? 0 ????
        var wPos = -1;
        for (var i = 0; i < wStrNum.length; i++){
            if (wStrNum.charAt(i) != '0') {
                wPos = i;
                break;
            }
        }
        if (wPos != - 1)
            wReturn = wStrNum.substring(wPos);
		if (wReturn.charAt(0) == ".") wReturn = "0" + wReturn;

        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pStrNum
	*     @return	{string}
	*     @example	미결
	*/
    function clearBehindZero(pStrNum){
	    var wStrNum = "" + pStrNum;
        if (wStrNum.indexOf('.') == -1)
            return wStrNum;
        
        // ????? 0 ????
        var wReturn = "0";
        var wPos = -1;
        for (var i = wStrNum.length - 1; i >= 0; i--){
            if (wStrNum.charAt(i) != '0') {
                wPos = i;
                break;
            } else if (wStrNum.charAt(i) == '.') {
                wPos = i - 1;
                break;
            }
        }
        if (wPos != - 1)
            wReturn = wStrNum.substring(0, wPos + 1);
        if (wReturn.endsWith("."))
            wReturn = wStrNum.substring(0, wReturn.length - 1);
            
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pStrNumX
	*     @param	{number}	pStrNumY
	*     @return	{boolean}
	*     @example	미결
	*/
    function fncLarger(pStrNumX, pStrNumY){
        var wReturn = false;
        var pStrNumX1 = ""; var pStrNumY1 = ""; var pStrNumX2 = ""; var pStrNumY2 = "";
        pStrNumX = pStrNumX + ""; 
		pStrNumY = pStrNumY + "";
		
        // ????? ??? ?и?
        var wPos = pStrNumX.indexOf(".");
        if (wPos > -1) {
        	pStrNumX1 = pStrNumX.substring(0, wPos);
        	pStrNumX2 = pStrNumX.substring(wPos + 1);
        } else {
        	pStrNumX1 = pStrNumX;
        	pStrNumX2 = "";
        }
        
        wPos = pStrNumY.indexOf(".");
        if (wPos > -1) {
        	pStrNumY1 = pStrNumY.substring(0, wPos);
        	pStrNumY2 = pStrNumY.substring(wPos + 1);
        } else {
        	pStrNumY1 = pStrNumY;
        	pStrNumY2 = "";
        }

        //????? ???? ??
        var wIsEqual = false;
        pStrNumX1 = clearFrontZero(pStrNumX1);
        pStrNumY1 = clearFrontZero(pStrNumY1);
        if (pStrNumX1.length > pStrNumY1.length){
            wReturn = true;
        } else if (pStrNumX1.length == pStrNumY1.length
                   && pStrNumX > pStrNumY){
            wReturn = true;
        } else if (pStrNumX1.length == pStrNumY1.length
                   && pStrNumX == pStrNumY){
            wIsEqual = true;     	
        }
        
        //????? ???? ??
        if (wIsEqual){
        	if (pStrNumX2 == ""){
        		wReturn = false;
        	} else if (pStrNumY2 == ""){
        		wReturn = true;
        	} else {
                wReturn = (pStrNumX2 > pStrNumY2);
            }
        }

        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pStrNumX
	*     @param	{number}	pStrNumY
	*     @return	{object}
	*     @example	미결
	*/
    function fncEqual(pStrNumX, pStrNumY){
        return (clearFrontZero(pStrNumX) == clearFrontZero(pStrNumY));
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pStrNumX
	*     @param	{number}	pStrNumY
	*     @return	{string}
	*     @example	미결
	*/
    function fncMultiply (pStrNumX, pStrNumY){
        // ????? ??? ?????. ??????? ??????? ?????  
        var wReturn = ""; 
	    pStrNumX = pStrNumX + "";
	    pStrNumY = pStrNumY + "";
        if (pStrNumX == "0" || pStrNumY == "0") return "0";
         
        // ????? ?????? a???
        var wVarX = new Array(5);
        var wVarY = new Array(5);
        var wMultiplyValue = 0; var wAddingNum = 0;var wFixingNum = 0;
        
        // ????? ???? o?? 
        var wMinusSign = ((pStrNumX.startsWith("-") && !pStrNumY.startsWith("-"))
                           || (!pStrNumX.startsWith("-") && pStrNumY.startsWith("-")) );
        if (pStrNumX.startsWith("-")) pStrNumX = pStrNumX.substring(1);
        if (pStrNumY.startsWith("-")) pStrNumY = pStrNumY.substring(1);

        // ??????? ???? o?? 
        var wDotPosFromLeft = 0;
        var wDotPosFromRight = 0;
   
        wDotPosFromLeft = pStrNumX.indexOf('.');
        if (wDotPosFromLeft != -1) {
            wDotPosFromRight = pStrNumX.length - 1 -wDotPosFromLeft;
            pStrNumX = pStrNumX.substring(0, wDotPosFromLeft) + pStrNumX.substring(wDotPosFromLeft + 1);
        }
        
        wDotPosFromLeft = pStrNumY.indexOf('.');
        if (wDotPosFromLeft != -1) {
            wDotPosFromRight = wDotPosFromRight + pStrNumY.length - 1 -wDotPosFromLeft;
            pStrNumY = pStrNumY.substring(0, wDotPosFromLeft) + pStrNumY.substring(wDotPosFromLeft + 1);
        }

        // 15??? ????? ????? ??? 
        pStrNumX = repeatString('0', 15 - pStrNumX.length) + pStrNumX;
        pStrNumY = repeatString('0', 15 - pStrNumY.length) + pStrNumY;
        
        
        for (var i = 0; i < 5; i++){
             wVarX[i] = parseInt(pStrNumX.substring(3 * i, (3 * i) + 3), 10);
             wVarY[i] = parseInt(pStrNumY.substring(3 * i, (3 * i) + 3), 10);
        }
        wReturn = ""; wAddingNum = 0; wMultiplyValue = 0;
        for (var i = 0; i < 10; i++){
            if (i == 0){
                wMultiplyValue = wVarX[4] * wVarY[4];
            } else if (i == 1){
                wMultiplyValue = wAddingNum + (wVarX[3] * wVarY[4]) 
                                            + (wVarX[4] * wVarY[3]);
            } else if (i == 2){
                wMultiplyValue = wAddingNum + (wVarX[2] * wVarY[4]) 
                                            + (wVarX[3] * wVarY[3])  
                                            + (wVarX[4] * wVarY[2]);
            } else if (i == 3){
                wMultiplyValue = wAddingNum + (wVarX[1] * wVarY[4]) 
                                            + (wVarX[2] * wVarY[3])  
                                            + (wVarX[3] * wVarY[2]) 
                                            + (wVarX[4] * wVarY[1]);
            } else if (i == 4){
                wMultiplyValue = wAddingNum + (wVarX[0] * wVarY[4]) 
                                            + (wVarX[1] * wVarY[3])  
                                            + (wVarX[2] * wVarY[2]) 
                                            + (wVarX[3] * wVarY[1]) 
                                            + (wVarX[4] * wVarY[0]); 
            } else if (i == 5){
                wMultiplyValue = wAddingNum + (wVarX[0] * wVarY[3]) 
                                            + (wVarX[1] * wVarY[2]) 
                                            + (wVarX[2] * wVarY[1]) 
                                            + (wVarX[3] * wVarY[0]); 
            } else if (i == 6){
                wMultiplyValue = wAddingNum + (wVarX[0] * wVarY[2]) 
                                            + (wVarX[1] * wVarY[1]) 
                                            + (wVarX[2] * wVarY[0]); 
            } else if (i == 7){
                wMultiplyValue = wAddingNum + (wVarX[0] * wVarY[1]) 
                                            + (wVarX[1] * wVarY[0]); 
            } else if (i == 8){
                wMultiplyValue = wAddingNum + (wVarX[0] * wVarY[0]);
            } else if (i == 9){
                wMultiplyValue = wAddingNum;
            }
            
            wAddingNum = parseInt(wMultiplyValue / 1000,10);
            wFixingNum = wMultiplyValue % 1000;
            wReturn = numberFormat(("" + wFixingNum),"000") + wReturn;
        }
        
        // ????? ????
        if (wDotPosFromRight > 0){
            wDotPosFromLeft = wReturn.length - wDotPosFromRight;
            wReturn = wReturn.substring(0, wDotPosFromLeft) + "." + wReturn.substring(wDotPosFromLeft);
        }
        if (wReturn.startsWith(".")) wReturn = "0" + wReturn;
        
        // ????? 0 ????
        wReturn = clearFrontZero(wReturn);
        wReturn = clearBehindZero(wReturn);
        if (wReturn.startsWith(".")) wReturn = "0" + wReturn;
        if (wReturn.endsWith(".")) wReturn = wReturn.substring(0, wReturn.length - 1) ;
                
        // ??? ????
        if (wMinusSign && wReturn != "0") wReturn = "-" + wReturn;

       return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pStrNumX
	*     @param	{number}	pStrNumY
	*     @param	{number}	pCalsToPos
	*     @return	{object}
	*     @example	미결
	*/
    function fncMod(pStrNumX, pStrNumY, pCalcToPos){
	
    	 var wReturn = fncDivide(pStrNumX, pStrNumY, pCalcToPos, false);
    	 wReturn = fncMultiply(wReturn, pStrNumY);
    	 wReturn = fncMinus(pStrNumX, wReturn);

         return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pStrNumX
	*     @param	{number}	pStrNumY
	*     @param	{number}	pCalsToPos
	*     @param	{number}	pRoundUp
	*     @return	{string}
	*     @example	미결
	*/
    function fncDivide(pStrNumX, pStrNumY, pCalcToPos, pRoundUp){
        var wReturn = "";
        var wCurrentDigitPos = 0; var wDigitsGap = 0;
	    pStrNumX = pStrNumX + "";
	    pStrNumY = pStrNumY + "";

        // ????? ???? o?? 
        var wMinusSign = ((pStrNumX.startsWith("-") && !pStrNumY.startsWith("-"))
                              || (!pStrNumX.startsWith("-") && pStrNumY.startsWith("-")) );
        if (pStrNumX.startsWith("-")) pStrNumX = pStrNumX.substring(1);
        if (pStrNumY.startsWith("-")) pStrNumY = pStrNumY.substring(1);

        // ?? ???? ???? ??????? ???
        var wDotPosFromLeftX = pStrNumX.indexOf('.');
        var wDotPosFromLeftY = pStrNumY.indexOf('.');
        var wDotPosFromRightX = 0;
        var wDotPosFromRightY = 0;
        
        if (wDotPosFromLeftX >= 0)
            wDotPosFromRightX = pStrNumX.length - wDotPosFromLeftX - 1;
        if (wDotPosFromLeftY >= 0)
            wDotPosFromRightY = pStrNumY.length - wDotPosFromLeftY - 1;
        if (wDotPosFromRightY > wDotPosFromRightX) {
            pStrNumX = pStrNumX + repeatString('0', wDotPosFromRightY - wDotPosFromRightX);
        } else if (wDotPosFromRightX > wDotPosFromRightY) {
            pStrNumY = pStrNumY + repeatString('0', wDotPosFromRightX - wDotPosFromRightY);
        }
        
        if ( wDotPosFromLeftX > 0)
            pStrNumX = pStrNumX.substring(0, wDotPosFromLeftX) + pStrNumX.substring(wDotPosFromLeftX + 1);
        if (wDotPosFromLeftY > 0)
            pStrNumY = pStrNumY.substring(0, wDotPosFromLeftY) + pStrNumY.substring(wDotPosFromLeftY + 1);
        wDigitsGap = pStrNumX.length - pStrNumY.length;


        
        // ???????? ?????? ??? 0?? ?????
        wCurrentDigitPos = 0;
        if (wDigitsGap < 0){
            pStrNumX = repeatString('0', (-1) * wDigitsGap) + pStrNumX;
        } else if (wDigitsGap > 0){
            wCurrentDigitPos = wDigitsGap;
        }
        wDigitsGap = pStrNumX.length - pStrNumY.length;
        
        // ?ð?????? ????? ???? ??? ???  
        var wCompared= new Array(10);   //String
        for (var i = 0; i < 10; i++){
            wCompared[i] = fncMultiply(pStrNumY, i + "");
		}
       
        // ??ø? ?????? ???? ???? ??? ??????. 
        var wValue;
        var j = 0;
        var wLenY = pStrNumY.length;
		
		
        pStrNumX = pStrNumX + "00000000000000000000000"; //???ο??궧 '0'?? ????? ????? ???????? ??????
        var wTarget = pStrNumX.substring(0, wLenY);
        for (; wCurrentDigitPos > ((-1) * pCalcToPos - 2); wCurrentDigitPos--){
           j++;
           wValue = 9; // ??? ?????? ??? ?????? ?? ???? 9?? ??
           for (i = 1; i <= 9; i++){
               if (fncLarger(wCompared[i], wTarget)){

                   wValue = i - 1;
                   break;
               }
           } 
           var wReminder = fncMinus(wTarget, wCompared[wValue]);
           if (wReminder == "0"){
               wTarget = pStrNumX.substring(wLenY + j - 1, wLenY + j);
           } else {
               wTarget = wReminder + pStrNumX.charAt(wLenY + j - 1);
           }
           wReturn += wValue + '';
        }
        
        if (pCalcToPos >= 0) {
            wDotPosFromLeftX = wReturn.length - pCalcToPos - 1;
            wReturn = wReturn.substring(0, wDotPosFromLeftX) + "." + wReturn.substring(wDotPosFromLeftX);
        } else if (pCalcToPos < 0) {
            wReturn = wReturn + repeatString('0', (-1) * pCalcToPos);
        }
		
        if (pRoundUp) { 
            wReturn = round(wReturn, pCalcToPos);
        } else {
            wReturn = floor(wReturn, pCalcToPos);
        }
        wReturn = clearFrontZero(wReturn);
        wReturn = clearBehindZero(wReturn);
        if (wReturn.startsWith(".")) wReturn = "0" + wReturn;
        if (wReturn.endsWith(".")) wReturn = wReturn.substring(0, wReturn.length - 1) ;

        // ??? ????
        if (wMinusSign && wReturn != "0") wReturn = "-" + wReturn;

        return  wReturn;
   };
   
   /**
	*     @description	미결
	*     @param	{number}	pStrNumX
	*     @param	{number}	pStrNumY
	*     @return	{string}
	*     @example	미결
	*/
   function fncPlus(pStrNumX, pStrNumY){
       var wReturn = "";
       var wMinusSign = false;
	   pStrNumX = pStrNumX + "";
	   pStrNumY = pStrNumY + "";

       // ????? ???? o?? 
       if (!pStrNumX.startsWith("-") && pStrNumY.startsWith("-")) {
           pStrNumY = pStrNumY.substring(1);
           return fncMinus(pStrNumX, pStrNumY);
       } else if (pStrNumX.startsWith("-") && !pStrNumY.startsWith("-")) {
           pStrNumX = pStrNumX.substring(1);
           return fncMinus(pStrNumY, pStrNumX);
       } else if (pStrNumX.startsWith("-") && pStrNumY.startsWith("-")) {
           wMinusSign = true;
           pStrNumX = pStrNumX.substring(1);
           pStrNumY = pStrNumY.substring(1);
       }
       
       // ??????? ??????
       var wDigitsAfterDotX = 0;
       var wDigitsAfterDotY = 0;
       if (pStrNumX.indexOf('.') != -1) 
           wDigitsAfterDotX = pStrNumX.length - pStrNumX.indexOf('.') - 1;        
       if (pStrNumY.indexOf('.') != -1)
           wDigitsAfterDotY = pStrNumY.length - pStrNumY.indexOf('.') - 1;        
       var wDigitsPosition = (wDigitsAfterDotX > wDigitsAfterDotY ? wDigitsAfterDotX : wDigitsAfterDotY);
            
       var wDigitsGap = wDigitsAfterDotX - wDigitsAfterDotY;
       if (wDigitsGap < 0){
           pStrNumX = pStrNumX + repeatString('0', (-1) * wDigitsGap);
       } else if (wDigitsGap > 0){
           pStrNumY = pStrNumY + repeatString('0', wDigitsGap);
       }

       // ?? ???? ???? ??????? ???
       var wDotPosFromLeft = pStrNumX.indexOf('.');
       if (wDotPosFromLeft != -1)
           pStrNumX = pStrNumX.substring(0, wDotPosFromLeft) + pStrNumX.substring(wDotPosFromLeft + 1);
       wDotPosFromLeft = pStrNumY.indexOf('.');
       if (wDotPosFromLeft != -1)
           pStrNumY = pStrNumY.substring(0, wDotPosFromLeft) + pStrNumY.substring(wDotPosFromLeft + 1);
       
       // ????? ?????? a???
       var wVarX = new Array(10);
       var wVarY = new Array(10);
       var wPlusValue = 0; var wAddingNum = 0; var wFixingNum = 0;
       
       // 30??? ????? ????? ??? 
       pStrNumX = repeatString('0', 30 - pStrNumX.length) + pStrNumX;
       pStrNumY = repeatString('0', 30 - pStrNumY.length) + pStrNumY;
       
       for (var i = 0; i < 10; i++){
             wVarX[i] = parseInt(pStrNumX.substring(3 * i, (3 * i) + 3), 10);
             wVarY[i] = parseInt(pStrNumY.substring(3 * i, (3 * i) + 3), 10);
       }
        
       wReturn = ""; wAddingNum = 0; wPlusValue = 0;wFixingNum = 0;
       for (var i = 9; i >= 0; i--){
           wPlusValue = wAddingNum + wVarX[i] + wVarY[i];
           wAddingNum = parseInt(wPlusValue / 1000, 10);
           wFixingNum = wPlusValue % 1000;
           wReturn = numberFormat(wFixingNum + '',"000") + wReturn;
		   
        }
        if (wAddingNum > 0) 
            wReturn = wAddingNum + '' + wReturn;
        
        // ????? ????
        if (wDigitsPosition > 0){
            wDotPosFromLeft = wReturn.length - wDigitsPosition;
            wReturn = wReturn.substring(0, wDotPosFromLeft) + "." + wReturn.substring(wDotPosFromLeft);
        }
        if (wReturn.startsWith(".")) wReturn = "0" + wReturn;
        
        // ????? 0 ????
        wReturn = clearFrontZero(wReturn);
        wReturn = clearBehindZero(wReturn);
        if (wReturn.startsWith(".")) wReturn = "0" + wReturn;
        if (wReturn.endsWith(".")) wReturn = wReturn.substring(0, wReturn.length - 1) ;
                
        // ??? ????
        if (wMinusSign && wReturn != "0") wReturn = "-" + wReturn;
   
       return  wReturn;
   };
   
   /**
	*     @description	미결
	*     @param	{number}	pStrNumX
	*     @param	{number}	pStrNumY
	*     @return	{string}
	*     @example	미결
	*/
   function fncMinus(pStrNumX, pStrNumY){
        var wReturn = "";
        var wMinusSign = false;
		pStrNumX = pStrNumX + "";
		pStrNumY = pStrNumY + "";
        
        // ????? ???? o?? 
        if (!pStrNumX.startsWith("-") && pStrNumY.startsWith("-")) {
            pStrNumY = pStrNumY.substring(1);
            return fncPlus(pStrNumX, pStrNumY);
        } else if (pStrNumX.startsWith("-") && !pStrNumY.startsWith("-")) {
            pStrNumY = "-" + pStrNumY;
            return fncPlus(pStrNumY, pStrNumX);
        } else if (pStrNumX.startsWith("-") && pStrNumY.startsWith("-")) {
            wMinusSign = true;
            pStrNumX = pStrNumX.substring(1);
            pStrNumY = pStrNumY.substring(1);
        }
       
        // ??????? ??????
        var wDigitsAfterDotX = 0;
        var wDigitsAfterDotY = 0;
        if (pStrNumX.indexOf('.') != -1) 
            wDigitsAfterDotX = pStrNumX.length - pStrNumX.indexOf('.') - 1;        
        if (pStrNumY.indexOf('.') != -1)
            wDigitsAfterDotY = pStrNumY.length - pStrNumY.indexOf('.') - 1;        
        var wDigitsPosition = (wDigitsAfterDotX > wDigitsAfterDotY ? wDigitsAfterDotX : wDigitsAfterDotY);
            

        // ?? ???? ???? ??????? ???
        var wDigitsGap = wDigitsAfterDotX - wDigitsAfterDotY;
        var wDotPosFromLeft = pStrNumX.indexOf('.');
        if (wDotPosFromLeft != -1)
            pStrNumX = pStrNumX.substring(0, wDotPosFromLeft) + pStrNumX.substring(wDotPosFromLeft + 1);
        wDotPosFromLeft = pStrNumY.indexOf('.');
        if (wDotPosFromLeft != -1)
            pStrNumY = pStrNumY.substring(0, wDotPosFromLeft) + pStrNumY.substring(wDotPosFromLeft + 1);
      
        if (wDigitsGap < 0){
               pStrNumX = pStrNumX + repeatString('0', (-1) * wDigitsGap);
        } else if (wDigitsGap > 0){
               pStrNumY = pStrNumY + repeatString('0', wDigitsGap);
        }

        // 15??? ????? ??? 
        pStrNumX = repeatString('0', 30 - pStrNumX.length) + pStrNumX;
        pStrNumY = repeatString('0', 30 - pStrNumY.length) + pStrNumY;

        var wStrNum = ""; 
        if (pStrNumX < pStrNumY && !wMinusSign){
            wStrNum  = pStrNumX;
            pStrNumX = pStrNumY;
            pStrNumY = wStrNum;
            wMinusSign = true;
        } else if (pStrNumX > pStrNumY && !wMinusSign){
            wMinusSign = false;
        } else if (pStrNumX < pStrNumY && wMinusSign){
            wStrNum  = pStrNumX;
            pStrNumX = pStrNumY;
            pStrNumY = wStrNum;
            wMinusSign = false;
        } else if (pStrNumX > pStrNumY && wMinusSign){
            wMinusSign = true;
        }
      
        // ????? ?????? a???
        var wVarX = new Array(10);
        var wVarY = new Array(10);
        var wMinusValue = 0; var wAddingNum = 0; var wFixingNum = 0;
         
         // 30??? ????? ??? 
         for (var i = 0; i < 10; i++){
              wVarX[i] = parseInt(pStrNumX.substring(3 * i, (3 * i) + 3), 10);
              wVarY[i] = parseInt(pStrNumY.substring(3 * i, (3 * i) + 3), 10);
         }
         
         wReturn = ""; wAddingNum = 0; wMinusValue = 0;

         for (var i = 9; i >= 0; i--){
             wMinusValue = wAddingNum + 1000 + wVarX[i] - wVarY[i];
             wAddingNum = parseInt(wMinusValue / 1000, 10) - 1;
             wFixingNum = wMinusValue % 1000;
             wReturn = numberFormat(wFixingNum + "","000") + wReturn;
         }
        
         // ????? ????
         if (wDigitsPosition > 0){
             wDotPosFromLeft = wReturn.length - wDigitsPosition;
             wReturn = wReturn.substring(0, wDotPosFromLeft) + "." + wReturn.substring(wDotPosFromLeft);
         }
         if (wReturn.startsWith(".")) wReturn = "0" + wReturn;
         
         // ????? 0 ????
         wReturn = clearFrontZero(wReturn);
         wReturn = clearBehindZero(wReturn);
         if (wReturn.startsWith(".")) wReturn = "0" + wReturn;
         if (wReturn.endsWith(".")) wReturn = wReturn.substring(0, wReturn.length - 1) ;
                
         // ??? ????
         if (wMinusSign && wReturn != "0") wReturn = "-" + wReturn;
 
         return  wReturn;
    };
   
    /* ---- ???? ????? ?????? ????? ---- */
    /**
	*     @description	미결
	*     @return	{string}
	*     @example	미결
	*/
    function Now()
    {
        var wReturn = "";
	    var d = new Date();
		wReturn = ""  + d.getFullYear() 
		        + "-" + (d.getMonth() < 9 ? "0" + (d.getMonth() + 1) : (d.getMonth() + 1) + '') 
		        + "-" + (d.getDate() < 10 ? "0" + d.getDate() : d.getDate() + '')
		        + " " + (d.getHours() < 10 ? "0" + d.getHours() : d.getHours() + '')
		        + ":" + (d.getMinutes() < 10 ? "0" + d.getMinutes() : d.getMinutes() + '')
		        + ":" + (d.getSeconds() < 10 ? "0" + d.getSeconds() : d.getSeconds() + '');
        
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pYear
	*     @return	{number}
	*     @example	미결
	*/
    function isLeapYear(pYear)
    {
        return (new Date(pYear, 2, 0)).getDate() == 29;                             
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pYear
	*     @param	{number}	pMon
	*     @param	{number}	pDay
	*     @return	{object}
	*     @example	미결
	*/
    function DaysOfYear(pYear, pMon, pDay)
    {
        var wLastYearLastDate = (pYear - 1) + "1231";
        var TargetDate = ""  + pYear 
		               + (pMon < 10 ? "0" + pMon : pMon + '') 
		               + (pDay < 10 ? "0" + pDay : pDay + '');

        return dayDiff(wLastYearLastDate, TargetDate);
    };

    /**
	*     @description	미결
	*     @param	{number}	pStrNum
	*     @param	{number}	pPosition
	*     @return	{object}
	*     @example	미결
	*/
    function round(pStrNum, pPosition)
    {
    	//2016 04 20(차중훈) 수정 : pPosition 입력 안 한 경우 0으로 처리
    	pPosition = (typeof pPosition == "undefined") ? 0 : pPosition;
    	
        // ?????? ???? ???? 0?? ???δ?. 
        var wReturn = "0000000000" + pStrNum;
        if (wReturn.indexOf('.') == -1) wReturn += ".0000000000000";
		wReturn += "0000000000000";
        
        // ?????????? ????? ?? ??ø??????? ????? ??????. 
        var wDotPos = wReturn.indexOf('.');
        wReturn = wReturn.substring(0, wDotPos) + wReturn.substring(wDotPos + 1);
        // ??ø?????? ???. 
        wReturn = wReturn.substring(0, wDotPos + pPosition + 1);

        var wCharEnd = wReturn.charAt(wReturn.length - 1);
        wReturn = wReturn.substring(0, wReturn.length - 1);
        if (wCharEnd >= '5'){
            var len1 = wReturn.length;
            wReturn = fncPlus(wReturn, "1");
            var len2 = wReturn.length;
            
            if (len1 > len2) wReturn = repeatString("0",len1 - len2) + wReturn;         
        }
        // ??????? ??? ???δ?.
        if (pPosition > 0) {
            wDotPos = wReturn.length - pPosition;
            wReturn = wReturn.substring(0, wDotPos) + "." + wReturn.substring(wDotPos);
        } else if (pPosition <= 0) {
            wReturn = wReturn + repeatString('0', (-1) * pPosition);
        }

        wReturn = clearFrontZero(wReturn);
        if (wReturn.startsWith(".")) wReturn = "0" + wReturn;
        if (wReturn.endsWith(".")) wReturn = wReturn.substring(0, wReturn.length - 1) ;
        
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pStrNum
	*     @param	{number}	pPosition
	*     @return	{object}
	*     @example	미결
	*/
    function ceil(pStrNum, pPosition)
    {
        // ?????? ???? ???? 0?? ???δ?. 
        var wReturn = "0000000000" + pStrNum;
        if (wReturn.indexOf('.') == -1) wReturn += ".0000000000000";
		wReturn += "0000000000000";
        
        // ?????????? ????? ?? ??ø??????? ????? ??????. 
        var wDotPos = wReturn.indexOf('.');
        wReturn = wReturn.substring(0, wDotPos) + wReturn.substring(wDotPos + 1);
        
        // ?ø?????? ???. 
        wReturn = wReturn.substring(0, wDotPos + pPosition);
        wReturn = fncPlus(wReturn, "1");      
        
        // ??????? ??? ???δ?.
        if (pPosition > 0) {
            wDotPos = wReturn.length - pPosition;
            wReturn = wReturn.substring(0, wDotPos) + "." + wReturn.substring(wDotPos);
        } else if (pPosition <= 0) {
            wReturn = wReturn + repeatString('0', (-1) * pPosition);
        }

        wReturn = clearFrontZero(wReturn);
        if (wReturn.startsWith(".")) wReturn = "0" + wReturn;
        if (wReturn.endsWith(".")) wReturn = wReturn.substring(0, wReturn.length - 1) ;
         
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pStrNum
	*     @param	{number}	pPosition
	*     @return	{object}
	*     @example	미결
	*/
    function floor(pStrNum, pPosition)
    {
        // ?????? ???? ???? 0?? ???δ?. 
        var wReturn = "0000000000" + pStrNum;
        if (wReturn.indexOf('.') == -1) wReturn += ".0000000000000";
		wReturn += "0000000000000";
        
        // ?????????? ????? ?? ??ø??????? ????? ??????. 
        var wDotPos = wReturn.indexOf('.');
        wReturn = wReturn.substring(0, wDotPos) + wReturn.substring(wDotPos + 1);
        
        // ?ø?????? ???. 
        wReturn = wReturn.substring(0, wDotPos + pPosition);
    
        // ??????? ??? ???δ?.
        if (pPosition > 0) {
            wDotPos = wReturn.length - pPosition;
            wReturn = wReturn.substring(0, wDotPos) + "." + wReturn.substring(wDotPos);
        } else if (pPosition <= 0) {
            wReturn = wReturn + repeatString('0', (-1) * pPosition);
        }

        wReturn = clearFrontZero(wReturn);
        wReturn = clearBehindZero(wReturn);

        if (wReturn.startsWith(".")) wReturn = "0" + wReturn;
        if (wReturn.endsWith(".")) wReturn = wReturn.substring(0, wReturn.length - 1) ;
        if (wReturn == "-0") wReturn = "0" ;
         
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{number}	num
	*     @return	{string}
	*     @example	미결
	*/
    function abs(num)
    {
        var wReturn = num + '';
        if (wReturn.startsWith("-")) wReturn = wReturn.substring(1);
        
        return wReturn;
    };

   /* ---- ???? ????? ????? ?????? ????? ---- */
    /**
	*     @description	미결
	*     @param	{string}	pString
	*     @param	{number}	pPosition
	*     @return	{boolean}
	*     @example	미결
	*/
    function isDBCSPoint(pString, pPosition)
    {
        var wReturn = 0;
        var str = pString;
        var wPosition = 0;
        for (var i = 0; i < str.length; i++) {
            var wISDBCSChar = str.charCodeAt(i) > 128;
            wPosition += wISDBCSChar ? 2 : 1;
            
            if (wISDBCSChar && wPosition == pPosition) {
                wReturn = 2;
                break;
            } else if (wISDBCSChar && wPosition > pPosition) {
                wReturn = 1;
                break;
            } else if (wPosition >= pPosition) {
                break;
            }
        }
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pSource
	*     @param	{number}	pCount
	*     @return	{string}
	*     @example	미결
	*/
    function leftB(pSource, pCount)
    {
        var wReturn = pSource;
        var str = pSource;
        var wCount = 0;
        for (var i = 0; i < str.length; i++) {
            var wISDBCSChar = str.charCodeAt(i)> 128;
            wCount += wISDBCSChar ? 2 : 1;
            
            if (wISDBCSChar && wCount > pCount) { 
                wReturn = str.substring(0, i) + " ";
                break;
            } else if (wCount >= pCount) {
                wReturn = str.substring(0, i + 1);
                break;
            }
        }
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pSource
	*     @param	{number}	pCount
	*     @return	{string}
	*     @example	미결
	*/
    function rightB(pSource, pCount)
    {
        var wReturn = pSource;
        var str = pSource;
        var wCount = 0;
        for (var i = str.length -1; i > 0; i--) {
            var wISDBCSChar = str.charCodeAt(i) > 128;
            wCount += wISDBCSChar ? 2 : 1;
            
            if (wISDBCSChar && wCount > pCount) {
                wReturn = str.substring(i+1) ;
                break;
            } else if (wCount >= pCount) {
                wReturn = str.substring(i);
                break;
            }
        }
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pSource
	*     @param	{number}	pStart
	*     @param	{number}	pCount
	*     @return	{string}
	*     @example	미결
	*/
    function midB(pSource, pStart, pCount)
    {
        var wReturn = pSource;
        var str = pSource;
        var wCount = 0;
		var wStartPoint = -1; var wEndPoint = pSource.length;
		
        for (var i = 0; i < str.length; i++) {
            var wISDBCSChar = str.charCodeAt(i)> 128;
            wCount += wISDBCSChar ? 2 : 1;
			

            if (wCount > pStart && wStartPoint == -1) {
                wStartPoint = i;
            }
			
            if (wCount == pStart + pCount) {
                wEndPoint = i + 1;
                break;
            } else if (wCount > pStart + pCount) {
                wEndPoint = i;
               break;
            } 
			
			
        }
		wReturn = str.substring(wStartPoint, wEndPoint);
		
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pSource
	*     @param	{string}	pTarget
	*     @param	{number}	pStartPos
	*     @param	{object}	pBinarySearch
	*     @return	{boolean}
	*     @example	미결
	*/
    function instrB(pSource, pTarget, pStartPos, pBinarySearch)
    {
        var wReturn = 0;
		var wPos = 0; 
		var wStartPoint = 0;
		var str = pSource;
		var wCount = 0;
		var wTarget = "" + pTarget;
		
        for (var i = 0; i < str.length; i++) {
            wCount += (str.charCodeAt(i)> 128) ? 2 : 1;
			
            if (wCount >= pStartPos) {
                wStartPoint = i; break;
            }
        }
		
        
        if (pBinarySearch){
            wPos = pSource.toUpperCase().indexOf(wTarget.toUpperCase(), wStartPoint);
        } else {
            wPos = pSource.indexOf(wTarget, wStartPoint);
        }
        if (wPos == -1) {
        	wReturn = 0;
        } else {
	        for (var i = 0; i <= wPos; i++) 
	            wReturn += (str.charCodeAt(i)> 128) ? 2 : 1;
		}
        
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pSource
	*     @param	{string}	pTarget
	*     @param	{string}	pString
	*     @return	{boolean}
	*     @example	미결
	*/
    function replaceFirstOne(pSource, pTarget, pString)
    {
        return pSource.replace(pTarget, pString);
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pSource
	*     @param	{string}	pTarget
	*     @param	{string}	pString
	*     @param	{number}	pStart
	*     @param	{number}	pCount
	*     @param	{object}	pBinarySearch
	*     @return	{string}
	*     @example	미결
	*/
    function replaceNN(pSource, pTarget, pString, pStart, pCount, pBinarySearch)
    {
        var wReturn = "";
        var wFoundCount = 0;
        var wReplaceCount = 0;
        var wPosNext = 0; var wPosBefore = 0;
        var wTarget = "" + pTarget;

        if (pBinarySearch){
            pSource = pSource.toUpperCase();
            wTarget = wTarget.toUpperCase();
        }
        var wPos = pSource.indexOf(wTarget);

        while (wPos != -1){
            
            wReturn += pSource.substring(wPosBefore, wPos);
            if (++wFoundCount >= pStart && wReplaceCount < pCount){
                wReturn += pString;
                wReplaceCount++;
            } else {
                wReturn += wTarget;
            }

            wPosBefore = wPos + wTarget.length;
            wPos = pSource.indexOf(wTarget, wPos + 1);
        }
        wReturn += pSource.substring(wPosBefore);
        
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pSource
	*     @param	{string}	pChar
	*     @return	{boolean}
	*     @example	미결
	*/
    function countOfChar(pSource, pChar)
    {
        var wCount = 0;
        var wPos = pSource.indexOf(pChar);
        while (wPos != -1){
            wCount++;
            wPos = pSource.indexOf(pChar, ++wPos);
        }
        return wCount;
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pSource
	*     @param	{string}	pTarget
	*     @return	{boolean}
	*     @example	미결
	*/
    function countOfStr(pSource, pTarget)
    {
        var wTarget = "" + pTarget;
    	var wCount = 0;
        var wPos = pSource.indexOf(wTarget);
        while (wPos != -1){
            wCount++;
            wPos = pSource.indexOf(wTarget, ++wPos);
        }
        return wCount;
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pSource
	*     @return	{object}
	*     @example	미결
	*/
    function RTrim(pSource)
    {
         return pSource.replace(/(\s*$)/, "");
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pSource
	*     @return	{object}
	*     @example	미결
	*/
    function LTrim(pSource)
    {
        return pSource.replace(/(^\s*)/, "");
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pString
	*     @return	{object}
	*     @example	미결
	*/
    function isNumeric(pString)
    {
        if (pString.length == 0) return false;
        
        var wString = pString;
		wString = wString.trim();
		
		var wReturn =  wString.replace(/[^0-9]/g, "") == wString 
		            || (wString.charAt(0) == "-" && wString.substring(1).replace(/[^0-9]/g, "") == wString.substring(1));
		return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pString
	*     @param	{number}	pPosition
	*     @return	{boolean}
	*     @example	미결
	*/
    function isSign(pString, pPosition)
    {
        if (pPosition == 0) return true;
        
        var wResult = true;
        var wPos = pPosition - 1;
        var wChar = " ";
        var wString = "";
        while (0 <= wPos){
            wChar = pString.charAt(wPos);			
            if (wChar == " "){
                wPos--;
                continue;
            }
    
            // ???????? ?????? +-?? ??????.
            wResult = false;
            
            if (wChar == "*" || wChar == "/" || wChar == "\\" || wChar == "=" || 
                wChar == ">" || wChar == "+" || wChar == "-"  || wChar == "<" || 
                wChar == "(" || wChar == "," ){
                wResult = true;
            }
            if (1 <= wPos){
                wString = pString.substring(wPos - 1, wPos + 1).toUpperCase();
                if (wString == "OR") wResult = true;
            } 
            if (2 <= wPos) {
                wString = pString.substring(wPos - 2, wPos + 1).toUpperCase();
                if (wString == "AND" || wString == "MOD" ||wString == "NOT") wResult = true;
            }
            break;
        }
    
        return wResult;
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pString
	*     @return	{boolean}
	*     @example	미결
	*/
    function val(pString)
    {
        if (typeof(pString) == "number") return pString;
        
        var wReturn = 0;
        var wPos = 0;
        var wString = "";
	
		while (pString.charAt(wPos) == " ") wPos++;
		
        var wChar = pString.charAt(wPos);
        if (wChar == '-'){
           wString += "-";
           wPos++;
        } else if (wChar == '+'){
           wPos++;
        }
        
        for (var i = wPos; i < pString.length; i++){
            wChar = pString.charAt(i);
            if (wChar == '.' || (wChar >= '0' && wChar <= '9')) {
                wString += wChar;
            }
        }
        
        if (wString.length > 0) 
            wReturn = parseFloat(1 * wString);
        
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{object}	pBoolValue
	*     @return	{boolean}
	*     @example	미결
	*/
    function ChangeStrB2I(pBoolValue)
    {
        return (pBoolValue ? "-1" : "0");
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pattern
	*     @param	{string}	text
	*     @return	{number}
	*     @example	미결
	*/
    function checkLike(pattern, text) {
        var wMask = pattern || "";
		var original = text || "";
		
		if (wMask.indexOf("\\"))
    		wMask = wMask.replace(/\\/g,"<XXXxxx>");
		if (wMask.indexOf("+"))
    		wMask = wMask.replace(/\+/g,"\\+");
		if (wMask.indexOf("$"))
    		wMask = wMask.replace(/\$/g,"\\$");
		if (wMask.indexOf("^"))
    		wMask = wMask.replace(/\^/g,"\\^");
		if (wMask.indexOf("."))
    		wMask = wMask.replace(/\./g,"\\.");
		if (wMask.indexOf("("))
    		wMask = wMask.replace(/\(/g,"\\(");
		if (wMask.indexOf(")"))
    		wMask = wMask.replace(/\)/g,"\\)");
		if (wMask.indexOf("["))
    		wMask = wMask.replace(/\[/g,"\\[");
		if (wMask.indexOf("]"))
    		wMask = wMask.replace(/\]/g,"\\]");
		if (wMask.indexOf("*"))
    		wMask = wMask.replace(/\*/g,".*");
		if (wMask.indexOf("?"))
    		wMask = wMask.replace(/\?/g,".");
		if (wMask.indexOf("<XXXxxx>"))
    		wMask = wMask.replace(/<XXXxxx>/g,"\\\\");
		
	    var re=new RegExp(wMask, "g");
	    var arrMatched = original.match(re);
		
		return arrMatched != null && arrMatched[0].length == original.length;

    };
    
    /**
	*     @description	미결
	*     @param	{string}	pString
	*     @return	{string}
	*     @example	미결
	*/
    function pressSpace(pString)
    {
        var wReturn = "";
        var wPos = 0;
		var wChar0 = "";
		var wChar1 = "";

        for (i = 0; i < pString.length; i++){
            wChar1 = pString.charAt(i);
            if (wChar0 != ' ' || wChar1 != ' ') {
                wReturn += wChar1;
            }
            wChar0 = wChar1;
        }
        
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pSource
	*     @param	{string}	pTarget1
	*     @param	{string}	pTarget2
	*     @return	{string}
	*     @example	미결
	*/
    function cutString(pSource, pTarget1, pTarget2)
    {
        var wString = "";
        var wCount = 0;
        var wPos1 = pSource.indexOf(pTarget1);
        var wPos2 = 0;
        var wHaveNull = false;
       
        while (wPos1 != -1){
            wPos2 = pSource.indexOf(pTarget2, ++wPos1);
            if (wPos2 == -1) break;
            wString += pSource.substring(wPos1, wPos2); 
            if (wPos1 == wPos2) {wString += "$NULL$"; wHaveNull = true;} 
            wString += "/DV/"; 
            
            wPos1 = pSource.indexOf(pTarget1, ++wPos2);
        }
        
        var wArrReturn = wString.split("/DV/"); 
        
        if (wHaveNull){
            for (var i = 0; i < wArrReturn.length; i++){
            	if (wArrReturn[i] == "$NULL$"){
            		wArrReturn[i] = "";
            	}
            }
        }

        return wArrReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pSource
	*     @param	{string}	pTarget1
	*     @param	{string}	pTarget2
	*     @return	{string}
	*     @example	미결
	*/
    function removeString(pSource, pTarget1, pTarget2)
    {
        var wReturn = "";
        var wCount = 0;
        var wPos0 = 0;
        var wPos1 = pSource.indexOf(pTarget1);
        var wPos2 = 0;
        var wLen1 = pTarget1.length;
        var wLen2 = pTarget2.length;
        
        while (wPos1 != -1){
            wPos2 = pSource.indexOf(pTarget2, wPos1 + wLen1);
            if (wPos2 == -1) break;
            wReturn += pSource.substring(wPos0, wPos1); 
            
            wPos0 = wPos2 + wLen2; 
            wPos1 = pSource.indexOf(pTarget1, wPos0);
        }
        if (wPos0 < pSource.length)
          wReturn += pSource.substring(wPos0); 
        
        return wReturn;
    };
    
    /* =======================================================================
                ????? : "?????;NULL??????"   ????? : "?????:???? ???;0 ???;NULL???"
      ========================================================================*/
    /**
	*     @description	미결
	*     @param	{string}	pTarget
	*     @param	{string}	pForamt
	*     @return	{string}
	*     @example	미결
	*/
    function format(pTarget, pFormat, pRound)
    {
        // ???? ???? u? 
        if (pTarget.length == 0 || pFormat.length == 0) return "";

        // ????????
        var wTarget = "" + pTarget;
        var wReturn = wTarget;
        var wLength = (pFormat.length < wTarget.length) ? wTarget.length : pFormat.length;
        var wType = 0; 
    
        // 1. ???? pFormat?? ?????? ??????.
        if( pFormat.indexOf('@') >= 0 ){
            wType = 1;
        } else if( pFormat.indexOf('&') >= 0 ){
            wType = 1;
        } else if( pFormat.indexOf("YY") != -1 ||
                   pFormat.indexOf("MM") != -1 || 
                   pFormat.indexOf("DD") != -1 ||
                   pFormat.indexOf("Hh") != -1 ||
                   pFormat.indexOf("Nn") != -1 ||
                   pFormat.indexOf("Ss") != -1 ||
                   pFormat.indexOf("mm") != -1 ||
                   pFormat.indexOf("dd") != -1 ||
                   pFormat.indexOf("hh") != -1 ||
                   pFormat.indexOf("nn") != -1 ||
                   pFormat.indexOf("ss") != -1 ||
                   pFormat.indexOf("WK") != -1 ||
                   pFormat.indexOf("wk") != -1
        ){
            wType = 3;
        } else {
            wType = 2;
        } 
    
        var wArrString = pFormat.split(";");
        var wFormatCnt = wArrString.length;
        
        // 2. ????????? ??츦 o?????. 
        if (wType == 2){
            if (wTarget.length == 0){
                if (wFormatCnt >= 4)
                    wReturn = wArrString[3];
            } else {
                pFormat = wArrString[0];
                if (wTarget == "0"){
                    if (wFormatCnt >= 3)
                        pFormat = wArrString[0];
                } else if (wTarget.startsWith("-")){
                    if (wFormatCnt >= 2)
                        pFormat = wArrString[1];
                }
                
                wReturn = numberFormat(wTarget, pFormat, pRound);
            }
        // 3. ???? ????? ??츦 o?????. 
        } else if (wType == 1){
            if (wTarget.length == 0){
                if (wFormatCnt >= 1)  
                    wReturn = wArrString[1];
            } else {
                pFormat = wArrString[0];
                wReturn = stringFormat(wTarget, pFormat);
            }
    
        // 4. ????????? ??츦 o?????. 
        } else if (wType == 3){
        	pFormat = wArrString[0];
        	wReturn = dateFormat(wTarget, pFormat);
        }
    
        return wReturn;
    };

    /* =======================================================================
       ????? : ?? -> "0", "#", ".", "%", ",",     ????? ->"- + $ ( )"   
                "X" : X????? ??????? ???
                " "ABC" " : ???????? ??????? ???? 
      ========================================================================*/
    /**
	*     @description	미결
	*     @param	{string}	pTarget
	*     @param	{string}	pFormat
	*     @return	{string}
	*     @example	미결
	*/
    function numberFormat(pTarget, pFormat, pRound)
    {
        var wReturn = "";
        var wTarget =  "" + pTarget;
        var wLeft = 0; var wRight = 0; var wTLeft = 0; var wTRight = 0;
        var w_bInline = false;
        var w_bNegative = false;
        
        if( pFormat.indexOf(".") >= 0 ){
        	var formatPointAfter = pFormat.substring(pFormat.indexOf(".") + 1);
 			var formatPointCount = formatPointAfter.length;
 			var value = 1 * pTarget;
 			
 			if( pRound == DISPAY_FORMAT_CEIL ){
 				wTarget = "" + (Math.ceil(value * Math.pow(10, formatPointCount)) / Math.pow(10, formatPointCount));
 			}
 			else if( pRound == DISPAY_FORMAT_FLOOR ){
 				wTarget = "" + (Math.floor(value * Math.pow(10, formatPointCount)) / Math.pow(10, formatPointCount));
 			}
 			else{ /* pRound == DISPAY_FORMAT_ROUND */
 				wTarget = "" + (Math.round(value * Math.pow(10, formatPointCount)) / Math.pow(10, formatPointCount));
 			}
 			
 			value = null;
 			formatpointAfter = null;
        }
		
		// - ????? o??
        if (wTarget.startsWith("-")) {
            wTarget = wTarget.substring(1);
            w_bNegative = true;
        }
        
        //pFormat?? '%'?? ?????? ??? 100?? ???? ???´?. 
        if (pFormat.indexOf('%') >= 0) 
            wTarget = fncMultiply(wTarget, "100");
            
        // ??????? ???? ??????? ????? ??? ??? ????? ??? ??? ?и? 
        var wPos = pFormat.indexOf('.');
        if (wPos == -1){
            wLeft  = pFormat;
            wRight = "";
        } else {
            wLeft  = pFormat.substring(0, wPos);
            wRight = pFormat.substring(wPos + 1);
        }
        
        wPos = wTarget.indexOf('.');
        if (wPos == -1){
            wTLeft  = wTarget;
            wTRight = "";
        } else {
            wTLeft  = wTarget.substring(0, wPos);
            wTRight = wTarget.substring(wPos + 1);
        }
        
        // ????? ????? ??????? ??ø? 
        // ??????????? ??ø? ???
        var wCount2 = countOfChar(wRight, '0') + countOfChar(wRight, '#');
        //2016-07-07(수정) : 반올림 로직 제외
//        if (wCount2 > 1){
//            wTRight = wTRight + "0000000000000";
//            var wChar = wTRight.charAt(wCount2 - 1);
//            var wCharEnd = wTRight.charAt(wCount2);
//            wTRight = wTRight.substring(0, wCount2 - 1);
//            
//            if (wCharEnd >= '5'){
//                wTRight = wTRight + (++wChar);      
//            } else {
//                wTRight = wTRight + wChar;      
//            } 
//        }
    
        // Format??????? ??????? ????? ???´?. 
        var wCount1 = countOfChar(wLeft, '0') + countOfChar(wLeft, '#');
        var wLength = wTLeft.length;
        if (wLength < wCount1) {
            wTLeft = repeatString('0', wCount1 - wLength) + wTLeft; 
            wLength = wCount1;
        } else if (wLength > wCount1) {
            wPos = wLeft.indexOf('0');
            var wPosSharp = wLeft.indexOf('#');
            if (wPos == -1) {
               wPos = wPosSharp;
            } else if (wPosSharp > -1 && wPos > wPosSharp) {
               wPos = wPosSharp;
            }
            wLeft = wLeft.substring(0, wPos) 
                  + repeatString('#', wLength - wCount1) 
                  + wLeft.substring(wPos); 
        }
        wCount1 = wLeft.length;
        
        //??????? ??????? ???? 
        var p1 = 0; var t1 = 0; // p1:??????????? ??? t1: ??????????? ???
        var wPChar = ""; var wTChar = "";
        while (p1 < wCount1 || t1 < wLength){
            if (p1 < wCount1) wPChar = wLeft.charAt(p1);
            if (t1 < wLength) wTChar = wTLeft.charAt(t1);
            if (p1 >= wCount1){
                wReturn +=  wTChar;
                t1++;
    
            } else if (wPChar == '0'){
                if (wTChar == '0'){
                    wReturn +=  '0';
                } else {
                    wReturn +=  wTChar;
                }
                if (wTChar != '0') w_bInline = true;
                p1++; t1++;
    
            } else if (wPChar == '#') {
                if (wTChar != '0') {
                    wReturn +=  wTChar;
                } else if (w_bInline){
                    wReturn +=  wTChar;
                }
                if (wTChar != '0') w_bInline = true;
                p1++; t1++;
    
            } else if (wPChar == ',') {
                if (w_bInline)
                    wReturn +=  wPChar;
                p1++;
    
            } else {
                wReturn +=  wPChar;
                p1++;
            }
            
        }
    
        //??????? ??????? ???? 
        if (wCount2 > 0) wReturn += ".";
        
        wCount2 = wRight.length;
        wLength = wTRight.length;
        var p2 = 0; var t2 = 0; // p1:??????????? ??? t1: ??????????? ???
    
        while (p2 < wCount2){
            if (p2 < wCount2) wPChar = wRight.charAt(p2);
            if (t2 < wLength) wTChar = wTRight.charAt(t2);
            if (wPChar == '0'){
                if (t2 >= wLength  || wTChar == '0'){
                    wReturn +=  '0';
                } else { 
                   wReturn +=  wTChar;
                }
                p2++; 
                if (t2 < wLength) t2++;
                
            } else if (wPChar == '#') {
            	//if (t2 < wLength && wTChar != '0'){	// ex) 1.016 값이 1.16으로 나옴
            	if (t2 < wLength && (wTChar != '0' || (wTChar == '0' && countOfChar(wTRight.substring(t2+1),'0') != (wLength-(t2+1))))){
                    wReturn +=  wTChar;
                }
                p2++;
                if (t2 < wLength) t2++;
            } else {
                wReturn +=  wPChar;
                p2++;
            }
        }

        if (w_bNegative){
            wPos = wLeft.indexOf('0');
            var wPosSharp = wLeft.indexOf('#');
            if (wPos == -1) {
               wPos = wPosSharp;
            } else if (wPosSharp > -1 && wPos > wPosSharp) {
               wPos = wPosSharp;
            }
            wReturn = wReturn.substring(0, wPos) 
                  + "-" 
                  + wReturn.substring(wPos); 
            
        }
        if (wReturn.endsWith(".")) {
        	wReturn = wReturn.substring(0, wReturn.length - 1);
        }
        
        return wReturn;
    };


    /* =======================================================================
       ????? : "@" : ????? ??? ??? "&" :????? ??? ???? 
          "<" :?빮?? ">" : ????? "!":????????
      ========================================================================*/
    /**
	*     @description	미결
	*     @param	{string}	pTarget
	*     @param	{string}	pFormat
	*     @return	{string}
	*     @example	미결
	*/
    function stringFormat(pTarget, pFormat)
    {
        var wReturn = "";
        var wTarget = "" + pTarget;
        var w_b2Upper = false; var w_b2Lower = false;
		var w_b2LAlign = false; var w_bInline = false;
    
        //?? ???? ??????? ???? ????  
        if (pFormat.startsWith("!")) {
            w_b2LAlign = true;
            pFormat = pFormat.substring(1);
        }
    
        if (pFormat.startsWith("<")) {
            w_b2Upper = true;
            pFormat = pFormat.substring(1);
        } else if (pFormat.startsWith(">")) {
            w_b2Lower = true;
            pFormat = pFormat.substring(1);
        }
    
        // ?ε???? ! ?? ?? ????츦 ??? ???? u? 
        if (pFormat.startsWith("!")) {
            w_b2LAlign = true;
            pFormat = pFormat.substring(1);
        }
    
        //Format??????? ??????? ????? ???´?. 
        var wLength = wTarget.bytes();
        var wCount = countOfChar(pFormat, '@') + countOfChar(pFormat, '&');
        if (wCount > wLength){
            if (w_b2LAlign) {
                wTarget = wTarget + repeatString(' ', wCount - wLength);
            } else {
                wTarget = repeatString(' ', wCount - wLength) + wTarget;
            }
        } else { 
            if (w_b2LAlign) { 
			    wTarget = leftB(wTarget, wCount);
            } else {
                wTarget = rightB(wTarget, wCount);
            }
        }
		
		
		
        //??????? ???? 
        var str = wTarget;
        var wCount = 0;
		var wPos = 0; var wFormatPos = 0;
		while (wPos < wTarget.length){
		    var wChar = wTarget.charAt(wPos);
			var wCharCode = wTarget.charCodeAt(wPos);
			
			if (pFormat.charAt(wFormatPos) == "@"){
			    wReturn += wChar;
				wPos++; wFormatPos++;
				if (wCharCode > 128) wFormatPos++;
				
			} else if (pFormat.charAt(wFormatPos) == "&"){
			    if (wChar != " ") wReturn += wChar;
				wPos++; wFormatPos++;
				if (wCharCode > 128) wFormatPos++;
				
			} else {
			    wReturn += pFormat.charAt(wFormatPos);
				wFormatPos++;
			}
		}
		
		
        if (w_b2Upper) {
            wReturn = wReturn.toUpperCase();
        } else if (w_b2Lower) {
            wReturn = wReturn.toLowerCase();
        }
    
        return wReturn;
    };


    /* =======================================================================
       ????? : "YYYY", "YY", "MM" , "DD" , "Hh", "Nn", "Ss", "mm" , "dd" , "hh", "nn", "ss", "WK", "Wk"
      ========================================================================*/
    /**
	*     @description	미결
	*     @param	{string}	pTarget
	*     @param	{string}	pFormat
	*     @return	{string}
	*     @example	미결
	*/
    function dateFormat(pTarget, pFormat)
    {
        var wReturn = pFormat;
        // ??u????? ????? ?????? ??? ?ð???? ??????? ?????? 
//        var wTarget = replace2DateTimeType("" + pTarget);
        var wTarget = pTarget.replace(/\-/g, "");;
    
        //????? ???°? ???????? ?????? ????
        if (wReturn.indexOf("YYYY") >= 0)
            wReturn = wReturn.replaceWord("YYYY", wTarget.substring(0, 4));
        if (wReturn.indexOf("YY") >= 0)
            wReturn = wReturn.replaceWord("YY", wTarget.substring(2, 4));
        if (wReturn.indexOf("MM") >= 0)
            wReturn = wReturn.replaceWord("MM", wTarget.substring(4, 6));
        if (wReturn.indexOf("mm") >= 0)
            wReturn = wReturn.replaceWord("mm", numberFormat(wTarget.substring(4, 6), "#0"));
        if (wReturn.indexOf("DD") >= 0)
            wReturn = wReturn.replaceWord("DD", wTarget.substring(6, 8));
        if (wReturn.indexOf("dd") >= 0)
            wReturn = wReturn.replaceWord("dd", numberFormat(wTarget.substring(6, 8), "#0"));
        if (wReturn.indexOf("Hh") >= 0)
            wReturn = wReturn.replaceWord("Hh", wTarget.substring(8, 10));
        if (wReturn.indexOf("hh") >= 0)
            wReturn = wReturn.replaceWord("hh", numberFormat(wTarget.substring(8, 10), "#0"));
        if (wReturn.indexOf("Nn") >= 0)
            wReturn = wReturn.replaceWord("Nn", wTarget.substring(10, 12));
        if (wReturn.indexOf("nn") >= 0)
            wReturn = wReturn.replaceWord("nn", numberFormat(wTarget.substring(10, 12), "#0"));
        if (wReturn.indexOf("Ss") >= 0)
            wReturn = wReturn.replaceWord("Ss", wTarget.substring(12, 14));
        if (wReturn.indexOf("ss") >= 0)
            wReturn = wReturn.replaceWord("ss", numberFormat(wTarget.substring(12, 14), "#0"));
        if (wReturn.indexOf("WK") >= 0)
        	wReturn = wReturn.replaceWord("WK", getWeekCharacter(wTarget, "L"));
        if (wReturn.indexOf("wk") >= 0)
        	wReturn = wReturn.replaceWord("wk", getWeekCharacter(wTarget, "S"));
    
        return wReturn;
    };
	    
    /* =======================================================================
       ?????? ??? ????? ???? 
           "YYYY-MM-DD Hh:Nn:Ss"  "YYYY-MM-DD Hh:Nn"  "YYYY-MM-DD AM/PM Hh:Nn:Ss" 
           "YYYYMMDD Hh:Nn:Ss"  "YYYYMMDD Hh:Nn"  "YYYYMMDD AM/PM Hh:Nn:Ss" 
           "YYYY-MM-DD AM/PM Hh:Nn"   "YYYY-MM-DD" "YYYYMMDD", "YYMMDD" 
           "Hh:Nn:Ss" "Hh:Nn" "AM/PM Hh:Nn:Ss" "AM/PM Hh:Nn" 
      ========================================================================*/
    /**
	*     @description	미결
	*     @param	{object}	pDate
	*     @return	{string}
	*     @example	미결
	*/
    function replace2DateTimeType(pDate)
    {
        var wReturn = "";
        var wTemp;

        //????
        var wCount = pDate.length;
        wCount = (wCount < 21 ? 21 : wCount);
    
        //???? ??ø? ??????? ??????? 
		var now  = new Date(); // ????ð? ????????
		var year = now.getFullYear(); // ?? ????????
		var month= now.getMonth() + 1; // ?? ???????? (+1)
		var date = now.getDate(); // ??￥ ????????
		
        var wDate = "" + year 
		          + (month < 10 ? "0" : "") + month
			      + (date  < 10 ? "0" : "") + date;
		
        var wTarget = pressSpace(pDate).trim().toUpperCase();
    
        var wReturnLength = wTarget.length;
    
        if (wReturnLength == 22){     // YYYY-MM-DD AM/PM Hh:Nn:Ss
            if (!wTarget.substring(11, 13) == "AM"){
                wTemp = wTarget.substring(14, 16);
            } else {
                wTemp = (parseInt(wTemp,10) + 12) + "";
            }
            
            wReturn = wTarget.substring(0, 11)
                    +  wTemp
                    +  wTarget.substring(16, 22);
        
        } else if (wReturnLength == 20){      // YYYYMMDD AM/PM Hh:Nn:Ss
            if (wTarget.substring(9, 11) == "AM"){
                wTemp = wTarget.substring(12, 14);
            } else {
                wTemp = (parseInt(wTemp,10) + 12) + "";
            }
            
            wReturn = wTarget.substring(0, 4) + "-"
                    + wTarget.substring(4, 6) + "-"
                    + wTarget.substring(6, 9)
                    + wTemp;
                    + wTarget.substring(14, 20);
        
        } else if (wReturnLength == 19){      // YYYY-MM-DD AM/PM Hh:Nn
            if (wTarget.substring(11,13) != "AM" && 
                wTarget.substring(11,13) != "PM") {
                wReturn = wTarget;
            } else {
                if (wTarget.substring(11, 13) == "AM"){
                    wTemp = wTarget.substring(14, 16);
                } else {
                    wTemp = (parseInt(wTemp,10) + 12) + "";
                }
                wReturn = wTarget.substring(0, 11) + wTemp
                        + wTarget.substring(16, 19) + ":00";
            }
        
        } else if (wReturnLength == 17){      // YYYYMMDD Hh:Nn:Ss
            wReturn = wTarget.substring(0, 4) + "-"
                    +  wTarget.substring(4, 6) + "-"
                    +  wTarget.substring(6, 9)
                    +  wTarget.substring(9, 17);
        
        } else if (wReturnLength == 16){      // YYYY-MM-DD Hh:Nn
            wReturn = wTarget + ":00";
        
        } else if (wReturnLength == 14){      // YYYYMMDD Hh:Nn
            wReturn = wTarget.substring(0, 4) + "-"
                    +  wTarget.substring(4, 6) + "-"
                    +  wTarget.substring(6, 9)
                    +  wTarget.substring(9, 14)
                    +  ":00";
        
        } else if (wReturnLength == 10){      // YYYY-MM-DD
            wReturn = wTarget + " 00:00:00";
        
        } else if (wReturnLength == 8){       
            if (wTarget.indexOf('-') == -1 && wTarget.indexOf(':') == -1){        // YYYYMMDD
                wReturn = wTarget.substring(0, 4) + "-"
                        + wTarget.substring(4, 6) + "-"
                        + wTarget.substring(6, 8) + " 00:00:00";
			     
            } else if (wTarget.indexOf(":") > -1 &&  
			           wTarget.indexOf("AM") == -1 && wTarget.indexOf("PM") == -1){  // Hh:Nn:Ss
                wReturn = wDate + " " + wTarget;
                
            } else {        // AM/PM Hh:Nn
                if (wTarget.startsWith("AM")){
                    wTemp = wTarget.substring(3, 5);
                } else {
                    wTemp = (parseInt(wTemp,10) + 12) + "";
                }
                wReturn = wDate +  " " + wTemp + ":" + wTarget.substring(6, 8) + ":00";
            }
    
        } else if (wReturnLength == 6){       // YYMMDD
            wReturn = (wTarget.substring(0,2) >= "50" ? "20" : "19")
                    +  wTarget.substring(0, 2)
                    +  "-"
                    +  wTarget.substring(2, 4)
                    +  "-"
                    +  wTarget.substring(4, 6)
                    + " 00:00:00";
    
        } else if (wReturnLength == 5){       // Hh:Nn
            wReturn =  wDate + " " + wTarget + ":00";
    
        } else if (wReturnLength == 11){      // AM/PM Hh:Nn:Ss
            if (!wTarget.startsWith("AM")){
                wTemp = wTarget.substring(3, 5);
            } else {
                wTemp = (parseInt(wTemp,10) + 12) + "";
            }
            
            wReturn =  wDate + " " + wTemp + ":" + wTarget.substring(6, 11);
        } 
    
        return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{string}	pTarget
	*     @param	{string}	pFormat
	*     @param	{number}	pPoint
	*     @return	{boolean}
	*     @example	미결
	*/
    function findNext(pStatement, pFind, pPoint)
    {
    	if (pStatement.length <= pPoint || pFind.length == 0) return -1;
    	
    	var wReturn = -1;
    	var wLength = pFind.length;
    
    	var p = pPoint;
    	while (p < pStatement.length){
    		if (pStatement.charAt(p) == ' ') {
    			p++;
    			continue;
    		} else if (pStatement.substring(p, p + wLength) == pFind){
    			wReturn = p;	
    		}
    		break;
    	}
    
    	return wReturn;
    };
    
    /**
	*     @description	미결
	*     @param	{string}	dateStr
	*     @return	{string}
	*     @example	미결
	*/
    function yearOf(dateStr){
    	return dateStr.substring(0, 4);
    };
    
    /**
	*     @description	미결
	*     @param	{string}	dateStr
	*     @return	{object}
	*     @example	미결
	*/
    function monthOf(dateStr){
        wTemp = dateStr.replace(/\-/g, "").substring(4, 6);
        return numberFormat(wTemp, "#0");
    };
    
    /**
	*     @description	미결
	*     @param	{string}	dateStr
	*     @return	{object}
	*     @example	미결
	*/
    function dayOf(dateStr){
        var wTemp = dateStr.replace(/\-/g, "");
        wTemp = wTemp.substring(wTemp.length - 2);
        return numberFormat(wTemp, "#0");
    };
    
    /**
	*     @description	미결
	*     @param	{string}	dateStr
	*     @return	{object}
	*     @example	미결
	*/
    function beforeYearOf(dateStr){
        var wYM = dateStr.replace(/\-/g, "");
        var wYY = parseInt(wYM.substring(0, 4), 10);
        var wMM = parseInt(wYM.substring(4, 6), 10);

        if (wMM == 1)  wYY--;

        return numberFormat(wYY, "0000");
    };
    
    /**
	*     @description	미결
	*     @param	{string}	dateStr
	*     @return	{object}
	*     @example	미결
	*/
    function beforeMonthOf(dateStr){
        var wYM = dateStr.replace(/\-/g, "");
        var wYY = parseInt(wYM.substring(0, 4), 10);
        var wMM = parseInt(wYM.substring(4, 6), 10);
        
        wMM--;

        if (wMM == 0) wMM = 12;

        return numberFormat(wMM, "0000");
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pStart
	*     @param	{number}	pEnd
	*     @return	{number}
	*     @example	미결
	*/
    function dayDiff(pStart, pEnd)
    {
    	var wTemp = pStart.replace(/\-/g, "");
        var wYear = parseInt(wTemp.substring(0,4), 10);
        var wMonth = parseInt(wTemp.substring(4,6), 10) - 1;
        var wDate = parseInt(wTemp.substring(6,8), 10);
        var d1 = new Date(wYear, wMonth, wDate);

        wTemp = pEnd.replace(/\-/g, "");
        wYear = parseInt(wTemp.substring(0,4), 10);
        wMonth = parseInt(wTemp.substring(4,6), 10) - 1;
        wDate = parseInt(wTemp.substring(6,8), 10);
        var d2 = new Date(wYear, wMonth, wDate);

        
        return Math.round((d2.getTime() - d1.getTime()) / (24*60*60*1000));
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pStart
	*     @param	{number}	pEnd
	*     @return	{number}
	*     @example	미결
	*/
    function dateDiff(pStart, pEnd){
        return dayDiff(pStart, pEnd);
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pStart
	*     @param	{number}	pEnd
	*     @return	{number}
	*     @example	미결
	*/
    function timeDiff(pStart, pEnd)
    {
        // "00000000 00:00:00" 형태로 변환
    	// var wStart = replace2DateTimeType("" + pStart);
        // var wEnd = replace2DateTimeType("" + pEnd);
         var wStart = pStart.replace(/\-/g, "");;
         var wEnd = pEnd.replace(/\-/g, "");;
    	
    	var wYear = parseInt(wStart.substring(0,4), 10);
        var wMonth = parseInt(wStart.substring(4,6), 10) - 1;
        var wDate = parseInt(wStart.substring(6,8), 10);
        var wHour = parseInt(wStart.substring(8,10), 10);
        var wMinute = parseInt(wStart.substring(10,12), 10);
        var wsecond = parseInt(wStart.substring(12,14), 10);
        var d1 = new Date(wYear, wMonth, wDate, wHour, wMinute, wsecond);

        wYear = parseInt(wEnd .substring(0,4), 10);
        wMonth = parseInt(wEnd .substring(4,6), 10) - 1;
        wDate = parseInt(wEnd .substring(6,8), 10);
        wHour = parseInt(wEnd .substring(8,10), 10);
        wMinute = parseInt(wEnd .substring(10,12), 10);
        wsecond = parseInt(wEnd .substring(12,14), 10);
        var d2 = new Date(wYear, wMonth, wDate, wHour, wMinute, wsecond);
        
        return Math.round((d2.getTime()  - d1.getTime()) / 1000);
    };    
    
    /* see common.js */
    /*
    function dayAdd(pStart, pAddCount){}
    */
    
    /**
	*     @description	미결
	*     @param	{number}	pYear
	*     @param	{number}	pMonth
	*     @return	{number}
	*     @example	미결
	*/
    function daysOf(pYear, pMonth){
        return (new Date(pYear,pMonth,0)).getDate();                             
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pDay
	*     @return	{number}
	*     @example	미결
	*/
    function weekDayOf(pDay){
    	var wTemp = pDay.replace(/\-/g, "");
    	
        var wYear = parseInt(wTemp.substring(0,4), 10);
        var wMonth = parseInt(wTemp.substring(4,6), 10) - 1;
        var wDate = parseInt(wTemp.substring(6,8), 10);
        
        return (new Date(wYear,wMonth,wDate)).getDay() + 1;                             
    };
    
    /**
	*     @description	미결
	*     @param	{number}	pDay
	*     @return	{number}
	*     @example	미결
	*/
    function weekDay(pDay){
        return weekDayOf(pDay);                             
    };
    
    /**
	*     @description	미결
	*     @return	{object}
	*     @example	미결
	*/
    function sort(){
    	var args = Array.prototype.slice.call(arguments);
        var wHaveString = false;
        for (var i=0; i < args.length; i++)
        	wHaveString = wHaveString || (typeof(args[i])=="string");

    	return (wHaveString ? sortStrings(args).join(",") : sortValues(args).join(","));
    };
    
    /**
	*     @description	미결
	*     @return	{object}
	*     @example	미결
	*/
    function sortDesc(){
    	var args = Array.prototype.slice.call(arguments);
        var wHaveString = false;
        for (var i=0; i < args.length; i++)
        	wHaveString = wHaveString || (typeof(args[i])=="string");

    	return (wHaveString ? reverseStrings(args).join(",") : reverseValues(args).join(","));
    } ;
    
    /**
	*     @description	미결
	*     @return	{object}
	*     @example	미결
	*/
    function topNOf(){
    	var args = Array.prototype.slice.call(arguments);
    	var n = args[0];
        var wHaveString = false;
        args.splice(0, 1); // 앞하나 줄임
        for (var i=0; i < args.length; i++)
        	wHaveString = wHaveString || (typeof(args[i])=="string");

    	return (wHaveString ? topNStrings(n, args).join(",") : topNValues(n, args).join(","));
    	
    };
    
    /**
	*     @description	미결
	*     @return	{object}
	*     @example	미결
	*/
    function lowNOf(){
    	var args = Array.prototype.slice.call(arguments);
    	var n = args[0];
        var wHaveString = false;
        args.splice(0, 1); // 앞하나 줄임
        for (var i=0; i < args.length; i++)
        	wHaveString = wHaveString || (typeof(args[i])=="string");

    	return (wHaveString ? lowNStrings(n, args).join(",") : lowNValues(n, args).join(","));
    };
    
    /**
	*     @description	미결
	*     @param	{number}	a
	*     @param	{number}	b
	*     @return	{number}
	*     @example	미결
	*/
    function sortIt(a,b){
    	return(a-b);
    };
    
    /**
	*     @description	미결
	*     @param	{object}	inputvalues
	*     @return	{object}
	*     @example	미결
	*/
    function sortValues(inputvalues){
    	inputvalues.sort(sortIt);
    	
    	return inputvalues;
    };
    
    /**
	*     @description	미결
	*     @param	{object}	inputvalues
	*     @return	{object}
	*     @example	미결
	*/
    function sortStrings(inputvalues){
    	inputvalues.sort();
        return inputvalues;
    };
    
    /**
	*     @description	미결
	*     @param	{object}	inputvalues
	*     @return	{object}
	*     @example	미결
	*/
    function reverseValues(inputvalues){
		inputvalues.sort(sortIt);
		inputvalues.reverse();
        return inputvalues;
    };
    
    /**
	*     @description	미결
	*     @param	{object}	inputvalues
	*     @return	{object}
	*     @example	미결
	*/
    function reverseStrings(inputvalues){
		inputvalues.sort();
		inputvalues.reverse();
        return inputvalues;
    };
    
    /**
	*     @description	미결
	*     @param	{object}	n
	*     @param	{object}	inputvalues
	*     @return	{object}
	*     @example	미결
	*/
    function topNValues(n, inputvalues){
    	inputvalues.sort(sortIt); // 소트
        return inputvalues.splice(0,n); // n개를 잘라냄
    };
    
    /**
	*     @description	미결
	*     @param	{object}	n
	*     @param	{object}	inputvalues
	*     @return	{object}
	*     @example	미결
	*/
    function topNStrings(n, inputvalues){
    	inputvalues.sort();
        return inputvalues.splice(0,n); // n개를 잘라냄
    };
    
    /**
	*     @description	미결
	*     @param	{object}	n
	*     @param	{object}	inputvalues
	*     @return	{object}
	*     @example	미결
	*/
    function lowNValues(n, inputvalues){
    	inputvalues.sort(sortIt); // 소트
    	inputvalues.reverse();    // 도치
        return inputvalues.splice(0,n); // n개를 잘라냄
    };
    
    /**
	*     @description	미결
	*     @param	{object}	n
	*     @param	{object}	inputvalues
	*     @return	{object}
	*     @example	미결
	*/
    function lowNStrings(n, inputvalues){
    	inputvalues.sort();
    	inputvalues.reverse();    // 도치
        return inputvalues.splice(0,n); // n개를 잘라냄
    };
    
	/**
	*     @description	미결]
	*     @return	{string}
	*     @example	미결
	*/
	function sumOf(){
    	var wArr = null;
    	var wVal = null;
    	var wSum = "0";
    	var wArrSize = 0;
    	var i = 0;
    	
    	if( typeof(arguments[0]) == "object" && arguments[0].length > 0 ){
    		wArr = arguments[0];
    		wArrSize = wArr.length;
    	}
    	else{
    		wArr = arguments;
    		wArrSize = arguments.length;
    	}
    	
    	for(i = 0; i < wArrSize; i++){
    		wVal = wArr[i];
    		wSum = fncPlus(wSum, ((wVal == null || typeof wVal == "undefined") ? "0" : "" + wVal));
    	}
    	
    	if( isNaN(wSum) ) wSum = NaN;
    	
    	//메모리 해제
    	wVal = null; wArr = null;
    	
    	return wSum;
    };
    
    /**
	*     @description	미결
	*     @return	{string}
	*     @example	미결
	*/
    function avgOf(){
 	   var wReturn = wSum = "0";

       if(typeof(arguments[0]) == "object" && arguments[0].length){
	       var wArr = arguments[0];
	       for (var i = 0; i < wArr.length; i++)
	          wSum = fncPlus(wSum, wArr[i] + "");
			  
	       wReturn = fncDivide(wSum, "" + wArr.length, 8, false);
		   
	   } else { 
	       for (var i = 0; i < arguments.length; i++)
	          wSum = fncPlus(wSum, arguments[i] + "");
			  
	       wReturn = fncDivide(wSum, "" + arguments.length, 8, false);
	   }
       
       if(isNaN(wReturn)) wReturn = NaN;
	   
       return wReturn;
    };
    
    /**
	*     @description	미결
	*     @return	{object}
	*     @example	미결
	*/
    function maxOf()
    {
       var wReturn;
       if(typeof(arguments[0]) == "object" && arguments[0].length){
    	   var wArr =  arguments[0];
    	   wReturn =  wArr[0];
           for (var i = 1; i <  wArr.length; i++)
              if (wArr[i] > wReturn) wReturn = wArr[i] ;
		   
	   } else { 
    	   wReturn =  arguments[0];
           for (var i = 1; i <  arguments.length; i++)
              if (arguments[i] > wReturn) wReturn = arguments[i] ;
	   }

       return wReturn;
    };
    
    /**
	*     @description	미결
	*     @return	{string}
	*     @example	미결
	*/
    function minOf()
    {
       var wReturn;
       if(typeof(arguments[0]) == "object" && arguments[0].length){
    	   var wArr =  arguments[0];
    	   wReturn =  wArr[0];
           for (var i = 1; i <  wArr.length; i++)
              if (wArr[i] < wReturn) wReturn = wArr[i] ;
		   
	   } else { 
    	   wReturn =  arguments[0];
           for (var i = 1; i <  arguments.length; i++)
              if (arguments[i] < wReturn) wReturn = arguments[i] ;
	   }
       return wReturn;
    };
    
    //===== 
    /**
	*     @description	미결
	*     @param	{string}	formula
	*     @return	{string}
	*     @example	미결
	*/
    function fillInfoToFormula(formula){
    	
    	formula = formula.replaceWord("[" + getText("message_usr_personalid", "사용자.사번")   + "]",       "" + USER_PERSONALID);
    	formula = formula.replaceWord("[" + getText("message_usr_personname", "사용자.성명")   + "]",     "\"" + USER_PERSONALNAME + "\"");
    	formula = formula.replaceWord("[" + getText("message_usr_cogu",       "사용자.회사")   + "]",       "" + USER_COGU);
    	formula = formula.replaceWord("[" + getText("message_usr_bon",        "사용자.사업장") + "]",       "" + USER_BON);
    	formula = formula.replaceWord("[" + getText("message_usr_part",       "사용자.부서")   + "]",       "" + USER_PART);
    	formula = formula.replaceWord("[" + getText("message_usr_organ",      "사용자.조직")   + "]",       "" + USER_ORGANIZATION);
    	formula = formula.replaceWord("[" + getText("message_usr_date",       "사용자.일자")   + "]",     "\"" + USER_DATE + "\"");
    	formula = formula.replaceWord("[" + getText("message_usr_month",      "사용자.년월")   + "]",       "" + USER_MONTH);
    	formula = formula.replaceWord("[" + getText("message_usr_year",       "사용자.년도")   + "]",       "" + USER_YEAR);
    	formula = formula.replaceWord("[" + getText("message_usr_seq",        "사용자.순번")   + "]",       "" + USER_SEQ);
    	formula = formula.replaceWord("[" + getText("message_usr_time",       "사용자.시간")   + "]",     "\"" + USER_TIME + "\"");
    	formula = formula.replaceWord("[" + getText("message_usr_userId",     "사용자.아이디") + "]",     "\"" + USER_USERID + "\"");
    	formula = formula.replaceWord("[" + getText("message_usr_ipAddr",     "사용자.아이피주소") + "]",   "" + USER_PERSONALID);
    	
    	
    	
    	for (var id in controls) {
    		if (typeof(controls[id])=="function") continue;
    		
    		var wControl = controls[id];
    		var controlString = getText("message_str_control","콘트롤");
    		var controlName = wControl.controlName;
    		
    		try {  // 클라스가 옶는 경우에 대비해서 오류 스킵
        		if (control.controlId.toLowerCase().indexOf("sheet_") >= 0){
        			for (var colNum = 1; colNum <= wControl.maxCols; colNum++){
        				cellType = wControl.columns[colNum].defaultCellType; 
                        if (cellType == CELLTYPE_DATE){
                            formula = formula.replaceWord("[" + controlString + "." + controlName + "." + colNum + "]",   "\"" + wControl.getValue(colNum) + "\"");
                        } else if (cellType == CELLTYPE_EDIT){
                            formula = formula.replaceWord("[" + controlString + "." + controlName + "." + colNum + "]",   "\"" + wControl.getValue(colNum) + "\"");
                        } else if (cellType == CELLTYPE_NUMBER){
                            formula = formula.replaceWord("[" + controlString + "." + controlName + "." + colNum + "]",   "" + wControl.getValue(colNum));
                        } else if (cellType == CELLTYPE_INTEGER){
                            formula = formula.replaceWord("[" + controlString + "." + controlName + "." + colNum + "]",   "" + wControl.getValue(colNum));
                        } else if (cellType == CELLTYPE_BUTTON){
                            formula = formula.replaceWord("[" + controlString + "." + controlName + "." + colNum + "]",   "" + wControl.getValue(colNum));
                        } else if (cellType == CELLTYPE_PICTURE){
                            formula = formula.replaceWord("[" + controlString + "." + controlName + "." + colNum + "]",   "\"" + wControl.getValue(colNum) + "\"");
                        } else if (cellType == CELLTYPE_COMBOBOX){
                            formula = formula.replaceWord("[" + controlString + "." + controlName + "." + colNum + "]",   "" + wControl.getValue(colNum));
                        } else if (cellType == CELLTYPE_CHECKBOX){
                            formula = formula.replaceWord("[" + controlString + "." + controlName + "." + colNum + "]",   "" + wControl.getValue(colNum));
                        } 
        			}
        		} 
    		} catch(err){ }
    		try {  // 클라스가 옶는 경우에 대비해서 오류 스킵
        		if (wControl instanceof CheckBox){
                	formula = formula.replaceWord("[" + controlString + "." + controlName + "]",   "" + wControl.value);
        		} 
    		} catch(err){ }
    		try {  // 클라스가 옶는 경우에 대비해서 오류 스킵
        		 if (wControl instanceof ComboBox || wControl instanceof ListBox || wControl instanceof ListBoxW){
                	formula = formula.replaceWord("[" + controlString + "." + controlName + "]",   "" + wControl.value);
        		} 
    		} catch(err){ }
    		try {  // 클라스가 옶는 경우에 대비해서 오류 스킵
        		 if (wControl instanceof Label){
                	formula = formula.replaceWord("[" + controlString + "." + controlName + "]",   "" + wControl.value);
        		} 
    		} catch(err){ }
    		try {  // 클라스가 옶는 경우에 대비해서 오류 스킵
        		 if (wControl instanceof TextBox){
                	formula = formula.replaceWord("[" + controlString + "." + controlName + "]",   "" + wControl.value);
        		} 
    		} catch(err){ }
    		try {  // 클라스가 옶는 경우에 대비해서 오류 스킵
        		 if (wControl instanceof OptionButton){
                	formula = formula.replaceWord("[" + controlString + "." + controlName + "]",   "" + wControl.value);
        		} 
    		} catch(err){ }
    	}
    	for (var id in parameters) {
    		if (typeof(parameters[id])=="function") continue;
    		
    		if (typeof(parameters[id])=="number"){
            	formula = formula.replaceWord("[" + getText("message_str_parameter","파라메터") + "." + id + "]",   "" + parameters[id]);
    		} else {
            	formula = formula.replaceWord("[" + getText("message_str_parameter","파라메터") + "." + id + "]",   "\"" + parameters[id] + "\"");
    		}
    		
    	}
    	for (var id in objects) {
    		if (typeof(objects[id])=="function") continue;
    		
    		var wObject = objects[id];
    		
			for (var ndx = 1; ndx <= wObject.propertyCount; ndx++){
				var propertyId = wObject.propertyInfos[ndx].id;
				var propertyName = wObject.propertyInfos[ndx].name;
				
                if (wObject.propertyInfos[ndx].isNumericType){
                    formula = formula.replaceWord("[" + wObject.name + "." + propertyName + "]", "" + wObject.getValue(propertyId));          // 2017.08.18 지운학
                } else {
                    formula = formula.replaceWord("[" + wObject.name + "." + propertyName + "]", "\"" + wObject.getValue(propertyId) + "\""); // 2017.08.18 지운학
                } 
			}
    	}
    	return formula;
    	
    };
    /**
	*     @description	미결
	*     @param	{string}	formula
	*     @return	{string}
	*     @example	미결
	*/
    function FORMULAA(formula){
		return formulaA(formula);
    };
    /**
	*     @description	미결
	*     @param	{string}	formula
	*     @return	{string}
	*     @example	미결
	*/
    function formulaA(formula){
		return (new EXOCalculator()).CalcuratedResult(fillInfoToFormula(formula));
    };/**
 * @description	미결
 * @param 		{String}	storageType
 * @returns 	{Boolean}
 * @example		미결
 */
function storageAvailable(storageType){
	try {
		if( BrowserDetect.browser == "Explorer" )
			return false;
		
		var storage = window[storageType];
		storage.setItem("__Storage_Test__", "TRUE");
		storage.removeItem("__Storage_Test__");
		return true;
	}
	catch(e) {
		return false;
	}
};

var IS_AVAILABLE_LOCALSTORAGE = storageAvailable("localStorage");
var SERVICEABLE_TYPE = "smallint;integer;money;float;char;array;dataset;string;number;";

/*
paramDefineObj = {
	"파라메터Smallint"	: { "type" : "Smallint"	, "isreturn" : false },
	"파라메터Integer"	: { "type" : "Integer"	, "isreturn" : false },
	"파라메터Money"		: { "type" : "Money"	, "isreturn" : false },
	"파라메터Float"		: { "type" : "Float"	, "isreturn" : false },
	"파라메터Char"		: { "type" : "Char"		, "isreturn" : false },
	"파라메터CharM"		: { "type" : "Char"		, "isreturn" : false },
	"파라메터Dataset"	: { "type" : "Dataset"	, "isreturn" : false },
	"리턴"			: { "type" : "Char"		, "isreturn" : true  },
	"리턴Dataset"		: { "type" : "Dataset"	, "isreturn" : true  }
};
*/

/**
 * @description	미결
 * @param 		{String}	paramDefineObj
 * @returns 	{undefined}
 * @example		미결
 */
function Parameter( paramDefineObj ){
	this.parameterKey = "";
	this.parameterInfo = {};
	this.parameterItems = null;
	
	this.returnKey = "";
	
	var key = null;
	
	for(key in paramDefineObj){
		if( typeof paramDefineObj[key] == "function" ) continue;
		
		this.parameterInfo[key] = paramDefineObj[key];
	}
};

/**
 * @description	미결
 * @param 		{String}	paramDefineObj
 * @return		{undefined}
 * @example		미결
 */
Parameter.prototype.set = function(paramDefineObj){
	var key = null;
	
	for(key in paramDefineObj){
		if( typeof paramDefineObj[key] == "function" ) continue;
		
		this.parameterInfo[key] = paramDefineObj[key];
	}
};
/**
 * @description	미결
 * @param 		{String}	paramDefineObj
 * @return		{void}
 * @example		미결
 */
Parameter.prototype.load = function( paramDefineObj ){
	var i = 0;
	
	if( typeof paramDefineObj != "undefined" ){
		this.set(paramDefineObj);
	}
	
	if( this.parameterItems == null ) this.parameterItems = {};
	
	//ULR에 포함되어 전달되는 파라메터 분석
	var queryStr = null;
	var queryItems = null;
	var queryItem = null;
	//ULR Parse
	if( window.location.href.split("?").length == 2 ){
		queryStr = window.location.href.split("?")[1];
		queryItems = queryStr.split("&");
		
		for(i = 0; i < queryItems.length; i++){
			queryItem = queryItems[i].split("=");
			this.parameterInfo[queryItem[0]] = {"type" : "string", "isreturn" : false};
			parameters[queryItem[0]] = this.parameterItems[queryItem[0]] = queryItem[1];
			
			queryItem = null;
		}
		
		queryItems = null;
		queryStr = null;
	}
	
	this.parameterKey = this.parameterItems["paramKey"];
	this.returnKey = USER_FORMID + ".";
	
	//localStorage 사용 가능여부 체크하여 파라메터 불러올 곳 선택
	var key = null;
	var value = null;
	//localStorage 사용 가능한 경우 : localStorage
	if( IS_AVAILABLE_LOCALSTORAGE && typeof this.parameterKey == "string" ){
		for(key in this.parameterInfo){
			value = localStorage.getItem(this.parameterKey + "." + key);
			
			//파라메터 불러옴, 반환형 파라메터인 경우 초기값 설정
			if( this.parameterInfo[key].type == "Smallint" 
				|| this.parameterInfo[key].type == "Integer" 
				|| this.parameterInfo[key].type == "Money"
				|| this.parameterInfo[key].type == "Float" 
			){
				this.parameterItems[key] = (!this.parameterInfo[key].isreturn || value != null) ? 1 * value : 0;
			}
			else if( this.parameterInfo[key].type == "Char" ){
				this.parameterItems[key] = (!this.parameterInfo[key].isreturn || value != null) ? "" + value : "";
			}
			else if( this.parameterInfo[key].type == "Array" ){
				
			}
			else if( this.parameterInfo[key].type == "Dataset" ){
				value = "" + value;
				if( value == "undefined" ){
					this.parameterItems[key] = null;
				}
				else if( !this.parameterInfo[key].isreturn ){
			    	this.parameterItems[key] = (opener !== window && parent === window) ? opener.dataSets[value] : (parent !== window && opener === null && typeof parent.dataSets != "undefined") ? parent.dataSets[value] : top[key];
			    	if(parent === top && opener === null) delete top[key];
			    }
			    else{
			    	//반환형 데이터셋
			    	this.parameterItems[key] = (opener !== window && parent === window) ? opener.dataSets[value] : (parent !== window && opener === null && typeof parent.dataSets != "undefined") ? parent.dataSets[value] : null;
			    }
			}
			
			value = null;
		}
	}
	//localStorage 사용 불가능한 경우 : JSP Parameter
	else if( typeof PARAMS != "undefined" ){
		for(key in this.parameterInfo){
			value = PARAMS[key];
			
			//파라메터 불러옴, 반환형 파라메터인 경우 초기값 설정
			if( this.parameterInfo[key].type == "Smallint" 
				|| this.parameterInfo[key].type == "Integer" 
				|| this.parameterInfo[key].type == "Money"
				|| this.parameterInfo[key].type == "Float" 
			){
				this.parameterItems[key] = (!this.parameterInfo[key].isreturn || typeof value != "undefined") ? 1 * value : 0;
			}
			else if( this.parameterInfo[key].type == "Char" ){
				this.parameterItems[key] = (!this.parameterInfo[key].isreturn || typeof value != "undefined") ? "" + value : "";
			}
			else if( this.parameterInfo[key].type == "Array" ){
				
			}
			else if( this.parameterInfo[key].type == "Dataset" ){
				value = "" + value;
			    if( !this.parameterInfo[key].isreturn ){
			    	this.parameterItems[key] = (window === opener || opener == null) ? ((typeof parent.dataSets == "undefined") ? top[key] : parent.dataSets[value]) : opener.dataSets[value];
			        if( (this === opener || opener == null) && (typeof parent.dataSets == "undefined") ) delete top[key];
			    }
			    else{
			    	//반환형 데이터셋
			    	this.parameterItems[key] = (window === opener || opener == null) ? ((typeof parent.dataSets == "undefined") ? null : parent.dataSets[value]) : opener.dataSets[value];
			    }
			}
			
			value = null;
		}
	}
	
	key = null;
	
	return;
};

/**
 * @description	미결
 * @param 		{String}	name
 * @param 		{String}	value
 * @param 		{String}	type
 * @param 		{boolean}	isReturn
 * @return		{void}
 * @example		미결
 */
Parameter.prototype.setParameter = function(name, value, type, isReturn){
	var parameterInfo = null;
	var compType = "";
	
//	if( !(name in this.parameterInfo) ){	
//	if( typeof this.parameterInfo[name] == "undefined" ){	
	if( this.parameterInfo[name] == undefined ){	
		type = (typeof type == "undefined") ? "string" : type;
		isReturn = (typeof isReturn == "boolean" && isReturn) ? true : false;
		compType = ("" + type).toLocaleLowerCase() + ";";
		
		if( SERVICEABLE_TYPE.indexOf(compType) < 0 ){
			alert(getText("message_parameter_001", "사용 가능한 파라메터 타입이 아닙니다."));
			return;
		}
		
		parameterInfo = this.parameterInfo[name] = {"type" : type, "isreturn" : isReturn};
	}
	else{
		parameterInfo = this.parameterInfo[name];
		parameterInfo.type = type;
		parameterInfo.isreturn = isReturn;
	}
	
	if( this.parameterItems == null ) this.parameterItems = {};
	
	if( ("" + parameterInfo.type).toLocaleLowerCase() == "dataset" && parameterInfo.isreturn ){
		if( ((opener !== window && parent === window) || (parent !== window && opener === null)) && this.parameterItems[name] != null ){
			this.parameterItems[name].copy( dataSets[value] );
		}
	}
	else{
		if( typeof value != "undefined" && value != null ){
			if( parameterInfo.type == "Smallint" 
				|| parameterInfo.type == "Integer" 
				|| parameterInfo.type == "Money"
				|| parameterInfo.type == "Float"  
			){
				value = 1 * value;
			}
			else if( parameterInfo.type == "Char"
				|| parameterInfo.type == "string"
			){
				value = "" + value;
			}
		}
		
		this.parameterItems[name] = value;
		
		if( IS_AVAILABLE_LOCALSTORAGE ){
			name = this.parameterInfo[name].isreturn ? this.returnKey + name : name;
			localStorage.setItem(name, value);
		}
	}
	
	return;
};

/**
 * @description	미결
 * @param 		{String}	name
 * @return		{void}
 * @example		미결
 */
Parameter.prototype.getParameter = function(name){
	var parameterType = null;
	
//	if( name in this.parameterInfo ){
//	if( !(typeof this.parameterInfo[name] == "undefined") ){
	if( !(this.parameterInfo[name] == undefined) ){
		parameterType = ("" + this.parameterInfo[name].type).toLocaleLowerCase();
		
		if( parameterType == "smallint" ){
			return this.getSmallint(name);
		}
		else if( parameterType == "integer" ){
			return this.getInteger(name);
		}
		else if( parameterType == "money" ){
			return this.getMoney(name);
		}
		else if( parameterType == "float"
			|| parameterType == "number" ){
			return this.getFloat(name);
		}
		else if( parameterType == "char"
				|| parameterType == "string"
				|| parameterType == "" ){
			return this.getChar(name);
		}
		else if( parameterType == "array" ){
			return this.getArray(name);
		}
		else if( parameterType == "dataset" ){
			return this.getDataset(name);
		}
	}
	else{
		return localStorage.getItem(name);
	}
	
	return null;
};

/**
 * @description	미결
 * @param 		{String}	name
 * @return		{String}
 * @example		미결
 */
Parameter.prototype.getSmallint = function(name){
	var value = this.parameterItems[name];
	//Number 타입이 아니거나 NaN인 경우, null 리턴
	if( typeof (value * 1) != "number" || value == NaN ) value = null;
	
	return value;
};
/**
 * @description	미결
 * @param 		{String}	name
 * @return		{String}
 * @example		미결
 */
Parameter.prototype.getInteger = function(name){
	var value = this.parameterItems[name];
	//Number 타입이 아니거나 NaN인 경우, null 리턴
	if( typeof (value * 1) != "number" || value == NaN ) value = null;
	
	return value;
};
/**
 * @description	미결
 * @param 		{String}	name
 * @return		{String}
 * @example		미결
 */
Parameter.prototype.getMoney = function(name){
	var value = this.parameterItems[name];
	//Number 타입이 아니거나 NaN인 경우, null 리턴
	if( typeof (value * 1) != "number" || value == NaN ) value = null;
	
	return value;
};
/**
 * @description	미결
 * @param 		{String}	name
 * @return		{String}
 * @example		미결
 */
Parameter.prototype.getFloat = function(name){
	var value = this.parameterItems[name];
	//Number 타입이 아니거나 NaN인 경우, null 리턴
	if( typeof (value * 1) != "number" || value == NaN ) value = null;
	
	return value;
};
/**
 * @description	미결
 * @param 		{String}	name
 * @return		{String}
 * @example		미결
 */
Parameter.prototype.getChar = function(name){
	var value = this.parameterItems[name];
	//String 타입이 아닌 경우, null 리턴
	if( typeof value != "string" ) value = null;
	
	return value;
};
/**
 * @description	미결
 * @param 		{String}	name
 * @return		{String}
 * @example		미결
 */
Parameter.prototype.getArray = function(name){
	var value = this.parameterItems[name];
	//Array 객체가 아닌 경우, null 리턴
	if( !([] instanceof Array) ) value = null;
	
	return value;
};
/**
 * @description	미결
 * @param 		{String}	name
 * @return		{String}
 * @example		미결
 */
Parameter.prototype.getDataset = function(name){
	var value = this.parameterItems[name];
	//파라메터 값이 없는 경우, null 리턴
	if( typeof value == "undefined" ) value = null;
	
	return value;
};
/**
 * @description	미결
 * @param 		{String}	name
 * @return		{void}
 * @example		미결
 */
Parameter.prototype.remove = function(name){
	var isReturn = false;
	
	if( name in this.parameterInfo ){
		isReturn = this.parameterInfo[name].isreturn;
		delete this.parameterInfo[name];
		this.parameterInfo[name] = null;
	}
	if( name in this.parameterItems ){
		delete this.parameterItems[name];
		this.parameterItems[name] = null;
	}
	
	if( IS_AVAILABLE_LOCALSTORAGE ){
		if( isReturn == true )	localStorage.removeItem(this.returnKey + name);				// 리턴 파라메터
		else					localStorage.removeItem(this.parameterKey + "." + name);	// 파라메터
	}
	
	return;
};

var PARAMETER = new Parameter();

//WsDataSet 업데이트구분 상수
var WSDATASET_UPDATEGU_INFO = {
		//"insert" 	: "X",	//신규 레코드가 추가되면 업데이트 구분은 X로 지정(기본값), 레코드에 __UPDATEGU__ 필드가 없어 undefined 라면 X와 동일 처리, 객체로드시 N으로 추가됨(이 경우 객체에서 처리)
		"insert"	:
		{
			"X" : "X",
			undefined : "X"
		},
		"update"	:
		{
			"changed"	:	//레코드 데이터가 변경된 경우
			{
				"X" : "I",	//X 인 경우, I 로 변경 : 빈 레코드를 수정
				"I" : "I",	//I 인 경우, I 로 유지 : 수정된 레코드를 수정
				"N" : "U",	//N 인 경우, U 로 변경 : 객체로드 된 레코드를 수정
				"U" : "U"	//U 인 경우, U 로 유지 : 수정된 레코드를 수정
			},
			"restored"	:	//레코드 데이터가 변경되지 않은 경우
			{
				"I" : "X",	//I 인 경우, X 로 변경 : 수정된 레코드가 레코드의 최초 데이터로 돌아옴
				"U" : "N",	//U 인 경우, N 으로 변경 : 수정된 레코드가 객체로드 된 레코드 데이터로 돌아옴
				"X" : "X"	//새행을 추가한 후 값이 변경되지 않은 상태에서 update 할 경우 update 구분이 X 이므로 예외가 발생하여 추가
			}
		},
		"delete"	:
		{
			"X" : "E",		//X 인 경우, E 로 변경
			"I" : "E",		//I 인 경우, E 로 변경
			"N" : "D",		//N 인 경우, D 로 변경 : 객체로드 된 레코드를 삭제
			"U" : "D"		//U 인 경우, D 로 변경 : 객체로드 된 레코드를 삭제
		}
};

var WSDATASET_DELETE_POLICY = {
	"DELETE_RECORD_IN_DATA"	: 0,
	"LEAVE_RECORD_IN_DATA"	: 1
};

function WsDataSet(){
	/** [읽기 전용] 필드정보가 들어 있는 객체
	 *  @type {Object}  
	 *  */  	
	this.fieldInfos = {};  // "__...__" 형식은 필드 정보에 넣지 않는다.
	
	/** [읽기 전용] 데이터 셋의 데이터 객체 배열  
	 *  @type {Object[]}  
	 *  */  	
	this.data = [];			//전체 레코드 데이터(updateGu : X, N, I, U)
	
	/** [읽기 전용]데이터 셋의 삭제된 데이터 객체 배열  
	 *  @type {Object[]}  
	 *  */  	
	this.deletedData = [];	//삭제된 레코드 데이터(updateGu : E, D)
	
	/** 데이터 셋의 삭제된 데이터 처리 정책 설정
	 *  @type {Number(CONSTANT)}  
	 *  */
	this.deleteDataPolicy = WSDATASET_DELETE_POLICY.DELETE_RECORD_IN_DATA;
};

/**
 * @description 
 *     JSON 형태의 정보를 받아 데이터셋에 필드명을 추가한다 .
 * 
 * @param 	{Object} 	 fieldinfo	추가될 필드의 정보를 포함하는 JSON 정보 <br>
 * 									- {field: "필드영문아이디", fieldName: "필드명", dataType: "필드에 들어갈 데이터형"}<br>
 * 									- fieldName 속성은 생략가능하며, 생략하는 경우 field속성값과 같은 것으로 취급된다.<br>
 * @return {Object} 				오류정보룰 포함하는 개체 <br>
 * 									- {result: true/false, errorMsg: "사용자메시지"}<br>
 * @example 
 * // 데이터셋객체에 학생ID를 studentId란 필드로 추가하는 경우 
 * var rtnObject = dataset.addField({field: "studentId", fieldName: "학생ID", dataType: "string"});
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 */
WsDataSet.prototype.addField = function( fieldinfo ){
	if (typeof fieldinfo["field"] == "undefined"){    // fieldinfo 객체 필드ID
		return {result: false, errorMsg: getText("message_WSDataSet_001", "필드 정보 중 'field' 속성이 올바르지 않습니다.")};
	}
	if (typeof fieldinfo["dataType"] == "undefined"){ // fieldinfo 객체 필드 데이터타입
		return {result: false, errorMsg: getText("message_WSDataSet_002", "필드 정보 중 필드 'dataType' 속성이 올바르지 않습니다.")};
	}
	
	try{
		this.fieldInfos[fieldinfo.field] = { 
				field : fieldinfo.field, 
				fieldName : fieldinfo.fieldName || fieldinfo.field, 
				dataType : fieldinfo.dataType
		};

	}
	catch(e){
        return {
        	result: false, 
        	errorMsg: getText("message_WSDataSet_000", 
        					  "dataset.{0}({1}) 함수의 실행중 오류가 발생했습니다.\n" + 
        					  " 오류내용 :{2} \n {3}", 
        					  ["addField", JSON.stringify(fieldinfo), e.name, e.description])
        };
	}
	
    return {result: true, errorMsg: ""};
};

/**
 * @description 
 *     JSON 형태의 정보를 받아 데이터셋에 데이터를 교체한다 .
 * 
 * @param 	{Object}	jsonObject	추가될 데이터를 포함하는 JSON 정보 <br>
 *						{ <br>
 *							fieldList : [ <br>
 *								{field : "fieldid", fieldName : "fieldname", dataType : "datatype"}, <br>
 *								{field : "fieldid", fieldName : "fieldname", dataType : "datatype"}, <br>
 *								{field : "fieldid", fieldName : "fieldname", dataType : "datatype"}, <br>
 *								... <br>
 *								{field : "fieldid", fieldName : "fieldname", dataType : "datatype"}, <br>
 *							], <br>
 *							recordList : [ <br>
 *								{field : value, field : value, ... , field : value}, <br>
 *								{field : value, field : value, ... , field : value}, <br>
 *								{field : value, field : value, ... , field : value}, <br>
 *								... <br>
 *								{field : value, field : value, ... , field : value} <br>
 *							], <br>
 *							rowCount : n <br>
 *						} <br>
 * 
 * @return {Object} 				오류정보룰 포함하는 개체 <br>
 * 									- {result: true/false, errorMsg: "사용자메시지"}<br>
 * @example 
 * var rtnObject = dataset.setData(json);
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 */
WsDataSet.prototype.setData = function( jsonObject ){
	var functionName = "setData";
	
	if(typeof jsonObject == "undefined"){
		return {result: false, errorMsg: getText("message_WSDataSet_003", "dataset.{0}(jsonObject) 함수의 jsonObject가 지정되지 않았습니다.", functionName)};
	}
	if(typeof jsonObject["fieldList"] == "undefined"){
		return {result: false, errorMsg: getText("message_WSDataSet_004", "dataset.{0}(jsonObject) 함수의 jsonObject가 'fieldList' 속성을 가지고 있지 않습니다.", functionName)};
	}
	if (!Array.isArray(jsonObject.fieldList)){ 
		return {result: false, errorMsg: getText("message_WSDataSet_005", "dataset.functionName(jsonObject) 함수의 jsonObject가 'fieldList'값은 배열이어야 합니다.", functionName)};
	}

	// 데이터 클리어
	var resultObject = this.clearData();
	if (resultObject.result == false){
		return resultObject;
	}
	
	// 데이터 채우기 
	return this.__addJsonObject(jsonObject, functionName);
};

WsDataSet.prototype.__addJsonObject = function( jsonObject, functionName){
	try{
		// 필드정보 추가
		for(var i = 0; i < jsonObject.fieldList.length; i++){
			var receivedField = jsonObject.fieldList[i];
			var flieldId = "" + receivedField.field;
			
			var field = this.fieldInfos[flieldId] = receivedField;
			field.fieldName = receivedField.fieldName || receivedField.field;
		}

		// 구 데이터 형식 처리 
		if (typeof jsonObject.fieldList.__ROWID__ != "undefined"){
			delete jsonObject.fieldList.__ROWID__;
			
			if (typeof jsonObject.fieldList.__UPDATEGU__ != "undefined"){
				delete jsonObject.fieldList.__UPDATEGU__;
			}
			if (typeof jsonObject.fieldList.__SKIPGU__ != "undefined"){
				delete jsonObject.fieldList.__SKIPGU__;
			}
			if (typeof jsonObject.fieldList.__TEMP_SEQ_KEY__ != "undefined"){
				delete jsonObject.fieldList.__TEMP_SEQ_KEY__;
			}
			if (typeof jsonObject.fieldList.__OLDDATA__ != "undefined"){
				delete jsonObject.fieldList.__OLDDATA__;
			}
			
			for (var i=0; i < jsonObject.recordList.length; i++){
				var record = jsonObject.recordList[i];
				record.__STATE__ = {};
				
				if (typeof record.__ROWID__ != "undefined"){
					record.__STATE__.rowId = "" + record.__ROWID__;
					delete record.__ROWID__;
				}
				if (typeof record.__UPDATEGU__ != "undefined"){
					record.__STATE__.updateGu = record.__UPDATEGU__;
					delete record.__UPDATEGU__;
				}
				if (typeof record.__SKIPGU__ != "undefined"){
					record.__STATE__.skipGu = record.__SKIPGU__;
					delete record.__SKIPGU__;
				}
				if (typeof record.__TEMP_SEQ_KEY__ != "undefined"){
					record.__STATE__.tempSeqKey = record.__TEMP_SEQ_KEY__;
					delete record.__TEMP_SEQ_KEY__;
				}
				if (typeof record.__OLDDATA__ != "undefined"){
					record.__STATE__.oldData = record.__OLDDATA__;
					delete record.__OLDDATA__;
				}
			}
		}
		
		// 데이터 추가 
		this.data = this.data.concat(JSON.parse(JSON.stringify(jsonObject.recordList)));
		
		//rowId 갱신
		var record = null;
		var state = null;
		var scale = Math.pow(10, 16);
		var dataCount = this.data.length;
		var i = 0;
		
		for(i = 0; i < dataCount; i++, state = null, record = null){
			record = this.data[i];
			state = record.__STATE__;
			
			//레코드의 __STATE__ 가 없다면 생성
			if( typeof state == "undefined" )
				state = record.__STATE__ = {};
			
			//__STATE__의 rowId가 없다면 추가
			if( typeof state.rowId == "undefined" )
				state.rowId = "" + Math.round((Math.random() * scale));
		}
	}
	catch(e){
		return {
        	result: false, 
        	errorMsg: getText("message_WSDataSet_000", 
                              "dataset.{0}({1}) 함수의 실행중 오류가 발생했습니다.\n" + 
                              " 오류내용 :{2} \n {3}", 
                              [functionName, "jsonObject", e.name, e.description])
        };
	}
	
	return {result: true, errorMsg: ""};
};


/**
 * @description 
 *     JSON 형태의 정보를 받아 데이터셋에 데이터를 교체한다 .
 * 
 * @param  {Object}		dataSet	추가될 데이터를 포함하는 데이터셋 정보 <br>
 * @return {Object} 				오류정보룰 포함하는 개체 <br>
 * 									- {result: true/false, errorMsg: "사용자메시지"}<br>
 * @example 
 * var rtnObject = dataset.setDataSet(anotherDataset);
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 */
WsDataSet.prototype.setDataSet = function( dataSet ){
	var functionName = "setDataSet";
	
	if(typeof dataSet == "undefined"){
		return {result: false, errorMsg: getText("message_WSDataSet_006", 
				                                 "dataset.{0}(dataSet) 함수의 dataSet이 지정되지 않았습니다.", functionName)};
	}
	if(typeof dataSet["fieldInfos"] == "undefined" || !(dataSet.fieldInfos instanceof Object)){
		return {result: false, errorMsg: getText("message_WSDataSet_007", 
				                                 "dataset.{0}(dataSet) 함수의 인수 dataSet가 객체형태의 'fieldInfos' 속성을 가지고 있지 않습니다.\n" + 
				                                 "제대로 된 데이터셋인지 확인하세요 ", functionName)};
	}
	if(typeof dataSet["data"] == "undefined" || !Array.isArray(dataSet.data)){
		return {result: false, errorMsg: getText("message_WSDataSet_008", 
                								 "dataset.{0}(dataSet) 함수의 인수 dataSet가 배열형태의 'data' 속성을 가지고 있지 않습니다.\n" + 
				                                 "제대로 된 데이터셋인지 확인하세요 ", functionName)};
	}
	
	// 데이터 클리어
	var resultObject = this.clearData();
	if (resultObject.result == false){
		return resultObject;
	}
	
	// 데이터 채우기 
	return this.__addDataSet(dataSet, functionName);
};

WsDataSet.prototype.__addDataSet = function(dataSet, functionName){
	try{
		// 필드정보 추가, 기존에 같은 필드 아이디가 있으면 새로운 값으로 변경되게 된다.
		for(var flieldId in dataSet.fieldInfos){
			var field = this.fieldInfos[flieldId] = JSON.parse(JSON.stringify(dataSet.fieldInfos[flieldId]));
			field.fieldName = field.fieldName || flieldId;
		}
		
		// concat을 하더라도 안의 객체 데이터는 같은 데이터를 가리키므로 복사 기능을 이용한다.
		this.data = this.data.concat(JSON.parse(JSON.stringify(dataSet.data)));
		
		//rowId 갱신
		var record = null;
		var state = null;
		var scale = Math.pow(10, 16);
		var dataCount = this.data.length;
		var i = 0;
		
		for(i = 0; i < dataCount; i++, state = null, record = null){
			record = this.data[i];
			state = record.__STATE__;
			
			//레코드의 __STATE__ 가 없다면 생성
			if( typeof state == "undefined" )
				state = record.__STATE__ = {};
			
			//__STATE__의 rowId가 없다면 추가
			if( typeof state.rowId == "undefined" )
				state.rowId = "" + Math.round((Math.random() * scale));
		}
		
		if (typeof dataSet.deletedData != "undefined"){
			if (typeof this.deletedData != "undefined") {
				this.deletedData = [];
			}
			
			this.deletedData = this.deletedData.concat(JSON.parse(JSON.stringify(dataSet.deletedData)));
		}
	}
	catch(e){
		return {
        	result: false, 
        	errorMsg: getText("message_WSDataSet_000", 
                              "dataset.{0}({1}) 함수의 실행중 오류가 발생했습니다.\n" + 
                              " 오류내용 :{2} \n {3}", 
                              [functionName, "dataSet", e.name, e.description])
        };
	}
	
	return {result: true, errorMsg: ""};
};

/**
 * @description 
 *     JSON 형태의 정보와 칼럼정보를 받아 데이터셋에 데이터를 추가한다 .
 * 
 * @param 	{Object[]}	jsonObject		추가될 데이터를 포함하는 JSON 정보 <br>
 *						[ <br>
 *								{field : value, field : value, ... , field : value}, <br>
  *								{field : value, field : value, ... , field : value}, <br>
 *								{field : value, field : value, ... , field : value}, <br>
 *								... <br>
 *								{field : value, field : value, ... , field : value}, <br>
 *						], <br>
 * @param 	{Object[]}	[columnInfos=Empty Array]		추가될 칼럼정보를 포함하는 JSON 정보 <br>
 *						[ <br>
 *								{dataField : "fieldid", dataType : "datatype"}, <br>
  *								{dataField : "fieldid", dataType : "datatype"}, <br>
 *								... <br>
 *								{dataField : "fieldid", dataType : "datatype"}, <br>
 *						], <br>
 * 
 * @return {Object} 				오류정보룰 포함하는 개체 <br>
 * 									- {result: true/false, errorMsg: "사용자메시지"}<br>
 * @example 
 * var jsonArray = [{studentId : "20170729", studentNm : "홍길동"}, {studentId : "20170730", studentNm : "아모개"}];
 * var columnInfos = [{field : "studentId", fieldName : "학생ID",  dataType : "string"},
 *                    {field : "studentNm", fieldName : "학생이름", dataType : "string"}];
 *                    
 * var rtnObject = setDataArray(jsonArray, columnInfos);
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 */
WsDataSet.prototype.setDataArray = function( jsonArray, columnInfos ){
	var functionName = "setDataArray";
	
	if(typeof jsonArray == "undefined" || !Array.isArray(jsonArray)){
		return {result: false, errorMsg: getText("message_WSDataSet_009", 
                								 "dataset.{0}(jsonArray, columnInfos) 함수의 인수 jsonArray가 배열형태 속성을 가지고 있지 않습니다.\n" + 
				                                 "제대로 된 데이터 배열인지 확인하세요 ", functionName)};
	}
	if(jsonArray.length == 0){
		return {result: false, errorMsg: getText("message_WSDataSet_010", 
                								 "dataset.{0}(jsonArray, columnInfos) 함수의 인수 jsonArray가 데이터를 가지고 있지 않습니다.\n" + 
				                                 "데이터를 확인하세요 ", functionName)};
	}
	if(typeof columnInfos == "undefined"){
		columnInfos = [];
	} else {
		if(!Array.isArray(columnInfos)){
			return {result: false, errorMsg: getText("message_WSDataSet_011", 
	                								 "dataset.{0}(jsonArray, columnInfos) 함수의 인수 columnInfos가 배열형태 속성을 가지고 있지 않습니다.\n" + 
					                                 "제대로 된 데이터 배열인지 확인하세요 ", functionName)};
		}
		if(columnInfos.length > 0 && typeof columnInfos[0].field == "undefined" || 
				typeof columnInfos[0].fieldName == "undefined"){
			return {result: false, errorMsg: getText("message_WSDataSet_013", 
	                								 "dataset.{0}(jsonArray, columnInfos) 함수의 인수 columnInfos가 정상적인 칼럼개체가 아닙니다.\n" + 
					                                 "배열의 내용을 확인하세요", functionName)};
		}
	} 
	
	// 데이터 클리어
	var resultObject = this.clearData();
	if (resultObject.result == false){
		return resultObject;
	}
	// 데이터 채우기 
	return this.__addDataArray(functionName, jsonArray, columnInfos);
};

WsDataSet.prototype.__addDataArray = function(functionName, jsonArray, columnInfos){
	try{
		// 필드정보 추가, 기존에 같은 필드 아이디가 있으면 새로운 값으로 변경되게 된다.
		for(var i = 0; i < columnInfos.length; i++){
			var columnInfo = columnInfos[i];
			var fieldId = columnInfo.field;
			
			this.fieldInfos[fieldId] = {
					field: fieldId, 
					fieldName: columnInfo.fieldName || fieldId,
					dataType: (columnInfo.dataType == "number") ? "number" : "string"
			};
		}
		
		// concat을 하더라도 안의 객체 데이터는 같은 데이터를 가리키므로 복사 기능을 이용한다.
		this.data = this.data.concat(JSON.parse(JSON.stringify(jsonArray)));
		
		//rowId 갱신
		var record = null;
		var state = null;
		var scale = Math.pow(10, 16);
		var dataCount = this.data.length;
		var i = 0;
		
		for(i = 0; i < dataCount; i++, state = null, record = null){
			record = this.data[i];
			state = record.__STATE__;
			
			//레코드의 __STATE__ 가 없다면 생성
			if( typeof state == "undefined" )
				state = record.__STATE__ = {};
			
			//__STATE__의 rowId가 없다면 추가
			if( typeof state.rowId == "undefined" )
				state.rowId = "" + Math.round((Math.random() * scale));
		}
	}
	catch(e){
		return {
        	result: false, 
        	errorMsg: getText("message_WSDataSet_000", 
                              "dataset.{0}({1}) 함수의 실행중 오류가 발생했습니다.\n" + 
                              " 오류내용 :{2} \n {3}", 
                              [functionName, "dataSet", e.name, e.description])
        };
	}
	
	return {result: true, errorMsg: ""};
};


/**
 * @description 
 *     JSON 형태의 정보를 받아 데이터셋에 데이터를 추가한다 .
 * 
 * @param 	{Object}	jsonObject	추가될 데이터를 포함하는 JSON 정보 <br>
 *						{ <br>
 *							fieldList : [ <br>
 *								{field : "fieldid", fieldName : "fieldname", dataType : "datatype"}, <br>
 *								{field : "fieldid", fieldName : "fieldname", dataType : "datatype"}, <br>
 *								{field : "fieldid", fieldName : "fieldname", dataType : "datatype"}, <br>
 *								... <br>
 *								{field : "fieldid", fieldName : "fieldname", dataType : "datatype"}, <br>
 *							], <br>
 *							recordList : [ <br>
 *								{field : value, field : value, ... , field : value}, <br>
 *								{field : value, field : value, ... , field : value}, <br>
 *								{field : value, field : value, ... , field : value}, <br>
 *								... <br>
 *								{field : value, field : value, ... , field : value} <br>
 *							], <br>
 *							rowCount : n <br>
 *						} <br>
 * 
 * @return {Object} 				오류정보룰 포함하는 개체 <br>
 * 									- {result: true/false, errorMsg: "사용자메시지"}<br>
 * @example 
 * var rtnObject = dataset.setData(json);
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 */
WsDataSet.prototype.appendData = function( jsonObject ){
	var functionName = "appendData";
	
	if(typeof jsonObject == "undefined"){
		return {result: false, errorMsg: getText("message_WSDataSet_003", "dataset.{0}(jsonObject) 함수의 jsonObject가 지정되지 않았습니다.", functionName)};
	}
	if(typeof jsonObject["fieldList"] == "undefined"){
		return {result: false, errorMsg: getText("message_WSDataSet_004", "dataset.{0}(jsonObject) 함수의 jsonObject가 'fieldList' 속성을 가지고 있지 않습니다.", functionName)};
	}
	if (!Array.isArray(jsonObject.fieldList)){ 
		return {result: false, errorMsg: getText("message_WSDataSet_005", "dataset.functionName(jsonObject) 함수의 jsonObject가 'fieldList'값은 배열이어야 합니다.", functionName)};
	}
	
	// 데이터 채우기 
	return this.__addJsonObject(jsonObject, functionName);
};

/**
 * @description 
 *     JSON 형태의 정보를 받아 데이터셋에 데이터를 추가한다 .
 * 
 * @param  {Object}		dataSet	추가될 데이터를 포함하는 데이터셋 정보 <br>
 * @return {Object} 				오류정보룰 포함하는 개체 <br>
 * 									- {result: true/false, errorMsg: "사용자메시지"}<br>
 * @example 
 * var rtnObject = dataset.setDataSet(anotherDataset);
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 */
WsDataSet.prototype.appendDataSet = function( dataSet ){
	var functionName = "appendDataSet";
	
	if(typeof dataSet == "undefined"){
		return {result: false, errorMsg: getText("message_WSDataSet_006", 
				                                 "dataset.{0}(dataSet) 함수의 dataSet이 지정되지 않았습니다.", functionName)};
	}
	if(typeof dataSet["fieldInfos"] == "undefined" || !(dataSet.fieldInfos instanceof Object)){
		return {result: false, errorMsg: getText("message_WSDataSet_007", 
				                                 "dataset.{0}(dataSet) 함수의 인수 dataSet가 배열형태의 'fieldList' 속성을 가지고 있지 않습니다.\n" + 
				                                 "제대로 된 데이터셋인지 확인하세요 ", functionName)};
	}
	if(typeof dataSet["data"] == "undefined" || !Array.isArray(dataSet.data)){
		return {result: false, errorMsg: getText("message_WSDataSet_008", 
                								 "dataset.{0}(dataSet) 함수의 인수 dataSet가 배열형태의 'data' 속성을 가지고 있지 않습니다.\n" + 
				                                 "제대로 된 데이터셋인지 확인하세요 ", functionName)};
	}
	
	// 데이터 채우기 
	return this.__addDataSet(dataSet, functionName);
}; 

/**
 * @description 
 *     JSON 형태의 정보와 칼럼정보를 받아 데이터셋에 데이터를 추가한다 .
 * 
 * @param 	{Object[]}	jsonObject	추가될 데이터를 포함하는 JSON 정보 <br>
 *						[ <br>
 *								{field : value, field : value, ... , field : value}, <br>
  *								{field : value, field : value, ... , field : value}, <br>
 *								{field : value, field : value, ... , field : value}, <br>
 *								... <br>
 *								{field : value, field : value, ... , field : value}, <br>
 *						], <br>
 * @param 	{Object[]}	jsonObject	추가될 칼럼정보를 포함하는 JSON 정보 <br>
 *						[ <br>
 *								{dataField : "fieldid", dataType : "datatype"}, <br>
  *								{dataField : "fieldid", dataType : "datatype"}, <br>
 *								... <br>
 *								{dataField : "fieldid", dataType : "datatype"}, <br>
 *						], <br>
 * 
 * @return {Object} 				오류정보룰 포함하는 개체 <br>
 * 									- {result: true/false, errorMsg: "사용자메시지"}<br>
 * @example 
 * var jsonArray = [{studentId : "20170729", studentNm : "홍길동"}, {studentId : "20170730", studentNm : "아모개"}];
 * var columnInfos = [{field : "studentId", fieldName : "학생ID",  dataType : "string"},
 *                    {field : "studentNm", fieldName : "학생이름", dataType : "string"}];
 *                    
 * var rtnObject = setDataArray(jsonArray, columnInfos);
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 */
WsDataSet.prototype.appendDataArray = function( jsonArray, columnInfos ){
	var functionName = "appendDataArray";
	
	if(typeof jsonArray == "undefined" || !Array.isArray(jsonArray)){
		return {result: false, errorMsg: getText("message_WSDataSet_009", 
                								 "dataset.{0}(jsonArray, columnInfos) 함수의 인수 jsonArray가 배열형태 속성을 가지고 있지 않습니다.\n" + 
				                                 "제대로 된 데이터 배열인지 확인하세요 ", functionName)};
	}
	if(jsonArray.length == 0){
		return {result: false, errorMsg: getText("message_WSDataSet_010", 
                								 "dataset.{0}(jsonArray, columnInfos) 함수의 인수 jsonArray가 데이터를 가지고 있지 않습니다.\n" + 
				                                 "데이터를 확인하세요 ", functionName)};
	}
	if(typeof columnInfos == "undefined" || !Array.isArray(columnInfos)){
		return {result: false, errorMsg: getText("message_WSDataSet_011", 
                								 "dataset.{0}(jsonArray, columnInfos) 함수의 인수 columnInfos가 배열형태 속성을 가지고 있지 않습니다.\n" + 
				                                 "제대로 된 데이터 배열인지 확인하세요 ", functionName)};
	}
	if(columnInfos.length == 0){
		return {result: false, errorMsg: getText("message_WSDataSet_012", 
                								 "dataset.{0}(jsonArray, columnInfos) 함수의 인수 columnInfos가 데이터를 가지고 있지 않습니다.\n" + 
				                                 "데이터를 확인하세요", functionName)};
	}
	if(typeof columnInfos[0].dataField == "undefined" || 
			typeof columnInfos[0].headerText == "undefined"){
		return {result: false, errorMsg: getText("message_WSDataSet_013", 
                								 "dataset.{0}(jsonArray, columnInfos) 함수의 인수 columnInfos가 정상적인 칼럼개체가 아닙니다.\n" + 
				                                 "배열의 내용을 확인하세요", functionName)};
	}
	
	// 데이터 채우기 
	return this.__addDataArray(functionName, jsonArray, columnInfos);
};

/**
 * @description 
 *     데이터셋의 데이터를 메시지 객체에 담아 리턴한다 .
 *     
 * @return {Object} 오류정보룰 포함하는 개체 <br>
 * 			- {    
 *              result: true/false, 
 *              errorMsg: "사용자메시지",
 *              resultData: 
 *				[
 *					{field : value, field : value, ... , field : value},
 *					{field : value, field : value, ... , field : value},
 *					...
 *					{field : value, field : value, ... , field : value},
 *				]
 *           } <br>
 * @example 
 * var rtnObject = getData();
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 * 
 * alert("데이터수: " + rtnObject.resultData.length);
 * 
 */
WsDataSet.prototype.getData = function(){
	try{
		return {
			result: true, 
			errorMsg: "",
			resultData: JSON.parse(JSON.stringify(this.data))
		};
	}
	catch(e){
		return {
        	result: false, 
        	errorMsg: getText("message_WSDataSet_000", 
                              "dataset.{0}({1}) 함수의 실행중 오류가 발생했습니다.\n" + 
                              " 오류내용 :{2} \n {3}", 
                              [functionName, "dataSet", e.name, e.description])
        };
	}
	
	return null;
};

/**
 * @description 
 *     데이터셋의 데이터와 필드 정보를 완전히 초기화 한다, <br>
 *     clearData() 메서드는 필드정보는 그대로 두는 반면 <br>
 *     clear()는 필드정보까지 모두를 초기화 하는 점이 다르다 .<br>
 *     
 * @return {Object} 오류정보룰 포함하는 개체 <br>
 * 			- {    
 *              result: true/false, 
 *              errorMsg: "사용자메시지",
 *            } <br>
 * @example 
 * var rtnObject = dataset.clear();
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 *  
 */
WsDataSet.prototype.clear = function(){
	try{
		//필드 클리어 및 메모리 초기화
		delete this.fieldInfos;
		
		this.fieldInfos = {};
		
		//데이터 클리어 및 메모리 초기화
		var resultObject = this.clearData();
		if (resultObject.result == false){
			return resultObject;
		}
	}
	catch(e){
		return {
        	result: false, 
        	errorMsg: getText("message_WSDataSet_000", 
                              "dataset.{0}({1}) 함수의 실행중 오류가 발생했습니다.\n" + 
                              " 오류내용 :{2} \n {3}", 
                              [functionName, "dataSet", e.name, e.description])
        };
	}
	
	return {result: true, errorMsg: ""};
};

/**
 * @description 
 *     데이터셋의 데이터를 빈상태로 초기화 한다, <br>
 *     clearData() 메서드는 필드정보는 그대로 두는 반면 <br>
 *     clear()는 필드정보까지 모두를 초기화 하는 점이 다르다 .<br>
 *     
 * @return {Object} 오류정보룰 포함하는 개체 <br>
 * 			- {    
 *              result: true/false, 
 *              errorMsg: "사용자메시지",
 *            } <br>
 * @example 
 * var rtnObject = dataset.clearData();
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 */
WsDataSet.prototype.clearData = function(){
	try{
		for (var i = 0; i < this.data.length; i++){
			if (typeof this.data[i].__STATE__ == "undefined") continue;
			if (typeof this.data[i].__STATE__.oldData == "undefined") continue;
			
			delete this.data[i].__STATE__.oldData;
		}
		this.data.clear();

		for (var i = 0; i < this.deletedData.length; i++){
			if (typeof this.deletedData[i].__STATE__ == "undefined") continue;
			if (typeof this.deletedData[i].__STATE__.oldData == "undefined") continue;
			
			delete this.deletedData[i].__STATE__.oldData;
		}
		this.deletedData.clear();
	}
	catch(e){
		return {
        	result: false, 
        	errorMsg: getText("message_WSDataSet_000", 
                              "dataset.{0}({1}) 함수의 실행중 오류가 발생했습니다.\n" + 
                              " 오류내용 :{2} \n {3}", 
                              [functionName, "dataSet", e.name, e.description])
        };
	}
	
	return {result: true, errorMsg: ""};
};

/**
 * @description 
 *     데이터셋의 데이터의 갯수를 리턴하는 함수 <br>
 *     
 * @param {Boolean}	[notIncludeDeleted=false] 	 - 삭제된 레코드를 포함할 것인지 여부를 지정 <br>
 *			                                   1) true : 삭제된 레코드를 포함하지 않은 레코드 수<br>
 *			                                   2) false / undefined : 삭제된 레코드 포함한 모든 레코드 수<br>
 * @return {Number}                            데이터의 갯수 <br>

 * @example 
 *     alert(dataset.getCount());   // 데이터의 갯수를 표시
 */
WsDataSet.prototype.getCount = function( notIncludeDeleted ){
	if (typeof notIncludeDeleted == "undefined") {
		notIncludeDeleted = false;
	}
	
	var count = this.data.length + (notIncludeDeleted ? this.deletedData.length : 0);
	
	return  count;
};

/**
 * @description 
 *     데이터셋에서 무효데이터를 제외한 레코드의 인덱스를 리턴하는 함수 <br>
 *     
 * @param {Number} 	 row 	 - 코드의 인덱스를 찾을 행
 * @return {Number}          - 레코드를 찾은 경우 해당 레코드의 인덱스를 리턴하고, 찾지 못한 경우 -1을 리턴<br>

 * @example 
 *     alert(dataset.getIndex(3));   // 세번째 유효 데이터의 인덱스값
 */
WsDataSet.prototype.getIndex = function( row ){
	var rowIndex = -1;
	
	try{
		//레코드 중  삭제되지 않은 레코드 중 row 와 같은 순서의 레코드 인덱스를 리턴
		var idx = 0;
		for(var i = 0; i < this.data.length; i++){
			//삭제된 행은 체크하지 않음
			var updateGu = this.getState(i, "updateGu");
			if( updateGu == "D" || updateGu == "E" ) continue;
			
			if( row == idx++){  //row 와 idx 가 같은 경우
				rowIndex = i;
				break;
			}
		}
	}
	catch(e){
		return {
        	result: false, 
        	errorMsg: getText("message_WSDataSet_000", 
                              "dataset.{0}({1}) 함수의 실행중 오류가 발생했습니다.\n" + 
                              " 오류내용 :{2} \n {3}", 
                              ["getIndex", "", e.name, e.description])
        };
	}
	
	return rowIndex;
};

/**
 * @description 
 *     데이터셋에서 rowId에 해당하는 레코드의 인덱스를 리턴하는 함수 <br>
 *     
 * @param  {String} 	 rowId 	 - 코드의 인덱스를 찾을 행
 * @return {Number}              - 레코드를 찾은 경우 해당 레코드의 인덱스를 리턴하고, 찾지 못한 경우 -1을 리턴<br>

 * @example 
 *     alert(dataset.getIndex("id1234"));   // "id1234"에 해당하는 데이터의 인덱스값
 */
WsDataSet.prototype.getInexByRowId = function( rowId ){
	var rowIndex = -1;
	
	try{
		var dataCount = this.data.length;
		var i = 0;
		
		//레코드 중  삭제되지 않은 레코드 중 row 와 같은 순서의 레코드 인덱스를 리턴
		for(i = 0; i < dataCount; i++){
			if( rowId == this.getState(i, "rowId")){ 
				rowIndex = i;
				break;
			}
		}
	}
	catch(e){
		return {
        	result: false, 
        	errorMsg: getText("message_WSDataSet_000", 
                              "dataset.{0}({1}) 함수의 실행중 오류가 발생했습니다.\n" + 
                              " 오류내용 :{2} \n {3}", 
                              ["getInexByRowId", "", e.name, e.description])
        };
	}
	
	return rowIndex;
};


/**
 * @description 
 *     데이터셋에서 레코드의 상태를 변경하는 함수 <br>
 *     
 * @param  {String}  action 	 		- 레코드 동작 : "insert", "update", "delete"
 * @param  {Object}  record 	 		- 변경할 레코드 객체
 * @param  {Boolean} [isChanged=true] 	- action 파라메터가 update 인 경우에만 사용되는 데이터의 변경 여부
 * 
 * @return {Number}              - 레코드를 찾은 경우 해당 레코드의 인덱스를 리턴하고, 찾지 못한 경우 -1을 리턴<br>

 * @example 
 *    var action = "insert";
 *    var record = this.data[indexToDelete];
 *    var isChanged = true;
 * 
 *    var bResult = dataset._changeRecordUpdateGu(action, record, isChanged);
 *    
 *    if (!bResult) alert("레코드의 상태를 수정하지 못했습니다."); 
 */
WsDataSet.prototype._changeRecordUpdateGu = function(action, record, isChanged){
	var wReturn = false;
	var oldUpdateGu = record.__STATE__.updateGu;		// 이전 __UPDATEGU__ 를 백업하여 오류 발생시 이전 상태로 복귀하기 위해 필요
	
	try{
		var key = "";
		var updateGuInfo = null;
		
		//WsDataSet 업데이트 구분 상수를 각 action 에 맞는 배열을 구함
		switch(action){
		case "insert":
			updateGuInfo = WSDATASET_UPDATEGU_INFO[action];
			break;
		case "update":
			updateGuInfo = (WSDATASET_UPDATEGU_INFO[action])[(isChanged ? "changed" : "restored")];
			break;
		case "delete":
			updateGuInfo = WSDATASET_UPDATEGU_INFO[action];
			break;
		default :
			//action 이 올바르지 않음
			throw 1;
		}
		
		//레코드 __UPDATEGU__ 갱신
		record.__STATE__.updateGu = updateGuInfo[record.__STATE__.updateGu];
		//레코드 __UPDATEGU__ 가 undefined 인 경우, 업데이트 구분이 정상적으로 반영되지 않음
		if(typeof  record.__STATE__.updateGu == "undefined"){
			throw 2;
		}
		
		wReturn = true;
	}
	catch(err){
		//레코드의 __UPDATEGU__ 를 이전 __UPDATEGU__ 로 복구
		 record.__STATE__.updateGu = oldUpdateGu;
		//리턴 false
		wReturn = false;
	}
	
	return wReturn;
};

/**
 * @description 
 *     데이터셋에 데이터를 신규로 추가한다.<br>
 *     
 * @param {Number}	[indexToInsert=maxRows] 	 - 행을 삽입할 행 인덱스, 생략하는 경우, 행을 데이터 맨 끝에 추가
 * @return {Object} 오류정보룰 포함하는 개체 <br>
 * 			- {    
 *              result: true/false, 
 *              errorMsg: "사용자메시지",
 *            } <br>
 * @example 
 * var rtnObject = dataset.insertData(10);
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * } else {
 *     alert("추가된 레코드ID: " + rtnObject.recordID);
 *     alert("추가된 레코드번호: " + rtnObject.recordIndex);
 * }
 */
WsDataSet.prototype.insertData = function(indexToInsert){
	//행번호 체크, 인덱스는 undefined 와 number 만 가능함
	if (typeof indexToInsert == "undefined"){
		// 마지막줄에 추가된다 
		indexToInsert = this.getCount();
		
	} else if (typeof indexToInsert == "number"){
		//인덱스가 number 인 경우, 인덱스는 0보다 크고 레코드 수보다 작아야 함
		if(indexToInsert < 0 || indexToInsert > this.getCount()){ 
			return {result: false, 
				   errorMsg: getText("message_WSDataSet_015", 
						             "dataset.{0}({1}) 함수의 인수{1}의 값 \n'{2}'이 적정한 줄번호 범위내에 있지 않습니다.\n" + 
                                     "레코드번호를 다시 확인하세요 ", ["insertData", "indexToInsert", indexToInsert])};
		}
	} else {
		return {result: false, 
			    errorMsg: getText("message_WSDataSet_016", 
			    		          "dataset.{0}({1}) 함수의 인수{1}는 숫자형태의 인수이어야 합니다.\n" + 
                                  "'{2}' 데이터형을 '숫자형태'로 조정하세요  ", ["insertData", "indexToInsert", typeof(indexToInsert)])};
	}
	
	try{
		//새 레코드 생성
		var rowId = "" + Math.round((Math.random() * Math.pow(10, 16)));
		var record = {__STATE__: {rowId: rowId}};
		
		//레코드에 필드 추가
		for(var key in this.fieldInfos){
			//필드의 기본정보 __XXXX__를 레코드에 추가하지 않음
			if(/^__.*__$/.test(key)) continue;
			
			var field = this.fieldInfos[key];
			
			//필드의 타입이 number 인 경우 기본값은 0으로  string 인 경우 ""로 그 외는 null 로 초기화
//			record[key] = (field.dataType == "number") ? 0 : 
//				          (field.dataType == "string") ? "" : null;
			record[key] = (field.dataType == "number" || field.dataType == "string") ? "" : null;
		}
		
		//추가된 레코드의 __UPDATEGU__ 갱신
		var updated = this._changeRecordUpdateGu("insert", record);
		if( !updated ){ 
			return {result: false, 
		            errorMsg: getText("message_WSDataSet_017", 
	                                  "dataset._changeRecordUpdateGu('{0}', record)를 정상적으로 처리하지 멋했습니다.\n" + 
                                      "record: {1}", ["insert", JSON.stringify(record)])};
		}
		
		cond = 11;
		// 새 레코드 추가, 해당 인덱스에 행을 삽입
		this.data.splice(indexToInsert, 0, record);
		
		// 필터링되어 originData가 생성되었다면 originData에도 레코드를 추가해야함
		if( typeof this.originData != "undefined"
			&& (this.originData instanceof Array && this.originData.length > 0)
		){
			var data = null;
			var beforeRecord = null;
			var maxLength = 0;
			var i = 0;
			
			//data에 추가된 레코드의 인덱스를 찾아 이전 레코드 객체를 찾음
			for(data = this.data, maxLength = data.length, i = 0; i < maxLength; i++){
				if( data[i] === record ){
					beforeRecord = data[(i <= 0 ? 0 : i - 1)];
					break;
				}
			}
			//originData에 data에서 찾은 이전 레코드와 같은 레코드 뒤에 레코드를 추가
			for(data = this.originData, maxLength = data.length, i = 0; i < maxLength; i++){
				if( data[i] === beforeRecord ){
					data.splice(i + 1, 0, record);
					break;
				}
			}
			
			//메모리 해제
			beforeRecord = null; data = null;
		}
		
		//메모리 해제
		record = null;
		
		return {result : true, 
			    errorMsg : "",
			    recordID: rowId,
			    recordIndex: indexToInsert};
		
	}
	catch(e){
		return {
        	result: false, 
        	errorMsg: getText("message_WSDataSet_000", 
                              "dataset.{0}({1}) 함수의 실행중 오류가 발생했습니다.\n" + 
                              " 오류내용 :{2} \n {3}", 
                              ["insertData", "indexToInsert", e.name, e.description])
        };
	}
	
	return null;
};

/**
 * @description 
 *     데이터셋에서 줄번호를 지정하여 데이터를 삭제한다<br>
 *     
 * @param {Number} 	 indexToDelete 	 - 행을 삭제할 행 인덱스, 생략할 수 없다.
 * @return {Object} 오류정보룰 포함하는 개체 <br>
 * 			- {    
 *              result: true/false, 
 *              errorMsg: "사용자메시지",
 *            } <br>
 * @example 
 * var rtnObject = dataset.deleteData(10);
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 */
WsDataSet.prototype.deleteData = function(indexToDelete){
	//행번호 체크, number 만 가능함
	if (typeof indexToDelete == "undefined"){
		return {result: false, 
		    errorMsg: getText("message_WSDataSet_014", 
		    		          "dataset.{0}({1}) 함수의 인수 {1} 인수가 없습니다.\n" + 
                              "인수를 확인하세요 ", ["deleteData", "indexToDelete"])};
                              
	} else if (typeof indexToDelete == "number"){
		//인덱스가 number 인 경우, 인덱스는 0보다 크고 레코드 수보다 작아야 함
		if(indexToDelete < 0 || indexToDelete >= this.getCount()){ 
			return {result: false, 
				    errorMsg: getText("message_WSDataSet_015", 
				    		          "dataset.{0}({1}) 함수의 인수{1}의 값 \n'{2}'이 적정한 줄번호 범위내에 있지 않습니다.\n" + 
                                      "레코드번호를 다시 확인하세요 ", ["deleteData", "indexToDelete",  indexToInsert])};
		}
	} else {
		return {result: false, 
			    errorMsg: getText("message_WSDataSet_016", 
			    		          "dataset.{0}({1}) 함수의 인수{1}는 숫자형태의 인수이어야 합니다.\n" + 
                                  "'{2}' 데이터형을 '숫자형태'로 조정하세요  ",  ["deleteData", "indexToDelete",  typeof(indexToInsert)])};
	}
	
	try{
		var record = this.data[indexToDelete];
		
		//추가된 레코드의 __UPDATEGU__ 갱신
		var updated = this._changeRecordUpdateGu("delete", record);
		if( !updated ){ 
			return {result: false, 
		            errorMsg: getText("message_WSDataSet_017", 
	                                  "dataset._changeRecordUpdateGu('{0}', record)를 정상적으로 처리하지 멋했습니다.\n" + 
                                      "record: {1}", ["delete", JSON.stringify(record)])};
		}
		
		// data 배열에서 deletedData 로 레코드 이동 
		this.deletedData.push(record);
		// data 배열에서 레코드 삭제 정책에 따라 data 배열에서 데이터 삭제 처리
		if( this.deleteDataPolicy === WSDATASET_DELETE_POLICY.DELETE_RECORD_IN_DATA ){
			this.data.splice(indexToDelete, 1);
			
			// 필터링되어 originData가 생성되었다면 originData에도 레코드를 삭제해야함
			if( typeof this.originData != "undefined"
				&& (this.originData instanceof Array && this.originData.length > 0)
			){
				var data = null;
				var maxLength = 0;
				var i = 0;
				
				//originData에서 삭제한 레코드와 같은 레코드 객체의 인덱스를 찾아 삭제
				for(data = this.originData, maxLength = data.length, i = 0; i < maxLength; i++){
					if( data[i] === record ){
						data.splice(i, 1);
						break;
					}
				}
				
				//메모리 해제
				data = null;
			}
		}
		
		record = null;
		
		return {result : true, errorMsg : ""};
	}
	catch(e){
		return {
        	result: false, 
        	errorMsg: getText("message_WSDataSet_000", 
                              "dataset.{0}({1}) 함수의 실행중 오류가 발생했습니다.\n" + 
                              " 오류내용 :{2} \n {3}", 
                              ["insertData", "indexToInsert", e.name, e.description])
        };
	}
	
	return null;
};

/**
 * @description 
 *     데이터셋에서 줄번호를 지정하여 데이터를 삭제한다<br>
 *     
 * @param {Number} 	 indexToDelete 	 - 행을 삭제할 행 인덱스, 생략할 수 없다.
 * @param {Object} 	 jsonDataObject  - 수정할 내용이 들어 있는 객체 .<br>
 *                                     {field : value, field : value, ... field : value}
 * 
 * @return {Object} 오류정보룰 포함하는 개체 <br>
 * 			- {    
 *              result: true/false, 
 *              errorMsg: "사용자메시지",
 *            } <br>
 * @example 
 * var rtnObject = dataset.updateData(10, jsonDataObject);
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 */
WsDataSet.prototype.updateData = function( indexToUpdate, jsonDataObject ){
	//행번호 체크, number 만 가능함
	if (typeof indexToUpdate == "undefined"){
		return {result: false, 
		    errorMsg: getText("message_WSDataSet_014", 
		    		          "dataset.{0}({1}) 함수의 인수 {1} 인수가 없습니다.\n" + 
                              "인수를 확인하세요 ", ["updateData", "indexToUpdate"])};
                              
	} else if (typeof indexToUpdate == "number"){
		//인덱스가 number 인 경우, 인덱스는 0보다 크고 레코드 수보다 작아야 함
		if(indexToUpdate < 0 || indexToUpdate >= this.getCount()){ 
			return {result: false, 
				    errorMsg: getText("message_WSDataSet_015", 
				    		          "dataset.{0}({1}) 함수의 인수{1}의 값 \n'{2}'이 적정한 줄번호 범위내에 있지 않습니다.\n" + 
                                      "레코드번호를 다시 확인하세요 ", ["updateData", "indexToUpdate",  indexToUpdate])};
		}
		
	} else if (typeof indexToUpdate == "string" ){
		indexToUpdate = this.getInexByRowId(indexToUpdate);	 // 레코드 ID 로 레코드의 인덱스를 찾음
		
		if( indexToUpdate < 0 ){ 
			return {result: false, 
				errorMsg: getText("message_WSDataSet_018", 
						          "dataset.{0}({1}) 함수의 인수{1}는 줄번호 또는 rowId 이어야 합니다.\n" + 
						          "인수값 {2} 를 알맞게  조정하세요  ",  ["updateData", "indexToUpdate",  indexToUpdate])};

		}
	} else {
		return {result: false, 
			    errorMsg: getText("message_WSDataSet_018", 
			    		          "dataset.{0}({1}) 함수의 인수{1}는 줄번호 또는 rowId 이어야 합니다.\n" + 
				                  "인수값 {2} 를 알맞게  조정하세요  ",  ["updateData", "indexToUpdate",  indexToUpdate])};
	}
	
	try{
		var record = this.data[indexToUpdate];
		var oldRecord = JSON.parse(JSON.stringify( this.data[indexToUpdate] ));	 //이전 레코드 객체를 복사하여 백업
		
		if( typeof record.__STATE__ == "undefined" ){
			record.__STATE__ = {};
		}
		
		// 레코드의 __UPDATEGU__ 가 undefined 인 경우 X 와 같음
		if( typeof record.__STATE__.updateGu == "undefined" ){
			record.__STATE__.updateGu = "X";
		}
		
		if( typeof record.__STATE__.oldData == "undefined" || 
				   record.__STATE__.oldData == null ){
			record.__STATE__.oldData = {};
		}
		
		var record_oldData_ = record.__STATE__.oldData;
		var isChanged = false;
		var key = null;
		
		//레코드 데이터 갱신
		for(key in this.fieldInfos){
			//필드의 기본정보 __XXXX__를 레코드에 추가하지 않음
			if (/^__.*__$/.test(key)) continue;
			
			//__OLDDATA__ 에 해당 필드가 없는 경우 변경 이력이 없는 필드로 __OLDDATA__ 에 추가하여 old value 를 보관
			if(typeof record_oldData_[key] == "undefined"){
				//필드의 타입이 number 인 경우 기본값은 0으로  string 인 경우 ""로 그 외는 null 로 초기화
				record_oldData_[key] = record[key];
			}
			
			if( typeof jsonDataObject[key] == "undefined" ) continue;
			
			//수정된 데이터 적용
			record[key] = jsonDataObject[key];
			
			//데이터가 변경되었는지 확인
			//변경되었으면 isChanged 가 true 가 되고, 변경되지 않았다면 그대로 false 로 유지됨
			if( !isChanged ){
				isChanged = (record_oldData_[key] !== record[key]);
			}
			
			key = null;
		}
		
		//수정한 데이터가 이전 데이터와 동일하여 isChanged 가 false인 경우 전체 데이터를 대상으로 데이터 변경된 상태인지 체크  
		if( !isChanged ){
			for(key in this.fieldInfos){
				//데이터가 변경되었으면 더이상 체크하지 않고 빠져나감
				if( isChanged ) break;
				//isChanged 가 false인 경우 변경 여부 체크
				else isChanged = (record_oldData_[key] !== record[key]);
				//메모리 해제
				key = null;
			}
		}

		//추가된 레코드의 __UPDATEGU__ 갱신
		var updated = this._changeRecordUpdateGu("update", record, isChanged);
		if( !updated ){ 
			//데이터 변경 중 오류가 발생한 경우 이전 데이터로 복구
			this.data[indexToUpdate] = oldRecord;
			
			return {result: false, 
		            errorMsg: getText("message_WSDataSet_017", 
	                                  "dataset._changeRecordUpdateGu('{0}', record)를 정상적으로 처리하지 멋했습니다.\n" + 
                                      "record: {1}", ["update", JSON.stringify(record)])};
		}
		
		//메모리 해제
		delete oldRecord.__STATE__;
		delete oldRecord;
		record_oldData_ = null;
		oldRecord = null;
		record = null;
		
		return {result : true, errorMsg : ""};
		
	}
	catch(e){
		return {
        	result: false, 
        	errorMsg: getText("message_WSDataSet_000", 
                              "dataset.{0}({1}) 함수의 실행중 오류가 발생했습니다.\n" + 
                              " 오류내용 :{2} \n {3}", 
                              ["insertData", "indexToInsert", e.name, e.description])
        };
	}
	
	return null;
};


// 상태값들을 조회하는 함수 
WsDataSet.prototype.getState = function(rowNum, propertyName){
	var data = this.data[rowNum];
	
	if (typeof data.__STATE__ == "undefined"){
		data.__STATE__ = {};
	}
	
	return data.__STATE__[propertyName];
};

//상태값들을 설정하는 함수 
WsDataSet.prototype.setState = function(rowNum, propertyName, value){
	var data = this.data[rowNum];
	
	if (typeof data.__STATE__ == "undefined"){
		data.__STATE__ = {};
	}
	
	data.__STATE__[propertyName] = value;
	
	return ;
};

WsDataSet.prototype.setOldValue = function(rowNum, fieldId, value){
	var oldData = this.getState(rowNum, "oldData");
	if (typeof oldData == "undefined"){
		oldData = this.data[rowNum].__STATE__.oldData = {};
	}
	
	oldData[fieldId] = value;
};
WsDataSet.prototype.getOldValue = function(rowNum, fieldId){
	var oldData = this.getState(rowNum, "oldData");
	if (typeof oldData == "undefined") return null;
	if (typeof oldData[fieldId] == "undefined") return null;
	
	return oldData[fieldId];
};

//Sort 정보 객체와 함수  -----------------------------------------------------------------------------
/**
 * Dataset의 Record들을 내림차순이나 오름차순으로 정렬하는 Method 입니다.
 * Column ID 자체에 공백문자가 사용 가능하기 때문에 strColList의 Column ID는 공백 없이 입력해야 합니다.
 * 
 *  sort(sortInfo);
 *  sort(sortInfo, nullIsLarger);
 *  
 * @param 	{String|String[]|Object[]}	sortInfo	    칼럼정정보와 소팅 정보가 들어 있는 정보  <br>
 *                                      				- 문자열로 "칼럼명"이나 "칼럼명:소팅정보"를 받을 수 있다 <br>
 *                                      				- 배열로 "칼럼명"이나 "칼럼명:소팅정보"의 배열을 받을 수 있다.   <br>
 *                                      				- 배열로 {colId: "칼럼명", ascending:시트정렬상수}를 받을 수 있다.  <br>
 *                                      				- 상수는 SHEET_SORT_ORDER_ASCENDING:오름차순, SHEET_SORT_ORDER_DESCENDING:내림차순
 * @param   {Boolean}	[nullLarger=false]				NULL값을 값이 있는경우보다 크게 적용할지 여부 True면 NULL값이 값이 있는경우보다 큰것으로 적용[Default Value = False
 * @return  {Boolean}   성공이면 true, 실패하면 false을 Return 
 */
WsDataSet.prototype.sort = function(sortInfos, nullLarger){
	if( typeof sortInfos == undefined ){
		// 오류메시지 
		return false;
	}
	else if( typeof sortInfos == "string" && !Array.isArray(sortInfos) ){
		// 오류메시지 
		return false;
	}
	
	if( typeof nullLarger == undefined )
		nullLarger = false;
	
	var xyZ_$$_SortKeys = [];
	
	if( typeof sortInfos == "string" ){
		var sortInfo = sortInfos;
		xyZ_$$_SortKeys.push(parseSortInfo(sortInfo));
	}
	else if( typeof sortInfos[0] == "string" ){
		for(var i = 0; i < sortInfos.length; i++){
			var sortInfo = sortInfos[i];
			xyZ_$$_SortKeys.push(parseSortInfo(sortInfo));
		}
	}
	else{
		for(var i = 0; i < sortInfos.length; i++){
			var sortInfo = sortInfos[i];
			sortInfo.ascending = (typeof sortInfo.order === "boolean") ? sortInfo.order : sortInfo.order.toUpperCase() === "ASC";
			xyZ_$$_SortKeys.push(sortInfo);
		}
	}
	
	//
	if( typeof this.originData != "undefined"
		&& (this.originData instanceof Array && this.originData.length > 0)
	){
		this.originData.sort(
				function(data1, data2){
					for(var i = 0; i < xyZ_$$_SortKeys.length; i++){
						var sortInfo = xyZ_$$_SortKeys[i];
						var colId = sortInfo.colId;
						
						if( sortInfo.ascending === SHEET_SORT_ORDER_ASCENDING ){
							if( data1[colId] === data2[colId] ){
								// 같은면 다음키 비교
							}
							else if( data1[colId] == null && data2[colId] == null ){
								// 같은면 다음키 비교
							}
							else if( data1[colId] == null ){
								return (nullLarger ? 1 : -1);
							}
							else if( data2[colId] == null ){
								return (nullLarger ? -1 : 1);
							}
							else if( data1[colId] > data2[colId] ){
								return 1;
							}
							else if( data1[colId] < data2[colId] ){
								return -1;
							} 
						}
						else{
							if( data1[colId] === data2[colId] ){
								// 같은면 다음키 비교
							}
							else if( data1[colId] == null && data2[colId] == null ){
								// 같은면 다음키 비교
							}
							else if( data1[colId] == null ){
								return (nullLarger ? -1 : 1);
							}
							else if( data2[colId] == null ){
								return (nullLarger ? 1 : -1);
							}
							else if( data1[colId] > data2[colId] ){
								return -1;
							}
							else if( data1[colId] < data2[colId] ){
								return 1;
							} 
						}
					}
					
					return 0;
				}
		);
	}
	
	//
	this.data.sort(
			function(data1, data2){
				for(var i = 0; i < xyZ_$$_SortKeys.length; i++){
					var sortInfo = xyZ_$$_SortKeys[i];
					var colId = sortInfo.colId;
					
					if( sortInfo.ascending === SHEET_SORT_ORDER_ASCENDING ){
						if( data1[colId] === data2[colId] ){
							// 같은면 다음키 비교
						}
						else if( data1[colId] == null && data2[colId] == null ){
							// 같은면 다음키 비교
						}
						else if( data1[colId] == null ){
							return (nullLarger ? 1 : -1);
						}
						else if( data2[colId] == null ){
							return (nullLarger ? -1 : 1);
						}
						else if( data1[colId] > data2[colId] ){
							return 1;
						}
						else if( data1[colId] < data2[colId] ){
							return -1;
						} 
					}
					else{
						if( data1[colId] === data2[colId] ){
							// 같은면 다음키 비교
						}
						else if( data1[colId] == null && data2[colId] == null ){
							// 같은면 다음키 비교
						}
						else if( data1[colId] == null ){
							return (nullLarger ? -1 : 1);
						}
						else if( data2[colId] == null ){
							return (nullLarger ? 1 : -1);
						}
						else if( data1[colId] > data2[colId] ){
							return -1;
						}
						else if( data1[colId] < data2[colId] ){
							return 1;
						} 
					}
				}
				
				return 0;
			}
	);
	
	while(xyZ_$$_SortKeys.length > 0){
		xyZ_$$_SortKeys.pop();
	}
	
	return true;
};

WsDataSet.prototype.sortOut = function(){
	try{
		if( typeof this.originData != "undefined"
			&& (this.originData instanceof Array && this.originData.length > 0)
		){
			this.originData.sort(function(data1, data2){
//				var rownum1 = data1.__STATE__.rowNum;
//				var rownum2 = data2.__STATE__.rowNum;
				var rownum1 = (typeof data1.__STATE__ != "undefined" ? data1.__STATE__.rowNum : 0);
				var rownum2 = (typeof data2.__STATE__ != "undefined" ? data2.__STATE__.rowNum : 0);
				
				if( rownum1 === rownum2 ){
					// 같은면 다음키 비교
				}
				else if( rownum1 == null && rownum2 == null ){
					// 같은면 다음키 비교
				}
				else if( rownum1 == null ){
					return (nullLarger ? 1 : -1);
				}
				else if( rownum2 == null ){
					return (nullLarger ? -1 : 1);
				}
				else if( rownum1 > rownum2 ){
					return 1;
				}
				else if( rownum1 < rownum2 ){
					return -1;
				}
				
				return 0;
			});
		}
		
		this.data.sort(function(data1, data2){
//			var rownum1 = data1.__STATE__.rowNum;
//			var rownum2 = data2.__STATE__.rowNum;
			var rownum1 = (typeof data1.__STATE__ != "undefined" ? data1.__STATE__.rowNum : 0);
			var rownum2 = (typeof data2.__STATE__ != "undefined" ? data2.__STATE__.rowNum : 0);
			
			if( rownum1 === rownum2 ){
				// 같은면 다음키 비교
			}
			else if( rownum1 == null && rownum2 == null ){
				// 같은면 다음키 비교
			}
			else if( rownum1 == null ){
				return (nullLarger ? 1 : -1);
			}
			else if( rownum2 == null ){
				return (nullLarger ? -1 : 1);
			}
			else if( rownum1 > rownum2 ){
				return 1;
			}
			else if( rownum1 < rownum2 ){
				return -1;
			}
			
			return 0;
		});
	}
	catch(err){
		return false;
	}
	
	return true;
};

/** 
 * @description 
 *     "col1", "col2:D", "col3:ASC" 처럼된 문자열을 아래와 같이 리턴하는 함수<br>
 *     {colId: "col1", ascending: SHEET_SORT_ORDER_ASCENDING}, <br>
 *     {colId: "col2", ascending: SHEET_SORT_ORDER_DESCENDING}, <br>
 *     {colId: "col3", ascending: SHEET_SORT_ORDER_ASCENDING}.  <br>
 *     
 * @param 	{String}	strSortInfo	    칼럼정정보와 소팅 정보가 들어 있는 문자열 값 <br>
 *                                      - "칼럼명:소팅정보"의 형식이며, 오름차순 소팅인 경우 ":ASC" 는 생략가능하다.<br>
 *                                      - 소팅정보는 오름차순 "ASC", 내림차순 "DESC"이며, "A" 또는 "D"로 사용가능하고 대소문자를 구분하지 않는다. 
 *                                      - 단, 칼럼명은 대소문자를 엄밀하게 구분하여야 한다 
 * @return 	{Object}					칼럼 소팅정보가 들어있는 JSON 객체
 * 		
 * @example
 * parseSortInfo("col1");			// {colId: "col1", ascending: SHEET_SORT_ORDER_ASCENDING} 리턴  
 * parseSortInfo("col2:D");			// {colId: "col2", ascending: SHEET_SORT_ORDER_DESCENDING} 리턴  
 * parseSortInfo("col3:ASC");		// {colId: "col3", ascending: SHEET_SORT_ORDER_ASCENDING} 리턴  
 * 
 */
function parseSortInfo(strSortInfo){
	var str = null;
	var order = null;
	var colId = strSortInfo;
	var ascending = SHEET_SORT_ORDER_ASCENDING;
	
	if( strSortInfo.indexOf(":") >= 0 ){
		str = strSortInfo.split(":");
		colId = str[0];
		order = str[1];
		
		if( typeof order == "string" ){
			order = order.toUpperCase();
			ascending = (order === "A" || order === "ASC");
		}
		
		order = null; str = null;
	}
	
	return {"colId" : colId, "ascending" : ascending};

};

var inProcess = false;
var recordsets = [];
var batchWorks = [];

var PARAMTYPE_INPUT  = 1;
var PARAMTYPE_OUTPUT = 2;

/**
 * @description	미결
 * @param		{string}	pKey
 * @return  	{String}
 * @example		미결
 */
function getRecordsetByKey(pKey){
    var wFound = false;
    for (var wKey in recordsets){
    	if (this.recordsets[wKey] instanceof Function) continue;
        if (wKey == pKey){
            wFound = true;
            break;
        }
    }
    var wRecordset = null;
    
    if (wFound){
        wRecordset = recordsets[pKey];
    } else {
        wRecordset = new Recordset(pKey);
    }
    return wRecordset;
};

/**
 * @description	미결
 * @param		{Number}	sqlnum
 * @return  	{String}
 * @example		미결
 */
function getRecordsetBySqlNum(sqlnum){
    var wRecordset = null;
    for (var wKey in recordsets){
    	if (this.recordsets[wKey] instanceof Function) continue;
        if (recordsets[wKey].sqlnum == sqlnum){
        	wRecordset = recordsets[wKey];
            break;
        }
    }
    return wRecordset;
};
/**
 * @class	DataAction
 * @constructor
 */

function Recordset(id) {
	this.id = id;

	this.sqlnum = 0;
	this.sqlBuff = "";
	this.connectionID = "";
	this.encoded = "false";
	this.permitNullParam = false;
	this.parameters = [];

	this.commandType = "Recordset";
	this.clearData = true;
	this.updateRow = false;
	this.dniMode = true;
	this.useReset = true;
	this.needSync = false;
	this.errInfo = "";
	this.rowCount = 0;
	this.currentRow = -1;
	this.BOF = true;
	this.EOF = true;

	this.totalRowCount = 0;
	this.pageSize = 0;
	this.pageNum = 0;
	this.smode = "N";
	this.smore = "N";

	this.fields = [];
	this.recordNum = 0;
	this.recordNums = [];
	
	this.mappingRule = null;
	this._oldMappingRule = null;
	this._sheetDatas = null;
	this._jsonData = null;
	
	this._mapData = null;
	this._targetResetObjects = null;
	
	this.dataSet = new WsDataSet();

	this.casheMode = false;
	this.casheKey = "";

	recordsets[id] = this;

	this.AUIrecordList = null; // AUI 일때

	this.hasReceiveEvent = (typeof self[this.id + "_OnReceive"] == "function");
	if( this.hasReceiveEvent ){
		this.fncReceiveEvent = new Function("return function(){" + this.id + "_OnReceive();}")();
	}

	return this;
};

/**
 * @description	미결
 * @param	{string}	fieldName
 * @param	{string}	dataValue
 * @return  {void}
 * @example	미결
 */
Recordset.prototype.setParameter = function(fieldName, dataValue){
    // functionname : [Recordset.setParameter]
	
    this.parameters[fieldName] = new Parameter(fieldName, dataValue);
    
    return;
};

/**
 * @description	미결
 * @param	{string}	fieldInfo
 * @return  {void}
 * @example	미결
 */
Recordset.prototype.setFields = function(fieldInfo){
    // functionname : [Recordset.setFields]
	
	var wFieldNum = 0;
	var wReturn = true;
	var field = null;
	
	if( this.commandType == "Recordset" ){
		if (fieldInfo.trim().length == 0) return false;
		
		var fields = null;
		var fieldName = null;
		var fieldType = null;
		
		fields = fieldInfo.split(";");
		
		for(wFieldNum = 0; wFieldNum < fields.length; wFieldNum++){
			if( fields[wFieldNum].length == 0 ){
				wReturn = false;
				break;
			}
			
			field = fields[wFieldNum].split(":");
			fieldName = field[0];
			fieldType = (field[1] == "") ? 0 : parseInt(field[1]);
			
			this.fields[wFieldNum] = new Field(this, fieldName, fieldType);
			
			fieldType = null; fieldName = null; field = null;
		}
		
		fields = null;
	}
	else if( this.commandType == "Dataset" ){
		var wResult = null;
		
		for(wFieldNum = 0; wFieldNum < fieldInfo.length; wFieldNum++){
			field = fieldInfo[wFieldNum];
			
			if( typeof field != "object" || !("field" in field) || !("dataType" in field) ){
				wReturn = false;
				break;
			}
			
			wResult = this.dataSet.addField( fieldInfo );
			
			if( wResult == null || !wResult.result ){
				wReturn = false;
				break;
			}
			
			wResult = null; field = null;
		}
		
		wResult = null; field = null;
	}
    
    return wReturn;
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
Recordset.prototype.open = function() {
	// functionname : [Recordset.open]

	// 데이터를 리턴받는 경우 레코드셋을 미리 만들어 두고 이 루틴을 호출할 것
	var recordsetId = this.id;
	var ndx = 0;
	
	this.casheKey = "";
	
	for(var wKey in this.parameters){
		if( this.parameters[wKey] instanceof Function ) continue;
		this.casheKey += (ndx++ > 0 ? ":" : "");
		this.casheKey += this.parameters[wKey].value();
	}
	
//	if( this.id.length > 9 && this.id.substring(0, 9) == "fillList_" ){
//		if( dataCashes[this.sqlnum + ":" + this.casheKey] != undefined ){
//			this.setCashedData();
//			return;
//		}
//	}
	
	//가져오기시 조회한 데이터의 레코드 업데이트 구분을 설정
	if( this._targetResetObjects != null && typeof this._targetResetObjects != "undefined" ){
		var targetCount = this._targetResetObjects.length;
		if( targetCount > 0 ){
			var targetObject = null;
			var oldDniMode = null;
			
			for(ndx = 0; ndx < targetCount; ndx++, targetObject = null){
				targetObject = getObjectById(this._targetResetObjects[0]);
				
				if( targetObject == null ){
					continue;
				}
				if( oldDniMode != null && targetObject.dniMode != oldDniMode ){
					targetObject = null;
					return;
				}
				
				oldDniMode = this.dniMode = targetObject.dniMode;
			}
		}
	}
	
	// 한글 없이 영숫자이면 "GET"으로 호출하기 위하여 체크한다
	var needPost = false;
	for(var wKey in this.parameters){
		if( this.parameters[wKey] instanceof Function ) continue;
		needPost = needPost || hasHangul("" + this.parameters[wKey].value());
	}
	
	// 파라메터 정보에는 콜론이 하나 더 붙는다.
	var wParamInfo = this.casheKey + ":";
	var wQueryString = "lang=" + USER_LANGUAGE + "&cogu=" + USER_COGU
			+ "&personalId=" + USER_PERSONALID + "&sqlnum=" + this.sqlnum
			+ "&pageNum=" + this.pageNum + "&pageSize=" + this.pageSize
			+ "&permitNull=" + this.permitNullParam + "&smode=" + this.smode
			+ "&dniMode=" + this.dniMode + "&formid=" + USER_FORMID
			+ "&paramInfo=" + encodeURIComponent(wParamInfo) 
			+ "&tm=" + (new Date()).valueOf() + (Math.floor(Math.random() * 1000) + 1);
	var queryURL = "/query.do";
	var queryFlag = "openRecordset";
	
	if( this.commandType == "Dataset" ){
		queryURL = "/query2.do";
		queryFlag = "openDataset";
	}
	
	if( TEST_MODE == undefined || !TEST_MODE ){
		if( jobControler.loadType == 1 || this.needSync ){
			ajaxCallSync((needPost ? "POST" : "GET"), getContextPath() + queryURL, wQueryString, this, queryFlag);
		}
		else{
			ajaxCall((needPost ? "POST" : "GET"), getContextPath() + queryURL, wQueryString, this, queryFlag);
		}
	}
	else{
		if( jobControler.loadType == 1 || this.needSync ){
			ajaxCallSync((needPost ? "POST" : "GET"), getContextPath() + "/test/" + queryURL, wQueryString, this, queryFlag);
		}
		else{
			ajaxCall((needPost ? "POST" : "GET"), getContextPath() + "/test/" + queryURL, wQueryString, this, queryFlag);
		}
	}
	
//	if( TEST_MODE == undefined || !TEST_MODE ){
//		if( jobControler.loadType == 1 || this.needSync ){
//			ajaxCallSync((needPost ? "POST" : "GET"), getContextPath() + "/query.do", wQueryString, this, "openRecordset");
//		}
//		else{
//			ajaxCall((needPost ? "POST" : "GET"), getContextPath() + "/query.do", wQueryString, this, "openRecordset");
//		}
//	}
//	else{
//		if( jobControler.loadType == 1 || this.needSync ){
//			ajaxCallSync((needPost ? "POST" : "GET"), getContextPath() + "/test/query.do", wQueryString, this, "openRecordset");
//		}
//		else{
//			ajaxCall((needPost ? "POST" : "GET"), getContextPath() + "/test/query.do", wQueryString, this, "openRecordset");
//		}
//	}
	
	return;
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
Recordset.prototype.setCashedData = function(){
	// functionname : [Recordset.setCashedData]

	var dataCashe = dataCashes[this.sqlnum + ":" + this.casheKey];

	// 데이터 담기
	this.rowCount = dataCashe.rowCount;
	this.totalRowCount = dataCashe.totalRowCount;
	this.recordNums = dataCashe.recordNums.slice(0);

	if(this.commandType == "Recordset"){
		this.fields = [];
		for(var wFieldNum = 0; wFieldNum < dataCashe.fields.length; wFieldNum++) {
			this.fields[wFieldNum] = new Field(this, dataCashe.fields[wFieldNum].fieldName, dataCashe.fields[wFieldNum].datatype);
			this.fields[wFieldNum].datas = dataCashe.fields[wFieldNum].datas.slice(0);
		}		
	}
	else if( this.commandType == "Dataset" ){
		this.dataSet.setDataSet(dataCashe.dataSet);
	}

	// 레코드 변수 초기화
	this.currentRow = 0;
	this.BOF = true;
	this.EOF = (this.rowCount == 0);
	this.recordNum = this.recordNums[0];

	// 이벤트 일으키기
	if (this.hasReceiveEvent) {
		this.fncReceiveEvent();
	}
	
	// dni모드가 false인 객체의 레코드 상태를 수정
	if( this.useReset && this._targetResetObjects != null ){
		this.reset();
	}
	
	return;
};

/**
 * @description	미결
 * @param	{string}	jsonActionObject
 * @param	{string}	message
 * @return  {void}
 * @example	미결
 */
Recordset.prototype.parseData = function(jsonActionObject, message){
	// functionname : [Recordset.parseData]

	// 오류 메시지 먼저 파악
	if( jsonActionObject == null ){
		this.errInfo = message;
		callEvent(this.id + "_OnReceiveErr", message);
		return;
	}

	// 오류정보 분석
	// 서버에서 메시지가 넘어오면 무조건오류이다
	if( typeof jsonActionObject.errorMsg != "undefined" && jsonActionObject.errorMsg != null && jsonActionObject.errorMsg.length > 0 ){
		this.errInfo = jsonActionObject.errorMsg;
		callEvent(this.id + "_OnReceiveErr", jsonActionObject.errorMsg);
		return;
	}

	if( typeof jsonActionObject.smore != "undefined" ){
		this.smore = jsonActionObject.smore;
	}
	
	if( this.commandType == "Recordset" ){
		// 서버데이터 분석
		this.rowCount = jsonActionObject.recordList.length;

		var fieldList = jsonActionObject.fieldList;
		var recordList = jsonActionObject.recordList;
		var fields = null;
		var wFieldNum = 0;
		var wRow = 0;
		
		for(wFieldNum = 0; wFieldNum < fieldList.length; wFieldNum++){
			this.fields[wFieldNum] = new Field(this, fieldList[wFieldNum].fieldName, fieldList[wFieldNum].datatype);
		}

		// 결과값 분석, 두번쨰 페이지 부터는 안 넘어온다. 처음 조회내용 유지
		if( this.smode == "N" && jsonActionObject.rowCount > 0 ){
			this.totalRowCount = jsonActionObject.rowCount;
		}
		else if( this.smode == "Y" ){
			this.totalRowCount = 9999999;
		}
		
		for(wRow = 0; wRow < recordList.length; wRow++){
			this.recordNums[wRow] = recordList[wRow].rowNum;
			
			fields = recordList[wRow].fields;
			
			for(var wCol = 0; wCol < fields.length; wCol++){
				if( fields[wCol] == null ){
					if( this.fields[wCol].dataType == SQL_TYPE_NUMERIC
						|| this.fields[wCol].dataType == SQL_TYPE_DECIMAL
						|| this.fields[wCol].dataType == SQL_TYPE_INTEGER
						|| this.fields[wCol].dataType == SQL_TYPE_SMALLINT
						|| this.fields[wCol].dataType == SQL_TYPE_FLOAT
						|| this.fields[wCol].dataType == SQL_TYPE_REAL
						|| this.fields[wCol].dataType == SQL_TYPE_DOUBLE )
					{
						this.fields[wCol].datas[wRow] = 0;
					}
					else{
						this.fields[wCol].datas[wRow] = "";
					}
				}
				else{
					this.fields[wCol].datas[wRow] = fields[wCol];
				}
			}
			
			fields = null;
		}
		
		this.recordNum = (typeof this.recordNums[0] != "undefined") ? this.recordNums[0] : 0;

		// 데이터 클리어
		for(wRow = 0; wRow < recordList.length; wRow++){
			recordList[wRow].fields.clear();
		}
		recordList.clear();	recordList = null;
		fieldList.clear();	fieldList = null;
	}
	else if( this.commandType == "Dataset" ){
		if( this.dataSet == null ){
			this.dataSet = new WsDataSet();
		}
		
		var wResult = this.dataSet.setData( jsonActionObject );
		if( wResult.result == null || !wResult.result ){
			wResult = null;
			return;
		}
		
		this.currentRow = 0;
		this.rowCount= this.dataSet.getCount();
		this.recordNum = (this.dataSet.getCount() > 0 && typeof this.dataSet.data[0].__STATE__ != "undefined") ? this.dataSet.data[0].__STATE__.rowNum : 0;
		
		// 결과값 분석, 두번쨰 페이지 부터는 안 넘어온다. 처음 조회내용 유지
		if( this.smode == "N" && jsonActionObject.rowCount > 0 )
			this.totalRowCount = jsonActionObject.rowCount;
		else if( this.smode == "N" && this.pageSize <= 0 && jsonActionObject.rowCount === 0 )
			this.totalRowCount = 0;
		else if( this.smode == "Y" )
			this.totalRowCount = 9999999;
		
		//field ID가 다른 매핑 정보가 있다면 매핑 데이터를 생성함
		this._remakeMappingData();
		
		wResult = null;
	}
	
	// 레코드 변수 초기화
	this.currentRow = 0;
	this.BOF = true;
	this.EOF = (this.rowCount == 0);
	
	// 객체 상태 reset 여부
	var doReset = (this.BOF != this.EOF);

	// 리스트 채우기 쿼리인 경우 페이지 격납
	if( this.id.length > 9 && this.id.substring(0, 9) == "fillList_" ){
		dataCashes[this.sqlnum + ":" + this.casheKey] = new DataCashe(this);
	}
	
	// 피벗 채우기 호출 
	if (typeof pivotAgent != "undefined" && pivotAgent.IsInPivotPool(this.id)){
		pivotAgent.RunPivot(this.id, this.dataSet);
	}

	// 이벤트 일으키기
	if (this.hasReceiveEvent) {
		this.fncReceiveEvent();
	}
	
	// dni모드가 false인 객체의 레코드 상태를 수정
	if( this.useReset && this._targetResetObjects != null ){
		this.reset();
	}

	//hideAjaxBox();

	return;
};

// 문자는 엑셀에서 따옴표 붙여 넘겨줄것
/**
 * @description	미결
 * @param	{string}	jsonArrayObject
 * @param	{string}	message
 * @return  {void}
 * @example	미결
 */
Recordset.prototype.parseDataExcel = function(jsonArrayObject, message) {
	// functionname : [Recordset.parseDataExcel]

	// 오류 메시지 먼저 파악
	if( jsonArrayObject == null ){
		this.errInfo = message;
		callEvent(this.id + "_OnReceiveErr", message);
		return;
	}

	// 서버데이터 분석
	this.rowCount = jsonArrayObject.length;
	if( this.rowCount == 0 ){
		alert(getText("message_dataAction_001", "엑셀로 변환된 결과값이 없습니다."));
		return;
	}
	var colCount = jsonArrayObject[0].length;
	if( colCount == 0 ){
		alert(getText("message_dataAction_001", "엑셀로 변환된 결과값이 없습니다."));
		return;
	}

	var arrColumnDatas = jsonArrayObject[0];
	for( var wFieldNum = 0; wFieldNum < colCount; wFieldNum++ ){
		var dataType = (typeof (arrColumnDatas[wFieldNum]) == "number" ? SQL_TYPE_DOUBLE : SQL_TYPE_VARCHAR);
		this.fields[wFieldNum] = new Field(this, "column" + wFieldNum, dataType);
	}

	this.totalRowCount = jsonArrayObject.rowCount;

	for(var wRow = 0; wRow < this.rowCount; wRow++){
		this.recordNums[wRow] = wRow;
		arrColumnDatas = jsonArrayObject[wRow];

		var fields = recordList[wRow].fields;
		for(var wCol = 0; wCol < colCount; wCol++){
			this.fields[wCol].datas[wRow] = arrColumnDatas[wCol];
		}
	}

	// 데이터 클리어
	for(var wRow = 0; wRow < this.rowCount; wRow++){
		jsonArrayObject[wRow].clear();
	}
	jsonArrayObject.clear();
	jsonArrayObject = null;

	// 레코드 변수 초기화
	this.currentRow = 0;
	this.BOF = true;
	this.EOF = (this.rowCount == 0);
	this.recordNum = this.recordNums[0];
	
//	//객체 상태 reset 여부
//	var doReset = (this.BOF != this.EOF && !this.updateRow);

	// 이벤트 일으키기
	if( this.hasReceiveEvent ){
		this.fncReceiveEvent();
	}
	
	// dni모드가 false인 객체의 레코드 상태를 수정
	if( this.useReset && this._targetResetObjects != null ){
		this.reset();
	}

	return;
};

/**
 * @description	미결
 * @param	{string}	fieldID
 * @return  {string}
 * @example	미결
 */
Recordset.prototype.field = function(fieldID) {
	// functionname : [Recordset.field]

	if( this.commandType == "Recordset" ){
		var wField = null;

		for (var wFieldNum = 0; wFieldNum < this.fields.length; wFieldNum++) {
			if (this.fields[wFieldNum].fieldName == fieldID) {
				wField = this.fields[wFieldNum];
			}
		}

		return wField;
	}
	else if( this.commandType == "Dataset" ){
		var value = this.dataSet.data[this.currentRow][fieldID];
		
		return {
			value : function(){
				return value;
			}
		};
	}

	return null;
};

// BOF가 아니라 첫번째 레코드를 이동한다는 점에 주의
/**
 * @description	미결
 * @return  {boolean}
 * @example	미결
 */
Recordset.prototype.moveFirst = function() {
	// functionname : [Recordset.moveFirst]

	if( this.commandType == "Recordset" ){
		if( this.fields[0].datas.length == 0 ){
			this.currentRow = 0;
			this.recordNum = 0;
			
			return false;
		}
		
		this.currentRow = 0;
		this.recordNum = this.recordNums[this.currentRow];
	}
	else if( this.commandType == "Dataset" ){
		if( this.rowCount == 0 ){
			this.currentRow = 0;
			this.recordNum = 0;
			
			return false;
		}
		
		this.currentRow = 0;
		this.recordNum = this.dataSet.getState(this.currentRow, "rowNum");
		this.recordNum = typeof this.recordNum != "undefined" ? this.recordNum : 0;
	}
	
	return true;
};

/**
 * @description	미결
 * @return  {boolean}
 * @example	미결
 */
Recordset.prototype.moveNext = function() {
	// functionname : [Recordset.moveNext]

	this.currentRow++;

	if( this.commandType == "Recordset" ){
		if( this.fields[0].datas.length <= this.currentRow ){
			this.EOF = true;
			this.currentRow = 0;
			this.recordNum = this.recordNums[0];
			
			return false;
		}
		
		this.recordNum = this.recordNums[this.currentRow];
	}
	else if( this.commandType == "Dataset" ){
		if( this.rowCount <= this.currentRow ){
			this.EOF = true;
			this.currentRow = 0;
			this.recordNum = 0;
			
			return false;
		}
		
		this.recordNum = this.dataSet.getState(this.currentRow, "rowNum");
		this.recordNum = typeof this.recordNum != "undefined" ? this.recordNum : 0;
	}

	return true;
};

/**
 * @description	미결
 * @param	{number}	pPageNum
 * @return  {boolean}
 * @example	미결
 */
Recordset.prototype.setAbsolutePage = function(pPageNum) {
	// functionname : [Recordset.setAbsolutePage]

	this.currentRow = (pPageNum - 1) * this.pageSize;
	
	if( this.commandType == "Recordset" ){
		this.recordNum = this.recordNums[this.currentRow];
	}
	else{
		this.recordNum = this.dataSet.getState(this.currentRow, "rowNum");
		this.recordNum = typeof this.recordNum != "undefined" ? this.recordNum : 0;
	}
	
	return true;
};

/**
 * @description	미결
 * @return  {boolean}
 * @example	미결
 */
Recordset.prototype.close = function(){
	// functionname : [Recordset.close]
	var controlName = null;
	var i = 0;
	
	for(i = this.parameters.length - 1; i >= 0; i--){
	    this.parameters[i].destroy();
	    this.parameters.pop();
	}
	this.parameters = null;
	this.parameters = [];
	
	for(i = this.fields.length - 1; i >= 0; i--){
	    this.fields[i].destroy();
	    this.fields.pop();
	}
	this.fields = null;
	this.fields = [];
	
	for(i = this.recordNums.length - 1; i >= 0; i--){
	    this.recordNums.pop();
	}
	this.recordNums = null;
	this.recordNums = [];
	
	if( this.dataSet != null && typeof this.dataSet != "undefined" ){
		this.dataSet.clear(); 
	}
	this.dataSet = null;
	
	if( this._mapData != null ){
		for(controlName in this._mapData){
			if( typeof this._mapData[controlName] != "undefined" ){
				if( this._mapData[controlName] instanceof WsDataSet )
					this._mapData[controlName].clear();
				this._mapData[controlName] = null;
			}
			
			controlName = null;
		}
	}
	this._mapData = null;
	
//	if( this._targetResetObjects != null ){
//		this._targetResetObjects.clear();
//	}
//	this._targetResetObjects = null;
	this.dniMode = true;
//	this.useReset = true;
	
	this.errInfo = "";
	this.CallString = "";
	this.recordNum = 0;
	this.currentRow = -1;
	this.BOF = true;
	this.EOF = true;
	this.rowCount= 0;
//	this.totalRowCount = 0;
	this.smode = "N";
	this.smore = "N";
	
	this.errInfo = "";
	this.sqlBuff = "";
	this.connectionID = "";
	this.encoded = "false";
	this.pageSize = 0;
	this.pageNum = 0;
	
	if(this.AUIrecordList){
		var AUIrecordListLen = this.AUIrecordList.length - 1;
		for (var i = AUIrecordListLen; i >= 0; i--) {
			this.AUIrecordList[i] = null;
		}
	}
	this.AUIrecordList = null; // AUI 일때
	
	return true;
};

Recordset.prototype.setMapRule = function(mapRules){
	var controlName = null;
	var cellIndex = null;
	var formula = null;
	var colId = null;
	var mapObj = null;
	var i = 0;
	
	if( this._oldMapRule != null && JSON.stringify(this._oldMapRule) == JSON.stringify(mapRules) )
		return;
	
	this._oldMapRule = mapRules;
	
	if( this.mapRule == null || typeof this.mapRule == "undefined" )
		this.mapRule = {};
	
	for(i = 0; i < mapRules.length; i++){
		controlName = mapRules[i].control;
		cellIndex = mapRules[i].cell;
		formula = mapRules[i].formula;
		
		if( typeof this.mapRule[controlName] == "undefined" )
			this.mapRule[controlName] = {};
		
		if( typeof DataSet != "undefined" && typeof dataSets[controlName] != "undefined" ){
			this.mapRule[controlName].clear = mapRules[i].clear;
		}
		else{
			if( typeof cellIndex == "number" )
				colId = controls[controlName].getColId(cellIndex);
			else
				colId = cellIndex;
			
			mapObj = this.mapRule[controlName];
			mapObj[colId] = ((typeof formula == "undefined" || formula == null) ? null : new Function("recordset", formula));
			mapObj = null;
			colId = null;
		}
		
		formula = null; cellIndex = null; controlName = null;
	}
	
	return;
};

Recordset.prototype.setTargetResetObjects = function(targetResetObjects){
	if( typeof targetResetObjects == "string" ){
		this._targetResetObjects = [];
		
		if( targetResetObjects.length > 0 ){
			var targetObjectList = targetResetObjects.split(",");
			var targetObject = null;
			var targetObjectCount = targetObjectList.length;
			var i = 0;
			
			for(i = 0; i < targetObjectCount; i++, targetObject = null){
				targetObject = targetObjectList[i].replace(/(^\s*)|(\s*$)/g, "");
				
				if( targetObject.length <= 0 ){
					continue;
				}
				
				this._targetResetObjects.push(targetObject);
			}
			
			targetObjectList = null;
		}
	}
	else if( targetResetObjects == null ){
		this._targetResetObjects = null;
	}
};

Recordset.prototype._remakeMappingData = function(){
	//매핑 룰이 없다면 매핑 데이터를 생성하지 않음
	if( this.mapRule == null )
		return;
	
	if( typeof this._mapData == "undefined" || this._mapData == null )
		this._mapData = {};
	
	var controlName = null;
	var control = null;
	var fieldList = null;
	var recordList = null;
	var mapRuleObj = null;
	var record = null; oldRecord = null; var recordState = null;
	var data = null; oldData = null;
	var key = null;
	var recordCount = 0;
	var i = 0;
	
	for(controlName in this.mapRule){
		if( typeof DataSet != "undefined" && typeof dataSets[controlName] != "undefined" ){
			//데이터셋용 데이터는 별도로 생성하지 않음
			continue;
		}
		else{
			control = controls[controlName];
			
			if( this._mapData != null && typeof this._mapData[controlName] == "undefined" )
				this._mapData[controlName] = new WsDataSet();
			else
				this._mapData[controlName].clear();
			
			if( typeof control == "undefined" || typeof control.dataSet == "undefined" )
				continue;
			
			//매핑 정보
			mapRuleObj = this.mapRule[controlName];
			
			//필드정보 리스트 초기화
			fieldList = [];
			//필드정보 추가
			for(key in mapRuleObj){
				fieldList.push((key in this.dataSet.fieldInfos) ? this.dataSet.fieldInfos[key] : control.dataSet.fieldInfos[key]);
				key = null;
			}
			
			//레코드 리스트 초기화
			recordList = [];
			//레코드 리스트 생성
			for(i = 0, recordCount = this.rowCount; i < recordCount; i++, record = null, oldRecord = null, data = null, oldData = null){
				record = {};	//새 레코드 생성
				oldRecord = {};	//oldData 레코드 생성
				data = this.dataSet.data[i];
				oldData = data.__STATE__.oldData;
				
				//레코드에 데이터 추가
				for(key in mapRuleObj){
					record[key] = (mapRuleObj[key] == null) ? data[key] : mapRuleObj[key](this);
					oldRecord[key] = this.dniMode ? null : record[key];
					key = null;
				}
				if( typeof data.__STATE__ != "undefined" ){
					record["__STATE__"] = {};
					record.__STATE__.rowNum = data.__STATE__.rowNum;
					record.__STATE__.updateGu = data.__STATE__.updateGu;
					record.__STATE__.oldData = oldRecord;
				}
				
				//새 레코드 리스트에 추가
				recordList.push(record);
				
				this.moveNext();
			}
			
			//시트 데이터 추가
			this._mapData[controlName].setDataArray(recordList, fieldList);
			
			//레코드셋 현재행 초기화
			this.currentRow = 0;
			
			//메모리 초기화
			recordList.clear(); recordList = null;
			fieldList.clear(); fieldList = null;
			mapRuleObj = null; control = null;
		}
		
		//메모리 초기화
		controlName = null;
	}
};

Recordset.prototype.recalcMapRule = function(){
	this._remakeMappingData();
};

Recordset.prototype.getMappingData = function(sheetName){
	if( this._mapData == null ){
		if( this.mapRule != null )
			this._remakeMappingData();
		else
			return this.dataSet;
	}
	
	return this._mapData[sheetName];
};

Recordset.prototype.getSheetData = function(sheetName){
	return this.getMappingData(sheetName);
};

Recordset.prototype.setDataToDataset = function(dataSetName){
	var datasetMi = dataSets[dataSetName];
	var datasetUpdateCtrl = null;
	
	if( typeof DataSet != "undefined" && typeof datasetMi != "undefined"){
		datasetUpdateCtrl = datasetMi.instantUpdateControl;
		
		//데이터셋 컨트롤 업데이트 구분 막음
		datasetMi.setInstantUpdateControl(false);
		
		//클리어 구분에 따라 데이터 추가
		if( this.mapRule[dataSetName].clear )
			datasetMi.loadJsonQry( this.dataSet.data );	//load
		else
			datasetMi.appendJsonQry( this.dataSet.data );	//append
		
		//데이터셋 컨트롤 업데이트 구분 복구
		datasetMi.setInstantUpdateControl(datasetUpdateCtrl);
		
		//메모리 초기화
		datasetUpdateCtrl = null;
	}
};

Recordset.prototype.reset = function(){
	var objectId = null;
	var object = null;
	
	for(objectId in objects){
		object = objects[objectId];
		
		//예외처리
		if( typeof object == "function" )
			continue;
		//현재 가져오기 작업으로 영향이 미치는 객체만 리셋해야 하므로 이 가져오기에 의해 영향이 없는 객체는 건너뛴다
		if( this._targetResetObjects != null && this._targetResetObjects.indexOf(object.id) < 0 )
			continue;
		
		object.resetState();
		
		//메모리 해제
		object = null;
		objectId = null;
	}
};

/**
 * @constructor
 */
function Parameter(fieldName, dataValue) {
	this.fieldName = fieldName;
	this.datas = [dataValue];
	this.returnIndex = -1;
};

// 인수가 하나면 0번 줄에 들어가는 값이고, 둘이면, 줄번호와 값이다
/**
 * @description	미결
 * @return  {undefined}
 * @example	미결
 */
Parameter.prototype.setValue = function() {
	// functionname : [Parameter.setValue]

	var length = arguments.length;
	var wRow = 0;
	var wValue = null;

	if( length == 1 ){
		wValue = arguments[0];
	}
	else if( length == 2 ){
		wRow = arguments[0];
		wValue = arguments[1];
	}
	
	this.datas[wRow] = wValue;
};

// 인수가 없으면 0번 줄에 있으면 그줄에 들어간다
/**
 * @description	미결
 * @param	{number}	pRow
 * @return  {number}
 * @example	미결
 */
Parameter.prototype.value = function(pRow) {
	// functionname : [Parameter.value]

	var wRow = pRow || 0;

	return this.datas[wRow];
};

/**
 * @description	미결
 * @return  {undefined}
 * @example	미결
 */
Parameter.prototype.clear = function() {
	// functionname : [Parameter.clear]

	this.datas.clear();
};

/**
 * @description	미결
 * @param		{String}	recordset
 * @param		{Object}	fieldName
 * @param		{String}	dataType
 * @return  	{Undefined}
 * @example		미결
 */
function Field(recordset, fieldName, dataType) {
	this.recordset = recordset;
	this.fieldName = fieldName.toLowerCase();
	this.dataType = dataType;

	this.datas = [];
};

/**
 * @description	미결
 * @return  {string}
 * @example	미결
 */
Field.prototype.value = function() {
	// functionname : [Field.value]

	var wValue = null;
	
	if( this.dataType == SQL_TYPE_INTEGER || this.dataType == SQL_TYPE_SMALLINT ){
		if( this.datas[this.recordset.currentRow] == undefined ){
			wValue = 0;
		}
		else{
			wValue = parseInt(1 * this.datas[this.recordset.currentRow]);
		}
	}
 	else if( this.dataType == SQL_TYPE_NUMERIC
 			|| this.dataType == SQL_TYPE_DECIMAL
			|| this.dataType == SQL_TYPE_FLOAT
			|| this.dataType == SQL_TYPE_REAL
			|| this.dataType == SQL_TYPE_DOUBLE )
 	{
		if( this.datas[this.recordset.currentRow] == undefined ){
			wValue = 0.0;
		}
		else{
			wValue = parseFloat(1.0 * this.datas[this.recordset.currentRow]);
		}
	}
 	else{
 		if( this.datas[this.recordset.currentRow] == undefined ){
			wValue = "";
		}
 		else{
			wValue = this.datas[this.recordset.currentRow];
		}
	}

	return wValue;
};

/**
 * @description	미결
 * @return  {string}
 * @example	미결
 */
Field.prototype.setValue = function(value) {
	// functionname : [Field.setValue]

	return (this.datas[this.recordset.currentRow] = value);
};
/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
Field.prototype.destroy = function() {
	// functionname : [Field.destroy]

	this.recordset = null;

	this.datas.clear();
	this.datas = null;
	
	return;
};

/*******************************************************************************
 * ObjectManager Batch정보를 포함하여 객체를 삭제하거나 저장하는 역할을 한다
 ******************************************************************************/
/**
 * @description	미결
 * @return  	{Undefined}
 * @example		미결
 */
function ObjectManager() {
	this.deleteBatchId = "";
	this.deleteBatchParam = "";
	this.insertBatchId = "";
	this.insertBatchParam = "";
	this.callerCommandName = "";
	this.fillkeyFieldValue = "";

	this.batchWorkDelete = null;
	this.batchWorkInsert = null;
	this.dataloaded = false;		// fillObjectToScreen으로 데이터가 채워진 경우 true
	this.busy = false;
};

/**
 * @description	미결
 * @param	{string}	batchWork
 * @return  {undefined}
 * @example	미결
 */
ObjectManager.prototype.setBatchWorkDelete = function(batchWork) {
	// functionname : [ObjectManager.setBatchWorkDelete]

	this.batchWorkDelete = batchWork;
	this.deleteBatchId = batchWork.id;

	batchWork.inintialize();
};

/**
 * @description	미결
 * @param	{string}	batchWork
 * @return  {undefined}
 * @example	미결
 */
ObjectManager.prototype.setBatchWorkInsert = function(batchWork) {
	// functionname : [ObjectManager.setBatchWorkInsert]

	this.batchWorkInsert = batchWork;
	this.insertBatchId = batchWork.id;

	batchWork.inintialize();
};

// 서버데이터 공통 파싱 모듕
/**
 * @description	미결
 * @param	{string}	jsonActionObject
 * @param	{string}	message
 * @param	{string}	pFlag
 * @return  {void}
 * @example	미결
 */
ObjectManager.prototype.parseData = function(jsonActionObject, message, pFlag){
	// functionname : [ObjectManager.parseData]
    
	this.busy = false;
	
	var checkFunction = false;
	var key = null;
	
	if( pFlag == "loadData" ){
		// 오류 메시지 먼저 파악 
		if( jsonActionObject == null ){
			callEvent("LoadObjects_OnFail", message);
			return;
		}
		
		// 오류정보 분석 
		// 서버에서 메시지가 넘어오면 무조건오류가 아니다, 성공메시지도 있다
		if( jsonActionObject.resultCode != "SUCCESS" ){
			if( jsonActionObject.message != undefined && jsonActionObject.message != null && jsonActionObject.message.length > 0 ){
				this.errInfo = jsonActionObject.message;
				callEvent("LoadObjects_OnFail", jsonActionObject.message);
				return;
			}
			if( jsonActionObject.errorMsg != undefined && jsonActionObject.errorMsg != null && jsonActionObject.errorMsg.length > 0 ){
				this.errInfo = jsonActionObject.errorMsg;
				callEvent("LoadObjects_OnFail", jsonActionObject.errorMsg);
				return;
			}
		}
		
		// 서버데이터 분석
		// FAILED 체크는 필요없는 부분이나 기존소스와의 호환을 위해 살려둠 
		if( jsonActionObject.resultCode == "SUCCESS" ){
			for(key in jsonActionObject.mapResult){
				if( typeof(jsonActionObject.mapResult[key])=="function" ) continue;
				getObjectById(key).loadData(jsonActionObject.mapResult[key]);
				key = null;
			}
			
			callEvent("LoadObjects_OnComplete", jsonActionObject.message);
		}
		else if( jsonActionObject.resultCode == "FAILED" ){
			callEvent("LoadObjects_OnFail", jsonActionObject.message);
		}
	}
	
	if( pFlag == "deleteData" ){
		// 오류 메시지 먼저 파악 
		if( jsonActionObject == null ){
			callEvent("Object_DeleteFailed", message);
			return;
		}
		
		// 오류정보 분석 
		// 서버에서 메시지가 넘어오면 무조건오류가 아니다, 성공메시지도 있다
		if( jsonActionObject.resultCode != "SUCCESS" ){
			if( jsonActionObject.message != undefined && jsonActionObject.message != null && jsonActionObject.message.length > 0 ){
				this.errInfo = jsonActionObject.message;
				callEvent("Object_DeleteFailed", jsonActionObject.message);
				return;
			}
			if( jsonActionObject.errorMsg != undefined && jsonActionObject.errorMsg != null && jsonActionObject.errorMsg.length > 0 ){
				this.errInfo = jsonActionObject.errorMsg;
				callEvent("Object_DeleteFailed", jsonActionObject.errorMsg);
				return;
			}
		}
		
		// 데이터분석
		for(key in jsonActionObject.mapResult){
			if( typeof(jsonActionObject.mapResult[key]) == "function" ) continue;
			
			if( this.batchWorkDelete )
				this.batchWorkDelete.setResult(key, jsonActionObject.mapResult[key]);
			
			key = null;
		}
		
		// 완료가 되었으면 object_DeleteCompleted()이벤트를 호출하고
		// FAILED 체크는 필요없는 부분이나 기존소스와의 호환을 위해 살려둠 
		if( jsonActionObject.resultCode == "SUCCESS" ){
			// 객체삭제 완료 이벤트 발생
			callEvent("Object_DeleteCompleted", jsonActionObject.message);
			
			// 삭제 배치완료 이벤트 먼저 발생
			if( this.batchWorkDelete )
				callEvent("batch" + this.batchWorkDelete.batchId + "_OnSuccess", jsonActionObject.message);
		}
		// 실패 메시지이면  object_DeleteFailed()이벤트를 호출한다
		else if( jsonActionObject.resultCode == "FAILED" ){
			callEvent("Object_DeleteFailed", jsonActionObject.message);
		}
		
		this.close();  
	}
	
	if( pFlag == "writeData" ){
		if( jsonActionObject == null ){
			callEvent("Object_WriteFailed", message);
			return;
		}
		
		// 오류정보 분석 
		if( jsonActionObject.errorMsg != undefined && jsonActionObject.errorMsg != null && jsonActionObject.errorMsg.length > 0 ){
			this.errInfo = jsonActionObject.errorMsg;
			callEvent("Object_WriteFailed", jsonActionObject.errorMsg);
			return;
		}
		
		// 데이터분석
		for(key in jsonActionObject.mapResult){
			if( typeof(jsonActionObject.mapResult[key]) == "function" ) continue;
			
			if( this.batchWorkInsert )
				this.batchWorkInsert.setResult(key, jsonActionObject.mapResult[key]);
			
			key = null;
		}
		
		// 완료가 되었으면 object_WriteCompleted()이벤트를 호출하고
		// FAILED 체크는 필요없는 부분이나 기존소스와의 호환을 위해 살려둠 
		if( jsonActionObject.resultCode == "SUCCESS" ){
			// 배치완료 이벤트 먼저 발생
			callEvent("Object_WriteCompleted", jsonActionObject.message);
			
			// 객체저장완료 이벤트 발생
			if( this.batchWorkInsert )
//				callEvent("batch" + this.batchWorkInsert.batchId + "_OnSuccess", jsonActionObject.message);
				callEvent("batch" + this.batchWorkInsert.batchId + "_wrt_OnSuccess", jsonActionObject.message);
		}
		// 실패 메시지이면  object_WriteFailed()이벤트를 호출한다
		else if( jsonActionObject.resultCode == "FAILED" ){
			callEvent("Object_WriteFailed", jsonActionObject.message);
		}
	}
	
	// hideAjaxBox();
	
	return;
};

/**
 * @description	미결
 * @return  {boolean}
 * @example	미결
 */
ObjectManager.prototype.loadData = function(){
	// functionname : [ObjectManager.loadData]
	
	// 로드할 키 정보가 충분한지 점검한다 
	var canLoadData = true;
	for(var key in objects){
		if( typeof(objects[key]) == "function" ) continue;
		canLoadData = canLoadData && objects[key].canLoadData();
	}
	
	// 자동으로 호출되기 떄문에 되도록 메시지 박스를 뛰우지 않는다.
	if( !canLoadData ) return false;
	
	// 쿼리문자열을 만든다.
	// 로드할 객체의 키값들을 리턴한다
	var wQueryString = "lang=" + USER_LANGUAGE
					 + "&cogu=" + USER_COGU
					 + "&personalId=" + USER_PERSONALID;
	
//	var loadData = "";
//	for(var key in objects){
//		if( typeof(objects[key])=="function" ) continue;
//		if( loadData.length != 0 ) loadData += ";";
//		loadData += objects[key].getLoadData();
//	}
	
	var key = null;
	
	var loadData = {};
	var selectCondition = {};
	for(key in objects){
		if( typeof(objects[key]) == "function" ) continue;
		loadData[objects[key].tableID] = objects[key].getLoadJSON();
		selectCondition[objects[key].tableID] = objects[key].getSelectCondition();
		key = null;
	}
	
	wQueryString += "&data=" + this.encode64( JSON.stringify(loadData) );
	wQueryString += "&condition=" + this.encode64( JSON.stringify(selectCondition) );
	wQueryString += "&tm=" + (new Date()).valueOf() + (Math.floor(Math.random() * 1000) + 1);
	this.busy = true;
	
	// 화면을 Clear한다. 이때, 키항목을 제외하고 clear한다.
	clearForm(false);
	
	// 서버에 서비스를 의뢰한다  (formXXXXDataAction.java -> loadData Method) ajaxCallSync
//	showAjaxBox("선택하신 화면자료를 조회하는 중입니다.", 0);	
//	ajaxCallSync("POST", "/FlexFrame/form/FlexForm"+ "_" + USER_FORMID + "_Load.do", wQueryString, this, "loadData");
	if( typeof TEST_MODE == "undefined" || !TEST_MODE ){
		ajaxCallSync("POST", getContextPath()+"/" + USER_FORMID+ "_loadData.do", wQueryString, this, "loadData");
	} else {
		ajaxCallSync("POST", getContextPath()+"/test/" + USER_FORMID+ "_loadData.do", wQueryString, this, "loadData");
	}
	
	selectCondition = null;
	loadData = null;
	
	return true;
};

/**
 * @description	미결
 * @param	{string}	callerCommandName
 * @return  {void}
 * @example	미결
 */
ObjectManager.prototype.deleteData = function(callerCommandName){
	// functionname : [ObjectManager.deleteData]
	
	// 컴맨드 단추가 속한 프래임의 하위 객체만이 대상이다 
	// 하위객체는 데이터 시트가 기준이 된다.
	// 데이터 시트가 없는 경우에는 컨트롤과 연결된 객체를 찾는다.
	if( callerCommandName != undefined && callerCommandName.length > 0 )
		this.callerCommandName = callerCommandName;
	else
		this.callerCommandName = "";
	
	// 배치정보를 만든다 
	var wParamInfo = "";
	var wQueryString = "lang=" + USER_LANGUAGE
					 + "&cogu=" + USER_COGU
					 + "&personalId=" + USER_PERSONALID 
					 + "&batchId=" + this.deleteBatchId
					 + "&batchParam=" + this.deleteBatchParam;
	
	// 쿼리문자열을 만든다.
	// 지워야할 객체의 키값들을 리턴한다
//	var deleteData = "";
//	if( this.callerCommandName.length > 0 ){
//		var commandControl = controls[callerCommandName];
//		for(var i = 0; i < commandControl.objectNames.length; i++){
//			deleteData += objects[commandControl.objectNames[i]].getDeleteData();
//		}
//		wQueryString += "&data=" + this.encode64(deleteData);
//	} else {
//		for(var id in objects){
//			if( typeof(objects[id])=="function" ) continue;
//			deleteData += objects[id].getDeleteData();
//		}
//		wQueryString += "&data=" + this.encode64(deleteData);
//	}
//	wQueryString += "&tm=" + (new Date()).valueOf() + (Math.floor(Math.random() * 1000) + 1);
	
	var commandControl = null;
	var id = null;
	var i = 0;
	
	var deleteData = {};
	if( this.callerCommandName.length > 0 ){
		commandControl = controls[callerCommandName];
		for(i = 0; i < commandControl.objectNames.length; i++){
			deleteData[objects[commandControl.objectNames[i]].tableID] = objects[commandControl.objectNames[i]].getDeleteJSON();
		}
		commandControl = null;
	}
	else{
		for(id in objects){
			if( typeof(objects[id]) == "function" ) continue;
			deleteData[objects[id].tableID] = objects[id].getDeleteJSON();
			id = null;
		}
	}
	
	wQueryString += "&data=" + this.encode64( JSON.stringify(deleteData) );
	wQueryString += "&tm=" + (new Date()).valueOf() + (Math.floor(Math.random() * 1000) + 1);
	this.busy = true;
	
	// 서버에 서비스를 의뢰한다  (formXXXXDataAction.java -> deleteData Method)
	//showAjaxBox("자료를 삭제중입니다", 0);
    if( typeof TEST_MODE == "undefined" || !TEST_MODE ){
    	ajaxCall("POST", getContextPath() + "/" + USER_FORMID + "_Delete.do", wQueryString, this, "deleteData");    
    } else {
    	ajaxCall("POST", getContextPath() + "/test/" + USER_FORMID + "_Delete.do", wQueryString, this, "deleteData");    
    }
    
    deleteData = null;
    
    return;
};

/**
 * @description	미결
 * @param	{string}	callerCommandName
 * @return  {void}
 * @example	미결
 */
ObjectManager.prototype.writeData = function(callerCommandName){
	// functionname : [ObjectManager.writeData]
	
	// 컴맨드 단추가 속한 프래임의 하위 객체만이 대상이다 
	// 하위객체는 데이터 시트가 기준이 된다.
	// 데이터 시트가 없는 경우에는 컨트롤과 연결된 객체를 찾는다.
	var commandControl = null;
	if( callerCommandName != undefined && callerCommandName.length > 0 ){
		this.callerCommandName = callerCommandName;
		commandControl = controls[callerCommandName];
	}
	else{
		this.callerCommandName = "";
	}
	
	// 배치정보를 만든다 
	var wParamInfo = "";
	var wQueryString = "lang=" + USER_LANGUAGE
					 + "&cogu=" + USER_COGU
					 + "&personalId=" + USER_PERSONALID
					 + "&callerCommandName" + callerCommandName
					 + "&batchId=" + this.deleteBatchId
					 + "&batchParam=" + this.deleteBatchParam
					 + "&batchId2=" + this.insertBatchId
					 + "&batchParam2=" + this.insertBatchParam;
	
	// 객체 시퀀스를 시트를 기준으로 재정비한다.
	var control = null;
	var id = null;
	try{
		for(id in controls){
			control = controls[id];
			
			if( typeof(control)=="function" ) continue;
			
			if( control.controlId.toLowerCase().indexOf("sheet_") >= 0 && control.controlId.toLowerCase().indexOf("listsheet_") < 0 ){
				control.updateSeqFieldOfLinkedObject();
				// 시트 시퀀스도 같이 재정비한다. 
				//15.05.01 이지홍 추가
				control.updateObjectSeq();
			}
			
			id = null;
			control = null;
		}
	}
	catch(e){
		id = null;
		control = null;
		
		// AUIGrid인 경우 'control instanceof DataSheet' 에러
	}
	
	// dniMode 인겨우 seq 의 재부여
	var wObject = null;
	var id = null;
//	if (!this.dataloaded) {
		if( this.callerCommandName.length > 0 ){
			for(var i = 0; i < commandControl.objectNames.length; i++){
				//객체저장
				wObject = objects[commandControl.objectNames[i]];
				wObject.sortBySeq();
				wObject.arrangeSeq();
				wObject = null;
			}
		}
		else{
			for(id in objects) {
				if( typeof(objects[id]) == "function" ) continue;
				wObject = objects[id];
				wObject.sortBySeq();
				wObject.arrangeSeq();
				id = null;
				wObject = null;
			}
	    }
//	}
	id = null;
	wObject = null;
	
	// 객체별로 데이터를 불러와 인코딩한다.
//	var writeData = "";
//    if (this.callerCommandName.length > 0){
//    	for (var i=0; i < commandControl.objectNames.length;i++){
//    		writeData += objects[commandControl.objectNames[i]].getWriteData();
//    	}
//    } else {
//    	for (var id in objects) {
//    		if (typeof(objects[id])=="function") continue;
//    		writeData += objects[id].getWriteData();
//    	}
//    }
	
	var writeData = {};
	var dniModeQry = {}
	if( this.callerCommandName.length > 0 ){
		for(var i=0; i < commandControl.objectNames.length;i++){
			writeData[objects[commandControl.objectNames[i]].tableID] = objects[commandControl.objectNames[i]].getWriteJSON();
			dniModeQry[objects[commandControl.objectNames[i]].tableID] = objects[commandControl.objectNames[i]].dniMode;
		}
	}
	else{
		for(var id in objects){
			if( typeof(objects[id]) == "function" ) continue;
			writeData[objects[id].tableID] = objects[id].getWriteJSON();
			dniModeQry[objects[id].tableID] = objects[objects[id].tableID].dniMode;
		}
	}
	
	wQueryString += "&data=" + this.encode64( JSON.stringify(writeData) );
	wQueryString += "&dniMode=" + (this.dataloaded ? "0" : "1"); /* 2015.09.22 이지홍 */  
	wQueryString += "&dniModeQry=" + this.encode64( JSON.stringify(dniModeQry) );   
	wQueryString += "&tm=" + (new Date()).valueOf() + (Math.floor(Math.random() * 1000) + 1);
	this.busy = true;
	
	//window.clipboardData.setData("Text", this.encode64(writeData));
	// 서버에 서비스를 의뢰한다  (formXXXXDataAction.java -> writeData Method)
	//showAjaxBox("자료를 등록중입니다", 0);
//	alert("/FlexFrame/form/FlexForm" + USER_COGU + "_" + USER_FORMID + "_Write.action?"+wQueryString);
	//DebugCopy("/FlexFrame/form/FlexForm" + USER_COGU + "_" + USER_FORMID + "_Write.action?" + wQueryString);
//	ajaxCall("POST", "/FlexFrame/form/FlexForm" + USER_COGU + "_" + USER_FORMID + "Controller" +"_Write.do", wQueryString, this, "writeData");
	if( TEST_MODE == undefined || !TEST_MODE ){
		ajaxCall("POST", getContextPath() + "/" + USER_FORMID + "_Write.do", wQueryString, this, "writeData");
	} else{
		ajaxCall("POST", getContextPath() + "/test/" + USER_FORMID + "_Write.do", wQueryString, this, "writeData");
	}
	
    writeData = null;
    
    return;
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
ObjectManager.prototype.fillData = function(){
	// functionname : [ObjectManager.fillData]
	
	if( typeof fillObjectToScreen == "function" ){
		fillObjectToScreen(this.fillkeyFieldValue);
		this.dataloaded = true;
	}
	
	return;
};

/**
 * @description	미결
 * @return  {boolean}
 * @example	미결
 */
ObjectManager.prototype.objectChanged = function(){
	// functionname : [ObjectManager.objectChanged]
	
	// 변화가 있는 객체만을 기록한다. (변화가 없으면 메시지만 뿌리고 빠진다.)
	var needWrite = false;
	var commandControl = null;
	
	if( this.callerCommandName.length > 0 ){
		commandControl = controls[this.callerCommandName];
		
		for(var i = 0; i < commandControl.objectNames.length; i++)
			needWrite = needWrite || objects[commandControl.objectNames[i]].needWrite();
		
		commandControl = null;
	}
	else{
		for(var id in objects){
			if( typeof(objects[id]) == "function" )
				continue;
			
			needWrite = needWrite || objects[id].needWrite();
		}
	}
	
	return needWrite;
};

/**
 * @description	미결
 * @param	{string}	data
 * @return  {string}
 * @example	미결
 */
ObjectManager.prototype.encode64 = function(data){
    // functionname : [ObjectManager.encode64]

	var wReturn = "";
	var index = 0;
	var input = encodeURIComponent(data);

	while (index < input.length) {
	   var charCode1 = input.charCodeAt(index++);
	   var charCode2 = input.charCodeAt(index++);
	   var charCode3 = input.charCodeAt(index++);

	   var newCode1 =   charCode1 >> 2;
	   var newCode2 = ((charCode1 & 3)  << 4) | (charCode2 >> 4);
	   var newCode3 = ((charCode2 & 15) << 2) | (charCode3 >> 6);
	   var newCode4 =   charCode3 & 63;

	   if (isNaN(charCode2))  newCode3 = 64;
       if (isNaN(charCode3))  newCode4 = 64;

       wReturn += USER_KEYSTR.charAt(newCode1) + USER_KEYSTR.charAt(newCode2) + USER_KEYSTR.charAt(newCode3) + USER_KEYSTR.charAt(newCode4);
	}

	return wReturn;
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
ObjectManager.prototype.close = function(){
    // functionname : [ObjectManager.close]

	if (this.batchWorkDelete != null){
	    this.batchWorkDelete.close();
	    this.batchWorkDelete = null;
	}
	if (this.batchWorkInsert != null){
	    this.batchWorkInsert.close();
	    this.batchWorkInsert = null;
	}
	return;
};

/* ********************************************************************
 *   CALL BATCH WORK
 * ********************************************************************/
/**
 * @description	미결
 * @param		{String}	pKey
 * @param		{String}	batchId
 * @return  	{Object}
 * @example		미결
 */
function getBatchWorkByKey(pKey, batchId){
	if (batchId == undefined) batchId = pKey;
    var wFound = false;
    for (var wKey in batchWorks){
    	if (batchWorks[wKey] instanceof Function) continue;
        if (wKey == pKey){
            wFound = true;
            break;
        }
    }
    var batchWork = null;
    
    if (wFound){
        batchWork = batchWorks[pKey];
    } else {
    	batchWork = batchWorks[pKey] = new BatchWork(pKey);
    }
    batchWork.batchId = batchId;
    
    return batchWork;
};

/**
 * @description	미결
 * @param		{String}	id
 * @param		{String}	batchId
 * @return  	{String}
 * @example		미결
 */
function BatchWork(id, batchId){
    this.id = id;
    this.batchId = id;
    this.parameters = [];
    this.results = [];
    this.report = null;
    this.nextBatchId = "";
    this.skip = false;
    
    this.message = "";
    
	batchWorks[batchId] = this;  
	this.busy = false;
    return this;
};

/**
 * @description	미결
 * @param	{string}	fieldName
 * @param	{string}	dataValue
 * @return  {void}
 * @example	미결
 */
BatchWork.prototype.setParameter = function(fieldName, dataValue){
    // functionname : [BatchWork.setParameter]

	this.parameters[fieldName] = new Parameter(fieldName, dataValue);
    return;
};

/**
 * @description	미결
 * @param	{string}	resultName
 * @param	{string}	dataValue
 * @return  {void}
 * @example	미결
 */
BatchWork.prototype.setResult = function(resultName, dataValue){
    // functionname : [BatchWork.setResult]

    this.results[resultName] = dataValue;
    return;
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
BatchWork.prototype.execute = function(){
    // functionname : [BatchWork.execute]

    if (this.skip){
    	if (this.nextBatchId.length != 0){
    		setTimeout("getBatchWorkByKey('" + this.nextBatchId + "').execute();", 1);
    	}
		return;
     }
                       
    // 데이터를 리턴받는 경우 레코드셋을 미리 만들어 두고 이 루틴을 호출할 것 
    var wParamInfo = ""; var seq = 1;
    for (var wKey in this.parameters){
    	if (this.parameters[wKey] instanceof Function) continue;
    	
        wParamInfo  += "&parameter" + (seq++) + "=" 
                    + encodeURIComponent(this.parameters[wKey].value());
    }

    var wQueryString = "lang=" + USER_LANGUAGE
                    + "&cogu=" + USER_COGU
                    + "&userId=" + USER_USERID
                    + "&personalId=" + USER_PERSONALID
			        + "&batchId=" + this.batchId
			        + wParamInfo
			        + "&tm=" + (new Date()).valueOf() + (Math.floor(Math.random() * 1000) + 1);

    this.busy = true;
	// showAjaxBox("작업중입니다. 잠시만기다려 주십시요", 0);
	   
	var batchWork = this;
    if (TEST_MODE == undefined || !TEST_MODE){
    	ajaxCall("POST", getContextPath()+"/run" + this.batchId + ".do", wQueryString, this, "execute");
    } else {
    	ajaxCall("POST", getContextPath()+"/test/run" + this.batchId + ".do", wQueryString, this, "execute");
    }
	
	return;
	
};

/**
 * @description	미결
 * @param	{object}	jsonActionObject
 * @param	{string}	message
 * @param	{object}	pFlag
 * @return  {void}
 * @example	미결
 */
BatchWork.prototype.parseData = function(jsonActionObject, message, pFlag){
    // functionname : [BatchWork.parseData]
    this.busy = false;
                       
	// 오류 메시지 먼저 파악 
	if (jsonActionObject == null){
		callEvent("batch" + this.id + "_OnFailure", message);
		return;
	}

	// 오류정보 분석 
	if (jsonActionObject.errorMsg != undefined && jsonActionObject.errorMsg != null && jsonActionObject.errorMsg.length > 0){
		this.errInfo = jsonActionObject.errorMsg;
		callEvent("batch" + this.id + "_OnFailure", jsonActionObject.errorMsg);
		return;
	}
	
	// 구버전 메시지
	if (jsonActionObject.message != undefined && jsonActionObject.message != null && jsonActionObject.message.length > 0){
		this.errInfo = jsonActionObject.message;
		callEvent("batch" + this.id + "_OnFailure", jsonActionObject.message);
		return;
	}
	
	// 데이터분석
	for (var key in jsonActionObject.mapResult){
		if (typeof(jsonActionObject.mapResult[key])=="function") continue;
        this.setResult(key, jsonActionObject.mapResult[key]);
    }
	
	// 배치 스텝내 레포트 호출
	for (var key in this.results){
		if (!key.startsWith("executeOfBatch_")) continue;
		executeOfBatch(this.results[key]);
    }
    
   	// message 체크는 필요없는 부분이나 기존소스와의 호환을 위해 살려둠 
	var message = this.message;
	if (message.length == 0){
        callEvent("batch" + this.id + "_OnSuccess");
        
        // 연결리포트 수행
        if (this.report != null) this.report.execute();

	} else {
        callEvent("batch" + this.id + "_OnFailure", message);
	}
	
	return;
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
BatchWork.prototype.inintialize = function(){
    // functionname : [BatchWork.inintialize]

    for (var i = this.parameters.length - 1; i >= 0; i--) {
        this.parameters.pop();
     }
    this.parameters= null;
    this.parameters= [];
    
    for (var i = this.results.length - 1; i >= 0; i--) {
        this.results.pop();
     }
    this.results= null;
    this.results= [];
    this.nextBatchId = "";
    this.needSkip = false;
	return;	
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
BatchWork.prototype.close = function(){
    // functionname : [BatchWork.close]

	// hideAjaxBox();
    this.inintialize();
	return;
};

// 채번 정보 처리 객체
var isInNumberingProcess = false;
function NumberingSVC(){
	this.controlName = ""; // TextBox
	this.controlId = "";
	this.commandName = "";
	
	this.cogu=0;
	this.dbId="";
	this.objectId="";
	this.maxGu="";
	this.propertyId="";
	this.propertyType="";
	this.param = "";
	this.encoding = "";
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
NumberingSVC.prototype.callService = function(){
    // functionname : [NumberingSVC.callService]
    var wQueryString = "lang=" + USER_LANGUAGE
                     + "&cogu=" + USER_COGU
                     + "&maxGu=" + this.maxGu
                     + "&dbId=" + this.dbId
			         + "&objectId=" + this.objectId
			         + "&propertyId=" + this.propertyId
			         + "&propertyType=" +this.propertyType
			         + "&encoding=" +this.encoding
			         + "&param=" + encodeURIComponent(this.param)
			         + "&tm=" + (new Date()).valueOf() + (Math.floor(Math.random() * 1000) + 1);

	//showAjaxBox("번호 채번 작업 중입니다. 잠시만 기다려 주십시요.", 0);
    ajaxCall("POST", getContextPath()+"/numbering.do", wQueryString, this, "numbering");
    
    return;
};

/**
 * @description	미결
 * @param	{object}	jsonActionObject
 * @param	{string}	message
 * @param	{object}	pFlag
 * @return  {void}
 * @example	미결
 */
NumberingSVC.prototype.parseData = function(jsonActionObject, message, pFlag){
    // functionname : [NumberingSVC.parseData]
	//hideAjaxBox();

	// 오류 메시지 먼저 파악 
	if (jsonActionObject == null){
        callEvent("numbering_" + this.controlId + "_failed", message);
		return;
	}

	// 오류정보 분석 
	if (jsonActionObject.errorMsg != undefined && jsonActionObject.errorMsg != null && jsonActionObject.errorMsg.length > 0){
		this.errInfo = jsonActionObject.errorMsg;
        callEvent("numbering_" + this.controlId + "_failed", jsonActionObject.errorMsg);
		return;
	}
	
	// 데이터분석 
   	// message 체크는 필요없는 부분이나 기존소스와의 호환을 위해 살려둠 
	var message = jsonActionObject.errorMsg;
	if (message.length == 0){
		isInNumberingProcess = true; // 채번중에는 가저오기, 객체로드 채우기능 동작이 일어나면 데이터가 손상될 수 있다
		controls[this.controlName].setValue(jsonActionObject.newNumber);
		isInNumberingProcess = false;
		
        callEvent("numbering_" + this.controlId + "_Completed", parseInt(1 * jsonActionObject.newNumber), this.commandName);
	} else {
        callEvent("numbering_" + this.controlId + "_failed", message);
	}
	
	return;
};

/**
 * @description	미결
 * @param		{Object}	recordset
 * @return  	{Undefined}
 * @example		미결
 */
//케시에 사용되는 목록
function DataCashe(recordset){
    this.sqlnum = recordset.sqlnum;
	this.key = recordset.key;
    this.rowCount= recordset.rowCount;
    this.totalRowCount = recordset.totalRowCount;

	this.recordNums = recordset.recordNums.slice(0);
	
	var wFields = recordset.fields;
    this.fields = [];
    for (var wFieldNum = 0; wFieldNum < wFields.length; wFieldNum++){
        this.fields[wFieldNum] = new Field(null, wFields[wFieldNum].fieldName, wFields[wFieldNum].datatype);
	    this.fields[wFieldNum].datas = wFields[wFieldNum].datas.slice(0);
    }
};

function executeOfBatch(info){
	try {
		if (BrowserDetect.browser == "Explorer") {
			var win = window.open("ViewReportLoad.do?fileName="+encodeURI(encodeURIComponent(info)), "_blank", "width=1024px, height=768px, toolbar=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no");
		} else {
			var win = window.open("about:blank", "_blank", "width=1024px, height=768px, toolbar=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no");
			if (!win) throw getText("message_report_001", "팝업이 차단 되었습니다. 레포트를 실행하시려면 팝업을 허용해 주세요. \n ※팝업차단허용방법: 브라우저 상단 메뉴바에서 [도구]-[팝업차단]-[팝업차단설정] 에서 허용할 웹사이트 주소란에 주소를 추가해 주시고 레포트를 실행해 주세요.");
			setTimeout(function (){
			win.document.write('<html><head><title>'+info.split("|")[2]+'</title><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><style type="text/css">body{margin:0;padding:0;height:100%;}</style></head>');
			win.document.write('<body><iframe src="ViewReportLoad.do?fileName='+encodeURI(encodeURIComponent(info))+'" width="100%" height="100%" marginheight="0" marginwidth="0" border="0" frameborder="0" scrolling="no"></iframe></body></html>');
			}, 100);
		}
	} catch(e){
	    alert(e);
	}
	
	return;
};
/**
 * @class Flexformscripthead
 * @constructor Flexformscripthead
 * @description	미결
 */


/*******************************************************************************
    폼에대한 기초보안 조치 
*******************************************************************************/

/**
 * @description	미결
 * @name		Flexformscripthead#
 * @event
 * @returns		{Boolean}
 */
// 포커스 이벤트 
    document.onselectstart = function(e) {
    	// functionname : [document.onselectstart]
    	                   
        e = window.event || e;
    	var em =  (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
        if (em.tagName !="INPUT" && em.tagName !="TEXTAREA") return false; 
        return true;
    };
    
    /**
     * @description	미결
     * @returns		{Boolean}
     * @example		미결
     */
    // prevent user's right click();
    document.oncontextmenu = function(){ 
    	// functionname : [document.oncontextmenu]

    	//return true;
    	return false;
    };
    
    /**
     * @description	미결
     * @name		Flexformscripthead#
     * @event
     * @returns		{Boolean}
     */
    //글로벌 키다운
	document.onkeydown= function(e) {
		if(e.keyCode == 116) {
			if(typeof e.preventDefault == "function") {
				e.preventDefault();
			} else {
				e.returnValue = false; // for IE
			}
			return false;
		}
	};

/*******************************************************************************
    폼 동작에 필요한 변수들 
*******************************************************************************/
    var jFormid = "";
    var jLinkid = "";
    var jMenuID = "";
    var jParams = "";
    var jGlobal = "";
    var jLoaded = false;
    var jCharInfo = "";
    var jTreeSQL = "";
    var FTPString = "";
    var wControl = null;
    var jUploadPrefix = "";
    var keyInfoStr = "";
    
    // IFRAME 기능으로 호출되었는지 여부
    var thisIsIframe = (self.parent && 
    		            self.parent.document.getElementsByName(self.name).length > 0 && 
    		            self.parent.document.getElementsByName(self.name)[0].tagName.toUpperCase() == "IFRAME");
    
/*******************************************************************************
    전역상수 
*******************************************************************************/
    
    var USER_BROWSER_NAME = navigator.appName.toLowerCase();  // ex:"microsoft internet explorer", "Netscape"
    var USER_BROWSER_VER  = parseFloat(navigator.appVersion);
//    var IS_IE9_OR_LOWER_VERSION = ( navigator.appName.toLowerCase().indexOf("microsoft") >= 0 && 
//                                    (navigator.appVersion.indexOf("MSIE 7") > 0 || 
//                                     navigator.appVersion.indexOf("MSIE 8") > 0 ||
//                                     navigator.appVersion.indexOf("MSIE 9") > 0));
    var IS_IE9_OR_LOWER_VERSION = (navigator.appVersion.indexOf("MSIE 7") >= 0
    								|| navigator.appVersion.indexOf("MSIE 8") >= 0
    								|| navigator.appVersion.indexOf("MSIE 9") >= 0);
    		
/*
 * Tree 동작에 필요한 상수
 */
    var tvwTreeLines = 0;
    var tvwRootLines = 1;
    
    var tvwFirst = 0;
    var tvwLast = 1;
    var tvwNext = 2;
    var tvwPrevious = 3;
    var tvwChild = 4;
    
    // 트리에 필요한 그림상수 변수
    var PLUS_NORMAL   = 0;
    var PLUS_BOTTOM   = 1;
    var MINUS_NORMAL  = 2;
    var MINUS_BOTTOM  = 3;
    var FOLDER_NORMAL = 4;
    var FOLDER_OPEN   = 5;
    var JOIN_NORMAL   = 6;
    var JOIN_BOTTOM   = 7;
    var LINE_BLANK    = 8;
    var EMPTY_ICON    = 9;
    var PAGE_ICON     = 10;

    // CROSS SHEET에 필요한 상수    
    // 선긋기에 필요한 상수 
    var RCTYPE_ISCOL = 1;
    var RCTYPE_ISROW = 1;
    var FONT_WIDTH   = 7; // 폰트 한바이트당 크기
    
    // 보이기 숨기기 구분
    var ACTION_SHOW = 1;
    var ACTION_HIDE = 2;
    
    // 트리에 필요한 상수
    var icons = new Array(6);
    icons[PLUS_NORMAL]       = new Image();
    icons[PLUS_NORMAL].src   = CONTEXT_ROOT + "/winnersoft/images/tree/plus.gif";
    icons[PLUS_BOTTOM]       = new Image();
    icons[PLUS_BOTTOM].src   = CONTEXT_ROOT + "/winnersoft/images/tree/plusbottom.gif";
    icons[MINUS_NORMAL]      = new Image();
    icons[MINUS_NORMAL].src  = CONTEXT_ROOT + "/winnersoft/images/tree/minus.gif";
    icons[MINUS_BOTTOM]      = new Image();
    icons[MINUS_BOTTOM].src  = CONTEXT_ROOT + "/winnersoft/images/tree/minusbottom.gif";
    icons[FOLDER_NORMAL]     = new Image();
    icons[FOLDER_NORMAL].src = CONTEXT_ROOT + "/winnersoft/images/tree/folder.gif";
    icons[FOLDER_OPEN]       = new Image();
    icons[FOLDER_OPEN].src   = CONTEXT_ROOT + "/winnersoft/images/tree/folderopen.gif";
    icons[JOIN_NORMAL]       = new Image();
    icons[JOIN_NORMAL].src   = CONTEXT_ROOT + "/winnersoft/images/tree/join.gif";
    icons[JOIN_BOTTOM]       = new Image();
    icons[JOIN_BOTTOM].src   = CONTEXT_ROOT + "/winnersoft/images/tree/joinbottom.gif";
    icons[LINE_BLANK]        = new Image();
    icons[LINE_BLANK].src    = CONTEXT_ROOT + "/winnersoft/images/tree/line.gif";
    icons[EMPTY_ICON]        = new Image();
    icons[EMPTY_ICON].src    = CONTEXT_ROOT + "/winnersoft/images/tree/empty.gif";
    icons[PAGE_ICON]         = new Image();
    icons[PAGE_ICON].src     = CONTEXT_ROOT + "/winnersoft/images/tree/page.gif";
    
    // 쿼리 데이터 타입
    var SQL_TYPE_NULL          = 0   ;
    var SQL_TYPE_CHAR          = 1   ;
    var SQL_TYPE_NUMERIC       = 2   ;
    var SQL_TYPE_DECIMAL       = 3   ;
    var SQL_TYPE_INTEGER       = 4   ;
    var SQL_TYPE_SMALLINT      = 5   ;
    var SQL_TYPE_FLOAT         = 6   ;
    var SQL_TYPE_REAL          = 7   ;
    var SQL_TYPE_DOUBLE        = 8   ;
    var SQL_TYPE_LONGVARCHAR   = -1  ;
    var SQL_TYPE_BINARY        = -2  ;
    var SQL_TYPE_VARBINARY     = -3  ;
    var SQL_TYPE_LONGVARBINARY = -4  ;
    var SQL_TYPE_BIGINT        = -5  ;
    var SQL_TYPE_TINYINT       = -6  ;
    var SQL_TYPE_BIT           = -7  ;
    var SQL_TYPE_VARCHAR       = 12  ;
    var SQL_TYPE_BOOLEAN       = 16  ;
    var SQL_TYPE_DATALINK      = 70  ;
    var SQL_TYPE_DATE          = 91  ;
    var SQL_TYPE_TIME          = 92  ;
    var SQL_TYPE_TIMESTAMP     = 93  ;
    var SQL_TYPE_OTHER         = 1111;
    var SQL_TYPE_JAVA_OBJECT   = 2000;
    var SQL_TYPE_DISTINCT      = 2001;
    var SQL_TYPE_STRUCT        = 2002;
    var SQL_TYPE_ARRAY         = 2003;
    var SQL_TYPE_BLOB          = 2004;
    var SQL_TYPE_CLOB          = 2005;
    var SQL_TYPE_REF           = 2006;

    // 가저오기중 시트채우기 실행중구분 : 시트갱신시 콘트롤 매번 시퀀스 바꿔가며 갱신 방지
    var FILLSTATE_NONE = 0;
	var FILLSTATE_SHEET = 1;
	var fillState = FILLSTATE_NONE;

	
    // 리스트박스 상수 선언부
    var LISTBOX_TYPE_OLDSINGSELECT = 0;
    var LISTBOX_TYPE_SINGSELECT    = 1;
    var LISTBOX_TYPE_MULTISELECT   = 2;
    var LISTBOX_TYPE_CHECKSELECT   = 3;
    var LISTBOX_TYPE_DATASELECT    = 4;
    
    // 시트채우기 모드
    var DATALISTBOX_SETITEM = 1;
    var DATALISTBOX_SETDATA = 2;
    
    // 데이터 저장 구분
    var LISTBOX_SAVE_SINGLE = 0;
    var LISTBOX_SAVE_MULTI  = 1;
    
    // ===== Timer Start  ====
	var TIMER_DISPLAY_NONE = 0;			// 표시 없음
	var TIMER_DISPLAY_USERTEXT = 1;		// 산식결과
	var TIMER_DISPLAY_IMAGEURL = 2;		// 이미지
	var TIMER_DISPLAY_TIMELEFT = 3;		// 남은시간 표시
	var TIMER_DISPLAY_CURRTIME = 4;		// 현재시간 표시
    // =====  Timer End   ====

/*******************************************************************************
    전역객체 
 *******************************************************************************/
    var wCalculator = new EXOCalculator();
    var wLogic      = new EXOLogic("");
    var objectManager = new ObjectManager();
/*******************************************************************************
    전역변수 
 *******************************************************************************/
    var arrKeyCodes=[8, 9, 16,17,18,19,20,27,33,34,35,36,37,38,39,40,91,92];
    // 8:백스페이스 9:Tab 
    // 16:shift 17 :ctl 18:alt 19:break 20 :caps 
    // 27 :esc 33:pageup 34:page down 35:End 36:Home 37:좌로 38:up 39:우로 40 : down 
    // 91:윈도우92:윈도우
    var objects     = []; //associative array
    var controls    = []; //associative array
    var parameters  = []; //associative array
    var dataCashes  = []; //associative array * 키는 sql번호:파라메터1:파라메터2:....:파라메터n
    var cachedimages= []; //associative array
    var charts		= [];
    var crosssheets = [];
    var pictures	= [];
    var reports  	= [];
    var DocDateControlName = ""; 
    var DocNumControlName = "";
    var DocTitleControlName = "";
    var uploadControls = []; // 파일업로드 정보가 들어 있는 곳
    
    // 마우스 이동에 관한 변수 
    var jClassName = "";
    var jObject = null;
    
    // 시트크기조절에 관한 변수
    var ResizeObject = null; 
    var wIsResizing = false;
    var mustFillScreenAfterLoad = false;
    
    // 시트 컬럼 이동에 관한 변수
    var wIsColumnMove = false;
    var wIsColumnMoving = false;
    var MoveObject = null;
    var moveOldColumn = 0;
    var moveScrollLeft = 0;
    
/*******************************************************************************
    전역함수 
 *******************************************************************************/
    /**
     * @description	미결
     * @returns		{Void}
     * @example		미결
     */
    function unloadForm(){
    	if (typeof EventCache != "undefined") EventCache.flush();
    	for (var id in controls) {
    		if (typeof(controls[id])=="function") continue;
    		delete controls[id];
    	}
    	for (var id in parameters) {
    		if (typeof(parameters[id])=="function") continue;
    		delete parameters[id];
    	}
//    	for (var id in objects) {
//    		if (typeof(objects[id])=="function") continue;
//    		objects[id].clear();
//    		delete objects[id];
//    	}
    	
    	icons.clear();
    	arrKeyCodes.clear();
    	jObject = null;
        ResizeObject = null;
        MoveObject = null;
        wLogic = null;
        wCalculator = null;
    	
    	return;
    };
	
	//Document Unload Event 추가
	if (window.attachEvent){
	    /*IE and Opera*/
	    window.attachEvent("onunload", unloadForm);
	}
	else if (document.addEventListener){
	    /*Chrome, FireFox*/
	    window.onbeforeunload = unloadForm;
	    /*IE 6, Mobile Safari, Chrome Mobile*/
	    window.addEventListener("unload", unloadForm, false);
	}
	else{
	    /*etc*/
	    document.addEventListener("unload", unloadForm, false);
	}
    
    /**
     * @description	미결
     * @param		{String}	id
     * @returns		{String}
     * @example		미결
     */
    function getControlById(id) 
    {
    	var wReturn = null;
    	for (var wKey in controls){
    	if (controls[wKey] instanceof Function) continue;
    		if (controls[wKey].id == id){
    			wReturn = controls[wKey];
    			break;
    		}
    	}
    	return wReturn;
    };
    
    function getControlByTag(tag) 
    {
    	var wReturn = null;
    	
    	var pEm = tag;
    	while (pEm.parentNode && !pEm.id) {
    		pEm = pEm.parentNode;
    	}
    	if (pEm == null) return undefined;
    	
    	return getControlById(pEm.id);
    };
    
    /**
     * @description	미결
     * @returns		{Undefined}
     * @example		미결
     */
    function clearControls(){
    	for (var id in controls) {
    		if (typeof(controls[id])=="function") continue;
    		delete controls[id];
    	}
    };


    /**
     * @description	미결
     * @param		{Object}	em
     * @returns		{String}
     * @example		미결
     */
    function searchSheet(em){
    	var pEm = em;
    	var wReturn = null;
    	while (pEm.parentNode && !pEm.className.startsWith("DataSheet") && !pEm.className.startsWith("AUIDataSheet") && !pEm.className.startsWith("ListSheet") && !pEm.className.startsWith("CrossSheet")) {
    		pEm = pEm.parentNode;
    		if (pEm == null) return null;
    	}
    	if (pEm.className.startsWith("DataSheet") || pEm.className.startsWith("AUIDataSheet") || pEm.className.startsWith("ListSheet") || pEm.className.startsWith("CrossSheet")){ 
    	       wReturn = getControlById(pEm.id);
    	}
    	return wReturn;
    };
    	
    /**
     * @description	미결
     * @param		{Object}	em
     * @returns		{String}
     * @example		미결
     */
    function searchRow(em){
    	var wReturn = null;
    	
    	var parentEm = em;
    	while (parentEm.tagName != "TR") {  // TR테그가 없는 경우 document객체까지 서슬러 올라가게 된다
    		parentEm = parentEm.parentNode;
		    if (parentEm == null) return null;
    	}
    	if (parentEm.tagName == "TR" && parentEm.getAttribute("haveData") == "1") {
    		wReturn = searchSheet(em).dataTable.tBodies[0].rows[parentEm.rowIndex];
    	}
    	
    	return wReturn;
    };

    /**
     * @description	미결
     * @param		{Object}	em
     * @returns		{Object}
     * @example		미결
     */
    function searchCell(em){
//    	var wReturn = null;
    	
    	var parentEm = em;
    	
    	while (parentEm.parentNode.tagName != "TR") {  // TR테그가 없는 경우 document객체까지 서슬러 올라가게 된다
    		parentEm = parentEm.parentNode;
		    if (parentEm.parentNode == null) return null;
    	}
//    	if (parentEm.parentNode.tagName == "TR" && parentEm.parentNode.getAttribute("haveData") == "1") {
//    		wReturn = parentEm.parentNode;
//    	}
    	
    	return parentEm;
    };
    
    /**
     * @description	미결
     * @returns		{Void}
     * @example		미결
     */
    function loadParamFromQuery(){
    	if (this.location.href.split("?").length <= 1) return;
    	
    	var qryStr = this.location.href.split("?")[1];
    	arr = qryStr.split("&");
    	for (var i=0; i < arr.length;i++){
    		var arr1 = arr[i].split("=");
    		parameters[arr1[0]] = arr1[1];
    	}
    	return;
    };

/*******************************************************************************
    전역 이벤트 처리 
 *******************************************************************************/
    /**
     * @description	미결
     * @name		Flexformscripthead#
     * @event		
     * @returns		{Boolean}
     */
    // 시트에 공통되는 이벤트  : 마우스이벤트의 케치 
document.onmousedown = function(e) {
     e = window.event || e;
     
     //공통 이벤트 처리
     var em = e.toElement;
     if(em != undefined && em != null){
         var Sheets = document.getElementsByClassName("DataSheet");
         var sheetLen = Sheets.length;
         for(var i=0; i<sheetLen; i++){
        	 var sheetControl = searchSheet(Sheets[i]);
        	 if(sheetControl != null){
        		 sheetControl.setPickHeaderClass(-1, -1, "");
        	 }
         }
         
		 // 달력 div에서 일어난 이벤트인지 판단.
		 while(em != null && em.localName != null && em.localName != "html"){
			 if(em.getAttribute("ID") == "calendarDiv") return true;
			 em = em.parentNode;
		 }
		 // 펼쳐진 달력이 있다면 닫는다.
		 var calendarDiv = document.getElementById("calendarDiv");
		 if(calendarDiv != null && calendarDiv != undefined) {
			 if(calendarDiv.style.display != "none") closeNotActionCalendar();
		 }
     }

		
     if (e.button == 2) return false;
     var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
     if (em == null) return false;
     if(em.className =="ComboBox" || em.className =="TextBox" || em.className == "CommandButton") return true;
     if (BrowserDetect.browser == "Chrome" && em.tagName == "HTML") return true; // 크롬에서 HTML Scroll 이 안먹는문제
     
     var wReturn = true;
//     if (em.tagName == "TD" && searchSheet(em) != null){
//             wReturn = Sheet_onmousedown(em);
//             stopPropagation(e);
//     }
     return wReturn;
};

/**
 * @description	미결
 * @name		Flexformscripthead#
 * @event		
 * @returns		{Boolean}
 */
document.onmousemove = function(e) {
	// functionname : [document.onmousemove]
	if (wIsResizing) {
		resizeCell(window.event.clientX, window.event.clientY);
		return true;
	}
	
	if (wIsColumnMove) {
		movingOfSheetColumn(window.event.clientX);
		return true;
	}
	
     e = window.event || e;
     var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
     if (em == null) return false;
     if(em.className =="ComboBox" || em.className =="TextBox" || em.className == "CommandButton") return true;
     if(BrowserDetect.browser == "Firefox" && (em.className == "TabSel" || em.className == "TabGen")) return true; // 파이어폭스에서 탭 풍선도움말 문제

     var wReturn = true;
//     if (em.tagName == "TD" && searchSheet(em) != null){
//             wReturn = Sheet_onmousemove(em);
//             stopPropagation(e);
//     }

     return wReturn;
};

/**
 * @description	미결
 * @name		Flexformscripthead#
 * @event		
 * @returns		{Boolean}
 */
document.onmouseout=function(e) {
	// functionname : [document.onmouseout]
     e = window.event || e;
     em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
     if (em == null) return false;
     if(em.className =="ComboBox" || em.className =="TextBox" || em.className == "CommandButton") return true;
     if(BrowserDetect.browser == "Firefox" && (em.className == "TabSel" || em.className == "TabGen")) return true; // 파이어폭스에서 탭 풍선도움말 문제
     
     var wReturn = true;
//     if (em.tagName == "TD" && searchSheet(em) != null){
//             wReturn = Sheet_onmouseout(em);
//             stopPropagation(e);
//     }

     return wReturn;
};

/**
 * @description	미결
 * @name		Flexformscripthead#
 * @event		
 * @returns		{Boolean}
 */
document.onmouseup = function(e) {
	// functionname : [document.onmouseup]
     e = window.event || e;
     
     // 셀 크기 조정 정보 초기화
     if(wIsResizing) {
			ResizeObject.table.parentNode.parentNode.setAttribute("cellsize", ResizeObject.cellSizes.join(";"));
			
			for(var i = ResizeObject.cellSizes.length - 1; i >= 0; i--) {
				ResizeObject.cellSizes.pop();
			}
			ResizeObject.cellSizes = null;
			ResizeObject.table = null;
			ResizeObject.tableRow = null;
			ResizeObject = null;
			
			wIsResizing = false;
			
			return false;
     }
     
     // 컬럼 이동 정보 초기화a
     if(wIsColumnMove) {
    	 movingOfSheetColumnSuccess();
    	 return false;
     }
	 
     if (e.button==2) return false;
     var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
     if (em == null) return false;
     if(em.className =="ComboBox" || em.className =="TextBox" || em.className == "CommandButton") return true;
     
     var wReturn = true;
//     if (em.tagName == "TD" && searchSheet(em) != null){
//             wReturn = Sheet_onmouseup(em);
//             stopPropagation(e);
//     }

     return wReturn;
};

/**
 * @description	미결
 * @param		{Object}
 * @returns		{Boolean}
 * @example		미결
 */
function preventbubble(evt){
	evt = evt || window.event;
	if (evt.stopPropagation){
		evt.stopPropagation();
		evt.preventDefault();
	}else if(typeof evt.cancelBubble != "undefined"){
		evt.cancelBubble = true;
		evt.returnValue = false;
	}
	return false;
};

///***************************************************************************
//     데이터시트 콘트롤의 이벤트 처리함수 부분이다
// ***************************************************************************/
//function Sheet_onmousedown(em) {
//
//	if (em.tagName != "TD" || 
//	    (em.className != "ColHead" && em.className != "lColHead" && em.className != "RowHead")) return false;
//	
//	var wTable = em.parentNode;
//	while(wTable.tagName != "TABLE") wTable = wTable.parentNode;
//	
//	var dir = getDirection(em);
//	if (dir == "") {
//		return;
//	}
//	wIsResizing = true;
//	
//	ResizeObject = new resizeObject();
//	
//	ResizeObject.em = em;
//	ResizeObject.dir = dir;
//	
//	ResizeObject.grabx = window.event.clientX;
//	ResizeObject.graby = window.event.clientY;
//	
//	ResizeObject.width = em.offsetWidth;
//	ResizeObject.height = em.offsetHeight;
//	ResizeObject.left = em.offsetLeft;
//	ResizeObject.top = em.offsetTop;
//	
//	ResizeObject.table = wTable;
//	ResizeObject.tableWidth = wTable.style.pixelWidth;
//	
//	var wArr = wTable.parentNode.parentNode.getAttribute("cellsize").split(";");  ///
//	
//	ResizeObject.cellSizes = new Array(wArr.length);
//	for (var i = 0; i < wArr.length; i++) ResizeObject.cellSizes[i] = parseInt(wArr[i]);
//	
//	ResizeObject.colCount = ResizeObject.cellSizes.length;
//	ResizeObject.headerRows = parseInt(wTable.parentNode.parentNode.getAttribute("headerrows"));
//	
//	var wRowIndex = em.parentNode.rowIndex + em.rowSpan - 1; 
//	
//	ResizeObject.tableRow = wTable.rows[wRowIndex];
//	ResizeObject.rowHeight = wTable.rows[wRowIndex].offsetHeight;
//	
//	return;
//};

//function Sheet_onmouseup(em) {
//	if (ResizeObject != null){
//		ResizeObject.table.parentNode.parentNode.setAttribute("cellsize", ResizeObject.cellSizes.join(";"));
//		
//		for(var i = ResizeObject.cellSizes.length - 1; i >= 0; i--) ResizeObject.cellSizes.pop();
//		ResizeObject.cellSizes = null;
//		ResizeObject.table = null;
//		ResizeObject.tableRow = null;
//		ResizeObject = null;
//		
//		wIsResizing = false;
//		
//		return false;
//	} 
//	
//	if(em == null) {
//		em = (navigator.userAgent.indexOf('Firefox') >= 0 ? event.target : event.srcElement);
//	}
//	
//	if (em.tagName=="TD" && (em.className == "ColHead" || em.className == "lColHead")){
//		    var wSheet = searchSheet(em);
//		    var wResult = wSheet.sortTable(em);
//		    wSheet.setResultOfSort(wResult); 
//		    return false;
//	    
//	} else if (em.tagName=="TD" && em.className == "RowHead"){
//	    var wSheet = searchSheet(em);
//	    var wMoveOverTR = searchRow(em);
//	    
//	    if (wMoveOverTR != null) {
//	        
//	       //클릭한 줄이 삭제된 경우
//	        if (wSheet.clickedTR && wSheet.clickedTR.rowIndex == -1){
//	            wSheet.clickedTR = null;
//	        }
//	
//	        if (wSheet.clickedTR ) 
//	            wSheet.setRowClass(wSheet.clickedTR.rowIndex, wSheet.getOddEvenStyle(wSheet.clickedTR.rowIndex));
//	        wSheet.setRowClass(wMoveOverTR.rowIndex, "SelectedStyle");
//	        
//	        wSheet.clickedTR = wMoveOverTR;
//	        wSheet.lastTRClass="SelectedStyle";
//	        
//	        if (wSheet instanceof ListSheet){
//	        	wSheet.selectRow(em);
//	        } else if (wSheet.controlId.toLowerCase().indexOf("sheet_") >= 0 && wSheet.controlId.toLowerCase().indexOf("listsheet_") < 0){
//	            wSheet.click(em);
//	        }           
//		}
//		
//	    return false;
//	    
//	} else  if(em.tagName == "TD"){
//	
//	    var wSheet = searchSheet(em);
//	    if (wSheet instanceof ListSheet){
//	        var wMoveOverTR = searchRow(em);
//	        if (wMoveOverTR != null) {
//	            if (wSheet.clickedTR) 
//	                wSheet.setRowClass(wSheet.clickedTR.rowIndex, wSheet.getOddEvenStyle(wSheet.clickedTR.rowIndex));
//	            wSheet.setRowClass(wMoveOverTR.rowIndex, "SelectedStyle");
//	            
//	            wSheet.clickedTR = wMoveOverTR;
//	            wSheet.lastTRClass="SelectedStyle";
//	            
//	            wSheet.selectRow(em);
//	    	}
//	    } else if (wSheet instanceof DataSheet){
//	        var wMoveOverTR = searchRow(em);
//	        if (wSheet.clickedTR && wSheet.clickedTR.rowIndex >= 0) 
//	            wSheet.setRowClass(wSheet.clickedTR.rowIndex, wSheet.getOddEvenStyle(wSheet.clickedTR.rowIndex));
//	        
//            wSheet.clickedTR = wMoveOverTR;
//            wSheet.lastTRClass=wSheet.getOddEvenStyle(wMoveOverTR.rowIndex);
//	        wSheet.click(em);
//	
//	    }
//	}
//	
//	return true;
//};

//function Sheet_onmousemove(em) {
//
//	if (em.className == "ColHead" || em.className == "lColHead" || em.className == "RowHead"){
//		
//		if (wIsResizing){
//		    resizeCell(window.event.clientX, window.event.clientY);
//		    return true;
//	    } else {
//		    str = getDirection(em);
//		    if (str == "") {
//		    	em.style.cursor = "";
//		    } else {
//		    	str += "-resize";
//		    	em.style.cursor = str;
//		    }
//		}
//		
//	} 
//	var wMoveOverTR = searchRow(em);
//	
//	if (wMoveOverTR != null) {
//	    var sheetObject = searchSheet(em);
//	    wMoveOverTR = sheetObject.dataTable.tBodies[0].rows[wMoveOverTR.rowIndex];
//	    
//	    if (sheetObject.moveOverTR != wMoveOverTR){
//	        sheetObject.moveOverTR = wMoveOverTR;
//	        sheetObject.lastTRClass = sheetObject.moveOverTR.className;
//	        
//	        sheetObject.setRowClass(wMoveOverTR.rowIndex, "MoveStyle");
//	    }
//	}
//	
//	return true;       
//};
//
//function Sheet_onmouseout(em) {
//
//	var wMoveOverTR = searchRow(em);
//	if (wMoveOverTR != null) {
//	    var wSheet = searchSheet(em);
//	    wSheet.setRowClass(wMoveOverTR.rowIndex, wSheet.lastTRClass);
//	}
//	
//	em.style.cursor = "";
//	
//	return true;
//};

/***************************************************************************
  데이터시트 콘트롤의 공통함수 부분이다
***************************************************************************/
var oldscrollTop = 0;
var oldscrollLeft = 0;
var scrollmode = 0;

/**
 * @description	미결
 * @param		{Object}	em
 * @returns		{Void}
 * @example		미결
 */
function scrollAction(em){
	var wTables = em.parentNode.getElementsByTagName("table");
	
	for(var i=0; i<wTables.length; i++){
		var wTable = wTables[i];
		var wTableName = wTables[i].getAttribute("name");
		
		 if(wTableName == "dataTable") {
			 wTable.style.top = (-1) * em.scrollTop + 'px';
			 wTable.style.left = (-1) * em.scrollLeft + 'px';
		 }
		 else if(wTableName == "colHeadTable") wTable.style.left = (-1) * em.scrollLeft + 'px';
		 else if(wTableName == "leftRowTable") wTable.style.top = (-1) * em.scrollTop + 'px';
		 else if(wTableName == "rightRowTable") wTable.style.top = (-1) * em.scrollTop + 'px';
		 else if(wTableName == "bottomCenterTable") wTable.style.left = (-1) * em.scrollLeft + 'px';
	}
	
	var wSheet = searchSheet(em);
    wSheet._setEditControlPosition();
    wSheet.scrollAction(em.scrollTop, em.scrollLeft);

    return;

};

/**
 * @description	미결
 * @param		{Object}	em
 * @returns		{Void}
 * @example		미결
 */
function crossSheetscrollAction(em){
	var wTables = em.parentNode.getElementsByTagName("table");
	wTables[DATA_TABLE].style.top = (-1) * em.scrollTop + 'px';
	wTables[DATA_TABLE].style.left = (-1) * em.scrollLeft + 'px';
	wTables[COL_TABLE].style.left = (-1) * em.scrollLeft + 'px';
	wTables[ROW_TABLE].style.top = (-1) * em.scrollTop + 'px';
	
    return;

};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function resizeObject() {
	this.dir = ""; 
	this.grabx = null; 
	this.graby = null;
	this.width = null;
	this.height = null;
	this.left = null;
	this.top = null;
	
	this.table = null;
	this.tableWidth = null;
	this.cellSizes = null;
	this.ColCount = 0;
	
	this.tableRow = null;
	this.rowHeight = null;
	
	this.cellIndex = 0;
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function moveObject() {
	this.grabx = null; 
	this.pickColumn = 0;
	this.pickCell = null;
	this.pickTableName = "";
	this.changeColumn = 0;
	this.sheet = null;
	this.emTr = null;
	this.cellSizes = [];
	this.mergeRow = 0;
	this.emTrIndex = 0;
	this.div = null;
	this.browserX = 0;
};

/**
 * @description	미결
 * @param		{Object}	em
 * @returns		{String}
 * @example		미결
 */
function getDirection(em) {
	var xPos, yPos, offset, dir;
	dir = "";
	
	if(navigator.userAgent.indexOf('Firefox') >= 0){
		offset = em.offsetParent;
		var offsetHeight = 0;
		var offsetWidth = 0;

		while (offset) {
			offsetHeight += offset.offsetTop;
			offsetWidth += offset.offsetLeft;
			offset = offset.offsetParent;
		}

		xPos = event.pageX - em.offsetLeft - offsetWidth;
		yPos = event.pageY - em.offsetTop - offsetHeight;		
		
	}else{
		xPos = window.event.offsetX;
		yPos = window.event.offsetY;
		offset = 8;		
	}
	
	if (yPos > em.offsetHeight-offset) dir = "s";
	if (xPos > em.offsetWidth-offset) dir += "e";	
	
	return dir;
};

/**
 * @description	미결
 * @param		{Number}	pClientX
 * @param		{Number}	pClientY
 * @returns		{Undefined}
 * @example		미결
 */
function resizeCell(pClientX, pClientY){
//	var xPos, yPos, str;
//	var xMin = 2; var yMin = 19; 
//	var wWidth = 0;
	var isRight = false;
	wIsResizing = true;
	
	var wTable = ResizeObject.em.parentNode;
	while(wTable.tagName != "TABLE") wTable = wTable.parentNode;
	
	if(wTable.getAttribute("name").match(/right/) != null) isRight = true;
	
	var wControl = controls[wTable.parentNode.parentNode.getAttribute("ctlname")];
	var wHeadSpanInfo = wControl.headSpanInfo;
	
	if (ResizeObject.dir.indexOf("e") != -1) {
		// 위치이동량을 계산한다
	    var wIncrementX = pClientX - ResizeObject.grabx;
		
		// 바뀐 셀번호를 구한다
		var wRow = ResizeObject.em.parentNode;
		var wCellIndex = ResizeObject.em.cellIndex;
		var wChangedColNum = getColNum(wHeadSpanInfo, wRow.rowIndex>1&&wCellIndex==0?0:wRow.rowIndex, wCellIndex);
		if (ResizeObject.cellSizes[wChangedColNum] + wIncrementX < 1) return;

		ResizeTableWidth(wControl, wChangedColNum, wIncrementX, isRight);
	    
		ResizeObject.grabx = pClientX;
		ResizeObject.tableWidth += wIncrementX;
	}
	if (ResizeObject.dir.indexOf("s") != -1){
	    var wIncrementY = pClientY - ResizeObject.graby;
	    wIncrementY = wIncrementY / searchSheet(wTable).rowsPerDataRow;
	    
//		if (ResizeObject.rowHeight + wIncrementY < 19) return;
//		var scrollHeight = wControl.tagObject.getElementsByTagName("DIV")[0].style.height.match(/\d+/)[0] - 19;
		// ResizeObject.tableRow.height = (ResizeObject.rowHeight + wIncrementY)+'px'
		//20110415 변겸함 chrome 적용
	  	ResizeObject.tableRow.setAttribute("height",ResizeObject.rowHeight + wIncrementY); 
		ResizeTableHeight(ResizeObject.table, ResizeObject.tableRow.rowIndex, ResizeObject.rowHeight + wIncrementY);
		
		ResizeObject.graby = pClientY;
		ResizeObject.rowHeight += wIncrementY;
	}
};

/**
 * @description	미결
 * @param		{Object}	control
 * @param		{Number}	colNum
 * @param		{Number}	changeSize
 * @param		{Boolean}	isRight
 * @returns		{Undefined}
 * @example		미결
 */
function ResizeTableWidth(control, colNum, changeSize, isRight) {
	var wHeaderRows = ResizeObject.headerRows;
	var wTables = control.tagObject.getElementsByTagName("table");
	var frozenRight = searchSheet(wTables[0]).frozenColsRight;
	
//	colNum +=  ResizeObject.cellIndex;
	// 표의 사이즈 정보를 바꾸어 준다
    ResizeObject.cellSizes[colNum] += changeSize;
    var repeat = false;
    var repeatWidth = "";

    for (var i = 0; i < wTables.length; i++){
		var wTable = wTables[i];
		var notRight = wTable.getAttribute("name").match(/right/i) == null;
		
		if(!notRight && !isRight) continue;
		if(notRight && isRight) {
			repeat = true;
			continue;
		}
		
		var wTableSizeChanged = false;
		var wWidth = 0;
		for (var wRowNum=0; wRowNum < wHeaderRows; wRowNum++){
		    var wRow = wTable.tBodies[0].rows[wRowNum];
			var wCellIndex = getcellIndex(control.headSpanInfo, wRowNum, colNum);
			if (wCellIndex == -1) continue;  // 이줄에는 해당되는 셀이 없다 
			if (wCellIndex >= wTable.rows[wRowNum].cells.length) continue;  // 로우나 픽스 테이블은 열이 적다
			
		    // Span을 감안하여 셀사이즈를 부여한다.
			var wCell = wRow.cells[wCellIndex];
		    var wColSpan = wCell.colSpan;
		    wWidth = 0;
		    for (var j = 0 ; j < wColSpan; j++) {
		    	var wColNum = colNum + j;
		    	wWidth += ResizeObject.cellSizes[wColNum];
		    	if (j > 0) wWidth++;
		    }
		    wWidth = wWidth + "px";
	
		    wRow.cells[wCellIndex].style.width = wWidth;
		    repeatWidth = wWidth;
		    wTableSizeChanged = true;
		}
		if (wTableSizeChanged){
			wTable.style.width = (wWidth.match(/\d+/)[0]*1) + "px";
		}
	}
    // 우고정이 있을 경우 데이터 테이블 셀 크기를 다시 조정해준다.
    if(repeat){
    	colNum = colNum+frozenRight;
    	for (var i = 0; i < wTables.length; i++){
    		var wTable = wTables[i];
    		var notRight = wTable.getAttribute("name").match(/right/i) == null;
    		
    		if(!notRight) continue;
    		
    		var wTableSizeChanged = false;
    		for (var wRowNum=0; wRowNum < wHeaderRows; wRowNum++){
    			var wRow = wTable.tBodies[0].rows[wRowNum];
    			var wCellIndex = getcellIndex(control.headSpanInfo, wRowNum, colNum);
    			if (wCellIndex == -1) continue;  // 이줄에는 해당되는 셀이 없다 
    			if (wCellIndex >= wTable.rows[wRowNum].cells.length) continue;  // 로우나 픽스 테이블은 열이 적다
    			
    			// Span을 감안하여 셀사이즈를 부여한다.
    			
    			wRow.cells[wCellIndex].style.width = repeatWidth;
    			wTableSizeChanged = true;
    		}
    		if (wTableSizeChanged){
    			wTable.style.width = (repeatWidth.match(/\d+/)[0]*1) + "px";
    		}
    	}
    }
    
    // 스크롤을 위한 사이즈 조정
	control.resetScroll();
};

/**
 * @description	미결
 * @param		{Object}	pTable
 * @param		{Number}	pRowNum
 * @param		{Number}	pSize
 * @returns		{Undefined}
 * @example		미결
 */
function ResizeTableHeight(pTable, pRowNum, pSize) {
	var wTables = pTable.parentNode.getElementsByTagName("table");
	var control = controls[wTables[0].parentNode.parentNode.getAttribute("ctlname")];
	
	var perDataRows = searchSheet(wTables[0]).rowsPerDataRow;
	
	for (var i = 0; i < wTables.length; i++){
		var wTable = wTables[i];
		
		if(/bottom/.test(wTable.getAttribute("name"))) {
			wTable.style.top = control.dataTable.scrollHeight + 1 + "px";
			continue;
		}
//		if (wTable == pTable) continue;
		if (wTable.tBodies[0].rows.length - 1 < pRowNum) continue;
		
		//wTable.tBodies[0].rows[pRowNum].height = pSize;
		for(var j=0; j<perDataRows; j++){
			wTable.tBodies[0].rows[pRowNum - j].setAttribute("height",pSize);
		}
	} 
    
    // 스크롤을 위한 사이즈 조정
	control.resetScroll();
};

/**
 * @description	미결
 * @param		{Number}	pClientX
 * @returns		{Void}
 * @example		미결
 */
// 컬럼 이동 함수
function movingOfSheetColumn(pClientX){
	// 현재 마우스의 가로 위치에 시트의 left 값을 빼서 계산
	MoveObject.div.style.left = (pClientX + MoveObject.grabx) + "px";
	MoveObject.pickCell.className = "MovePickCell";
	
	var wSheet = MoveObject.sheet; // 시트객체
	var scrollPanel = MoveObject.sheet.scrollPanel; // 스크롤 div
	var sheetSize = MoveObject.browserX * (-1); // 바꿔야 할 td태그의 위치 계산용
	var pickTableName = MoveObject.pickTableName; // 현재 td태그의 테이블 Name 값
	
	// 좌측 또는 우측 고정열이 아닐 경우에만 현재 시트의 스크롤 위치를 계산한다.
	if(pickTableName == "colHeadTable"){
		sheetSize += scrollPanel.scrollLeft * (-1);
	}
	// 우측 고정 테이블 일때 스크롤 최대 값을 항상 준다.
	else if(pickTableName == "rightColHeadTable"){
		sheetSize += MoveObject.sheet.scrollPanel.clientWidth - MoveObject.sheet.scrollPanel.scrollWidth;
	}
	
	// 마우스의 이동값과 셀 사이즈로 바뀔 td태그의 index를 찾아낸다.
	var columnLength = MoveObject.cellSizes.length;
	for(var i=0; i<columnLength; i++){
		sheetSize += (MoveObject.cellSizes[i]*1) + 1;
		if(sheetSize >= pClientX){
			MoveObject.changeColumn = i - MoveObject.mergeRow;
			break;
		}
	}
	
	// 0. 이동에 필요한 변수
	var rightColNum = 0; // 우고정열은 논리적인 셀번호와 물리적인 셀번호가 달라 우측고정번호를 계산해 줘야한다.
	var moveTdLeft = pClientX + MoveObject.grabx; // 마우스로 이동하는셀의 left 값
	
	// 우고정열 이동시 rightColNum 을 넣어준다.
	if(pickTableName == "rightColHeadTable"){
		rightColNum = wSheet.frozenColsRight;
		moveTdLeft -= MoveObject.sheet.scrollPanel.getElementsByTagName("div")[0].clientWidth - MoveObject.emTr.clientWidth+14; // 743
	}
	
	var changeColNum = MoveObject.changeColumn - rightColNum; // 셀이동으로 인해 위치가 변경되는 셀의 colNum
	
	// 2. 논리에 맞지않는 상황일때 리턴
	if(moveOldColumn == MoveObject.changeColumn || MoveObject.changeColumn<1 ||
	   pickTableName != "leftColHeadTable" && MoveObject.changeColumn <= wSheet.frozenCols && wSheet.leftRowTable != null ||
	   pickTableName != "rightColHeadTable" && MoveObject.changeColumn >= wSheet.frozenColsRight && wSheet.rightRowTable != null ||
	   pickTableName == "leftColHeadTable" && MoveObject.changeColumn > wSheet.frozenCols ||
	   pickTableName == "rightColHeadTable" && MoveObject.changeColumn < wSheet.frozenColsRight){
		   // 리턴 하기 전에 changeColumn 을 유효한 colNum 으로 바꿔준다.
		   MoveObject.changeColumn = moveOldColumn;
		   return;
	}
	
	// 3. scrollTo 함수 호출 (열단위 만 동작한다.)
	if(pickTableName == "colHeadTable") wSheet.scrollTo(0, changeColNum);
	
	// 5. 마우스가 컬럼 경계선을 이동했는지 판단하기 위한 변수에 새로 이동된 컬럼을 대입
	moveOldColumn = changeColNum;
	
	return;
};

/**
 * @description	미결
 * @returns		{Void}
 * @example		미결
 */
// 컬럼 이동 완료
function movingOfSheetColumnSuccess(){
	var wSheet = MoveObject.sheet;
	var perDataRow = wSheet.rowsPerDataRow;
	var headRow = wSheet.headRows;
	var pickColNum = MoveObject.pickColumn; // 이동시킨 셀의 최초 Physical ColNum
	var changeColNum = MoveObject.changeColumn + MoveObject.mergeRow; // 이동시킨 셀의 바뀐 Physical ColNum
	var wTables = wSheet.tagObject.getElementsByTagName("table");
	var rightColNum = 0;
	var wTr = null;
	var wTableName = "";
	var realRowMerge = 1;
	
	MoveObject.pickCell.className = "ColHead";
	MoveObject.div.parentNode.removeChild(MoveObject.div);
	
	// 1. 셀 사이즈 재조정 및 sheetCol 값 변경
	if(pickColNum != changeColNum && changeColNum>0){
		// 셀 사이즈 재조정
		var headCells =wSheet.colHeadTable.rows[0].cells;
		var headCellLength = headCells.length;
		var cellSize = ""; 
		
		for (var i=0; i<headCellLength; i++){
			cellSize += headCells[i].clientWidth + ";";
		}
		
		wSheet.tagObject.setAttribute("cellsize", cellSize);
	
		// sheetCol 값 변경
		var sheetColumns = wSheet.columns;
		var logical = null;
		var logicalNum = []; 
		var Num=0;
		
		// 변경된 셀들의 LogicalNum을 배열에 저장 후 해당 LogicalNum의 sheetCol을 바꿔준다.
		if(/right/i.test(MoveObject.pickTableName)) realRowMerge = 0;
		for(var j=1; j<=perDataRow; j++){
			var wRow = j+headRow-1;
			// 오른쪽 이동시 LogicalNum 저장 
			for(var i=pickColNum+1; i<=changeColNum; i++){
				logical = wSheet.colNumOf(wRow, (j>1? i-realRowMerge: i), CONV_HARD_LOGICAL);
				logicalNum.push(logical);
				if(i == changeColNum){
					logical = wSheet.colNumOf(wRow, (j>1? pickColNum-realRowMerge: pickColNum), CONV_HARD_LOGICAL);
					logicalNum.push(logical);
				}
			}
			// 왼쪽 이동시 LogicalNum 저장 
			for(var i=changeColNum; i<pickColNum; i++){
				if(i == changeColNum){
					logical = wSheet.colNumOf(wRow, (j>1? pickColNum-realRowMerge: pickColNum), CONV_HARD_LOGICAL);
					logicalNum.push(logical);
				}
				logical = wSheet.colNumOf(wRow, (j>1? i-realRowMerge: i), CONV_HARD_LOGICAL);
				logicalNum.push(logical);
			}
			// 배열에 저장한 LogicalNum 으로 시트컬럼 변경
			for(var sColNum=pickColNum; sColNum<=changeColNum; sColNum++,Num++){
				sheetColumns[logicalNum[Num]].sheetCol = sColNum;
			}
			for(var sColNum=changeColNum; sColNum<=pickColNum; sColNum++,Num++){
				sheetColumns[logicalNum[Num]].sheetCol = sColNum;
			}
		}
		
		logicalNum = null;
	}
	
	// 2. 루핑을 돌며 모든 테이블의 td태그 이동
	for(var i=0; i<wTables.length; i++){
		if(pickColNum == changeColNum || changeColNum<=0) break;
		rightColNum = 0;
		wTableName = wTables[i].getAttribute("name");
		
		if(/right/i.test(wTableName)) rightColNum = wSheet.frozenColsRight;
		
		wTr = wTables[i].getElementsByTagName("tr");
		
		if(wTr[0].cells[pickColNum - rightColNum] == undefined || wTr[0].cells[changeColNum - rightColNum] == undefined) continue;
		
		for(var j=0; j<wTr.length; j++){
			realRowMerge = 0;
			// 두번째 줄부터는 줄번호가 RowSpan된상태이므로 한줄이 없다.
			var wRowNum = (j ) % perDataRow + 1;
			if (wRowNum > 1 && rightColNum < 1) --realRowMerge;
			
			var picIndex = pickColNum - rightColNum + realRowMerge;
			var changeIndex = changeColNum - rightColNum + realRowMerge;
			
			if(changeColNum + realRowMerge > pickColNum + realRowMerge){
				wTr[j].insertBefore(wTr[j].cells[picIndex], wTr[j].cells[changeIndex + 1]);
			}else if(changeColNum + realRowMerge - rightColNum - 1 >= 0){
				wTr[j].insertBefore(wTr[j].cells[picIndex], wTr[j].cells[changeIndex - 1].nextSibling);
			}else{
				wTr[j].insertBefore(wTr[j].cells[picIndex], wTr[j].cells[changeIndex]);
			}
		}
	}
	
	// 4. MoveObject 초기화
	MoveObject = null; 
	
	// 5. 전역 변수 초기화
	wIsColumnMove = false;
	wIsColumnMoving = false;
	moveOldColumn = 0;
	moveScrollLeft = 0;
	
	return;
}

/*********************************************************************
 *   셀틀의 스펜상태를 분해하기위한 객체및 함수   
     <<< 사용방법 >>>
     var wTable = document.getElementsByName("sampleTable")[0];
     var wHeadSpanInfos = getHeadSpanInfo(wTable);

     alert(getColNum(wHeadSpanInfos,4,2));
     alert(getcellIndex(wRows,4,getColNum(wHeadSpanInfos,4,2)));
* ********************************************************************/

/**
 * @description	미결
 * @param		{Number}	rowSpan
 * @param		{Number}	colSpan
 * @param		{Number}	colNum
 * @param		{String}	cellIndex
 * @returns		{Undefined}
 * @example		미결
 */
function cellSpanInfo(rowSpan, colSpan, colNum, cellIndex){
    this.rowSpan = rowSpan;
    this.colSpan = colSpan;
    this.colNum  = colNum;
    this.cellIndex = cellIndex;
};

/**
 * @description	미결
 * @param		{String}	wRows
 * @returns		{Undefined}
 * @example		미결
 */
function fillBlankCell(wRows){
    for (var rowNum=0; rowNum < wRows.length; rowNum++){
        var wCells = wRows[rowNum];
        for (var colNum=0;colNum < wCells.length;colNum++){
            var wCellSpanInfo = wCells[colNum];
            
            if (wCellSpanInfo.colSpan > 1){
                // 같은 줄 뒷셀들의 셀번호를 늘려 끼어들 수 있도록 한다. 
                for(var i = wCellSpanInfo.colNum + 1; i < wCells.length;i++){
                    wCells[i].colNum += (wCellSpanInfo.colSpan - 1);
                }
                // 빈칼럼들을 추가한다 
                for(var i = 1; i < wCellSpanInfo.colSpan;i++){
                   var indertPos = wCellSpanInfo.colNum + i;
                   wCells.splice(indertPos, 0, new cellSpanInfo(wCellSpanInfo.rowSpan, 1, indertPos, wCellSpanInfo.colNum));
                }
            }
            
            if (wCellSpanInfo.rowSpan > 1){
               // 아래줄에 rowSpan-1만큼의 줄에 빈셀을 삽입한다.
               for (var i=1;i < wCellSpanInfo.rowSpan;i++){
                    var belowRowNum = rowNum + i;
                    var belowRowCells = wRows[belowRowNum];
                    
                    if (colNum < belowRowCells.length){
                        // 같은 줄 뒷셀들의 셀번호를 늘려 끼어들 수 있도록 한다. 
                        for(var j = colNum; j < belowRowCells.length;j++){
                            belowRowCells[j].colNum++;
                        }
                        // 한칸을 삽입한다
                        belowRowCells.splice(colNum, 0, new cellSpanInfo(1, 1, colNum, -1, false));
                    
                    } else {
                        belowRowCells[belowRowCells.length] = new cellSpanInfo(1, 1, belowRowCells.length, -1);
                    }
                    
               }
            }
        }
    }

};

/**
 * @description	미결
 * @param		{Object}	table
 * @returns		{String}
 * @example		미결
 */
function getHeadSpanInfo(table) {
    var wRows = [];
    var tableLen = table.rows.length;
    
    // rowspan 정보를 담기위한 배열 default값(0) 을 미리 생성한다.
    var rowSpanArr = []; 
    for(var rnum=0; rnum<tableLen; rnum++){
        var colLength = table.rows[rnum].cells.length;
        rowSpanArr[rnum] = [];
        for(var cnum=0; cnum<colLength; cnum++){
        	rowSpanArr[rnum][cnum] = 0;
        }
    }

    for (var wRowNum=0; wRowNum < tableLen; wRowNum++){
        var wRow = [];
        wRows[wRowNum] = wRow;
        
        var cells = table.rows[wRowNum].cells;
        var cellsLen = cells.length;
        var rowSpan = 0; // rowSpan 값
        var colSpan = 0; // colSpan 값
        var rowSpanCnt = 0; // 누적된 rolSpan
        var colSpanCnt = 0; // 누적된 colSpan
        for (var wColNum=0; wColNum <  cellsLen; wColNum++){
            var wCell =  cells[wColNum];
            colSpan = wCell.colSpan;
            rowSpan = wCell.rowSpan;
            
            for(var i=0; i<colSpan; i++){
            	// 컬럼 번호 생성
            	// colSpan 된만큼 같은 cellIndex 값의 colNum을 넣어주기 위해 누적된 span값과 현재 span값을 더해준다.
            	var colNum = wColNum + i + colSpanCnt;
            	
            	// rowSpan이 되어 있다면 해당 rowSpan이 적용되는 줄에서 사용할수 있게 span 된만큼의 줄에 값1 을 넣어준다.
        		for(var j=1; j<rowSpan; j++){
        			rowSpanArr[wRowNum + j][colNum] = 1;
        		};
        		
        		// 현재줄에 rowSpan 되어 있는 셀이 있는지 체크 후 있다면 rowSpanCnt에 span값 1을 누적
        		rowSpanCnt += rowSpanArr[wRowNum][colNum];
        		
        		// 배열에 정보를 넣어준다.
            	wRow[colNum] = new cellSpanInfo(rowSpan, colSpan, colNum, wColNum - rowSpanCnt);
            }
            
            // colSpan값 누적
            colSpanCnt += (colSpan - 1);
        };
    }
    //fillBlankCell(wRows);
    
    return wRows;
};

/**
 * @description	미결
 * @param		{Number}	wRows
 * @param		{String}	rowIndex
 * @param		{String}	cellIndex
 * @returns		{Number}
 * @example		미결
 */
function getColNum(wRows, rowIndex, cellIndex){
    var wReturn = -1;
    
    for (var i = wRows[rowIndex].length - 1; i >= 0;i--){
        if (wRows[rowIndex][i].cellIndex == cellIndex){
            wReturn = wRows[rowIndex][i].colNum;
            break;
        }
    }
    return wReturn;
};

/**
 * @description	미결
 * @param		{Number}	wRows
 * @param		{String}	rowIndex
 * @param		{Number}	colNum
 * @returns		{String}
 * @example		미결
 */
// 시트콜트롤의 getCellIndex(em) 과는 대소문자 차이 
function getcellIndex(wRows, rowIndex, colNum){
    var wReturn = -1;
    
    for (var i = 0; i < wRows[rowIndex].length;i++){
        if (wRows[rowIndex][i].colNum == colNum){
            wReturn = wRows[rowIndex][i].cellIndex;
            break;
        }
    }
    return wReturn;

};

/**
 * @description	미결
 * @param		{Object}	statement
 * @returns		{Object}
 * @example		미결
 */
function RepalceVariable(statement){
	var wStatement = statement.replace(/\r/g," ").replace(/\n/g," ");
    if (wStatement.indexOf("[" + STRING_PARAM)){
    	for (var key in parameters){ 
			if (typeof(parameters[key])=="function") continue;
    		wStatement = wStatement.replaceWord("[" + STRING_PARAM + key + "]", parameters[key]);
    	}
    }
	
	if (wStatement.indexOf("&crlf;") >= 0) 
		wStatement = wStatement.replaceWord("&crlf;", mCoGu);

	if (wStatement.indexOf("[" + STRING_CONTROL)){
    	for (var key in controls){
			if (typeof(controls[key])=="function") continue;
    		wStatement = wStatement.replaceWord("[" + STRING_CONTROL + key + "]", controls[key]);
    	} 
    }

    if (wStatement.indexOf("[" + STRING_USER)){
    	if (wStatement.indexOf(STRING_USER_COGU) >= 0) 
    		wStatement = wStatement.replaceWord(STRING_USER_COGU, mCoGu);
    	if (wStatement.indexOf(STRING_USER_BON) >= 0) 
    		wStatement = wStatement.replaceWord(STRING_USER_BON, mBon);
    	if (wStatement.indexOf(STRING_USER_DATE) >= 0) 
    		wStatement = wStatement.replaceWord(STRING_USER_DATE, mdate);
    	if (wStatement.indexOf(STRING_USER_PARTCODE) >= 0) 
    		wStatement = wStatement.replaceWord(STRING_USER_PARTCODE, mPartCode);
    	if (wStatement.indexOf(STRING_USER_PARTNAME) >= 0) 
    		wStatement = wStatement.replaceWord(STRING_USER_PARTNAME, mPartName);
    	if (wStatement.indexOf(STRING_USER_ORGACODE) >= 0) 
    		wStatement = wStatement.replaceWord(STRING_USER_ORGACODE, mOrgaCode);
    	if (wStatement.indexOf(STRING_USER_ORGANAME) >= 0) 
    		wStatement = wStatement.replaceWord(STRING_USER_ORGANAME, mOrgaName);
    	if (wStatement.indexOf(STRING_USER_SEQ) >= 0) 
    		wStatement = wStatement.replaceWord(STRING_USER_SEQ, mSeq);
    	if (wStatement.indexOf(STRING_USER_PERSONALID) >= 0) 
    		wStatement = wStatement.replaceWord(STRING_USER_PERSONALID, mPersonalId);
    	if (wStatement.indexOf(STRING_USER_PERSONALNAME) >= 0) 
    		wStatement = wStatement.replaceWord(STRING_USER_PERSONALNAME, mPeraonalName);
    }
    
    return wStatement;
};

/**
 * @description	미결
 * @param		{Object}	formula
 * @returns		{Undefined}
 * @example		미결
 */
// 다른 프레임으로 분산된 산식기 호출
function calc(formula){
	var frame = document.getElementsByName("calcPage")[0];
	if (frame != undefined && frame.contentWindow.calc){
	    return frame.contentWindow.calc(formula);
	} else {
		return wLogic.ExecuteLogic(formula);
	}
};

/**
 * @description	미결
 * @param		{Object}	formula
 * @param		{Object}	format
 * @returns		{Undefined}
 * @example		미결
 */
function calcFormatByNum(formula, format){
	var frame = document.getElementsByName("calcPage")[0];
	
	if (frame != undefined && frame.contentWindow.calc){
	    return frame.contentWindow.numberFormat(formula, format);
	} else {
		return numberFormat(formula, format);
	}
};


/* **********************************************************************
 *   가저오기 작업 순차적인 수행을 위해 컨트롤러
 *   지정한 순서대로 가저온다  
 *   Setting 과정에서 발생한 가저오기는 연시 대기작업에 넣어 계속적으로 가저오도록 한다 
 *   Setting 과정에서 발생한 콘트롤 채우기 동작은 대기열에 넣었다가 "fillControl" 문자열을 만나면 일괄수행
 * **********************************************************************/

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function JobControler(){
	this.jobNameList = [];
	this.callerNameList = [];
	this.pageNumList = [];
	this.calledNameList = [];
	this.controlNameToFocus = "";
	this.isWaiting = false;
	this.loadType = 0;
	this.busy = false;
	this.loadType = 0;   // 1: 객체로드  2: 가저오기만으로 구성
};

var jobControler = new JobControler();

// 가저오기 작업목록을 추가한다.  (예:자가소비내역가져오기;소비내역합계가져오기;clear;)
/**
 * @description 미결
 * @param		{string}	jobListString
 * @param		{string}	callerControlName
 * @param		{number}	pageNum
 * @return		{void}
 * @example		미결
 */
JobControler.prototype.reserveJobs = function(jobListString, callerControlName, pageNum){
    // functionname : [JobControler.reserveJobs]
	
	if (pageNum == undefined) pageNum = 0;
	
	var jobNameList = (jobListString || "").split(";");
	if (jobNameList[jobNameList.length-1].length == 0) {
		jobNameList.pop();
	}

	var controlName = callerControlName || "";
	var callerNameList = new Array(jobNameList.length);
	for (var i=0; i < callerNameList.length; i++) {
		callerNameList[i] = controlName;
	}
	
	var pageNumList = new Array(jobNameList.length);
	for (var i=0; i < pageNumList.length; i++) {
		pageNumList[i] = pageNum;
	}
	
	
	// 예약작업이 없을 경우 첫번데이터를 채워 삭제하고 진행할 수 있도록 한다.
	if (this.jobNameList.length == 0){
		this.jobNameList = [null];
		this.callerNameList = [null];
		this.pageNumList = [null];
	}
	

	this.jobNameList = this.jobNameList.concat(jobNameList);
	this.callerNameList = this.callerNameList.concat(callerNameList);
	this.pageNumList = this.pageNumList.concat(pageNumList);
	
	return;
};

/**
 * @description 미결
 * @return		{string}
 * @example		미결
 */
JobControler.prototype.hasJob = function(){
	// functionname : [JobControler.hasJob]

	// this.jobNameList.length는 기본적으로 1이다
	return this.jobNameList.length > 0;

};

//채우기 작업목록을 추가한다.  
/**
 * @description 미결
 * @param		{string}	controlId
 * @return		{void}
 * @example		미결
 */
JobControler.prototype.reserveFiller = function(controlId){
	// functionname : [JobControler.reserveFiller]

	this.reserveJobs("fillControl:" + controlId, "");

return;
};

/**
 * @description 미결
 * @return		{void}
 * @example		미결
 */
JobControler.prototype.notifyComplete = function(){
	// functionname : [JobControler.notifyComplete]
	                   
	this.jobNameList.splice(0, 1);
	this.callerNameList.splice(0, 1);
	this.pageNumList.splice(0, 1);
	this.calledNameList.splice(0, 1);
	
   	if (this.jobNameList.length == 0){
   		this.busy = false;

		// hideAjaxBox();
	} else {
		this.executeNext();
	}
	return;
};

/**
 * @description 미결
 * @return		{void}
 * @example		미결
 */
JobControler.prototype.cancel = function(){
	// functionname : [JobControler.cancel]
  this.jobNameList.clear();
	this.callerNameList.clear();
	this.pageNumList.clear();
	this.calledNameList.clear();
	this.controlNameToFocus = "";
	
	this.busy = false;
	// hideAjaxBox();
	return;
};

/**
 * @description 미결
 * @param		{string}	jobListString
 * @param		{string}	callerControlName
 * @param		{number}	pageNum
 * @return		{void}
 * @example		미결
 */
JobControler.prototype.open = function(jobListString, callerControlName, pageNum){
    // functionname : [JobControler.open]
	
	this.busy = true;
    
    // 화면의 데이터 로드타입 파악
    this.checkLoadType();
    // 진행중 메시지를 보여준다
    //showAjaxBox(jobListString + " 조회 중입니다.", 0);

    
	if (pageNum == undefined) pageNum = 0;
	var canExecute = (this.jobNameList.length == 0);
	
	var controlName = callerControlName || "";
	var jobNameList = (jobListString || "").split(";");
	

	if (jobNameList[jobNameList.length-1].length == 0) {
		jobNameList.pop();

	}
	
	var callerNameList = new Array(jobNameList.length);
	var pageNumList = new Array(jobNameList.length);

	for (var i=0; i < jobNameList.length; i++) {
		callerNameList[i] = controlName;
		pageNumList[i] = pageNum;
	}
	

	this.jobNameList = this.jobNameList.concat(jobNameList);
	this.callerNameList = this.callerNameList.concat(callerNameList);
	this.pageNumList = this.pageNumList.concat(pageNumList);
	
	if (!this.isWaiting && canExecute)	{
		this.execute();
	}
	return;
};

/**
 * @description 미결
 * @param		{string}	jobListString
 * @param		{string}	callerControlName
 * @param		{number}	pageNum
 * @return		{undefined}
 * @example		미결
 */
JobControler.prototype.isCurrentJob = function(jobListString, callerControlName, pageNum){
	if (this.jobNameList.length == 0) return false;
	return (this.jobNameList[0] == jobListString && this.callerNameList[0] == callerControlName && this.pageNumList[0] == pageNum);
};

/**
 * @description 미결
 * @param		{string}	controlId
 * @return		{void}
 * @example		미결
 */
JobControler.prototype.fillControl = function(controlId){
	// functionname : [JobControler.fillControl]
	                   
	this.open("fillControl:" + controlId, "");

return;
};

/**
 * @description 미결
 * @return		{undefined}
 * @example		미결
 */
JobControler.prototype.execute = function(){
    // functionname : [JobControler.execute]

	this.executeNext();
};

/**
 * @description 미결
 * @return		{undefined}
 * @example		미결
 */
JobControler.prototype.executeNext = function(){
    // functionname : [JobControler.executeNext]

    // 객체채우기 중이면 대기
    if (this.isWaiting) return;

    if (this.jobNameList.length == 0) return;
    
    // calledNameList를 둔 이유는 release시 재 호출을 막기위해
    var index = 0;
    if (this.calledNameList.length > 0){
    	var nextJobFound = false;
    	for (var i = 0; i < this.jobNameList.length;i++){
    		index = i;
    		if (this.calledNameList.indexOf(this.jobNameList[i]) < 0){
    			nextJobFound = true;
    			break;
    		}
    	}
    	if (!nextJobFound) return;
    }
	
	var jobName = this.jobNameList[index];
	var callerName = this.callerNameList[index];
	var pageNum = this.pageNumList[index];
	
	this.calledNameList[this.calledNameList.length] = jobName;
	
	if (jobName.startsWith("fillControl:")){
		var controlName = jobName.substring(12);
		//eval("fillList_" + controlName + "()");
		if (typeof self["fillList_" + controlName] != "undefined"){
			self["fillList_" + controlName]();
		}
	} else if (pageNum != 0) {
		//eval("fillJob_" + jobName + "(\"" + callerName + "\"," + pageNum + ")");
		if (typeof self["fillJob_" + jobName] != "undefined"){
			self["fillJob_" + jobName](callerName, pageNum);
		}
	} else {
		//eval("fillJob_" + jobName + "(\"" + callerName + "\")");
		if (typeof self["fillJob_" + jobName] != "undefined"){
			self["fillJob_" + jobName](callerName);
		}
	}

};

// 객체 로드 작업중 가저오기 방지용
/**
 * @description 미결
 * @return		{undefined}
 * @example		미결
 */
JobControler.prototype.wait = function(){
    // functionname : [JobControler.wait]
	
	this.isWaiting = true;	
};

//객체 로드 작업중 가저오기 재개용
JobControler.prototype.release = function(){
    // functionname : [JobControler.release]

	this.isWaiting = false;	
	if (this.jobNameList.length == 0){
		this.busy = false;
		//hideAjaxBox();
	} else {
		this.executeNext();
	}
};

/**
 * @description 미결
 * @param		{string}	jobListString
 * @return		{void}
 * @example		미결
 */
JobControler.prototype.close = function(jobListString){
    // functionname : [JobControler.close]

    var index = this.jobNameList.indexOf(jobListString);

	this.jobNameList.splice(index, 1);
	this.callerNameList.splice(index, 1);
	this.pageNumList.splice(index, 1);
	
    index = this.calledNameList.indexOf(jobListString);
	this.calledNameList.splice(index, 1);
	
	// 모든작업이 끝난 것이 확인되면 포커스를 주고 빠진다
	if (this.jobNameList.length == 0){
		if (this.controlNameToFocus.length > 0 && controls[this.controlNameToFocus].focus) controls[this.controlNameToFocus].focus();
		this.controlNameToFocus = "";
		this.busy = false;

		//hideAjaxBox();
	} else {
		this.executeNext();
	}
	return;
};

/**
 * @description 미결
 * @return		{void}
 * @example		미결
 */
JobControler.prototype.checkLoadType = function(){
    // functionname : [JobControler.close]
    if (this.loadType != 0) return;
	for (var id in controls) {
		var control = controls[id];
		if (typeof(control)=="function") continue;
		if (control.isKeyControl){
			this.loadType = 1;
			return;
		}
	}
    
	this.loadType = 2;
	return;
};
/* **********************************************************************
*   확인 단추등에 따른 화면 클리어 
* **********************************************************************/
/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function clearScreen(){
	location.reload(true);
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function clearSeqScreen(){
    // 콘트롤 값들을 지운다 
	for (var id in controls) {
		if (typeof(controls[id])=="function") continue;
		var wControl = controls[id];
		if (wControl.isSeqClearControl){
			if (wControl instanceof TextBox) wControl.setValue("");
			if (wControl instanceof ComboBox || wControl instanceof ListBox) wControl.setValueToDefault();
			if (wControl instanceof CheckBox) wControl.setValue(0);
			if (wControl instanceof OptionButton) wControl.setValue(0);
			if (wControl.controlId.toLowerCase().indexOf("sheet_") >= 0) {
				wControl.clear();
				wControl.setMaxRows(1);
				wControl.moveTo(1,1);
			}
		}
		if ((wControl instanceof ComboBox || wControl instanceof ListBox) && wControl.callerControlName != "form"){
			wControl.clear();
		}
	}
	
	// 디폴트값 처리
	for (var id in controls) {
		if (typeof(controls[id])=="function") continue;
		var wControl = controls[id];
		if (wControl.isSeqClearControl && wControl.defaultValue.length == 0){
			var value = eval(wControl.defaultValue);
			if (wControl instanceof TextBox) wControl.setValue(value);
			if (wControl instanceof ComboBox || wControl instanceof ListBox) wControl.setValue(value);
			if (wControl instanceof CheckBox)  wControl.setValue(value);
			if (wControl instanceof OptionButton) wControl.setValue(value);
		}
	}
	// 객체 디폴트값처리
	var properties = null;
	for (var id in objects) {
		if (typeof(objects[id])=="function") continue;
		properties = objects[id].recordset[wObject.seq].properties;
		var propertyInfos = objects[id].propertyInfos;
		for (var i=1; i < propertyInfos.length; i++){
			var value = eval(propertyInfos[i].defaultValue);
			var id = propertyInfos[i].id;
			properties[id].value = value;
		}
	}
	
	// Seq추가시 지우지 않는 기존 콘트롤값 승계
	for (var id in objects) {
		if (typeof(objects[id])=="function") continue;
		var propertyInfos = objects[id].propertyInfos;
		for (var i=1; i < propertyInfos.length; i++){
			var propertyInfo = propertyInfos[i];
			for (var j=0; j < propertyInfo.linkControlNames.length; j++){
				var control = controls[propertyInfo.linkControlNames[j]];
				if (!control.isSeqClearControl && (wControl.controlId.toLowerCase().indexOf("sheet_") >= 0)){
					properties[id].value = control.value;
				}
			}
		}
	}
};


/* *****************************************************************************
 *     DEBUG SECTION
 * *****************************************************************************/
    var debugTime = null;
    /**
     * @description	미결
     * @param		{String}	msg
     * @returns		{Undefined}
     * @example		미결
     */
    function checkTime(msg){
    	
    	var checkTime = new Date().getTime();      //시작시간 체크(단위 ms)
    	if (debugTime != null){
        	var nDiff = checkTime - debugTime;      //두 시간차 계산(단위 ms)
    		console.log(getText("message_flexformscripthead_001", "{0}\n execution time: {1}ms", [msg, nDiff]));
    	}
    	debugTime = checkTime;
    };

    /**
     * @description	미결
     * @returns		{Undefined}
     * @example		미결
     */
	function Debugger(){
		this.debugLayer = null;
		this.xPos = "800px";
		this.enable = false;

	};
	
	/**
	 * @description 미결
	 * @return		{undefined}
	 * @example		미결
	 */
	Debugger.prototype.setLayer = function() {
        // functionname : [Debugger.setLayer]

		if (!this.enable) return;
		if (this.debugLayer == null){
			if (document.getElementsByName("DebugLayer") && document.getElementsByName("DebugLayer").length > 0){
				this.debugLayer = document.getElementsByName("DebugLayer")[0];
				this.debugLayer.style.left = this.xPos;
			} else {
				return;
			}
		}
		if (this.debugLayer){
			this.debugLayer.style.display = "block";
		}
	};
	
	/**
	 * @description 미결
	 * @return		{undefined}
	 * @example		미결
	 */
	Debugger.prototype.print = function() {
        // functionname : [Debugger.print]

		if (!this.enable) return;

		this.setLayer();
		
		if (this.debugLayer == null) return;
	    var msg = "";
	    for (var i = 0; i < arguments.length;i++) msg += arguments[i] + ",&nbsp;";
	    this.debugLayer.innerHTML = this.debugLayer.innerHTML + "<BR/>" + msg;
	};

	/**
	 * @description 미결
	 * @return		{undefined}
	 * @example		미결
	 */
	Debugger.prototype.clear = function() {
        // functionname : [Debugger.clear]

		if (!this.enable) return;

		if (this.debugLayer == null) return;
		this.debugLayer.innerHTML = "";
    	this.hide();
	};

	/**
	 * @description 미결
	 * @return		{undefined}
	 * @example		미결
	 */
	Debugger.prototype.hide = function() {
        // functionname : [Debugger.hide]

		if (!this.enable) return;

		if (this.debugLayer == null) return;
		this.debugLayer.style.left = "-10000px";
		this.debugLayer.style.display = "none";
	};

	/**
	 * @description 미결
	 * @return		{void}
	 * @example		미결
	 */
	Debugger.prototype.copy = function() {
        // functionname : [Debugger.copy]

		if (arguments.length == 0) return;
	    var wString = "" + arguments[0];
	    
	    if (window.clipboardData) // IE 
	    { 
	        // var txt = window.clipboardData.getData('Text');         
	        var result = window.clipboardData.setData('Text', wString); 
	    } 
	    return;
	};

	/**
	 * @description 미결
	 * @return		{String}
	 * @example		미결
	 */
	Debugger.prototype.getStackTrace = function() {
        // functionname : [Debugger.getStackTrace]

		var callstack = [];
		  var isCallstackPopulated = false;
		  try {
		    i.dont.exist+=0; //doesn't exist- that's the point
		  } catch(e) {
		    if (e.stack) { //Firefox, Chrome
		    	if (BrowserDetect.browser == "Chrome"){
		    	  var cutStart = 0;
		  	      var lines = e.stack.split('\n');
			      for (var i=0, len=lines.length; i<len; i++) {
			        if (lines[i].match(/^\s*[A-Za-z0-9\-._\s\$]+\(/)) {
			        	if (lines[i].indexOf("printStackTrace") > 0){
			        		cutStart = lines[i].indexOf("printStackTrace");
			        	}
			        	
			            callstack.push(lines[i].substring(cutStart, lines[i].indexOf("(")).trim());
			        }
			      }

			      //Remove call to printStackTrace()
			      callstack.shift();
			      isCallstackPopulated = true;
			      
		    	} else { //Firefox
		  	      var lines = e.stack.split('\n');
			      for (var i=0, len=lines.length; i<len; i++) {
			        if (lines[i].match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
			          callstack.push(lines[i]);
			        }
			      }
			      

			      //Remove call to printStackTrace()
			      callstack.shift();
			      isCallstackPopulated = true;
		    	}
		    }
		    else if (window.opera && e.message) { //Opera
		      var lines = e.message.split('\n');
		      for (var i=0, len=lines.length; i<len; i++) {
		        if (lines[i].match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
		          var entry = lines[i];
		          //Append next line also since it has the file info
		          if (lines[i+1]) {
		            entry += " at " + lines[i+1];
		            i++;
		          }
		          callstack.push(entry);
		        }
		      }
		      //Remove call to printStackTrace()
		      callstack.shift();
		      isCallstackPopulated = true;
		    }
		  }
		  if (!isCallstackPopulated) { //IE and Safari

		    var currentFunction = arguments.callee.caller;
		    while (currentFunction) {
		      var fn = currentFunction.toString();
		      var fname = fn.substring(fn.indexOf("function") + 8, fn.indexOf('(')).trim(); // || 'anonymous';
		      var index = fn.indexOf("functionname : [");
		      if (fname.length == 0 && index > 0){
		    	  fname = fn.substring(index + 16, fn.indexOf("]"));
		      }
		      
		      fname = fname || 'anonymous';
		      
		      if (callstack.indexOf(fname) >= 0) break;
		      
		      callstack.push(fname);
		      
		      currentFunction = currentFunction.caller;
		    }
		  }
		  
		  
		  for(var i = 0; i < callstack.length;i++){
			  if (callstack[i].startsWith("Debugger.")){
				  callstack.shift();
			  }
		  }
		  return callstack;
	};
	
	/**
	 * @description 미결
	 * @return		{void}
	 * @example		미결
	 */
	Debugger.prototype.printStackTrace = function() {
        // functionname : [Debugger.printStackTrace]

		if (!this.enable) return;
		
		var callstack = this.getStackTrace();
		if (callstack.length > 0){
		    this.print(callstack.reverse().join('<br/>'));
		}
		
		return;
	};

	/**
	 * @description 미결
	 * @param		{string}	functionName
	 * @return		{boolean}
	 * @example		미결
	 */
	Debugger.prototype.isCallerFunction = function(functionName) {
        // functionname : [Debugger.isCallerFunction]

		var wReturn = false;
		
		var callstack = this.getStackTrace();
		for (var i = 0; i < callstack.length; i++){
			if (callstack[i].trim() == functionName){
				wReturn = true; break;
			}
		}
		
		return wReturn;
	};

	var debug = new Debugger();


	/* *****************************************************************************
	*  MAKE FILE UPLOAD AGENT
	   arguments : parentNode: iframe's parentName name:iframe's name
	               linkname: textbox controlName for filename
	               picname : picture controls name for preeview
	               ftpDir  : ftp upload directory under gw root dir 
	* *****************************************************************************/
	/**
	 * @description	미결
	 * @param		{Object}	parentNode
	 * @param		{String}	name
	 * @param		{String}	linkname
	 * @param		{String}	picname
	 * @param		{Object}	ftpDir
	 * @param		{Boolean}	noftp
	 * @param		{Boolean}	nozip
	 * @param		{Object}	directUploadGu
	 * @returns		{Undefined}
	 * @example		미결
	 */
	function IFrame_Upload(parentNode, name, linkname, picname, ftpDir, noftp, nozip, directUploadGu) {
		this.noftp = (noftp == undefined ? false : noftp);
		this.nozip = (nozip == undefined ? false : nozip);
		
	    if(parentNode == null){
	        parentNode = document.body;  
	        try {
	    	    parentNode.removeChild(document.getElementsByName(name)[0]);
	        } catch (e){}
	    } else {
	        if (document.getElementsByName(name).length != 0){
	        	removeTag(document.getElementsByName(name)[0]);
	        }
	    }

//	    var iframe = document.createElement("iframe");  
//	    iframe.name = iframe.id   = name;
//	    iframe.linkname=linkname;
//	    iframe.picname=picname;
//	    iframe.directuploadgu = directUploadGu;
//	    parentNode.appendChild(iframe);  
	    parentNode.innerHTML = "<iframe name='" + name + "' id='" + name + "' src='about:blank'></iframe>";
	    var iframe = parentNode.childNodes[0];
	    iframe.setAttribute("linkname", linkname);
	    iframe.setAttribute("picname",  picname);
	    iframe.setAttribute("directUploadGu", directUploadGu); 

	    iframe.doc = null;  

	    if(iframe.contentDocument)                // Firefox, Opera  
	       iframe.doc = iframe.contentDocument;  

	    else if(iframe.contentWindow)             // Internet Explorer  
	       iframe.doc = iframe.contentWindow.document;  

	    else if(iframe.document)                  // Others?  
	       iframe.doc = iframe.document;  

	    if(iframe.doc == null)  
	       throw "Document not found, append the parent element to the DOM before creating the IFrame";  

	    iframe.doc.open();  
	    iframe.doc.close();  
	    
//	    var frm = iframe.doc.createElement("<form method='post' name='frmupload"+name+"' action='fileUpload.do?id="+name+"' enctype='multipart/form-data'>");  
	    var frm = iframe.doc.createElement("form");
	    frm.method = "post";
	    frm.name = "frmupload"+name;
	    frm.action = "fileUpload.do?id="+name;
	    frm.enctype = "multipart/form-data";
//	    iframe.doc.body.appendChild(frm);  
	    parentNode.appendChild(frm);  
	    /*frm.method ="POST" ;
	     frm.enctype="multipart/form-data";
	   frm.name   = frm.id ="frmupload" ;
	    frm.action ="fileUpload2.action" ; */ // fileUpload2.action은 압축하지 않고 올리기 fileUpload2.action는 압축하여 올리기
	    this.frm = frm;
	     
	    var inputctltemp = iframe.doc.createElement("input");
	    inputctltemp.type = "file";  
	    inputctltemp.name = inputctltemp.id  ="upload" ;
	    
	    var inputctl = iframe.doc.createElement("input");
	    inputctl.type = "file";  
	    inputctl.name = inputctl.id  ="upload" ;
	    inputctl.linkname=linkname;
	    inputctl.picname=picname;	    
	    inputctl.directuploadgu = directUploadGu;
	    
	    frm.appendChild(inputctl);
	    this.inputctl = inputctl;

	    var dirctl = iframe.doc.createElement("input");
	    dirctl.type = "hidden";  
	    dirctl.name="uploadSubDir" ;
	    dirctl.id  ="uploadSubDir" ;
	    dirctl.value = ftpDir;
	     
	    frm.appendChild(dirctl);
	    
	    var filenamectl = iframe.doc.createElement("input");
	    filenamectl.type = "hidden";  
	    filenamectl.name="uploadFileName" ;
	    filenamectl.id  ="uploadFileName" ;
	    filenamectl.value = "";
	     
	    frm.appendChild(filenamectl);
	    
	    var uploadPrefixctl = iframe.doc.createElement("input");
	    uploadPrefixctl.type = "hidden";  
	    uploadPrefixctl.name="uploadPrefix" ;
	    uploadPrefixctl.id  ="uploadPrefix" ;
	    uploadPrefixctl.value = "";
	     
	    frm.appendChild(uploadPrefixctl);
	    
	    var noftpctl = iframe.doc.createElement("input");
	    noftpctl.type = "hidden";  
	    noftpctl.name="noftp" ;
	    noftpctl.id  ="noftp" ;
	    noftpctl.value = this.noftp;
	     
	    frm.appendChild(noftpctl);
	    
	    var nozipctl = iframe.doc.createElement("input");
	    nozipctl.type = "hidden";  
	    nozipctl.name="nozip" ;
	    nozipctl.id  ="nozip" ;
	    nozipctl.value = this.nozip;
	     
	    frm.appendChild(nozipctl);
	    
	    iframe.onload = function(){
	    	// functionname : [IFrame_Upload.onload]

	        if (this.picname.length != 0){
	        	var picDir = parent.getControlById(this.linkname).value;
		        //var picDir = parent.document.getElementById(this.linkname).value;
	            parent.controls[this.picname].setPicture("file:///" + picDir);
	        }
	        removeTag(document.getElementsByName(this.name)[0]);
	    };
	    iframe.onreadystatechange = function(){
	    	// functionname : [IFrame_Upload.onreadystatechange]

		    if (this.readyState == 'complete') {
		        if (this.picname.length != 0){
		        	var picDir = parent.getControlById(this.linkname).tag;
		            //var picDir = parent.document.getElementById(this.linkname).tag;
		            parent.controls[this.picname].setPicture("file:///" + picDir);
		        }
		        removeTag(document.getElementsByName(this.name)[0]);
		    }
		};
	    
	    inputctl.onchange = function(){
	    	// functionname : [IFrame_Upload.onchange]

	        var filePath = this.value;
			if (this.value.indexOf("\\fakepath\\") >= 0) {
				this.select();
				if (document.selection)
					filePath = document.selection.createRange().text.toString();
				else 
					filePath = this.files[0].name;
				this.blur();
		    }
	    
	        var fileName = "";
	        if (filePath.indexOf("\\") > 0) {
	            fileName = filePath.split("\\")[filePath.split("\\").length -1];
	        }
	        
//	        var fileTag = timeEncodeString();
//	        this.document.getElementsByName("uploadFileName")[0].value = fileName;
	        
	        //parent.getControlById(this.linkname).setValue(fileName);
	        //parent.getControlById(this.linkname).tag = filePath;
	        controls[this.linkname].setValue(filePath);
	        //parent.document.getElementById(this.linkname).tag = filePath;
	        
	        if (this.picname.length != 0){
	        	
	        	
	            parent.controls[this.picname].setPicture("file:///" + filePath);
	        }
	        
	        if (this.directuploadgu == true){
	        	if (jUploadPrefix.length == 0) {
	         		jUploadPrefix = timeEncodeString();
	        	}
	        	this.parentNode.uploadPrefix.value = jUploadPrefix;
		        this.parentNode.submit();
	        }
		};
	    
	    this.selectFile = function(){
	    	// functionname : [IFrame_Upload.selectFile]
	    	
	    	this.inputctl.click();
	    };
	    
	    this.uploadFile = function(){
	    	// functionname : [IFrame_Upload.uploadFile]
	        this.frm.uploadPrefix.value = jUploadPrefix;

	    	this.frm.submit();
	    };
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
/* *****************************************************************************
*  INFORMATION OBJECT FOR GENERATING EXCEL    
* *****************************************************************************/
function xlGenerationInfo(){
	this.colsNum = 0;
	this.rowsNum = 0;
	this.rowsColors = "";
	this.colsWidth = "";
	this.data = "";
	
	this.fixRows = 0;
	this.fixCols = 0;
	this.decimal = "";
	this.sheetType = 0;		/* 0: EasySheet, 1: CrossSheet */
	this.align = "";		/* SHEET_ALIGN_LEFT:0, SHEET_ALIGN_RIGHT:1, SHEET_ALIGN_CENTER:2 */
	this.format = "";
};

/* *****************************************************************************
*  MAKE EXCEL FILE AGENT(name:iframe's name, func:click time callBack function  
* *****************************************************************************/
/**
 * @description	미결
 * @param		{Object}	parentNode
 * @param		{String}	name
 * @param		{Object}	generationInfo
 * @param		{String}	templateXLSFileName
 * @param		{String}	paramsJXLS
 * @returns		{Undefined}
 * @example		미결
 */
function IFrame_Excel(parentNode, name, generationInfo, templateXLSFileName, paramsJXLS, downFileName) {  
    if(parentNode == null){
        parentNode = document.body;  
        try {
    	    parentNode.removeChild(document.getElementsByName(name)[0]);
        } catch (e){}
    } else {
        if (document.getElementsByName(name).length != 0){
        	removeTag(document.getElementsByName(name)[0]);
        }
    }

    var iframe = document.createElement("iframe");  
    iframe.name = iframe.id   = name;
    parentNode.appendChild(iframe);  

    iframe.doc = null;  

    if(iframe.contentDocument) iframe.doc = iframe.contentDocument;           // Firefox, Opera  
    else if(iframe.contentWindow) iframe.doc = iframe.contentWindow.document; // Internet Explorer  
    else if(iframe.document) iframe.doc = iframe.document;                    // Others?  
    if(iframe.doc == null)  
       throw "Document not found, append the parent element to the DOM before creating the IFrame";  

    iframe.doc.open();  
    iframe.doc.close();  
    
    var frm = iframe.doc.createElement("form");  
    iframe.doc.body.appendChild(frm);  
    frm.method ="POST" ;
    frm.name   = frm.id ="frmExcel" ;
    frm.action ="excelDownload.do" ;
    // frm.enctype="multipart/form-data";
    frm.enctype="application/x-www-form-urlencoded";
    this.frm = frm;
    
    var wControl = iframe.doc.createElement("input");
    wControl.type = "hidden";  
    wControl.id   = wControl.name = "lang" ;
    wControl.value = USER_LANGUAGE;
    frm.appendChild(wControl);

    var wControl = iframe.doc.createElement("input");
    wControl.type = "hidden";  
    wControl.id   = wControl.name = "colsNum" ;
    wControl.value = generationInfo.colsNum;
    frm.appendChild(wControl);
    
    wControl = iframe.doc.createElement("input");
    wControl.type = "hidden";  
    wControl.id   = wControl.name = "rowsNum" ;
    wControl.value = generationInfo.rowsNum;
    frm.appendChild(wControl);
    
    wControl = iframe.doc.createElement("input");
    wControl.type = "hidden";  
    wControl.id   = wControl.name = "rowsColors" ;
    wControl.value = generationInfo.rowsColors;
    frm.appendChild(wControl);
    
    wControl = iframe.doc.createElement("input");
    wControl.type = "hidden";  
    wControl.id   = wControl.name = "colsWidth" ;
    wControl.value = generationInfo.colsWidth;
    frm.appendChild(wControl);
    
    wControl = iframe.doc.createElement("input");
    wControl.type = "hidden";  
    wControl.id   = wControl.name = "data" ;
    wControl.value = generationInfo.data;
    frm.appendChild(wControl);
     
    wControl = iframe.doc.createElement("input");
    wControl.type = "hidden";  
    wControl.id   = wControl.name = "templateXLSFileName" ;
    wControl.value = templateXLSFileName;
    frm.appendChild(wControl);
     
    wControl = iframe.doc.createElement("input");
    wControl.type = "hidden";  
    wControl.id   = wControl.name = "paramsJXLS" ;
    wControl.value = paramsJXLS;
    frm.appendChild(wControl);
    
    wControl = iframe.doc.createElement("input");
    wControl.type = "hidden";  
    wControl.id   = wControl.name = "decimal" ;
    wControl.value = generationInfo.decimal;
    frm.appendChild(wControl);
    
    wControl = iframe.doc.createElement("input");
    wControl.type = "hidden";  
    wControl.id   = wControl.name = "sheetType" ;
    wControl.value = generationInfo.sheetType;
    frm.appendChild(wControl);
    
    wControl = iframe.doc.createElement("input");
    wControl.type = "hidden";  
    wControl.id   = wControl.name = "formName" ;
    wControl.value = downFileName;
    frm.appendChild(wControl);
    
    wControl = iframe.doc.createElement("input");
    wControl.type = "hidden";  
    wControl.id   = wControl.name = "align" ;
    wControl.value = generationInfo.align;
    frm.appendChild(wControl);
    
    wControl = iframe.doc.createElement("input");
    wControl.type = "hidden";  
    wControl.id   = wControl.name = "format" ;
    wControl.value = generationInfo.format;
    frm.appendChild(wControl);
    
    wControl = iframe.doc.createElement("input");
    wControl.type = "hidden";  
    wControl.id   = wControl.name = "rowsLevels" ;
    wControl.value = generationInfo.rowsLevels;
    frm.appendChild(wControl);
    
   iframe.onload = function(){
    	// functionname : [IFrame_Excel.uploadFile]
	   
	   setTimeout(function (){removeTag(document.getElementsByName(this.name)[0]);},100);
    };
    iframe.onreadystatechange = function(){
    	// functionname : [IFrame_Excel.onreadystatechange]

        if (this.readyState == 'complete') {
        	removeTag(document.getElementsByName(this.name)[0]);
        }
    };

    this.submit = function(){
    	// functionname : [IFrame_Excel.submit]

    	this.frm.submit();
    };
 };

/* *****************************************************************************
*  MAKE FILE DOWNLOAD AGENT  
		parentNode : invisible DIV
		name       : iframe's unduplicated name 
		action     : servlet or action which returns file stream
		params     : need Parameter Object's Array 	  
		
     SAMPLE CODE   :
    	var parent = document.getElementsByName("X")[0];
		var action = "/FlexFrame/certi/certiGenerate.action" ;
		var params = [];
		params[0] = new Parameter("coGu", 3);
		params[1] = new Parameter("yy", 2011);
		
		var iFrame_DownLoad = new IFrame_DownLoad(parent, "XXX", action, params);
		iFrame_DownLoad.submit();
* *****************************************************************************/
 /**
  * @description	미결
  * @param		{Object}	parentNode
  * @param		{String}	name
  * @param		{Object}	action
  * @param		{Object}	params
  * @returns		{Undefined}
  * @example		미결
  */
 function IFrame_DownLoad(parentNode, name, action, params) {  
    if(parentNode == null){
        parentNode = document.body;  
        try {
    	    parentNode.removeChild(document.getElementsByName(name)[0]);
        } catch (e){}
    } else {
        if (document.getElementsByName(name).length != 0){
        	removeTag(document.getElementsByName(name)[0]);
        }
    }
    var iframe = document.createElement("iframe");  
    iframe.name = iframe.id   = name;
    parentNode.appendChild(iframe);  

    iframe.doc = null;  

    if(iframe.contentDocument) iframe.doc = iframe.contentDocument;           // Firefox, Opera  
    else if(iframe.contentWindow) iframe.doc = iframe.contentWindow.document; // Internet Explorer  
    else if(iframe.document) iframe.doc = iframe.document;                    // Others?  
    if(iframe.doc == null)  
       throw "Document not found, append the parent element to the DOM before creating the IFrame";  

    iframe.doc.open();  
    iframe.doc.close();  
    
    var frm = iframe.doc.createElement("form");  
    iframe.doc.body.appendChild(frm);  
    frm.method ="POST" ;
    frm.name   = frm.id ="frmdownload" ;
    frm.action = action ;
    frm.enctype="application/x-www-form-urlencoded";
    this.frm = frm;

    for (var key in params){
		if (typeof(params[key])=="function") continue;

		var wControl = iframe.doc.createElement("input");
	    wControl.type = "hidden";  
	    wControl.id   = wControl.name = params[key].fieldName ;
	    wControl.value = params[key].datas[0];
	    frm.appendChild(wControl);
        
    }

   this.submit = function(){
    	// functionname : [IFrame_DownLoad.submit]

    	this.frm.submit();
    };
};

/**
 * @description	미결
 * @param		{String}	scriptPath
 * @param		{String}	callBackString
 * @returns		{Undefined}
 * @example		미결
 */
function ScriptManager(scriptPath, callBackString){
	this.scriptPath = scriptPath;
	this.callBackString = callBackString;
	this.busy = false;
};

/**
 * @description 미결
 * @return		{undefined}
 * @example		미결
 */
ScriptManager.prototype.getScript = function(){
    // functionname : [ScriptManager.getScript]

	var wQueryString = "scriptPath=" 
    	             + this.scriptPath 
			         + "&lang=" + USER_LANGUAGE
    	             + "&tm=" + (new Date()).valueOf();
	this.busy = true;
	ajaxCall("POST", getContextPath() + "/groupware/form/getScript.do", wQueryString, this, "textScript");
};

/**
 * @description 미결
 * @param		{object}	info
 * @param		{object}	message
 * @param		{object}	pFlag
 * @return		{void}
 * @example		미결
 */
ScriptManager.prototype.parseData = function(info, message, pFlag){
	// functionname : [ChartBox.parseData]
   	this.busy = false;
	// 오류 메시지 먼저 파악 
	if (info == null){
		return;
	}
	
    globalEval(info);
    globalEval(this.callBackString);
    
	return;
};

/**
 * @description	미결
 * @param		{String}	src
 * @returns		{Undefined}
 * @example		미결
 */
var globalEval = function globalEval(src) {
    // functionname : [globalEval]
    if (window.execScript) {
        window.execScript(src);
        return null;
    }
    var fn = function() {
        window.eval.call(window, src);
    };
    fn();
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
 function setFireFoxEvent(){
	 // Firefox 에서 event 값을 가져오기 위하여 아래코드를 추가한다 
	 if(navigator.userAgent.indexOf('Firefox') >= 0){ 
	        (function(){
	            var events = ["mousedown", "mouseover", "mouseout", "mousemove", "mousedrag", "click", "dblclick", "keypress", "keydown", "keyup","focus","blur","resize","message"];  
	        	for (var i = 0; i < events.length; i++){
	        	    window.addEventListener(events[i], function(e){ window.event = e;}, true);
	        	}
	        }());
	 };
	 
	 // InnerText 속성을 사용하기 위하여
	 setInnerTextProperty();
 };
 
 /**
  * @description	미결
  * @name			flexformscripthead#getSrcElement
  * @event
  * @returns		{String}
  */
 // Firefox 에서 event 값을 캐취하지 방식이 틀려 firefox 와 다른브라우져에서 쓰는 방식으로 나눔. 
 function getSrcElement(e){
 var srcElement=null;
 
    if(navigator.userAgent.indexOf('Firefox') >= 0){
 		srcElement = e.target;
 	} else {
 		srcElement = e.srcElement;
 	}
 	return srcElement;
 };
 
 /**
  * @description	미결
  * @param			{Object}	element
  * @param			{String}	eventname
  * @param			{Object}	func
  * @returns		{Void}
  * @example		미결
  */
 function setEventHandler(element, eventname, func){

     if (BrowserDetect.browser == "Firefox"){
         // FIrefox의 addEventListener는 onload,onmouseover,onmouseout 에만 적용된다, 나머지는 이 루틴 활용할 것
//         if (eventname != "load" && eventname != "mouseover" && eventname != "mousemove" && eventname != "mouseout" && eventname != "change"&& eventname != "resize") {
    	 if(eventname != "load" && eventname != "message" && eventname != "mouseover" && eventname != "mousemove" && eventname != "mouseout" && eventname != "mouseup" && eventname != "change" && eventname != "dblclick" && eventname != "resize") {
             // 주의 다른 범주내의 함수는 쓸 수 없고 window내의 함수만 쓸 수 있다
             element.setAttribute("on" + eventname, func.name + "(event);");
             return;
         } else  if (eventname == "mousewheel"){
	    	 eventname = "DOMMouseScroll";
	     }
     }

          
 	if (element.addEventListener){  // DOM2: FF, Opera, Chrome
 		element.addEventListener(eventname, func, false);
     
     // IE에서 changedlqpsxmsms propertychange의 value변화값 체크로 확실히 한다.
     } else if (element.attachEvent){ // IE 5+
         if (eventname == "change"){
                 element.attachEvent("onpropertychange", function(e){
                         // Get event details for IE
                         if (!e) e = window.event;

                         if (e.propertyName == 'value' && func != null)
                             func(e);
                     });
         } else {
 		    element.attachEvent("on" + eventname, func);
         }
     } else { // IE 4
         if (eventname == "change"){
             element.onpropertychange = func;
         } else {
 	        element["on" + eventname] = func;
         }
     }
 	
 	EventCache.add(element, eventname, func, false);
 	return;
 };
 
 /* 20161230 추가(차중훈) */
 function removeEventHandler(element, eventname, func){
	 if(element == null) return;
	 
	 var eventNameWithOn = "on" + eventname;
	 
	 if( BrowserDetect.browser == "Firefox" ){
         // FIrefox의 addEventListener는 onload,onmouseover,onmouseout 에만 적용된다, 나머지는 이 루틴 활용할 것
    	 if( eventname != "load"		&& 
    		 eventname != "message"		&& 
    		 eventname != "mouseover"	&& 
    		 eventname != "mousemove"	&& 
    		 eventname != "mouseout"	&& 
    		 eventname != "mouseup"		&& 
    		 eventname != "change"		&& 
    		 eventname != "dblclick"	&& 
    		 eventname != "resize" ){
             // 주의 다른 범주내의 함수는 쓸 수 없고 window내의 함수만 쓸 수 있다
             element.removeAttribute(eventNameWithOn);
             return;
         }
    	 else if( eventname == "mousewheel" ){
	    	 eventname = "DOMMouseScroll";
	     }
     }
	 
	 if( element.removeEventListener ){	// DOM2: FF, Opera, Chrome
		 element.removeEventListener(eventname, func, false);
	 }
	 else if( element.detachEvent ){	// IE 5+
//		 if (eventname == "change"){
//			 eventNameWithOn = "onpropertychange";
//		 }
		 element.detachEvent(eventNameWithOn, func);
	 }
	 else{	// IE 4
		 if(eventname == "change"){
			 element.onpropertychange = null;
		 }
		 else{
			 element[eventNameWithOn] = null;
		 }
	 }
	 
	 return;
 }
 /* 20161230 추가(차중훈) */
 
 /**
  * @description	미결
  * @param			{Object}	element
  * @param			{String}	eventname
  * @param			{Object}	func
  * @returns		{Void}
  * @example		미결
  */
 function setTouchEventHandler(element, eventname, func){
	//터치이벤트
     var mc = Hammer(element, {
         touchAction: 'pan-x pan-y'
     });
     mc.get('pan').set({ direction: Hammer.DIRECTION_ALL });
     mc.get('swipe').set({ direction: Hammer.DIRECTION_ALL });
     
     if(eventname == "scroll"){
    	 mc.on("pan swipe rotate pinch tap doubletap press", function(ev) {
//         console.log("델타x : "+ev.deltaX +" , 델타Y : "+ev.deltaY +" , ev : "+ev);
    		 var scrollDiv = element.getElementsByTagName("div")[0];
    		 var scroll_Y = ev.deltaY/2;
    		 var scroll_X = ev.deltaX/2;
    		 
    		 if(Math.abs(scroll_Y) >= Math.abs(scroll_X)){
    			 scrollDiv.scrollTop += (-1) * scroll_Y;
    		 }else{
    			 scrollDiv.scrollLeft += (-1) * scroll_X;
    		 }
    		 
    		 // 스마트 그리드 동작을 위해 scrollAction 호출
    		 var wSheet = searchSheet(scrollDiv);
        	 if(wSheet == undefined || wSheet == null) return;
    	     wSheet.scrollAction(scrollDiv.scrollTop, scrollDiv.scrollLeft);
    	 });
     }

     
	 return;
 };

 /**
  * @description	미결
  * @param			{Object}	evt
  * @returns		{Object}
  * @example		미결
  */
function getShiftKeyPressed(evt){
    return evt.shiftKey; 
};

/**
 * @description	미결
 * @param		{Object}	evt
 * @returns		{Boolean}
 * @example		미결
 */
function getCtrlPressed(evt){
	    return evt.ctrlKey || evt.metaKey; // Mac support
};

/**
 * @description	미결
 * @param		{Object}	evt
 * @returns		{Object}
 * @example		미결
 */
function getAltPressed(evt){
	    return evt.altKey;
};

/**
 * @description	미결
 * @param		{Object}	pem
 * @param		{Object}	em
 * @returns		{Object}
 * @example		미결
 */
function removeElement(pem, em) {
    pem.removeChild(em);
};

/**
 * @description	미결
 * @name		flexformscripthead#getButtonElement
 * @event
 * @returns		{}
 */
function getButtonElement(e){
    var srcElement=0;
    if(USER_BROWSER_NAME == "firefox" || USER_BROWSER_NAME == "netscape"){
      if( e == 0){
    		srcElement = 1;
      }
	} else {
		srcElement = e;
	}
	return srcElement;
};

/* ************************************************************************
*   상위 화면에서  객체 조회 호출시 동작 설정
*   * "조회"라는 가저오기가 있어야 한다 
* ************************************************************************/
/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function executeDisplayJob(){
	var checkEvent = false;
	try {
   	if (eval("fillJob_조회")) checkEvent = true;
   } catch(e){}
   
   if (checkEvent){
   	jobControler.open("조회;");
   }    
};

var commonButtons = []; //associative array
/**
 * @description	미결
 * @param		{Number}	strName
 * @returns		{Void}
 * @example		미결
 */
function callCommonButton(strName){
	commonButtons[strName].click();
	return;
};

/**
 * @description	미결
 * @param		{Object}	control
 * @returns		{Void}
 * @example		미결
 */
function setCommonButton(control){
	for (var wKey in commonButtons){
		if (commonButtons[wKey] == control){
			var keyControl = document.getElementsByName(wKey)[0];
			if(keyControl != undefined && keyControl != null){
				document.getElementsByName(wKey)[0].style.display = (control.enabled ? "block" : "none");
			}
			break;
		}
	}
	return;
};

/* ************************************************************************
*   인라인 메시지박스
* ************************************************************************/
/**
 * @description	미결
 * @param		{String}	msg
 * @returns		{Void}
 * @example		미결
 */
function inlineMessage(msg){
	try {
		if( typeof parent.frames["bottomFrame"] != "undefined"){
			parent.frames["bottomFrame"].tabsMsgPrint(msg);
		}
		else{
			alert(msg);
		}
	} catch(e){
		alert(msg);
	}
	
	return;
};

/**
 * @description	미결
 * @returns		{Void}
 * @example		미결
 */
function clearInlineMessage(){
	try {
		if( typeof parent.frames["bottomFrame"] != "undefined")
			parent.frames["bottomFrame"].tabsMsgPrint("");
	} catch(e){}
	
	return;
};

/* ************************************************************************
*   엔터키 동작설정 
*   * 지정콘트롤의 다음 순번의 콘트롤중 Enable상태인 것을 찾는다
* ************************************************************************/
/**
 * @description	미결
 * @param		{String}	pControlName
 * @returns		{Void}
 * @example		미결
 */
function setFocusToNextControl(pControlName){
	var found = false;
	for (var i = tabInfos.indexOf(pControlName) + 1; i < tabInfos.length; i++){
		var controlName = tabInfos[i];
		var wControl = controls[controlName];
//		if (wControl.enabled && wControl.visible && 
//				!(BrowserDetect.browser == "Firefox" && wControl.tagObject.clientHeight == 0) &&
//				!(BrowserDetect.browser == "Safari" && wControl.tagObject.clientHeight == 0)) {
		if (wControl.enabled && wControl.visible && wControl.tagObject.clientHeight != 0) {
			if (wControl.focus && wControl.focus()){
				found = true;
				break;
			}
		}
	}
	if (found) return; 
	for (var i = 0; i < tabInfos.indexOf(pControlName); i++){
		var controlName = tabInfos[i];
		var wControl = controls[controlName];
		if (wControl.enabled && wControl.visible) {
			if (wControl.focus && wControl.focus()){
				found = true;
				break;
			}
		}
	}
	return;
};

/**
 * @description	미결
 * @param		{String}	pControlName
 * @returns		{Void}
 * @example		미결
 */
function setFocusToFormerControl(pControlName){
	var found = false;
	for (var i = tabInfos.indexOf(pControlName) - 1; i >=0 ; i--){
		var controlName = tabInfos[i];
		var wControl = controls[controlName];
		if (wControl.enabled && wControl.visible) {
			if (wControl.focus && wControl.focus()){
				found = true;
				break;
			}
		}
	}
	
	if (found) return; 
	for (var i =  tabInfos.length - 1; i > tabInfos.indexOf(pControlName); i--){
		var controlName = tabInfos[i];
		var wControl = controls[controlName];
		if (wControl.enabled && wControl.visible) {
			if (wControl.focus && wControl.focus()){
				found = true;
				break;
			}
		}
	}
	
	
	return;
};

/**
 * @description	미결
 * @returns		{Void}
 * @example		미결
 */
function setFocusToFirstControl(){
//	var found = false;
	self.focus();
	
	for (var i = 0; i < tabInfos.length; i++){
		var controlName = tabInfos[i];
		if (controlName == null || controlName.trim().length == 0) continue;
		
		var wControl = controls[controlName];
		if (wControl.enabled && wControl.visible && 
				!(BrowserDetect.browser == "Firefox" && wControl.tagObject.clientHeight == 0) &&
				!(BrowserDetect.browser == "Safari" && wControl.tagObject.clientHeight == 0)) {
			if ( wControl.focus 	){
				setTimeout(function(){
					wControl.focus();
				}, 500);
//				found = true;
				return wControl;
			}
		}
	}
	return;
};

/**
 * @description	미결
 * @param		{Object}	event
 * @returns		{Undefined}
 * @example		미결
 */
// 이벤트 겐슬에 관한 함수
// 상위로 전달되는 버블링 단계의 방지
function stopPropagation(event){
	
    if (event.stopPropagation){
       event.stopPropagation();
    } else {
       event.cancelBubble = true;
    }
};

/**
 * @description	미결
 * @param		{Object}	event
 * @returns		{Undefined}
 * @example		미결
 */
// 이벤트의 디폴트 후속 동작을 취소
function preventDefault(event) {
    if (event.preventDefault){
       event.preventDefault();
    } else {
       event.returnValue = false;
    }
};

/**
 * @description	미결
 * @param		{Object}	event
 * @returns		{Undefined}
 * @example		미결
 */
// 두가지 다
function stopEvent(event){
    stopPropagation(event);
    preventDefault(event);
};

/**
 * @description	미결
 * @param		{Object}	editor
 * @returns		{String}
 * @example		미결
 */
// IE 커서의 위치가처오기 나머지 네개 브라우저는 em.selectionStart,  em.selectionEnd 속성가능
function synGetCaret(editor) {
	var selectionStart = 0; selectionEnd = 0;
    if(document.selection){
    	// The current selection
    	var range = document.selection.createRange();
    	var stored_range = range.duplicate();
    	
    	stored_range.moveToElementText( element );
    	stored_range.setEndPoint( 'EndToEnd', range );
    	
    	selectionStart = stored_range.text.length - range.text.length;
    	selectionEnd = element.selectionStart + range.text.length;
    }
    
    return {"selectionStart":selectionStart, "selectionEnd":selectionEnd};
};

/**
 * @description	미결
 * @param		{Object}	data
 * @returns		{String}
 * @example		미결
 */
function escapeParseString(data){
    var wString = "" + data;
    wString = wString.replaceWord(",", "<comma>");
    wString = wString.replaceWord(";", "<sclon>");
    wString = wString.replaceWord(":", "<clon>");
	wString = wString.replaceWord("&", "<amp>");
	wString = wString.replaceWord("%", "<percent>");
	wString = wString.replaceWord("?", "<question>");
    
    return wString;	
};

/**
 * @description	미결
 * @returns		{Void}
 * @example		미결
 */
// 로케일 찾기 
function setLocale(){
	
	if (USER_LANGUAGE != undefined && USER_LANGUAGE.trim().length > 0){
		return;
	} 
	
	
	if ( navigator ) {
		var wLanguge = "BrowserLanguage_";
	    if ( navigator.language ) {
	    	wLanguge += navigator.language;
	    }
	    else if ( navigator.browserLanguage ) {
	    	wLanguge += navigator.browserLanguage;
	    }
	    else if ( navigator.systemLanguage ) {
	    	wLanguge += navigator.systemLanguage;
	    }
	    else if ( navigator.userLanguage ) {
	    	wLanguge += navigator.userLanguage;
	    }
	    
	    USER_LANGUAGE = wLanguge;
	}
	
	return; 
};

/**
 * @description	미결
 * @param		{Object}	el
 * @returns		{Number}
 * @example		미결
 */
// 텍스트박스에서 커서위치 찾기
function getCaretPosition(el) {
	  if (el.selectionStart) {
	    return el.selectionStart;
	  } else if (document.selection) {
		  try { el.focus(); } catch(e){}

	    var r = document.selection.createRange();
	    if (r == null) {
	      return 0;
	    }

	    var re = el.createTextRange(),
	        rc = re.duplicate();
	    re.moveToBookmark(r.getBookmark());
	    rc.setEndPoint('EndToStart', re);

	    return rc.text.length;
	  } 
	  return 0;
};
/**
 * @description	미결
 * @param		{Object}	el
 * @returns		{Number}
 * @example		미결
 */
function getCaretLength(el) {
	  if (el.selectionStart) {
	    return (el.selectionEnd - el.selectionStart);
	  } else if (document.selection) {
		  try { el.focus(); } catch(e){}

	    var r = document.selection.createRange();
	    if (r == null) {
	      return 0;
	    }
	    return r.text.length;
	  } 
	  return 0;
};

//---------------------------------------------------------------------------------------
//파이어폭스에서 innerText 인식이 안되는 경우
//이 함수를 먼저 읽히게 하면 innerText 를 사용할 수 있음
//---------------------------------------------------------------------------------------
/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function setInnerTextProperty() {
 if(typeof HTMLElement != "undefined" && typeof HTMLElement.prototype.__defineGetter__ != "undefined") {
     HTMLElement.prototype.__defineGetter__("innerText",function() {
         if(this.textContent) {
             return(this.textContent);
         } 
         else {
             var r = this.ownerDocument.createRange();
             r.selectNodeContents(this);
             return r.toString();
         }
     });
     
     HTMLElement.prototype.__defineSetter__("innerText",function(sText) {
         this.innerHTML = sText;
     });
 }
};

//insertAdjacentHTML(), insertAdjacentText() and insertAdjacentElement()
//for Netscape 6/Mozilla by Thor Larholm me@jscript.dk
//Usage: include this code segment at the beginning of your document
//before any other Javascript contents.
/**
 * @description	미결
 * @param		{String}	where
 * @param		{String}	parseNode
 * @returns		{Undefined}
 * @example		미결
 */
if(typeof HTMLElement!="undefined" && !
HTMLElement.prototype.insertAdjacentElement){
 HTMLElement.prototype.insertAdjacentElement = function (where,parsedNode){
     switch (where){
     case 'beforeBegin':
         this.parentNode.insertBefore(parsedNode,this);
         break;
     case 'afterBegin':
         this.insertBefore(parsedNode,this.firstChild);
         break;
     case 'beforeEnd':
         this.appendChild(parsedNode);
         break;
     case 'afterEnd':
         if (this.nextSibling) 
             this.parentNode.insertBefore(parsedNode,this.nextSibling);
         else 
        	 this.parentNode.appendChild(parsedNode);
         break;
     }
 };

 /**
  * @description 미결
  * @param		{object}	where
  * @param		{object}	htmlStr
  * @return		{undefined}
  * @example		미결
  */
 HTMLElement.prototype.insertAdjacentHTML = function (where,htmlStr) {
     var r = this.ownerDocument.createRange();
     r.setStartBefore(this);
     var parsedHTML = r.createContextualFragment(htmlStr);
     this.insertAdjacentElement(where,parsedHTML);
 };

 /**
  * @description 미결
  * @param		{object}	where
  * @param		{object}	txtStr
  * @return		{undefined}
  * @example		미결
  */
 HTMLElement.prototype.insertAdjacentText = function (where,txtStr) {
     var parsedText = document.createTextNode(txtStr);
     this.insertAdjacentElement(where,parsedText);
 };
}


/*	Implement array.push for browsers which don't support it natively.
	Please remove this if it's already in other code */
if(Array.prototype.push == null){
	Array.prototype.push = function(){
		for(var i = 0; i < arguments.length; i++){
			this[this.length] = arguments[i];
		};
		return this.length;
	};
};

/*	Event Cache uses an anonymous function to create a hidden scope chain.
	This is to prevent scoping issues. */
var EventCache = function(){
	var listEvents = [];
	
	return {
		listEvents : listEvents,
	
		add : function(node, sEventName, fHandler, bCapture){
			listEvents.push(arguments);
		},
	
		flush : function(){
			var i, item;
			for(i = listEvents.length - 1; i >= 0; i = i - 1){
				item = listEvents[i];
				
				if(item[0].removeEventListener){
					item[0].removeEventListener(item[1], item[2], item[3]);
				};
				
				/* From this point on we need the event names to be prefixed with 'on" */
				if(item[1].substring(0, 2) != "on"){
					item[1] = "on" + item[1];
				};
				
				if(item[0].detachEvent){
					item[0].detachEvent(item[1], item[2]);
				};
				
				item[0][item[1]] = null;
			};
		}
	};
}();

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
/*  *****  로컬 스토리지 사용 _모바일 ***** */
function supports_html5_storage() {
    try {
    	return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
    	return false;
    }
};
/*  *****  사용의 사례 _모바일 *****
 * 
// 스토리지 이벤트 부여  
if (window.addEventListener) {
	window.addEventListener("storage", handle_storage, false);
} else {
	window.attachEvent("onstorage", handle_storage);
};

function handle_storage(e) {
	if (!e) { e = window.event; }
}

// 메모리 사용 _모바일
document.addEventListener("deviceready", onDeviceReady, false);
function onDeviceReady() {
    window.localStorage.setItem("key", "value");
    
    var keyname = window.localStorage.key(i);
    // keyname is now equal to "key"
    
    var value = window.localStorage.getItem("key");
    // value is now equal to "value"
    
    window.localStorage.removeItem("key");
    
    window.localStorage.setItem("key2", "value2");
    
    window.localStorage.clear();
    // localStorage is now empty
}

*/ 
/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
// 폼리사이징 이벤트 함수 _모바일
var resizeTimer = 0;
function doResize(){
    if (resizeTimer) clearTimeout(resizeTimer);
    resizeTimer = setTimeout(doResizeEnd, 500);
};
/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function doResizeEnd(){
    var w = window;
    var d = document;
    var e = d.documentElement;
    var g = d.getElementsByTagName('body')[0];
    var w = w.innerWidth || e.clientWidth || g.clientWidth;
    var h = w.innerHeight|| e.clientHeight|| g.clientHeight;
    w = parseIntSize(w); h = parseIntSize(h);
      
    document_onresize(w, h);
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function ActivateResizeEvent(){
	setEventHandler(window, "resize", function(e){
	    e = window.event || e;
	    doResize();
	});

};


//화면간 메시지교환 동작에 필요한 선언과 함수들
//모달폼 전역변수 선언
var modalDialogWindow = null;
var modalCommandId = "";  //command_NNN_onclick() 이벤트에서 대입
var modalArguments = ";";

/**
 * @description	미결
 * @name		flexformscripthead#postMessageController
 * @event
 * @returns		{Undefined}
 */
//postMessage 방식의 리턴값 받기
function postMessageController(e) {
	if (e.data == "loaded"){				// 차일드에서 받는 부모폼폼코딩
		//window.setTimeout("postArgument();", 1);
		postArgument();
	} else if (e.data.endsWith(";POST")){	// 부모폼에서 받는 차일드폼 코딩
		modalArguments = e.data;
	} else {								// 차일드에서 받는 부모폼폼코딩
		if( typeof self["setReturnValue_" + modalCommandId] == "function" ){
			eval("setReturnValue_" + modalCommandId + "(e.data);"    );
//			self["setReturnValue_" + modalCommandId](e.data);
		}
	}
};
/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function postArgument(){
	if(modalDialogWindow != null) modalDialogWindow.postMessage(modalCommandId + ";POST", '*');
};
//POST MESSAGE EVENT를 붙인다
setEventHandler(window, "message", postMessageController);

//Post 방식으로 다이얼로그 팝업을 호출했을 경우 팝업 호출 정보를 가져오는 함수
function getPostArgument(){
	return modalCommandId + ";POST";
};

/**
 * @description	미결
 * @returns		{Number}
 * @example		미결
 */
function findHighestZIndex()
{
	var elements = document.getElementsByTagName("*");
	var highest = 0;
	var elementLength = elements.length - 1;
	var elementStyle = null;
	var elementZIndex = 0;
	
	for (var i = 0; i < elementLength; i++) {
		elementStyle = elements[i].currentStyle;
		comp = elementStyle ? elementStyle : getComputedStyle(elements[i], null);
		elementZIndex = comp.zIndex;
	    if (parseInt(elementZIndex) > highest) {
	    	highest = parseInt(elementZIndex);
	    }
	}
	
    return highest;
};

/**
 * @description	미결
 * @returns		{String}
 * @example		미결
 */
//160119 김남용 Frame에으로 팝업화면 호출후 종료버튼 및 값넘겨주기시  종료처리하기위해 추가.
function parentFrameCtlName(){
	var ctlName = "";
	
	if(thisIsIframe){
	    var pEm = self.parent.document.getElementsByName(self.name)[0];
	  	while (pEm.parentNode && !pEm.className.startsWith("Frame_") ) {
	  		pEm = pEm.parentNode;
	  	}
	  	if (pEm != null){
	  	   ctlName = pEm.getAttribute("ctlname");
	  	}
	}
	return ctlName;
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
/* 페이지 사이즈 체크 함수*/
function getVisibleDocWidth() {
	  if (self.innerHeight) {
	    return self.innerWidth;
	  }

	  if (document.documentElement && document.documentElement.clientWidth) {
	    return document.documentElement.clientWidth;
	  }

	  if (document.body) {
	    return document.body.clientWidth;
	  }
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function getVisibleDocHeight() {
	  if (self.innerHeight) {
	    return self.innerHeight;
	  }

	  if (document.documentElement && document.documentElement.clientHeight) {
	    return document.documentElement.clientHeight;
	  }

	  if (document.body) {
	    return document.body.clientHeight;
	  }
};



//유저 정보 및 추가 사용자 세션 정보 불러오기
var userInfoLoader = null;

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function UserInfoLoader(){
	this.contextPath = getContextPath();
	this.addItemKeys = [];
	
	//사용자 이벤트
	//1. 유저정보 로드 전 처리
	this.hasLoadBefore = false;
	this.fncLoadBefore = null;
	
	this.hasLoadBefore = (typeof self["userInfo_onLoadBrfore"] != "undefined");
	if( this.hasLoadBefore ){
		this.fncLoadBefore = new Function("return function(){ return userInfo_onLoadBrfore(); }")();
	}
	
	//2.유저정보 로드 후 처리
	this.hasLoadCompleted = false;
	this.fncLoadCompleted = null;
	
	this.hasLoadCompleted = (typeof self["userInfo_onLoadCompleted"] != "undefined");
	if( this.hasLoadCompleted ){
		this.fncLoadCompleted = new Function("return function(jsonObject){ return userInfo_onLoadCompleted(jsonObject); }")();
	}
};

/**
 * @description 미결
 * @return		{undefined}
 * @example		미결
 */
UserInfoLoader.prototype.loadData = function(){
	//유저정보 로드 전 처리
	if( this.hasLoadBefore ){
		this.fncLoadBefore();
	}
	
	ajaxCallSync("POST", this.contextPath + "/loadUserInfo.do", "", this, "");
};

/**
 * @description 미결
 * @param		{object}	jsonObject
 * @param		{string}	message
 * @return		{boolean}
 * @example		미결
 */
UserInfoLoader.prototype.parseData = function(jsonObject, message){
	//기본 유저정보 설정
	USER_COGU			= jsonObject.USER_COGU;
	USER_BON			= jsonObject.USER_BON;
	USER_PART     		= jsonObject.USER_PART;
	USER_ORGANIZATION	= jsonObject.USER_ORGANIZATION;
	USER_PERSONALID		= jsonObject.USER_PERSONALID;
	USER_PERSONALNAME	= jsonObject.USER_PERSONALNAME;
//	USER_DATE			= jsonObject.USER_DATE;
//	USER_YEAR			= parseInt(USER_DATE.substring(0,4), 10);
//	USER_MONTH			= parseInt(USER_DATE.substring(0,6), 10);
//	USER_TIME			= jsonObject.USER_TIME;
	USER_USERID			= jsonObject.USER_USERID;
	USER_IPADDR			= jsonObject.USER_IPADDR;
	USER_LANGUAGE		= jsonObject.USER_LANGUAGE;
	USER_MESSAGE		= jsonObject.USER_MESSAGE;
	
	//유저정보 로드 후 처리
	if( this.hasLoadCompleted ){
		this.fncLoadCompleted(jsonObject);
	}
	
	return true;
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function settingUserInfos(){
	if( userInfoLoader == null )
		userInfoLoader = new UserInfoLoader();
	
	userInfoLoader.loadData();
};



//setEventHandler(document, "unload", function(){ alert("Document Unload!!!"); return true; });

/**
 * @description 
 *     EasyMaker Vertical Data Sheet For Big Data.
 * 
 * @constructor
 * 
 * @param {string} 	 controlId 	 - 콘트롤 고유 아이디 (영문)
 * @param {string} 	 controlName - 콘트롤 명 (사용자 고유 언어)
 * @param {HTMLNode} tagObject   - HTML 본문중의 매칭되는 HTML DOM Node. 
 * @return {Object} - 생성된 EasySheet 개체
 * @exception 널값 예외
 * 
 */
function ControlBase(controlId, controlName, tagObject){
	this.controlId = controlId;
	this.id = controlId;            // id와 controlId는 혼용가능
	this.controlName = controlName;
	this.tagObject = tagObject;
    /**
     *   @description  사용자가 컨트롤에 입력한 값에 의한 체크조건을 설정하는 값입니다.<br><br>
     *                 <table width="500">
     *                   <caption>CHECKTYPE 상수 정보</caption>
     *                   <thead>
     *                      <tr>
     *                          <th align="left">CHECKTYPE Value</th>
     *                          <th align="left">Description</th>
     *                       </tr>
     *                    </thead>
     *                    <tbody>
     *                       <tr>
     *                          <td> NONE </td>
     *                          <td> 체크조건이 없습니다. </td>
     *                       </tr>
     *                       <tr>
     *                          <td> FORMULA </td>
     *                          <td> 산식체크 </td>
     *                       </tr>
     *                       <tr>
     *                          <td> YYYY </td>
     *                          <td> 년도 </td>
     *                       </tr>
     *                       <tr>
     *                          <td> YM </td>
     *                          <td> 년월 </td>
     *                       </tr>
     *                       <tr>
     *                          <td> YMD </td>
     *                          <td> 년월일 </td>
     *                       </tr>
     *                       <tr>
     *                          <td> RESINUM </td>
     *                          <td> 주민등록번호 </td>
     *                       </tr>
     *                       <tr>
     *                          <td> TAXNUM </td>
     *                          <td> 사업자등록번호 </td>
     *                       </tr>
     *                       <tr>
     *                          <td> POSTNUM </td>
     *                          <td> 우편번호 </td>
     *                       </tr>
     *                       <tr>
     *                          <td> _EMPTY </td>
     *                          <td> 사용안함 </td>
     *                       </tr>
     *                       <tr>
     *                          <td> AMOUNT </td>
     *                          <td> 금액</td>
     *                       </tr>
     *                       <tr>
     *                          <td> NUMBER </td>
     *                          <td> 숫자 </td>
     *                       </tr>
     *                       <tr>
     *                          <td> IMEMODE </td>
     *                          <td> 한글 </td>
     *                       </tr>
     *                       <tr>
     *                          <td> ENGLNUM </td>
     *                          <td> 영문 + 숫자</td>
     *                       </tr>
     *                       <tr>
     *                          <td> BARCODE </td>
     *                          <td> 바코드 </td>
     *                       </tr>
     *                       <tr>
     *                          <td> PASSWORD </td>
     *                          <td> 패스워드 </td>
     *                       </tr>
     *                 </table>
     *   @example      ControlBase.checkType = ControlBase.CHECKTYPE.YYYY;
     */
	// 상수선언부
    this.CHECKTYPE = {
    		NONE 	: 0,
    		FORMULA : 1,
    		YYYY 	: 2,
    		YM   	: 3,
    		YMD 	: 4,
    		RESINUM : 5,
    		TAXNUM  : 6,
    		POSTNUM : 7,
    		_EMPTY  : 8,
    		AMOUNT  : 9,
    		NUMBER  : 10,
    		IMEMODE : 11,
    		ENGLNUM : 12,
    		BARCODE : 13,
    		PASSWORD: 14};
	
    /**
     *   @description  사용자가 컨트롤에 입력한 값이 확정되었을 때, 컨트롤에 입력된 값을 Key로 하여 데이터를 조회합니다.<br>
     *                 기본값: false<br><br>
     *                 <table width="500">
     *                   <caption>isKeyControl Variable Value</caption>
     *                   <thead>
     *                      <tr>
     *                          <th align="left">Value</th>
     *                          <th align="left">Description</th>
     *                       </tr>
     *                    </thead>
     *                    <tbody>
     *                       <tr>
     *                          <td> true </td>
     *                          <td> 컨트롤 값에 의해 자료를 조회합니다. </td>
     *                       </tr>
     *                       <tr>
     *                          <td> false </td>
     *                          <td> 컨트롤 값에 의해 자료를 조회하지 않습니다. </td>
     *                       </tr>
     *                 </table><br>
     */  
    this.isKeyControl = false;
    /**
     *   @description      조회한 자료에서 Key 필드와 함께 추가로 조건을 주기위해 사용합니다.<br>
     *                     컨트롤에 화면채우기 설정이 되어있다면 Key필드와 컨트롤의 값에 만족하는 데이터를 화면에 채웁니다.<br>
     *                     기본값 : false<br><br>
     *                     <table width="500">
     *                       <caption>isFillControl Variable Value</caption>
     *                       <thead>
     *                          <tr>
     *                              <th align="left">Value</th>
     *                              <th align="left">Description</th>
     *                           </tr>
     *                        </thead>
     *                        <tbody>
     *                           <tr>
     *                              <td> true </td>
     *                              <td> 컨트롤에 값을 채웁니다. </td>
     *                           </tr>
     *                           <tr>
     *                              <td> false </td>
     *                              <td> 컨트롤에 값을 채우지 않습니다. </td>
     *                           </tr>
     *                     </table><br>
     */    
    this.isFillControl = false;
    /**    
     *   @description      Clear나 확인버튼을 클릭하여 실행시키고 난 후 후속작업을 위해 컨트롤의 데이터를 비울지 설정합니다.<br>
     *                     기본값 : false<br><br>
     *                     <table width="500">
     *                       <caption>isClearControl Variable Value</caption>
     *                       <thead>
     *                            <tr>
     *                                <th align="left">Value</th>
     *                              <th align="left">Description</th>
     *                           </tr>
     *                        </thead>
     *                        <tbody>
     *                           <tr>
     *                               <td> true </td>
     *                              <td> Clear 기능 실행 후 컨트롤의 값을 비웁니다. </td>
     *                           </tr>
     *                           <tr>
     *                                <td> false </td>
     *                              <td> Clear 기능 실행하더라도 컨트롤의 값을 유지합니다. </td>
     *                           </tr>
     *                     </table><br>
     */    
    this.isClearControl = false;
    /**
     *   @description      입력/조회 시트에서 줄추가/삭제시 컨트롤의 값을 비울지 설정합니다.<br>
     *                     줄 단위로 다른 값이 들어갈 데이터에 적용됩니다.<br>기본값 : false<br><br>
     *                     <table width="500">
     *                       <caption>isSeqClearControl Variable Value</caption>
     *                       <thead>
     *                            <tr>
     *                                <th align="left">Value</th>
     *                              <th align="left">Description</th>
     *                           </tr>
     *                        </thead>
     *                        <tbody>
     *                           <tr>
     *                               <td> true </td>
     *                              <td> 줄추가/삭제시 컨트롤의 값을 비웁니다. </td>
     *                           </tr>
     *                           <tr>
     *                              <td> false </td>
     *                              <td> 줄추가/삭제를 하더라도 컨트롤의 값은 유지됩니다. </td>
     *                           </tr>
     *                     </table><br>
     */ 
    this.isSeqClearControl = false;
    /**
     *   @description  컨트롤의 기본값을 지정합니다.<br>
     *                 eval 명령으로 실행할 수 있는 산식도 들어갈 수 있습니다<br>기본값 : 없음<br><br>
     */
    this.defaultValue = "";       // eval명령으로 샐행할 수 있는 산식이 들어간다 
    /**
     *   @description  다른 컨트롤에 연관되어 출력되는 데이터가 다른 컨트롤의 값에 따라 변하는 경우 다른 컨트롤의 이름을 지정합니다.<br>기본값 : 없음<br><br>
     */ 
    this.callerControlName = "";  // 콘트롤 채우기를 호출하는 콘트롤명
    /**
     *   @description  사용자가 입력한 컨트롤의 데이터입니다.<br>기본값 : 없음<br><br>
     */ 
    this.value = null;
    this.image = "";
    /**
     *   @description  컨트롤의 배경색입니다.<br>기본값 : #FFFFFF<br><br>
     */ 
	this.backColor = "#FFFFFF";
    /**
     *   @description  사용자가 입력한 컨트롤 데이터의 글씨색입니다.<br>기본값 : #000000<br><br>
     */
	this.foreColor ="#000000";
    /**
     *   @description  컨트롤의 기능 활성화/비활성화 설정합니다.<br>기본값 : true<br><br>
     *                 <table width="500">
     *                   <caption>visible Variable Value</caption>
     *                   <thead>
     *                      <tr>
     *                          <th align="left">Value</th>
     *                          <th align="left">Description</th>
     *                       </tr>
     *                    </thead>
     *                    <tbody>
     *                       <tr>
     *                          <td> true </td>
     *                          <td> 컨트롤이 보입니다. </td>
     *                       </tr>
     *                       <tr>
     *                          <td> false </td>
     *                          <td> 컨트롤이 안 보입니다. </td>
     *                       </tr>
     *                 </table><br>
     */
	this.visible = true;
    /**
     *   @description  컨트롤의 기능 활성화/비활성화 설정합니다.<br>기본값 : true<br><br>
     *                 <table width="500">
     *                   <caption>enabled Variable Value</caption>
     *                   <thead>
     *                      <tr>
     *                          <th align="left">Value</th>
     *                          <th align="left">Description</th>
     *                       </tr>
     *                    </thead>
     *                    <tbody>
     *                       <tr>
     *                          <td> true </td>
     *                          <td> 컨트롤을 활성화 시킵니다. </td>
     *                       </tr>
     *                       <tr>
     *                          <td> false </td>
     *                          <td> 컨트롤을 비활성화 시킵니다. </td>
     *                       </tr>
     *                 </table><br>
     */
	this.enabled = true;
	this.readOnly = false;
    /**
     *   @description  사용자가 입력한 컨트롤 데이터를 정렬합니다.<br>
     *                 기본값 : "left"<br><br>
     *                 <table width="500">
     *                   <caption>enabled Variable Value</caption>
     *                   <thead>
     *                      <tr>
     *                          <th align="left">Value</th>
     *                          <th align="left">Description</th>
     *                       </tr>
     *                    </thead>
     *                    <tbody>
     *                       <tr>
     *                          <td> left </td>
     *                          <td> 왼쪽 정렬. </td>
     *                       </tr>
     *                       <tr>
     *                          <td> center </td>
     *                          <td> 가운데 정렬. </td>
     *                       </tr>
     *                       <tr>
     *                          <td> right </td>
     *                          <td> 오른쪽 정렬. </td>
     *                       </tr>
     *                 </table><br>
     */
	this.alignment = "left";
    /**
     *   @description  사용자가 입력한 컨트롤 데이터의 글씨굵기를 설정합니다.<br>
     *                 기본값 : false<br><br>
     *                 <table width="500">
     *                   <caption>fontBold Variable Value</caption>
     *                   <thead>
     *                      <tr>
     *                          <th align="left">Value</th>
     *                          <th align="left">Description</th>
     *                       </tr>
     *                    </thead>
     *                    <tbody>
     *                       <tr>
     *                          <td> true </td>
     *                          <td> 글씨 굵기를 굵게합니다. </td>
     *                       </tr>
     *                       <tr>
     *                          <td> false </td>
     *                          <td> 글씨 굵기를 굵게하지 않습니다. </td>
     *                       </tr>
     *                 </table><br>
     */
	this.fontBold = false;
    /**
     *   @description  사용자가 입력한 컨트롤 데이터의 글꼴을 기울임꼴로 설정합니다.<br>
     *                 기본값 : false<br><br>
     *                 <table width="500">
     *                   <caption>fontItalic Variable Value</caption>
     *                   <thead>
     *                      <tr>
     *                          <th align="left">Value</th>
     *                          <th align="left">Description</th>
     *                       </tr>
     *                    </thead>
     *                    <tbody>
     *                       <tr>
     *                          <td> true </td>
     *                          <td> 컨트롤 값의 글꼴을 기울임꼴로 설정합니다. </td>
     *                       </tr>
     *                       <tr>
     *                          <td> false </td>
     *                          <td> 컨트롤 값의 글꼴을 기울이지 않습니다. </td>
     *                       </tr>
     *                 </table><br>
     */
	this.fontItalic = false;
    /**
     *   @description  사용자가 입력한 컨트롤 데이터의 글씨체를 설정합니다.<br>
     *                 기본값 : false<br><br>
     */
	this.fontName = "";
    /**
     *   @description  사용자가 입력한 컨트롤 데이터의 글씨크기를 설정합니다.<br>
     *                 기본값 : 9<br>
     *                 단  위 : pt<br><br>
     */
	this.fontSize = 9;  //pt
    /**
     *   @description  사용자가 입력한 컨트롤 데이터의 글자 중간에 가로줄을 그을지 설정합니다.<br>
     *                 기본값 : false<br><br>
     *                 <table width="500">
     *                   <caption>fontStrikethru Variable Value</caption>
     *                   <thead>
     *                      <tr>
     *                          <th align="left">Value</th>
     *                          <th align="left">Description</th>
     *                       </tr>
     *                    </thead>
     *                    <tbody>
     *                       <tr>
     *                          <td> true </td>
     *                          <td> 컨트롤 값의 글자 중간에 가로줄을 긋습니다. </td>
     *                       </tr>
     *                       <tr>
     *                          <td> false </td>
     *                          <td> 컨트롤 값의 글자 중간에 가로줄을 긋지 않습니다. </td>
     *                       </tr>
     *                 </table><br>
     */
	this.fontStrikethru = false;
    /**
     *   @description  사용자가 입력한 컨트롤 데이터의 글자에 밑줄을 그을지 설정합니다.<br>
     *                 기본값 : false<br><br>
     *                 <table width="500">
     *                   <caption>fontBold Variable Value</caption>
     *                   <thead>
     *                      <tr>
     *                          <th align="left">Value</th>
     *                          <th align="left">Description</th>
     *                       </tr>
     *                    </thead>
     *                    <tbody>
     *                       <tr>
     *                          <td> true </td>
     *                          <td> 컨트롤 값의 글자에 밑줄을 긋습니다. </td>
     *                       </tr>
     *                       <tr>
     *                          <td> false </td>
     *                          <td> 컨트롤 값의 글자에 밑줄을 긋지 않습니다. </td>
     *                       </tr>
     *                 </table><br>
     */
	this.fontUnderline = false;
	this.fontColor = "#000000";
    /**
     *   @description  컨트롤에 도움말을 넣을지 설정합니다.<br>
     *                 기본값 : 없음<br><br>
     */
	this.toolTipText = "";
	
	this.oldbgcolor = "";
	this.oldcolor = "";
    
    // 드래그 드롭 관련 부분
    this.draggable	= false;
    this.droppable	= false;
    this.outerDroppable	= false;     
    this.hasDragStartEvent = false;	this.fncDragStartEvent = null;
    this.hasDragMoveEvent = false;	this.fncDragMoveEvent = null;
    this.hasDragEndEvent = false;	this.fncDragEndEvent = null;
    this.hasDragEnterEvent = false;	this.fncDragEnterEvent = null;
    this.hasDragOverEvent = false;	this.fncDragOverEvent = null;
    this.hasDragLeaveEvent = false;	this.fncDragLeaveEvent = null;
    this.hasDropEndEvent = false;	this.fncDropEndEvent = null;

    this.hasDragStartEvent = (typeof self[this.controlId + "_ondragstart"] != "undefined");
    if (this.hasChangeEvent){ this.fncDragStartEvent = new Function( "return function (event) { return " + this.controlId + "_ondragstart(event); }")(); }
    this.hasDragMoveEvent = (typeof self[this.controlId + "_ondragmove"] != "undefined");
    if (this.hasDragMoveEvent){ this.fncDragMoveEvent = new Function( "return function (event) { return " + this.controlId + "_ondragmove(event); }")(); }
    this.hasDragEndEvent = (typeof self[this.controlId + "_ondragend"] != "undefined");
    if (this.hasDragEndEvent){ this.fncDragEndEvent = new Function( "return function (event) { return " + this.controlId + "_ondragend(event); }")(); }

    this.hasDragEnterEvent = (typeof self[this.controlId + "_ondragenter"] != "undefined");
    if (this.hasDragEnterEvent){ this.fncDragEnterEvent = new Function( "return function (event, srcControlName, arrFiles, arrFileTypes) { return " + this.controlId + "_ondragenter(event, srcControlName, arrFiles, arrFileTypes); }")(); }
    this.hasDragOverEvent = (typeof self[this.controlId + "_ondragover"] != "undefined");
    if (this.hasDragOverEvent){ this.fncDragOverEvent = new Function( "return function (event, srcControlName, arrFiles, arrFileTypes) { return " + this.controlId + "_ondragover(event, srcControlName, arrFiles, arrFileTypes); }")(); }
    this.hasDragLeaveEvent = (typeof self[this.controlId + "_ondragleave"] != "undefined");
    if (this.hasDragLeaveEvent){ this.fncDragLeaveEvent = new Function( "return function (event, srcControlName, arrFiles, arrFileTypes) { return " + this.controlId + "_ondragleave(event, srcControlName, arrFiles, arrFileTypes); }")(); }
    this.hasDropEndEvent = (typeof self[this.controlId + "_ondropend"] != "undefined");
    if (this.hasDropEndEvent){ 
    	this.fncDropEndEvent = new Function( 
    			"return function (event, srcControlName, arrFiles, arrFileTypes, arrIsImage, arrIsText, arrIsSheet) " + 
    			        "{ " + 
    			           "return " + this.controlId + "_ondropend(event, srcControlName, arrFiles, arrFileTypes, arrIsImage, arrIsText, arrIsSheet); " + 
    			        "}"
        )(); 
    }
    
    this.hasValidateEvent = (typeof self[this.controlId + "_onvalidate"] != "undefined");
    if (this.hasValidateEvent) { this.fncValidateEvent = new Function( "return function (event) { return " + this.controlId + "_onvalidate(event); }")(); }
    
    
	if (tagObject){
    	var cssStyle = getStyle(this.tagObject);
    	var image = tagObject.getAttribute("image");
    	var className = tagObject.className;
    	
    	this.image = (image != null && image !== "") ? image : className.substring(0, className.indexOf(" "));
    	this.backColor = (cssStyle.backgroundColor ? cssStyle.backgroundColor : "#FFFFFF");
    	this.foreColor =(cssStyle.color ? cssStyle.color : "#000000");
    	this.visible = (cssStyle.display ? cssStyle.display != "none" : (cssStyle.left ? cssStyle.left != "-10000px" : true));
    	this.enabled = !(this.tagObject.disabled ? this.tagObject.disabled : this.tagObject.getAttribute("disabled"));
    	this.readOnly = (this.tagObject.readOnly ? this.tagObject.readOnly : this.tagObject.hasAttribute("readOnly"));
    	this.alignment = (cssStyle.textAlign ? cssStyle.textAlign : "left");
    	this.fontBold = (cssStyle.fontWeight == "bold");
    	this.fontItalic = (cssStyle.fontStyle == "italic"); 
    	this.fontName = (cssStyle.fontFamily ? cssStyle.fontFamily : "");
    	this.fontSize = (cssStyle.fontSize ? parseIntSize(cssStyle.fontSize) : 9);
    	this.fontStrikethru = (cssStyle.textDecoration == "line-through");
    	this.fontUnderline = (cssStyle.textDecoration == "underline");
    	this.fontColor = (cssStyle.color ? cssStyle : "#000000");
    	this.toolTipText = (this.tagObject.title ? this.tagObject.title : "");
    	this.zIndex = (cssStyle.zIndex ? cssStyle.zIndex : 0);
    	this.oldbgcolor = this.backColor;
    	this.oldcolor = this.fontColor;
    	
    	image = null; className = null;
    	cssStyle = null;

    	//Enabled가 false인 경우
    	if( !this.enabled ){
//    		this.tagObject.style.backgroundColor="#d2d0d0";
    		this.tagObject.classList.remove(this.image);
    		this.tagObject.classList.add(this.image+"-disabled");
        }
    	
        // Drag Drop 이벤트 선언부
        setEventHandler(this.tagObject, "dragstart",   control_DragStart);
        setEventHandler(this.tagObject, "drag",        control_Drag);
        setEventHandler(this.tagObject, "dragend",     control_DragEnd);

        setEventHandler(this.tagObject, "dragenter",   control_DragEnter);
        setEventHandler(this.tagObject, "dragover",    control_DragOver);
        setEventHandler(this.tagObject, "dragleave",   control_DragLeave);
        setEventHandler(this.tagObject, "drop",        control_Drop);
    } 
    /**
     *   @description  컨트롤에 표시문자열을 지정합니다.<br>
     *                 기본값 : 없음<br><br>
     */
	this.caption = "";
    /**`
     *   @description  tagObject의 태그 속성 객체입니다.<br>
     *                 컨트롤의 html 태그 속성값에 대한 설정을 할 수 있습니다<br><br>
     *   @example      this.tagObject.style.fontWeight = "bold";
     *                 this.tagObject.style.fontStyle = "italic";
     */
    this.style = "";  // EasyMaker에서 스타일 기능 추가시 사용
    this.tag = "";
    /**
     *   @description  사용자가 입력한 컨트롤 데이터에 대한 타입을 설정합니다.<br>
     *                 타입은 상수로 선언된 CHECKTYPE으로 설정합니다.<br>
     *                 기본값 : 0<br><br>
     */
    this.checkType = 0;
    /**
     *       @name           ControlBase#fncValidateEvent
     *       @event
     *       @description    컨트롤의 데이터, 상태등이 변경되었을 때 발생하는 사용자 이벤트 메소드입니다.<br>유저가 추가한 이벤트 코드를 실행하는 함수입니다.
     */
	this.dataBinds = [];     	// 데이터 링크된 콘트롤들 
	this.bindDataset = "";
	this.innerDataset = "";
	
	this.passEvent = false;		//사용자 이벤트 동작 여부(true:동작안함 / false:동작함)
};

ControlBase.prototype.setDataBind = function(){
	var args = Array.prototype.slice.call(arguments);
	var argCount = args.length;
	var dataset = null; var col = null; var codeCol = null;
	var bindInfo = null;
	
	if( argCount == 2 ){
		dataset = args[0];
		col = args[1];
		
		//예외처리
		if( typeof dataset != "string" || (typeof dataset == "string" && dataset.length == 0) ){
			args.clear(); args = null; col = null; dataset = null; //메모리 해제
			return;
		}
		if( typeof col != "string" || (typeof col == "string" && col.length == 0) ){
			args.clear(); args = null; col = null; dataset = null; //메모리 해제
			return;
		}
	}
	else if( argCount == 3 ){
		dataset = args[0];
		col = args[1];
		codeCol = args[2];
		
		//예외처리
		if( typeof dataset != "string" || (typeof dataset == "string" && dataset.length == 0) ){
			args.clear(); args = null; codeCol = null; col = null; dataset = null; //메모리 해제
			return;
		}
		if( typeof col != "string" ){
			args.clear(); args = null; codeCol = null; col = null; dataset = null; //메모리 해제
			return;
		}
		if( typeof codeCol != "string" ){
			args.clear(); args = null; codeCol = null; col = null; dataset = null; //메모리 해제
			return;
		}
	}
	else{
		args.clear(); args = null;
		return;
	}
	
	var regexp = /^ListBox[ABCD]{0,1}$/;
	var image = (regexp.test(this.image) ? "List1" : this.image);
	
	//바인드 정보 생성
	bindInfo = new BindInfo(dataset, col, image, this.controlName);
	
	//콤보 또는 리스트박스의 경우 내부값 연결 컬럼 설정
	if( codeCol != null && (typeof codeCol == "string" && codeCol.length > 0) )
		bindInfo.colId_value = codeCol;
	
	//컨트롤에 바인드 정보 설정
	//파라메터가 2개인 경우 : 연결데이터셋, 연결 컬럼
	if( argCount == 2 )
		this.dataBinds[dataset] = bindInfo;
	//파라메터가 3개인 경우 : 연결데이터셋, 내부값 연결 컬럼, 텍스트 연결 컬럼
	else if( argCount == 3 )
		this.dataBinds[dataset + "_" + col] = bindInfo;
	
	//데이터셋에 바인드 정보 설정
	dataSets[dataset].dataBinds[this.controlName] = bindInfo;
	
	//메모리 해제
	bindInfo = null; image = null; regexp = null;
	codeCol = null; col = null; dataset = null;
	args = null;
};

ControlBase.prototype.setInnerBind = function(){
	var args = Array.prototype.slice.call(arguments);
	var argCount = args.length;
	var dataset = null; var col = null; var codeCol = null;
	var bindInfo = null;
	
	if( argCount == 3 ){
		dataset = args[0];
		col = args[1];
		codeCol = args[2];
		
		//예외처리
		if( typeof dataset != "string" || (typeof dataset == "string" && dataset.length == 0) ){
			args.clear(); args = null; codeCol = null; col = null; dataset = null; //메모리 해제
			return;
		}
		if( typeof col != "string" ){
			args.clear(); args = null; codeCol = null; col = null; dataset = null; //메모리 해제
			return;
		}
		if( typeof codeCol != "string" ){
			args.clear(); args = null; codeCol = null; col = null; dataset = null; //메모리 해제
			return;
		}
	}
	else{
		args.clear(); args = null; //메모리 해제
		return;
	}
	
	var regexp = /^ListBox[ABCD]{0,1}$/;
	var image = (regexp.test(this.image) ? "List1" : this.image);
	
	//바인드 정보 생성
	bindInfo = new BindInfo(dataset, col, image, this.controlName);
	
	//콤보 또는 리스트박스의 경우 내부값 연결 컬럼 설정
	if( codeCol != null && (typeof codeCol == "string" && codeCol.length > 0) )
		bindInfo.colId_value = codeCol;
	
	//this.innerBinds[dataset + "_" + col] = bindInfo;
	
	//데이터셋에 바인드 정보 설정
	dataSets[dataset].innerBinds[this.controlName] = bindInfo;
	
	//메모리 해제
	bindInfo = null; image = null; regexp = null;
	codeCol = null; col = null; dataset = null;
	args = null;
};

//cellNum은 생략될 수 있다
/*
ControlBase.prototype.addLinkInfo = function(objectName, propertyName, cellNum){
	var newPropertyIndex = this.linkPropertyNames.length + 1;
	
	if (cellNum == undefined){
		this.linkPropertyNames[newPropertyIndex] = "" + objectName + "." + propertyName;
	} else {
		this.linkPropertyNames[newPropertyIndex] = cellNum + ":" + objectName + "." + propertyName;
	}
	return;
}

ControlBase.prototype.setLinkedProperties = function(value, cellNum, objectSeq){
	var objectName = "";
	var propertyName = "";
	
	for(var i=0; i < this.linkPropertyNames.length; i++){
		if (cellNum != undefined){
			var wCellNum = parseInt(this.linkPropertyNames[i].split(":")[0]);
			if (wCellNum != cellNum){
				continue;
			}
			objectName   = this.linkPropertyNames[i].split(".")[0].split(":")[1];
			propertyName = this.linkPropertyNames[i].split(".")[1];
		} else {
			objectName   = this.linkPropertyNames[i].split(".")[0];
			propertyName = this.linkPropertyNames[i].split(".")[1];
		}
		
		var wObject = objects[objectName];
		if (objectSeq != undefined){
			// 이벤트 없이 값의 변화만 유도
			wObject.recordset[objectSeq].properties[propertyName].value = value;
		} else {
			// 값의 변화후 후속작업까지 호출된다
			if (wObject.getValue(propertyName) != value){
				wObject.setValue(propertyName, value);
			}
		}
	}
	return;
}
*/

/**
*     @description  컨트롤의 배경색을 지정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param        backColor     {String}     <br> 배경색으로 지정할 컬러코드 값입니다.<br>컬러코드는 &로 시작하며 &를 포함하여 총 8자리입니다.
*     @return       배경색 지정에 성공하면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환하게 됩니다.
*     @example      var wControls = controls["base_1"];
*      //배경색 코드를 &HBCB0A8 로 지정합니다.
*      if( false == wControls.setBackColor("&HBCB0A8") ){
*           //배경색 지정에 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //에러 발생시 setBackColor 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/
ControlBase.prototype.setBackColor = function(backColor){
	// functionname : [Control.setBackColor]

	this.backColor = backColor;
	this.tagObject.style.backgroundColor = backColor;
	
	// 하위 테그들의 백칼러 조정
	for (var i = 0; i < this.tagObject.children.length;i++){
		childTag = this.tagObject.children[i];
		childTag.style.backgroundColor = backColor;
		for (var j = 0; j < childTag.children.length;j++){
			childTag.children[j].style.backgroundColor = backColor;
			
		}
	}
};

/**
*     @description  컨트롤의 전경색을 지정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param        foreColor     {String}      <br>전경색으로 지정할 컬러코드 값입니다.<br>컬러코드는 &로 시작하며 &를 포함하여 총 8자리입니다.
*     @return       전경색 지정에 성공하면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환하게 됩니다.
*     @example      var wControls = controls["base_1"];
*      //전경색 코드를 &HBCB0A8 로 지정합니다.
*      if( false == wControls.setForeColor("&HBCB0A8") ){
*           //전경색 지정에 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //에러 발생시 setForeColor 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/
ControlBase.prototype.setForeColor = function(foreColor){
	// functionname : [Control.setForeColor]

	this.foreColor = foreColor;
	this.tagObject.style.color = foreColor;
	
	// 하위 테그들의 글자색 조정
	for (var i = 0; i < this.tagObject.children.length;i++){
		childTag = this.tagObject.children[i];
		childTag.style.color = foreColor;
		for (var j = 0; j < childTag.children.length;j++){
			childTag.children[j].style.color = foreColor;
			
		}
	}
};

var _layerPopupBackgroundDiv = null;

/**
*     @description  컨트롤의 보이기 설정값을 지정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param        visible     {Boolean}       <br>true : 컨트롤을 화면상에 보입니다.<br>fasle : 컨트롤을 화면상에 보이지 않습니다.
*     @return       보이기 설정값 지정을 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*     @example      var wControls = controls["base_1"];
*      //보이기 설정값을 false로 지정하여 컨트롤을 숨깁니다.
*      if( false == wControls.setVisible(false) ){
*           //컨트롤 숨기기에 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //에러 발생시 setVisible 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/
ControlBase.prototype.setVisible = function(visible){
	// functionname : [Control.setVisible]

	if (this.visible == visible) return;
	this.visible = visible;

	var obj =  this.tagObject;
	var comp = obj.currentStyle ? obj.currentStyle : getComputedStyle(obj, null);
	
    if (("" + comp.position).toLowerCase() == "absolute" || ("" + comp.position).toLowerCase() == "relative"){
    	if (visible){
    		if (obj.style.left == "-10000px"){
    			obj.style.left = obj.getAttribute("xposition");
    		}
    	} else {
    		obj.setAttribute("xposition", obj.style.left);
    		obj.style.left = "-10000px";
    	}
    	this.tagObject.style.display = (visible ? "block" : "none");
    } else {
    	this.tagObject.style.display = (visible ? "inline" : "none");
    }
    
    var isFrameBoxType = false;
    try {isFrameBoxType = this instanceof FrameBox;} catch(e){}
	if (isFrameBoxType){
	    if (visible){
	    	if (this.controlName == "layerPopup"){
	    		_layerPopupBackgroundDiv = document.getElementsByName("_layerPopupBackgroundDiv")[0];
	    		if( _layerPopupBackgroundDiv ){
	    			_layerPopupBackgroundDiv.style.display = "block";	    			
	    			_layerPopupBackgroundDiv.style.zIndex = 9998;
	    			controls["layerPopup"].tagObject.zIndex = 9999;
	    		}
	    	}
	    	
	    	var contentObj = this.tagObject.querySelector(".content > div");
	    	if( contentObj != null && typeof contentObj != "undefined" ){
	    		var childList = contentObj.children;
	    		var childItem = null;
	    		var childCount = 0;
	    		var className = null;
	    		var control = null;
	    		var i = 0;
	    		
	    		for(i = 0, childCount = childList.length; i < childCount; i++, childItem = null, className = "", control = null){
	    			childItem = childList[i];
	    			className = ("" + childItem.getAttribute("class"));
	    			control = controls[("" + childItem.getAttribute("ctlname"))];
	    			
	    			if( className.indexOf("DataSheet") >= 0 ){
	    				if( control != null && typeof control != "undefined" ){
	    					if( typeof control.setPosition == "function" ) control.setPosition();
	    					if( typeof control.resize == "function" ) control.resize();
	    				}
	    			}
	    		}
	    		
	    		childList = null; contentObj = null;
	    	}
	    	
		    if (this.hasOpenEvent) {
		    	this.fncOpenEvent();
		    }
	    } else {
	    	if (this.controlName == "layerPopup"){
	    		_layerPopupBackgroundDiv = document.getElementsByName("_layerPopupBackgroundDiv")[0];
	    		if( _layerPopupBackgroundDiv ){
	    			_layerPopupBackgroundDiv.style.display = "none";	    			
	    			_layerPopupBackgroundDiv.style.zIndex = -10;
	    			controls["layerPopup"].tagObject.zIndex = "auto";
	    		}
	    	}
    	    if (this.hasCloseEvent) {
    	    	this.fncCloseEvent();
    	    }
	    }
	}
};

/**
*     @description  컨트롤의 전경색을 지정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param        foreColor     {String}      <br>전경색으로 지정할 컬러코드 값입니다.<br>컬러코드는 &로 시작하며 &를 포함하여 총 8자리입니다.
*     @return       전경색 지정에 성공하면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환하게 됩니다.
*     @example      var wControls = controls["base_1"];
*      //전경색 코드를 &HBCB0A8 로 지정합니다.
*      if( false == wControls.setForeColor("&HBCB0A8") ){
*           //전경색 지정에 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //에러 발생시 setForeColor 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/
ControlBase.prototype.setEnabled = function(enabled){
	// functionname : [Control.setEnabled]

	this.enabled = enabled;
	// 하위 테그들의 글자색 조정
    this.tagObject.disabled = !enabled;
	for (var i = 0; i < this.tagObject.children.length;i++){
		childTag = this.tagObject.children[i];
		childTag.disabled = !enabled;
		for (var j = 0; j < childTag.children.length;j++){
			childTag.children[j].disabled = !enabled;
			
		}
	}
	
	/**
	 * 2016-07-13 김재익
     * 콘트롤동작 투명도 조정 -> 배경색 조정
     */
	if (!enabled) {
		//this.tagObject.style.opacity = "0.6";
		//this.tagObject.style.filter = "Alpha(Opacity=60)";
		//this.oldbgcolor =this.tagObject.style.backgroundColor;
		//this.oldcolor= this.tagObject.style.color ;  		
//		this.tagObject.style.backgroundColor="#d2d0d0";
		this.tagObject.classList.remove(this.image);
		this.tagObject.classList.add(this.image+"-disabled");
		//this.tagObject.style.color="#f1f1f1";	
    } else {
    	//this.tagObject.style.opacity = "";
    	//this.tagObject.style.filter = "";
    	this.tagObject.style.backgroundColor =this.oldbgcolor;
    	this.tagObject.classList.remove(this.image+"-disabled");
    	this.tagObject.classList.add(this.image);
    	//this.tagObject.style.color = this.oldcolor;    	
    	
    }
};

ControlBase.prototype.setReadOnly = function(readOnly){
	// functionname : [Control.setReadOnly]
	
	this.readOnly = readOnly;
	
	if( typeof this.readOnly != "undefined" )
		this.tagObject.readOnly = readOnly;
	else{
		if( readOnly )
			this.tagObject.setAttribute("readOnly", "");
		else
			this.tagObject.removeAttribute("readOnly");
	}
};

/* 좌우로 정렬 
 * default :left, (left,right, center)
 */   
/**
*     @description  컨트롤의 데이터를 정렬합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param        alignment       {Boolean}       <br>"left" : 왼쪽정렬 합니다.<br>"right" : 오른쪽정렬 합니다.<br>"center" : 가운데정렬 합니다.
*     @return       데이터 정렬을 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*     @example      var wControls = controls["base_1"];
*      //데이터를 가운데정렬하기 위하여 "center"를 설정하였습니다.
*      if( false == wControls.setAlignment("center") ){
*           //데이터 정렬을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //에러 발생시 setAlignment 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/
ControlBase.prototype.setAlignment = function(alignment){
		// functionname : [Control.setAlignment]

	this.alignment = alignment;
    this.tagObject.style.textAlign = alignment;
};

/* 굵은 글씨체 
* default :normal, (bold,normal)
*/   
/**
*     @description  컨트롤 데이터의 글꼴 굵기를 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param        fontBold       {Boolean}        <br>true : 글꼴의 굵기를 굵게합니다.<br>false : 글꼴의 굵기를 굵게하지 않습니다.
*     @return       글꼴 굵기 설정을 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*     @example      var wControls = controls["base_1"];
*      //데이터 글꼴을 굵게하기 위하여 true를 설정하였습니다.
*      if( false == wControls.setFontBold(true) ){
*           //데이터의 글꼴 굵기 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //에러 발생시 setFontBold 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/
ControlBase.prototype.setFontBold = function(fontBold){
	// functionname : [Control.setFontBold]

	this.fontBold = fontBold;
    wValue = (fontBold ? "bold" : "normal");
    this.tagObject.style.fontWeight = wValue;
};

/* 기운 글씨체 
* default :normal, (italic,normal)
*/   
/**
*     @description  컨트롤 데이터의 글꼴 기울기를 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param        fontItalic      {Boolean}       <br>true : 글꼴을 기울게합니다.<br>false : 글꼴의 기울게하지 않습니다.
*     @return       글꼴 기울기 설정을 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*     @example      var wControls = controls["base_1"];
*      //데이터 글꼴을 기울게하기 위하여 true를 설정하였습니다.
*      if( false == wControls.setFontItalic(true) ){
*           //데이터의 글꼴 기울기 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //에러 발생시 setFontItalic 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/  
ControlBase.prototype.setFontItalic = function(fontItalic){
	// functionname : [Control.setFontItalic]

	this.fontItalic = fontItalic;
    wValue = (fontItalic ? "italic" : "normal");
    this.tagObject.style.fontStyle = wValue;
};

/* 글씨체 */   
/**
*     @description  컨트롤 데이터의 글씨체를 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param        fontName        {String}        <br>글씨체 명을 입력합니다.
*     @return       글씨체 설정을 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*     @example      var wControls = controls["base_1"];
*      //데이터의 글씨체를 "돋움체"로 설정하였습니다.
*      if( false == wControls.setFontName("돋움체") ){
*           //데이터의 글씨체 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //에러 발생시 setFontName 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/  
ControlBase.prototype.setFontName = function(fontName){
	// functionname : [Control.setFontName]

	this.fontName = fontName;
    this.tagObject.style.fontFamily = fontName;
};

/* 글씨크기 */   
/**
*     @description  컨트롤 데이터의 글씨 크기를 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param        fontSize        {Number}        <br>글씨체의 크기를 입력합니다.
*     @return       글씨 크기 설정을 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*     @example      var wControls = controls["base_1"];
*      //데이터의 글씨 크기를 15로 설정하였습니다.
*      if( false == wControls.setFontSize(15) ){
*           //데이터의 글씨체 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //에러 발생시 setFontSize 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/
ControlBase.prototype.setFontSize = function(fontSize){
	// functionname : [Control.setFontSize]

	this.fontSize = fontSize;
    this.tagObject.style.fontSize = fontSize + "pt";
};

/* 취소 글씨체 */   
/**
*     @description  컨트롤 데이터에 취소선을 그을지 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param        fontStrikethru      {Boolean}       <br>true : 데이터에 취소선을 긋습니다.<br>false : 데이터에 취소선을 긋지 않습니다.
*     @return       취소선 설정을 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*     @example      var wControls = controls["base_1"];
*      //데이터에 취소선을 긋습니다.
*      if( false == wControls.setFontStrikethru(true) ){
*           //데이터에 취소선 긋기를 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //에러 발생시 setFontStrikethru 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/
ControlBase.prototype.setFontStrikethru = function(fontStrikethru){
	// functionname : [Control.setFontStrikethru]

	this.fontStrikethru = fontStrikethru;
	if (fontStrikethru){
        this.tagObject.style.textDecoration = "line-through";
	} else {
        this.tagObject.style.textDecoration = "none";
	}
};

/* 밑줄 글씨체 */   
/**
*     @description  컨트롤 데이터에 밑줄을 그을지 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param        fontUnderline       {Boolean}       <br>true : 데이터에 밑줄을 긋습니다.<br>false : 데이터에 밑줄을 긋지 않습니다.
*     @return       밑줄 설정을 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*     @example      var wControls = controls["base_1"];
*      //데이터에 밑줄을 긋습니다.
*      if( false == wControls.setFontUnderline(true) ){
*           //데이터에 밑줄 긋기를 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //에러 발생시 setFontUnderline 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/
ControlBase.prototype.setFontUnderline = function(fontUnderline){
	// functionname : [Control.setFontUnderline]

	this.fontUnderline = fontUnderline;
	if (fontUnderline){
        this.tagObject.style.textDecoration = "underline";
	} else {
        this.tagObject.style.textDecoration = "none";
	}
};

/* 글자 색 */   
ControlBase.prototype.setFontColor = function(fontColor){
	// functionname : [Control.setFontColor]

	this.fontColor = fontColor ? fontColor : "#000000";
	if (fontColor){
        this.tagObject.style.color = fontColor;
	} else {
        this.tagObject.style.color = "#000000";
	}
};

/**
*     @description  컨트롤에 사용자 도움말(말풍선)을 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param        toolTipText         {String}        컨트롤에 설정할 도움말입니다.
*     @return       도움말 설정을 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*     @example      var wControls = controls["base_1"];
*      //도움말 "도움말 입니다."을 추가합니다.
*      if( false == wControls.setToolTipText("도움말 입니다.") ){
*           //도움말 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //에러 발생시 setFontUnderline 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/
/* 도움말 */   
ControlBase.prototype.setToolTipText = function(toolTipText){
	// functionname : [Control.setToolTipText]

	this.toolTipText = toolTipText;
	
	// 하위 테그들의 도움말 조정
	this.tagObject.title = toolTipText;
	for (var i = 0; i < this.tagObject.children.length;i++){
		childTag = this.tagObject.children[i];
		childTag.title = toolTipText;
		for (var j = 0; j < childTag.children.length;j++){
			childTag.children[j].title = toolTipText;
		}
	}
};

/* 표시문자열 */   
/**
*     @description  컨트롤의 표시문자열을 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param        caption         {String}        컨트롤의 표시문자열입니다.
*     @return       표시문자열 설정을 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*     @example      var wControls = controls["base_1"];
*      //컨트롤의 표시문자열을 "목록보기"로 변경합니다.
*      if( false == wControls.setCaption("목록보기") ){
*           //표시문자열 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //에러 발생시 setCaption 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/
ControlBase.prototype.setCaption = function(caption){
	// functionname : [Control.setCaption]

	this.caption = caption;
    this.tagObject.innerText = caption;
};

/**
*     @description  컨트롤에 넣을 주석을 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param        tag         {String}        컨트롤의 주석입니다.
*     @return       주석 설정을 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*     @example      var wControls = controls["base_1"];
*      //주석을 "목록보기로 변경합니다.
*      if( false == wControls.setTag("목록을 보는 컨트롤") ){
*           //주석 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //에러 발생시 setTag 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/
ControlBase.prototype.setTag= function(tag){
	// functionname : [Control.setTag]

	this.tag = tag;
	return;
};

/**
*     @description  체크 조건에 의해 컨트롤의 데이터를 검사합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @return       체크 조건에 의한 검사 결과가 맞다면 true를 반환합니다.<br>검사 결과가 맞지 않는다면 false를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*     @example      var wControls = controls["base_1"];
*      //컨트롤의 데이터를 검사합니다.
*      if( false == wControls.checkError() ){
*           //컨트롤의 데이터가 체크조건에 맞지 않습니다. 에러처리 코드를 입력해주세요.
*           //검사결과가 맞지 않거나 에러 발생시 checkError 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControls.errorMsg 필드로 확인할 수 있습니다.
*      }
*/
ControlBase.prototype.checkError = function(){
	// functionname : [Control.checkError]
	
	var err = 0;
	var wText = this.value;
	
	if( ("" + wText).length == 0 ) return true;
	
	try{
		//데이타의 속성에 비추어 오류를 점검한다
		switch( this.checkType ){
			case this.CHECKTYPE.YYYY: 
				if( hasHangul(wText) )		throw 8;
				if( !CheckYear(wText) )		throw 3;
				break;
			case this.CHECKTYPE.YM: 
				if( hasHangul(wText) )		throw 8;
				if( !CheckMonth(wText) )	throw 2;
				break;
			case this.CHECKTYPE.YMD: 
				if( hasHangul(wText) )		throw 8;
				if( !CheckDate(wText) )		throw 1;
				break;
			case this.CHECKTYPE.RESINUM: 
				if( hasHangul(wText) ) 			throw 8;
				if( !IsResidentNumber(wText) )	throw 4;
				break;
			case this.CHECKTYPE.TAXNUM: 
				if( hasHangul(wText) ) 		throw 8; 
				if( !IsTaxNumber(wText) ) 	throw 5; 
				break;
			case this.CHECKTYPE.POSTNUM: 
				if( hasHangul(wText) ) 		throw 8;
				if( wText.length < 5 
					|| wText.length > 6 )	throw 6;  
				break;
			case this.CHECKTYPE.IMEMODE:
				break;
			case this.CHECKTYPE.ENGLNUM:
			case this.CHECKTYPE.PASSWORD:
				if( hasHangul(wText) )		throw 8; 
				break;
			case this.CHECKTYPE.AMOUNT:
			case this.CHECKTYPE.NUMBER:
				if( hasHangul(wText) )		throw 8; 
				if( !("" + wText).isNum() )	throw 9; 
				break;
		}
	    
		// 이 자리에 산식체크로직이 들어간다
		// 사용자 코딩 추가영역을 호출한다

		if (this.hasValidateEvent){
			var result = this.fncValidateEvent();
			if( result === false )
				return false;
		}

		return true;
    }
	catch(err){
		switch(err){
			case 1:	
				alert(getText("message_controlbase_001", "날짜입력이 틀렸습니다. 날짜를 지우거나 고치십시요"));
				break;
			case 2:
				alert(getText("message_controlbase_002", "년월입력이 틀렸습니다. 년월를 지우거나 고치십시요"));
				break;
			case 3:
				alert(getText("message_controlbase_003", "년도입력이 틀렸습니다. 년도를 지우거나 고치십시요"));
				break;
			case 4:
				alert(getText("message_controlbase_004", "주민등록번호가 맞지 않습니다. 주민등록번호를 지우거나 고치십시요"));
				break;
			case 5:
				alert(getText("message_controlbase_005", "사업자등록번호가 맞지 않습니다. 사업자등록번호를 지우거나 고치십시요"));
				break;
			case 6:
				alert(getText("message_controlbase_006", "우편번호입력이 틀렸습니다. 우편번호를 지우거나 고치십시요"));
				break;
			case 8:
				alert(getText("message_controlbase_007", "한글이 입력되었습니다."));
				break;
			case 9:
				alert(getText("message_controlbase_008", "금액형태에 맞지 않습니다."));
				break;
			default:
				alert(getText("message_controlbase_009", "위치: ControlBase.checkError\n에러번호:{0}\n에러정보:\n{1}", [err.number, err.description]));
		}
	}
	
	return false;
};
/**
*     @description	미결
*     @param	{number}	zIndex
*     @return	{String}
*     @example	미결
*/
ControlBase.prototype.setZIndex = function(zIndex){
	// functionname : [Control.setZIndex]
	
	var wReturn = false;
	var oldZIndex = this.zIndex;
	
	try{
		this.zIndex = zIndex;
		this.tagObject.style.zIndex = zIndex;
		wReturn = true;
	}
	catch(err){
		this.zIndex = oldZIndex;
	}
	
	return wReturn;
};

/**
*     @description	미결
*     @param	{object}	zOrder
*     @return	{string}
*     @example	미결
*/
ControlBase.prototype.setZOrder = function(zOrder){
	// functionname : [Control.setZOrder]
	
	return this.setZIndex(zOrder);
};

/**
 *     @description	미결
 *     @param	{string}	className
 *     @return	{void}
 *     @example	미결
 */
ControlBase.prototype.addClass = function(className){
	// functionname : [Control.addClass]
	
	//예외처리
	if( typeof className != "string" )	//클래스 명이 문자열이 아닌 경우 예외처리함
		return;
	
	var classStr = null;
	var classItems = null;
	
	//클래스 속성 구함
	classStr = this.tagObject.getAttribute("class");
	
	//기존 클래스 속성이 없는 경우
	if( classStr == null ){
		classStr = className;
	}
	//기존 클래스 속성이 있는 경우 
	else{
		//클래스 속성 양 끝 공백 제거
		classStr = ("" + classStr).replace(/(^\s*)|(\s*$)/g, "");
		//공백 구분 문자열로 배열 생성
		classItems = classStr.split(" ");
		
		//클래스 속성 문자열에 클래스명이 없다면 추가
		if( classItems.indexOf(className) < 0 )
			classItems.push(className);
		
		//메모리 해제
		classStr = null;
		
		//클래스 문자열 생성
		classStr = classItems.join(" ").replace(/\s+/g, " ");
	}
	
	//클래스 명 사이의 공백 중 2개 이상 띄어진 공백이 있는 경우 1개 공백으로 바꿔 클래스 속성 설정
	this.tagObject.setAttribute("class", classStr);
	
	//메모리 해제
	classItems.clear(); classItems = null;
	classStr = null;
};

/**
 *     @description	미결
 *     @param	{string}	className
 *     @return	{void}
 *     @example	미결
 */
ControlBase.prototype.removeClass = function(className){
	// functionname : [Control.addClass]
	
	//예외처리
	if( typeof className != "string" )	//클래스 명이 문자열이 아닌 경우 예외처리함
		return;

	//클래스 속성 구함
	var classStr = this.tagObject.getAttribute("class");
	var classItems = null;
	var classIndex = 0;
	
	//기존 클래스 속성이 있는 경우에만 클래스를 제거할 수 있음
	if( classStr != null ){
		//클래스 속성 양 끝 공백 제거 후, 클래스 명 사이 공백 중 2개 이상 골백을 1개 공백으로 변환
		classStr = ("" + classStr).replace(/(^\s*)|(\s*$)/g, "").replace(/\s+/g, " ");
		//클래스 구분자인 1개 공백을 기준으로 배열로 변환
		classItems = classStr.split(" ");
		//클래스명 체크
		classIndex = classItems.indexOf(className);
		
		//클래스가 있는 경우
		if( classIndex >= 0 ){
			//클래스 제거
			classItems[classIndex] = "";
			//메모리 해제
			classStr = null;
			
			//클래스 배열을 다시 구분자인 1개 공백으로 합침
			classStr = classItems.join(" ").replace(/\s+/g, " ").replace(/(^\s*)|(\s*$)/g, "");
			
			//클래스 설정
			this.tagObject.setAttribute("class", classStr);
		}
		
		//메모리 해제
		classItems = null;
		classStr = null;
	}
};

// 드래그 드롭 관련 부분
ControlBase.prototype.setDraggable = function(draggable){
	// functionname : [Control.setDraggable]
	
	this.tagObject.setAttribute("draggable", "true");
	return this.draggable = draggable;
};
//드래그 드롭 관련 부분
ControlBase.prototype.setDroppable = function(droppable){
	// functionname : [Control.setDroppable]
	return this.droppable = droppable;
};
//드래그 드롭 관련 부분
ControlBase.prototype.setOuterDroppable = function(outerDroppable){
	// functionname : [Control.setOuterDroppable]
	return this.outerDroppable = outerDroppable;
};

// 드래그쪽 이벤트 호출
function control_DragStart(e){
	// functionname : [control_DragStart]

	e = window.event || e;
    var em = e.srcElement ? e.srcElement : e.target;
    var control = getControlByTag(em);
    
    if (!control.draggable) return false;
    
    e.dataTransfer.setData("text", control.controlName);
    
    if (control.hasChangeEvent){
    	control.fncDragStartEvent(e);
    	var result = control.fncDragStartEvent(e);
    	if (typeof result != "undefined" && result === false) return false;
    }
    
	return true;
};

function control_Drag(e){
	// functionname : [control_Drag]
	
    e = window.event || e;
    var em = e.srcElement ? e.srcElement : e.target;
    var control = getControlByTag(em);
    
    if (!control.draggable) return false;
    
    if (control.hasDragMoveEvent){
    	control.fncDragMoveEvent(e);
    }
    
	return true;
};

function control_DragEnd(e){
	// functionname : [control_DragEnd]
	
	     e = window.event || e;
    var em = e.srcElement ? e.srcElement : e.target;
    var control = getControlByTag(em);
    
    if (!control.draggable) return false;
    
    if (control.hasDragEndEvent){
    	control.fncDragEndEvent(e);
    }
    
	return true;
};

//드롭쪽 이벤트 호출
function control_DragEnter(e){
	// functionname : [control_DragEnter]
	
    e = window.event || e;
    var em = e.srcElement ? e.srcElement : e.target;
    var control = getControlByTag(em);
        
    var fileLength = e.dataTransfer.files.length;
    if (fileLength > 0){
    	if (!control.outerDroppable) return false;
        var arrFiles = e.dataTransfer.files;
        var arrFileTypes = [];
        
        for (var i=0; i < fileLength; i++){
        	arrFileTypes[i] = e.dataTransfer.files[i].type;
        }
        
        if (control.hasDragEnterEvent){
        	control.fncDragEnterEvent(e, "", arrFiles, arrFileTypes);
        }    
    } else {
    	if (!control.droppable) return false;
        var srcControlName = e.dataTransfer.getData("text");
        
        if (control.hasDragEnterEvent){
        	control.fncDragEnterEvent(e, srcControlName, [], []);
        }    
    }
	
	return true;
};
function control_DragOver(e){
	// functionname : [control_DragOver]
	
    e = window.event || e;
    e.preventDefault();
    
    var em = e.srcElement ? e.srcElement : e.target;
    var control = getControlByTag(em);
    
    var fileLength = e.dataTransfer.files.length;
    if (fileLength > 0){
    	if (!control.outerDroppable) return false;
        var arrFiles = e.dataTransfer.files;
        var arrFileTypes = [];
        
        for (var i=0; i < fileLength; i++){
        	arrFileTypes[i] = e.dataTransfer.files[i].type;
        }
        
        if (control.hasDragOverEvent){
        	control.fncDragOverEvent(e, "", arrFiles, arrFileTypes);
        }    
    } else {
    	if (!control.droppable) return false;
        var srcControlName = e.dataTransfer.getData("text");
        
        if (control.hasDragOverEvent){
        	control.fncDragOverEvent(e, srcControlName, [], []);
        }    
    }
	
	return true;
};
function control_DragLeave(e){
	// functionname : [control_DragLeave]
	
    e = window.event || e;
    var em = e.srcElement ? e.srcElement : e.target;
    var control = getControlByTag(em);

    var fileLength = e.dataTransfer.files.length;
    if (fileLength > 0){
    	if (!control.outerDroppable) return false;
        var arrFiles = e.dataTransfer.files;
        var arrFileTypes = [];
        
        for (var i=0; i < fileLength; i++){
        	arrFileTypes[i] = e.dataTransfer.files[i].type;
        }
        
        if (control.hasDragLeaveEvent){
        	control.fncDragLeaveEvent(e, "", arrFiles, arrFileTypes);
        }    
    } else {
    	if (!control.droppable) return false;
        var srcControlName = e.dataTransfer.getData("text");
        
        if (control.hasDragLeaveEvent){
        	control.fncDragLeaveEvent(e, srcControlName, [], []);
        }    
    }

	return true;
};
function control_Drop(e){
	// functionname : [control_Drop]
	
    e = window.event || e;
    e.preventDefault();
    
    
    var em = e.srcElement ? e.srcElement : e.target;
    var control = getControlByTag(em);

    var fileLength = e.dataTransfer.files.length;
    if (fileLength > 0){
    	if (!control.outerDroppable) return false;
        var arrFiles = e.dataTransfer.files;
        var arrFileTypes = [];
        var arrIsImage = [];
        var arrIsText = [];
        var arrIsSheet = [];
          
        
        for (var i=0; i < fileLength; i++){
        	var fileType = e.dataTransfer.files[i].type;
        	arrFileTypes[i] = fileType;
        	arrIsImage[i] = fileType.match(/image.*/);
        	arrIsText[i]  = fileType.match(/text.*/);
        	arrIsSheet[i] = fileType.match(/application.*.ms-excel/) || 
        	                fileType.match(/application.*.sheet/);
        }
        
        if (control.hasDropEndEvent){
        	control.fncDragLeaveEvent(e, "", arrFiles, arrFileTypes, arrIsImage, arrIsText, arrIsSheet);
        }
        
        // 기본 드롭동작 수행
        _defaultDropTask_outer(arrFiles, arrFileTypes, arrIsImage, arrIsText, arrIsSheet);

    } else {
    	if (!control.droppable) return false;
        var srcControlName = e.dataTransfer.getData("text");
        var targetControlName = control.controlName;
        var optionItem = null;
        var result = false;
        
        if (control.hasDragLeaveEvent){
        	var result = control.fncDropEndEvent(e, srcControlName, [], [], [], [], []);
        	if (typeof result != "undefined" && result === false) return false;
        }  
        
        // 기본 드롭동작 수행
        _defaultDropTask_inner(e, srcControlName, targetControlName, optionItem);
        
    }
	return true;
};

// 드롭시 정해진 동작 
function _defaultDropTask_inner(e, srcControlName, targetControlName, optionItem){
	
	var srcControl    = controls[srcControlName];
	var targetControl = controls[targetControlName];
	
	var srcElement    = srcControl.tagObject;
	var targetElement = targetControl.tagObject;
		
	var data = typeof Label != "undefined" && srcControl instanceof Label ? { text: srcControl.value }:
		       typeof TextBox != "undefined" && srcControl instanceof TextBox && !srcControl.multiLine  ? { text: srcElement.value.substring(srcElement.selectionStart, srcElement.selectionEnd)} : 
			   typeof TextBox != "undefined" && srcControl instanceof TextBox && srcControl.multiLine  ? { text: srcElement.value} : 
			   typeof ComboBox != "undefined" && srcControl instanceof ComboBox ? {value: srcControl.value, text: srcControl.text} : 
			   typeof ListBox != "undefined" && srcControl instanceof ListBox && srcControl.listType != LISTBOX_TYPE_DATASELECT ? { value: srcControl.value, text: srcControl.text} : 
			   typeof ListBox != "undefined" && srcControl instanceof ListBox && srcControl.listType != LISTBOX_TYPE_DATASELECT ? { value: optionItem.value, text: optionItem.text } : 
			   typeof CheckBox != "undefined" && srcControl instanceof CheckBox ? {value: srcControl.value, text: srcControl.caption} : 
			   typeof OptionButton != "undefined" && srcControl instanceof OptionButton ? {value: srcControl.value, text: srcControl.caption} : 
			   typeof PictureBox != "undefined" && srcControl instanceof PictureBox ? {src: srcElement.getElementsByTagName("IMG")[0].src} : 
			   typeof ListSheet != "undefined" && srcControl instanceof ListSheet ? {src: srcElement.getValue()} : 
			   typeof TextBox2 != "DataSheet" && srcControl instanceof DataSheet ? {src: srcElement.getValue()} : 
			   typeof TreeView != "undefined" && srcControl instanceof TreeView ? {value: srcControl.selectedItem.value, text: srcControl.selectedItem.text} : 
			   typeof Linker != "undefined" && srcControl instanceof Linker ? {src: srcControl.url} : 
			   {};
			   
	if (typeof Label != "undefined" && targetControl instanceof Label){
		if (typeof data.text != "undefined"){
			targetControl.setCaption(data.text);
		} else if (typeof data.value != "undefined"){
			targetControl.setCaption(data.value);
		} else if (typeof data.src != "undefined"){
			targetControl.setCaption(data.src);
		} 
		
	} else if (typeof TextBox != "undefined" && targetControl instanceof TextBox){
		if (typeof data.text != "undefined"){
			targetControl.setValue(data.text);
		} else if (typeof data.value != "undefined"){
			targetControl.setValue(data.value);
		} else if (typeof data.src != "undefined"){
			targetControl.setValue(data.src);
		} 
		
	} else if (typeof ComboBox != "undefined" && targetControl instanceof ComboBox){
		if (typeof data.value != "undefined"){
			targetControl.setValue(data.value);
		} else if (typeof data.text != "undefined"){
			targetControl.setText(data.text);
		} 
		
	} else if (typeof ListBox != "undefined" && targetControl instanceof ListBox  && targetControl.listType != LISTBOX_TYPE_DATASELECT){
		if (typeof data.value != "undefined"){
			targetControl.setValue(data.value);
		} else if (typeof data.text != "undefined"){
			targetControl.setText(data.text);
		} 
		
	} else if (typeof ListBox != "undefined" && targetControl instanceof ListBox  && targetControl.listType == LISTBOX_TYPE_DATASELECT){
		if (typeof data.text != "undefined" && typeof data.value != "undefined"){
			targetControl.addItem(data.text, data.value);
		} else if (typeof data.value != "undefined"){
			targetControl.addItem(data.value, data.value);
		} else if (typeof data.text != "undefined"){
			targetControl.addItem(data.text, data.text);
		} 
		
	} else if (typeof CheckBox != "undefined" && targetControl instanceof CheckBox){
		if (typeof data.value != "undefined"){
			targetControl.setValue(data.value);
		}
		
	} else if (typeof OptionButton != "undefined" && targetControl instanceof OptionButton){
		if (typeof data.value != "undefined"){
			targetControl.setValue(data.value);
		}
		
	} else if (typeof PictureBox != "undefined" && targetControl instanceof PictureBox){
		if (typeof data.url != "undefined"){
			targetControl.setValue(data.url);
		}
		
	} else if (typeof ListSheet != "undefined" && targetControl instanceof ListSheet){
		if (typeof data.value != "undefined"){
			targetControl.setValue(data.value);
		}
		
	} else if (typeof DataSheet != "undefined" && targetControl instanceof DataSheet){
		if (typeof data.value != "undefined"){
			targetControl.setValue(data.value);
		}
		
	} else if (typeof DataSheet != "Linker" && targetControl instanceof Linker){
		if (typeof data.url != "undefined"){
			targetControl.setValue(data.url);
		}
        if (typeof data.text != "undefined"){
			targetControl.setCaption(data.text);
		} 		
		
	} else if (typeof DataSheet != "IFrame" && targetControl instanceof Linker){
		if (typeof data.url != "undefined"){
			targetControl.setValue(data.url);
		}
	}
	
	return;
};

function _defaultDropTask_outer(arrFiles, arrFileTypes, arrIsImage, arrIsText, arrIsSheet){
	
	// 소스와 타겟별 기본 동작을 입힌다.
	/*
       "text/plain", 
       "application/octet-stream", 
       "application/microdata+json", 
       "text/uri-list",
       "application/vnd.ms-excel", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
       "application/msword", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
       "application/vnd.ms-powerpoint"
       "audio/x-ms-wma"
	 * */
	return;
};
var turnOffYearSpan = false;     // true = Only show This Year and Next, false = show +/- 5 years
var weekStartsOnSunday = false;  // true = Start the week on Sunday, false = start the week on Monday

var calendar_display_time = true;


var todayStringFormat = getText("message_calendar_001", "오늘 날짜 : [year]년[monthString]월[day]일  [todayString]");
var pathToImages = getContextPath() + "/winnersoft/images/calendar/";	

var speedOfSelectBoxSliding = 200;	
var intervalSelectBox_minutes = 5;	

var calendar_offsetTop = 0;		
var calendar_offsetLeft = 0;	
var calendarDiv = false;
var calendarMMDiv = false;
var MSIE = false;
var Opera = false;
var WTagId='';
var CType = 1;
if(navigator.userAgent.indexOf('MSIE')>=0 && navigator.userAgent.indexOf('Opera')<0)MSIE=true;
if(navigator.userAgent.indexOf('Opera')>=0)Opera=true;

		var monthArray = [
		                  getText("message_calendar_002", '1월'),
		                  getText("message_calendar_003", '2월'),
		                  getText("message_calendar_004", '3월'),
		                  getText("message_calendar_005", '4월'),
		                  getText("message_calendar_006", '5월'),
		                  getText("message_calendar_007", '6월'),
		                  getText("message_calendar_008", '7월'),
		                  getText("message_calendar_009", '8월'),
		                  getText("message_calendar_010", '9월'),
		                  getText("message_calendar_011", '10월'),
		                  getText("message_calendar_012", '11월'),
		                  getText("message_calendar_013", '12월')];
		var monthArrayShort = ['1','2','3','4','5','6','7','8','9','10','11','12'];
		var dayArray = [
		                getText("message_calendar_014", '일'),
		                getText("message_calendar_015", '월'),
		                getText("message_calendar_016", '화'),
		                getText("message_calendar_017", '수'),
		                getText("message_calendar_018", '목'),
		                getText("message_calendar_019", '금'),
		                getText("message_calendar_020", '토')];
		var weekString = getText("message_calendar_021", '주');
		var todayString = '';

if (weekStartsOnSunday) {
   var tempDayName = dayArray[6];
   for(var theIx = 6; theIx > 0; theIx--) {
      dayArray[theIx] = dayArray[theIx-1];
   }
   dayArray[0] = tempDayName;
}



var daysInMonthArray = [31,28,31,30,31,30,31,31,30,31,30,31];
var currentMonth;
var currentYear;
var currentHour;
var currentMinute;
var calendarContentDiv;
var returnDateTo;
var returnFormat;
var activeSelectBoxMonth;
var activeSelectBoxYear;
var activeSelectBoxHour;
var activeSelectBoxMinute;

var iframeObj = false;
var iframeObj2 =false;

/**
 * @description	미결
 * @param		{String}	where2fixit
 * @returns		{Undefined}
 * @example		미결
 */
function EIS_FIX_EI1(where2fixit)
{

		if(!iframeObj2)return;
		iframeObj2.style.display = 'block';
		iframeObj2.style.height =document.getElementById(where2fixit).offsetHeight+1;
		iframeObj2.style.width=document.getElementById(where2fixit).offsetWidth;
		iframeObj2.style.left=getleftPos(document.getElementById(where2fixit))+1-calendar_offsetLeft;
		iframeObj2.style.top=getTopPos(document.getElementById(where2fixit))-document.getElementById(where2fixit).offsetHeight-calendar_offsetTop;
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function EIS_Hide_Frame()
{		
	if(iframeObj2)iframeObj2.style.display = 'none';};
var returnDateToYear;
var returnDateToMonth;
var returnDateToDay;
var returnDateToHour;
var returnDateToMinute;

var inputYear;
var inputMonth;
var inputDay;
var inputHour;
var inputMinute;
var calendarDisplayTime = false;

var selectBoxHighlightColor = '#D60808'; 
var selectBoxRolloverBgColor = '#ffffff'; 

var selectBoxMovementInProgress = false;
var activeSelectBox = false;

/**
 * @description	미결
 * @returns		{Boolean}
 * @example		미결
 */
function cancelCalendarEvent()
{
	return false;
};
/**
 * @description	미결
 * @param		{Number}	inputYear
 * @returns		{Undefined}
 * @example		미결
 */
function isLeapYear(inputYear)
{
	if(inputYear%400==0||(inputYear%4==0&&inputYear%100!=0)) return true;
	return false;

};
var activeSelectBoxMonth = false;
var activeSelectBoxDirection = false;

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function highlightMonthYear()
{
	if(activeSelectBoxMonth)activeSelectBoxMonth.className='';
	activeSelectBox = this;


	if(this.className=='monthYearActive'){
		this.className='';
	}else{
		this.className = 'monthYearActive';
		activeSelectBoxMonth = this;
	}

	if(this.innerHTML.indexOf('-')>=0 || this.innerHTML.indexOf('+')>=0){
		if(this.className=='monthYearActive')
			selectBoxMovementInProgress = true;
		else
			selectBoxMovementInProgress = false;
		if(this.innerHTML.indexOf('-')>=0)activeSelectBoxDirection = -1; else activeSelectBoxDirection = 1;

	}else selectBoxMovementInProgress = false;

};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function showMonthDropDown()
{
	if(document.getElementById('monthDropDown').style.display=='block'){
		document.getElementById('monthDropDown').style.display='none';
				EIS_Hide_Frame();
	}else{
		document.getElementById('monthDropDown').style.display='block';
		document.getElementById('yearDropDown').style.display='none';
		document.getElementById('hourDropDown').style.display='none';
		document.getElementById('minuteDropDown').style.display='none';
			if (MSIE)
		{ EIS_FIX_EI1('monthDropDown')}

	}
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function showYearDropDown()
{    
	if(document.getElementById('yearDropDown').style.display=='block'){
		document.getElementById('yearDropDown').style.display='none';
				EIS_Hide_Frame();
	}else{
		document.getElementById('yearDropDown').style.display='block';
		document.getElementById('monthDropDown').style.display='none';
		document.getElementById('hourDropDown').style.display='none';
		document.getElementById('minuteDropDown').style.display='none';
			if (MSIE)
		{ EIS_FIX_EI1('yearDropDown')}


	}

};
/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function showHourDropDown()
{
	if(document.getElementById('hourDropDown').style.display=='block'){
		document.getElementById('hourDropDown').style.display='none';

				EIS_Hide_Frame();
	}else{
		document.getElementById('hourDropDown').style.display='block';
		document.getElementById('monthDropDown').style.display='none';
		document.getElementById('yearDropDown').style.display='none';
		document.getElementById('minuteDropDown').style.display='none';
				if (MSIE)
		{ EIS_FIX_EI1('hourDropDown')}

	}

};
/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function showMinuteDropDown()
{
	if(document.getElementById('minuteDropDown').style.display=='block'){
		document.getElementById('minuteDropDown').style.display='none';

				EIS_Hide_Frame();
	}else{
		document.getElementById('minuteDropDown').style.display='block';
		document.getElementById('monthDropDown').style.display='none';
		document.getElementById('yearDropDown').style.display='none';
		document.getElementById('hourDropDown').style.display='none';
				if (MSIE)
		{ EIS_FIX_EI1('minuteDropDown')}

	}

};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function selectMonth()
{
	document.getElementById('calendar_month_txt').innerHTML = this.innerHTML
	currentMonth = this.id.replace(/[^\d]/g,'');

	document.getElementById('monthDropDown').style.display='none';
	//// fix for EI frame problem on time dropdowns 09/30/2006
				EIS_Hide_Frame();
	for(var no=0;no<monthArray.length;no++){
		document.getElementById('monthDiv_'+no).style.color='';
	}
	this.style.color = selectBoxHighlightColor;
	activeSelectBoxMonth = this;
	writeCalendarContent();

};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function selectMinute()
{
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function selectYear()
{
	document.getElementById('calendar_year_txt').innerHTML = this.innerHTML
	currentYear = this.innerHTML.replace(/[^\d]/g,'');
	document.getElementById('yearDropDown').style.display='none';
				EIS_Hide_Frame();
	if(activeSelectBoxYear){
		activeSelectBoxYear.style.color='';
	}
	activeSelectBoxYear=this;
	this.style.color = selectBoxHighlightColor;
	writeCalendarContent();

};
/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
//150918
//좌우측버튼 클릭시 월변경처리
function switchMonth()
{

	if(this.src.indexOf('left')>=0){
		if(CType == 1){
			currentMonth=currentMonth-1;;
			if(currentMonth<0){
				currentMonth=11;
				currentYear=currentYear-1;
			}
		}else if(CType == 2){
			currentYear=currentYear-1;
		}
	}else{
		if(CType == 1){		
			currentMonth=currentMonth+1;;
			if(currentMonth>11){
				currentMonth=0;
				currentYear=currentYear/1+1;
			}
		}else if(CType == 2){
			currentYear=currentYear/1+1;
		}
	}

	//달력만들기 실행
	writeCalendarContent();
};

/**
 * @description	미결
 * @returns		{Object}
 * @example		미결
 */
function createMonthDiv(){
	var div = document.createElement('DIV');
	div.className='monthYearPicker';
	div.id = 'monthPicker';
	for(var no=0;no<monthArray.length;no++){
		var subDiv = document.createElement('DIV');
		subDiv.innerHTML = monthArray[no];
		subDiv.onmouseover = highlightMonthYear;
		subDiv.onmouseout = highlightMonthYear;
		subDiv.onclick = selectMonth;
		subDiv.id = 'monthDiv_' + no;
		subDiv.style.width = '37px';
    //20110404 추가
    //  	subDiv.style.cssText ='float:left;	margin-right:1px;';	
    subDiv.style.cssText='float:none;	clear:both;		padding:1px;	margin:1px;		cursor:pointer;';
		subDiv.onselectstart = cancelCalendarEvent;
		div.appendChild(subDiv);
		if(currentMonth && currentMonth==no){
			subDiv.style.color = selectBoxHighlightColor;
			activeSelectBoxMonth = subDiv;
		}
	}
	return div;
};

/**
 * @description	미결
 * @name		calendar#changeSelectBoxYear
 * @event		
 * @param		{Object}	inputObj
 * @returns		{Undefined}
 * @example		미결
 */
function changeSelectBoxYear(e,inputObj)
{
	if(!inputObj)inputObj =this;
	var yearItems = inputObj.parentNode.getElementsByTagName('DIV');
	if(inputObj.innerHTML.indexOf('-')>=0){
		var startYear = yearItems[1].innerHTML/1 -1;
		if(activeSelectBoxYear){
			activeSelectBoxYear.style.color='';
		}
	}else{
			var startYear = "";
		if (inputObj.name == "up") 
			startYear = yearItems[1].innerHTML/1 -1;
		else
			startYear = yearItems[1].innerHTML/1 +1;
			
		if(activeSelectBoxYear){
			activeSelectBoxYear.style.color='';

		}
	}

	for(var no=1;no<yearItems.length-1;no++){
		yearItems[no].innerHTML = startYear+no-1;
		yearItems[no].id = 'yearDiv' + (startYear/1+no/1-1);

	}
	if(activeSelectBoxYear){
		activeSelectBoxYear.style.color='';
		if(document.getElementById('yearDiv'+currentYear)){
			activeSelectBoxYear = document.getElementById('yearDiv'+currentYear);
			activeSelectBoxYear.style.color=selectBoxHighlightColor;
		}
	}
};

/**
 * @description	미결
 * @name		calendar#changeSelectBoxHour
 * @event		
 * @param		{Object}	inputObj
 * @returns		{Undefined}
 * @example		미결
 */
function changeSelectBoxHour(e,inputObj)
{
alert(" e =" + e +" inputObj : " + inputObj);
	if(!inputObj)inputObj = this;

	var hourItems = inputObj.parentNode.getElementsByTagName('DIV');
	if(inputObj.innerHTML.indexOf('-')>=0){
		var startHour = hourItems[1].innerHTML/1 -1;
		if(startHour<0)startHour=0;
		if(activeSelectBoxHour){
			activeSelectBoxHour.style.color='';
		}
	}else{
		var startHour = hourItems[1].innerHTML/1 +1;
		if(startHour>14)startHour = 14;
		if(activeSelectBoxHour){
			activeSelectBoxHour.style.color='';

		}
	}
	var prefix = '';
	for(var no=1;no<hourItems.length-1;no++){
		if((startHour/1 + no/1) < 11)prefix = '0'; else prefix = '';
		hourItems[no].innerHTML = prefix + (startHour+no-1);

		hourItems[no].id = 'hourDiv' + (startHour/1+no/1-1);

	}
	if(activeSelectBoxHour){
		activeSelectBoxHour.style.color='';
		if(document.getElementById('hourDiv'+currentHour)){
			activeSelectBoxHour = document.getElementById('hourDiv'+currentHour);
			activeSelectBoxHour.style.color=selectBoxHighlightColor;;
		}
	}
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function updateYearDiv()
{
    var yearSpan = 5;
    if (turnOffYearSpan) {
       yearSpan = 0;
    }
	var div = document.getElementById('yearDropDown');
	var yearItems = div.getElementsByTagName('DIV');
	for(var no=1;no<yearItems.length-1;no++){
		yearItems[no].innerHTML = currentYear/1 -yearSpan + no;
		if(currentYear==(currentYear/1 -yearSpan + no)){
			yearItems[no].style.color = selectBoxHighlightColor;
			activeSelectBoxYear = yearItems[no];
		}else{
			yearItems[no].style.color = '';
		}
	}
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function updateMonthDiv()
{
	for(no=0;no<12;no++){
		document.getElementById('monthDiv_' + no).style.color = '';
	}

	document.getElementById('monthDiv_' + currentMonth).style.color = '#000000';
	activeSelectBoxMonth = 	document.getElementById('monthDiv_' + currentMonth);
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function updateHourDiv()
{

	var div = document.getElementById('hourDropDown');
	var hourItems = div.getElementsByTagName('DIV');

	var addHours = 0;
	if((currentHour/1 -6 + 1)<0){
		addHours = 	(currentHour/1 -6 + 1)*-1;
	}
	for(var no=1;no<hourItems.length-1;no++){
		var prefix='';
		if((currentHour/1 -6 + no + addHours) < 10)prefix='0';
		hourItems[no].innerHTML = prefix +  (currentHour/1 -6 + no + addHours);
		if(currentHour==(currentHour/1 -6 + no)){
			hourItems[no].style.color = selectBoxHighlightColor;
			activeSelectBoxHour = hourItems[no];
		}else{
			hourItems[no].style.color = '';
		}
	}
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function updateMinuteDiv()
{
	for(no=0;no<60;no+=intervalSelectBox_minutes){
		var prefix = '';
		if(no<10)prefix = '0';

		document.getElementById('minuteDiv_' + prefix + no).style.color = '';
	}
	if(document.getElementById('minuteDiv_' + currentMinute)){
		document.getElementById('minuteDiv_' + currentMinute).style.color = selectBoxHighlightColor;
		activeSelectBoxMinute = document.getElementById('minuteDiv_' + currentMinute);
	}
};


/**
 * @description	미결
 * @returns		{String}
 * @example		미결
 */
function createYearDiv()
{

	if(!document.getElementById('yearDropDown')){
		var div = document.createElement('DIV');
		div.className='monthYearPicker';
		div.style.cursor='pointer';
	}else{
		var div = document.getElementById('yearDropDown');
		var subDivs = div.getElementsByTagName('DIV');
		for(var no=0;no<subDivs.length;no++){
			subDivs[no].parentNode.removeChild(subDivs[no]);
		}
	}


	var d = new Date();
	if(currentYear){
		d.setFullYear(currentYear);
	}

	var startYear = d.getFullYear()/1 - 5;

    var yearSpan = 10;
	if (! turnOffYearSpan) {
    	var subDiv = document.createElement('DIV');
    	subDiv.innerHTML = '&nbsp;&nbsp;▲ ';
    	subDiv.style.cursor='pointer';
    	subDiv.id = subDiv.name = "up";
    	subDiv.onclick = changeSelectBoxYear;
    	subDiv.onmouseover = highlightMonthYear;
    	subDiv.onmouseout = function(){ selectBoxMovementInProgress = false;};
    	subDiv.onselectstart = cancelCalendarEvent;
    	div.appendChild(subDiv);
    } else {
       startYear = d.getFullYear()/1 - 0;
       yearSpan = 2;
    }

	for(var no=startYear;no<(startYear+yearSpan);no++){
		var subDiv = document.createElement('DIV');
		subDiv.innerHTML = no;
		subDiv.onmouseover = highlightMonthYear;
		subDiv.onmouseout = highlightMonthYear;
		subDiv.onclick = selectYear;
		subDiv.id = 'yearDiv' + no;
		subDiv.onselectstart = cancelCalendarEvent;
		div.appendChild(subDiv);
		if(currentYear && currentYear==no){
			subDiv.style.color = selectBoxHighlightColor;
			activeSelectBoxYear = subDiv;
		}
	}
	if (! turnOffYearSpan) {
    	var subDiv = document.createElement('DIV');
    	subDiv.innerHTML = '&nbsp;&nbsp;▼';
    	subDiv.style.cursor='pointer';    	
    	subDiv.id = subDiv.name = "down";
    	subDiv.onclick = changeSelectBoxYear;
    	subDiv.onmouseover = highlightMonthYear;
    	subDiv.onmouseout = function(){ selectBoxMovementInProgress = false;};
    	subDiv.onselectstart = cancelCalendarEvent;
    	div.appendChild(subDiv);
	}
	return div;
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function slideCalendarSelectBox()
{
	if(selectBoxMovementInProgress){
		if(activeSelectBox.parentNode.id=='hourDropDown'){
			changeSelectBoxHour(false,activeSelectBox);
		}
		if(activeSelectBox.parentNode.id=='yearDropDown'){
			changeSelectBoxYear(false,activeSelectBox);
		}

	}
	setTimeout('slideCalendarSelectBox()',speedOfSelectBoxSliding);

};

/**
 * @description	미결
 * @returns		{String}
 * @example		미결
 */
function createHourDiv()
{
	if(!document.getElementById('hourDropDown')){
		var div = document.createElement('DIV');
		div.className='monthYearPicker';
	}else{
		var div = document.getElementById('hourDropDown');
		var subDivs = div.getElementsByTagName('DIV');
		for(var no=0;no<subDivs.length;no++){
			subDivs[no].parentNode.removeChild(subDivs[no]);
		}
	}

	if(!currentHour)currentHour=0;
	var startHour = currentHour/1;
	if(startHour>14)startHour=14;

	var subDiv = document.createElement('DIV');
	subDiv.innerHTML = '&nbsp;&nbsp;- ';
	subDiv.onclick = changeSelectBoxHour;
	subDiv.onmouseover = highlightMonthYear;
	subDiv.onmouseout = function(){ selectBoxMovementInProgress = false;};
	subDiv.onselectstart = cancelCalendarEvent;
	div.appendChild(subDiv);


	var subDiv = document.createElement('DIV');
	subDiv.innerHTML = '&nbsp;&nbsp;+ ';
	subDiv.onclick = changeSelectBoxHour;
	subDiv.onmouseover = highlightMonthYear;
	subDiv.onmouseout = function(){ selectBoxMovementInProgress = false;};
	subDiv.onselectstart = cancelCalendarEvent;
	div.appendChild(subDiv);

	return div;
};
/* This function creates the minute div at the bottom bar */

/**
 * @description	미결
 * @returns		{String}
 * @example		미결
 */
function createMinuteDiv()
{
	if(!document.getElementById('minuteDropDown')){
		var div = document.createElement('DIV');
		div.className='monthYearPicker';
	}else{
		var div = document.getElementById('minuteDropDown');
		var subDivs = div.getElementsByTagName('DIV');
		for(var no=0;no<subDivs.length;no++){
			subDivs[no].parentNode.removeChild(subDivs[no]);
		}
	}
	var startMinute = 0;
	var prefix = '';
	for(var no=startMinute;no<60;no+=intervalSelectBox_minutes){

		if(no<10)prefix='0'; else prefix = '';
		var subDiv = document.createElement('DIV');
		subDiv.innerHTML = prefix + no;
		subDiv.onmouseover = highlightMonthYear;
		subDiv.onmouseout = highlightMonthYear;
		subDiv.onclick = selectMinute;
		subDiv.id = 'minuteDiv_' + prefix +  no;
		subDiv.onselectstart = cancelCalendarEvent;
		div.appendChild(subDiv);
		if(currentYear && currentYear==no){
			subDiv.style.color = selectBoxHighlightColor;
			activeSelectBoxYear = subDiv;
		}
	}
	return div;
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function highlightSelect()
{
	if(this.className=='selectBox'){
		this.className = 'selectBoxOver';
		this.getElementsByTagName('IMG')[0].src = pathToImages + 'over_bottom_arrow.png';

	}else if(this.className=='selectBoxOver'){
		this.className = 'selectBox';
		this.getElementsByTagName('IMG')[0].src = pathToImages + 'down.png';
	
	}
};
/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function highlightSelect2()
{
	var wUrl;
	if(this.className=='weekdaynum' || this.className=='activeDay' ){
		this.className = this.className +'Over';
		wUrl = pathToImages + 'calendar_over.jpg';
		this.style.backgroundImage = "url("+wUrl+")";

	}else if(this.className=='weekdaynumOver' || this.className=='activeDayOver'){
		this.className = this.className.replace('Over', '');
		if(this.className == 'weekdaynum'){
			wUrl = pathToImages + 'daily_block_background.gif';	
		}else{
			wUrl = pathToImages + 'checked_today.png';
		}
		
		this.style.backgroundImage = "url("+wUrl+")";		
	}
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function highlightArrow()
{
	if(this.src.indexOf('over')>=0){
		//if(this.src.indexOf('left')>=0)this.src = pathToImages + 'cal_left.gif';
		//if(this.src.indexOf('right')>=0)this.src = pathToImages + 'cal_right.gif';
		if(this.src.indexOf('left')>=0)this.src = pathToImages + 'cal_left.png';
		if(this.src.indexOf('right')>=0)this.src = pathToImages + 'cal_right.png';
	}else{
		//if(this.src.indexOf('left')>=0)this.src = pathToImages + 'cal_left_over.gif';
		//if(this.src.indexOf('right')>=0)this.src = pathToImages + 'cal_right_over.gif';
		if(this.src.indexOf('left')>=0)this.src = pathToImages + 'cal_left_over.png';
		if(this.src.indexOf('right')>=0)this.src = pathToImages + 'cal_right_over.png';
	}
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function highlightClose()
{
	if(this.src.indexOf('over')>=0){
		this.src = pathToImages + 'cal_close.gif';
	}else{
		this.src = pathToImages + 'cal_close_over.gif';
	}

};
/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
//150918 달력 close
//시트와 컨트롤에 데이타 넣기
function closeCalendar(){
	try {
		parent.controls[IFrame_1].tagObject.style.height = IFrame_1_height + 'px';
	} catch (e) {}

	document.getElementById('yearDropDown').style.display='none';
	if(CType == 1) document.getElementById('monthDropDown').style.display='none';
	if(CType == 1) document.getElementById('hourDropDown').style.display='none';
	if(CType == 1) document.getElementById('minuteDropDown').style.display='none';

	calendarDiv.style.zIndex = 0;
	calendarDiv.style.display='none';
	if(iframeObj){
		iframeObj.style.display='none';
			EIS_Hide_Frame();}
	if(activeSelectBoxMonth)activeSelectBoxMonth.className='';
	if(activeSelectBoxYear)activeSelectBoxYear.className='';
	//20110407  textbox에 강제적으로 값을 넣어준다.이유는 기존 달력의 포커스를 잃어 버리는 경우에만 
	//값이 들어가는데 변경된 달력의 경우 달력을 클릭하면 포커스가 바로 잃어 버리기때문에이다.
	if(returnDateTo.id.match(/^[a-zA-Z]+/)[0] == "shtTextsheet"){
		var wSheet = controls["Sheet"+returnDateTo.id.match(/_\d+/)[0]];
		//var wSheet = controls[document.getElementById("Sheet"+returnDateTo.id.match(/_\d+/)[0]).attributes.name.nodeValue];
		wSheet.setValue(wSheet.currentRow,wSheet.currentCol,returnDateTo.value.split(specialChars).join(""));
	}else{
		var cal_ctl = controls[returnDateTo.getAttribute("ctlname")];
		var specialChars = /[~!\#$^&*\=+|:;?"<,.>'-\/]/;
		cal_ctl.setValue(returnDateTo.value.split(specialChars).join(""));
		
	}

	//document.getElementById(WTagId).select();
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function closeNotActionCalendar(){
	try {
		parent.controls[IFrame_1].tagObject.style.height = IFrame_1_height + 'px';
	} catch (e) {}

	document.getElementById('yearDropDown').style.display='none';
	document.getElementById('monthDropDown').style.display='none';
	document.getElementById('hourDropDown').style.display='none';
	document.getElementById('minuteDropDown').style.display='none';

	calendarDiv.style.zIndex = 0;
	calendarDiv.style.display='none';
	if(iframeObj){
		iframeObj.style.display='none';
			EIS_Hide_Frame();}
	if(activeSelectBoxMonth)activeSelectBoxMonth.className='';
	if(activeSelectBoxYear)activeSelectBoxYear.className='';
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
//150918 상단 달력 만들기
function writeTopBar()
{
/* 상단 테그 생성
 * 
 */
	
	var topBar = document.createElement('DIV');
//	topBar.className = 'topBar';
	topBar.style.backgroundImage = pathToImages+"caledar_x-repeat_bg.gif";
	topBar.id = 'topBar';
	
	//150916 김남용 백그라운드 색상변경
	topBar.style.cssText ='	height:25px; padding:5px; background-color:#d23000; ';
	calendarDiv.appendChild(topBar);
   /*
	var img = document.createElement('IMG');
	img.style.cssText ='width:100%;	height:25px;';
	img.src = pathToImages + 'caledar_x-repeat_bg.gif';
	topBar.appendChild(img);
	*/
	// Left arrow
	var leftDiv = document.createElement('DIV');
	//20110404 추가	
	//leftDiv.style.cssText ='float:left;	margin-right:1px;';
	//150916 Left
	if(CType == 1 ){
//		leftDiv.style.cssText ='float:left;	margin-left: 5px;';
		leftDiv.style.cssText ='float:left;	margin-left: 20px;margin-top:7px;';		
	}else if(CType == 2 ){
		leftDiv.style.cssText ='float:left;	margin-left: 12px;margin-top:7px;';
	} 
	

	
	var img = document.createElement('IMG');
	img.style.cssText = 'cursor:pointer;';
	//img.src = pathToImages + 'cal_left.gif';
	img.src = pathToImages + 'cal_left.png';
	img.onmouseover = highlightArrow;
	img.onclick = switchMonth;
	img.onmouseout = highlightArrow;
	leftDiv.appendChild(img);
	topBar.appendChild(leftDiv);
	if(Opera)leftDiv.style.width = '16px';
	
	// Year selector
	var yearDiv = document.createElement('DIV');
  //20110404 추가
	//yearDiv.style.cssText ='float:left;	margin-right:1px;width:50px;';	
	yearDiv.style.cssText ='float:left;	width:50px;top: 2px;left: 23px;font-weight:bold;';
	
	//150916 년도 
	if(CType == 1 ){
		yearDiv.style.cssText ='float:left;	width:50px;top: 5px;left: 23px;font-weight:bold;';
	}else if(CType == 2 ){
		yearDiv.style.cssText ='float:left; top: 5px;left: 25px;font-weight:bold; FONT-FAMILY: 나눔고딕;	font-size:15px;';
	} 
	
	yearDiv.onmouseover = highlightSelect;
	yearDiv.onmouseout = highlightSelect;
	yearDiv.onclick = showYearDropDown;
	var span = document.createElement('SPAN');

	span.innerHTML = currentYear;
	span.id = 'calendar_year_txt';
	span.style.cssText ='margin-right:2px;'; // 2011-06-21 추가
	yearDiv.appendChild(span);
	topBar.appendChild(yearDiv);

	var img = document.createElement('IMG');
	img.src = pathToImages + 'down.png';
  //20110404 추가		
	//img.style.cssText = 'float:right;cursor:pointer';
	img.style.cssText = 'cursor:pointer';
	img.style.marginTop= '5px';
	yearDiv.appendChild(img);
	yearDiv.className = 'selectBox';

  // 리스트 년 만들기.
	var yearPicker = createYearDiv();
	yearPicker.style.left = '55px';
	yearPicker.style.top = yearDiv.offsetTop + yearDiv.offsetHeight + 1 + 'px';
	yearPicker.style.width = '35px';
	yearPicker.id = 'yearDropDown';
	calendarDiv.appendChild(yearPicker);

/*
	var img = document.createElement('IMG');
	img.src = pathToImages + 'cal_close.gif';
  //20110404 추가	
	img.style.cssText = 'float:right;cursor:pointer';	
	img.onmouseover = highlightClose;
	img.onmouseout = highlightClose;
	img.onclick = closeNotActionCalendar;
	topBar.appendChild(img);
	if(!document.all){
		img.style.position = 'absolute';
		img.style.right = '2px';
	}
*/	
  //	
	
	// Month selector
	// 150616 년월일 달력일때문 실행
	//
		var monthDiv = document.createElement('DIV');
		calendarMMDiv=monthDiv;
		monthDiv.id = 'monthSelect';
	  //20110404 추가	
		//monthDiv.style.cssText ='float:left;	margin-right:5px;width:50px;';
		monthDiv.style.cssText ='float:left;	width:35px;top: 5px;left: 23px;font-weight:bold;';
		monthDiv.onmouseover = highlightSelect;
		monthDiv.onmouseout = highlightSelect;
		monthDiv.onclick = showMonthDropDown;
		var span = document.createElement('SPAN');
		span.innerHTML = monthArray[currentMonth];
		span.id = 'calendar_month_txt';
		monthDiv.appendChild(span);
	
		var img = document.createElement('IMG');
		img.src = pathToImages + 'down.png';
	  //20110404 추가	
		img.style.cssText = 'float:right; position:absolute; right:0px; cursor:pointer;margin-top:5px;';	
		monthDiv.appendChild(img);
		monthDiv.className = 'selectBox';
	
		topBar.appendChild(monthDiv);

	  // 리스트 월 만들기.
		var monthPicker = createMonthDiv();
		monthPicker.style.left = '108px';
		monthPicker.style.top = monthDiv.offsetTop + monthDiv.offsetHeight + 1 + 'px';
		monthPicker.style.width ='35px';
		monthPicker.id = 'monthDropDown';
		calendarDiv.appendChild(monthPicker);
		if(CType == 1){
			calendarMMDiv.style.display = 'block';
		}else{
			calendarMMDiv.style.display = 'none';
		}

		// Right arrow
	var rightDiv = document.createElement('DIV');
  //20110404 추가	
	//rightDiv.style.cssText ='float:left;	margin-right:1px;';			
	//150916 
	rightDiv.style.cssText ='float:left;	margin-left: 50px;margin-top:7px;';

	var img = document.createElement('IMG');
	img.style.cssText = 'cursor:pointer;';	
	//img.src = pathToImages + 'cal_right.gif';
	img.src = pathToImages + 'cal_right.png';	
	img.onclick = switchMonth;
	img.onmouseover = highlightArrow;
	img.onmouseout = highlightArrow;
	rightDiv.appendChild(img);
	if(Opera)rightDiv.style.width = '16px';
	topBar.appendChild(rightDiv);
	//


};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
//달력만들기. 달력선택
function writeCalendarContent()
{
	var calendarContentDivExists = true;
	if(!calendarContentDiv){
		calendarContentDiv = document.createElement('DIV');
		calendarDiv.appendChild(calendarContentDiv);
		calendarContentDivExists = false;
	}
	currentMonth = currentMonth/1;
	var d = new Date();

	d.setFullYear(currentYear);
	d.setDate(1);
	d.setMonth(currentMonth);

	var dayStartOfMonth = d.getDay();
	if (! weekStartsOnSunday) {
      if(dayStartOfMonth==0)dayStartOfMonth=7;
      dayStartOfMonth;
   }

	document.getElementById('calendar_year_txt').innerHTML = currentYear;
	// 150616 년월일 달력일때문 실행
	if(CType == 1){
		document.getElementById('calendar_month_txt').innerHTML = monthArray[currentMonth];
	}

	var existingTable = calendarContentDiv.getElementsByTagName('TABLE');
	if(existingTable.length>0){
		calendarContentDiv.removeChild(existingTable[0]);
	}
	//숫자요일 만들 테이블 생성
	var calTable = document.createElement('TABLE');
	calTable.width = '100%';
	calTable.cellSpacing = '0';
	calTable.borderCollapse = 'initial';
	calendarContentDiv.appendChild(calTable);


	var calTBody = document.createElement('TBODY');
	calTable.appendChild(calTBody);
	var row = calTBody.insertRow(-1);
	row.className = 'calendar_week_row';

	//요일 만들기 .. 월화수목금토일..
	// 150616 년월일 달력일때문 실행
	if(CType == 1){
		for(var no=0;no<dayArray.length;no++){
			var cell = row.insertCell(-1);
			cell.innerHTML = dayArray[no];
			//1509016 추가		
			cell.id="wn_weekdaynm";
		}
	}
//	else if(CType == 2){
//		for(var no=0;no<=monthArray.length;no++){
//			var row;
//			var cell;
//			if(no == 4 || no == 8){
//				row = calTBody.insertRow(-1);
//			}
//			cell = row.insertCell(-1);
//			cell.innerHTML = monthArray[no];		
//			cell.id="wn_weekdaynm";
//		}		
//	}
	
	// 150616 년월일 달력일때문 실행
	if(CType == 1){
		var row = calTBody.insertRow(-1);

		//첫번째줄 1일이 해당하는 요월에 맞게 셋팅 . 7이면 실행안함(시작이 일요일 이기때문에)
		if(dayStartOfMonth != 7){
		  	for(var no=0;no<dayStartOfMonth;no++){
		  		var cell = row.insertCell(-1);
		  		cell.innerHTML = '&nbsp;';
//				cell.id="wn_weekdaydefalut";  	
		  		cell.style.backgroundImage=pathToImages+"daily_block_background.gif"
				cell.style.borderLeft="1px solid #bebebe";
				cell.style.borderTop="1px solid #bebebe";				
		  	}
		  }
	
		var colCounter = dayStartOfMonth;
		
		var daysInMonth = daysInMonthArray[currentMonth];
		if(daysInMonth==28){
			if(isLeapYear(currentYear))daysInMonth=29;
		}
		var lastAddRow=7;
		var wOlecolCounter;
		var wLineOk=0;
		for(var no=1;no<=daysInMonth;no++){
			d.setDate(no-1);
			//alert(colCounter);
			if(colCounter>0 && colCounter%7==0){
				var row = calTBody.insertRow(-1);
				cell.style.borderRight=" 1px solid #bebebe";
				lastAddRow=7;	
				var wOlecolCounter  = (daysInMonth - (colCounter-dayStartOfMonth)) + (colCounter-dayStartOfMonth);
				if((no+6) >= daysInMonth ){
					//alert(wOlecolCounter+" , " +dayStartOfMonth+" , " + daysInMonth );
					wLineOk=1;
				}
			}
			//if(no > 28){
			//	alert(no + " ,  " +colCounter);	
			//}
			
			var cell = row.insertCell(-1);
			if(currentYear==inputYear && currentMonth == inputMonth && no==inputDay){
				cell.className='activeDay';
				//150916 선택시 글자색 변경
				cell.style.color='#0000ff';
//				cell.style.backgroundImage="url(winnersoft/images/calendar/checked_today.png)";
				cell.style.backgroundImage=pathToImages+"checked_today.png";
				cell.style.backgroundRepeat="no-repeat";
			}else{
				cell.className="weekdaynum";			
//				cell.style.backgroundImage="url(winnersoft/images/calendar/daily_block_background.gif)";	
				cell.style.backgroundImage=pathToImages+"daily_block_background.gif";	
			}
			// 요일숫자 넣기 1 ,2 ,3 ,4....
		  
			cell.innerHTML = no;
			cell.onclick = pickDate;
			cell.onmouseover = highlightSelect2;
			cell.onmouseout = highlightSelect2;
			cell.style.borderLeft=" 1px solid #bebebe";
			cell.style.borderTop=" 1px solid #bebebe";
			//1509016 추가
			cell.id="wn_weekdaynum";  	
			if(colCounter%7==0 || colCounter%7==6){
				cell.style.color='#ff0000';				
			}
			

			//150921 달력 마지막일자이후 빈공란 셋팅
			if(wLineOk ==1){
				cell.style.borderBottom="1px solid #bebebe";	
			}			
			if(daysInMonth == no){
				//cell.style.borderRight=" 1px solid #bebebe";
				cell.style.borderTop=" 1px solid #bebebe";					
				//alert(lastAddRow);
			  	for(var no1=1;no1<lastAddRow;no1++){
			  		var cell = row.insertCell(-1);
//					cell.id="wn_weekdaydefalut";  
			  		cell.style.backgroundImage=pathToImages+"daily_block_background.gif"
					cell.style.borderLeft="1px solid #bebebe";
					cell.style.borderTop="1px solid #bebebe";
					cell.style.borderBottom="1px solid #bebebe";					
			  	}
				cell.style.borderRight="1px solid #bebebe";
			}
			
			//마지막줄 추가
			lastAddRow= lastAddRow -1;
			colCounter++;
		}
	}else if(CType == 2){
		// 150916 년월달력
		var row = calTBody.insertRow(-1);
		var daysInMonth = daysInMonthArray[currentMonth];
		if(daysInMonth==28){
			if(isLeapYear(currentYear))daysInMonth=29;
		}
	
		for(var no=0;no<monthArrayShort.length;no++){
			d.setDate(no-1);
			
			if(no == 4 || no == 8){
				var row = calTBody.insertRow(-1);
				cell.style.borderRight="1px solid #bebebe";				
			}
			var cell = row.insertCell(-1);
			if(currentYear==inputYear && monthArrayShort[no] == (inputMonth+1) ){
				cell.className='activeDay';
				//150916 선택시 글자색 변경
				cell.style.color='#0000ff';
//				cell.style.backgroundImage="url(winnersoft/images/calendar/checked_today.png)";
				cell.style.backgroundImage=pathToImages+"checked_today.png";
				cell.style.backgroundRepeat="no-repeat";
			}else{
				cell.className="weekdaynum";				
//				cell.style.backgroundImage="url(winnersoft/images/calendar/daily_block_background.gif)";	
				cell.style.backgroundImage=pathToImages+"daily_block_background.gif";	
			}
			
			cell.innerHTML = monthArrayShort[no];
			cell.onclick = pickMm;
		
			//1509016 추가
			cell.style.width="25%";
			//cell.style.height="28px"; 
			cell.onmouseover = highlightSelect2;
			cell.onmouseout = highlightSelect2;			
			cell.id="wn_weekdaynum";
			cell.style.borderLeft="1px solid #bebebe";
			cell.style.borderTop="1px solid #bebebe";
			//150921 년월 보더 색상주기 
			if(no == 3 || no == 7 ||  no == 11){			
				cell.style.borderRight="1px solid #bebebe";				
			}
			if(no > 7) cell.style.borderBottom="1px solid #bebebe";
		}
	}
	
	if(!document.all){
		if(calendarContentDiv.offsetHeight)
			document.getElementById('topBar').style.top = calendarContentDiv.offsetHeight + document.getElementById('timeBar').offsetHeight + document.getElementById('timeBar').offsetHeight + document.getElementById('topBar').offsetHeight -1 + 'px';
		else{
			document.getElementById('topBar').style.top = '';
			document.getElementById('topBar').style.bottom = '0px';
		}
	}

	if(iframeObj){
		if(!calendarContentDivExists)setTimeout('resizeIframe()',350);else setTimeout('resizeIframe()',10);
	}
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function resizeIframe()
{
	iframeObj.style.width = calendarDiv.offsetWidth + 'px';
	iframeObj.style.height = calendarDiv.offsetHeight + 'px' ;


};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function pickTodaysDate()
{
	var d = new Date();

	currentMonth = d.getMonth();
	currentYear = d.getFullYear();
	pickDate(false,d.getDate());

};

/**
 * @description	미결
 * @name		calendar#pickDate
 * @event
 * @param		{Object}	inputDay	
 * @returns		{Undefined}
 * @example		미결
 * 
 */
function pickDate(e,inputDay)
{
	var month = currentMonth/1 +1;

	if(month<10)month = '0' + month;
	var day;
	if(!inputDay && this)day = this.innerHTML; else day = inputDay;

	if(day/1<10)day = '0' + day;
	//데이터셋팅

	if(returnFormat){
		returnFormat = returnFormat.replace('dd',day);
		returnFormat = returnFormat.replace('mm',month);
		returnFormat = returnFormat.replace('yyyy',currentYear);
		returnFormat = returnFormat.replace('hh',currentHour);
		returnFormat = returnFormat.replace('ii',currentMinute);
		returnFormat = returnFormat.replace('d',day/1);
		returnFormat = returnFormat.replace('m',month/1);
		returnDateTo.value = returnFormat;
		returnDateTo.setAttribute("value", returnFormat);
		
		try{
	
			returnDateTo.onchange();

		}catch(e){

		}
	}else{
		for(var no=0;no<returnDateToYear.options.length;no++){
			if(returnDateToYear.options[no].value==currentYear){
				returnDateToYear.selectedIndex=no;
				break;
			}
		}
		for(var no=0;no<returnDateToMonth.options.length;no++){
			if(returnDateToMonth.options[no].value==parseInt(month)){
				returnDateToMonth.selectedIndex=no;
				break;
			}
		}
		for(var no=0;no<returnDateToDay.options.length;no++){
			if(returnDateToDay.options[no].value==parseInt(day)){
				returnDateToDay.selectedIndex=no;
				break;
			}
		}
		if(calendarDisplayTime){
			for(var no=0;no<returnDateToHour.options.length;no++){
				if(returnDateToHour.options[no].value==parseInt(currentHour)){
					returnDateToHour.selectedIndex=no;
					break;
				}
			}
			for(var no=0;no<returnDateToMinute.options.length;no++){
				if(returnDateToMinute.options[no].value==parseInt(currentMinute)){
					returnDateToMinute.selectedIndex=no;
					break;
				}
			}
		}
	}
	closeCalendar();
};

/**
 * @description	미결
 * @name		calendar#pickMm
 * @event
 * @param		{Object}	inputMm	
 * @returns		{Undefined}
 * @example		미결
 * 
 */
function pickMm(e,inputMm)
{
	var month = currentMonth/1 +1;
	if(!inputMm && this)month = this.innerHTML; else month = inputMm;
	if(month/1<10)month = '0' + month;
	//데이터셋팅
	if(returnFormat){
		returnFormat = returnFormat.replace('mm',month);
		returnFormat = returnFormat.replace('yyyy',currentYear);
		returnDateTo.value = returnFormat;
		returnDateTo.setAttribute("value", returnFormat);
		
		try{
	
			returnDateTo.onchange();

		}catch(e){

		}
	}else{
		for(var no=0;no<returnDateToYear.options.length;no++){
			if(returnDateToYear.options[no].value==currentYear){
				returnDateToYear.selectedIndex=no;
				break;
			}
		}
		for(var no=0;no<returnDateToMonth.options.length;no++){
			if(returnDateToMonth.options[no].value==parseInt(month)){
				returnDateToMonth.selectedIndex=no;
				break;
			}
		}
		for(var no=0;no<returnDateToDay.options.length;no++){
			if(returnDateToDay.options[no].value==parseInt(day)){
				returnDateToDay.selectedIndex=no;
				break;
			}
		}
		if(calendarDisplayTime){
			for(var no=0;no<returnDateToHour.options.length;no++){
				if(returnDateToHour.options[no].value==parseInt(currentHour)){
					returnDateToHour.selectedIndex=no;
					break;
				}
			}
			for(var no=0;no<returnDateToMinute.options.length;no++){
				if(returnDateToMinute.options[no].value==parseInt(currentMinute)){
					returnDateToMinute.selectedIndex=no;
					break;
				}
			}
		}
	}
	closeCalendar();
};
/**

 * 
 * @description	미결
 * @name		calendar#pickDate
 * @event
 * @param		{Object}	writeTimeBar	
 * @returns		{Object}
 * @example		미결
 * 
 */
function writeTimeBar()
{
	var timeBar = document.createElement('DIV');
	timeBar.id = 'timeBar';
	timeBar.className = 'timeBar';

	var subDiv = document.createElement('DIV');
	subDiv.innerHTML = 'Time:';
	//timeBar.appendChild(subDiv);

	// Year selector
	var hourDiv = document.createElement('DIV');
	hourDiv.onmouseover = highlightSelect;
	hourDiv.onmouseout = highlightSelect;
	hourDiv.onclick = showHourDropDown;
	hourDiv.style.width = '30px';

	var hourPicker = createHourDiv();
	hourPicker.style.left = '130px';
	hourPicker.style.width = '35px';
	hourPicker.id = 'hourDropDown';
	calendarDiv.appendChild(hourPicker);

	// Add Minute picker

	// Year selector
	var minuteDiv = document.createElement('DIV');
	minuteDiv.onmouseover = highlightSelect;
	minuteDiv.onmouseout = highlightSelect;
	minuteDiv.onclick = showMinuteDropDown;
	minuteDiv.style.width = '30px';

	var minutePicker = createMinuteDiv();
	minutePicker.style.left = '167px';
	//minutePicker.style.top = monthDiv.offsetTop + monthDiv.offsetHeight + 1 + 'px';
	minutePicker.style.width = '35px';
	minutePicker.id = 'minuteDropDown';
	calendarDiv.appendChild(minutePicker);


	return timeBar;

};
/**
 * @description	미결
 * @returns		{Object}
 * @example		미결
 */
function writeTimeBar()
{
	var timeBar = document.createElement('DIV');
	timeBar.id = 'timeBar';
	timeBar.className = 'timeBar';

	var subDiv = document.createElement('DIV');
	subDiv.innerHTML = 'Time:';
	//timeBar.appendChild(subDiv);

	// Year selector
	var hourDiv = document.createElement('DIV');
	hourDiv.onmouseover = highlightSelect;
	hourDiv.onmouseout = highlightSelect;
	hourDiv.onclick = showHourDropDown;
	hourDiv.style.width = '30px';

	var hourPicker = createHourDiv();
	hourPicker.style.left = '130px';
	hourPicker.style.width = '35px';
	hourPicker.id = 'hourDropDown';
	calendarDiv.appendChild(hourPicker);

	// Add Minute picker

	// Year selector
	var minuteDiv = document.createElement('DIV');
	minuteDiv.onmouseover = highlightSelect;
	minuteDiv.onmouseout = highlightSelect;
	minuteDiv.onclick = showMinuteDropDown;
	minuteDiv.style.width = '30px';

	var minutePicker = createMinuteDiv();
	minutePicker.style.left = '167px';
	//minutePicker.style.top = monthDiv.offsetTop + monthDiv.offsetHeight + 1 + 'px';
	minutePicker.style.width = '35px';
	minutePicker.id = 'minuteDropDown';
	calendarDiv.appendChild(minutePicker);


	return timeBar;

};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function writeBottomBar()
{
/* 하단 현재일자 셋팅
 * 
 */
	
	var d = new Date();
	var bottomBar = document.createElement('DIV');

	bottomBar.id = 'bottomBar';

	bottomBar.style.cursor = 'pointer';
//	bottomBar.className = 'todaysDate';
	bottomBar.style.backgroundImage = pathToImages+"daily_block_background.gif";
	bottomBar.style.display = 'none';
	if(CType == 1){
		bottomBar.style.width = '203px';
	}else if(CType == 2){
		bottomBar.style.width = '148px';
	}
	
		// var todayStringFormat = '[todayString] [dayString] [day] [monthString] [year]';	;;

	var subDiv = document.createElement('DIV');
	subDiv.onclick = pickTodaysDate;
	subDiv.id = 'todaysDateString';
	subDiv.style.width = (calendarDiv.offsetWidth - 95) + 'px';
	var day = d.getDay();
	if (! weekStartsOnSunday) {
      if(day==0)day = 7;
      day--;
   }

	var bottomString = todayStringFormat;

	bottomString = bottomString.replace('[monthString]',monthArrayShort[d.getMonth()]);
	bottomString = bottomString.replace('[day]',d.getDate());
	bottomString = bottomString.replace('[year]',d.getFullYear());
	bottomString = bottomString.replace('[dayString]',dayArray[day].toLowerCase());
	bottomString = bottomString.replace('[todayString]',todayString);

	//현재일자 셋팅
	subDiv.innerHTML = todayString + ': ' + d.getDate() + '. ' + monthArrayShort[d.getMonth()] + ', ' +  d.getFullYear() ;
	
	subDiv.innerHTML = bottomString ;

	bottomBar.appendChild(subDiv);

	var timeDiv = writeTimeBar();
	bottomBar.appendChild(timeDiv);

	calendarDiv.appendChild(bottomBar);



};
/**
 * @description	미결
 * @param		{Object}	inputObj
 * @returns		{Number}
 * @example		미결
 */
function getTopPos(inputObj)
{

  var returnValue = inputObj.offsetTop + inputObj.offsetHeight;
  while((inputObj = inputObj.offsetParent) != null)returnValue += inputObj.offsetTop;
  return returnValue + calendar_offsetTop;
};

/**
 * @description	미결
 * @param		{Object}	inputObj
 * @returns		{Number}
 * @example		미결
 */
function getleftPos(inputObj)
{
  var returnValue = inputObj.offsetLeft;
  while((inputObj = inputObj.offsetParent) != null)returnValue += inputObj.offsetLeft;
  return returnValue + calendar_offsetLeft;
};

/**
 * @description	미결
 * @param		{Object}	inputObj
 * @returns		{Undefined}
 * @example		미결
 */
function positionCalendar(inputObj)
{
	calendarDiv.style.left = getleftPos(inputObj) + 'px';
	calendarDiv.style.top = getTopPos(inputObj) + 'px';
	if(iframeObj){
		iframeObj.style.left = calendarDiv.style.left;
		iframeObj.style.top =  calendarDiv.style.top;
		//// fix for EI frame problem on time dropdowns 09/30/2006
		iframeObj2.style.left = calendarDiv.style.left;
		iframeObj2.style.top =  calendarDiv.style.top;
	}

};
/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
//150918 달력 전체모양 만들기
function initCalendar()
{
	if(MSIE){
		iframeObj = document.createElement('IFRAME');
		iframeObj.style.filter = 'alpha(opacity=0)';
		iframeObj.style.position = 'absolute';
		iframeObj.border='0px';
		iframeObj.style.border = '0px';
		//iframeObj.style.backgroundColor = '#4598ff';

		iframeObj2 = document.createElement('IFRAME');
		iframeObj2.style.position = 'absolute';
		iframeObj2.border='0px';
		iframeObj2.style.border = '0px';
		iframeObj2.style.height = '1px';
		iframeObj2.style.width = '1px';

		document.body.appendChild(iframeObj2);  // gfb move this down AFTER the .src is set
		document.body.appendChild(iframeObj);
	}

	calendarDiv = document.createElement('DIV');
	calendarDiv.id = 'calendarDiv';
	calendarDiv.class = 'calendarDiv';
	calendarDiv.style.zIndex = 1000;
	if(CType == 1){
	//150921 하단 현재 날짜 안보이도록 display:none로  변경 
//		calendarDiv.style.cssText ='position:absolute;	width:205px;	border:0px solid #EAEAEA;	padding:1px;	background-color: #FDFDFD;  FONT-FAMILY: 나눔고딕;	font-size:12px;	padding-bottom:20px;	visibility:hidden; ';	
		calendarDiv.style.cssText ='position:absolute;	width:205px;	border:0px solid #EAEAEA;	padding:1px;	background-color: #FDFDFD;  FONT-FAMILY: 나눔바른고딕;	font-size:12px;	padding-bottom:0px;	visibility:hidden; ';
	}else if(CType == 2){
		calendarDiv.style.cssText ='position:absolute;	width:150px;	border:0px solid #858BFF;	padding:1px;	background-color: #FDFDFD;  FONT-FAMILY: 나눔바른고딕;	font-size:12px;	padding-bottom:0px;	visibility:hidden; ';		
	}
    	
    slideCalendarSelectBox();
	document.body.appendChild(calendarDiv);
	//달력 오늘날짜 하단태그
	//if(CType == 1){
		writeBottomBar();
	//}
	//달력 상단 년,월 선택 태그
	writeTopBar();



	if(!currentYear){
		var d = new Date();
		currentMonth = d.getMonth();
		currentYear = d.getFullYear();
	}
	
	//데이터 입력 
	writeCalendarContent();



};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function setTimeProperties()
{
	if(!calendarDisplayTime){
		document.getElementById('timeBar').style.display='none';
		document.getElementById('timeBar').style.visibility='hidden';
		if(CType == 1)document.getElementById('todaysDateString').style.width = '100%';


	}else{
		document.getElementById('timeBar').style.display='block';
		document.getElementById('timeBar').style.visibility='visible';
		if(CType == 1)document.getElementById('todaysDateString').style.width = '115px';
	}
};

/**
 * @description	미결
 * @param		{Number}	a
 * @param		{Number}	b
 * @returns		{Number}
 * @example		미결
 */
function calendarSortItems(a,b)
{
	return a/1 - b/1;
};

/**
 * @description	미결
 * @param		{Object}	inputField
 * @param		{Object}	inputControl
 * @param		{Object}	format
 * @param		{Object}	type
 * @param		{Number}	displayTime
 * @param		{Number}	timeInput
 * @returns		{Undefined}
 * @example		미결
 */
function popUpCalendar(inputField,inputControl,format,type,displayTime,timeInput)
{
// type:1(년월일) , type:2(년월) , type:3(년도)  

	CType = type;
	WTagId = inputField.id;  
	var controlValue = inputControl.value;

	if(displayTime)calendarDisplayTime=true; else calendarDisplayTime = false;

	if(controlValue.length>=6){ //dates must have at least 6 digits...
       if(!controlValue.match(/^[0-9]*?$/gi)){

 			var items = inputField.value.split(/[^0-9]/gi);
			var positionArray = new Array();
			positionArray['m'] = format.indexOf('mm');
			if(positionArray['m']==-1)positionArray['m'] = format.indexOf('m');
			positionArray['d'] = format.indexOf('dd');
			if(positionArray['d']==-1)positionArray['d'] = format.indexOf('d');
			positionArray['y'] = format.indexOf('yyyy');
			positionArray['h'] = format.indexOf('hh');
			positionArray['i'] = format.indexOf('ii');

			var positionArrayNumeric = Array();
			positionArrayNumeric[0] = positionArray['m'];
			positionArrayNumeric[1] = positionArray['d'];
			positionArrayNumeric[2] = positionArray['y'];
			positionArrayNumeric[3] = positionArray['h'];
			positionArrayNumeric[4] = positionArray['i'];


			positionArrayNumeric = positionArrayNumeric.sort(calendarSortItems);
			var itemIndex = -1;
			currentHour = '00';
			currentMinute = '00';
			
			var tmpDay = 0;
			
			for(var no=0;no<positionArrayNumeric.length;no++){
				if(positionArrayNumeric[no]==-1)continue;
				itemIndex++;
				if(positionArrayNumeric[no]==positionArray['m']){
					currentMonth = items[itemIndex]-1;
					continue;
				}
				if(positionArrayNumeric[no]==positionArray['y']){
					currentYear = items[itemIndex];
					continue;
				}
				if(positionArrayNumeric[no]==positionArray['d']){
					tmpDay = items[itemIndex];
					continue;
				}
				if(positionArrayNumeric[no]==positionArray['h']){
					currentHour = items[itemIndex];
					continue;
				}
				if(positionArrayNumeric[no]==positionArray['i']){
					currentMinute = items[itemIndex];
					continue;
				}
			}

			currentMonth = currentMonth / 1;
			tmpDay = tmpDay / 1;

		}else{
			var monthPos = format.indexOf('mm');
			currentMonth = controlValue.substr(monthPos,2)/1 -1;


			var yearPos = format.indexOf('yyyy');
			currentYear = controlValue.substr(yearPos,4);
			var dayPos = format.indexOf('dd');
			tmpDay = controlValue.substr(dayPos,2);

			var hourPos = format.indexOf('hh');
			if(hourPos>=0){
				tmpHour = controlValue.substr(hourPos,2);
				currentHour = tmpHour;
			}else{
				currentHour = '00';
			}
			var minutePos = format.indexOf('ii');
			if(minutePos>=0){
				tmpMinute = controlValue.substr(minutePos,2);
				currentMinute = tmpMinute;
			}else{
				currentMinute = '00';
			}
		}

	}else{
		var d = new Date();
		//년도
		currentYear = d.getFullYear();
		//월
		currentMonth = d.getMonth();
		//일
		tmpDay = d.getDate();
		//분
		currentHour = '08';
		//초
		currentMinute = '00';

	}
	
	//년도
	inputYear = currentYear;
	//월
	inputMonth = currentMonth;
	//일
	inputDay = tmpDay/1;

/* 최초 클릭시 태그를 생성여부 체크 */
	if(!calendarDiv){
		initCalendar();
			
	}else{

		if(calendarDiv.style.display=='block'){
			closeNotActionCalendar();
			return false;
		}
		//calendarDiv.remove();
		//initCalendar();
		if(CType == 1){
			//150921 하단 현재 날짜 안보이도록 display:none로  변경 
				calendarDiv.style.cssText ='position:absolute;	width:205px;	border:0px solid #EAEAEA;	padding:1px;	background-color: #FDFDFD;  FONT-FAMILY: 나눔바른고딕;	font-size:12px;	padding-bottom:0px;	visibility:hidden; ';
				calendarMMDiv.style.display = 'block';	
		}else if(CType == 2){
				calendarDiv.style.cssText ='position:absolute;	width:150px;	border:0px solid #858BFF;	padding:1px;	background-color: #FDFDFD;  FONT-FAMILY: 나눔바른고딕;	font-size:12px;	padding-bottom:0px;	visibility:hidden; ';		
				calendarMMDiv.style.display = 'none';	
				//$('#monthSelect').css({"display":"none"});
				//monthDiv.style.display = 'none';
			}		
		writeCalendarContent();
	}

	returnFormat = format;
	returnDateTo = inputField;
	positionCalendar(inputField);
	calendarDiv.style.zIndex = 1000;
	calendarDiv.style.visibility = 'visible';
	calendarDiv.style.display = 'block';

	if(iframeObj){
		iframeObj.style.display = '';
		iframeObj.style.height = '140px';
		iframeObj.style.width = '195px';
		
		iframeObj2.style.display = '';
		iframeObj2.style.height = '140px';
		iframeObj2.style.width = '195px';
	}

	setTimeProperties();
	updateYearDiv();
	updateMonthDiv();
	updateMinuteDiv();
	updateHourDiv();
	document.getElementById(WTagId).select();
	document.getElementById(WTagId).blur();

    var wleft = inputField.offsetLeft;
    var wtop = inputField.offsetTop;
    
    var pem = inputField.offsetParent;
    while(pem.tagName != "BODY"){
    	wleft += pem.offsetLeft;
    	wtop += pem.offsetTop;
        
        pem = pem.offsetParent;
    }
    
    
    var winHeight = 0;
    var winWidth  = 0;
    
	if (window.innerHeight)
		winHeight=window.innerHeight;
	else if (document.documentElement && document.documentElement.clientHeight)
		winHeight=document.documentElement.clientHeight;
	else if (document.body)
		winHeight=document.body.clientHeight;
	
	if (window.innerWidth)
		winWidth=window.innerWidth;
	else if (document.documentElement && document.documentElement.clientWidth)
		winWidth=document.documentElement.clientWidth;
	else if (document.body)
		winWidth=document.body.clientWidth;
    
    var documentScrollTop = document.documentElement.scrollTop;
    var documentScrollLeft = document.documentElement.scrollLeft;
    
    if (wtop > documentScrollTop + winHeight - calendarDiv.clientHeight -20) {
        calendarDiv.style.top = (documentScrollTop + winHeight - calendarDiv.clientHeight -20) + "px";
    }
    if (wleft > documentScrollLeft + winWidth - calendarDiv.clientWidth - 20) {
        calendarDiv.style.left = (documentScrollLeft + winWidth - calendarDiv.clientWidth -20) + "px";
    }
};

/**
 * @description	미결
 * @param		{Object}	yearInput
 * @param		{Object}	monthInput
 * @param		{Object}	dayInput
 * @param		{Object}	hourInput
 * @param		{Object}	minuteInput
 * @param		{Object}	buttonObj
 * @returns		{Undefined}
 * @example		미결
 */
function displayCalendarSelectBox(yearInput,monthInput,dayInput,hourInput,minuteInput,buttonObj)
{
	if(!hourInput)calendarDisplayTime=false; else calendarDisplayTime = true;

	currentMonth = monthInput.options[monthInput.selectedIndex].value/1-1;
	currentYear = yearInput.options[yearInput.selectedIndex].value;
	if(hourInput){
		currentHour = hourInput.options[hourInput.selectedIndex].value;
		inputHour = currentHour/1;
	}
	if(minuteInput){
		currentMinute = minuteInput.options[minuteInput.selectedIndex].value;
		inputMinute = currentMinute/1;
	}

	inputYear = yearInput.options[yearInput.selectedIndex].value;
	inputMonth = monthInput.options[monthInput.selectedIndex].value/1 - 1;
	inputDay = dayInput.options[dayInput.selectedIndex].value/1;

	if(!calendarDiv){
		initCalendar();
	}else{
		writeCalendarContent();
	}

	returnDateToYear = yearInput;
	returnDateToMonth = monthInput;
	returnDateToDay = dayInput;
	returnDateToHour = hourInput;
	returnDateToMinute = minuteInput;




	returnFormat = false;
	returnDateTo = false;
	positionCalendar(buttonObj);
	calendarDiv.style.zIndex = 1000;
	calendarDiv.style.visibility = 'visible';
	calendarDiv.style.display = 'block';
	if(iframeObj){
		iframeObj.style.display = '';
		iframeObj.style.height = calendarDiv.offsetHeight + 'px';
		iframeObj.style.width = calendarDiv.offsetWidth + 'px';
		//// fix for EI frame problem on time dropdowns 09/30/2006
		iframeObj2.style.display = '';
		iframeObj2.style.height = calendarDiv.offsetHeight + 'px';
		iframeObj2.style.width = calendarDiv.offsetWidth + 'px'
	}
	setTimeProperties();
	updateYearDiv();
	updateMonthDiv();
	updateHourDiv();
	updateMinuteDiv();

};
/**
 *   @autor   winnersoft korea
 *   @version 5.0
 *   @see     winnersoft.co.kr
 */


/**
 * @description 
 *     EasyMaker Vertical Data Object For Big Data.
 * 
 * @constructor
 * 
 * @param {string} 	 id 	 	- 콘트롤 고유 아이디 (영문)
 * @param {string} 	 tableID 	- 데이터가 들어갈 테이블 명
 * @param {string} 	 name 		- 객체명 (사용자 고유 언어)
 * 
 * @return {DataObject} - 생성된 DataObject 개체
 * 
 * @exception 널값 예외
 * 
 * @example 
 *     // 콘트롤 고유 아이디 "student", 테이블명: "TBL_STUDENT" 인 "학생" 객체
 *     var object = new DataObject("student", "TBL_STUDENT", "학생");
 */
function DataObject(id, tableID, name){
	/** [읽기 전용] 메모리 데이터 셋 <br/> dataSet은 고유값으로서 변경될 수 없다.
	 *  @type {DataSet}  
	 *  */  	
	this.dataSet = new WsDataSet();
	this.dataSet.deleteDataPolicy = WSDATASET_DELETE_POLICY.LEAVE_RECORD_IN_DATA;
	
	/** [읽기 전용] 데이터를 구성하는 각 필드의 정보가 기록되는 배열, 0 부터 채워진다 
	 *  @type {PropertyInfo[]}  
	 *  */  	
    this.propertyInfos = [];
    
    
	/** [읽기 전용] 데이터를 구성하는 각 필드의 정보가 기록되는 연관배열, 만들어진 순서로 채워진다  
	 *  @type {PropertyInfo[]}  
	 *  */  	
    this.propertyInfosById = {};  	// propertyInfos의 복사판 Id로 인덱싱하기 위헤필요
    
	/** [읽기 전용] 데이터를 구성하는 필드의 갯수 
	 *  @type {PropertyInfo[]}  
	 *  */  	
    this.propertyCount = 0;
    
	/** 
	 *  dni는 Delete aNd Insert 를 의미한다. 
	 *  화면에 있는 모든 데이터에 대하여 각 레코드의 키에 해당하는 데이터를 지우고 <br/>
	 *  새로운 데이터를 Insert 하는 형태로 서버상 데이터가 갱신 된다 <br/>
	 *  데이터를 서버데이터와 같은 형태로 '로드'한 상태인 경우 false이며 데이터의 변화에 따라 IUD(Insert, Update, Delete)동작을 하게 된다.<br/>
	 *  가져오기, 배치작업등으로 채운 경우 true이다. 이때는 DI(Delete, Insert)동작을 하게 된다.<br/> 
	 *  '로드'작업 이외의 동작으로 데이터를 채운후 "dniMode = true;" 로 설정하면 IUD 동작을 한다. 
	 *  
	 *   EasyMaker의 객체 메뉴에서 "갱신유형 - 전체" 가 선택된 경우 this.dniMode 는 true,
	 *                         "갱신유형 - 수정분"이 선택된 경우 this.dniMode 는 false,
	 *                         둘 다 선택되지 않은 경우는 this.dniMode 는 true 가 된다 
	 *  @type {Boolean}  
	 *  */  	
    this.dniMode = true; 			// 객체 속성이 dni 모드가 아니면 false
    
    /** @deprecated since version 5.0, [읽기 전용] AUI시트에서 줄추가된 데이터를 수정할때 해당속성이 true로 들어온다 
	 *  @type {Boolean}  
     * */
    this.newData = false;
       
    /** @deprecated since version 5.0, [읽기 전용] AUI시트에서 이 속성이 true 이면 setValue 함수에서 바로 리턴  
	 *  @type {Boolean}  
     * */
    this.notSetValue = false; 		
    
    /** @deprecated since version 5.0, [읽기 전용] AUI시트에서 이 속성이 true 이면 setValue 함수에서 같은 값이더라도 바로 리턴하지 않고 data updateGu 갱신 후 리턴  
	 *  @type {Boolean}  
     * */
    this.dataUp = false;
    
	/** [읽기 전용] 데이터셋 중 현재 레코드를 가리키는 순번
	 *  @type {Number}  
	 *  */  	
    this.seq = 0;
    
	/** [읽기 전용] 객체내 데이터셋의 레코드를 가리키는 순번중 최대값 , count속성값과 같다. 
	 *  @type {Number}  
	 *  */  	
    this.maxSeq = 0;				// count 정도의 역할 밖에는 안함 
    
	/** [읽기 전용] 객체내 데이터셋의 레코드 수  
	 *  @type {Number}  
	 *  */  	
    this.count = 0;               	// 집계함수 연산에 필요한 값
    
	/** [읽기 전용] 객체내 데이터셋의 레코드를 가리키는 순번의 시작 값, startSeq == 1 인 경우 1번부터 순번이 시작된다 
	 *  @type {Number=0}  
	 *  */  	
    this.startSeq = 1;				// 행과 열의 시작 번호 디폴트는 1이다 (기존 호환)

	/** [읽기 전용] 화면내에서 객체를 대표하는 ID 
	 *  @type {String}  
	 *  */  	
    this.id = id;
    
	/** [읽기 전용] 화면내에서 객체를 저장하는 Table의 ID
	 *  @type {String}  
	 *  */  	
    this.tableID = tableID;
    
	/** [읽기 전용] 화면내에서 객체를 대표하는 이름
	 *  @type {String}  
	 *  */  	
    this.name = name;
    
	/** [읽기 전용] 
	 * 객체로 "Load"동작을 통해서 데이터를 가져온 후 화면에 채우는 기준이 되는 속성의 ID. <br/> 
	 * 대량의 데이터를 로드해서 기준을 바꾸어 가며 화면에 표시하고 작업할 때 사용한다. <br/>
	 * fillKeyfieldId 과 fillKeyFieldName 은 같은 값이다. 
	 *  @type {String}  
	 *  */  	
    this.fillKeyfieldId = "";     
    
	/** [읽기 전용] 
	 * 객체로 "Load"동작을 통해서 데이터를 가져온 후 화면에 채우는 기준이 되는 속성의 필드명. <br/> 
	 * fillKeyfieldId 과 fillKeyFieldName 은 같은 값이다. 
	 *  @type {String}  
	 *  */  	
    this.fillKeyFieldName = "";
    
    
	/** [읽기 전용] 
	 * 객체로 "Load"동작을 통해서 데이터를 가져온 후 화면에 채우는 기준이 필드의 현재값<br/>
	 * 객체데이터중 이값과 같은 값을 가진 데코드만 화면에 채워지게 된다.  
	 *  @type {String}  
	 *  */  	
    this.fillkeyFieldValue = "";
    
    
	/** [읽기 전용] 
	 * 각레코드를 구분하는 필드를 시퀀스키필드(sequance key field)라고 하며, <br/>
	 * seqKeyFieldId속성은 시퀀스키필드의 속성 ID값을 의미한다. 
	 *  @type {String}  
	 *  */  	
    this.seqKeyFieldId = "";
    
    this.selectCondition = null;
    
    objects[name] = this;
    
    // 이벤트 또는 사용자 함수 처리부
	/** 
	 * 데이터나 속성 변경시 이벤트를 일으킬 것인지 여부를 지정한다  <br/>
	 * false: 이벤트를 발생시키지 않는다.
	 *  @type {Boolean}  
	 *  */  	
	this.FireEvent = true;		// 이벤트를 일으킬 것인지 여부
    
   	/**
	 * 레코드간 이동전 동작 취소가 가능한 이벤트 (CanSeqChange)
	 *
	 * @event DataObject#SeqChange
	 * @type {Object}
     * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
	 * @property {Number} oldSeq 	- 이동전 줄번호 
	 * @property {Number} seq 		- 이동후 줄번호
	 */
    this.hasCanSeqChangeEvent = (typeof self[this.id + "_CanSeqChange"] != "undefined");
    this.fncCanSeqChangeEvent = !this.hasCanSeqChangeEvent ? null : new Function("return function (oldSeq, seq) { return " + this.id + "_CanSeqChange(oldSeq, seq);}")();

   	/**
	 * 레코드간 이동후 발생하는 이벤트 (SeqChange)
	 *
	 * @event DataObject#SeqChange
	 * @type {Object}
 	 * @property {Number} oldSeq 	- 이동전 줄번호 
	 * @property {Number} seq 		- 이동후 줄번호
	 */
    this.hasSeqChangeEvent = (typeof self[this.id + "_onSeqChange"] != "undefined");
    this.fncSeqChangeEvent = !this.hasSeqChangeEvent ? null : new Function("return function (oldSeq, seq) { return " + this.id + "_onSeqChange(oldSeq, seq);}")();

   	/**
	 * 데이터의 값이 변경전 사용자 체크 코딩이 가능한 이벤트 
	 *
	 * @event DataObject#change
	 * @type {Object}
     * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
	 * @property {String} 						fieldId - 변경된 데이터의 필드ID
	 * @property {String|Number|Boolean|Object} newValue - 변경후 데이터 
	 * @property {String|Number|Boolean|Object} oldValue - 변경전 데이터 
	 */
    this.hasCanChangeEvent = (typeof self[this.id + "_CanChange"] != "undefined");
    this.fncCanChangeEvent = !this.hasCanChangeEvent ? null : new Function("return function (fieldId, newValue, oldValue) { return " + this.id + "_CanChange(fieldId, newValue, oldValue);}")();

   	/**
	 * 데이터의 값이 변경되었을 때 발생하는 이벤트 
	 *
	 * @event DataObject#change
	 * @type {Object}
     * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
	 * @property {String} 						fieldId - 변경된 데이터의 필드ID
	 * @property {String|Number|Boolean|Object} newValue - 변경후 데이터 
	 * @property {String|Number|Boolean|Object} oldValue - 변경전 데이터 
	 */
    this.hasChangeEvent = (typeof self[this.id + "_onChange"] != "undefined");
    this.fncChangeEvent = !this.hasChangeEvent ? null : new Function("return function (fieldId, newValue, oldValue) { return " + this.id + "_onChange(fieldId, newValue, oldValue);}")();
    if (!this.hasChangeEvent){  // 구버전 이벤트 대소문자 호환을 위한 코딩
    	this.hasChangeEvent = (typeof self[this.id + "_onchange"] != "undefined");
    	this.fncChangeEvent = !this.hasChangeEvent ? null : new Function("return function (fieldId, newValue, oldValue) { return " + this.id + "_onchange(fieldId, newValue, oldValue);}")();
    }

   	/**
	 * 줄 추가전 발생하는 이벤트 .
	 *
	 * @event DataObject#CanAddRecord
	 * @type {Object}
     * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
	 */
    this.hasCanAddRecordEvent = (typeof self[this.id + "_onCanAddRecord"] != "undefined");
    this.fncCanAddRecordEvent = !this.hasCanAddRecordEvent ? null : new Function("return function () { return " + this.id + "_onCanAddRecord();}")();
    
   	/**
	 * 줄 추가시 발생하는 이벤트 .
	 *
	 * @event DataObject#AddRecord
	 * @type {Object}
	 */
    this.hasAddRecordEvent = (typeof self[this.id + "_onAddRecord"] != "undefined");
    this.fncAddRecordEvent = !this.hasAddRecordEvent ? null : new Function("return function () { return " + this.id + "_onAddRecord();}")();

   	/**
	 * 줄 삭제전 발생하는 이벤트 .
	 *
	 * @event DataObject#CanDeleteRecord
	 * @type {Object}
     * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
	 */
    this.hasCanDeleteRecordEvent = (typeof self[this.id + "_onCanDeleteRecord"] != "undefined");
    this.fncCanDeleteRecordEvent = !this.hasCanDeleteRecordEvent ? null : new Function("return function () { return " + this.id + "_onCanDeleteRecord();}")();
    
   	/**
	 * 줄 삭제시 발생하는 이벤트 .
	 *
	 * @event DataObject#DeleteRecord
	 * @type {Object}
	 */
    this.hasDeleteRecordEvent = (typeof self[this.id + "_onDeleteRecord"] != "undefined");
    this.fncDeleteRecordEvent = !this.hasDeleteRecordEvent ? null : new Function("return function () { return " + this.id + "_onDeleteRecord();}")();
    
    //  
   	/**
	 * ChangeEvent , addrow, delrow가 발생되지 않는 대량 데이터 변경시 발생하는 이벤트 .
	 *
	 * @event DataObject#DataResetted
	 * @type {Object}
     * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
	 */
    this.hasDataResettedEvent = (typeof self[this.id + "_onDataResetted"] != "undefined");
    this.fncDataResettedEvent = !this.hasDataResettedEvent ? null : new Function("return function (actionType, error) { return " + this.id + "_onDataResetted(actionType, error);}")();
    
    // ----- 소스내 SKIP 함수가 있으면 참조 --------- 
    this.hasNeedSkipFunction = (typeof self[this.id + "_needSkip"] != "undefined");
    this.fncNeedSkip = !this.hasNeedSkipFunction ? null : new Function("return function () { return " + this.id + "_needSkip();}")();

};

/**
 * @description 			
 *     객체ID로 객체를 선택한다.
 *     예를 들어 '학생' 이란 객체의 ID가 'student'인 경우 
 *     objects['학생'] 또는 getObjectById('student')로 찾게 된다.
 *     
 * @param {String}		id 	- 선택할 객체의 ID
 * 
 * @returns {DataObject}	- 선택돤 객체 
 * 
 * @example
 *     var student = getObjectById("student");       // 학생 객체를 선색
 */
function getObjectById(id){
	var key = null;
	
	for(key in objects){
		if( objects[key] instanceof Function )
			continue;
		
		if( objects[key].id === id )
			return objects[key];
		
		key = null; 
	}
	
	return null;
};

/**
 * @description 
 *     객체에 필드 속성을 추가한다 
 * 
 * @param  {String}		id			추가된 속성의 식별자 ID <br/>
 * @param  {String}		fieldId		추가된 속성의 FieldID(= 식별자 ID) <br/>
 * @param  {String}		name		추가될 속성의 이름 <br/>
 * @param  {String}		propertyGu	추가될 속성의 형태 field,file,function, ... <br/>
 * @param  {String}		dataTypeName	추가될 속성의 데이터형 <br/>
 * @param  {String}		isKey		속성이 키필드 역할을 하는 지 구분 <br/> false: 키필드가 아니다, true: 키필드이다, seq: 순번키필드이다 <br/>
 * @param  {String}		formula		레코드가 생성될 때 디폴트 값을 지정하는 산식  <br/>
 * @param  {Boolean}	permitNull	해당 속성이 널값을 허용하는지 여부  <br/>
 * 
 * @return {propertyInfo} 			추가된 propertyInfo 객체 

 * @example 
 * 	var propertyInfo = object.addProperty ("studentid", "studentid", "학번", "field", "String", "true", "", false);
 */
DataObject.prototype.addProperty = function(id, fieldId, name, propertyGu, dataTypeName, isKey, formula, permitNull){
	// functionname : [DataObject.addProperty]
	
	var propertyInfo = null;
	var functionName = null;
	
	/*	프로퍼티 정보는 데이터 셋에 포함되지 않는 정보는 가져간다
	 *	추가되었을때 데이터 셋에 없으면 추가해 준다
	 */
	
	propertyInfo = new PropertyInfo(id, fieldId, name);
	
//	this.propertyInfos[++this.propertyCount] = propertyInfo;
	this.propertyInfos[this.propertyCount++] = propertyInfo;
	this.propertyInfosById[id] = propertyInfo;
	
	propertyInfo.id = id;
	propertyInfo.fieldId = fieldId;
	propertyInfo.name = name;
	propertyInfo.propertyGu = propertyGu;
	propertyInfo.dataTypeName = dataTypeName;
	propertyInfo.isKey = (isKey === "false" ? false : true); // true/false/seq;
	propertyInfo.isSeqKey = (isKey === "seq" ? true : false); // true/false/seq;
//	propertyInfo.formula = formula;
//	propertyInfo.defaultValue = formula;
	propertyInfo.permitNull = permitNull;
	
	if( formula.length > 0 ){
		propertyInfo.formula = new Function("return " + formula + ";");
		propertyInfo.defaultValue = new Function("return " + formula + ";");
	}
	
//	if (propertyInfo.isSeqKey == "seq"){
//		this.seqKeyFieldId = fieldId;
//	}
	if( propertyInfo.isSeqKey ){
		this.seqKeyFieldId = fieldId;
	}

	var numericTypes = [
        "short", "long", "single", "double", "currency", "bit", "byte", "guid" /* MDB */
        , "smallint", "int", "real", "float", "money", "smallmoney", "bit", "tinyint", "uniqueidentifier", "timestamp", "decimal", "numeric" /* MSSQL */
        , "decimal", "money", "integer", "serial", "smallint", "smallfloat", "float" /* Informix */
        , "float", "number" /* Oracle */
        , "bit", "bit auto_increment", "tinyint", "tinyint unsigned", "tinyint auto_increment", "tinyint unsigned auto_increment", "bigint"
        , "bigint unsigned", "bigint auto_increment", "bigint unsigned auto_increment", "decimal", "integer", "integer unsigned", "int", "int unsigned", "mediumint"
        , "mediumint unsigned", "integer auto_increment", "integer unsigned auto_increment", "int auto_increment"
        , "int unsigned auto_increment", "mediumint auto_increment", "mediumint unsigned auto_increment", "smallint"
        , "smallint unsigned", "smallint auto_increment", "smallint unsigned auto_increment", "double", "double auto_increment", "float"
        , "float auto_increment", "double", "double auto_increment", "year" /* MySQL */
	];

	propertyInfo.isNumericType = (numericTypes.indexOf(dataTypeName.toLowerCase()) >= 0);

	functionName = fieldId.substring(0,1).toUpperCase() + fieldId.substring(1);
	
	if( propertyGu == "field" && functionName != "Seq" ){
		this["set" + functionName] = new Function("return function (value) { return this.setValue(\"" + fieldId + "\", value);}")();
		this["get" + functionName] = new Function("return function() { return this.getValue(\"" + fieldId + "\");}")();
		this["set" + functionName + "All"] = new Function("return function (value) { return this.setValueAll(\"" + fieldId + "\", value);}")();
	}
	// 배치호출
	else if( propertyGu == "service" ){
		/* */
	}
	else if( propertyGu == "function" ){
		this["get" + functionName] = new Function("return function() { return " + formula + ";}")();
	}
	// 파일동작
	else if( propertyGu == "file" ){
		this["set" + functionName] = new Function("return function (value) { return this.setValue(\"" + fieldId + "\", value);}")();
		this["get" + functionName] = new Function("return function() { return this.getValue(\"" + fieldId + "\");}")();
		this["set" + functionName + "All"] = new Function("return function (value) { return this.setValueAll(\"" + fieldId + "\", value);}")();
	}
	
	//메모리 해제
	functionName = null;
	
	// 채우기 필수 키정보 채우기
	if( ("," + keyInfoStr).indexOf("," + this.id + "_" + id + ",") > 0 ){
		propertyInfo.isFillKey = true;
	}
	
	// 데이터셋에 필드 추가
	this.dataSet.addField({
		field: id
		, fieldId: name
		, dataType: (propertyInfo.isNumericType ? "number" : "string")
	}); // ??? 데이터세트와 시트, 객체의 데이터 타입을 정리하여 소스 정비 할 것
	
	return propertyInfo;
};

/**
 * @description 
 *     DataSet정보를 받아 객체내 데이터셋을 교체한다 .
 * 
 * @param  {Object}		dataSet	추가될 데이터를 포함하는 데이터셋 정보 <br/>
 * @return {Object} 				오류정보룰 포함하는 개체 <br/>
 * 									- {result: true/false, errorMsg: "사용자메시지"}<br/>
 * @example 
 * var rtnObject = object.setDataSet(anotherDataset);
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 */
DataObject.prototype.setDataSet = function(dataset){
	// functionname : [DataObject.setDataSet]
	
	var rtnObject = null;
	var errorInfo = null;
	
	this.clear();
	
	// 객체 데이터셋 데이터 갱신
	rtnObject = this.dataSet.setDataSet(dataset);
	
	var propertyInfo = null;
	var fieldInfoKey = null;
	var fieldId = null;
	var dataList = this.dataSet.data;
	var dataRecord = null;
	var dataLength = dataList.length;
	var isSame = false;
	var newSeq = this.startSeq;
//	var oldSeq = this.seq;
	var i = 0;
	
	for(i = 0; i < dataLength; i++, newSeq++){
		dataRecord = dataList[i];
		
		for(fieldId in this.propertyInfosById){
			propertyInfo = this.propertyInfosById[fieldId];
			
			if( !propertyInfo.isNumericType ){
				propertyInfo = null; fieldId = null;
				continue;
			}
			
			if( propertyInfo.propertyGu == "field" ){
				for(fieldInfoKey in this.dataSet.fieldInfos){
					if( fieldId.toLocaleLowerCase() == fieldInfoKey.toLocaleLowerCase() ){
						isSame = true; break;
					}
					fieldInfoKey = null;
				}
			}
			else if( propertyInfo.propertyGu == "function" ){
				this.seq = newSeq;
				dataRecord[fieldId] = propertyInfo.formula();
				isSame = true;
			}
			
			if( !isSame ){
				propertyInfo = null; fieldId = null;
				continue;
			}
			
			value = 1 * dataRecord[fieldId];
			propertyInfo.min = (propertyInfo.min > value ? value : propertyInfo.min);
			propertyInfo.max = (propertyInfo.max < value ? value : propertyInfo.max);
//			propertyInfo.sum += value;
			this._updateSum(fieldId, 0, value);
			
			value = null; propertyInfo = null; fieldId = null;
		}
		
		dataRecord = null;
	}
	
	this.seq = this.startSeq;
	this.count = dataLength;
	
	// 사용자 코딩 추가영역을 호출한다
	if( rtnObject.result == true ){
		if( this.FireEvent && this.hasDataResettedEvent ){
			errorInfo = {code: 0, message: ""};
			
			this.fncDataResettedEvent(OBJECT_DATA_RESET_BY_SETDATASET, errorInfo);
			
			// 서브루틴에서 메시지 표시한 오류는 (-)로 넘어 오도록 한다.
			if( errorInfo.code > 0 )
				alert(errorInfo.message);
			
			// 메모리 해제
			errorInfo = null;
		}
	}
	
	return rtnObject;
};

/**
 * @description 
 *     DataSet정보를 받아 객체내 데이터셋에 데이터를 추가한다 .
 * 
 * @param  {Object}		dataSet	추가될 데이터를 포함하는 데이터셋 정보 <br/>
 * @return {Object} 				오류정보룰 포함하는 개체 <br/>
 * 									- {result: true/false, errorMsg: "사용자메시지"}<br/>
 * @example 
 * var rtnObject = object.setDataSet(anotherDataset);
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 */
DataObject.prototype.appendDataSet = function(dataset){
	// functionname : [DataObject.appendDataSet]
	
	var rtnObject = null;
	var errorInfo = null;
	
	//객체 데이터셋 데이터 추가
	rtnObject = this.dataSet.appendDataSet(dataset);
	
	var propertyInfo = null;
	var fieldInfoKey = null;
	var fieldId = null;
	var dataList = this.dataSet.data;
	var dataRecord = null;
	var dataLength = dataList.length;
	var isSame = false;
	var newSeq = this.startSeq;
	var oldSeq = this.seq;
	var i = 0;
	
	for(i = 0; i < dataLength; i++, newSeq++){
		dataRecord = dataList[i];
		
		for(fieldId in this.propertyInfosById){
			propertyInfo = this.propertyInfosById[fieldId];
			
			if( !propertyInfo.isNumericType ){
				propertyInfo = null; fieldId = null;
				continue;
			}
			
			if( propertyInfo.propertyGu == "field" ){
				for(fieldInfoKey in this.dataSet.fieldInfos){
					if( fieldId.toLocaleLowerCase() == fieldInfoKey.toLocaleLowerCase() ){
						isSame = true; break;
					}
					fieldInfoKey = null;
				}
			}
			else if( propertyInfo.propertyGu == "function" ){
				this.seq = newSeq;
				dataRecord[fieldId] = propertyInfo.formula();
				isSame = true;
			}
			
			if( !isSame ){
				propertyInfo = null; fieldId = null;
				continue;
			}
			
			value = 1 * dataRecord[fieldId];
			propertyInfo.min = (propertyInfo.min > value ? value : propertyInfo.min);
			propertyInfo.max = (propertyInfo.max < value ? value : propertyInfo.max);
//			propertyInfo.sum += value;
			this._updateSum(fieldId, 0, value);
			
			value = null; propertyInfo = null; fieldId = null;
		}
		
		dataRecord = null;
	}
	
	this.seq = oldSeq;
	this.count = dataLength;
	
	// 사용자 코딩 추가영역을 호출한다
	if( rtnObject.result == true ){
		if( this.FireEvent && this.hasDataResettedEvent ){
			errorInfo = {code: 0, message: ""};
			
			this.fncDataResettedEvent(OBJECT_DATA_RESET_BY_APPENDDATASET, errorInfo);
			
			// 서브루틴에서 메시지 표시한 오류는 (-)로 넘어 오도록 한다.
			if( errorInfo.code > 0 )
				alert(errorInfo.message);
			
			// 메모리 해제
			errorInfo = null;
		}
	}
	
	return rtnObject;
};

/**
 * @description 
 *     DataSet정보를 받아 객체내 데이터셋을 교체한다 .
 * 
 * @param  {Object}		Array	추가될 데이터를 포함하는 데이터 리스트(배열) <br/>
 * @param  {Object}		Array	추가될 데이터를 포함하는 데이터 컬럼 정보 <br/>
 * @return {Object} 			오류정보룰 포함하는 개체 <br/>
 * 								- {result: true/false, errorMsg: "사용자메시지"}<br/>
 * @example 
 * var rtnObject = object.setDataArray(anotherDataArray, fieldInfo);
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 */
DataObject.prototype.setDataArray = function(dataArray, fieldInfo){
	// functionname : [DataObject.setDataArray]
	
	if( typeof fieldInfo == "undefined" ){
		fieldInfo = this.dataSet.columnInfos;
	}
	
	var rtnObject = null;
	var errorInfo = null;
	
	this.clear();
	
	// 객체 데이터셋 데이터 갱신
	rtnObject = this.dataSet.setDataArray(dataArray, fieldInfo);
	
	var propertyInfo = null;
	var fieldInfoKey = null;
	var fieldId = null;
	var dataList = this.dataSet.data;
	var dataRecord = null;
	var dataLength = dataList.length;
	var isSame = false;
	var newSeq = this.startSeq;
//	var oldSeq = this.seq;
	var i = 0;
	
	for(i = 0; i < dataLength; i++, newSeq++){
		dataRecord = dataList[i];
		
		for(fieldId in this.propertyInfosById){
			propertyInfo = this.propertyInfosById[fieldId];
			
			if( !propertyInfo.isNumericType ){
				propertyInfo = null; fieldId = null;
				continue;
			}
			
			if( propertyInfo.propertyGu == "field" ){
				for(fieldInfoKey in this.dataSet.fieldInfos){
					if( fieldId.toLocaleLowerCase() == fieldInfoKey.toLocaleLowerCase() ){
						isSame = true; break;
					}
					fieldInfoKey = null;
				}
			}
			else if( propertyInfo.propertyGu == "function" ){
				this.seq = newSeq;
				dataRecord[fieldId] = propertyInfo.formula();
				isSame = true;
			}
			
			if( !isSame ){
				propertyInfo = null; fieldId = null;
				continue;
			}
			
			value = 1 * dataRecord[fieldId];
			propertyInfo.min = (propertyInfo.min > value ? value : propertyInfo.min);
			propertyInfo.max = (propertyInfo.max < value ? value : propertyInfo.max);
//			propertyInfo.sum += value;
			this._updateSum(fieldId, 0, value);
			
			value = null; propertyInfo = null; fieldId = null;
		}
		
		dataRecord = null;
	}
	
	this.seq = this.startSeq;
	this.count = dataLength;
	
	// 사용자 코딩 추가영역을 호출한다
	if( rtnObject.result == true ){
		if( this.FireEvent && this.hasDataResettedEvent ){
			errorInfo = {code: 0, message: ""};
			
			this.fncDataResettedEvent(OBJECT_DATA_RESET_BY_SETDATASET, errorInfo);
			
			// 서브루틴에서 메시지 표시한 오류는 (-)로 넘어 오도록 한다.
			if( errorInfo.code > 0 )
				alert(errorInfo.message);
			
			// 메모리 해제
			errorInfo = null;
		}
	}
	
	return rtnObject;
};

/**
 * @description 
 *     DataSet정보를 받아 객체내 데이터셋에 데이터를 추가한다 .
 * 
 * @param  {Object}		Array	추가될 데이터를 포함하는 데이터 리스트(배열) <br/>
 * @param  {Object}		Array	추가될 데이터를 포함하는 데이터 컬럼 정보 <br/>
 * @return {Object} 			오류정보룰 포함하는 개체 <br/>
 * 								- {result: true/false, errorMsg: "사용자메시지"}<br/>
 * @example 
 * var rtnObject = object.appendDataArray(anotherDataArray, fieldInfo);
 * 
 * // 오류를 리턴하는 경우의 처리 
 * if (rtnObject.result == false){
 *     alert(rtnObject.errorMsg);
 * }
 */
DataObject.prototype.appendDataArray = function(dataArray, fieldInfo){
	// functionname : [DataObject.appendDataArray]
	
	if( typeof fieldInfo == "undefined" ){
		fieldInfo = this.dataSet.columnInfos;
	}
	
	var rtnObject = null;
	var errorInfo = null;
	
	//객체 데이터셋 데이터 추가
	rtnObject = this.dataSet.appendDataArray(dataArray, fieldInfo);
	
	var propertyInfo = null;
	var fieldInfoKey = null;
	var fieldId = null;
	var dataList = this.dataSet.data;
	var dataRecord = null;
	var dataLength = dataList.length;
	var isSame = false;
	var newSeq = this.startSeq;
	var oldSeq = this.seq;
	var i = 0;
	
	for(i = 0; i < dataLength; i++, newSeq++){
		dataRecord = dataList[i];
		
		for(fieldId in this.propertyInfosById){
			propertyInfo = this.propertyInfosById[fieldId];
			
			if( !propertyInfo.isNumericType ){
				propertyInfo = null; fieldId = null;
				continue;
			}
			
			if( propertyInfo.propertyGu == "field" ){
				for(fieldInfoKey in this.dataSet.fieldInfos){
					if( fieldId.toLocaleLowerCase() == fieldInfoKey.toLocaleLowerCase() ){
						isSame = true; break;
					}
					fieldInfoKey = null;
				}
			}
			else if( propertyInfo.propertyGu == "function" ){
				this.seq = newSeq;
				dataRecord[fieldId] = propertyInfo.formula();
				isSame = true;
			}
			
			if( !isSame ){
				propertyInfo = null; fieldId = null;
				continue;
			}
			
			value = 1 * dataRecord[fieldId];
			propertyInfo.min = (propertyInfo.min > value ? value : propertyInfo.min);
			propertyInfo.max = (propertyInfo.max < value ? value : propertyInfo.max);
//			propertyInfo.sum += value;
			this._updateSum(fieldId, 0, value);
			
			value = null; propertyInfo = null; fieldId = null;
		}
		
		dataRecord = null;
	}
	
	this.seq = oldSeq;
	this.count = dataLength;
	
	// 사용자 코딩 추가영역을 호출한다
	if( rtnObject.result == true ){
		if( this.FireEvent && this.hasDataResettedEvent ){
			errorInfo = {code: 0, message: ""};
			
			this.fncDataResettedEvent(OBJECT_DATA_RESET_BY_APPENDDATASET, errorInfo);
			
			// 서브루틴에서 메시지 표시한 오류는 (-)로 넘어 오도록 한다.
			if( errorInfo.code > 0 )
				alert(errorInfo.message);
			
			// 메모리 해제
			errorInfo = null;
		}
	}
	
	return rtnObject;
};

/**
 * @description 
 *     DataSet정보를 받아 객체내 데이터셋에서 데이터셋을 삭제하고 초기화한다.
 * 
 * @return {Void}
 * @example 
 * 	var rtnObject = object.removeDataSet();
 */
DataObject.prototype.removeDataSet = function(){
	// functionname : [DataObject.removeDataSet]
	
	var errorInfo = null;
	
	// 데이터셋 초기화
	this.dataSet.clear();
	this.dataSet = null;
	this.dataSet = new WsDataSet();
	
	this.maxSeq = 0;
    this.seq = 0;
    this.count = 0;
	
	// 사용자 코딩 추가영역을 호출한다
	if( this.FireEvent && this.hasDataResettedEvent ){
		errorInfo = {code: 0, message: ""};
		
		this.fncDataResettedEvent(OBJECT_DATA_RESET_BY_REMOVEDATASET, errorInfo);
		
		// 서브루틴에서 메시지 표시한 오류는 (-)로 넘어 오도록 한다.
		if( errorInfo.code > 0 )
			alert(errorInfo.message);
		
		// 메모리 해제
		errorInfo = null;
	}
	
	return;
};

/**
 * @description 
 *     객체 데이터를 시트 컨트롤에 갱신한다.
 * 
 * @param  {String}		sheetName	데이터를 갱신할 시트명
 * @return {Boolean} 				시트 데이터를 갱신한다면 true를 리턴
 * @example 
 * var result = object.updateDataLinkedSheet("Sheet_1");
 */
DataObject.prototype.updateDataLinkedSheet = function( sheetName ){
	//예외처리
	//1. 시트 명 파라메터가 없는 경우 예외처리
	if( typeof sheetName == "undefined" || sheetName == null )
		return false;
	
	var control = null;
	var linkedObjectList = null;
	var linkedObjectSize = 0;
	var isLinkedSheet = false;
	var i = 0, j = 0;
	
	//2. 시트 컨트롤이 없는 경우 예외처리
	control = controls["" + sheetName];
	if( typeof control == "undefined" || control == null )
		return false;
	//3. 시트에 연결된 객체가 없는 경우 예외처리
	linkedObjectList = control.linkedObjects;
	if( typeof linkedObjectList == "undefined" || linkedObjectList == null )
		return false;
	//4. 시트에 연결된 객체 중 자신(객체)이 없는 경우 예외처리
	for(i = 0, linkedObjectSize = linkedObjectList.length && !isLinkedSheet; i < linkedObjectSize; i++){
		isLinkedSheet = (linkedObjectList[i] === this);
	}
	if( !isLinkedSheet ){
		linkedObjectList = null; control = null;
		return false;
	}
	
	var linkedObjectId = this.id;
	var propertyCount = this.propertyCount;
	var columnCount = control.columns.length;
	var columnInfo = null;
	var needMappingData = false;
	
	//객체 프로퍼티와 열결된 시트 컬럼ID 체크
	for(i = 0; i < columnCount && !needMappingData; i++){
		columnInfo = control.columns[i];
		
		//객체 프로퍼티와 연결된 컬럼이 없는 경우
		if( !(linkedObjectId in columnInfo.linkedPropertys) )
			continue;
		//객체 프로퍼티와 연결된 컬럼의 아이디가 다르면 매핑데이터 생성 필요
		if( columnInfo.colId != columnInfo.linkedPropertys[linkedObjectId] )
			needMappingData = true;
		
		//메모리 해제
		columnInfo = null;
	}
	
	var remakeDataset = null;
	var recordLength = this.dataSet.getCount();
	var recordList = null;
	var recordItem = null;
	var dataRow = null;
	
	//매핑데이터 생성 여부 체크하여 데이터 생성
	if( needMappingData ){
		remakeDataset = new WsDataSet();
		remakeDataset.deleteDataPolicy = WSDATASET_DELETE_POLICY.LEAVE_RECORD_IN_DATA;
		recordList = [];
		
		for(i = 0; i < recordLength; i++){
			recordItem = recordList[i] = {};
			dataRow = this.dataSet.data[i];
			
			for(j = 0; j < columnCount; j++){
				columnInfo = control.columns[j];
				if( !linkedObjectId in columnInfo.linkedPropertys ) continue;
				recordItem[columnInfo.colId] = dataRow[columnInfo.linkedPropertys[linkedObjectId]];
				columnInfo = null;
			}
			
			if( typeof dataRow.__STATE__ != "undefined" ){
				recordItem.__STATE__ = {"updateGu" : dataRow.__STATE__.updateGu};
			}
			
			dataRow = null; recordItem = null;
		}
		
		remakeDataset.setDataArray(recordList);
		recordLength = remakeDataset.getCount();
		
		//메모리 해제
		recordList.clear(); recordList = null;
		linkedObjectId = null;
	}
	else{
		remakeDataset = this.dataSet;
	}
	
	//시트 데이터 갱신
	control._updateDataSetByLinkedObject(remakeDataset);
	//시트 objectSeq 갱신
	if( this.seqKeyFieldId.length > 0 ){
		var oldSeq = this.seq;
		
		for(i = this.startSeq, j = control.startRowColNum; i <= recordLength; i++, j++){
			this.seq = i;
			control.rows(j).objectSeq = this.getValue(this.seqKeyFieldId);
		}
		
		this.seq = oldSeq;
	}
	else{
		for(i = this.startSeq, j = control.startRowColNum; i <= recordLength; i++, j++){
			control.rows(j).objectSeq = i;
		}
	}
	
	//메모리 해제
	control = null;
	if( remakeDataset !== this.dataSet ) remakeDataset.clear();
	remakeDataset = null; linkedObjectList = null;
	
	return true;
};

DataObject.prototype.resetState = function(){
	//예외처리
	//아래의 경우 객체 레코드의 상태를 수정하지 않음
	// 1. 객체로드로 조회한 경우
	// 2. 객체의 dni모드가 true인 경우 
	if( objectManager.dataloaded || this.dniMode ) return;
	
	var resetUpdateGuList = ["N", "I", "U"];
	
	//
	var propertyInfos = this.propertyInfos;
	var propertyCount = this.propertyCount;
	var propertyId = null;
	var recordList = this.dataSet.data;
	var recordSize = recordList.length;
	var record = null;
	var recordOld = null;
	var updateGu = null;
	var i = 0; var j = 0;
	
	for(i = 0; i < recordSize; i++){
		record = recordList[i];
		recordOld = record.__STATE__.oldData;
		updateGu = record.__STATE__.updateGu;
		
		if( resetUpdateGuList.indexOf(updateGu) >= 0 ){
			//현재 레코드의 데이터와 이전 데이터를 일치시킴.
			for(j = 0; j < propertyCount; j++, propertyId = null){
				propertyId = propertyInfos[j].id;
				recordOld[propertyId] = record[propertyId];
			}
			//업데이트 구분을 N으로 설정
			record.__STATE__.updateGu = "N";
		}
		
		//메모리 해제
		updateGu = null; recordOld = null; record = null;
	}
	
	//메모리 해제
	recordList = null;
	propertyInfos = null;
	resetUpdateGuList = null;
	
	/*
	//객체와 연결된 시트 컨트롤의 데이터를 갱신
	var key = null;
	var control = null;
	//현재 화면에 시트 컨트롤이 존재하는 경우에만 갱신
	if( typeof EasySheet != "undefined" ){
		for(key in controls){
			control = controls[key];
			//컨트롤이 시트인 경우에만 갱신
			if( control instanceof EasySheet ){
				for(i = control.linkedObjects.length - 1; i >= 0; i--){
					if( control.linkedObjects[i].id == this.id ){
						this.updateDataLinkedSheet(control.controlName);
//						this.setSeq(this.startSeq);
					}
	            }
	        }
			//메모리 해제
			control = null; key = null;
		}
	}
	*/
};

/**
 * @description 
 *     데이터를 clear하면 전체줄을 모두 지우고 한줄을 추가한다. <br/>
 *     객체의 모든 설정이 초기화 된다 .<br/>
 *     <br/>
 *     이때 객체의 설정된 속성 정보는 계속 유효하다. <br/>
 * 
 * @return {Void}  

 * @example 
 * 	object.clear();
 */
DataObject.prototype.clear = function(){
	// functionname : [DataObject.clear]
	
	var propertyInfo = null;
	var propertyNum = 0;
	var errorInfo = null;
	
	this.dataSet.clearData(); 
	
	this.maxSeq = 0;
	this.seq = 0;
	this.count = 0;		// 집계함수 연산에 필요한 값
	
	for(propertyNum = 0; propertyNum < this.propertyCount; propertyNum++){
		propertyInfo = this.propertyInfos[propertyNum /*+ this.startSeq*/];
		
		if( propertyInfo.isNumericType ){
			propertyInfo.min = 0;
			propertyInfo.max = 0;
			propertyInfo.sum = 0;
		}
		
		// 메모리 해제
		propertyInfo = null;
	}
	
	// 사용자 코딩 추가영역을 호출한다
//	if( this.FireEvent && this.hasDataResettedEvent ){
//		errorInfo = {code:0, message:""};
//		
//		this.fncDataResettedEvent(OBJECT_DATA_RESET_BY_CLEAR, errorInfo);
//		
//		if( errorInfo.code != 0 ){
//			alert(errorInfo.message);
//		}
//		
//		// 메모리 해제
//		errorInfo = null;
//	}
	
	return;
};

/**
 * @description 
 *     현재 포커싱되어 처리중인 레코드가 아직 아무 작업도 진행되지 않고 비어 있는지 여부를 말해주는 함수. <br/>

 * @return {Boolean}		- 비어있는 레코드이면 true를 리턴한다 
 * @example 
 * 	// 빈줄이면 메시지를 보여 준다. 
 * 	if (object.isEmpty()){
 *  	alert("아직 처리되지 않은 레코드입니다.");
 * 	}
 */
DataObject.prototype.isEmpty = function(){
	// functionname : [DataObject.isEmpty]
	
	return (
		this.dataSet.data.length == 0
		|| (this.dataSet.data.length == 1 && ["X", "D"].indexOf(this.getUpdateGu(this.seq)) >= 0)
	);
};

/**
 * @description 
 *     해당 순번에 해당하는 레코드의 IUD 상태를 리턴한다   
 *     
 * @return {String} 		
 */
DataObject.prototype.getUpdateGu = function(seq) {
	// functionname : [DataObject.getUpdateGu]
	
	return this.dataSet.getState((seq - this.startSeq), "updateGu");
};
/**
 * @description 
 *     해당 순번에 해당하는 레코드의 IUD 상태를 설정한다   
 *     
 * @return {String} 		
 */
DataObject.prototype.setUpdateGu = function(seq, updateGu) {
	// functionname : [DataObject.setUpdateGu]
	
	return this.dataSet.setState((seq - this.startSeq), "updateGu", updateGu);
};

/**
 * @description 
 *     객체로 "Load"동작을 통해서 데이터를 가져온 후 화면에 채우는 기준이 되는 속성의 ID를 채운다. <br/> 
 *     대량의 데이터를 로드해서 기준을 바꾸어 가며 화면에 표시하고 작업할 때 사용한다. <br/>

 * @return {Void}
 * @example 
 * 	// studentId 필드를 채우기의 기준으로 삼는다. 
 * 	object.setFillKeyFieldId("studentId");
 */
DataObject.prototype.setFillKeyFieldId = function(fieldId){
	// functionname : [DataObject.setFillKeyFieldId]
	
	this.fillKeyFieldName = fieldId;
	this.fillKeyFieldId = fieldId;
};

/** 
 * @deprecated since version 5.0, object.setFillKeyFieldId() 로 대체 
 * */
DataObject.prototype.setFillKeyFieldName = function(fieldId){
	// functionname : [DataObject.setFillKeyFieldName]
	
	this.setFillKeyFieldId(fieldId);
};

/**
 * @description 
 *     인수로 받은 순번에 해당하는 레코드를 찾아 순번 필드값을 갱신한다. <br/>
 *     순번과 순번 필드의 개념은 다르다. 
 * 
 * @param  {Number}	seq			변경항 데이터의 순번 <br/>
 * @param  {Number}	seqValue	새로운 순번 값 <br/>
 * 
 * @return {Void} 
 * @example 
 * 
 * 	object.updateSeqField(1, 100);		// 1번 레코드의 순번 값을 100으로 변경한다
 */
DataObject.prototype.updateSeqField = function(seq, seqValue){
	// functionname : [DataObject.updateSeqField]
	
	var rowNum = 0;
	var oldSeq = 0;
	
	if( this.seqKeyFieldId == "" ){
		rowNum = seq - this.startSeq;
		
		this.dataSet.setState(rowNum, "tempSeqKey", seqValue);
    }
	else{
		oldSeq = this.seq;
		
		this.seq = seq;
		this.setValue(this.seqKeyFieldId, seqValue);
		this.seq = oldSeq;
	}
	
	return;
};

/**
 * @description 
 * 		현재 포커싱되어 처리중인 레코드에서 인수로 지정한 레코드로 이동하는 함수이다.<br/>
 *  
 * @return {Void}		
 * @example 
 * 	// 1번 Seq로 데이터를 이동한다. 
 * 	object.setSeq(1);
 */
DataObject.prototype.setSeq = function(seq){
	// functionname : [DataObject.setSeq]
	
	if( this.seq == seq )
		return true;
	
	if( seq > this.maxSeq - 1 + this.startSeq ){
		alert(getText("message_object_001", "현재의 줄 수{0}보다 클 수는 없습니다.", [this.maxSeq]));
		return false;
	}
	
	// 사용자 코딩 추가영역을 호출한다
	if( this.hasCanSeqChangeEvent ){
		if( !this.fncCanSeqChangeEvent(this.seq, seq) )
			return false;
	} 	

	var result = true;
	var oldSeq = this.seq;
	
	this.seq = seq;
	
//	// seq이면 _onSeqChanged이벤트를 호출하지 않는다
//	if( seq == this.startSeq ) return;
	
	if( this.FireEvent && this.hasSeqChangeEvent ){
		result = this.fncSeqChangeEvent(oldSeq, seq);
		
		if( typeof result == "boolean" && !result ){
			this.seq = oldSeq;
			return false;
		}
	}
	
	return true;
};

/**
 * @description 
 * 		현재 포커싱되어 처리중인 레코드 다음의 유효레코드로 이동하고 이동한 레코드의 seq값을 돌려주는 함수이다.<br/>
 * 		다음 줄이 삭제된 레코드인 경우 제외하고 다음 유효한 레코드로 이동하게 된다. 
 * 		이떄 유효한 레코드가 없으면 첫레코드로 되돌아 간다.
 *  
 * @return {Boolean}		- 비어있는 레코드이면 true를 리턴한다 
 * @example 
 * 	// 빈줄이면 메시지를 보여 준다. 
 * 	var seq = object.isEmpty();
 */
DataObject.prototype.moveNext = function(){
	// functionname : [DataObject.moveNext]
	
	var haveNextData = false;
	var seq = 0;
	var oldSeq = this.seq;
	var nextSeq = 0;
	var rowNum = 0;
	
	if( this.fillkeyFieldValue.length == 0 ){
		for(seq = this.seq + 1; seq < this.dataSet.data.length && !haveNextData; seq++){
			rowNum = seq - this.startSeq;
			
			if( ["X","D"].indexOf(this.getUpdateGu(seq)) < 0 ){
				haveNextData = true;
				nextSeq = seq;
			}
		}
	}
	else{
		for(seq = this.seq + 1; seq < this.dataSet.data.length && !haveNextData; seq++){
			rowNum = seq - this.startSeq;
			
			if( ["X","D"].indexOf(this.getUpdateGu(seq)) < 0 ){
				if( this.dataSet.data[rowNum][this.fillKeyFieldId] == this.fillkeyFieldValue ){
					haveNextData = true;
					nextSeq = seq;
				}
			}
		}
	}
	
	// 사용자 코딩 추가영역을 호출한다
	if( this.hasCanSeqChangeEvent ){
		if( !this.fncCanSeqChangeEvent(this.seq, nextSeq) )
			return false;
	}
	
	if( haveNextData )
		this.seq = nextSeq;
	else
		this.seq = this.startSeq;	// 다음 레코드가 없으면 처음으로 돌아간다.
	
	if( this.FireEvent && this.hasSeqChangeEvent )
		this.fncSeqChangeEvent(oldSeq, this.seq);
	
	return haveNextData;
};

/**
 * @description 
 *     객체에 레코드를 한 줄 추가한다. 
 * @param  {Boolean}	withEvents		AddRecord 이벤트를 발생시킬것인지 여부 
 * @return {Number} 					추가된 레코드의 순번을 리턴한다. 
 * @example 
 * 
 * 	var seq = object.addNewData();		// AddRecord 이벤트 발생
 * 	var seq = object.addNewData(false);	// AddRecord 이벤트 발생 안함 
 * 
 */
DataObject.prototype.addNewData = function(withEvents){
	// functionname : [DataObject.addNewData]
	
	if( typeof withEvents == "undefined" )
		withEvents = true;
	
	// 사용자 코딩 추가영역을 호출한다
	if( this.hasCanAddRecordEvent && withEvents ){
		if( !this.fncCanAddRecordEvent() ){
			return -1;
		}
	}
	
	var rtnObject = null;
	var oldSeq = this.seq;
	var newSeq = 0;
	
	// 줄추가후 시퀀스를 바꿔 데이터를 넣기 위해서 원래 시퀀스에서 잠시 이동한다.
	rtnObject = this.dataSet.insertData();
	
	if( rtnObject.result == false ){
		alert(rtnObject.errorMsg);
		return -1;
	}
	else{
		this.dataSet.setState(rtnObject.recordIndex, "updateGu", "X");
	}
	
	this.maxSeq++;
	this.count++;
	this.seq = this.maxSeq;		// this.setSeq(this.maxSeq)를 사용하면 큰일남 seq-row대응전에 seqChange이벤트가 일어나  없는 objectseq를 참조
	
	if( this.seqKeyFieldId == "" )
		this.dataSet.setState(this.seq - this.startSeq, "tempSeqKey", this.seq);
	else {
		var fireEvent_Mem = this.FireEvent;
		this.FireEvent = withEvents;		
		this.setValue(this.seqKeyFieldId, this.seq);
		this.FireEvent = fireEvent_Mem;		
	}
	
	// 사용자 코딩 추가영역을 호출한다
	if( this.FireEvent && this.hasAddRecordEvent && withEvents ){
		this.fncAddRecordEvent();
	}
	
	// 화면은 아직 원래의 객체를 가리키고 있으므로 원래의 시퀀스로 환원한다
	newSeq = this.seq;
	this.seq = oldSeq;
	
	// 메모리 해제
	rtnObject = null;
	
	return newSeq;
};

/**
 * @description 
 *     인수로 받은 순번에 해당하는 레코드를 찾아 삭제한다 <br/>
 *     데이터가 삭제되는 것은 아니며 삭제 플레그가 붙고, 다른 함수의 처리과정에서 제외된다. 
 * @param  {Number}	seq			변경항 데이터의 순번 <br/>
 * @return {Void} 
 * @example 
 * 
 * 	object.deleteSeq(1);		// 1번 레코드를 삭제한다
 * 
 */
DataObject.prototype.deleteSeq = function(seq){
	// functionname : [DataObject.deleteSeq]
	
	// 사용자 코딩 추가영역을 호출한다
	if( this.hasCanDeleteRecordEvent ){
		if( !this.fncCanDeleteRecordEvent() )
			return -1;
	}
	
	var data = null;
	var key = null;
	var propertyInfo = null;
	var oldValue = null;
	var rowNum = 0;
	
	// 집계필드 갱신
	rowNum = seq - this.startSeq;
	data = this.dataSet.data[rowNum];
	
	for(key in data){
		//필드의 기본정보 __XXXX__를 레코드에 추가하지 않음
		if( /^__.*__$/.test(key) )
			continue;
		
		propertyInfo = this.propertyInfosById[key];
		oldValue = data[key];
		
		if( propertyInfo.isNumericType ){
			this._updateMaxMin(key, oldValue, 0, seq);
//			propertyInfo.sum -= oldValue;
			this._updateSum(key, oldValue, 0);
		}
	}
	
	this.dataSet.deleteData(rowNum);
	
	// 사용자 코딩 추가영역을 호출한다
	if( this.FireEvent && this.hasDeleteRecordEvent ){
		this.fncDeleteRecordEvent();
	}
	
	this.count--;
	
	return;
};

/**
 * @description 
 *     두개의 순번을 받아 서로 위치를 바꾼다.  
 * 
 * @param  {Number}	seqFrom		맞바꿀 앞레코드의 순번 <br/>
 * @param  {Number}	seqTo		맞바꿀 뒷레코드의 순번 <br/>
 * 
 * @return {Void} 
 * @example 
 * 
 * 	object.changeSeq(1,2);		// 1번 레코드와 2번 레코드의 위치를 바꾼다 
 * 
 */
DataObject.prototype.changeSeq = function(seqFrom, seqTo){
	// functionname : [DataObject.changeSeq]
	
	var rowNumFrom = 0;
	var rowNumTo = 0;
	var recordFrom = null;
	var recordTo = null;
	var errorInfo = null;
	
	rowNumFrom = seqFrom - this.startSeq;
	rowNumTo = seqTo - this.startSeq;
	recordFrom = JSON.parse(JSON.stringify(this.dataSet.data[rowNumFrom]));
	recordTo = JSON.parse(JSON.stringify(this.dataSet.data[rowNumTo]));
	
	this.dataSet.data[rowNumFrom] = null;
	this.dataSet.data[rowNumFrom] = recordTo;
	this.dataSet.data[rowNumTo] = null;
	this.dataSet.data[rowNumTo] = recordFrom;
	
	// 메모리 해제
	recordTo = null; recordFrom = null;
	
//	// 사용자 코딩 추가영역을 호출한다
//	if( this.FireEvent && this.hasDataResettedEvent ){
//		errorInfo = {code:0, message:""};
//		
//		this.fncDataResettedEvent(OBJECT_DATA_RESET_BY_CHANGESEQ, errorInfo);
//		
//		if( errorInfo.code != 0 ){
//			alert(errorInfo.message);
//		}
//		
//		// 메모리 해제
//		errorInfo = null;
//	}
};

/**
 * @description 
 *     인수로 받은 순번에 해당하는 레코드를 찾아 직전 레코드 값으로 데이터를 채운다  <br/>
 * @param  {Number}	seq			변경항 데이터의 순번 <br/>
 * @return {Void} 
 * @example 
 * 
 * 	copyUpperData(2);		// 2번 레코드의 각 프로퍼티의 값을 1번 레코드의 각 프로퍼티의 값으로 채운다.
 */
DataObject.prototype.copyUpperData = function(seq){
	// functionname : [DataObject.copyUpperData]
	
	if( seq <= this.startSeq )
		return;
	
	var rowNum = 0;
	var recordFrom = null;
	var recordTo = null;
	var key = null;
	var propertyInfo = null;
	var newValue = null;
	var oldValue = null;
	var data = null;
	
	//레코드에 필드 추가
	rowNum = seq - this.startSeq;
	recordFrom = this.dataSet.data[rowNum - 1];
	recordTo = this.dataSet.data[rowNum];
	
	for(key in recordTo){
		//필드의 기본정보 __XXXX__를 레코드에 추가하지 않음
		if(/^__.*__$/.test(key))
			continue;
		
		propertyInfo = this.propertyInfosById[key];
		oldValue = recordTo[key];
		newValue = recordFrom[key];
		data = {};
		data[key] = newValue;
		
//		this.setValue(key, newValue);
		this.dataSet.updateData(rowNum, data);
		
		if( propertyInfo.isNumericType ){
			this._updateMaxMin(key, oldValue, newValue, seq);
//			propertyInfo.sum += newValue - oldValue;
			this._updateSum(key, oldValue, newValue);
		}
		
		//메모리 해제
		data = null; newValue = null; oldValue = null; propertyInfo = null; key = null;
	}
	
	// 메모리 해제
	oldValue = null; newValue = null; propertyInfo = null; key = null;
	dataAfter = null; dataBefore = null;
	
	return;
};

/**
 * @description 
 *     순번정보를 지정하여 전체적으로 순번을 조정하게 한다.
 *     순번을 ":"로 연결한 문자열이나 순번의 배열을 받아 순서를 조정한다.
 * @param  {String|Number[]}	순번을 ":"로 연결한 문자열이나 순번의 배열<br/>
 * @return {Void} 
 * @example 
 * 
 * 	object.adjustOrder("1:4:5:3:2");		// 현재 1,2,3,4,5번 레코드를 다시 1,4,5,3,2 순서로 위치를 조정한다 
 * 	object.adjustOrder([1, 4, 5, 3, 2]);	// 현재 1,2,3,4,5번 레코드를 다시 1,4,5,3,2 순서로 위치를 조정한다 
 * 
 */
DataObject.prototype.adjustOrder = function(orderInfo){
	// functionname : [DataObject.adjustOrder]
	
	var orders = null;
	var result = true;
	
	orders = Array.isArray(orderInfo) ? orderInfo : orderInfo.split(":");
	
	if( orders.length != this.dataSet.getCount() )
		return false;
	
	var errorInfo = null;
	var datasOrigin = null;
	var datasTemp = null;
	var rowNum = 0;
	var seq = 0;
	var i = 0;
	
	datasOrigin = JSON.parse(JSON.stringify(this.dataSet.data));
	datasTemp = [];
	
	for(i = 0; i < orders.length; i++){
		seq = parseInt(1* orders[i]);
		rowNum = seq - this.startSeq;
		
		datasTemp.push(JSON.parse(JSON.stringify(datasOrigin[rowNum])));
	}
	
//	for(i = datas.length-1; i >= 0; i--)
//		datas.pop();
	
	this.dataSet.clearData();
	this.dataSet.data = null;
	this.dataSet.data = JSON.parse(JSON.stringify(datasTemp));
	
//	// 사용자 코딩 추가영역을 호출한다
//	if( this.FireEvent && this.hasDataResettedEvent ){
//		errorInfo = {code:0, message:""};
//		
//		this.fncDataResettedEvent("adjustOrder", errorInfo);
//		
//		if( errorInfo.code != 0 ){
//			alert(errorInfo.message);
//			result = false;
//			
//			//이전 상태로 복구
//			this.dataSet.data.clearData();
//			this.dataSet.data = null;
//			this.dataSet.data = JSON.parse(JSON.stringify(datasOrigin));
//		}
//		
//		// 메모리 해제
//		errorInfo = null;
//	}
	
	// 이전 데이터 복사본 비움
	for(i = datasOrigin.length-1; i >= 0; i--)
		datasOrigin.pop();
	// 정렬 데이터  비움
	for(i = datasTemp.length-1; i >= 0; i--)
		datasTemp.pop();
	//메모리 해제
	datasOrigin = null; datasTemp = null; orders = null;
	
	return result;
};

/**
 * @description 
 *     현재 레코드에서 지정된 속성의 값을 리턴한다. 
 * 
 * @param  {String}						fieldId		찾을 값의 FieldID<br/>
 * 
 * @return {String|Number|Boolean|Object} 			현재 

 * @example 
 * 	var value = object.getValue("studentid");
 */
DataObject.prototype.getValue = function(fieldId){
	// functionname : [DataObject.getValue]
	
	var value = this.dataSet.data[this.seq - this.startSeq][fieldId];
	
	//만약 데이터가 null 또는 undefined 라면 빈 문자열로 수정함
	if( value == null || typeof value == "undefined" )
		value = "";
	
	return value;
};


/**
 * @description 
 *     현재 레코드에서 지정된 속성의 값을 변경한다. 
 * 
 * @param  {String}							fieldId		변경할 칼럼의 FieldID<br/>
 * @param  {String|Number|Boolean|Object}	value		변경할 칼럼값<br/>
 * 
 * @return {Boolean} 						현재 

 * @example 
 * 	var success = object.setValue("studentid", "20010101");
 */
DataObject.prototype.setValue = function(fieldId, value){
	// functionname : [DataObject.setValue]
	
//	if (this.notSetValue) return true;
	
	if( this.seq < this.startSeq )
		return false;
	
	var result = false;
	var rowNum = 0;
	var record = null;
	var oldValue = null;
	var updateGu = null;
	var json = null;
	var propertyInfo = null;
	var oldMax = null;
	var oldMin = null;
	
//	if( this.propertyInfosById[fieldId].isNumericType ){
//		value = 1 * value;
//	}
	
	rowNum = this.seq - this.startSeq;
	record = this.dataSet.data[rowNum];
	oldValue = record[fieldId];	// 기존 데이터 메모
//	updateGu = record.__STATE__.updateGu;
	updateGu = this.dataSet.getState(rowNum, "updateGu");
	propertyInfo = this.propertyInfosById[fieldId];
	
	if( oldValue === value && !this.dataUp )		// this.dataUp == true 이면 같은 값이더라도 업데이트 한다
		return true;
	
	// 사용자 코딩 추가영역을 호출한다
	if( this.hasCanChangeEvent ){
		result = this.fncCanChangeEvent(fieldId, value);
		
		if( typeof result == "boolean" && !result )
			return false;
	}
	
	// 새로운 값으로 변경
	json = {};
	json[fieldId] = value;
	
	this.dataSet.updateData(rowNum, json);
	
	if( objectManager.dataloaded || !this.dniMode){
		var isChanged = false;
		var key = null, propInfo = null;
		var propValue = null, propOldValue = null;
		
		for(key in record){
			propInfo = this.propertyInfosById[key];
			
			// 키가 아니고 어느 콘트롤엔가 연결된 속성만 대상으로 Dirty를 파악한다.
			if( typeof propInfo != "undefined" && (!(propInfo.isKey || propInfo.isSeqKey) && propInfo.needDirtyCheck) ){
				propValue = record[key];
				propOldValue = record.__STATE__.oldData[key];
				
				if( propInfo.listLinked ){ // 콤보나 리스트는 디폴트 값이 "-1"이다
					if( propValue == propOldValue ){ /*통과*/ }
					else if( propValue == "-1" && propOldValue == "" ){ /*통과*/ }
					else if( propValue == "-1" && propOldValue == "" ){ /*통과*/ }
					else { isChanged = true; }
				}
				else{
					isChanged = isChanged || (propValue != propOldValue);
				}
				
				//메모리 해제
				propOldValue = null; propValue = null;
			}
			
			//메모리 해제
			propInfo = null; key = null;
			
			if( isChanged ) break;
		}
		
		if( updateGu == "X" ){
			if( isChanged ) updateGu = "I";
		}
		else if( updateGu == "N" ){
			if( isChanged ) updateGu = "U";
		}
		else if( updateGu == "I" ){
			if( !isChanged ) updateGu = "X";
		}
		else if( updateGu == "U" ){
			if( !isChanged ) updateGu = "N";
		}
		
		this.dataSet.setState(rowNum, "updateGu", updateGu);
	}
	// 가저오기로 채워 젔으면 I-> X 로 돌아가서는 안된다
	else{
		if( updateGu == "X" ){
			this.dataSet.setState(rowNum, "updateGu", updateGu);
			
			// DirtyCheck이 필요 없으면 X인 경우 그대로 둔다
			// DirtyCheck이 필요하면 조건에 따라 I로 강제 조정 한다 
			if( propertyInfo.needDirtyCheck ){
				// 객체키인 경우 데이터 시트에 링크되어 있으면 시트가 변하면 변경으로 간주되어야 하므로 I로 강제조정한다
				if( propertyInfo.isKey ){
					if( propertyInfo.sheetLinked ) this.dataSet.setState(rowNum, "updateGu", "I");
				}
				else if( propertyInfo.isSeqKey ){
					// 통과한다
				}
				else{
					this.dataSet.setState(rowNum, "updateGu", "I"); // 키가 아니면서 DirtyCheck이므로 I로 강제조정한다 
				}
			}
		}
	}
	
	// this.dataUp 가 true 일때 updateGu값 바꾼후 같은값이면 바로 리턴시키키 위해
	if( oldValue === value )
		return true;
	
	// 집계필드 갱신
	if( propertyInfo.isNumericType ){
		value = 1 * value;
		oldValue = 1 * oldValue;
		
		oldMax = propertyInfo.max;
		oldMin = propertyInfo.min;
		
		this._updateMaxMin(fieldId, oldValue, value, this.seq);
//		propertyInfo.sum += value - oldValue;
		this._updateSum(fieldId, oldValue, value);
	}
	
	var funcFieldInfos = [];
	var funcFieldInfo = null;
	var key = null; var value = null; var oldValue = null;
	var i = 0;
	
	//프로퍼티 구분이 function이면서 데이터타입이 number인 프로퍼티의 데이터, 집계데이터를 갱신한다
	for(i = 0, propertyInfo = null; i < this.propertyCount; i++, propertyInfo = null){
		propertyInfo = this.propertyInfos[i];
		
		if( propertyInfo.isNumericType && propertyInfo.propertyGu == "function" ){
			key = propertyInfo.fieldId;
			value = propertyInfo.formula();
			oldValue = record[key];
			
			if( value != oldValue ){
				funcFieldInfo = {};
				funcFieldInfo["fieldId"] = key;
				funcFieldInfo["value"] = value;
				funcFieldInfo["oldValue"] = oldValue;
				funcFieldInfo["oldMin"] = propertyInfo.min;
				funcFieldInfo["oldMax"] = propertyInfo.max;
				funcFieldInfos.push(funcFieldInfo);
				
				record[key] = value;
				this.dataSet.setOldValue(rowNum, key, oldValue);
				
				value = 1 * value;
				propertyInfo.min = (propertyInfo.min > value ? value : propertyInfo.min);
				propertyInfo.max = (propertyInfo.max < value ? value : propertyInfo.max);
//				propertyInfo.sum += value - oldValue;
				this._updateSum(key, oldValue, value);
				
				funcFieldInfo = null;
			}
			
			oldValue = null; value = null; key = null;
		}
	}
	
	// 사용자 코딩 추가영역을 호출한다
	if( fillState == FILLSTATE_NONE ){
		if( this.FireEvent && this.hasChangeEvent ){
			result = this.fncChangeEvent(fieldId, value, oldValue);
			
			//리턴 결과가 false인 경우 이전 상태로 복구함
			if( typeof result == "boolean" && !result ){
				//이전 데이터로 복구
				json[fieldId] = oldValue;
				this.dataSet.updateData(rowNum, json);
				
				//집계필드 복구
				if( propertyInfo.isNumericType ){
					propertyInfo.max = oldMax;
					propertyInfo.min = oldMin;
//					propertyInfo.sum = propertyInfo.sum - value + oldValue;
					this._updateSum(fieldId, value, oldValue);
				}
				
				//프로퍼티 구분이 function이면서 데이터타입이 number인 프로퍼티 집계 데이터 복구
				for(i = 0, funcFieldInfo = null, propertyInfo = null; i < funcFieldInfos.length; i++, funcFieldInfo = null, propertyInfo = null){
					funcFieldInfo = funcFieldInfos[i];
					propertyInfo = this.propertyInfosById[funcFieldInfo.fieldId]
					
					record[funcFieldInfo.fieldId] = funcFieldInfo.oldValue;
					
					propertyInfo.min = funcFieldInfo.oldMin;
					propertyInfo.max = funcFieldInfo.oldMax;
//					propertyInfo.sum = propertyInfo.sum - funcFieldInfo.value + funcFieldInfo.oldValue;
					this._updateSum(funcFieldInfo.fieldId, value, oldValue);
				}
				
				//메모리 해제
				funcFieldInfos.clear(); funcFieldInfos = null;
				propertyInfo = null; json = null; oldValue = null; record = null;
				
				return false;
			}
		}
	}
	
	//메모리 해제
	funcFieldInfos.clear(); funcFieldInfos = null;
	propertyInfo = null; json = null; updateGu = null; oldValue = null; record = null;
	
	return true;
};

/**
 * @description 
 *     현재 레코드에서 지정된 속성의 값을 변경한다. <br/>
 *     전체 줄 속의 프로퍼티 값을 동시에 갱신하는 경우 사용
 * 
 * @param  {String}							fieldId		변경할 칼럼의 FieldID<br/>
 * @param  {String|Number|Boolean|Object}	value		변경할 칼럼값<br/>
 * 
 * @return {Boolean} 						오류 발생여부 

 * @example 
 * 	var success = object.setValueAll ("studentAge", 1);
 */
DataObject.prototype.setValueAll = function(fieldId, value){
	// functionname : [DataObject.setValueAll]
	
	var rowNum = 0;
	var seq = 0;
	var record = null;
	var recordCount = 0;
	var oldValue = null;
	var updateGu = null;
	var json = null;
	var propertyInfo = null;
	
	// 먼저 전체 데이터를 바꾼다
	for(rowNum = 0, recordCount = this.dataSet.data.length; rowNum < recordCount; rowNum++, record = null){
		seq = rowNum + this.startSeq;
		
		// 아래에서 setValue를 처리하기 위해서, 여기서 고치면 이벤트가 일어날 수 없다.
		if( rowNum == this.seq - this.startSeq )
			continue;
		
		// 삭제된데이터
		if( ["D", "E"].indexOf(this.getUpdateGu(seq)) >= 0 )
			continue;
		
		record = this.dataSet.data[rowNum];
		oldValue = record[fieldId]; //기존 데이터 메모
		updateGu = this.dataSet.getState(rowNum, "updateGu");
		
		// this.dataUp == true 이면 같은 값이더라도 업데이트 한다
		if( oldValue === value && !this.dataUp )
			continue;
		
		// 새로운 값으로 변경
		json = {};
		json[fieldId] = value;
		
		this.dataSet.updateData(rowNum, json);
		
		// updateGu 갱신
		if( objectManager.dataloaded || !this.dniMode){
			var isChanged = false;
			var key = null, propInfo = null;
			var propValue = null, propOldValue = null;
			
			for(key in record){
				propInfo = this.propertyInfosById[key];
				
				// 키가 아니고 어느 콘트롤엔가 연결된 속성만 대상으로 Dirty를 파악한다.
				if( typeof propInfo != "undefined" && (!(propInfo.isKey || propInfo.isSeqKey) && propInfo.needDirtyCheck) ){
					propValue = record[key];
					propOldValue = record.__STATE__.oldData[key];
					
					if( propInfo.listLinked ){ // 콤보나 리스트는 디폴트 값이 "-1"이다
						if( propValue == propOldValue ){ /*통과*/ }
						else if( propValue == "-1" && propOldValue == "" ){ /*통과*/ }
						else if( propValue == "-1" && propOldValue == "" ){ /*통과*/ }
						else { isChanged = true; }
					}
					else{
						isChanged = isChanged || (propValue != propOldValue);
					}
					
					//메모리 해제
					propOldValue = null; propValue = null;
				}
				
				//메모리 해제
				propInfo = null; key = null;
				
				if( isChanged ) break;
			}
			
			if( updateGu == "X" ){
				if( isChanged ) updateGu = "I";
			}
			else if( updateGu == "N" ){
				if( isChanged ) updateGu = "U";
			}
			else if( updateGu == "I" ){
				if( !isChanged ) updateGu = "X";
			}
			else if( updateGu == "U" ){
				if( !isChanged ) updateGu = "N";
			}
			
			this.dataSet.setState(rowNum, "updateGu", updateGu);
			
			// 메모리 해제
			propOldValue = null; propValue = null;
		}
		// 가저오기로 채워 젔으면 I-> X 로 돌아가서는 안된다
		else{
			if( updateGu == "X" ){
				this.dataSet.setState(rowNum, "updateGu", updateGu);
				
				propertyInfo = this.propertyInfosById[fieldId];
				
				// DirtyCheck이 필요 없으면 X인 경우 그대로 둔다
				// DirtyCheck이 필요하면 조건에 따라 I로 강제 조정 한다 
				if( propertyInfo.needDirtyCheck ){
					// 객체키인 경우 데이터 시트에 링크되어 있으면 시트가 변하면 변경으로 간주되어야 하므로 I로 강제조정한다
					if( propertyInfo.isKey ){
						if( propertyInfo.sheetLinked ) this.dataSet.setState(rowNum, "updateGu", "I");
					}
					else if( propertyInfo.isSeqKey ){
						// 통과한다
					}
					else{
						this.dataSet.setState(rowNum, "updateGu", "I"); //키가 아니면서 DirtyCheck이므로 I로 강제조정한다 
					}
				}
				
				propertyInfo = null;
			}
		}

		// this.dataUp 가 true 일때 updateGu값 바꾼후 같은값이면 바로 리턴시키키 위해(oldValue와 newValue가 같은 값이므로 집계 데이터를 갱신하지 않음)
		if( oldValue === value )
			continue;
		
		// 집계필드 갱신
		propertyInfo = this.propertyInfosById[fieldId];
		if( propertyInfo.isNumericType ){
			value = 1 * value;
			oldValue = 1 * oldValue;
			
			this._updateMaxMin(fieldId, oldValue, value, seq);
			this._updateSum(fieldId, oldValue, value);
		}
		
		//
		var key = null;
		for(var i = 0, propertyInfo = null; i < this.propertyCount; i++, propertyInfo = null){
			propertyInfo = this.propertyInfos[i];
			
			if( propertyInfo.propertyGu == "function" ){
				key = propertyInfo.fieldId;
				value = propertyInfo.formula();
				oldValue = record[key];
				
				if( value != oldValue ){
					record[key] = value;
					this.dataSet.setOldValue(rowNum, key, oldValue);
					
					if( propertyInfo.isNumericType ){
						value = 1 * value;
						this._updateMaxMin(key, oldValue, value, seq);
						this._updateSum(key, oldValue, value);
					}
				}
				
				oldValue = null; value = null; key = null;
			}
		}
		
		// 메모리 해제
		oldValue = null; updateGu = null; propertyInfo = null; json = null;
	}
	
	// 현재 Seq에 이벤트를 일으키기위해 setValue호출
	return this.setValue(fieldId, value);
};

/**
 * @deprecated since version 5.0, DataObject.sum()로 대체
 * @description 
 *     인수로 받은 property Id 에 해당하는 필드의 값의 평균값을 리턴한다
 * @param  {String}	propertyId
 * @return {Number} 
 * @example 
 * 
 * 	var totalScore = object.getSumOf("score");		
 */
DataObject.prototype.getSumOf = function(propertyId){
	// functionname : [DataObject.getSumOf]
	
	return this._getSumFunc("SUM", propertyId);
};

/**
 * @description 
 *     인수로 받은 property Id 에 해당하는 필드의 값의 평균값을 리턴한다
 * @param  {String}	propertyId
 * @return {Number} 
 * @example 
 * 
 * 	var totalScore = object.sum("score");		
 */
DataObject.prototype.sum = function(propertyId){
	// functionname : [DataObject.sum]
	
	return this._getSumFunc("SUM", propertyId);
};

/**
 * @deprecated since version 5.0, DataObject.average()로 대체
 * @description 
 *     인수로 받은 property Id 에 해당하는 필드의 값의 합계를 리턴한다
 * @param  {String}	propertyId
 * @return {Number} 
 * @example 
 * 
 * 	var averageScore = object.getAvgOf("score");		
 */
DataObject.prototype.getAvgOf = function(propertyId){
	// functionname : [DataObject.getAvgOf]
	
	return this._getSumFunc("AVG", propertyId);
};

/**
 * @description 
 *     인수로 받은 property Id 에 해당하는 필드의 값의 합계를 리턴한다
 * @param  {String}	propertyId
 * @return {Number} 
 * @example 
 * 
 * 	var averageScore = object.average("score");		
 */
DataObject.prototype.average = function(propertyId){
	// functionname : [DataObject.average]
	
	return this._getSumFunc("AVG", propertyId);
};

/**
 * @deprecated since version 5.0, DataObject.max()로 대체
 * @description 
 *     인수로 받은 property Id 에 해당하는 필드의 값의 최대값를 리턴한다
 * @param  {String}	propertyId
 * @return {Number} 
 * @example 
 * 
 * 	var maxScore = object.getMaxOf("score");		
 */
DataObject.prototype.getMaxOf = function(propertyId){
	// functionname : [DataObject.getMaxOf]
	
	return this._getSumFunc("MAX",propertyId);
};

/**
 * @description 
 *     인수로 받은 property Id 에 해당하는 필드의 값의 최대값를 리턴한다
 * @param  {String}	propertyId
 * @return {Number} 
 * @example 
 * 
 * 	var maxScore = object.max("score");		
 */
DataObject.prototype.max = function(propertyId){
	// functionname : [DataObject.max]
	
	return this._getSumFunc("MAX",propertyId);
};

/**
 * @deprecated since version 5.0, DataObject.min()로 대체
 * @description 
 *     인수로 받은 property Id 에 해당하는 필드의 값의 최소값를 리턴한다
 * @param  {String}	propertyId
 * @return {Number} 
 * @example 
 * 
 * 	var minScore = object.getMinOf("score");		
 */
DataObject.prototype.getMinOf = function(propertyId){
	// functionname : [DataObject.getMinOf]
	
	return this._getSumFunc("MIN",propertyId);
};

/**
 * @description 
 *     인수로 받은 property Id 에 해당하는 필드의 값의 최소값를 리턴한다
 * @param  {String}	propertyId
 * @return {Number} 
 * @example 
 * 
 * 	var minScore = object.min("score");		
 */
DataObject.prototype.min = function(propertyId){
	// functionname : [DataObject.min]
	
	return this._getSumFunc("MIN",propertyId);
};

/**
 * @deprecated since version 5.0, DataObject.upper()로 대체
 * @description 
 *     인수로 받은 property Id 에 해당하는 필드의 값의 직전값를 리턴한다
 * @param  {String}	propertyId
 * @return {Number} 
 * @example 
 * 
 * 	var upperScore = object.getFormerValueOf("score");		
 */
DataObject.prototype.getFormerValueOf = function(propertyId){
	// functionname : [DataObject.getFormerValueOf]
	
	return this._getSumFunc("FORMER",propertyId);
};

/**
 * @description 
 *     인수로 받은 property Id 에 해당하는 필드의 값의 직전값를 리턴한다
 * @param  {String}	propertyId
 * @return {Number} 
 * @example 
 * 
 * 	var upperScore = object.upper("score");		
 */
DataObject.prototype.upper = function(propertyId){
	// functionname : [DataObject.upper]
	
	return this._getSumFunc("FORMER",propertyId);
};

/**
 * @deprecated since version 5.0, DataObject.next()로 대체
 * @description 
 *     인수로 받은 property Id 에 해당하는 필드의 값의 직후값를 리턴한다
 * @param  {String}	propertyId
 * @return {Number} 
 * @example 
 * 
 * 	var nextScore = object.getNextValueOf("score");		
 */
DataObject.prototype.getNextValueOf = function(propertyId){
	// functionname : [DataObject.getNextValueOf]
	
	return this._getSumFunc("NEXT",propertyId);
};

/**
 * @description 
 *     인수로 받은 property Id 에 해당하는 필드의 값의 직후값를 리턴한다
 * @param  {String}	propertyId
 * @return {Number} 
 * @example 
 * 
 * 	var nextScore = object.next("score");		
 */
DataObject.prototype.next = function(propertyId){
	// functionname : [DataObject.next]
	
	return this._getSumFunc("NEXT",propertyId);
};

/**
 * @description 
 *     레코드의 일부가 수정되어 업로드가 필요한 상태인지 리턴하는 함수이다.   
 *     
 * @return {Boolean} 		
 */
DataObject.prototype.needWrite = function(seq){
	// functionname : [DataObject.needWrite]
	
	var datas = this.dataSet.data;
	var needed = false;
	var rowNum = 0;
	
	for(rowNum = 0; rowNum < datas.length && !needed; rowNum++) {
		needed = (["I", "U", "D"].indexOf(this.getUpdateGu(rowNum + this.startSeq)) >= 0);
	}
	
	//메모리 해제
	data = null;
	
	return needed;
};
/**
 * @description	미결
 * @param 		{number}	seq
 * @return		{String}
 * @example		미결
 */
DataObject.prototype.recordNeedWrite = function(seq) {
	// functionname : [DataObject.recordNeedWrite]
	
	return (["I", "U", "D"].indexOf(this.dataSet.getState(seq - this.startSeq, "updateGu")) >= 0);
};

/**
 * @description 
 *     객체의 키필드가 채워졌는 지 파악하여 데이터를 Load할 수 있는지 여부를 리턴한다  
 *     
 * @return {Boolean} 		- 데이터 LOAD가 가능한 상태이면 true를 리턴한다.
 * @example 
 * 
 * 	if (object.canLoadData()){
 *    // 데이터 로드 동작
 *  }		
 */
DataObject.prototype.canLoadData = function(){
	// functionname : [DataObject.canLoadData]
	
	var data = this.dataSet.data[0];
	var propertyInfo = null;
	var needCancel = false;
	var propertyNum = 0;
	
	for(propertyNum = 0; propertyNum < this.propertyCount && !needCancel; propertyNum++, propertyInfo = null){
		propertyInfo = this.propertyInfos[propertyNum];
		
		if( !propertyInfo.isKeyField )
			continue;
		
		needCancel = (("" + data[propertyInfo.fieldId]) == "");
	}
	
	// 메모리 해제
	propertyInfo = null;
	data = null;

	return !needCancel;
};
//내부함수  JSDOC 안함 
DataObject.prototype._updateMaxMin = function(propertyId, oldValue, newValue, seq){
	// functionname : [DataObject._updateMaxMin]
	
	var rowNum = 0;
	var rowNum1 = 0;
	var seq1 = 0;
	var fieldId = null;
	var propertyInfo = null;
	var datas = null;
	var value = null;
	var max = null;
	
	// 숫자타입이 아니면 통과
	if( isNaN(newValue) )
		return;
	
	oldValue = parseFloat(1 * oldValue);
	newValue = parseFloat(1 * newValue);

	if (oldValue === newValue)
		return;

	rowNum = seq - this.startSeq;
	fieldId = propertyId;
	propertyInfo = this.propertyInfosById[propertyId];
	datas = this.dataSet.data;
	
	// MAX 갱신
	if( oldValue < newValue ){
		propertyInfo.max = (propertyInfo.max < newValue ? newValue : propertyInfo.max);
	}
	// 값이 줄어 들었고 기존값이 Max값이었다면 나머지 데이터를 판단해야 한다
	else if (oldValue > newValue && oldValue == propertyInfo.max){
		max = parseFloat(1 * datas[0][fieldId]);
		
		for(rowNum1 = 0; rowNum1 < this.dataSet.data.length; rowNum1++){
			if(rowNum1 == rowNum)
				continue;
			
			seq1 = rowNum1 + this.startSeq;
			
			if( ["D", "X", "E"].indexOf(this.getUpdateGu(seq1)) >= 0 )	// 삭제된데이터
				continue;

			value = parseFloat(1 * datas[rowNum1][fieldId]);
			max = value > max ? value : max;
		}
		
		propertyInfo.max = max;
	}

	// MIN 갱신
	if( oldValue > newValue ){
		propertyInfo.min = (propertyInfo.min > newValue ? newValue : propertyInfo.min);
	}
	else if( oldValue < newValue ){
		if( oldValue > propertyInfo.min ){	// 통과
		}
		// 값이 늘어 났고고 기존값이 Min값이었다면 나머지 데이터를 판단해야 한다
		else if( oldValue < newValue && oldValue == propertyInfo.max){
			min = parseFloat(1 * datas[0][fieldId]);

			for(rowNum1 = 0; rowNum1 < this.dataSet.data.length; rowNum1++){
				if( rowNum1 == rowNum )
					continue;
				
				seq1 = rowNum1 + this.startSeq;
				
				if( ["D", "X", "E"].indexOf(this.getUpdateGu(seq1)) >= 0 )	// 삭제된데이터
					continue;

				value = parseFloat(1 * datas[rowNum1][fieldId]);
				min = value < min ? value : min;
			}
			
			propertyInfo.min = min;
		}
	}
	
	//메모리 해제
	propertyInfo = null; fieldId = null; datas = null;

	return;
};

DataObject.prototype._updateSum = function(propertyId, oldValue, newValue){
	// functionname : [DataObject._updateSum]
	
	var propertyInfo = this.propertyInfosById[propertyId];
	var sumStr = "" + propertyInfo.sum;
	var newStr = "" + newValue;
	var oldStr = "" + oldValue;
	var sumPointCnt = (sumStr.indexOf(".") < 0) ? 0 : sumStr.length - (sumStr.indexOf(".") + 1);
	var newPointCnt = (newStr.indexOf(".") < 0) ? 0 : newStr.length - (newStr.indexOf(".") + 1);
	var oldPointCnt = (oldStr.indexOf(".") < 0) ? 0 : oldStr.length - (oldStr.indexOf(".") + 1);
	var decimalPoint = (sumPointCnt > newPointCnt ? sumPointCnt : (newPointCnt > oldPointCnt ? newPointCnt : oldPointCnt));
	var decimalValue = Math.pow(10, decimalPoint);
	
	propertyInfo.sum = 1 * ((((propertyInfo.sum * decimalValue) - (oldValue * decimalValue) + (newValue * decimalValue)) / decimalValue).toFixed(10));
	
	//메모리 해제
	oldStr = null; newStr = null; sumStr = null; propertyInfo = null;
	
	return;
};

//내부함수  JSDOC 안함 
DataObject.prototype._getSumFunc = function(functionName, pPropertyId){
	// functionname : [DataObject.getSumFunc]
	
	var propertyInfo = this.propertyInfosById[pPropertyId];
	var wResult = 0.0;
	var wReturn = "";
	
	if( !propertyInfo.isNumericType && functionName != "FORMER" && functionName != "NEXT" ){
		propertyInfo = null;
		return wReturn;
	}
	
	if( functionName == "SUM" ){
		wResult = propertyInfo.sum;
	}
	else if( functionName == "AVG" ){
		wResult = propertyInfo.sum / this.count;
	}
	else if( functionName == "MAX" ){
		wResult = propertyInfo.max;
	}
	else if( functionName == "MIN" ){
		wResult = propertyInfo.min;
	}
	else if( functionName == "CNT" ){
		wResult = this.count;
	}
	else if( functionName == "FORMER" ){
		wReturn = (this.seq == this.startSeq ? "" : this.dataSet.data[seq - 1][pPropertyId]);
	}
	else if( functionName == "NEXT" ){
		wReturn = (this.seq == this.maxSeq ? "" : this.dataSet.data[seq + 1][pPropertyId]);
	}

	if( functionName != "FORMER" && functionName != "NEXT" ){
		wReturn = "" + wResult;
	}
	
	//메모리 해제
	propertyInfo = null;
	
	return wReturn;
};

//내부함수  JSDOC 안함 
DataObject.prototype.getLoadJSON = function(){
	// functionname : [DataObject.getLoadJSON]
	
	var wReturn = null;
	var list = [{}];
	var record = list[0];
	
	var propertyInfo = null;
	var propertyCount = this.propertyCount;
	var c = 0;
	
	for(c = 0; c < propertyCount; c++){
		propertyInfo = this.propertyInfos[c];
		
		if( ["field", "file"].indexOf(propertyInfo.propertyGu) < 0 )
			continue;
		
//		if (objectManager.sql) {
//			for (key in objectManager.sql[this.tableID]) {
//				record[key] = objectManager.sql[this.tableID][key];
//			}
//		}
//		else
		if( propertyInfo.isKey && !propertyInfo.isSeqKey )
			record[propertyInfo.fieldId] = this._getDBWritableKeyValue(this.startSeq, propertyInfo);
		
		propertyInfo = null;
	}
	
	wReturn = JSON.stringify(list);	//메모리와 서버에서 데이터 변형 문제로 문자열로 변환
	
	//메모리 해제
	record = null;
	list.clear(); list = null;
	
	return wReturn;
};

//내부함수  JSDOC 안함 
DataObject.prototype.getWriteJSON = function(){
	// functionname : [DataObject.getWriteJSON]
	
	var wReturn = null;
	var list = [];
	var record = null;
	
	var oldSeq = this.seq; //임시로 현재 시쿼스 번호 백업
	var datas = this.dataSet.data;
	var dataLength = datas.length;
	var updateGu = null;
	var seq = 0, idx = 0, r = 0; c = 0;
	var propertyInfo = null;
	
	for(r = 0, idx = 0; r < dataLength; r++){
		this.seq = r + this.startSeq;
		updateGu = this.getUpdateGu(this.seq);
		
		//삭제된데이터 제외
		if( ["N", "X", "E"].indexOf(updateGu) >= 0 )
			continue;
		
		if( this.hasNeedSkipFunction && this.fncNeedSkip() )
			continue;
		
		//레코드 복사
		record = JSON.parse(JSON.stringify(datas[r]));
		//레코드 데이터 변형
		record = this._getDBWritableRecord(record);
		//레코드 업데이트 구분 추가
		record["updategu"] = updateGu;
		
		//리스트에 추가
		list[idx++] = record;
		
		//메모리 해제
		record = null;
		updateGu = null;
	}
	
	this.seq = oldSeq; //백업한 시쿼스 번호로 복구
	wReturn = JSON.stringify(list);	//메모리와 서버에서 데이터 변형 문제로 문자열로 변환
	
	//메모리 해제
	list.clear(); list = null;
	datas = null;
	
	return wReturn;
};

//내부함수  JSDOC 안함 
DataObject.prototype.getDeleteJSON = function(){
	// functionname : [DataObject.getDeleteJSON]
	
	var wReturn = null;
	var list = [];
	var record = null;
	
	var datas = this.dataSet.data;
	var dataLength = datas.length;
	var propertyInfo = null;
	var propertyCount = this.propertyCount;
	var updateGu = null;
	var seq = 0, r = 0, c = 0;
	
	for(r = 0; r < dataLength; r++){
		seq = r + this.startSeq;
		updateGu = this.getUpdateGu(seq);
		record = {};
		
		for(c = 0; c < propertyCount; c++, propertyInfo = null){
			propertyInfo = this.propertyInfos[c];
			
			if( ["field", "file"].indexOf(propertyInfo.propertyGu) < 0 )
				continue;
			
			if( propertyInfo.isKey && !propertyInfo.isSeqKey )
				record[propertyInfo.fieldId] = this._getDBWritableKeyValue(seq, propertyInfo);
		}
		
		list[r] = record;
		
		record = null;
		updateGu = null;
	}
	
	wReturn = JSON.stringify(list);	//메모리와 서버에서 데이터 변형 문제로 문자열로 변환
	
	//메모리 해제
	list.clear(); list = null;
	datas = null;
	
	return wReturn;
};

DataObject.prototype.getJsonData = function(){
	// functionname : [DataObject.getJsonData]
	
	var wReturn = null;
	var list = []; var record = null;
	var value = null; var updateGu = null;
	var oldSeq = this.seq; //임시로 현재 시쿼스 번호 백업
	var dataItems = this.dataSet.data;
	var dataItem = null; var dataOldItem = null;
	var dataCount = dataItems.length;
	var propertyCount = this.propertyCount;
	var propertyInfo = null; var propertyId = null;
	var i = 0, r = 0; c = 0;
	
	for(r = 0, i = 0; r < dataCount; r++, updateGu = null){
		this.seq = r + this.startSeq;
		updateGu = this.getUpdateGu(this.seq);
		
		//삭제된데이터 제외
		if( ["X", "E"].indexOf(updateGu) >= 0 )
			continue;
		
		//스킵조건
		if( this.hasNeedSkipFunction && this.fncNeedSkip() )
			continue;
		
		dataItem = dataItems[r];
		dataOldItem = dataItem.__STATE__.oldData;
		record = {"IUDFlag" : updateGu}; //레코드 업데이트 구분 추가
		
		//레코드에 데이터 추가
		for(c = 0; c < propertyCount; c++, propertyInfo = null, propertyId = null, value = null){
			propertyInfo = this.propertyInfos[c];
			propertyId = propertyInfo.fieldId;
			value = dataItem[propertyId];
			
			//null, NaN, undefined 인 경우, 빈문자열로 대체
			if( value == "NaN" || value == null || typeof value == "undefined" )
				value = "";
			
			//디폴트값을 대입한 후에도 값이 ""이면 필요한 조치
			if( ("" + value).trim() == "" ){
				if( propertyInfo.isNumericType )
					value = 0;
				else if( !propertyInfo.permitNull )
					value = " ";
			}
			
			//파일인 경우 처리
			if( propertyInfo.propertyGu == "file" && value.length > 0 )
				if( !(value.length > 11 && /^\[.{8}_\}/.test(value)) )
					value = (value.trim().length > 0 ? jUploadPrefix : "") + value;
			
			//데이터 추가
			record[propertyId] = value;
			record[propertyId + "Old"] = dataOldItem[propertyId];
		}
		
		//리스트에 추가
		list[r] = record;
		
		//메모리 해제
		record = null;
		dataOldItem = null;
		dataItem = null;
	}
	
	//
	if( this.seqKeyFieldId.length > 0 ){
		var key = null; var control = null; var sheet = null;
		var rowNum = 0; var rowCount = 0; var seq = 0; var newSeq = 0;
		
		for(key in controls){
			control = controls[key];
			//
			if( typeof control.linkedObjects != "undefined" ){
				for(i = control.linkedObjects.length - 1; i >= 0; i--){
					if( control.linkedObjects[i] === this ){
						sheet = control;
						break;
		            }
		        }
		    }
			//
			if( sheet != null ){
				control = null; key = null;
				break;
		    }
			//
			control = null; key = null;
		}
		
		if( sheet != null ){
			for(i = 0, newSeq = this.startSeq; i < sheet.maxRows; i++, newSeq++, record = null){
				rowNum = i + sheet.startRowColNum;
				seq = sheet.getRowAttribute(rowNum, "objectSeq");
				
				record = list[seq - this.startSeq];
				record[this.seqKeyFieldId] = newSeq;
			}
			
			sheet = null;
		}
		
		list.sort(function(a, b){
			return (a[this.seqKeyFieldId] - b[this.seqKeyFieldId]);
		});
		
		for(i = 0, newSeq = this.startSeq, rowCount = list.length; i < rowCount; i++, record = null, updateGu = null){
			record = list[i];
			//
			if( typeof record == "undefined" ) continue;
			
			//업데이트 구분
			updateGu = record["IUDFlag"];
			//삭제된데이터
			if( ["D", "X", "E"].indexOf(updateGu) >= 0 ) continue;
			
			if( parseInt(1 * record[this.seqKeyFieldId + "Old"]) != newSeq ){
				if( updateGu == "X" )
					record["IUDFlag"] = "I";
				else if( updateGu == "N" )
					record["IUDFlag"] = "U";
			}
			
			record[this.seqKeyFieldId] = newSeq++;
		}
	}
	
	//
	for(i = list.length; i >= 0; i--){
		//
		if( typeof list[i] == "undefined" )
			list.splice(i, 1);
	}
	
	this.seq = oldSeq;				//백업한 시쿼스 번호로 복구
	wReturn = JSON.stringify(list);	//메모리와 서버에서 데이터 변형 문제로 문자열로 변환
	
	//메모리 해제
	list.clear(); list = null;
	dataItems = null;
	
	return wReturn;
};

//내부함수  JSDOC 안함
DataObject.prototype.getSelectCondition = function(){
	return (this.selectCondition != null) ? this.selectCondition : {};
};

//내부함수  JSDOC 안함 
/**
 * @description	미결
 * @param 		{String}	arrJSonObject
 * @return		{void}
 * @example		미결
 */
DataObject.prototype.loadData = function(arrJsonObject){
	// functionname : [DataObject.loadData]
	
	this.clear();
	
	var datas = this.dataSet.data;
	var data = null;
	var jsonObject = null;
	var propertyInfo = null;
	var fieldId = null;
	var jsonKey = null;
	var value = null;
	var recordSize = 0;
	var rowNum = 0;
	
	//
	for(rowNum = 0, recordSize = arrJsonObject.length; rowNum < recordSize; rowNum++){
		this.dataSet.insertData();
		this.dataSet.setState(rowNum, "updateGu", "N"); // 수정전상태는 "N"이다
		
		jsonObject = arrJsonObject[rowNum];
		data = datas[rowNum];
		
		for(fieldId in this.propertyInfosById){
			propertyInfo = this.propertyInfosById[fieldId];
			
			for(jsonKey in jsonObject){
				if( ("" + fieldId).toLocaleLowerCase() == ("" + jsonKey).toLocaleLowerCase() ){
					value = jsonObject[jsonKey];
					
					data[fieldId] = value;
					this.dataSet.setOldValue(rowNum, fieldId, value);
					
					// 집계함수 계산
					if( propertyInfo.isNumericType ){
						value = 1 * value;
						propertyInfo.min = (propertyInfo.min > value ? value : propertyInfo.min);
						propertyInfo.max = (propertyInfo.max < value ? value : propertyInfo.max);
//						propertyInfo.sum += value;
						this._updateSum(fieldId, 0, value);
					}
					
					value = null; jsonKey = null;
					
					break;
				}
				
				jsonKey = null;
			}
			
			propertyInfo = null; fieldId = null;
		}
		
		data = null; jsonObject = null;
	}
	
	var propNum = 0;
	var newSeq = 0;
	var oldSeq = this.seq;
	var dataCount = datas.length;
	
	//
	for(propNum = 0; propNum < this.propertyCount; propNum++, propertyInfo = null, fieldId = null){
		propertyInfo = this.propertyInfos[propNum];
		fieldId = propertyInfo.fieldId;
		
		if( !propertyInfo.isNumericType || propertyInfo.propertyGu != "function" )
			continue;
		
		for(rowNum = 0, newSeq = this.startSeq; rowNum < dataCount; rowNum++, newSeq++){
			data = datas[rowNum];
			
			this.seq = newSeq;
			value = propertyInfo.formula();
			
			data[fieldId] = value;
			this.dataSet.setOldValue(rowNum, fieldId, value);
			
			// 집계함수 계산
//			if( propertyInfo.isNumericType ){
				value = 1 * value;
				propertyInfo.min = (propertyInfo.min > value ? value : propertyInfo.min);
				propertyInfo.max = (propertyInfo.max < value ? value : propertyInfo.max);
//				propertyInfo.sum += value;
				this._updateSum(fieldId, 0, value);
//			}
			
			value = null; data = null;
		}
	}
	
	this.seq = oldSeq;
	this.maxSeq = arrJsonObject.length - 1 + this.startSeq;
	this.count = dataCount;
	
	//객체로드한 경우 dni모드가 IUD로 설정되어야 함(IUD : false / D&I : true)
	this.dniMode = false;
	
	arrJsonObject.clear();
	arrJsonObject = null;
	datas = null;
	
//	// 사용자 코딩 추가영역을 호출한다
//	if( this.FireEvent && this.hasDataResettedEvent ){
//		errorInfo = {code:0, message:""};
//		actionType = OBJECT_DATA_RESET_BY_LOADDATA;
//		
//		this.fncDataResettedEvent(actionType, errorInfo);
//		if( errorInfo.code != 0 ){
//			// !!! 오류 메시지 
//			alert(errorInfo.message);
//		}
//		
//		actionType = null;
//		errorInfo = null;
//	}
	
	return;
};

//내부함수  JSDOC 안함 
/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
DataObject.prototype.getLoadData = function(){
	// functionname : [DataObject.getLoadData]
	
	var uploadString = "Object:" + this.tableID + ";";
	var propertyInfo = null;
	var propertyNum = 0;
	
	for(propertyNum = 0; propertyNum < this.propertyCount; propertyNum++, propertyInfo = null){
		propertyInfo = this.propertyInfos[propertyNum];
		
		if( ["field", "file"].indexOf(propertyInfo.propertyGu) < 0 )
			continue;
		
		if( propertyInfo.isKey && !propertyInfo.isSeqKey )
			uploadString += this._getDBWritableValue(this.startSeq, propertyInfo) + ",";
	}
	
	uploadString += ";";
	
	// 메모리 해제
	propertyInfo = null;
	
	return uploadString;
};
/**
 * @description	미결
 * @param 		{String}	pPropertyId
 * @return		{boolean}
 * @example		미결
 */
DataObject.prototype.getWriteData = function(){
	// functionname : [DataObject.getWriteData]
	
	var oldSeq = this.seq;
	var uploadString = "Object:" + this.tableID + ";";
	
	var datas = this.dataSet.data;
	var dataLength = datas.length;
	var updateGu = null;
	var rowNum = 0;
	var seq = 0;
	var propertyInfo = null;
	var propertyCount = this.propertyCount;
	var propertyNum = 0;
	var tempStr = null;
	var fieldId = null;
	var oldValue = null;
	
	for(rowNum = 0; rowNum < dataLength; rowNum++, updateGu = null){
		this.seq = rowNum + this.startSeq;
		updateGu = this.getUpdateGu(this.seq);
		
		// 삭제된데이터
		if( ["N", "X", "E"].indexOf(updateGu) >= 0 )
			continue;
		
	    if( this.hasNeedSkipFunction && this.fncNeedSkip() )
	    	continue;
	    
		for(propertyNum = 0; propertyNum < propertyCount; propertyNum++){
			propertyInfo = this.propertyInfos[propertyNum];
			
			if( (propertyInfo.propertyGu == "field") ){
				uploadString += this._getDBWritableValue(this.seq, propertyInfo);
				uploadString += ",";
		    }
			else if( (propertyInfo.propertyGu == "file") ){
				tempStr = this._getDBWritableValue(this.seq, propertyInfo);
				
				if( tempStr.length == 0 ){
					// 생략
				}
				else if( tempStr.length > 11 && tempStr.substring(0,1) == "[" && tempStr.substring(9,11) == "_]" ){
					uploadString += tempStr;
				}
//				// 대상에서 모바일 이미지 처리시만 사용  
//				else if( tempStr.length > 11 && tempStr.substring(0,1) == "[" && tempStr.substring(10,11) == "]" ){
//		    		uploadString += tempStr;
//		    	}
				else{
					uploadString += (tempStr.trim().length > 0 ? jUploadPrefix : "") + tempStr;
				}
				
				uploadString += ",";
				tempStr = null;
			}
			
			propertyInfo = null;
		}
		
		uploadString += updateGu;
		
		for(propertyNum = 0; propertyNum < this.propertyCount; propertyNum++, propertyInfo = null){
			propertyInfo = this.propertyInfos[propertyNum];
			
			if( !propertyInfo.isKey || !propertyInfo.isSeqKey )
				continue;
			
			uploadString += ",";
			fieldId = propertyInfo.fieldId;
			oldValue = this.dataSet.getOldValue(rowNum, fieldId);
			
			if( oldValue == null || typeof oldValue == "undefined" )
				oldValue = "";
			
			if( propertyInfo.isNumericType )
				uploadString += ("" + oldValue == "") ? "0" : oldValue;
			else
				uploadString += ("" + oldValue == "") ? "null" : escapeParseString(oldValue);
			
			oldValue = null;
			fieldId = null;
			
			break;
		}
		
		uploadString += ";";
	}
	
	this.seq = oldSeq; // 화면의 시퀀그로 돌려 놓는다.
	
	//메모리 해제
	datas = null;
	
	return uploadString;
};

//내부함수  JSDOC 안함 
/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
DataObject.prototype.getDeleteData = function(){
	// functionname : [DataObject.getDeleteData]
	
	var uploadString = "Object:" + this.tableID + ";";
	
	var datas = this.dataSet.data;
	var dataLength = datas.length;
	var propertyInfo = null;
	var updateGu = null;
	var propertyNum = 0;
	var rowNum = 0;
	var seq = 0;
	
	for(rowNum = 0; rowNum < dataLength; rowNum++, updateGu = null){
		seq = rowNum + this.startSeq;
		
		for(propertyNum = 0; propertyNum < this.propertyCount; propertyNum++, propertyInfo = null){
			propertyInfo = this.propertyInfos[propertyNum];
			
			if( ["field", "file"].indexOf(propertyInfo.propertyGu) < 0 )
				continue;
			
			if( propertyInfo.isKey && !propertyInfo.isSeqKey )
				uploadString += this._getDBWritableValue(seq, propertyInfo) + ",";
		}
		uploadString += ";";
	}
	
	//메모리 해제
	datas = null;
	
	return uploadString;
};

//내부함수  JSDOC 안함 
DataObject.prototype._getDBWritableRecord = function(record){
	// functionname : [DataObject._getDBWritableRecord]
	
	var propertyInfo = null;
	var propertyCount = this.propertyCount;
	var updateGu = null;
	var value = null;
	var c = 0;
	
	for(c = 0; c < propertyCount; c++){
		propertyInfo = this.propertyInfos[c];
		value = record[propertyInfo.fieldId];
		
		if( value == "NaN" || value == null || typeof value == "undefined" )
			value = "";
		
		//디폴트값 설정
		if( value == "" )
			value = (typeof propertyInfo.defaultValue == "function") ? propertyInfo.defaultValue() : propertyInfo.defaultValue;
		else if( ("" + value) == "-1" && propertyInfo.linkedToListControl ) //콤보,리스트박스, 콤보셀이면서 값이 "-1"인것
			value = (typeof propertyInfo.defaultValue == "function") ? propertyInfo.defaultValue() : propertyInfo.defaultValue;
		
		//디폴트값을 대입한 후에도 값이 ""이면 필요한 조치
		if( ("" + value).trim() == "" ){
			if( propertyInfo.isNumericType )
				value = 0;
			else if( !propertyInfo.permitNull )
				value = " ";
		}
	    
//		//파싱문자의 Escaping
//		if( !propertyInfo.isNumericType )
//			value = escapeParseString(value);
		
		//파일인 경우 처리
		if( propertyInfo.propertyGu == "file" && value.length > 0 )
			if( !(value.length > 11 && /^\[.{8}_\}/.test(value)) )
				value = (value.trim().length > 0 ? jUploadPrefix : "") + value;
		
		record[propertyInfo.fieldId] = value;
		
		//이전 값 설정
//		if( !propertyInfo.isKey || !propertyInfo.isSeqKey )
		if( !propertyInfo.isKey && !propertyInfo.isSeqKey )
			continue;
		
		updateGu = record.__STATE__.updateGu;
//		value = record.__STATE__.oldData[propertyInfo.fieldId];
		value = (updateGu == "I") ? record[propertyInfo.fieldId] : record.__STATE__.oldData[propertyInfo.fieldId];
		value = (typeof value == "undefined") ? "" : value;
		
		if( propertyInfo.isNumericType )
			value = (isNaN(value) ? null : (("" + value === "") ? 0 : value));
		
		record[propertyInfo.fieldId + "Old"] = value;
		
		//메모리 해제
		value = null;
		propertyInfo = null;
	}
	
	return record;
};

//내부함수  JSDOC 안함 
DataObject.prototype._getDBWritableKeyValue = function(seq, propertyInfo){
	// functionname : [DataObject._getDBWritableValue]
	
	var rowNum = seq - this.startSeq;
	var value = this.dataSet.data[rowNum][propertyInfo.fieldId];
	
	if( value == "NaN" )
		value = "";
	
	if( value == "" )
		value = (typeof propertyInfo.defaultValue == "function") ? propertyInfo.defaultValue() : propertyInfo.defaultValue;
	else if( ("" + value) == "-1" && propertyInfo.linkedToListControl ) //콤보,리스트박스, 콤보셀이면서 값이 "-1"인것
		value = (typeof propertyInfo.defaultValue == "function") ? propertyInfo.defaultValue() : propertyInfo.defaultValue;
	
	// 디폴트값을 대입한 후에도 값이 ""이면 필요한 조치
	if( ("" + value).trim() == "" ){
		if( propertyInfo.isNumericType )
			value = "0";
		else if( !propertyInfo.permitNull )
			value = " ";
	}
	
//	// 파싱문자의 Escaping
//	if( !propertyInfo.isNumericType )
//		value = escapeParseString(value);
	
	return value;
};

//내부함수  JSDOC 안함 
DataObject.prototype._getDBWritableValue = function(seq, propertyInfo){
	// functionname : [DataObject._getDBWritableValue]
	
	var rowNum = seq - this.startSeq;
	var value = this.dataSet.data[rowNum][propertyInfo.fieldId];
	
	if( value == "NaN" )
		value = "";
	
	if( value == "" )
		value = (typeof propertyInfo.defaultValue == "function") ? propertyInfo.defaultValue() : propertyInfo.defaultValue;
	else if( ("" + value) == "-1" && propertyInfo.linkedToListControl ) //콤보,리스트박스, 콤보셀이면서 값이 "-1"인것
		value = (typeof propertyInfo.defaultValue == "function") ? propertyInfo.defaultValue() : propertyInfo.defaultValue;
	
	// 디폴트값을 대입한 후에도 값이 ""이면 필요한 조치
	if( ("" + value).trim() == "" ){
		if( propertyInfo.isNumericType )
			value = "0";
		else if( !propertyInfo.permitNull )
			value = " ";
	}
	
	// 파싱문자의 Escaping
	if( !propertyInfo.isNumericType )
		value = escapeParseString(value);
	
	return value;
};

//내부함수  JSDOC 안함 
//이발빠진 시퀀스 번호를 정비한다.
//oldSequence Value는 건들지않고 value만 갱신한다
/**
 * @description	미결
 * @return		{void}
 * @example		미결
 */
DataObject.prototype.arrangeSeq = function(){
	// functionname : [DataObject.arrangeSeq]
	
	var datas = this.dataSet.data;
	var updateGu = null;
	var rowNum = 0;
	var seq = 0;
	var oldSeq = 0;
	
	for(rowNum = 0; rowNum < this.dataSet.data.length; rowNum++) {
		updateGu = this.getUpdateGu(rowNum + this.startSeq);
//		seq++;

		if( ["D", "X", "E"].indexOf(updateGu) >= 0 ){	// 삭제된데이터
			continue;
		}
		
		if( this.seqKeyFieldId == "" ){
			this.dataSet.setState(rowNum, "tempSeqKey", ++seq);
		}
		else{
			seq++;
			oldSeq = this.dataSet.getOldValue(rowNum, this.seqKeyFieldId);
			
			if( parseInt(1 * oldSeq) != seq ){
				if( updateGu == "X" )
					this.dataSet.setState(rowNum, "updateGu", "I")
				else if( updateGu == "N" )
					this.dataSet.setState(rowNum, "updateGu", "U")
			}
			
			datas[rowNum][this.seqKeyFieldId] = seq;
		}
	}
	
	// 메모리 해제
	datas = null;
	
	return;
};

//내부함수  JSDOC 안함 
/**
 * @description	미결
 * @return		{void}
 * @example		미결
 */
DataObject.prototype.sortBySeq = function(){
	// functionname : [DataObject.sortBySeq]
	
	var errorInfo = null;
	var datas = this.dataSet.data;
	
	if( this.seqKeyFieldId == "" ){
		datas.sort(function(a, b){
			return (a.__STATE__.tempSeqKey - b.__STATE__.tempSeqKey);
		});
	}
	else{
		datas.sort(function(a, b){
			return (a[this.seqKeyFieldId] - b[this.seqKeyFieldId]);
		});
	}
	
//	// 사용자 코딩 추가영역을 호출한다
//	if( this.FireEvent && this.hasDataResettedEvent ){
//		errorInfo = {code:0, message:""};
//		
//		this.fncDataResettedEvent(OBJECT_DATA_RESET_BY_SORT, errorInfo);
//		
//		if(errorInfo.code != 0)
//			alert(errorInfo.message);
//	}
	
	return;
};

/**
 * @description 
 *     데이터 객체의 속성정보 개체
 * 
 * @constructor
 * 
 * @param {string} 	 id 	 	- 속성의 고유 아이디 (영문)
 * @param {string} 	 fieldId 	- 속성의 테이블 필드아이디
 * @param {string} 	 name 		- 속성명 (사용자 고유 언어)
 * 
 * @return {PropertyInfo} 		- 생성된 DataObject 개체
 * 
 */
function PropertyInfo(id, fieldId, name){
    this.id = id;
    this.fieldId = fieldId;
    this.name = name;
    this.propertyGu = ""; // field, service, function, file
    this.dataTypeName = "";
    this.isNumericType = false;
    this.isKey = false;
    this.isSeqKey = false;
    this.length = 0;
    this.formula = "";
    this.defaultValue = "";  //eval이 적용되는 산식
    this.permitNull = false;
    this.seqClear = false;
    this.linkedToListControl = false; // 콤보나 리스트, 콤보셀에 링크되었는지 여부
    this.needDirtyCheck = true;       // 사용자의 "화면 동작"과 관련 없는 속성값은 통과 : 변경을 체크하지 않는다
    this.sheetLinked= false;          // 데이터시트에 연결된 프로퍼티인지 구분 객체값 변경체크시 사용
    this.listLinked= false;           // 콤보와  리스트에 연결된 프로퍼티인지 구분  객체값변경체크시 사용
    this.isFillKey = false;
    this.sum = 0.0;                     // 연산에 필요한 값
    this.max = 0.0;
    this.min = 0.0;
};

/*
 *  주요 변경 내용으로 영향도 평가사항 
 *  
 *  0번 seq부터 데이터가 채워진다 .
 *  Easysheet 아닌 기존시트 코드와의 호환성 유지 하여야 한다 
 *  record는 data[rowNum]을 가리킨다 
 *  object는 seq를 사용하고, dataSet은 rowNum을 사용한다.
 *  
 *  3. seq는 0부터 시작하며 기존호환이 필요할 때는 "object.startSeq = 1;" 로 설정한다.
 *     업로드 되는 seq필드는 무조건 1부터 시작된다. seq속성과 seq필드는 다른 개념이다
 *  4. dniMode 추적할 것 
 * */
/**
 * @class TextBox 클래스
 * @constructor TextBox
 * 
 * @param controlId
 *            {String} 해당 컨트롤의 ID를 지정합니다.
 * @param controlName
 *            {String} 해당 컨트롤의 Name을 지정합니다.
 * @param tagObject
 *            {Object} 해당 컨트롤의 태그 객체를 지정합니다.
 * 
 * @return 객체 생성 성공하면 객체의 errorMsg 필드가 null 입니다.<br>
 *         만약 에러가 발생한다면 errorMsg 필드에 에러메시지를 반환합니다.
 * 
 * @example var wControl = controls["textbox_3"] = new TextBox("textbox_3",
 *          "TextBox_3", document.getElementsByName("textbox_3")[0]);
 *          if(wControl.errorMsg != null){ //객체 생성 실패하였습니다. 에러처리 코드를 입력해주세요. }
 *  // 후속코드 생략...
 */
function TextBox(controlId, controlName, tagObject){
	if( tagObject == undefined || tagObject == null )
		return;
	
	// 상속선언부
	this.base = ControlBase;						//부모클래스 지정
	this.base(controlId, controlName, tagObject);	//부모클래스 생성자호출
	
	// 속성 선언부
	/**
	 * @description 텍스트 박스 입력값입니다.<br>
	 *              기본값 : 없음<br>
	 *              <br>
	 */
	this.value = "";
	/**
	 * @description 한글입력모드 입니다.<br>
	 *              기본값 : auto<br>
	 *              <br>
	 *              <table width="500"> <caption>imemode Variable Value</caption>
	 *              <thead>
	 *              <tr>
	 *              <th align="left">Value</th>
	 *              <th align="left">Description</th>
	 *              </tr>
	 *              </thead> <tbody>
	 *              <tr>
	 *              <td> auto </td>
	 *              <td> 한글입력 자동모드 입니다. </td>
	 *              </tr>
	 *              <tr>
	 *              <td> active </td>
	 *              <td> 한글입력 활성화 모드 입니다. </td>
	 *              </tr>
	 *              <tr>
	 *              <td> inactive </td>
	 *              <td> 한글입력 비활성화 모드 입니다. </td>
	 *              </tr>
	 *              </table><br>
	 */
	this.imemode = "auto";
	/**
	 * @description 표기형식 문자열입니다.<br>
	 *              기본값 : 없음<br>
	 *              <br>
	 */
//	this.dispFormat = (tagObject.getAttribute("displayformat") != undefined && tagObject.getAttribute("displayformat") != null ? tagObject.getAttribute("displayformat") : "");
	this.dispFormat = "";
	/**
	 * @description 표기형식 반올림 플래그 값이다.<br>
	 *              기본값 : 반올림<br>
	 *              <br>
	 */
	this.dispRound = 0; //DISPAY_FORMAT_ROUND(0) / DISPAY_FORMAT_CEIL(1) / DISPAY_FORMAT_FLOOR(2)
	/**
	 * @description 여러행 입력허용 플래그 값이다.<br>
	 *              기본값 : auto<br>
	 *              <br>
	 *              <table width="500"> <caption>multiLine Variable Value</caption>
	 *              <thead>
	 *              <tr>
	 *              <th align="left">Value</th>
	 *              <th align="left">Description</th>
	 *              </tr>
	 *              </thead> <tbody>
	 *              <tr>
	 *              <td> true </td>
	 *              <td> 여러행 입력을 허용합니다. </td>
	 *              </tr>
	 *              <tr>
	 *              <td> false </td>
	 *              <td> 여러행 입력을 허용하지 않습니다.<br>
	 *              단일행으로만 입력이 가능합니다. </td>
	 *              </tr>
	 *              </table><br>
	 */
	this.multiLine = false;
	/**
	 * @description 컨트롤에 대한 주석입니다.<br>
	 *              기본값 : 없음<br>
	 *              <br>
	 */
	this.tag = "";
	/**
	 * @description 사용자가 컨트롤에 입력한 값이 확정되었을 때, 컨트롤에 입력된 값을 Key로 하여 데이터를 조회합니다.<br>
	 *              기본값 : false<br>
	 *              <br>
	 *              <table width="500"> <caption>isKeyControl Variable Value</caption>
	 *              <thead>
	 *              <tr>
	 *              <th align="left">Value</th>
	 *              <th align="left">Description</th>
	 *              </tr>
	 *              </thead> <tbody>
	 *              <tr>
	 *              <td> true </td>
	 *              <td> 컨트롤 값에 의해 자료를 조회합니다. </td>
	 *              </tr>
	 *              <tr>
	 *              <td> false </td>
	 *              <td> 컨트롤 값에 의해 자료를 조회하지 않습니다. </td>
	 *              </tr>
	 *              </table><br>
	 */
	this.isKeyControl  = false;
	/**
	 * @description 조회한 자료에서 Key 필드와 함께 추가로 조건을 주기위해 사용합니다.<br>
	 *              컨트롤에 화면채우기 설정이 되어있다면 Key필드와 컨트롤의 값에 만족하는 데이터를 화면에 채웁니다.<br>
	 *              기본값 : false<br>
	 *              <br>
	 *              <table width="500"> <caption>isFillControl Variable Value</caption>
	 *              <thead>
	 *              <tr>
	 *              <th align="left">Value</th>
	 *              <th align="left">Description</th>
	 *              </tr>
	 *              </thead> <tbody>
	 *              <tr>
	 *              <td> true </td>
	 *              <td> 컨트롤에 값을 채웁니다. </td>
	 *              </tr>
	 *              <tr>
	 *              <td> false </td>
	 *              <td> 컨트롤에 값을 채우지 않습니다. </td>
	 *              </tr>
	 *              </table><br>
	 */
	this.isFillControl = false;
	/**
	 * @description Clear나 확인버튼을 클릭하여 실행시키고 난 후 후속작업을 위해 컨트롤의 데이터를 비울지 설정합니다.<br>
	 *              기본값 : false<br>
	 *              <br>
	 *              <table width="500"> <caption>isClearControl Variable Value</caption>
	 *              <thead>
	 *              <tr>
	 *              <th align="left">Value</th>
	 *              <th align="left">Description</th>
	 *              </tr>
	 *              </thead> <tbody>
	 *              <tr>
	 *              <td> true </td>
	 *              <td> Clear 기능 실행 후 컨트롤의 값을 비웁니다. </td>
	 *              </tr>
	 *              <tr>
	 *              <td> false </td>
	 *              <td> Clear 기능 실행하더라도 컨트롤의 값을 유지합니다. </td>
	 *              </tr>
	 *              </table><br>
	 */
	this.isClearControl = false;
	/**
	 * @description 입력/조회 시트에서 줄추가/삭제시 컨트롤의 값을 비울지 설정합니다.<br>
	 *              줄 단위로 다른 값이 들어갈 데이터에 적용됩니다.<br>
	 *              기본값 : false<br>
	 *              <br>
	 *              <table width="500"> <caption>isSeqClearControl Variable
	 *              Value</caption> <thead>
	 *              <tr>
	 *              <th align="left">Value</th>
	 *              <th align="left">Description</th>
	 *              </tr>
	 *              </thead> <tbody>
	 *              <tr>
	 *              <td> true </td>
	 *              <td> 줄추가/삭제시 컨트롤의 값을 비웁니다. </td>
	 *              </tr>
	 *              <tr>
	 *              <td> false </td>
	 *              <td> 줄추가/삭제를 하더라도 컨트롤의 값은 유지됩니다. </td>
	 *              </tr>
	 *              </table><br>
	 */
	this.isSeqClearControl = false;
	/**
	 * @description 입력값에 대한 검사 조건입니다.<br>
	 *              기본값 : CHECKTYPE.NONE<br>
	 *              <br>
	 */
	this.checkType = 0;
	/**
	 * @description 미결
	 */
	this._isEnterKeyDown = -1;
	/**
	 * @description	미결
	 */
	this.maxLength = 60;
    this.picctlname = "";
	this.subPath = "";
    this.nozip = false;
    this.serverfilename = "";
    
    
    if( this.tagObject ){
    	var value = null;
    	
    	value = this.tagObject.getAttribute("displayformat");
    	this.dispFormat = (typeof value != "undefined" && value != null) ? value : this.dispFormat;
    	value = null;
    	
    	value = this.tagObject.getAttribute("displayround");
    	this.dispRound = (typeof value != "undefined" && value != null) ? value : this.dispRound;
    	value = null;
    	
    	value = this.tagObject.getAttribute("tag");
    	this.tag = (typeof value != "undefined" && value != null) ? value : "";
    	value = null;
    	
    	value = this.tagObject.getAttribute("checktype");
    	this.checkType = (typeof value != "undefined" && value != null) ? parseInt(value) : this.checkType;
    	value = null;
    	
    	value = this.tagObject.getAttribute("maxlength");
    	this.maxLength = (typeof value != "undefined" && value != null) ? (value * 1) : this.maxLength;
    	value = null;
    	
    	//maxLength 가 0 인 경우, 표시형식이 있다면 표시형식 자리수만큼 설정한다.
    	if( this.maxLength == 0 && this.dispFormat.length > 0 ){
    		this.maxLength = this.dispFormat.length;
    		this.tagObject.setAttribute("maxlength", this.maxLength);
    	}
    	
    	//자동완성 기능 끄기
    	this.tagObject.setAttribute("autocomplete", "off");
    	
    	this.isKeyControl = (tagObject.getAttribute("iskeycontrol") == "true");
    	this.isFillControl = (tagObject.getAttribute("isfillcontrol") == "true");
    	this.isClearControl = (tagObject.getAttribute("isclearcontrol") == "true");
    	this.isSeqClearControl = (tagObject.getAttribute("isseqclearcontrol") == "true");
	}
	
	tagObject.value = "";
	
//	this.tagObject.onkeypress = text_KeyPress;
//	this.tagObject.onkeydown = text_KeyDown;
//	this.tagObject.onkeyup = text_KeyUp;
//	this.tagObject.onfocus = text_Focus;
//	this.tagObject.onblur = text_Blur;
//	this.tagObject.onclick = text_Click;
//	this.tagObject.ondblclick = text_DoubleClick;

	// 이벤트 선언부
	setEventHandler(tagObject, "keypress", text_KeyPress);
	setEventHandler(tagObject, "keydown", text_KeyDown);
	setEventHandler(tagObject, "keyup", text_KeyUp);
	setEventHandler(tagObject, "focus", text_Focus);
	setEventHandler(tagObject, "blur", text_Blur);
	setEventHandler(tagObject, "click", text_Click);
	setEventHandler(tagObject, "dblclick", text_DoubleClick);
	
	// 사용자 이벤트
	this.hasChangeEvent = false;	this.fncChangeEvent = null;
	this.hasBlurEvent = false;		this.fncBlurEvent = null;
	this.hasFocusEvent = false;		this.fncFocusEvent = null;
	this.hasKeyUpEvent = false;		this.fncKeyUpEvent = null;
	this.hasKeyDownEvent = false;	this.fncKeyDownEvent = null;
	
	
	
	if( this.controlId.length > 0 ){
		this.hasChangeEvent = (typeof self[this.controlId + "_onchange"] == "function");
		if( this.hasChangeEvent ){
			this.fncChangeEvent = new Function("return function(){ return " + this.controlId + "_onchange(); }")();
		}
		
		this.hasBlurEvent = (typeof self[this.controlId + "_onblur"] == "function");
		if( this.hasBlurEvent ){
			this.fncBlurEvent = new Function("return function(){ return " + this.controlId + "_onblur(); }")();
		}
		
		this.hasFocusEvent = (typeof self[this.controlId + "_onfocus"] == "function");
		if( this.hasFocusEvent ){
			this.fncFocusEvent = new Function("return function(){ return " + this.controlId + "_onfocus(); }")();
		}

		this.hasKeyUpEvent = (typeof self[this.controlId + "_onkeyup"] == "function");
		if( this.hasKeyUpEvent ){
			this.fncKeyUpEvent = new Function("return function(keyCode, shiftDown, ctrlDown, altDown){ return " + this.controlId + "_onkeyup(keyCode, shiftDown, ctrlDown, altDown); }")();
		}		
		
		this.hasKeyDownEvent = (typeof self[this.controlId + "_onkeydown"] == "function");
		if( this.hasKeyDownEvent ){
			this.fncKeyDownEvent = new Function("return function(keyCode, shiftDown, ctrlDown, altDown){ return " + this.controlId + "_onkeydown(keyCode, shiftDown, ctrlDown, altDown); }")();
		}		
	}
};

TextBox.prototype = new ControlBase();	// 의미없음 코딩 편의기능을 활용하기 위함

/**
 * @description 텍스트박스 컨트롤의 ID를 반환합니다.
 * @param       em {Object} 텍스트박스 컨트롤 객체를 입력합니다.
 * @return      텍스트박스 컨트롤의 ID를 반환합니다.<br>
 *              만약 에러가 발생할 경우, false 반환합니다.
 * @example     var wControl =
 *              searchControl_Text(document.getElementsByName("textbox_3")[0])
 *              if(wControl == null){ //옵션 버튼 컨트롤을 찾는데 실패하였습니다. } if(wControl ==
 *              false){ //텍스트박스으로 포커스를 지정합니다. }
 *  // 후속코드 생략...
 */
function searchControl_Text(em){
	var pEm = em;
	var image = pEm.getAttribute("image");
	var wReturn = null;
	
//	while(pEm.parentNode && !pEm.className.startsWith("TextBox"))
//		pEm = pEm.parentNode;
//	if( pEm.className.startsWith("TextBox") )
//		wReturn = getControlById(pEm.id);
	
	while(pEm.parentNode && image !== "TextBox"){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}
	
	if( pEm.getAttribute("image") === "TextBox" ){
		wReturn = getControlById(pEm.id);
	}
	else{
		pEm = null;
		pEm = em;
		
		while(pEm.parentNode && !pEm.className.startsWith("TextBox"))
			pEm = pEm.parentNode;
		
		if( pEm.className.startsWith("TextBox") )
			wReturn = getControlById(pEm.id);
	}
	
	//메모리 해제
	image = null;
	pEm = null;
	
	return wReturn;
};

/* 포커스 주기*/
/**
 * @description 링크 컨트롤에 포커스를 지정합니다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @return      포커스 지정을 성공한다면 true를 반환합니다.<br>
 *              만약 에러가 발생한다면 false를 반환합니다.
 * @example     var wControl =
 *              searchControl_Text(document.getElementsByName("textbox_3")[0])
 *              if(wControl == null){ //텍스트박스 컨트롤을 찾는데 실패하였습니다. } if(wControl ==
 *              false){ //텍스트박스으로 포커스를 지정합니다. } //텍스트박스로 포커스를 지정합니다. if(
 *              txtbox.focus() == false ){ //focus 함수 동작 실패하였습니다. 에러처리 코드를 입력해주세요.
 *              //focus 함수 실패하거나 에러 발생시 focus 메소드는 false 를 반환합니다. //에러에 관한 메세지는
 *              wControl.errorMsg 필드로 확인할 수 있습니다. }
 */
TextBox.prototype.focus = function(){
	// functionname : [TextBox.focus]
	
	var wReturn = true;
	
	try{
		this.tagObject.focus();
	}
	catch(e){
		wReturn = false;
	}
	
	return wReturn;
};

/* 한글지원*/
/**
 * @description 텍스트박스의 한글입력모드를 설정합니다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @param       imemode {String} auto : 자동모드 / active : 활성화모드 / inactive : 비활성화모드
 * @return      한글모드입력 설정을 성공하면 true를 반환합니다. 만약 에러가 발생할 경우, false 반환합니다.
 * @example     var wControl = controls["textbox_3"]; //한글입력모드를 비활성화 합니다. if(
 *              wControl.setIMEMode("inactive") == false ) //setIMEMode 함수 동작
 *              실패하였습니다. 에러처리 코드를 입력해주세요. //setIMEMode 함수 실패하거나 에러 발생시 focus 메소드는
 *              false 를 반환합니다. //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다. }
 */
TextBox.prototype.setIMEMode = function(imemode){
	// functionname : [TextBox.setIMEMode]
	
	this.imemode = imemode;
	this.tagObject.style.imeMode = imemode; //( "active" : "auto" : "inactive");
};

/**
 * @description 텍스트박스 컨트롤의 체크조건에 따라 한글입력모드를 설정합니다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @param       checkType  {Constant} ControlBase 클래스의 CHECKTYPE 상수를 참조하십시오.
 * @param       callAction
 * @return      검사조건 설정을 성공하면 true를 반환합니다. 만약 에러가 발생할 경우, false 반환합니다.
 * @example     var wControl = controls["textbox_3"]; //한글입력모드를 비활성화 합니다. if(
 *              wControl.setCheckType(this.CHECKTYPE.IMEMODE, ??) == false )
 *              //setCheckType 함수 동작 실패하였습니다. 에러처리 코드를 입력해주세요. //setCheckType 함수
 *              실패하거나 에러 발생시 setCheckType 메소드는 false 를 반환합니다. //에러에 관한 메세지는
 *              wControl.errorMsg 필드로 확인할 수 있습니다. }
 */
TextBox.prototype.setCheckType = function(checkType, callAction){
	// functionname : [TextBox.setCheckType]
	
	this.checkType = checkType;
	
	if( this.checkType == this.CHECKTYPE.IMEMODE )
		this.setIMEMode("active");
	else if( this.checkType == this.CHECKTYPE.NONE )
		this.setIMEMode("auto");
	else
		this.setIMEMode("inactive");
	
	// 체크동작
	if( callAction ){
		/* */
	}
	
	return;
};

/**
 * @description 텍스트박스에 데이터를 표시할 형식 문자열을 설정합니다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @param       dispFormat  {String} 텍스트박스에 데이터를 표시할 형식 문자열을 입력합니다.
 * @param       callAction
 * @return      형식문자열을 설정한다면 true 를 반환합니다. <br>
 *              만약 에러가 발생한다면 false를 반환합니다.
 * @example     var wControl = controls["textbox_3"]; //텍스트박스에 '####-##-##'로 표시할 형식
 *              문자열을 설정합니다. if( wControl.setDispFormat("####-##-##", ??) == false){
 *              //표시문자열 설정을 실패하였습니다. 에러처리 코드를 입력해주세요. //setDispFormat 함수 실패하거나 에러
 *              발생시 setDispFormat 메소드는 false 를 반환합니다. //에러에 관한 메세지는
 *              wControl.errorMsg 필드로 확인할 수 있습니다. }
 */
TextBox.prototype.setDispFormat = function(dispFormat, callAction){
	// functionname : [TextBox.setDispFormat]
	
	this.dispFormat = dispFormat;
	
	if( this.dispFormat.length > 0 )
		this.tagObject.value = mask(this.value, this.dispFormat);
	else
		this.tagObject.value = this.value;
	
	// 체크동작
	if( callAction ){
		/* */
	}
	
	return;
};

/*
TextBox.prototype.setDispRound = function(round){
	// functionname : [TextBox.setDispRound]
	
	this.dispRound = round;
	
	var value = this.value;
	
	if( this.dispFormat.length > 0 ){
		
		this.tagObject.value = mask(value, this.dispFormat);
	}
	else{
		
		this.tagObject.value = value;
	}
	
	return;
};
*/

/**
 * @description 텍스트박스 입력값의 다행입력허용을 설정합니다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @param       multiLine {Boolean} true : 다행입력을 허용합니다. / false : 다행입력을 허용안합니다.
 * @return      다행입력허용 설정을 성공하면 true를 반환합니다.<br>
 *              만약 에러가 발생할 경우, false 반환합니다.
 * @example     var wControl = controls["textbox_3"]; //텍스트박그 컨트롤에 다행입력을 허용합니다. if(
 *              wControl.setMultiLine(true) == false ){ //다행입력 설정을 실패하였습니다. 에러처리 코드를
 *              입력해주세요. //setMultiLine 함수 실패하거나 에러 발생시 setMultiLine 메소드는 false 를
 *              반환합니다. //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다. }
 */
TextBox.prototype.setMultiLine = function(multiLine){
	// functionname : [TextBox.setMultiLine]
	
	this.multiLine = multiLine;
};

/**
 * @description 텍스트박스에 데이터를 입력합니다.<br>
 *              만약 표기문자열을 설정하였다면 표기문자열의 형식에 맞춰 입력됩니다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @param       value {String} 텍스트박스에 입력할 데이터입니다.
 * @return      데이터입력을 성공하면 true를 반환합니다.<br>
 *              만약 에러가 발생할 경우 false 반환합니다.
 * @example     var wControl = controls["textbox_3"]; //텍스트박스에 '위너소프트'가 입력됩니다. if(
 *              wControl.setValue("위너소프트") == false ){ //텍스트박스에 데이터를 입력하는데 실패하였습니다.
 *              에러처리 코드를 입력해주세요. //setValue 함수 실패하거나 에러 발생시 setValue 메소드는 false 를
 *              반환합니다. //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다. }
 */
TextBox.prototype.setValue = function(value){
	// functionname : [TextBox.setValue]
	
	var oldValue = this.value;
	var result = true;
	
	if( typeof value == "undefined" || value == null ) value = "";
	else if( typeof value != "string" ) value = "" + value;
	
	if( typeof oldValue == "undefined" || oldValue == null ) oldValue = "";
	else if( typeof oldValue != "string" ) oldValue = "" + oldValue;
	
	if( (!this.multiLine && oldValue == value)
		|| (this.multiLine && oldValue.replace(/\r/gi, "") == value.replace(/\r/gi, ""))
	){
		if( this.dispFormat.length > 0 ) this.tagObject.value = mask(value, this.dispFormat, this.dispRound);
		return true;
	}
	else{
		this.value = value;
		
		/*
		// 데이터 가저오기
		if( this.isKeyControl ){
			if( this.isFillControl )
				mustFillScreenAfterLoad = true;
			
			objectManager.fillkeyFieldValue = this.value;
			objectManager.loadData();
		}
		// 데이터 채우기
		if( this.value != "" ){
			if( !this.isKeyControl && this.isFillControl )
				objectManager.fillData();
		}
		*/
		
		// 체크조건
		if( !this.checkError() ){
			this.value = oldValue;
			this.tagObject.focus();
			return false;
		}
		
		// dataset 갱신 기능
		if( typeof ControlBase.prototype._UpdateDataset != "undefined" ){
			result = this._UpdateDataset();
			
			if( typeof result == "boolean" && !result ){
				//컨트롤 값 복구
				this.value = oldValue;
				this.tagObject.value = (this.dispFormat.length > 0) ? mask(oldValue, this.dispFormat, this.dispRound) : oldValue;
				this.tagObject.focus();
				return false;
			}
		}
		
		//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
		if( !this.passEvent ){
			// 사용자 코딩 추가영역을 호출한다
			if( this.hasChangeEvent ){
				result = this.fncChangeEvent();
				
				if( (typeof result == "boolean" && !result) || (typeof result == "undefined") ){
					// 컨트롤 값 복구
					this.value = oldValue;
					// dataset 갱신 기능
					if( typeof ControlBase.prototype._UpdateDataset != "undefined" ) this._UpdateDataset();
					//
					this.tagObject.value = (this.dispFormat.length > 0) ? mask(oldValue, this.dispFormat, this.dispRound) : oldValue;
					this.tagObject.focus();
					return false;
				}
			}
		}
		
		// 후속동작
		if( result ) this.tagObject.value = (this.dispFormat.length > 0) ? mask(this.value, this.dispFormat, this.dispRound) : this.value; 
	}
	
	
	return result;
};

/**
 * @description 텍스트박스에 데이터를 입력합니다.<br>
 *              만약 표기문자열을 설정하였더라도 표기문자열 형식에 맞춰 입력되지 않습니다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @param       value {String} 텍스트박스에 입력할 데이터입니다.
 * @return      데이터입력을 성공하면 true를 반환합니다. 만약 에러가 발생할 경우, false 반환합니다.
 * @example     var wControl = controls["textbox_3"]; //텍스트박스에 '위너소프트'가 입력됩니다. if(
 *              wControl.setCaption("위너소프트") == false ){ //텍스트박스에 데이터를 입력하는데
 *              실패하였습니다. 에러처리 코드를 입력해주세요. //setCaption 함수 실패하거나 에러 발생시 setCaption
 *              메소드는 false 를 반환합니다. //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다. }
 */
TextBox.prototype.setCaption = function(caption){
	// functionname : [TextBox.setCaption]
	
	//캡션 파라메터의 값이 없는 경우 빈문자열로 세팅하여 캡션을 지움
	if( typeof caption == "undefined" || caption == null ) caption = "";
	
	//캡션 설정
	this.caption = "" + caption;
	//캡션 텍스트박스 태그 객체에 설정
	this.tagObject.setAttribute("placeholder", this.caption);
};

/**
 * @description	미결
 * @param 		{String} 	 maxLength
 * @return		{undefined}
 * @example		미결
 */
TextBox.prototype.setMaxLength = function(maxLength){
	// functionname : [TextBox.setMaxLength]
	
	this.maxLength = maxLength;
	
	if( this.tagObject ){
		this.tagObject.setAttribute("maxlength", maxLength);
	}
};

/**
 * @name	 	TextBox#text_KeyUp
 * @event
 * @return		{boolean}
 * @description	미결
 */
function text_KeyUp(e)
{
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_Text(em);
	var checkEvent = false;
	var result = true;

	//입력된 키 정보
	var wKeyCode = (e.which) ? e.which : e.keyCode;	// 키 코드
	var wCtrlDown = e.ctrlKey || e.metaKey;			// 컨트롤 // 커맨드(Mac지원)
	var wAltDown = e.altKey;						// 알트
	var wShiftDown = getShiftKeyPressed(e);			// 쉬프트

	//브라우저 버전이 IE8 이하 버전인 경우, 태그의 maxlength 속성을 지원하지 않으므로 스크립트에서 처리(IE 7, 8)
	if( navigator.appName.toLowerCase().indexOf("microsoft") >= 0 && (navigator.appVersion.indexOf("MSIE 7") > 0 || navigator.appVersion.indexOf("MSIE 8") > 0) ){
		if( !control.multiLine && control.maxLength * 1 > 0 && (em.value + "").length > control.maxLength * 1 && (wKeyCode != 9 || wKeyCode != 13) ){
			control = null; em = null;
			return false;
		}
	}

	/*
	if (control.dispFormat.length > 0){
		var wString = em.value.replace(/\-/g,"").replace(/\,/g,"").replace(/:/g,"");
		
		wCalculator.CalcuratedResult("Format(\"" + control.dispFormat + "\", \"" + wString + "\")")
		em.value = maskIn(wString, control.dispFormat)
	}
	*/
	
	var result = true;
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if (control.hasKeyUpEvent){
			result = control.fncKeyUpEvent(wKeyCode, wShiftDown, wCtrlDown, wAltDown);
		}
	}
	
	//메모리 해제
	control = null; em = null;
	
	return result;
};

/**
 * @name 		TextBox#text_KeyPress
 * @event
 * @return		{boolean}
 * @description	미결
 */
function text_KeyPress(e)
{
	e = window.event || e;
	
	var wKeyCode = (e.which ? e.which : e.keyCode);
	
	if( arrKeyCodes.indexOf(wKeyCode) >= 0 )
		return true;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_Text(em);
	
	//브라우저 버전이 IE8 이하 버전인 경우, 태그의 maxlength 속성을 지원하지 않으므로 스크립트에서 처리(IE 7, 8)
	if( navigator.appName.toLowerCase().indexOf("microsoft") >= 0 && (navigator.appVersion.indexOf("MSIE 7") > 0 || navigator.appVersion.indexOf("MSIE 8") > 0) ){
		if( !control.multiLine && control.maxLength * 1 > 0 && (em.value + "").length > control.maxLength * 1 && (wKeyCode != 9 || wKeyCode != 13) ){
			control = null; em = null;
			return false;
		}
	}
	
	if( wKeyCode >= 48 && wKeyCode <= 57 ){	// 숫자코드
		// 모든경우에 OK
	}
	else if( control.checkType == control.CHECKTYPE.YMD
			|| control.checkType == control.CHECKTYPE.YM
			|| control.checkType == control.CHECKTYPE.YYYY
			|| control.checkType == control.CHECKTYPE.RESINUM
			|| control.checkType == control.CHECKTYPE.TAXNUM
			|| control.checkType == control.CHECKTYPE.POSTNUM
			|| control.checkType == control.CHECKTYPE.BARCODE
	){
		control = null; em = null;
		stopEvent(e); return true;
	}
	else if( control.checkType == control.CHECKTYPE.AMOUNT ){
		if( wKeyCode == 45 || wKeyCode == 46 ){	// 45 : "-", 46 : "."
			if( ("" + em.value).length != 0 ){
				control = null; em = null;
				stopEvent(e); return true;
			}
		}
		else{
			control = null; em = null;
			stopEvent(e); return true;
		}
	}
	else if( control.checkType == control.CHECKTYPE.NUMBER ){
		if( wKeyCode == 45 || wKeyCode == 46 ){	// 45 : "-", 46 : "."
			/* */
		}
		else{
			control = null; em = null;
			stopEvent(e); return true;
		}
	}
	
	stopPropagation(e);
	
	//메모리 해제
	control = null; em = null;
	
	return true;
};

/**
 * @name 		TextBox#text_KeyDown
 * @event
 * @return		{boolean}
 * @description	미결
 */
function text_KeyDown(e)
{
	//F5새로고침 방지 추가
	if( e.keyCode == 116 ){
		if( typeof e.preventDefault == "function" )
			e.preventDefault();
		else
			e.returnValue = false; // for IE
		
		return false;
	}
	
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_Text(em);
	var checkEvent = true;
	var result = true;

	//입력된 키 정보
	var wKeyCode = (e.which) ? e.which : e.keyCode;	// 키 코드
	var wCtrlDown = e.ctrlKey || e.metaKey;			// 컨트롤 // 커맨드(Mac지원)
	var wAltDown = e.altKey;						// 알트
	var wShiftDown = getShiftKeyPressed(e);			// 쉬프트

	//브라우저 버전이 IE8 이하 버전인 경우, 태그의 maxlength 속성을 지원하지 않으므로 스크립트에서 처리(IE 7, 8)
	if( navigator.appName.toLowerCase().indexOf("microsoft") >= 0 && (navigator.appVersion.indexOf("MSIE 7") > 0 || navigator.appVersion.indexOf("MSIE 8") > 0) ){
		if( !control.multiLine && control.maxLength * 1 > 0 && (em.value + "").length > control.maxLength * 1 && (wKeyCode != 9 || wKeyCode != 13) ){
			control = null; em = null;
			return false;
		}
	}
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		if (control.hasKeyDownEvent){
			result = control.fncKeyDownEvent(wKeyCode, wShiftDown, wCtrlDown, wAltDown);
			if( typeof result == "boolean" && result == false){
				stopEvent(e);
				control = null; em = null;
				return false;
			}		
		}
	}

	//키 동작
	if( wKeyCode == 9 ){
		if( wShiftDown ){
			stopEvent(e);
			setTimeout("setFocusToFormerControl(\"" + control.controlName + "\")", 0);
			control = null; em = null;
			return true;
		}
		else{
			stopEvent(e);
			setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
			control = null; em = null;
			return true;
		}
	}
	else if( wKeyCode == 13 ){
		if( !control.multiLine ){
			stopEvent(e);
			control._isEnterKeyDown = wKeyCode;
			setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
			control = null; em = null;
			return true;
		}
	}
	
	stopPropagation(e);
	
	// e.returnValue = true;
	
	//메모리 해제
	control = null; em = null;
	
	return true;
};

/**
 * @name 		TextBox#text_Focus
 * @event
 * @return		{boolean}
 * @description	미결
 */
function text_Focus(e)
{
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_Text(em);
	var checkEvent = false;
	var result = true;

	em.value = control.value;

	// 포커스를 받은 문장 전체를 수정할 수 있게 한다.
	// control.value는 포멧이 들어가지 않은 값이다
	if( !control.multiLine ){
		em.focus();
		em.select();
	}
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if (control.hasFocusEvent){
			control.fncFocusEvent();
		}
	}
	
	//메모리 해제
	control = null; em = null;
	
	return result;
};

/**
 * @name 		TextBox#text_Blur
 * @event
 * @return		{boolean}
 * @description	미결
 */
function text_Blur(e)
{
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_Text(em);
	var displayFormat = control.dispFormat;
	var displayRound = control.dispRound;
	
	var checkEvent = false;
	var result = true;
	
	var wString = "";
	var wErrMsg = "";
	
	var oldValue = control.value;	var oVal = "" + oldValue;
	var newValue = em.value;		var nVal = "" + newValue;
	
	if( displayFormat.length > 0 ){
		if( displayFormat.indexOf("-") >= 0 )
			newValue = newValue.replace(/-/g,"");
		if( displayFormat.indexOf(",") >= 0 )
			newValue = newValue.replace(/,/g,"");
		if( displayFormat.indexOf(":") >= 0 )
			newValue = newValue.replace(/:/g,"");
		/*
		if( control.dispFormat.indexOf("/") >= 0 )
			newValue = newValue.replace(/\//g,"");
		*/
		if( displayFormat.indexOf("YY") != -1
			|| displayFormat.indexOf("MM") != -1
			|| displayFormat.indexOf("DD") != -1
			|| displayFormat.indexOf("Hh") != -1
			|| displayFormat.indexOf("Nn") != -1
			|| displayFormat.indexOf("Ss") != -1
			|| displayFormat.indexOf("mm") != -1
			|| displayFormat.indexOf("dd") != -1
			|| displayFormat.indexOf("hh") != -1
			|| displayFormat.indexOf("nn") != -1
			|| displayFormat.indexOf("ss") != -1
			|| displayFormat.indexOf("WK") != -1
			|| displayFormat.indexOf("wk") != -1
		){
			newValue = restoreDateFormatValue(newValue, displayFormat);
		}
	}
	
	control.value = newValue;
	
	if( (!control.multiLine && oVal == nVal)
		|| (control.multiLine && oVal.replace(/\r/gi, "") == nVal.replace(/\r/gi, ""))
	){
		em.value = (displayFormat.length > 0) ? mask(newValue, displayFormat, displayRound) : newValue;
	}
	else{
		if( !control.checkError() ){
			control.value = oldValue;
			em.focus();
			return false;
		}
	
		// dataset 갱신 기능
		if( typeof(ControlBase.prototype._UpdateDataset) != "undefined" ){
			result = control._UpdateDataset();
			
			if( typeof result == "boolean" && !result ){
				//컨트롤 값 복구
				control.value = oldValue;
				em.value = (displayFormat.length > 0) ? mask(oldValue, displayFormat, displayRound) : oldValue;
				em.focus();
				return false;
			}
		}
		
		//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
		if( !control.passEvent ){
			// 사용자 코딩 추가영역을 호출한다
			if( control.hasChangeEvent ){
				result = control.fncChangeEvent();
				//입력된 키 정보 복구
				control._isEnterKeyDown = -1;	
				
				if( (typeof result == "boolean" && !result)
					|| (typeof result == "undefined")
				){
					//컨트롤 값 복구
					control.value = oldValue;
					em.value = (displayFormat.length > 0) ? mask(oldValue, displayFormat, displayRound) : oldValue;
					// dataset 갱신 기능
					if( typeof ControlBase.prototype._UpdateDataset != "undefined" ) control._UpdateDataset();
					//
					em.focus();
					return false;
				}
			}
		}
		
		if( em.value.trim().length > 0 && displayFormat.length > 0 ){
			em.value = mask(newValue, displayFormat, displayRound);
		}
	}
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !control.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if( control.hasBlurEvent ){
			result = control.fncBlurEvent();
			
			if( typeof result == "boolean" && result === false ){
				em.focus();
				return false;
			}
		}
	}
	
	return true;
};

/**
 * @name 		TextBox#text_Click
 * @event
 * @description	미결
 */
function text_Click(e)
{
	e = window.event || e;
//	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
//	var control = searchControl_Text(em);
};

/**
 * @name 		TextBox#text_DoubleClick
 * @event
 * @description	미결
 */
function text_DoubleClick(e)
{
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_Text(em);

	if( control.checkType == control.CHECKTYPE.YMD ){
		try{
			//showCalendar(em);
			popUpCalendar(em, em, 'yyyymmdd', '1');
		} catch(e){}
	}
	else if( control.checkType == control.CHECKTYPE.YM ){
		try{
			//popUpMonthCalendar(em);
			popUpCalendar(em,em,'yyyymm','2');
		} catch(e){}
	}
	else if( control.checkType == control.CHECKTYPE.YYYY ){
		try{
			//popUpYear(em);
			popUpCalendar(em,em,'yyyy','2');
		} catch(e){}
	}
	
	//메모리 해제
	control = null; em = null;
};
/**
 * @class 콤보박스를 만들어주는 클래스
 * @contructor ComboBox Class생성자 함수
 * @param controlId	 	해당 컨트롤의 ID를 지정합니다.
 * @param controlName	해당 컨트롤의 Name을 지정합니다.
 * @param tagObject		해당 컨트롤의 태그 객체를 지정합니다.
 * @return 반환값 없음, 에러발생시 undefined 를반환함
 * @example var wControl = controls["ComboBox_1"]
 * 			if(wContorl.errMsg !=null){
 * 		//객체 생성에 실패하였습니다. 에러처리 코드를 입력해주세요.
 *  }
 *  	//후속코드생략..
 */
function ComboBox(controlId, controlName, tagObject){ 
	// 상속 선언부
	this.base = ControlBase;              			//부모클래스 지정
	this.base(controlId, controlName, tagObject);   //부모클래스 생성자호출
	
	// 상수 선언부
	
	// 속성 선언부
//	this.value = (this.tagObject.options.length > 0) ? this.tagObject.options[0].value : -1;
//	this.text = (this.tagObject.options.length > 0) ? this.tagObject.options[0].text : "";
	this.value = "";
	this.text = "";
	this.index = -1;
	
	this.reservedValue = "";
	this.reservedText = "";
	
	this.haveFixedTopItem = false;
	this.topItemValue = null;
	this.topItemText = null;
	
	this.valueField = "";
	this.textField = "";
	
	
	//2019-04-11 jaeik Safari브라우저 일 경우 select box 높이 재설정
	if (BrowserDetect.browser == "Safari") {
		this.tagObject.style.height = getComputedStyleSize(tagObject).height.replace("px","") - 12 + "px";
		this.tagObject.style.lineHeight = getComputedStyleSize(tagObject).height.replace("px","") - 12 + "px";
	}
	
	this.isKeyControl  = (tagObject.getAttribute("iskeycontrol")  == "true");
	this.isFillControl = (tagObject.getAttribute("isfillcontrol")  == "true");
	this.isClearControl = (tagObject.getAttribute("isclearcontrol")  == "true");
	this.isSeqClearControl = (tagObject.getAttribute("isseqclearcontrol")  == "true");
	this.checkType = parseInt(tagObject.getAttribute("checktype"));
	this.selectWhenOnlyItem= false;// 속성: selectonerecord인경우 처리
	this.stateClear = false;
	
	/**
	 * @description 미결
	 */
	this.editable = false;
	
	if( this.tagObject ){
		this.tagObject.selectedIndex = -1;
		
		//상단항목추가 설정 체크
		var options = this.tagObject.options;
		if( options.length > 0 ){
			var fixedTopItem = this.tagObject.options[0];
			if( (fixedTopItem.getAttribute("fixedtopitem") === "true") ){
				this.haveFixedTopItem = true;
				this.topItemValue = fixedTopItem.value;
				this.topItemText = fixedTopItem.text;
			}
			fixedTopItem = null;
		}
		options = null;
	}
	
	// 자체 이벤트 선언부 
	this.hasChangeEvent = false;	this.fncChangeEvent = null;
	this.hasFocusEvent = false;		this.fncFocusEvent = null;
	this.hasBlurEvent = false;		this.fncBlurEvent = null;
	this.hasClearEvent = false;		this.fncClearEvent = null;
	/**
	 *  @name           ComboBox#fncChangeEvent
	 *  @event
	 *  @description    ComboBox의 값이바뀌면 발생하는 이벤트 메소드입니다.
	 */
	this.hasChangeEvent = (typeof self[this.controlId + "_onchange"] != "undefined");
	if (this.hasChangeEvent){
		this.fncChangeEvent = new Function("return function () { return " + this.controlId + "_onchange(); }")();
	}
	/**
	 *  @name           ComboBox#fncFocusEvent
	 *  @event
	 *  @description    ComboBox의 포커스가 지정되면 발생하는 이벤트 메소드 입니다.
	 */
	this.hasFocusEvent = (typeof self[this.controlId + "_onfocus"] != "undefined");
	if (this.hasFocusEvent){
		this.fncFocusEvent = new Function("return function () { return " + this.controlId + "_onfocus(); }")();
	}
	/**
	 *  @name           ComboBox#fncBlurEvent
	 *  @event
	 *  @description    ComboBox의 포커스가 해제되면 발생하는 이벤트 메소드입니다.
	 */
	this.hasBlurEvent = (typeof self[this.controlId + "_onblur"] != "undefined");
	if (this.hasBlurEvent){
		this.fncBlurEvent = new Function("return function () { return " + this.controlId + "_onblur(); }")();
	}
	/**
	 *  @name           ComboBox#fncClearEvent
	 *  @event
	 *  @description    ComboBox의 항목이 비워졌을 때 발생하는 이벤트 메소드입니다.
	 */
	this.hasClearEvent = (typeof self[this.controlId + "_onclear"] != "undefined");
	if (this.hasClearEvent){
		this.fncClearEvent = new Function("return function () { return " + this.controlId + "_onclear(); }")();
	}
	
	// 이벤트 선언부
	setEventHandler(this.tagObject, "keydown",   combo_KeyDown);
	setEventHandler(this.tagObject, "change",    combo_Change);
	setEventHandler(this.tagObject, "focus",     combo_Focus);
	setEventHandler(this.tagObject, "blur",      combo_Blur);
	setEventHandler(this.tagObject, "mouseover", combo_MouseOver);
	
	// Edit 설정부
	/**
	 * @description 미정
	 */
	this.selectedItemNum = -1;
	
	makeComboEditControl();
    
	this.comboDiv = null;
	//
	if( BrowserDetect.browser == "Explorer"
		&& !isNaN(parseFloat(BrowserDetect.version))
		&& parseFloat(BrowserDetect.version) < 9
	){
		this.comboDiv = document.createElement(
				"<div id='_$_ComboDiv_' name='_$_ComboDiv_' class='dropdownlist' "
				+ "style='position:absolute; left:-10000px; width: 10px;height:240px; display:none; font-size: 13.3333px;'/></div>"
		);
	}
	else{
		var div = this.comboDiv = document.createElement("div");
		div.id				= "_$_ComboDiv_";
		div.name			= "_$_ComboDiv_";
		div.className		= "dropdownlist";
		div.style.display	= "none";
		div.style.position	= "absolute";
		div.style.left		= "-10000px";
		div.style.width		= "10px";
		div.style.height	= "240px";
		div.style.fontSize	= "12px";
		div = null;
	}
	// 콤보 리스트가 서버에서 조회되어 채워진 경우
	var options = this.tagObject.options;
	var optCnt = options.length;
	if( this.comboDiv && optCnt > 0){
		var option = null;
		var optStr = "";
		var i = 0;
		
		for(i = 0; i < optCnt; i++, option = null){
			option = options[i];
			optStr += "<a onmousedown='sel(event);'>" + option.text + "</a>\r\n";
		}
		
		this.comboDiv.innerHTML = optStr;
		
		optStr = null;
		options = null;
	}
};

ComboBox.prototype = new ControlBase(); // 의미없음 코딩 편의기능을 활용하기 위함
/**
 * @description 태그객체에서 콤보박스의 ID를 찾아 반환합니다. 
 * @param em {Object} ID를 찾을 element 입니다.
 * @return 태그객체의 ID를 반환합니다.,에러발생시 undefined를 반환합니다.
 * 
 */
function searchControl_ComboBox(em){
	var pEm = em;
	var image = pEm.getAttribute("image");
	var className = null;
	var wReturn = null;
	
//	while (pEm.parentNode && !pEm.className.startsWith("ComboBox")) 
//		pEm = pEm.parentNode;
//	if( pEm.className.startsWith("ComboBox") ){
//		wReturn = getControlById(pEm.id);
//	}
	
	while(pEm.parentNode && pEm.tagName != "body" && image !== "ComboBox"){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}
	
	if( pEm.getAttribute("image") === "ComboBox" ){
		wReturn = getControlById(pEm.id);
	}
	else{
		pEm = null;
		pEm = em;
		
		while(pEm.parentNode && !pEm.className.startsWith("ComboBox"))
			pEm = pEm.parentNode;
		
		if( pEm.className.startsWith("ComboBox") )
			wReturn = getControlById(pEm.id);
	}
	
	image = null;
	pEm = null;
	
	return wReturn;
};

/**
 * @description 선택된 ComboBox에 focus를 줍니다.
 * @return {boolean} 선택되었다면 true 그렇지않다면 false를 반환합니다
 * @example constorls["ComboBox_1"].focus();
 */
/* 포커스 주기*/
ComboBox.prototype.focus = function(){ 	
	// functionname : [ComboBox.focus]
	var wReturn = true;
	
	try{
		if( this.editable ){
			// 편집콘트롤을 세팅 
			setComboEditControl(this);
			self["_$_ComboEdit_"].focus();
		}
		else{
			this.tagObject.focus();
		}
		
		// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
		if( !this.passEvent ){
			// 사용자 코딩 추가영역을 호출한다
			if( this.hasFocusEvent ){
				var result = this.fncFocusEvent();
				if( typeof result == "boolean" )
					return result;
			}
		}
	}
	catch(e){
		wReturn = false;
	}
	
	return wReturn;
};

/**
 * @description  ComboBox에 내용을 채웁니다.
 * @param value {Object} option으로 들어올 값
 * @return {boolean} 내용이 성공적으로 채워졌으면 true, 실패했다면 false를 반환합니다.
 * @example controls["ComboBox_1"].setValue(value);
 */
ComboBox.prototype.setValue = function(value){ 	
	// functionname : [ComboBox.setValue]
	
	if( this.listCount() == 0 ) {
		this.reservedValue = value;
		return false;
	}
	
//	if( parseInt(1 * value) == 0 && !this.haveZeroValue() )
	if( (1 * value) == 0 && !this.haveZeroValue() )
		value = "";
	
	var oldValue = this.value;
	var oldText = this.text;
	var oldIndex = this.index;
	
	//seq 변경시 값은 바뀌지 않아도 콘트롤의 상태는 바꾸어줄 상황이 있다
	var selectedIndex = this.tagObject.selectedIndex;
	var control_value = (selectedIndex == -1 ? "" : ("" + this.tagObject.options[selectedIndex].value));
	var control_text = (selectedIndex == -1 ? "" : ("" + this.tagObject.options[selectedIndex].text));
	
	if( (("" + oldValue == "" + value) && ("" + control_value == "" + value))
		&& (("" + oldText == "" + this.topItemText) && ("" + control_text == "" + this.topItemText) && (this.topItemText !== ""))
	){
		//메모리 해제
		control_text = null; controlvalue = null;
		oldValue = null; oldText = null;
		return true;
	}
	
	var wOptions = null;
	var found = false;
	
	if( value === "" && this.topItemValue !== "" ){
		this.value = "";
		this.text = "";
		this.index = -1;
		this.tagObject.selectedIndex = this.index;
		found = true;
	}
	else{
		wOptions = this.tagObject.options;
		
		this.stateClear = true;
		for(var i = 0; i < wOptions.length; i++){
			if( wOptions[i].value == value ){
				wOptions[i].selected = true;
				this.value = value;
				this.text = wOptions[i].text;
				this.index = i;
				found = true;
				break;
			}
		}
		this.stateClear = false;
		
		wOptions = null;
	}
	
	if( !found ){
		this.reservedValue = value;
	    /**
	     * @description    콤보박스의 선택 값을 나타냅니다.<br>
        *                   기본값 : -1 (선택 안함)<br><br>
        *                   <table width="500">
        *                       <caption>value Variable Value</caption>
        *                       <thead>
        *                 	        <tr>
        *                 			    <th align="left">Value</th>
        *                 			    <th align="left">Description</th>
        *                 		    </tr><br>
	    */
		this.value = "";
	    /**
	     * @description    콤보박스의 보여질 문자를 나타냅니다.<br>
        *                   기본값 : null <br><br>
        *                   <table width="500">
        *                       <caption>text Variable Value</caption>
        *                       <thead>
        *                 	        <tr>
        *                 			    <th align="left">Value</th>
        *                 			    <th align="left">Description</th>
        *                 		    </tr>
        *                 	    </thead>
        *                   <br>
	    */
		this.text = "";
	    /**
	     * @description 미결
	     */
		this.index = -1;
		this.tagObject.selectedIndex = -1;
		
		if( !this.passEvent && typeof(ControlBase.prototype._UpdateDataset) != "undefined" ){
			var datasetId = null;
			var key = null;
			for(key in this.dataBinds){
				if( typeof this.dataBinds[key] == "function" ) continue;
				if( typeof BindInfo != "undefined" && this.dataBinds[key] instanceof BindInfo ){
					datasetId = this.dataBinds[key].datasetId;
					break;
				}
			}
			if( datasetId != null ){
				dataSets[datasetId].instantUpdateControl = false;
				this._UpdateDataset();
				dataSets[datasetId].instantUpdateControl = true;
			}
			//메모리 해제
			key = null; datasetId = null;
		}
		
		//메모리 해제
		controlvalue = null; oldValue = null; oldText = null;
		
		return false;
	}
    
    if( ("" + oldValue != "" + this.value) || (oldIndex != this.index) ){ // 내부값이 변경된 상황
	    if( !this.checkError() ){
			this.value = oldValue;
			this.text = oldText;
			this.index = oldIndex;
			this.tagObject.selectedIndex = oldIndex;
			if( !this.passEvent && typeof(ControlBase.prototype._UpdateDataset) != "undefined" ) this._UpdateDataset();
			this.tagObject.focus();
			//메모리 해제
			controlvalue = null; oldValue = null; oldText = null;
			return false;
	    }
	    
	    // dataset 갱신 기능 
	    if( typeof(ControlBase.prototype._UpdateDataset) != "undefined" )
	    	this._UpdateDataset();
	    
	    //passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
    	if( !this.passEvent ){
		    // 사용자 코딩 추가영역을 호출한다
    		if( this.hasChangeEvent ){
    			var result = this.fncChangeEvent();
    			if( result === false ){
    				this.value = oldValue;
    				this.text = oldText;
    				this.index = oldIndex;
    				this.tagObject.selectedIndex = oldIndex;
    				if( !this.passEvent && typeof(ControlBase.prototype._UpdateDataset) != "undefined" ) this._UpdateDataset();
    				this.tagObject.focus();
    				//메모리 해제
    				controlvalue = null; oldValue = null; oldText = null;
    				return false;
    			}
    		}
    	}
    }
    
	if( this.editable && this.visible ){
		self["_$_ComboEdit_"].style.display = "none";
		setComboEditControl(this);
	}
    
    //메모리 해제
    controlvalue = null; oldValue = null; oldText = null;
	
    return true;
};

/**
 * @description ComboBox에 겉값으로 보여질 문자를 설정합니다.
 * @param text {String}  ComboBox에 겉값으로 보여질 문자열입니다.
 * @return {boolean} 성공했다면 true, 실패했다면 false,<br>에러발생시 undefined를 반환합니다.
 * @example contorls["ComboBox_1"].setText("콤보박스");
 */
ComboBox.prototype.setText = function(text){
	// functionname : [ComboBox.setText]
	
	if( this.listCount() == 0 ) {
		this.reservedText = text;
		return false;
	}
	
	var oldValue = this.value;
	var oldText = this.text;
	var oldIndex = this.index;
	
	if( oldText == text && this.topItemText !== "" ){
		oldText = null; oldValue = null;
		return true;
	}
	
	var wOptions = null;
	var found = false;
	
	if( text === "" && !this.haveEmptyText() ){
		this.value = "";
		this.text = "";
		this.index = -1;
		this.tagObject.selectedIndex = this.index;
		found = true;
	}
	else{
		wOptions =  this.tagObject.options;
		
		this.stateClear = true;
		for(var i = 0; i < wOptions.length; i++){
			if( wOptions[i].text == text ){
				wOptions[i].selected = true;
				this.text = wOptions[i].text;
				this.value = wOptions[i].value;
				this.index = i;
				found = true;
				break;
			}
		}
		this.stateClear = false;
		
		wOptions = null;
	}
	
	if( !found ){
		this.reservedText = text;
		this.value = "";
		this.text = "";
		this.index = -1;
		this.tagObject.selectedIndex = -1;
		
		if( !this.passEvent && typeof(ControlBase.prototype._UpdateDataset) != "undefined" ){
			var datasetId = null;
			for(var key in this.dataBinds){
				if( typeof this.dataBinds[key] == "function" ) continue;
				if( typeof BindInfo != "undefined" && this.dataBinds[key] instanceof BindInfo ){
					datasetId = this.dataBinds[key].datasetId;
					break;
				}
			}
			if( datasetId != null ){
				dataSets[datasetId].instantUpdateControl = false;
				this._UpdateDataset();
				dataSets[datasetId].instantUpdateControl = true;
			}
			datasetId = null;
		}
		
		return false;
	}
	
	if( ("" + oldText != "" + this.text) || (oldIndex != this.index) ){		// 내부값이 변경된 상황
		if( !this.checkError() ){
			this.value = oldValue;
			this.text = oldText;
			this.index = oldIndex;
			this.tagObject.selectedIndex = oldIndex;
			if( !this.passEvent && typeof(ControlBase.prototype._UpdateDataset) != "undefined" ) this._UpdateDataset();
			this.tagObject.focus();
			return false;
		}
		
		// dataset 갱신 기능 
		if( typeof(ControlBase.prototype._UpdateDataset) != "undefined" )
			this._UpdateDataset();
		
		// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
		if( !this.passEvent ){
			// 사용자 코딩 추가영역을 호출한다
			if( this.hasChangeEvent ){
				var result = this.fncChangeEvent();
				if( result === false ){
					this.value = oldValue;
					this.text = oldText;
					this.index = oldIndex;
					this.tagObject.selectedIndex = oldIndex;
					if( !this.passEvent && typeof(ControlBase.prototype._UpdateDataset) != "undefined" ) this._UpdateDataset();
					this.tagObject.focus();
					return false;
				}
			}
		}
	}
	
	if( this.editable && this.visible ){
		self["_$_ComboEdit_"].style.display = "none";
		setComboEditControl(this);
	}
	
    // 관련객체 프로퍼티 채우기
    // this.setLinkedProperties(text, 1);
    /*
    // 데이터 가저오기
    if (this.isKeyControl){
        if (this.isFillControl){
        	mustFillScreenAfterLoad = true;
        }
        objectManager.fillkeyFieldValue = this.value;
     	objectManager.loadData();
    }
    
    // 데이터 채우기
    if (!this.isKeyControl && this.isFillControl){
    	objectManager.fillData();
    }
    */
	
	return true;
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
ComboBox.prototype.setValueToDefault = function(){
	// functionname : [ComboBox.setValueToDefault]
	
	var wOptions =  this.tagObject.options;
	var value = null;
	
	//콤보 내 목록이 없다면 기본값을 예약값으로 설정하고 콤보 값 초기화
	if( wOptions.length == 0 ){
		this.reservedValue = this.defaultValue;
		this.value = "";
		this.text = "";
		this.index = -1;
		this.tagObject.selectedIndex = -1;
		return false;
	}
	else if( wOptions.length == 1 && this.selectWhenOnlyItem ){
		return this.setIndex(0);
	}
	
	//기본값이 없는 경우
	if( this.defaultValue.length == 0 ){
		this.setIndex(-1);
		return false;
	}
	
	value = this.defaultValue;
	
	//기본값이 0이지만 콤보 내 항목 중 0이 없는 경우
	if( parseInt(1 * value) == 0 && !this.haveZeroValue() ){
		this.setIndex(-1);
		return false;
	}
	
	this.setValue(this.defaultValue);
	
	return true;
};

/**
 * @description ComboBox에 option을 추가합니다.
 * @param pText {String} option에 겉값으로 보여질 문자 입니다.
 * @param pData	{Object} option에 속값으로 설정될 값입니다.
 * @return 반환값없음, 에러발생시 undefined를 반환합니다.
 * @example controls["ComboBox_1"].addItem("abc",abc);
 */
ComboBox.prototype.addItem = function(pText, pData){
	// functionname : [ComboBox.addItem]
    
	var oldIndex = this.tagObject.selectedIndex;
	var opt = document.createElement("option");
	opt.value = pData;
	opt.text = pText;
	
	this.tagObject.options.add(opt);
	
	var anchor = null;
	if( typeof this.comboDiv != "undefined" && this.comboDiv != null ){
		anchor = document.createElement("a");
		anchor.text = pText;
		setEventHandler(anchor, "mousedown", sel);
		
		this.comboDiv.appendChild(anchor);
	}
	
	//이전 인덱스로 이동
	this.tagObject.selectedIndex = oldIndex;
	
	anchor = null;
	opt = null;
	
	return true;
};
/**
 * @description	미결
 * @param	{String}	pText	option에 겉값으로 보여질 문자 입니다.
 * @param	{Object}	pData
 * @param	{Object}	pIndex
 * @return	{undefined}
 * @example	미결
 */
ComboBox.prototype.insertItem = function(pText, pData, pIndex){
	// functionname : [ComboBox.insertItem]
	
	var opt = document.createElement("option");
	opt.value = pData;
	opt.text = pText;
	
	var anchor = null;
	if( typeof this.comboDiv != "undefined" && this.comboDiv != null ){
		anchor = document.createElement("a");
		anchor.text = pText;
		setEventHandler(anchor, "mousedown", sel);
	}
	
	var isNumRegx = /^\d+$/;
	
	//인덱스 파라메터가 0 이상인 정수인지 체크하여 0 이상인 경우 해당 인덱스 앞에 추가하지만 인덱스가 올바르지 않은 경우 맨 뒤에 추가
	if( !(isNumRegx.test(pIndex + "")) ){
		this.tagObject.options.add(opt);
		
		if( anchor != null ){
			this.comboDiv.appendChild(anchor);
		}
	}
	else{
		this.tagObject.insertBefore(opt, this.tagObject.childNodes[pIndex]);
		
		if( anchor != null ){
			var options = this.comboDiv.querySelectorAll("a");
			this.comboDiv.insertBefore(anchor, options[pIndex]);
			options = null;
		}
	}
	
	isNumRegx = null; anchor = null; opt = null;
    
    return true;
};

/**
 * @description	미결
 * @param	{Object}	pIndex
 * @return	{Object}
 * @example	미결
 */
ComboBox.prototype.selectIndex = function(pIndex){
	// functionname : [ComboBox.selectIndex]
	
	return this.setIndex(pIndex);
};

/**
 * @description 미결
 * @param	{Object}	pIndex
 * @return 	{boolean}
 * @example 미결
 */
ComboBox.prototype.setIndex = function(pIndex){
	// functionname : [ComboBox.setIndex]
	
	var result = true;
	var oldIndex = this.index;
	var oldValue = this.value;
	var oldText = this.text;
	
	if( oldIndex == pIndex && this.tagObject.selectedIndex == pIndex ){
		return true;
	}
	
	var wOptions = this.tagObject.options;
	
	if(0 > pIndex || wOptions.length <= pIndex){
		if(this.tagObject){
			this.value = "";
			this.text = "";
			this.index = -1;
			this.tagObject.selectedIndex = -1;
			
			if( !this.passEvent && typeof(ControlBase.prototype._UpdateDataset) != "undefined" ){
				var datasetId = null;
				for(var key in this.dataBinds){
					if( typeof this.dataBinds[key] == "function" ) continue;
					if( typeof BindInfo != "undefined" && this.dataBinds[key] instanceof BindInfo ){
						datasetId = this.dataBinds[key].datasetId;
						break;
					}
				}
				if( datasetId != null ){
					dataSets[datasetId].instantUpdateControl = false;
					this._UpdateDataset();
					dataSets[datasetId].instantUpdateControl = true;
				}
			}
		}
		
		result = false;
	}
	else{
		//콤보박스 항목 선택 및 콤보박스 객체의 value와 text property 갱신
		wOptions[pIndex].selected = true;
		this.value = wOptions[pIndex].value;
		this.text = wOptions[pIndex].text;
		this.index = pIndex * 1;
		
		if( !this.checkError() ){
			this.value = oldValue;
			this.text = oldText;
			this.index = oldIndex;
			this.tagObject.selectedIndex = oldIndex;
			
			if( !this.passEvent && typeof(ControlBase.prototype._UpdateDataset) != "undefined" ) this._UpdateDataset();
			
			return false;
		}
		
		// dataset 갱신 기능 
		if( typeof(ControlBase.prototype._UpdateDataset) != "undefined" ){
			this._UpdateDataset();
		}
		
		// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
		if( !this.passEvent ){
			// 사용자 코딩 추가영역을 호출한다
			if( this.hasChangeEvent ){
				var result = this.fncChangeEvent();
				if( result === false ){
					this.value = oldValue;
					this.text = oldText;
					this.tagObject.selectedIndex = oldIndex;
					
					if( typeof(ControlBase.prototype._UpdateDataset) != "undefined" ) this._UpdateDataset();
					
					return false;
				}
			}
		}
		
		if( this.editable && this.visible ){
	    	self["_$_ComboEdit_"].style.display = "none";
	    	setComboEditControl(this);
	    }
	}
	
	return result;
};
/**
 * @description ComboBox의 지정한 option을 삭제합니다.
 * @param pData {Object} 지워질option의 값입니다.
 * @return 반환값 없음, 에러발생시 undefined를 반환합니다.
 * @example controls["ComboBox_1"].removeItem(abc);
 */
ComboBox.prototype.removeItem = function(pData){
	// functionname : [ComboBox.removeItem]
	
	var wOptions = this.tagObject.options;
	var wOption = null;
	var deleteIndex = -1;
	var i = 0;
	
	if( ("" + pData).length > 0 ){
		for(i = wOptions.length - 1; i >= 0; i--, wOption = null){
			wOption = wOptions[i];
			
			if( wOption.value == pData ){
				wOptions.remove(i);
				deleteIndex = i;
				wOption = null;
				break;
			}
		}
	}
	
	if( typeof this.comboDiv != "undefined" && this.comboDiv != null ){
		var options = this.comboDiv.getElementsByTagName("a");
		var option = options[deleteIndex];
		
		removeEventHandler(option, "mousedown", sel);
		option.parentNode.removeChild(option);
		
		option = null;
		options = null;
	}
    
//	var aTagItems = this.comboDivClone.innerHTML.split("\n");
//	var aTagItemLength = aTagItems.length;
//	if(aTagItemLength > 0 && aTagItemLength > i && i >= 0){
//		removeEventHandler(aTagItems[i], "mousedown", sel);
//		aTagItems.splice(i, 1);
//		
//		this.comboDivClone.innerHTML = aTagItems.join("\r\n");
//		
//		for(i = aTagItemLength - 1; i >= 0; i--) aTagItems.pop();
//	}
//	aTagItems = null;
};
/**
 * @description	미결
 * @param	{object}	pData
 * @param	{object}	objectId
 * @return  {string}
 * @example	미결
 */
ComboBox.prototype.textOfData = function(pData, objectId){
	// functionname : [ComboBox.textOfData]

	var wReturn = "";
    var i = 0;
	               	
//	var checkEvent = false;
//	try {
//		if (eval("getCasheKey_" + this.controlId)) checkEvent = true;
//	} catch(e){}
//	
//	if (checkEvent){
//		var recordsetKey = "fillList_" + this.controlId;
//	    var casheKey = eval("getCasheKey_" + this.controlId + "(objectId);");
//	    var wArrKey = casheKey.split(":");
//	    
//	    // SQL번호만 있는 경우 콜론을 붙여준다
//	    if (casheKey.indexOf(":") < 0) casheKey += ":";
//        
//	    var recordset = getRecordsetByKey(recordsetKey);
//	    if (recordset.casheKey != casheKey){
//	        var dataCashe = dataCashes[casheKey];
//	        
//	        if (dataCashe == undefined){
//	        	// casheMode가 설정되면 리스트는 갱신안되고 캐시에만 저장된다
//	        	recordset.casheMode = true;
//	    		recordset.sqlnum = wArrKey[0];
//                
//	        	for (var i=1; i < wArrKey.length; i++){
//		    		recordset.setParameter("param" + i, wArrKey[i]);
//	        	}
//	        	// syncMode로 호출 된다
//	    		recordset.open();
//	    		// 호출후 recordsetKey + "_OnReceive"가 수행된다
//	    		
//	    		recordset.casheMode = false; 
//	    		dataCashe = dataCashes[casheKey];
//	        }
//	        else{
//	        	for (i = 0; i < dataCashe.rowCount; i++){
//	        		if (dataCashe.fields[0].datas[i] == pData){
//	        			wReturn = dataCashe.fields[1].datas[i];
//	        			break;
//	        		}
//	        	}
//	        	
//	        	return wReturn; 
//	        }	       
//	    }
//	}

    var wOptions = this.tagObject.options;
    
    for(i = wOptions.length - 1; i >= 0; i--){
    	if( ("" + pData).length > 0 && wOptions[i].value == pData ){
    		wReturn = wOptions[i].text;
            break;
        }
    }
    
    return wReturn;
};
/**
 * @description ComboBox에 속해있는 option의 갯수를 반환합니다.
 * @return {Integer} option의 갯수를 반환합니다.
 * @example contorls["ComboBox_1"].listCount();
 */
ComboBox.prototype.listCount = function(){
	// functionname : [ComboBox.listCount]

	return this.tagObject.options.length;
};
/**
 * @description ComboBox에 속해있는option들을 모두 지웁니다.
 * @return {boolean} clear성공시 true 실패시false를 반환한다.
 * @example contorls["ComboBox"].clear();
 */
ComboBox.prototype.clear = function(){
	// functionname : [ComboBox.clear]
	
	var haveComboDiv = (typeof this.comboDiv != "undefined" && this.comboDiv != null);
	var wOptions = this.tagObject.options;
	var wOption = null;
	var i = 0;
	
	this.stateClear = true;
	
	//리스트 클리어
	for(i = wOptions.length - 1; i >= 0; i--){
	    wOptions.remove(i);
	}
	
	//전체선택 코드와 텍스트 값이 모두 존재하는 경우에 전체선택  항목 추가
	if( this.haveFixedTopItem === true ){
		wOption = document.createElement("option");
		wOption.value = this.topItemValue;
		wOption.text = this.topItemText;
		//항목 추가
		wOptions.add(wOption);
	}
	
	//메모리 해제
	wOption = null;
	wOptions = null;
	
	//편집 콤보박스용 Div가 존재하는 경우
	if( haveComboDiv === true ){
		var options = this.comboDiv.getElementsByTagName("a");
		var option = null;
		
		//리스트 클리어
		for(i = options.length - 1; i >= 0; i--, option = null){
			option = options[i];
			removeEventHandler(option, "mousedown", sel);    			
		}
		this.comboDiv.innerHTML = "";
		
		//전체선택 코드와 텍스트 값이 모두 존재하는 경우에 전체선택  항목 추가
		if( this.haveFixedTopItem === true ){
			option = document.createElement("a");
			option.text = this.topItemText;
			setEventHandler(option, "mousedown", sel);
			//항목 추가
			this.comboDiv.appendChild(option);
		}
		
		//메모리 해제
		option = null;
		options = null;
	}
	
	this.stateClear = false;
	
//	this.value= "-1";
//	this.text = "";
	this.value = "";
	this.text = "";
	this.index = -1;
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if( this.hasClearEvent ){
			var result = this.fncClearEvent();
			if( typeof result == "boolean" ) return result;
		}
	}
	
	return true;
};

ComboBox.prototype.clearWithNoEvnets = function(){
	// functionname : [ComboBox.clearWithNoEvnets]
	
	var haveSelectAllm = ( (this.topItemText != null && typeof this.topItemText != "undefined") && (this.topItemValue != null && typeof this.topItemValue != "undefined") );
	var haveComboDiv = (typeof this.comboDiv != "undefined" && this.comboDiv != null);
	
	var wOptions = this.tagObject.options;
	var wOption = null;
	var i = 0;
	
	this.stateClear = true;
	
	//리스트 클리어
	for(i = wOptions.length - 1; i >= 0; i--){
	    wOptions.remove(i);
	}
	
	//전체선택 코드와 텍스트 값이 모두 존재하는 경우에 전체선택  항목 추가
	if( this.haveFixedTopItem === true ){
		wOption = document.createElement("option");
		wOption.value = this.topItemValue;
		wOption.text = this.topItemText;
		//항목 추가
		wOptions.add(wOption);
	}
	
	//메모리 해제
	wOption = null;
	wOptions = null;
	
	//편집 콤보박스용 Div가 존재하는 경우
	if( typeof this.comboDiv != "undefined" && this.comboDiv != null ){
		var options = this.comboDiv.getElementsByTagName("a");
		var option = null;
		
		//리스트 클리어
		for(i = options.length - 1; i >= 0; i--, option = null){
			option = options[i];
			removeEventHandler(option, "mousedown", sel);    			
		}
		this.comboDiv.innerHTML = "";
		
		//전체선택 코드와 텍스트 값이 모두 존재하는 경우에 전체선택  항목 추가
		if( this.haveFixedTopItem === true ){
			option = document.createElement("a");
			option.text = this.topItemText;
			setEventHandler(option, "mousedown", sel);
			//항목 추가
			this.comboDiv.appendChild(option);
		}
		
		//메모리 해제
		option = null;
		options = null;
	}
	
	this.stateClear = false;
	
	return true;
};

ComboBox.prototype.setLists = function(recordset){
	// functionname : [ComboBox.setLists]
	
	// 화면에 없는 데이터 가저오기인 경우
	if( recordset.casheMode ) return;
	
	if( this.reservedValue != "" || this.reservedText != "" )
		this.clearWithNoEvnets();	// 클리어 이벤트에서 콘트롤 값과 객체값을 바꾸지 않도록 한다
	else
		this.clear();
	
	/* 선택(-1) 무조건 추가하는 로직 제거
	// 데이터 하나만 있을때 무조건 선택하는 경우는 "(선택)"을 만들지 않음
	if(this.selectWhenOnlyItem){	// 통과	
	}
	else{
		//this.addItem("(선택)","-1");
	}
	*/
	
	var optList = [];
	var i = 0;
	
	//콤보 리스트 생성
	if( recordset.commandType == "Dataset" ){
		if( (typeof this.valueField == "string" && this.valueField.length > 0) || 
			(typeof this.textField == "string" && this.textField.length > 0)
		){
			var vField = (this.valueField.length > 0) ? this.valueField : this.textField;
			var tField = (this.textField.length > 0) ? this.textField : this.valueField;
			var list = recordset.dataSet.data;
			var listSize = list.length;
			var record = null; var text = null; var value = null;
			
			for(i = 0; i < listSize; i++, record = null, text = null, value = null){
				record = list[i];
				text = record[tField];
				value = record[vField];
				
				this.addItem(text, value);
				optList[i] = "<a onmousedown='sel(event);'>" + text + "</a>\r\n";
			}
			
			list = null; tField = null; vField = null;
		}
	}
	else{
		if( recordset.fields.length == 1 ){
			var text = null;
			
			while(!recordset.EOF){
				text = recordset.fields[0].value();
				
				this.addItem(text, text);
				optList.push("<a onmousedown='sel(event);'>" + text + "</a>");
				
				recordset.moveNext();
				
				text = null;
			}
		}
		else{
			var text = null; var value = null;
			
			while(!recordset.EOF){
				text = recordset.fields[1].value();
				value = recordset.fields[0].value();
				
				this.addItem(text, value);
				optList.push("<a onmousedown='sel(event);'>" + text + "</a>");
				
				recordset.moveNext();
				
				value = null; text = null;
			}
		}
	}
	
	if( typeof this.comboDiv != "undefined" && this.comboDiv != null ){
		this.comboDiv.innerHTML = optList.join("\r\n");
	}
	
	//메모리 해제
	optList.clear();
	optList = null;
	
	//콤보 항목이 1개이고 '단일레코드선택' 속성이 true로 설정되었다면, 첫번째 항목을 선택한다 
	if( recordset.rowCount == 1 && this.selectWhenOnlyItem ){
//		this.setValue(recordset.fields[0].datas[0]); //recordset.fields[필드번호].datas[레코드번호]
		this.setIndex(0); //첫번째 콤보 항목을 자동으로 선택한다
	}
//	else if( this.reservedValue != "-1" ){
//		// 리스팅을 다시 했으면 무조건 "_onchange" 이벤트가 일어나야 한다 
//		// 그러려고 값을 -1로 대입한다
//    	this.value = "-1";
//    	this.text = "";
//    	this.setValue(this.reservedValue);
//	}
	else if( this.reservedValue != "" ){
		this.value = "";
		this.text = "";
		this.index = -1;
    	this.setValue(this.reservedValue);
    }
//	else if( this.reservedText != "" ){
//		// 리스팅을 다시 했으면 무조건 "_onchange" 이벤트가 일어나야 한다 
//		// 그러려고 값을 -1로 대입한다
//		this.value = "-1";
//		this.text = "";
//		this.setText(this.reservedText);
//	}
	else if( this.reservedText != "" ){
    	this.value = "";
    	this.text = "";
    	this.index = -1;
    	this.setText(this.reservedText);
    }
	else{
		this.setValueToDefault();
    }
	
	recordset.close();
    
//	this.reservedValue = "-1";
//	this.reservedText = "";
	this.reservedValue = "";
	this.reservedText = "";
	
	return true;
};

// 화면로드시만 일어나는 기능으로 디폴트값선택등 추가기능은 생략
ComboBox.prototype.setDefaultLists = function(listsStr, itemsStr){
	// functionname : [ComboBox.setDefaultLists]
	
	if( typeof itemsStr == "undefined" || (typeof itemsStr == "string" && itemsStr.trim().length == 0) ){
		//itemsStr = listsStr;
	}
	
	listsStr = listsStr.replace(/,/g,"<COMMA>");
	itemsStr = itemsStr.replace(/,/g,"<COMMA>");
	
	var wOptions = this.tagObject.options;
	var wOption = null;
	var wOptionCnt = wOptions.length;
	var i = 0;
	
	if( wOptionCnt > (this.haveFixedTopItem === true ? 1 : 0) ){
		for(i = 0; i < wOptionCnt; i++, wOption = null){
			wOption = wOptions[i];
			listsStr += "<COMMA>" + wOption.text;
			itemsStr += "<COMMA>" + wOption.value;
		}
	}

	var arrayLists = listsStr.split("<COMMA>");
	var arrayItems = itemsStr.split("<COMMA>");
	var arrayListCnt = arrayLists.length;
	
	this.clear();
    
    for(i = 0; i < arrayListCnt; i++){
    	//if (i == 0) this.value = arrayItems[i]; // 초기값 셋팅
    	this.addItem(arrayLists[i], arrayItems[i]);
    }
	
	this.setValueToDefault();
	
//	this.reservedValue = "-1";
//	this.reservedText = "";
	this.reservedValue = "";
	this.reservedText = "";
	
	arrayItems.clear(); arrayItems = null;
	arrayLists.clear(); arrayLists = null;
	
	return true;
};

ComboBox.prototype.haveZeroValue = function(){
	// functionname : [ComboBox.haveZeroValue]

	var wReturn = false;
    var wOptions = this.tagObject.options;
    var wOption = null;
    
    for(var i = wOptions.length - 1; i >= 0; i--, wOption = null){
    	wOption = wOptions[i];
    	
    	if( wOption.value == "0" ){
    		wReturn = true;
    		wOption = null;
    		break;
    	}
    }
    
    wOptions = null;
    
    return wReturn;
};

ComboBox.prototype.haveEmptyText = function(){
	// functionname : [ComboBox.haveEmptyText]

	var wReturn = false;
    var wOptions = this.tagObject.options;
    var wOption = null;
    
    for(var i = wOptions.length - 1; i >= 0; i--, wOption = null){
    	wOption = wOptions[i];
    	
    	if( wOption.text == "" ){
    		wReturn = true;
    		wOption = null;
    		break;
    	}
    }
    
    wOptions = null;
    
    return wReturn;
};

ComboBox.prototype.textFound = function(textLinked){
    // functionname : [ComboBox.textFound]
    
    var wReturn = false;
    var text = textLinked || "";
	var wOptions =  this.tagObject.options;
	var wOption = null;
	
	for(var i = wOptions.length - 1; i >= 0; i--, wOption = null){
		wOption = wOptions[i];
		
		if( wOption.text == text ){
			wReturn = true;
			wOption = null;
			break;
		}
	}
	
	wOptions = null;
	text = null;
    	
    return wReturn;
};

ComboBox.prototype.setFixedTopItem = function(pText, pData){
	// functionname : [ComboBox.setFixedTopItem]
	
	//상단항목추가 설정이 true가 아니라면 추가하지 않음
	if( this.haveFixedTopItem == false ) return;
	
	//전체선택 텍스트 값이 비어있거나 null인 경우
	if( pText == null || typeof pText == "undefined" ) pText = "";
	//전체선택 코드 값이 비어있거나 null인 경우
	if( pData == null || typeof pData == "undefined" ) pData = "";
	
	this.topItemText = pText;
	this.topItemValue = pData;
	
	var option = this.tagObject.options[0];
	option.text = pText;
	option.value = pData;
	option = null;
	
	//만약 전체선택 값과 현재 콤보의 값이 같다면 setValue 함수 호출함
	if( this.value === pData ){
		this.setValue(pData);
	}
};

/**
 * @name ComboBox#combo_Focus
 * @event
 * @return	{boolean}
 * @description	미결
 */
function combo_Focus(e){
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? event.target : event.srcElement);
	var control = searchControl_ComboBox(em);

    if( control.editable ){
    	// 편집콘트롤을 세팅 
    	setComboEditControl(control);
    	
    	stopEvent(e);
    	
        var comboEdit = self["_$_ComboEdit_"];  // ??????
        comboEdit.focus();
        
        comboEdit = null;
        control = null;
		em = null;
        
		return false;
	}
    
	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !control.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if( control.hasFocusEvent ){
			var result = control.fncFocusEvent();
			if( typeof result == "boolean" ){
				control = null;
				em = null;
				return result;
			}
		}
	}
	
	control = null;
	em = null;
	
	return true;
};
/**
 * @name ComboBox#combo_Blur
 * @event
 * @return	{boolean}
 * @description	미결
 */
function combo_Blur(e){
    e = window.event || e;
    
    var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? event.target : event.srcElement);
	var control = searchControl_ComboBox(em);
	
	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !control.passEvent ){
	    // 사용자 코딩 추가영역을 호출한다
	    if( control.hasBlurEvent ){
	    	var result = control.fncBlurEvent();
	    	if( typeof result == "boolean" ){
	    		control = null;
	    		em = null;
	    		return result;
	    	}
	    }
	}
	
	control = null;
	em = null;
   
    return true;
};
/**
 * @name ComboBox#combo_Change
 * @event
 * @return	{boolean}
 * @description	미결
 */
function combo_Change(e){
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_ComboBox(em);
	
	if( control.stateClear )
		return false;
	
	var wOptions = (navigator.userAgent.indexOf('Firefox') >= 0 ? em.parentNode.options : em.options); 
	var wOption = null;
	var oldValue = control.value;
	var oldText = control.text;
	var oldIndex = control.index;
	var newValue = "";
	var newText = "";
	var newIndex = -1;
	var optCnt = wOptions.length;
	var i = 0;
	
	for(i = 0; i < optCnt; i++, wOption = null){
		wOption = wOptions[i];
		
		if( wOption.selected == true ){
			newValue = wOption.value;
			newText = wOption.text;
			newIndex = i;
			
			wOption = null;
			
			break;
		}
	}
	
	if( ("" + oldValue == "" + newValue) && (1 * oldIndex == 1 * newIndex) ){
		newText = null; newValue = null; oldText = null; oldValue = null;
		wOptions = null; control = null; em = null;
		return true;
	}
	
	control.value = newValue;
	control.text = newText;
	control.index = newIndex;
	
	// dataset 갱신 기능 
	if( typeof ControlBase.prototype._UpdateDataset != "undefined" && newIndex >= 0 ){
		result = control._UpdateDataset();
		
		if( typeof result == "boolean" && !result ){
			control.value = oldValue;
			control.text = oldText;
			control.index = oldIndex;
			
			//컨트롤 태그 선택 복구
			em.value = oldValue;
			
			//메모리 해제
			newText = null; newValue = null; oldText = null; oldValue = null;
			wOptions = null; control = null; em = null;
			
			return false;
		}
	}
    
	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !control.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if( control.hasChangeEvent ){
			var result = control.fncChangeEvent();
			
			if( result === false ){
				control.value = oldValue;
				control.text = oldText;
				control.index = oldIndex;
				
				//컨트롤 태그 선택 복구
				em.value = oldValue;
				
				//데이터셋 데이터 복구
				if( typeof ControlBase.prototype._UpdateDataset != "undefined" ) control._UpdateDataset();
				
				//메모리 해제
				newText = null; newValue = null; oldText = null; oldValue = null;
				wOptions = null; control = null; em = null;
				
				return false;
			}
		}
	}
	
	//메모리 해제
	newText = null; newValue = null; oldText = null; oldValue = null;
	wOptions = null; control = null; em = null;
	
	return true;
};
/**
 * @name ComboBox#combo_KeyDown
 * @event
 * @return	{boolean}
 * @description	미결
 */
function combo_KeyDown(e){
	//F5새로고침 방지 추가
	if( e.keyCode == 116 ){
		stopEvent(e);
		return false;
	}
	
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var wKeyCode = e.which || e.keyCode;
	var control = searchControl_ComboBox(em);

	if( wKeyCode == 9 ){
		if( getShiftKeyPressed(e) ){
			stopEvent(e);
			setTimeout("setFocusToFormerControl(\"" + control.controlName + "\")", 0);
			control = null; em = null;
			return true;
		}
		else{
			stopEvent(e);
			setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
			control = null; em = null;
			return true;
		}
	}
	else if( wKeyCode == 13 ){
		stopEvent(e);
		setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
		control = null; em = null;
		return true;
	}
	
	//F1 - F8  키다운시 공통버튼 동작
	try{
		if(shortCutFunc(e,true)){ 
			stopEvent(e);
			control = null; em = null;
			return true;
		}
	} catch(e){}
	
	stopEvent(e);
	
	control = null;
	em = null;
	
	return true;
};



/*
 *	Editable ComboBox 
 */
/**
 * @name ComboBox#combo_MouseOver
 * @event
 * @return	{boolean}
 * @description	미결
 */
function combo_MouseOver(e){
	e = window.event || e;
    
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_ComboBox(em);
	
	if( !control.editable ){
		control = null; em = null;
		return true;
	}
	
	var comboEdit = self["_$_ComboEdit_"];
	var comboTarget = comboEdit.getAttribute("target");
	var controlName = control.controlName;

	//현재 편집중인 콤보가 아니면 덥개 콘트롤을 세팅 
    if( comboEdit.style.display !== "block"
    	|| controlName !== comboTarget
    ){
    	setComboCover(control);
    }
    
    stopEvent(e);
    
    comboTarget = null; controlName = null; comboEdit = null;
    control = null; em = null;
    
    return true;
};

/**
 * @name ComboBox#comboEdit_onBlur
 * @event
 * @return	{boolean}
 * @description	미결
 */
function comboEdit_onBlur(e){
	e = window.event || e;
	
	var comboEdit = self["_$_ComboEdit_"];
	var controlName = comboEdit.getAttribute("target");
	var control = null;
	
	if( controlName != null && controlName.length > 0 ){
		control = controls[controlName];
		
		control.tagObject.disabled = false;
		
		if( control.comboDiv.style.display === "block" ){
			//setTimeout(hidecomboDiv, 300);
			hidecomboDiv();
		}
	}
	
	stopEvent(e);
	
	control = null; controlName = null;
	comboEdit = null;
	
	return true;
};

/**
*     @description	미결
*     @return	{undefined}
*     @example	미결
*/
function fillOptions(){
	var controlName = self["_$_ComboEdit_"].getAttribute("target");
	var control = controls[controlName];
	var comboDivObj = control.comboDiv;
    var tagObject = control.tagObject;
	var options= tagObject.options;
	var option = null;
	var optCnt = options.length;
	var i = 0;
	
	for(i = 0; i < optCnt; i++, option = null){
		option = options[i];
 	    innerHTML += "<a onmousedown='sel(event);'>" + option.text + "</a>\r\n";
	}
	
	comboDivObj.innerHTML = innerHTML;
	
	if( tagObject.selectedIndex >= 0 )
		selectItem(tagObject.selectedIndex);
	else
		selectItem(0);
	
	options = null; tagObject = null; comboDivObj = null;
	control = null; controlName = null;
 };

/**
 * @name ComboBox#sel
 * @event
 * @description	미결
 */
function sel(e){
	e = e || window.event;	
	
	var el = e.srcElement ? e.srcElement : e.target;
	
	selectItem(el);
	
	var controlName = self["_$_ComboEdit_"].getAttribute("target");
	var control = controls[controlName];
	var options = control.tagObject.options;
	var option = null;
	var optCnt = options.length;
	var i = 0;
	
	for(i = 0; i < optCnt; i++, option = null){
		option = options[i];
		
		if( option.text == el.innerText ){
			//control.tagObject.selectedIndex = i;
			control.setIndex(i);
			break;
		}
	}
	
	options = null; control = null; 
	controlName = null; el = null;
	
	return true;
};

/**
 *	@description	미결
 *	@param			{object}	varItem
 *	@return			{undefined}
 *	@example		미결
 */
function selectItem(varItem){
	var controlName = self["_$_ComboEdit_"].getAttribute("target");
	var control = null;
	var comboDivObj = null;
	
	if( controlName != null && controlName.length > 0 ){
		control = controls[controlName];
		comboDivObj = control.comboDiv;
	}
	else{
		comboBoxName = null;
		return;
	}
	
	var nodes = comboDivObj.getElementsByTagName("A");
	var node = null;
	var selectedItemNum = control.selectedItemNum;
	var item = null;
	var index = -1;
    
	if( typeof varItem == "number" ){
		index = varItem;
		item = nodes[index];
	}
	else if( typeof varItem == "object" ){
		if( typeof varItem.tagName != "undefined" && varItem.tagName.toUpperCase() == "A" ){
			item = varItem;
			
			var nodeCnt = nodes.length;
			var i = 0;
			
			for(i = 0; i < nodeCnt; i++, node = null){
				node = nodes[i];
				
				if( item == node ){
					index = i;
					node = null;
					break;
				}
			}
		}
	}
	
    if( typeof item == "undefined" ) return;
    
    //index
	if( selectedItemNum != index ){
		if( selectedItemNum >= 0 )
			nodes[selectedItemNum].className = "";
		
		item.className = "blueback";
	}
	
	control.selectedItemNum = index; 
	
	item.scrollIntoView(false);
	
	item = null; nodes = null;
	comboDivObj = null; control = null; controlName = null;
};

/**
 * @name ComboBox#comboEdit_onkeyup
 * @event
 * @return	{boolean}
 * @description	미결
 */
function comboEdit_onkeyup(e){
	e = e || window.event;
	
	var keyCode = e.which || e.keyCode;
	if( keyCode == 38 || keyCode == 40 ) return true;
	
	var ua = navigator.userAgent.toLowerCase(); 
	var isSafari = (ua.indexOf('safari') != -1 && ua.indexOf('chrome') == -1);
	if( isSafari && keyCode == 229 ){
		sel(e);
		ua = null;
		return true;
	}
	
	var comboEdit = self["_$_ComboEdit_"];
	var controlName = comboEdit.getAttribute("target");
	var control = null;
	var comboDivObj = null;
	var selectedItemNum = -1;
	
	if( controlName != null && controlName.length > 0 ){
		control = controls[controlName];
		comboDivObj = controls[controlName].comboDiv;
		selectedItemNum = control.selectedItemNum;
	}
	else{
		controlName = null; comboEdit = null; ua = null;
		return false;
	}
	
	var nodes = comboDivObj.getElementsByTagName("A");
	var node = null;
	var inHtml = null;
	var comboVal = comboEdit.value.toLowerCase();
	var isFirst = true;
	var nodeCount = nodes.length;
	var i = 0;
	
	for(i = 0; i < nodeCount; i++, node = null, inHtml = null){
		node = nodes[i];
		inHtml = node.innerHTML.toLowerCase();
		node.className = "";
		
		if( inHtml.indexOf(comboVal) >= 0 ){
			node.style.display = 'block';
			
			if( isFirst ){
				node.className = "blueback";
				control.selectedItemNum = i;
			}
			
			isFirst = false;
		}
		else{
			node.style.display = 'none';
		}
	}
	
	nodes = null; comboDivObj = null; control = null;
	controlName = null; comboEdit = null; ua = null;
	
	return true;
};

/**
 * @name ComboBox#comboEdit_onkeydown
 * @event
 * @return	{boolean}
 * @description	미결
 */
function comboEdit_onkeydown(e){
	e = e || window.event;
	
	var keyCode = e.which || e.keyCode;
	var comboEdit = self["_$_ComboEdit_"];
	var controlName = comboEdit.getAttribute("target");
	var control = controls[controlName];
	var comboDiv = control.comboDiv;
	var nodes = comboDiv.getElementsByTagName("A");
	var node = null;
	var selectedItemNum = control.selectedItemNum;
	var i = 0;
	
	if( keyCode == 9 ){
		var shiftKeyPressed = getShiftKeyPressed(e);
		
		setTimeout(function(){
			(function(pComboDiv, pControlName, pShiftKeyPressed){
				if( pComboDiv.style.display === "block" )
					hidecomboDiv();
				if( pShiftKeyPressed )
					setFocusToFormerControl(pControlName);
				else
					setFocusToNextControl(pControlName);
	 		})(comboDiv, controlName, shiftKeyPressed);
		}, 0);
		
		stopEvent(e);
		
		nodes = null; control = null; comboEdit = null;
//		comboDiv = null; controlName = null;
		
		return false;
	}
	
	if( keyCode == 13 ){
		if( selectedItemNum >= 0 ){
			//nodes[selectedItemNum].click();   // 사파리 에러 
			var text = nodes[selectedItemNum].innerHTML
			var options = control.tagObject.options;
			var option = null;
			var optionCount = options.length;
			
			for(i = 0; i < optionCount; i++, option = null){
				option = options[i];
				
				if( option.text == text ){
					control.setIndex(i);
					option = null;
					break;
				}
			}
			
			options = null; text = null;
		}
		
		control.tagObject.disabled = false;
		
		setTimeout(function(){
			(function(pComboDiv, pControlName){
				if( pComboDiv.style.display === "block" )
					hidecomboDiv();
				setFocusToNextControl(pControlName);
			})(comboDiv, controlName);
		}, 0);
		
		stopEvent(e);
		
		nodes = null; control = null; comboEdit = null;
//		comboDiv = null; controlName = null; 
		
		return false;
	}
	else{
		// 콘트롤 판넬 보이기 
		if( comboDiv.style.display === "none" ){
//			// 다른 Edit Combo가 포커스된상태에서  또다른 Edit Combo 선택시, 포커스가 변경안되고 comboEdit의 위치만 이동한다.
//			// 선택시 타겟이 다르면 리스트를 새로운 콘트롤로 이동시킨다 .
//			if( comboEdit.getAttribute("target") !== comboDiv.getAttribute("target") )
//				fillOptions();
			
			setcomboDiv(control);
			
			if( keyCode == 32 ){
				stopEvent(e);
				
				nodes = null; comboDiv = null; control = null;
				controlName = null; comboEdit = null;
				
				return false;
			}
		}
	}
	
	if( keyCode != 38 && keyCode != 40 ){
		nodes = null; comboDiv = null; control = null;
		controlName = null; comboEdit = null;
		
		return true;
	}
	
	// Move Selection Up
	var nodeCount = nodes.length;
	var newIndex = -1;
	
	if( keyCode == 38 ){		// UP
		for(i = selectedItemNum - 1; i >= 0; i--, node = null){
			node = nodes[i];
			
			if( node.style.display == '' || node.style.display == 'block' ){
				newIndex = i;
				node = null;
				break;
			}
		}
	}
	else if( keyCode == 40 ){	// DOWN
		for(i = selectedItemNum + 1; i < nodeCount; i++, node = null){
			node = nodes[i];
			
			if( node.style.display == '' || node.style.display == 'block' ){
				newIndex = i;
				node = null;
				break;
			}
		}
	}
	
	if( newIndex >= 0 ) selectItem(newIndex);
	
	nodes = null; comboDiv = null; control = null;
	controlName = null; comboEdit = null;
	
	return true;
};

/**
 * @name ComboBox#comboEdit_onmouseup
 * @event
 * @return	{boolean}
 * @description	미결
 */
function comboEdit_onmouseup(e){
	var comboEdit = self["_$_ComboEdit_"];
	var controlName = comboEdit.getAttribute("target");
	var control = null;
	var comboDiv = null;
	
	if( controlName != null && controlName.length > 0 ){
		control = controls[controlName];
		comboDiv = control.comboDiv;
	}
	else{
		controlName = null; comboEdit = null;
		return;
	}
	
	// 콘트롤 판넬 보이기 
	if( comboDiv.style.display !== "block" ){
		setcomboDiv(control);
	}
	
	stopEvent(e);
	
	comboDiv = null; control = null;
	controlName = null; comboEdit = null;
	
	return true;
};

/**
 * @name ComboBox#comboCover_MouseOver
 * @event
 * @return	{boolean}
 * @description	미결
 */
function comboCover_MouseOver(e){
	// 아래 콤보 동작을 막음
	stopEvent(e);
	
	return false;
};

/**
 * @name ComboBox#comboCover_MouseOut_1
 * @event
 * @return	{boolean}
 * @description	미결
 */
function comboCover_MouseOut(e){
	e = window.event || e;
	
	hideComboCover();
	
	stopEvent(e);
	
	return true;
};

function comboCover_onmouseup(e){
	var comboCover = self["_$_ComboCover_"];
	var comboEdit = self["_$_ComboEdit_"];
	var controlName = comboCover.getAttribute("target");
	var control = controls[controlName];
	
	if( control.enabled || !control.tagObject.disabled ){
		hideComboCover();
		
		// 다른 Edit Combo가 포커스된상태에서  또다른 Edit Combo 선택시, 포커스가 변경안되고 comboEdit의 위치만 이동한다.
		// 선택시 타겟이 다르면 리스트를 새로운 콘트롤로 이동시킨다. 
		setComboEditControl(control);
		
		var selectedItemNum = control.selectedItemNum;
		var nodes = control.comboDiv.getElementsByTagName("A");
		var node = null; var inHtml = null;
		var comboVal = comboEdit.value.toLowerCase();
		var nodeCount = nodes.length;
		var i = 0;
		
		for(i = 0; i < nodeCount; i++){
			node = nodes[i];
			inHtml = node.innerHTML.toLowerCase();
			node.className = "";
			
			if( inHtml.indexOf(comboVal) >= 0 ){
				node.style.display = 'block';
				
				if( i == selectedItemNum )
					node.className = "blueback";
			}
			else{
				node.style.display = 'none';
			}
			
			node = null; inHtml = null;
		}
		
		setcomboDiv(control);
		selectItem(selectedItemNum);
		
		comboEdit.focus();
		
		nodes = null;
	}
	
	stopEvent(e);
	
	control = null; controlName = null;
	comboEdit = null; comboCover = null;
	
	return true;
};

/**
 * @description	미결
 * @return		{void}
 * @example		미결
 */
function makeComboEditControl(){
	if( typeof self["_$_ComboEdit_"] != "undefined" )
		return;
	
	var oChild = null;
	
	//
	if( BrowserDetect.browser == "Explorer"
		&& !isNaN(parseFloat(BrowserDetect.version))
		&& parseFloat(BrowserDetect.version) < 9
	){
		oChild = document.createElement(
					"<input  id='_$_ComboEdit_' name='_$_ComboEdit_' type='text' class='comboEdit'"
					+ "style='position:absolute; left:-10000px; width: 10px; height:16px; display:none; border:none; padding-left:4px; padding-top:2px;'/>"
		);
	}
	else{
		oChild = document.createElement("input");
		oChild.id					= "_$_ComboEdit_";
		oChild.name					= "_$_ComboEdit_";
		oChild.className			= "comboEdit";
		oChild.style.display		= "none";
		oChild.style.position		= "absolute";
		oChild.style.left			= "-10000px";
		oChild.style.width			= "10px";
		oChild.style.height			= "16px";
		oChild.style.border			= "none";
		oChild.style.paddingLeft	= "4px";
//		oChild.style.paddingTop		= "2px";
		oChild.style.marginTop		= "2px";
		oChild.style.marginBottom	= "2px";
	}
	
	setEventHandler(oChild, "keydown", comboEdit_onkeydown);
	setEventHandler(oChild, "blur",    comboEdit_onBlur);
	setEventHandler(oChild, "mouseup", comboEdit_onmouseup);
	setEventHandler(oChild, "keyup",   comboEdit_onkeyup);
	
	/*
	setEventHandler(oChild, "focus", comboEdit_onFocus);
	setEventHandler(oChild, "mouseout",  comboEdit_MouseOut);
	*/
	
	oChild.setAttribute("target", "");
	
	self["_$_ComboEdit_"] = oChild;
	
	//
	if( typeof self["_$_ComboCover_"] != "undefined" )
		return;
	
	if( BrowserDetect.browser == "Explorer"
		&& !isNaN(parseFloat(BrowserDetect.version))
		&& parseFloat(BrowserDetect.version) < 9
	){
		oChild = document.createElement(
					"<div id='_$_ComboCover_' name='_$_ComboCover_' class='comboCover' "
					+ "style='position:absolute; left:-10000px; width: 10px;height:20px; display:none;"
					+ "background_color: black; opacity : 0; filter: alpha(opacity=0); -moz-opacity:0; -khtml-opacity: 0;'/></div>"
		);
	}
	else{
		oChild = document.createElement("div");
		oChild.id						= "_$_ComboCover_";
		oChild.name						= "_$_ComboCover_";
		oChild.className				= "comboCover";
		oChild.style.display			= "none";
		oChild.style.position			= "absolute";
		oChild.style.left				= "-10000px";
		oChild.style.width				= "10px";
		oChild.style.height				= "20px";
		oChild.style.backgroundColor	= "black";
		oChild.style.opacity			= "0";
		oChild.style.filter				= "alpha(opacity=0)";
		oChild.style.MozOpacity			= "0";
		oChild.style.KhtmlOpacity		= "0";
	}
	
	setEventHandler(oChild, "mouseover", comboCover_MouseOver); 
	setEventHandler(oChild, "mouseout",  comboCover_MouseOut);
	setEventHandler(oChild, "mouseup",   comboCover_onmouseup);
	
	self["_$_ComboCover_"] = oChild;
	
	oChild = null;
	
	return;
};

/**
 * @description	미결
 * @param	{object}	control
 * @return	{void}
 * @example	미결
 */
function setComboEditControl(control){
	var comboEdit = self["_$_ComboEdit_"];
	var currentTargetName = comboEdit.getAttribute("target");
	
	if( control.controlName == currentTargetName ){
		if( comboEdit.style.display == "block" )
			return;
	}
	else{
		if( currentTargetName != null && currentTargetName.length > 0 )
			controls[currentTargetName].tagObject.disabled = false;    	
	}
	
	var tagObject = control.tagObject;
	tagObject.disabled = true;
    
	if( tagObject.selectedIndex >= 0 )
		comboEdit.value = tagObject.options[tagObject.selectedIndex].text;
	else
		comboEdit.value = "";
	
	comboEdit.style.left		= (tagObject.offsetLeft + 1) + "px"; 
	comboEdit.style.top			= (tagObject.offsetTop + 1) + "px";
	comboEdit.style.width		= (tagObject.offsetWidth - 24) + "px";
//	comboEdit.style.height		= (tagObject.offsetHeight - 5) + "px";
	comboEdit.style.height		= (tagObject.offsetHeight - 6) + "px";
	comboEdit.style.fontFamily	= getStyleProp(tagObject, "font-family");
	comboEdit.style.fontSize	= getStyleProp(tagObject, "font-size");
	comboEdit.style.display		= "block";
	comboEdit.setAttribute("target", control.controlName);
	
	var parentNode = tagObject.parentNode;
	parentNode.appendChild(comboEdit);
	
	parentNode = null; tagObject = null;
	currentTargetName = null; comboEdit = null;
	
	return;
};

/**
 * @description	미결
 * @param	{object}	control
 * @return	{void}
 * @example	미결
 */
function setcomboDiv(control){
	var comboDiv = control.comboDiv;
	var tagObject = control.tagObject;
	
//	if( comboDiv.parentNode != document.body )
//		document.body.appendChild(comboDiv);
	
	document.body.appendChild(comboDiv);
	
	comboDiv.setAttribute("target", control.controlName);
	comboDiv.style.left			= (getOffsetLeft(tagObject) + 1) + "px";  
	comboDiv.style.top			= (getOffsetTop(tagObject) + tagObject.offsetHeight + 1) + "px";
	comboDiv.style.width		= (tagObject.offsetWidth - 4) + "px";
	comboDiv.style.height		= "240px";
	comboDiv.style.fontFamily	= getStyleProp(tagObject, "font-family");
	comboDiv.style.fontSize		= getStyleProp(tagObject, "font-size");
	comboDiv.style.zIndex		= 9990;
	comboDiv.style.display		= "block";
	
	tagObject = null; comboDiv = null;
	
	return;
};

/**
 * @description	미결
 * @return	{void}
 * @example	미결
 */
function hidecomboDiv(){
	var comboEdit = self["_$_ComboEdit_"];
	var controlName = comboEdit.getAttribute("target");
	
	comboEdit.style.left = "-10000px";
	comboEdit.style.display = "none";
	
	if( typeof controlName == "string" && controlName.length > 0){
		var comboBox = controls[controlName];
		var comboDiv = comboBox.comboDiv;
		
		comboDiv.style.left		= "-10000px";
		comboDiv.style.display	= "none";
		comboDiv.setAttribute("target", "");
		
		comboDiv.parentNode.removeChild(comboDiv);
		
		comboDiv = null;
		comboBox = null;
	}
	
	targetControlName = null; comboEdit = null;
	
	return;
};

/**
 * @description	미결
 * @param	{object}	control
 * @return	{void}
 * @example	미결
 */
function setComboCover(control){
	var comboCover = self["_$_ComboCover_"];
	var currentTargetName = comboCover.getAttribute("target");
	
	if( control.controlName == currentTargetName ){
		if( comboCover.style.display == "block" )
			return;
	}
	else{
		// 직전 콘트롤의 풀어준다 사파리등 상관없이 모두 가능
		if( currentTargetName != null ){
			var control = controls[currentTargetName];
			control.tagObject.disabled = false;
			control = null;
		}
	}
	
	var tagObject = control.tagObject;
	tagObject.disabled = true;
	
	comboCover.style.left		= (tagObject.offsetLeft - 1) + "px";  // ??? 
	comboCover.style.top		= (tagObject.offsetTop - 1) + "px";
	comboCover.style.width		= (tagObject.offsetWidth + 2) + "px";
	comboCover.style.height		= (tagObject.offsetHeight + 2) + "px";
	comboCover.style.display	= "block";
	comboCover.setAttribute("target", control.controlName);
	
	var parentNode = tagObject.parentNode;
	parentNode.appendChild(comboCover);
	
	parentNode = null;
	tagObject = null;
	currentTargetName = null;
	comboCover = null;
	
	return;
};

/**
 * @description	미결
 * @return	{void}
 * @example	미결
 */
function hideComboCover(){
	var comboCover = self["_$_ComboCover_"];
	comboCover.style.left = "-10000px";
	comboCover.style.display = "none";
	
	var controlName = comboCover.getAttribute("target");
	var control = controls[controlName];
	var tagObject = control.tagObject;
	tagObject.disabled = false;
	
	tagObject = null; control = null;
	controlName = null; comboCover = null;
	
	return;
};
/*
 *	Editable ComboBox 
 */



/*
 *	Dataset Binding
 */
ComboBox.prototype._updateLists = function(pLists){
	// functionname : [ComboBox._updateLists]
	
	var listLength = 0;
	
	//예외처리
	if( !(pLists instanceof Array) ) return;
	if( (listLength = pLists.length) == 0) return;
	
	var optItem = null;
	var optObj = null;
	var optStr = "";
	var i = 0;
	
	for(i = 0; i < listLength; i++){
		optItem = pLists[i];
		
		optObj = document.createElement("option");
		optObj.value = optItem.value;
		optObj.text = optItem.text;
		this.tagObject.options.add(optObj);
		
		optStr += "<a onmousedown='sel(event);'>" + optItem.text + "</a>\r\n";
		
		optObj = null;
		optItem = null;
	}
	
	this.comboDiv.innerHTML = optStr;
	
	while(pLists.length > 0){
		optItem = pLists.pop();
		optItem = null;
	}
	
	pLists = null;
	
	return;
};/**
 * @class ListBox를 만들어주는 클래스
 * @constructor Listbox
 * @param controlId
 *            {String} Control의 id를 입니다.
 * @param controlName
 *            {String} Control의 name을 입니다.
 * @param tagObject
 *            {Object} 태그객체 입니다.
 * @example var wControl = controls["ListBox_1"] if(wContorl.errMsg !=null){
 *          //객체 생성에 실패하였습니다. 에러처리 코드를 입력해주세요. } //후속코드생략..
 */
function ListBox(controlId, controlName, tagObject){
	// 상속 선언부
	this.base = ControlBase;						//부모클래스 지정
	this.base(controlId, controlName, tagObject);	//부모클래스 생성자호출
	
	// 상수 선언부
	
	// 속성 선언부
	this.value = "";
	this.text = "";
	this.index = -1;
	this.reservedValue = "";
	this.reservedText = "";
	
	this.isKeyControl  = (tagObject.getAttribute("iskeycontrol")  == "true");
	this.isFillControl = (tagObject.getAttribute("isfillcontrol")  == "true");
	this.isClearControl = (tagObject.getAttribute("isclearcontrol")  == "true");
	this.isSeqClearControl = (tagObject.getAttribute("isseqclearcontrol")  == "true");
	this.checkType = parseInt(tagObject.getAttribute("checktype"));
	this.stateClear = false;
	
	// 자체 이벤트 선언부 
    this.hasChangeEvent = false;	this.fncChangeEvent = null;
    this.hasFocusEvent = false;		this.fncFocusEvent = null;
    this.hasBlurEvent = false;		this.fncBlurEvent = null;
    this.hasClearEvent = false;		this.fncClearEvent = null;
    this.hasAddItemEvent = false;	this.fncAddItemEvent = null;
    
	this.hasChangeEvent = (typeof self[this.controlId + "_onchange"] != "undefined");
	if( this.hasChangeEvent ){
		this.fncChangeEvent = new Function("return function(){ return " + this.controlId + "_onchange(); }")();
	}
	this.hasFocusEvent = (typeof self[this.controlId + "_onfocus"] != "undefined");
	if( this.hasFocusEvent ){
		this.fncFocusEvent = new Function("return function(){ return " + this.controlId + "_onfocus(); }")();
	}
	this.hasBlurEvent = (typeof self[this.controlId + "_onblur"] != "undefined");
	if( this.hasBlurEvent ){
		this.fncBlurEvent = new Function("return function(){ return " + this.controlId + "_onblur(); }")();
	}
	this.hasClearEvent = (typeof self[this.controlId + "_onclear"] != "undefined");
    if( this.hasClearEvent ){
    	this.fncClearEvent = new Function("return function(){ return " + this.controlId + "_onclear(); }")();
    }
	this.hasAddItemEvent = (typeof self[this.controlId + "_onadditem"] != "undefined");
	if( this.hasAddItemEvent ){
		this.fncAddItemEvent = new Function("return function(){ return " + this.controlId + "_onadditem(); }")();
	}
	
	// 이벤트 선언부
	setEventHandler(this.tagObject, "keydown", list_KeyDown);
	setEventHandler(this.tagObject, "change", list_Change);
	setEventHandler(this.tagObject, "focus", list_Focus);
	setEventHandler(this.tagObject, "blur", list_Blur);
};

ListBox.prototype = new ControlBase();	// 의미없음 코딩 편의기능을 활용하기 위함

/**
 * @description 태그객체의 ID가 ListBox인것을 찾습니다.
 * @param em
 *            {Object} ID를 찾을 element 입니다.
 * @return 찾은ID를 반환합니다, 에러발생시 undefined를 반환합니다.
 */
function searchControl_ListBox(em){
	var pEm = em;
	var image = pEm.getAttribute("image");
	var className = null;
	var wReturn = null;
	
//	while (pEm.parentNode && !pEm.className.startsWith("ListBox")) 
//		pEm = pEm.parentNode;
//	if( pEm.className.startsWith("ListBox") ) 
//		wReturn = getControlById(pEm.id);
	
	while(pEm.parentNode && pEm.tagName != "body" && image !== "ListBox"){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}
	
	if( pEm.getAttribute("image") === "ListBox" ){
		wReturn = getControlById(pEm.id);
	}
	else{
		pEm = null;
		pEm = em;
		
		while(pEm.parentNode && !pEm.className.startsWith("ListBox")) 
			pEm = pEm.parentNode;
		
		if( pEm.className.startsWith("ListBox") )
			wReturn = getControlById(pEm.id);
	}
	
	image = null;
	pEm = null;
	
	return wReturn;
};

/* 포커스 주기*/
/**
 * @description ListBox포커스를 지정합니다.
 * @return {Boolean} 선택되었으면 true를 반환합니다<br>
 *         에러발생시 undefined를 반환합니다.
 * @example controls["ListBox_1"].focus();
 */
ListBox.prototype.focus = function(){
	// functionname : [ListBox.focus]
	
	var wReturn = true;
	
	try{
		this.tagObject.focus();
	}
	catch(e){
		wReturn = false;
	}
	
	return wReturn;
};
/**
 * @description ListBox안의 내용을 추가합니다.
 * @param value
 *            {Object} option의 속값으로 채워질 값
 * @returns {Boolean}
 * @example controls["ListBox"].setValue(value);
 */
ListBox.prototype.setValue = function(value){
	// functionname : [ListBox.setValue]
	
	if( parseInt(1 * value) == 0 && !this.haveZeroValue() )
		value = "";

	var oldValue = this.value;
	var oldText = this.text;
	var oldIndex = this.index;

	var selectedIndex = this.tagObject.selectedIndex;
	var controlvalue = (selectedIndex == -1 ? "" : this.tagObject.options[selectedIndex].value + "");

	if( "" + oldValue == "" + value && "" + controlvalue == "" + value )
		return true;

	var wOptions = this.tagObject.options;
	var found = false;
	
	this.stateClear = true;
	for(var i = 0; i < wOptions.length; i++){
		if( wOptions[i].value == value ){
			wOptions[i].selected = true;
			this.value = value;
			this.text = wOptions[i].text;
			this.index = i;
			found = true;
			break;
		}
	}
	this.stateClear = false;
	
	if( !found ){
		this.reservedValue = value;
		this.value = "";
		this.text = "";
		this.index = -1;
		this.tagObject.selectedIndex = -1;
		
		if( !this.passEvent && typeof(ControlBase.prototype._UpdateDataset) != "undefined" ){
			var datasetId = null;
			for(var key in this.dataBinds){
				if( typeof this.dataBinds[key] == "function" ) continue;
				if( typeof BindInfo != "undefined" && this.dataBinds[key] instanceof BindInfo ){
					datasetId = this.dataBinds[key].datasetId;
					break;
				}
			}
			if( datasetId != null ){
				dataSets[datasetId].instantUpdateControl = false;
				this._UpdateDataset();
				dataSets[datasetId].instantUpdateControl = true;
			}
		}
		
		return false;
	}
	
	if( !this.checkError() ){
		this.value = oldValue;
		this.text = oldText;
		this.index = oldIndex;
		this.tagObject.value = oldValue;
		if( !this.passEvent && typeof(ControlBase.prototype._UpdateDataset) != "undefined" ) this._UpdateDataset();
		this.tagObject.focus();
		return false;
	}
	
	// dataset 갱신 기능 
	if( typeof(ControlBase.prototype._UpdateDataset) != "undefined" )
		this._UpdateDataset();
	
	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if( this.hasChangeEvent ){
			var result = this.fncChangeEvent();
			if( result === false ){
				this.value = oldValue;
				this.text = oldText;
				this.index = oldIndex;
				this.tagObject.value = oldValue;
				this.tagObject.focus();
				return false;
			}
		}
	}
	
	// 관련객체 프로퍼티 채우기
	// this.setLinkedProperties(value, 2);
	/*
	// 데이터 가저오기
	if (this.value != -1){
	    if (this.isKeyControl){
	        if (this.isFillControl){
	        	mustFillScreenAfterLoad = true;
	        }
	        objectManager.fillkeyFieldValue = this.value;
	     	objectManager.loadData();
	    }
	    
	    // 데이터 채우기
	    if (!this.isKeyControl && this.isFillControl){
	    	objectManager.fillData();
	    }
	}
	*/
	
	return true;
};

/**
 * @description	미결
 * @param		{Object}	value
 * @returns		{Boolean}
 * @example 	미결
 */
ListBox.prototype.setValueToDefault = function(){
	// functionname : [ListBox.setValueToDefault]
	
	var wOptions = this.tagObject.options;
	
	if( wOptions.length == 0 )
		return true;
	
	if( this.defaultValue.length == 0 ){
		this.setValue("");
		return false;
	}
	
	var value = this.defaultValue;
	
	if( parseInt(1 * value) == 0 && !this.haveZeroValue() ){
		this.setValue("");
		return false;
	}
	
	return this.setValue(this.defaultValue);
};

/**
 * @description ListBox의 겉값으로 사용될 문자를 지정된 문자로 설정합니다.
 * @param text
 *            {String} 겉값으로 보여질 문자.
 * @return {Boolean} 문자열 설정 성공시 true,실패시 false를 반환 합니다.
 * @example controls["ListBox_1"].setText(text);
 */
ListBox.prototype.setText = function(text){
	// functionname : [ListBox.setText]
	
	var oldValue = this.value;
	var oldText = this.text;
	var oldIndex = this.index;
	
	if( oldText == text )
		return true;
	
	var wOptions = this.tagObject.options;
	var found = false;
	
	for(var i = 0; i < wOptions.length; i++){
		if( wOptions[i].text == text ){
			wOptions[i].selected = true;
			this.text = (i == 0 ? "" : text);
			this.value = wOptions[i].value;
			this.index = i;
			found = true;
			break;
		}
	}
	
	if( !found ){
		this.reservedText = text;
		this.value = "";
		this.text = "";
		this.index = -1;
		this.tagObject.selectedIndex = -1;
		
		if( !this.passEvent && typeof(ControlBase.prototype._UpdateDataset) != "undefined" ){
			var datasetId = null;
			for(var key in this.dataBinds){
				if( typeof this.dataBinds[key] == "function" ) continue;
				if( typeof BindInfo != "undefined" && this.dataBinds[key] instanceof BindInfo ){
					datasetId = this.dataBinds[key].datasetId;
					break;
				}
			}
			if( datasetId != null ){
				dataSets[datasetId].instantUpdateControl = false;
				this._UpdateDataset();
				dataSets[datasetId].instantUpdateControl = true;
			}
		}
		
		return false;
	}
	
	if( !this.checkError() ){
		this.value = oldValue;
		this.text = oldText;
		this.index = oldIndex;
		this.tagObject.value = oldValue;
		if( !this.passEvent && typeof(ControlBase.prototype._UpdateDataset) != "undefined" ) this._UpdateDataset();
		this.tagObject.focus();
		return false;
	}

	// dataset 갱신 기능 
	if (typeof(ControlBase.prototype._UpdateDataset) != "undefined"){
		this._UpdateDataset();
	}
	
	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if( this.hasChangeEvent ){
			var result = this.fncChangeEvent();
			if( result === false ){
				this.value = oldValue;
				this.text = oldText;
				this.index = oldIndex;
				this.tagObject.value = oldValue;
				if( !this.passEvent && typeof(ControlBase.prototype._UpdateDataset) != "undefined" ) this._UpdateDataset();
				this.tagObject.focus();
				return false;
			}
		}
	}
	
	// 관련객체 프로퍼티 채우기
	// this.setLinkedProperties(text, 1);
	/*
	// 데이터 가저오기
	if (this.isKeyControl){
	    if (this.isFillControl){
	    	mustFillScreenAfterLoad = true;
	    }
	    objectManager.fillkeyFieldValue = this.value;
	 	objectManager.loadData();
	}
	
	// 데이터 채우기
	if (!this.isKeyControl && this.isFillControl){
		objectManager.fillData();
	}
	*/
	
	return true;
};
/**
 * @description ListBox에 option을 추가합니다.
 * @param pText
 *            {String} 겉으로 보여질 문자열을 받아옵니다.
 * @param pData
 *            {Integer} 속값으로 채워질 값을 받아옵니다.
 * @return 반환값없음, 에러발생시 undefined를 반환합니다.
 * @example controls["ListBox"].addItem("text",data);
 */
ListBox.prototype.addItem = function(pText, pData){
	// functionname : [ListBox.addItem]
	
	var opt = document.createElement("option");
	opt.value = pData;
	opt.text = pText;
	
	this.tagObject.options.add(opt);
	
	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if( this.hasAddItemEvent ){
			this.fncAddItemEvent();
		}
	}
};
/**
 * @description	미결
 * @param		{String}	pText
 * @param		{Objert}	pData
 * @param		{Object}	pIndex
 * @return		{undefined}
 * @example		미결
 */
ListBox.prototype.insertItem = function(pText, pData, pIndex){
	// functionname : [ComboBox.insertItem]

    var opt = document.createElement("option");
    opt.value = pData;
    opt.text = pText;
    
    //인덱스가 0보다 큰 자연수가 아니라면 맨 끝에 항목 추가
    var isNumRegx = /^\d+$/;
    if( !isNumRegx.test(pIndex + "") ){
    	this.tagObject.options.add(opt);    	
    }
    else{
    	this.tagObject.insertBefore(opt, this.tagObject.childNodes[pIndex]);
    }
    
	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if( this.hasAddItemEvent ){
			this.fncAddItemEvent();
		}
	}
};

/**
 * @description 리스트에있는 해당목록을 지웁니다.
 * @param pData
 *            {Object} option에서 지워질 값입니다.
 * @return 반환값 없음, 에러발생시 undefined를 반환합니다
 * @example controls["ListBox"].removeItem(Data);
 */
ListBox.prototype.removeItem = function(pData){                  
	// functionname : [ListBox.removeItem]
	
	var wOptions =  this.tagObject.options;

	for(var i = wOptions.length - 1; i >= 0; i--){
		if( ("" + pData).length > 0 && wOptions[i].value == pData ){
			wOptions.remove(i);
			break;
		}
	}
};

/**
 * @description	미결
 * @param		{Object}	pData
 * @param		{Object}	objectId
 * @return		{Object}
 * @example		미결
 */
ListBox.prototype.textOfData = function(pData, objectId){
	// functionname : [ListBox.textOfData]
	
	var wReturn = "";
	var i = 0;
	
	/*
	var checkEvent = false;
	try {
		if (eval("getCasheKey_" + this.controlId)) checkEvent = true;
	} catch(e){}
	
	if (checkEvent){
		var recordsetKey = "fillList_" + this.controlId;
	    var casheKey = eval("getCasheKey_" + this.controlId + "(objectId);");
	    var wArrKey = casheKey.split(":");
	    
	    // SQL번호만 있는 경우 콜론을 붙여준다
	    if (casheKey.indexOf(":") < 0) casheKey += ":";
        
	    var recordset = getRecordsetByKey(recordsetKey);
	    if (recordset.casheKey != casheKey){
	        var dataCashe = dataCashes[casheKey];
	        
	        if (dataCashe == undefined){
	        	// casheMode가 설정되면 리스트는 갱신안되고 캐시에만 저장된다
	        	recordset.casheMode = true;
	    		recordset.sqlnum = wArrKey[0];
                
	        	for (var i=1; i < wArrKey.length; i++){
		    		recordset.setParameter("param" + i, wArrKey[i]);
	        	}
	        	// syncMode로 호출 된다
	    		recordset.open();
	    		// 호출후 recordsetKey + "_OnReceive"가 수행된다
	    		
	    		recordset.casheMode = false; 
	    		dataCashe = dataCashes[casheKey];
	        }
	        else{
	        	for (i = 0; i < dataCashe.rowCount; i++){
	        		if (dataCashe.fields[0].datas[i] == pData){
	        			wReturn = dataCashe.fields[1].datas[i];
	        			break;
	        		}
	        	}
	        	
	        	return wReturn; 	        	
	        }
	    }
	}
	*/
	
	var wOptions = this.tagObject.options;
    
	for(i = wOptions.length - 1; i >= 0; i--){
		if( ("" + pData).length > 0 && wOptions[i].value == pData ){
			wReturn = wOptions[i].text;
			break;
		}
	}
	
	return wReturn;
};
/**
 * @description 리스트의 option의 갯수를 반환합니다.
 * @returns {Integer} 리스트의 갯수를 반환합니다.
 * @example controls["ListBox_1"].listCount();
 */
ListBox.prototype.listCount = function(){
	// functionname : [ListBox.listCount]
	
	return this.tagObject.options.length;
};
/**
 * @description 리스트박스의 내용을 모두 지웁니다.
 * @return {boolean} 성공시true를 반환합니다.
 * @example controls["ListBox_1"].clear();
 */
ListBox.prototype.clear = function(){
	// functionname : [ListBox.clear]

	var wOptions =  this.tagObject.options;
	
	this.stateClear = true;
	for(var i = wOptions.length - 1 ; i >= 0; i--){
		wOptions.remove(i);
	}
	this.stateClear = false;
	
	this.value= "";
	this.text= "";
	this.index = -1;

	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if( this.hasClearEvent ){
			var result = this.fncClearEvent();
			if( typeof(result) == "boolean" )
				return result;
		}
	}
	
	return true;
};
/**
 * @description 가져오기로 리스트박스의 내용을 채웁니다.
 * @param recordset{Object}
 * @return 반환값없음
 * @example control["ListBox_1"].setList(recordset);
 */
ListBox.prototype.setLists = function(recordset){
	// functionname : [ListBox.setLists]
	
	// 화면에 없는 데이터 가저오기인 경우
	if( recordset.casheMode ) return;
	
	this.clear();
	
	if( recordset.fields.length == 1 ){
		while(!recordset.EOF){
			this.addItem(recordset.fields[0].value(), recordset.fields[0].value());
			recordset.moveNext();
		}
	}
	else{
		while(!recordset.EOF){
			this.addItem(recordset.fields[1].value(), recordset.fields[0].value());
			recordset.moveNext();
		}
	}
	
	recordset.close();
	
	if( this.reservedValue != "" ){
		this.value = "";
    	this.text = "";
    	this.index = -1;
		this.setValue(this.reservedValue);
	}
	else if( this.reservedText != "" ){
		this.value = "";
    	this.text = "";
    	this.index = -1;
    	this.setText(this.reservedText);
	}
	else if( this.value != "" ){
		this.setValue(this.value);
	}
	else{
		this.setValueToDefault();
	}
	
	this.reservedValue = "";
	this.reservedText = "";
		
	return true;
};

//화면로드시만 일어나는 기능으로 디폴트값선택등 추가기능은 생략
/**
 * @description	미결
 * @param		{String}	listsStr
 * @param		{String}	itemsStr
 * @return		{Boolean}
 * @example		미결
 */
ListBox.prototype.setDefaultLists = function(listsStr, itemsStr){
	// functionname : [ListBox.setDefaultLists]
	
	if( itemsStr == undefined || itemsStr.trim().length == 0 ){
		//itemsStr = listsStr;
	}
	
	var wOptions = null;
	var i = 0;
	
	if( this.listCount() > 0 ){
		wOptions = this.tagObject.options;
		
		for(var i = 0; i < wOptions.length; i++){
			listsStr += "," + wOptions[i].text;
			itemsStr += "," + wOptions[i].value;
		}
	}
	
	var arrayLists = listsStr.split(",");
	var arrayItems = itemsStr.split(",");

	this.clear();
	
	for(i = 0; i < arrayLists.length; i++){
		//if (i == 0) this.value = arrayItems[i]; // 초기값 셋팅
		this.addItem(arrayLists[i], arrayItems[i]);
	}
	
	this.setValueToDefault();

//	this.reservedValue = "-1";
//	this.reservedText = "";
	
	this.reservedValue = "";
	this.reservedText = "";
	
	return true;
};

ListBox.prototype.haveZeroValue = function(){
	// functionname : [ListBox.haveZeroValue]
	
	var wReturn = false;
	var wOptions =  this.tagObject.options;
	
	for(var i = wOptions.length - 1; i >= 0; i--){
		if( wOptions[i].value == "0" ){
			wReturn = true; break;
		}
	}
	
	return wReturn;
};

/**
 * @description	미결
 * @name		Listbox#list_Focus
 * @event
 * @returns		{Boolean}
 */
function list_Focus(e){
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_ListBox(em);
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if( this.hasFocusEvent ){
			var result = this.fncFocusEvent();
			if( typeof(result) == "boolean" )
				return result;
		}
	}
	
	return true;
};

/**
 * @description	미결
 * @name		Listbox#list_Blur
 * @event
 * @returns		{Boolean}
 */
function list_Blur(e){
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_ListBox(em);
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if( this.hasBlurEvent ){
			var result = this.fncBlurEvent();
			if( typeof(result) == "boolean" )
				return result;
		}
	}
	
	return true;
};
/**
 * @description	미결
 * @name		Listbox#list_Change
 * @event
 * @returns		{Boolean}
 */
function list_Change(e){
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_ListBox(em);
	
	if( control.stateClear )
		return false;
	
	var wOptions = (navigator.userAgent.indexOf('Firefox') >= 0 ? em.parentNode.options : em.options);
	
	var oldValue = control.value;
	var oldText = control.text;
	var oldIndex = control.index;
	var newValue = "";
    var newText = "";
    var newIndex = -1;
    var i = 0;
	
	for(i = 0; i < wOptions.length; i++){
		if( wOptions[i].selected == true ){
			newValue  = wOptions[i].value;
			newText = wOptions[i].text;
			newIndex = i;
			break;
		}
	}
	
	if( "" + oldValue == "" + newValue )
		return true;
	
	control.value = newValue;
	control.text = newText;
	control.index = newIndex;
	
	// dataset 갱신 기능 
	if( typeof(ControlBase.prototype._UpdateDataset) != "undefined" ){
		control._UpdateDataset();
	}
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if( this.hasChangeEvent ){
			var result = this.fncChangeEvent();
			if( result === false ){
				control.value = oldValue;
				control.text = oldText;
				control.index = oldIndex;
				control.tagObject.value = oldValue;
				if( typeof(ControlBase.prototype._UpdateDataset) != "undefined" ) control._UpdateDataset();
				return false;
			}
		}
	}
	
	return true;
};

/*
function list_KeyDown(){ 
	var wKeyCode = event.keyCode;
	
	if (wKeyCode == 13) event.keyCode = 9;
	return true;
};
*/

/**
 * @description	미결
 * @name		Listbox#list_KeyDown
 * @event
 * @returns		{Boolean}
 */
function list_KeyDown(e){
	//F5새로고침 방지 추가
	if( e.keyCode == 116 ){
		if( typeof e.preventDefault == "function" )
			e.preventDefault();
		else
			e.returnValue = false; // for IE
		
		return false;
	}  
	
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_ListBox(em);
	var wKeyCode = e.keyCode;
	
	if( wKeyCode == 9 ){
		if( getShiftKeyPressed(e) ){
			stopEvent(e);
			setTimeout("setFocusToFormerControl(\"" + control.controlName + "\")", 0);
			return true;
		}
		else{
			stopEvent(e);
			setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
			return true;
		}
	}
	else if( wKeyCode == 13 ){
		stopEvent(e);
		setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
		return true;
	}
	
	stopPropagation(e);
	
	// e.returnValue = true;
	
	return true;
};



/*
 *	Dataset Binding
 */
ListBox.prototype._updateLists = function(pLists){
	// functionname : [ListBox._updateLists]
	
	var listLength = 0;
	
	//예외처리
	if( !(pLists instanceof Array) ) return;
	if( (listLength = pLists.length) == 0) return;
	
	var optItem = null;
	var optObj = null;
	var optStr = "";
	var i = 0;
	
	for(i = 0; i < listLength; i++){
		optItem = pLists[i];
		optObj = document.createElement("option");
		optObj.value = optItem.value;
		optObj.text = optItem.text;
		
		this.tagObject.options.add(optObj);
		
		optObj = null;
		optItem = null;
	}
	
	optObj = null;
	optItem = null;
	
	while(pLists.length > 0){
		optItem = pLists.pop();
		optItem = null;
	}
	pLists = null;
	
	return;
};/**
 *   @autor   winnersoft korea
 *   @version 5.0
 *   @see     winnersoft.co.kr
 *   
 * @description 미결
 * 
 * @constructor
 * 
 * @param {string} 	 controlId 	 - 콘트롤 고유 아이디 (영문)
 * @param {string} 	 controlName - 콘트롤 명 (사용자 고유 언어)
 * @param {HTMLNode} tagObject   - HTML 본문중의 매칭되는 HTML DOM Node. 
 * @return {Object} - 생성된 EasySheet 개체
 * @exception 널값 예외
 * @example 미결
 * 
 */
function ListBoxW(controlId, controlName, tagObject){
	// xsl만들때 listType 타입할떄 그대로 사용.
	// 상속 선언부
	this.base = ControlBase;						//부모클래스 지정
	this.base(controlId, controlName, tagObject);	//부모클래스 생성자호출
	
	this.listType = LISTBOX_TYPE_SINGSELECT;		// 1 = singselect , 2 = multiselect , 3 = checkselect , 4 = dataselect 
    if (tagObject.className=="ListBoxA"){
    	this.listType = LISTBOX_TYPE_SINGSELECT;
    } else if (tagObject.className=="ListBoxB"){
    	this.listType = LISTBOX_TYPE_MULTISELECT;
    } else if (tagObject.className=="ListBoxC"){
    	this.listType = LISTBOX_TYPE_CHECKSELECT;
    } else if (tagObject.className=="ListBoxD"){
    	this.listType = LISTBOX_TYPE_DATASELECT;
    }
    this.listSaveType = (tagObject.getAttribute("listsavetype") == "" ? 0 : parseInt(tagObject.getAttribute("listsavetype")));
    this.numericInnerType = (tagObject.getAttribute("numericinnertype") == null || tagObject.getAttribute("numericinnertype") == "true");
    this.VALUE_WHEN_NOT_SELECTED = (this.listType == LISTBOX_TYPE_DATASELECT || !this.numericInnerType ? "" : "-1");
    
    // 자식객체생성
    this.options = new Options(tagObject, this.listType);
    
    // 속성 선언부
    this.currentIndex = 0;        // 최종적으로 선택된 항목을 가르킨다. [0 부터 시작]
    this.critIndex = 0;           // Shift의 경우 범위를 주기위해 활용. 범위의 첫 인덱스
    this._hasBlankItem = false;
    this.inputMode = DATALISTBOX_SETITEM;

    this.value = this.VALUE_WHEN_NOT_SELECTED;
    this.text = "";
    this.tag = "";
    this.subPath = "";
    this.noftp = false;
    this.nozip = false;

    this.reservedValue = this.VALUE_WHEN_NOT_SELECTED;
    this.isKeyControl  = (tagObject.getAttribute("iskeycontrol")  == "true");
    this.isFillControl = (tagObject.getAttribute("isfillcontrol")  == "true");
    this.isClearControl = (tagObject.getAttribute("isclearcontrol")  == "true");
    this.isSeqClearControl = (tagObject.getAttribute("isseqclearcontrol")  == "true");
    
    this.checkType = parseInt(tagObject.getAttribute("checktype"));
    
    // 이벤트 선언부
    this.listDIV = null;
    var  childDIV = this.listDIV = this.tagObject.getElementsByTagName("div")[0];
    setEventHandler(this.tagObject, "click",    ListBoxW_onclick);
    setEventHandler(this.tagObject, "keydown",  ListBoxW_KeyDown);
    setEventHandler(this.tagObject, "focus",    ListBoxW_Focus);
    setEventHandler(this.tagObject, "blur",     ListBoxW_Blur);
    
    // 리스트 최상단 메시지 설정, 리스트 타입별 동작 설정
    // 1. 데이터 리스트 타입은 데이터가 미리 채워진 경우는 없으며 메시지 한줄을 먼저 추가한다
    if (this.listType == LISTBOX_TYPE_DATASELECT){
    	// 더블클릭시 파일을 다운하기 위한 이벤트 설정
        setEventHandler(childDIV, "dblclick", ListBoxW_Dblclick);
        
        this.value= ""; this.text= "";
        
        // 데이터 리스트인 경우 화면의 시퀀스 1에 맞추기 위하여 기본적으로 하나의 레코드는 넣어준다
        //this.options.add(new Option("", "(선택하세요)"));
        //this._hasBlankItem = true;
        this.currentIndex = this.options.length - 1;
        this._hasBlankItem = false;
        
    // 단일항 선택타입인 경우 선택안함으로 취소할 수 있도록 헤준다    
    } else if(this.listType == LISTBOX_TYPE_SINGSELECT){
//    	if (this.options.length > 0){
//    		this.options.setItem(0, this.VALUE_WHEN_NOT_SELECTED, "(선택안함)")
//    	} else {
//            this.options.add(new Option(this.VALUE_WHEN_NOT_SELECTED, "(선택안함)"));
//    	}
    	
    // 다항선택과 체크항 선택의 경우에는 디폴트항이 필요없다. 토글해서 선택 안하면 된다.    
    } else if(this.listType == LISTBOX_TYPE_MULTISELECT || this.listType == LISTBOX_TYPE_CHECKSELECT){
//    	if (this.options.length > 0){
//    		this.options.remove(0)
//    	}
    } 
};

ListBoxW.prototype = new ControlBase(); // 의미없음 코딩 편의기능을 활용하기 위함
/**
 * @description	미결
 * @param		{Object}	em
 * @return		{String}
 * @example		미결
 */
function searchControl_ListBoxW(em){
	var pEm = em;
	var image = pEm.getAttribute("image");
	var wReturn = null;
	var classNames = ["ListBoxA", "ListBoxB", "ListBoxC", "ListBoxD"];
	
//	while(pEm.parentNode && classNames.indexOf(pEm.className) < 0)
//		pEm = pEm.parentNode;
//	if( classNames.indexOf(pEm.className) >= 0 )
//		wReturn = getControlById(pEm.id);
	
	while(pEm.parentNode && classNames.indexOf(image) < 0){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}
	
	if( classNames.indexOf(image) >= 0 ){
		wReturn = getControlById(pEm.id);
	}
	else{
		pEm = null;
		pEm = em;
		
		while(pEm.parentNode && classNames.indexOf(pEm.className) < 0)
			pEm = pEm.parentNode;
		
		if( classNames.indexOf(pEm.className) >= 0 )
			wReturn = getControlById(pEm.id);
	}
	
	classNames.clear(); classNames = null;
	image = null;
	pEm = null;
	
	return wReturn;
};

//자식
/**
 * @description	미결
 * @param		{String}	value
 * @param		{String}	text
 * @return		{String}
 * @example		미결
 */
function Option(value,text){
  this.value = value;
  this.text = text;
  this.selected = false;
  this.objectSeq = 0;
};

//부모
/**
 * @description	미결
 * @param		{Object}	tagObject
 * @param		{Object}	listType
 * @return		{undefined}
 * @example		미결
 */
function Options(tagObject, listType){
    this.length = 0;
    this.items = [];
    this.tagObject = tagObject;
    this.controlName = tagObject.getAttribute("ctlname");
    this.listDIV = this.tagObject.getElementsByTagName("div")[0];
    this.listType =listType;
    
    // tagObject 속의 최초 option 채우기
    var wOptions = this.tagObject.getElementsByTagName("div")[0].getElementsByTagName("div");
    for (var i = 0; i < wOptions.length; i++){
        var opt = wOptions[i];
        var wText = (BrowserDetect.browser == "Firefox" ? opt.textContent : opt.innerText);
        
        this.items[i] = new Option(opt.getAttribute("value"), wText);
        this.length++;
    } 
};

// Option 아이템 추가
/**
 * @description	미결
 * @param		{object}	option
 * @return  	{void}
 * @example		미결
 */
Options.prototype.add = function(option){
	// functionname : [ListBox.Options.add]
	
	this.items[this.length++] = option;
	
	if( this.listType == LISTBOX_TYPE_CHECKSELECT ){
		// 테그만들기
		var childDIV = document.createElement("div");
		
		childDIV.setAttribute("value", option.value);
		childDIV.setAttribute("top","1px");            
		childDIV.innerHTML = "<input type=\"checkbox\" style=\"height:12px;cursor: pointer;\" />" + option.text;
		childDIV.style.height="15px";
		childDIV.style.width=this.listDIV.style.width;
		childDIV.style.cursor = "pointer";
		childDIV.style.textOverflow = "ellipsis";
		childDIV.style.overflow = "hidden";
		
		// 태그 붙이기
		this.listDIV.appendChild(childDIV);
	}
	else{
		// 테그만들기
		var childDIV = document.createElement("div");
		
		childDIV.innerHTML = option.text;
		childDIV.setAttribute("value", option.value);
		childDIV.setAttribute("top","1px");
		childDIV.style.height="15px";
		childDIV.style.width=this.listDIV.style.width;
		childDIV.style.cursor = "pointer";
		childDIV.style.textOverflow = "ellipsis";
		childDIV.style.overflow = "hidden";
		
		// 태그 붙이기
		this.listDIV.appendChild(childDIV);
	}
	
	return;
};

// Options 아이템 삭제 ??? 0 부터인지 체크 
/**
 * @description	미결
 * @param		{String}	index
 * @return  	{void}
 * @example		미결
 */
Options.prototype.remove = function(index){
	// functionname : [ListBox.Options.remove]
	
	this.items[index] = null;
	this.items.splice(index, 1);
	this.length-- ;
	
	// 자식div찾기  자식div지우기
	var childDIV = this.listDIV.getElementsByTagName("div")[index];
	
	if( typeof childDIV != "undefined" ){
		this.listDIV.removeChild(childDIV);
	}
	
	return;
};


//강제로 Options 아이템 값,텍스트 바꾸기
/**
 * @description	미결
 * @param		{String}	index
 * @param		{String}	value
 * @param		{string}	text
 * @return 		{void}
 * @example		미결
 */
Options.prototype.setItem = function(index, value, text){
	this.items[index].value = value;
	this.items[index].text = text;
	
	var childDIV = this.listDIV.getElementsByTagName("div")[index];
	
	if( this.listType == LISTBOX_TYPE_CHECKSELECT ){
		childDIV.setAttribute("value", option.value);
		childDIV.innerHTML = "<input type=\"checkbox\" style=\"height:12px;cursor: pointer;\" />" + text;
	}
	else{
		childDIV.setAttribute("value", value);
		childDIV.innerHTML = text;
	}
	
	return;
};

/* 포커스 주기*/
/**
 * @description	미결
 * @return  	{boolean}
 * @example		미결
 */
ListBoxW.prototype.focus = function(){
	// functionname : [ListBox.focus]
	
	var wReturn = true;
	
	try{
		this.listDIV.focus();
		this.selectItem(this.currentIndex);
	}
	catch(e){
		wReturn = false;
	}
	
	return wReturn;
};

/**
 * @description	미결
 * @param		{String}	value
 * @param		{boolean}	needUpdateDataset
 * @return  	{boolean}
 * @example		미결
 */
ListBoxW.prototype.setValue = function(value, needUpdateDataset){
	// functionname : [ListBox.setValue]
    
	// 데이터리스트는 setValue 메서드를 허용하지 않고 오직 addItem만으로 값을 넣는다
	// 단일레코드로 저장하는 타입인 경우 setValue 메서드로 리스트목록을 채운다.
	if( this.listType == LISTBOX_TYPE_DATASELECT ){
		if( this.listSaveType == LISTBOX_SAVE_SINGLE ){
			if( "" + this.value == "" + value ) return false;
			
			var arrStrings = ("" + value).split(",");
			
			for(var i = 0; i < arrStrings.length; i++){
				if( arrStrings[i].length == 0 ) continue;
				var text = (hasTimeEncodeString(arrStrings[i]) ? timeDecodeString(arrStrings[i]) : arrStrings[i]);
				this.addItem(text, arrStrings[i]);
			}
		}
		
		return true;
	}
	
	if( parseInt(1 * value) == 0 && !this.haveZeroListValue() ){
		value = this.VALUE_WHEN_NOT_SELECTED;
	}
	
	// 멀티선택이나 체크선택의 경우 디폴트값이 목록에 없다. 따라서 클리어 처리 해 주어야 한다
	if( this.listType == LISTBOX_TYPE_MULTISELECT || this.listType == LISTBOX_TYPE_CHECKSELECT ){
		if( value == this.VALUE_WHEN_NOT_SELECTED ){
			this.clearSelection();
			return true;
		}
	}
	
	var oldValue = this.value;
	var oldText = this.text;
	
	if( "" + oldValue == "" + value )
		return true;
	
	// 값을 주려는 데 콘트롤이 아직 채워 지지 않았다.
	if( !this.valueFound(value) ){
		this.reservedValue = value;
		return false;
	}
	
	//임시로 콘트롤 값을 채우고(콘트롤 외양은 변화없음) 오류체크
	this.value = value;
	this.text = this.getTextLinked();
	
	if( !this.checkError() ){
		this.value = oldValue;
		this.text = oldText;
		this.focus();
		return false;
	}
	
	// 사용자 코딩 추가영역을 호출한다
	this.raiseChangeEvent();
	
	// 콘트롤의 보이는 모습을 갱신한다. 
	this.clearSelection();			// 선택을 모두 해제하고 
	this.setValueLinked(value);		// 새로운 항목만 선택
	
	// dataset 갱신 기능 
	if( typeof needUpdateDataset == "undefined" || needUpdateDataset == true ){
		if( this.listType == LISTBOX_TYPE_DATASELECT && this.listSaveType == LISTBOX_SAVE_MULTI ){
			if( typeof(ControlBase.prototype._UpdateDataset) != "undefined" ){
				this._UpdateDataset(this.currentIndex + 1);
			}
		}
	}
	
	return true;
};

/**
 * @description	미결
 * @return 		{boolean}
 * @example		미결
 */
ListBoxW.prototype.raiseChangeEvent = function(){
	// functionname : [ListBox.raiseChangeEvent]
	
	var checkEvent = false;
	
	try{
		if( eval(this.controlId + "_onchange") ) checkEvent = true;
	} catch(e){}
	
	if( checkEvent ){
		var result = eval(this.controlId + "_onchange();");
		if( typeof(result)=="boolean" ){
			if( result == false ){
				this.value = oldValue;
				this.text = oldText;
				this.focus();
				return false;
			}
		}
	}
};

/**
 * @description	미결
 * @return  	{boolean}
 * @example		미결
 */
ListBoxW.prototype.setValueToDefault = function(){
    // functionname : [ListBox.setValueToDefault]
	
    if (this.options.length == 0) return false;	
	
	if (this.defaultValue.length==0){
	    this.setValue(this.VALUE_WHEN_NOT_SELECTED);
        return true;
	}
	var value = this.defaultValue;
	
	if (parseInt(1 * value) == 0 && !this.haveZeroListValue()){
		this.setValue(this.VALUE_WHEN_NOT_SELECTED);
        return true;
	}
	
	this.setValue(this.defaultValue);

    return true;
};

/* 겉값주기*/
/**
 * @description	미결
 * @param		{string}	text
 * @return  	{boolean}
 * @example		미결
 */
ListBoxW.prototype.setText = function(text){
    // functionname : [ListBox.setText]   
	
	// 데이터리스트는 setText 메서드를 허용하지 않고 오직 addItem만으로 값을 넣는다
    if (this.listType == LISTBOX_TYPE_DATASELECT){
   	    return true;
    }

	// 멀티선택이나 체크선택의 경우 디폴트값이 목록에 없다. 따라서 클리어 처리 해 주어야 한다
	if (this.listType == LISTBOX_TYPE_MULTISELECT || this.listType == LISTBOX_TYPE_CHECKSELECT){
		if (text == ""){
			this.clearSelection();   
			// clearSelection내에도 value, text값을 재 설정하는 기능이 있다
			// 아래 로직을 타지 않아도 좋다
	    	return true;
		}
	}


	var oldValue = this.value; var oldText = this.text;
    if (oldText == text) return true;
    

    if (!this.textFound(text)) {
        // 리스트에 값을 주려는 데 콘트롤이 아직 채워 지지 않았다.
    	return false;
    } 

    //임시로 콘트롤 값을 채우고(콘트롤 외양은 변화없음) 오류체크
    this.text = text;
	this.value = this.getValueLinked();

    if (!this.checkError()){
 	    this.value = oldValue;  this.text = oldText;
 	    this.focus();
    	return false;
    }

    // 사용자 코딩 추가영역을 호출한다
	var checkEvent = false;
	try {
    	if (eval(this.controlId + "_onchange")) checkEvent = true;
    } catch(e){}
    
    if (checkEvent){
	   var result = eval(this.controlId + "_onchange();");
       if (typeof(result)=="boolean"){
    	   if (result==false){
        	   this.value = oldValue;  this.text = oldText;
        	   this.focus();
    	       return false;
    	   }
       }
    }

    // 콘트롤의 보이는 모습을 갱신한다. 
    this.clearSelection();                   // 선택을 모두 해제하고 
    this.setTextLinked(text);                // 새로운 항목만 선택

	// dataset 갱신 기능 
    if (typeof needUpdateDataset == "undefined" || needUpdateDataset == true){
    	if (this.listType == LISTBOX_TYPE_DATASELECT && this.listSaveType == LISTBOX_SAVE_MULTI){
    		if (typeof(ControlBase.prototype._UpdateDataset) != "undefined"){
    			this._UpdateDataset(this.currentIndex + 1);
    		}
    	}
    }
    
    
    return true;
};

/* 값추가하기*/ 
/**
 * @description	미결
 * @param		{string}	pText
 * @param		{String}	pData
 * @param		{boolean}	needUpdateDataset
 * @return  	{void}
 * @example		미결
 */
ListBoxW.prototype.addItem = function(pText, pData, needUpdateDataset){
    // functionname : [ListBox.addItem]
    
    // 데이터 리스트에서 빈레코드가 있는 경우 빈레코드를 없에고 항목을 추가한다                   
    if (this.listType == LISTBOX_TYPE_DATASELECT && this._hasBlankItem){
        var wOptions =  this.options;
        for (var i = wOptions.length - 1 ; i >= 0; i--){
            wOptions.remove(i, false);  // false: needUpdateDataset
        }
    }

    this.options.add(new Option(pData, pText));
    this.currentIndex = this.options.length - 1;
    this._hasBlankItem = false;
    
    if (this.listType == LISTBOX_TYPE_DATASELECT){
        // 데이터를 채우는 중에는 루핑을 방지하기 위하여 항목추가이벤트를 일으키지 않음
        if (this.inputMode == DATALISTBOX_SETDATA) return;

        // 데이터 리스트인 경우 additem이벤트에서 객체를 처리하기 위하여 값을 갱신함
        if (this.listSaveType == LISTBOX_SAVE_SINGLE){
            this.text = this.getValueLinked(true); 
            this.value = this.getTextLinked(true);
            this.raiseChangeEvent();
            
        } else if (this.listSaveType == LISTBOX_SAVE_MULTI){
            this.text = pText; this.value = pData;
        }
    }

    var checkEvent = false;
	try {
	    if (eval(this.controlId + "_onadditem")) checkEvent = true;
	} catch(e){}
	    
	if (checkEvent){
	     var result = eval(this.controlId + "_onadditem(" + this.currentIndex + ")");
	}
	
	// dataset 현재줄 추가 기능 
    if (typeof needUpdateDataset == "undefined" || needUpdateDataset == true){
    	if (this.listType == LISTBOX_TYPE_DATASELECT && this.listSaveType == LISTBOX_SAVE_MULTI){
    		if (typeof(ControlBase.prototype._UpdateDatasetAddRow) != "undefined"){
    			this._UpdateDatasetAddRow();
    			this._UpdateDataset(this.currentIndex + 1);
    		}
    	}
    }
	
    return ;
};

/**
 * @description	미결
 * @param		{String}	pData
 * @param		{string}	objectId
 * @return  	{string}
 * @example		미결
 */
ListBoxW.prototype.textOfData = function(pData, objectId){
	// functionname : [ListBox.textOfData]

	var wReturn = "";
    var i = 0;
	               	
	var checkEvent = false;
	try {
		if (eval("getCasheKey_" + this.controlId)) checkEvent = true;
	} catch(e){}
	
	if (checkEvent){
		var recordsetKey = "fillList_" + this.controlId;
	    var casheKey = eval("getCasheKey_" + this.controlId + "(objectId);");
	    var wArrKey = casheKey.split(":");
	    
	    // SQL번호만 있는 경우 콜론을 붙여준다
	    if (casheKey.indexOf(":") < 0) casheKey += ":";
        
	    var recordset = getRecordsetByKey(recordsetKey);
	    if (recordset.casheKey != casheKey){
	        var dataCashe = dataCashes[casheKey];
	        
	        if (dataCashe == undefined){
	        	// casheMode가 설정되면 리스트는 갱신안되고 캐시에만 저장된다
	        	recordset.casheMode = true;
	    		recordset.sqlnum = wArrKey[0];
                
	        	for (var i=1; i < wArrKey.length; i++){
		    		recordset.setParameter("param" + i, wArrKey[i]);
	        	}
	        	// syncMode로 호출 된다
	    		recordset.open();
	    		// 호출후 recordsetKey + "_OnReceive"가 수행된다
	    		
	    		recordset.casheMode = false; 
	    		dataCashe = dataCashes[casheKey];
	        }
	        for (i = 0; i < dataCashe.rowCount; i++){
	       	    if (dataCashe.fields[0].datas[i] == pData){
	       		    wReturn = dataCashe.fields[1].datas[i];
	                break;
	            }
	        }
	       
	        return wReturn; 
	    }
	}

    var wOptions =  this.options;
    for (i = wOptions.items.length - 1; i >= 0; i--){
    	if (("" + pData).length > 0 && wOptions[i].items.value == pData){
    		wReturn = wOptions.items[i].text;
            break;
        }
    }
    
    return wReturn;
};


/* 값수정하기*/
/**
 * @description	미결
 * @param		{string}	pText
 * @param		{String}	pData
 * @param		{boolean}	needUpdateDataset
 * @return  	{void}
 * @example		미결
 */
ListBoxW.prototype.updateItem = function(pText, pData, needUpdateDataset){
    // functionname : [ListBox.addItem]
    
    this.currentIndex = this.indexOfText(pText);
    this.options.items[this.currentIndex].value = pData;
    
    // 데이터 리스트인 경우 updateitem이벤트에서 객체를 처리하기 위하여 값을 갱신함
    if (this.listSaveType == LISTBOX_SAVE_SINGLE){
        this.text = this.getValueLinked(true); 
        this.value = this.getTextLinked(true);
        this.raiseChangeEvent();
        
    } else if (this.listSaveType == LISTBOX_SAVE_MULTI){
        this.text = pText; this.value = pData;
    }

    var checkEvent = false;
	try {
	    if (eval(this.controlId + "_onupdateitem")) checkEvent = true;
	} catch(e){}
	    
	if (checkEvent){
	     var result = eval(this.controlId + "_onupdateitem(" + this.currentIndex + ")");
	}

	// dataset 갱신 기능 
    if (typeof needUpdateDataset == "undefined" || needUpdateDataset == true){
    	if (this.listType == LISTBOX_TYPE_DATASELECT && this.listSaveType == LISTBOX_SAVE_MULTI){
    		if (typeof(ControlBase.prototype._UpdateDataset) != "undefined"){
    			this._UpdateDataset(this.currentIndex + 1);
    		}
    	}
    }

	
    return ;
};

/* 값삭제하기*/
/**
 * @description	미결
 * @param		{String}	pData
 * @param		{boolean}	needUpdateDataset
 * @return  	{undefined}
 * @example		미결
 */
ListBoxW.prototype.removeItem = function(pData, needUpdateDataset){
    // functionname : [ListBox.removeItem]
      var wOptions =  this.options;
      var nRow = -1;
      for (var i = wOptions.length - 1; i >= 0; i--){
      	if (("" + pData).length > 0 && wOptions.items[i].value == pData){
              wOptions.remove(i);
              nRow = i;
              break;
          }
      }
      
      // dataset 현재줄 삭제 기능 
      if (nRow >= 0){
    	    if (typeof needUpdateDataset == "undefined" || needUpdateDataset == true){
    	    	if (this.listType == LISTBOX_TYPE_DATASELECT && this.listSaveType == LISTBOX_SAVE_MULTI){
    	    		if (typeof(ControlBase.prototype._UpdateDatasetDelRow) != "undefined"){
    	    			this._UpdateDatasetDelRow(nRow + 1);
    	    		}
    	    	}
    	    }
      }
};


/* 리스트박스의 등록된 아이템의 갯수*/
/**
 * @description	미결
 * @return  	{number}
 * @example		미결
 */
ListBoxW.prototype.listCount = function(){
    // functionname : [ListBox.listCount]

	return this.options.length;
};

/* 리스트박스의 초기화*/
/**
 * @description	미결
 * @param		{boolean}	needUpdateDataset
 * @return  	{boolean}
 * @example		미결
 */
ListBoxW.prototype.clear = function(needUpdateDataset){
    // functionname : [ListBox.clear]

    var i = 0;
    var wOptions =  this.options;
    for (i = wOptions.length - 1 ; i >= 0; i--){
        wOptions.remove(i);
    }
    
    this.value= this.VALUE_WHEN_NOT_SELECTED; this.text= "";
    
    // 데이터 리스트인 경우 화면의 시퀀스 1에 맞추기 위하여 기본적으로 하나의 레코드는 넣어준다
    if (this.listType == LISTBOX_TYPE_DATASELECT){
        //this.options.add(new Option("", "(선택하세요)"));
    	//this._hasBlankItem = true;
        this.currentIndex = this.options.length - 1;
    	this._hasBlankItem = false;
        
        this.text = ""; this.value = "";
        
    }

	// dataset 현재줄 아래로 이동 기능 
    if (typeof needUpdateDataset == "undefined" || needUpdateDataset == true){
    	if (this.listType == LISTBOX_TYPE_DATASELECT && this.listSaveType == LISTBOX_SAVE_MULTI){
    		if (typeof(ControlBase.prototype._UpdateDatasetClear) != "undefined"){
    			this._UpdateDatasetClear();
    		}
    	}
    }
    
    // 사용자 코딩 추가영역을 호출한다
	var checkEvent = false;
	try {
    	if (eval(this.controlId + "_onclear")) checkEvent = true;
    } catch(e){}
    
    if (checkEvent){
 	   var result = eval(this.controlId + "_onclear();");
       if (typeof(result)=="boolean") return result;
    }
    
    return true;
};

/* 리스트 박스에 모든값채우기 */
/**
 * @description	미결
 * @param		{object}	recordset
 * @param		{boolean}	needUpdateDataset
 * @return 		{void}
 * @example		미결
 */
ListBoxW.prototype.setLists = function(recordset, needUpdateDataset){
    // functionname : [ListBox.setLists]
	
	// 화면에 없는 데이터 가저오기인 경우
	if (recordset.casheMode) return;
	

	this.clear();
	
	if( recordset.commandType == "Dataset" ){
		var dataSet = recordset.dataSet;
		var fieldInfos = dataSet.fieldInfos;
		var vField = fieldInfos.CODE.field;
		var tField = fieldInfos.CODE_NAME.field;
		var data = null;
		var i = 0;
		
		for(i = 0; i < recordset.rowCount; i++, data = null){
			data = dataSet.data[i];
			this.addItem(data[tField], data[vField]);
		}
		
		dataSet = null; fieldInfos = null;
		tField = null; vField = null;
		data = null; 
	}
	else {
		if (recordset.fields.length == 1){
			while (!recordset.EOF){
				this.addItem(recordset.fields[0].value(), recordset.fields[0].value());
				recordset.moveNext();
			}
		} else {
			while (!recordset.EOF){
				this.addItem(recordset.fields[1].value(), recordset.fields[0].value());
				recordset.moveNext();
			}
		}
	}
	
    recordset.close();
    
    if (this.reservedValue != this.VALUE_WHEN_NOT_SELECTED){
    	this.setValue(this.reservedValue);
    }else {
    	this.setValueToDefault();
    }
    this.reservedValue = this.VALUE_WHEN_NOT_SELECTED;
    
	//Dataset을 사용하지 않은 경우
    if (typeof needUpdateDataset == "undefined" || needUpdateDataset == true){
    	if (this.listType == LISTBOX_TYPE_DATASELECT && this.listSaveType == LISTBOX_SAVE_MULTI){
    		if(typeof(ControlBase.prototype._UpdateDatasetList) != "undefined"){
    			this._UpdateDatasetList();
    		}
    	}
    }
    
    
    return;
};

//화면로드시만 일어나는 기능으로 디폴트값선택등 추가기능은 생략
/**
 * @description	미결
 * @param		{String}	listsStr
 * @param		{String}	itemsStr
 * @return 		{boolean}
 * @example		미결
 */
ListBoxW.prototype.setDefaultLists = function(listsStr, itemsStr){
	// functionname : [ListBoxW.setDefaultLists]
	
	if( typeof itemsStr == "undefined" || (typeof itemsStr == "string" && itemsStr.trim().length == 0) ){
		//itemsStr = listsStr;
	}
	
	listsStr = listsStr.replace(/,/g,"<COMMA>");
	itemsStr = itemsStr.replace(/,/g,"<COMMA>");
	
	var i = 0;
	var wOptions = this.tagObject.getElementsByTagName("div")[0].getElementsByTagName("div");
	
	if( wOptions.length > 0 ){
		for(i = 0; i < wOptions.length; i++){
			listsStr += "<COMMA>" + wOptions[i].textContent;
			itemsStr += "<COMMA>" + wOptions[i].getAttribute("value");
		}
	}

	var arrayLists = listsStr.split("<COMMA>");
	var arrayItems = itemsStr.split("<COMMA>");
	
	this.clear();
    
    for(i = 0; i < arrayLists.length; i++){
    	this.addItem(arrayLists[i], arrayItems[i]);
    }
	
	this.setValueToDefault();
	
	this.reservedValue = "";
	this.reservedText = "";
	
	return true;
};

/*리스트 박스에 값있는지 여부 체크*/
/**
 * @description	미결
 * @return  	{boolean}
 * @example		미결
 */
ListBoxW.prototype.haveZeroListValue = function(){
    // functionname : [ListBox.haveZeroListValue]

	var wReturn = false;
    var wOptions =  this.options;
    for (var i = wOptions.length - 1 ; i >= 0; i--){
   		if ("" + wOptions.items[i].value != "0") continue;
   			wReturn = true;
   			break;
   		
    }
	  return wReturn;
};

/**
 * @description	미결
 * @return  	{object}
 * @example		미결
 */
ListBoxW.prototype.getListType = function (){
    // functionname : [ListBox.getListType]
  return this.listType;
};

/**
 * @description	미결
 * @return  	{object}
 * @example		미결
 */
ListBoxW.prototype.getCurrentIndex = function (){
    // functionname : [ListBox.getCurrentIndex]
    return this.currentIndex;
};

/**
 * @description	미결
 * @param		{number}	pLeft
 * @param		{number}	pTop
 * @param		{number}	pWidth
 * @param		{number}	pHeight
 * @return  	{void}
 * @example		미결
 */
ListBoxW.prototype.moveWindow= function(pLeft,pTop,pWidth,pHeight){
    // functionname : [ListBox.moveWindow]

    this.height = pHeight;
    this.tagObject.style.height=pHeight+'px';
 
    
    this.width = pWidth;
    this.tagObject.style.width=pWidth+'px';
 
    
    this.left = pLeft;
    this.tagObject.style.left=pLeft+'px';
 
    
    this.top = pTop;
    this.tagObject.style.top = pTop+'px';
 
    return;
};

/* 리스트박스에 포커스주기*/
/**
 * @description	미결
 * @return		{boolean}
 * @example		미결
 */
function ListBoxW_Focus(){

	  var control = searchControl_ListBoxW(getSrcElement(event));
    // 사용자 코딩 추가영역을 호출한다
  	var checkEvent = false;
	  try {
      	if (eval(control.controlId + "_onfocus")) checkEvent = true;
      } catch(e){}
    
      if (checkEvent){
	    var result = eval(control.controlId + "_onfocus();");
        if (typeof(result)=="boolean") return result;
      }
    return true;
};

/* 리스트박스에 포커스잃었을때*/
/**
 * @description	미결
 * @return		{boolean}
 * @example		미결
 */
function ListBoxW_Blur(){
	var control = searchControl_ListBoxW(getSrcElement(event));
    // 사용자 코딩 추가영역을 호출한다
	var checkEvent = false;
	try {
    	if (eval(control.controlId + "_onblur")) checkEvent = true;
    } catch(e){}
    
    if (checkEvent){
	   var result = eval(control.controlId + "_onblur();");
       if (typeof(result)=="boolean") return result;
    }
   
    return true;
};

/* 리스트박스에 키다운이 발생했을경우*/
/**
 * @name		ListBoxW#ListBoxW_KeyDown
 * @event
 * @return		{boolean}
 * @description 미결
 */
function ListBoxW_KeyDown(e)
{
	var evt = window.event || e;
    var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
    var em  = getSrcElement(evt);
    
    var control = searchControl_ListBoxW(em);
    
    var wKeyCode = evt.keyCode;
    if (wKeyCode == 9){
		if (getShiftKeyPressed(evt)){
			stopEvent(evt);
			setTimeout("setFocusToFormerControl(\"" + control.controlName + "\")", 0);
	   		return true;
		} else {
    		stopEvent(evt);
    		setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
    		return true;
		}
    } else if (wKeyCode == 13){
		stopEvent(evt);
		setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
		return true;
    } else if (evt.keyCode != 38 && evt.keyCode != 40 && evt.keyCode != 46) {     // 아래위 방향키가 아니면 스킵한다.
		stopEvent(evt);
        return true;
    }

    if (evt.keyCode == 46) {     // 삭제키
    	if (control.listType != LISTBOX_TYPE_DATASELECT) return false;    	
    }    
    // ctrl, alt 키가 눌려있으면 스킵한다
    if (getCtrlPressed(evt)) return true;
    if (getAltPressed(evt)) return true;
   
    // 삭제키가 눌린경우의 조치
    if (evt.keyCode == 46) {
    	if (control.currentIndex == -1) return false;
        var checkEvent = false;
        try {
            if (eval(control.controlId + "_onremoveitem")) checkEvent = true;
        } catch(e){}
            
        if (checkEvent){
             var result = eval(control.controlId + "_onremoveitem(" + control.currentIndex + ")");
             if (typeof(result)=="boolean" && !result) {
            	return false;
             }
        }

        
        if (control.options.length > 1) {
            control.options.remove(control.currentIndex);
            
            // dataset 현재줄 삭제 기능 
            if (control.listType == LISTBOX_TYPE_DATASELECT && control.listSaveType == LISTBOX_SAVE_MULTI){
            	if (typeof(ControlBase.prototype._UpdateDatasetDelRow) != "undefined"){
            		control._UpdateDatasetDelRow(control.currentIndex + 1);
            	}
            }
        } else {
            // 데이터가 하나이면 디폴트 처리를 하게 하기 위해서
        	control.clear();
        }                  
        
      	control.currentIndex = -1;
      	
        if (control.listSaveType == LISTBOX_SAVE_SINGLE){
        	control.text = control.getValueLinked(true); 
        	control.value = control.getTextLinked(true);
        	control.raiseChangeEvent();
        } else if (control.listSaveType == LISTBOX_SAVE_MULTI){
        	control.text = ""; control.value = "";
        }
      	
    	return true;
    }
    

    var delta = (evt.keyCode == 38 ? -1 : 1);
    var newIndex = control.currentIndex + delta;
    
    // 범위를 초과하는 이동은 방지한다.
    if (newIndex >= control.options.length) return false;
    if (newIndex < 0) return false;
    
    // 선택을 모두 해제하고 
    control.clearSelection();
    if (!getShiftKeyPressed(evt)){
        control.selectItem(newIndex);    // 새로운 항목만 선택
        
    } else if (control.listType == LISTBOX_TYPE_SINGSELECT || control.listType == LISTBOX_TYPE_DATASELECT){
        control.selectItem(newIndex);            // 새로운 항목만 선택
        
    } else if (control.listType == LISTBOX_TYPE_MULTISELECT || control.listType == LISTBOX_TYPE_CHECKSELECT){
        control.selectItem(control.critIndex, newIndex);   // 기준 ~새로운 항목만 선택
    } 

    preventbubble(evt);
    
    return true;
};

/**
 * @name		ListBoxW#ListBoxW_onclick
 * @event
 * @return		{boolean}
 * @description 미결
 */
function ListBoxW_onclick(e){
    var evt=window.event || e;
    var em = getSrcElement(evt);
    
    var control = searchControl_ListBoxW(em);
    if (em == control.listDIV) return false; // 항목이 하닌 바탕이 클릭된 경우 캔슬한다
    
    // 체크타입에서 체크가 클릭된 경우 상위 DIV로 대치
	//""=1;
    if (em.tagName.toUpperCase() == "INPUT") {
    	em = em.parentNode;
    }
    
    var checkEvent = false;
    try {
        if (eval(control.controlId + "_onclick")) checkEvent = true;
    } catch(e){}
        
    if (checkEvent) {
    	var result = eval(control.controlId + "_onclick()");
        if (typeof(result)=="boolean" && !result) {
        	return false;
        }
    }

    var newIndex = getItemIndex(em, "DIV");
    
    if (control.listType == LISTBOX_TYPE_SINGSELECT || control.listType == LISTBOX_TYPE_DATASELECT){
    	if (getCtrlPressed(evt)){
    		if (control.options.items[newIndex].selected){
                control.clearSelection(newIndex); 
            } else {
            	control.clearSelection();
                control.selectItem(newIndex);
            }
    	} else {
    		control.clearSelection();                // 선택을 모두 해제하고 
	        control.selectItem(newIndex);            // 새로운 항목만 선택
    	}
        
    } else if (control.listType == LISTBOX_TYPE_MULTISELECT){
        if (getShiftKeyPressed(evt)){
            control.clearSelection();                          // 선택을 모두 해제하고 
            control.selectItem(control.critIndex, newIndex);   // 기준 ~새로운 항목만 선택
        
        } else if (getCtrlPressed(evt)){
            // 새로운 항목만 토글
            if (control.options.items[newIndex].selected){
                control.clearSelection(newIndex); 
            } else {
                control.selectItem(newIndex);
            }
        
        } else {
            control.clearSelection();                // 선택을 모두 해제하고 
            control.selectItem(newIndex);            // 새로운 항목만 선택
        }
    } else if (control.listType == LISTBOX_TYPE_CHECKSELECT){
        // 새로운 항목만 토글
        if (control.options.items[newIndex].selected){
            control.clearSelection(newIndex); 
        } else {
            control.selectItem(newIndex);
        }
    } 
    
    // 사용자 코딩 추가영역을 호출한다
    control.raiseChangeEvent();

    return true;
    
};

/**
 * @description	미결
 * @param		{String}	index
 * @return  	{void}
 * @example		미결
 */
ListBoxW.prototype.clearSelection = function(index){
    // functionname : [ListBox.clearSelection]
    
    var fromIndex = (index == undefined ? 0 : index);
    var toIndex =  (index == undefined || index == null ? this.options.length - 1 : index);
    
    for (var i = fromIndex; i <= toIndex; i++){
        this.options.items[i].selected = false;

        var childDIV = this.listDIV.getElementsByTagName("div")[i];
        if (this.listType == LISTBOX_TYPE_CHECKSELECT){
            var childInput = childDIV.getElementsByTagName("input")[0];
            childInput.checked = false;
        } else {
            childDIV.style.backgroundColor = "transparent";
            childDIV.style.color = this.foreColor;
        }
    } 
    
	this.value = this.getValueLinked(); this.text  = this.getTextLinked();
 
    return;
};

/**
 * @description	미결
 * @param		{String}	critIndex
 * @param		{String}	currentIndex
 * @param		{boolean}	UpdateDataset
 * @return  	{void}
 * @example		미결
 */
ListBoxW.prototype.selectItem = function(critIndex, currentIndex, needUpdateDataset){
    // functionname : [ListBox.selectItem]

    var fromIndex = critIndex;
    var toIndex   = (currentIndex == undefined || currentIndex == null ? critIndex : currentIndex);
    
    this.critIndex = critIndex;
    this.currentIndex = toIndex;
    
    for (var i = fromIndex; i <= toIndex; i++){
        this.options.items[i].selected = true;

        var childDIV = this.listDIV.getElementsByTagName("div")[i];
        if (this.listType == LISTBOX_TYPE_CHECKSELECT){
            var childINPUT = childDIV.getElementsByTagName("input")[0];
            childINPUT.checked = true;
        } else {
//            childDIV.style.backgroundColor='#1500b4';
            childDIV.style.backgroundColor='#676767';
            childDIV.style.color='#FFFFFF';
        	
        }
    } 
    
	this.value = this.getValueLinked();
    this.text  = this.getTextLinked();
    
    this.scrollTo(this.currentIndex);
    
	// dataset 현재줄 갱신 기능 
    if (typeof needUpdateDataset == "undefined" || needUpdateDataset == true){
    	if (this.listType == LISTBOX_TYPE_DATASELECT && this.listSaveType == LISTBOX_SAVE_MULTI){
    		if (typeof(ControlBase.prototype._UpdateDatasetRowPos) != "undefined"){
    			this._UpdateDatasetRowPos(this.currentIndex + 1);
    		}
    	}
    }
    
    return;
};

/**
 * @description	미결
 * @param		{number}	currentIndex
 * @return  	{void}
 * @example		미결
 */
ListBoxW.prototype.scrollTo = function(currentIndex){
	// functionname : [ListBox.scrollTo]
	
	// 현재 보이는 영역을 계산한다
	var parentHeight = (1 * getComputedStyle(this.listDIV).height.replace("px", ""));
	var divs = this.listDIV.querySelectorAll("div");
	var divCount = divs.length;
	var scrollTop = this.tagObject.scrollTop;
	var scrollHeight = this.tagObject.scrollHeight;
	var scrollStep = scrollHeight / divCount;
	var displayDivCount = parentHeight / scrollStep;
	var indexOfTop = Math.round(scrollTop / scrollStep);
	var indexOfLast = indexOfTop + displayDivCount - 1;
	
	// 위로 가렸으면 아래로 내린다. (scrollTop -)
	if( currentIndex < indexOfTop ){
		this.tagObject.scrollTop = 20 * currentIndex;
	}
	
	// 아래로 가렸으면 위로 올린다. (scrollTop +)
	if( currentIndex > indexOfLast ){
		this.tagObject.scrollTop = scrollTop + (20 * (currentIndex - Math.floor(indexOfLast)));
	}
	
	divs = null;
	
	return;
};

// 아래 함수들은 선택된 값들을 여러개 세팅하거나 가저오는 방식이다.
/**
 * @description	미결
 * @param		{string}	valueLinked
 * @return  	{undefined}
 * @example		미결
 */
ListBoxW.prototype.setValueLinked = function(valueLinked){
    // functionname : [ListBox.setValueLinked]
    var text = valueLinked || "";
    this.setValueArray(text.split(","));

};
/**
 * @description	미결
 * @param		{boolean}	needAll
 * @return  	{object}
 * @example		미결
 */
ListBoxW.prototype.getValueLinked = function(needAll){
    // functionname : [ListBox.getValueLinked]
                       
    if (needAll == undefined) needAll = false;
    
    return this.getValueArray(needAll).join(",");
};

/**
 * @description	미결
 * @param		{string}	textLinked
 * @return  	{object}
 * @example		미결
 */
ListBoxW.prototype.getValueLinkedByText = function(textLinked){
    // functionname : [ListBox.getValueLinkedByText]

    var text = textLinked || "";
    var wArray0 = text.split(",");
    var wArray = []; var index = 0;
    
    var optionArray = this.options.items;
    for (var i=0; i < optionArray.length; i++){
        if (wArray0.indexOf(optionArray[i].text) >= 0){
            wArray[index++] = optionArray[i].value;
        } 
    }
    
    return wArray.join(",");
};

/**
 * @description	미결
 * @param		{string}	textLinked
 * @return  	{undefined}
 * @example		미결
 */
ListBoxW.prototype.setTextLinked = function(textLinked){
    // functionname : [ListBox.setTextLinked]

    var text = textLinked || "";
    this.setTextArray(text.split(","));
};

/**
 * @description	미결
 * @param		{boolean}	needAll
 * @return  	{object}
 * @example		미결
 */
ListBoxW.prototype.getTextLinked = function(needAll){
    // functionname : [ListBox.getTextLinked]
                       
    if (needAll == undefined) needAll =false;
    
    return this.getTextArray(needAll).join(",");
};

/**
 * @description	미결
 * @param		{string}	valueLinked
 * @return  	{object}
 * @example		미결
 */
ListBoxW.prototype.getTextLinkedByValue = function(valueLinked){
    // functionname : [ListBox.getTextLinkedByValue]

    var text = valueLinked || "";
    var wArray0 = text.split(",");
    var wArray = []; var index = 0;
    
    var optionArray = this.options.items;
    for (var i=0; i < optionArray.length; i++){
        if (wArray0.indexOf(optionArray[i].value) >= 0){
            wArray[index++] = optionArray[i].text;
        } 
    }
    
    return wArray.join(",");
};

/**
 * @description	미결
 * @param		{object}	pArr
 * @return  	{void}
 * @example		미결
 */
ListBoxW.prototype.setValueArray = function(pArr){
    // functionname : [ListBox.setValueArray]

    var optionArray = this.options.items;
    for (var i=0; i < optionArray.length; i++){
        var value = optionArray[i].value;
        if (pArr.indexOf(value) >= 0){
            this.selectItem(i);
        } 
    }
    return;
};

/**
 * @description	미결
 * @param		{boolean}	needAll
 * @return  	{object}
 * @example		미결
 */
ListBoxW.prototype.getValueArray = function(needAll){
    // functionname : [ListBox.getValueArray]
    
	if (needAll == undefined) needAll =false;
    
    var wArray = []; var index = 0;
    var optionArray = this.options.items;
    for (var i=0; i < optionArray.length; i++){
        if (needAll || optionArray[i].selected)
            wArray[index++] = optionArray[i].value;
    }
    return wArray;

};

/**
 * @description	미결
 * @param		{object}	pArr
 * @return  	{undefined}
 * @example		미결
 */
ListBoxW.prototype.setTextArray = function(pArr){
    // functionname : [ListBox.setTextArray]
    var optionArray = this.options.items;
    for (var i=0; i < optionArray.length; i++){
        var text = optionArray[i].text;
        if (pArr.indexOf(text) >= 0){
            this.selectItem(i);  
        } 
    }

};

/**
 * @description	미결
 * @param		{boolean}	needAll
 * @return  	{object}
 * @example		미결
 */
ListBoxW.prototype.getTextArray = function(needAll){
    // functionname : [ListBox.getTextArray]
                       
    if (needAll == undefined) needAll =false;
                       
    var wArray = []; var index = 0;
    var optionArray = this.options.items;
    for (var i=0; i < optionArray.length; i++){
        if (needAll || optionArray[i].selected)
            wArray[index++] = optionArray[i].text;
    }
    return wArray;
};

/**
 * @description	미결
 * @param		{string}	valueLinked
 * @return  	{boolean}
 * @example		미결
 */
ListBoxW.prototype.valueFound = function(valueLinked){
    // functionname : [ListBox.getTextLinkedByValue]
    
    var wReturn = false;

    var text = valueLinked || "";
    var wArray0 = text.split(",");
    var optionArray = this.options.items;
    
    for (var index = 0; index < wArray0.length; index++){
    	var found = false;
    	var wValue = wArray0[index];
	    for (var i=0; i < optionArray.length; i++){
	        if (wValue == optionArray[i].value){found = true; break;} 
	    }
	    if (found) {wReturn = true; break;}
    }
    	
    return wReturn;
};

/**
 * @description	미결
 * @param		{string}	textLinked
 * @return  	{boolean}
 * @example		미결
 */
ListBoxW.prototype.textFound = function(textLinked){
    // functionname : [ListBox.getTextLinkedByValue]
    
    var wReturn = false;

    var text = textLinked || "";
    var wArray0 = text.split(",");
    var optionArray = this.options.items;
    
    for (var index = 0; index < wArray0.length; index++){
    	var found = false;
    	var wText = wArray0[index];
	    for (var i=0; i < optionArray.length; i++){
	        if (wText == optionArray[i].text){found = true; break;} 
	    }
	    if (found) {wReturn = true; break;}
    }
    	
    return wReturn;
};


/**
 * @description	미결
 * @param		{string}	valueLinked
 * @return  	{object}
 * @example		미결
 */	
ListBoxW.prototype.indexOfValue = function(valueLinked){
    // functionname : [ListBox.getTextLinkedByValue]
    
    var wReturn = -1;

    var text = valueLinked || "";
    var wArray0 = text.split(",");
    var optionArray = this.options.items;
    
    for (var index = 0; index < wArray0.length; index++){
    	var found = false;
    	var wValue = wArray0[index];
	    for (var i=0; i < optionArray.length; i++){
	        if (wValue == optionArray[i].value){wReturn = i; found = true; break;} 
	    }
	    if (found) break;
    }
    	
    return wReturn;
};

/**
 * @description	미결
 * @param		{string}	textLinked
 * @return  	{object}
 * @example		미결
 */
ListBoxW.prototype.indexOfText = function(textLinked){
    // functionname : [ListBox.getTextLinkedByValue]
    
    var wReturn = -1;

    var text = textLinked || "";
    var wArray0 = text.split(",");
    var optionArray = this.options.items;
    
    for (var index = 0; index < wArray0.length; index++){
    	var found = false;
    	var wText = wArray0[index];
	    for (var i=0; i < optionArray.length; i++){
	        if (wText == optionArray[i].text){wReturn = i; found = true; break;} 
	    }
	    if (found) break;
    }
    	
    return wReturn;
};

/**
 * @description	미결
 * @return  	{void}
 * @example		미결
 */
ListBoxW.prototype.updateUploadPrefix = function(){
    // functionname : [ListBox.getTextLinkedByValue]
    
    if (this.listType != LISTBOX_TYPE_DATASELECT) return;
    
    var optionArray = this.options.items;
	for (var i=0; i < optionArray.length; i++){
		var value = optionArray[i].value;
		if (!hasTimeEncodeString(value)){
			optionArray[i].value = jUploadPrefix + value;
		}
	}
	
	if (this.listSaveType == LISTBOX_SAVE_SINGLE){
        this.text = this.getValueLinked(true); 
        this.value = this.getTextLinked(true);
        this.raiseChangeEvent();
    }     
	
	return;
};


// 데이터 시트의 더블클릭 이벤트
/**
 * @name		ListBoxW#ListBoxW_Dblclick
 * @event
 * @return		{boolean}
 * @description 미결
 */
function ListBoxW_Dblclick(e){
    var evt=window.event || e;
    var em = getSrcElement(evt);
    
    var control = searchControl_ListBoxW(em);
    if (em == control.listDIV) return false; // 항목이 하닌 바탕이 클릭된 경우 캔슬한다
    
    var newIndex = getItemIndex(em, "div");
    control.clearSelection();                // 선택을 모두 해제하고 
    control.selectItem(newIndex);            // 새로운 항목만 선택
    
    var text = control.options.items[newIndex].text;
    var value = control.options.items[newIndex].value;
    
    // 화면에서 새로 추가된 것은 타임이 붙지 않는다. 새로추가된 것은 다운을 하지 못한다.
    if (!hasTimeEncodeString(value)) {
    	alert(getText("message_listbox_w_001", " 아직 서버에 등록 되지 않은 자료입니다.\n PC내에서 조회하십시요!"));
    	return true;
    }    
    
    if (typeof FILE_DOWNLOAD_URL != "undefined"){
    	location.href = FILE_DOWNLOAD_URL + "?filename=" + fileName
                                          + "&filename_org=" + orgName 
                                          + "&filepath=" + path;
    	
    } else {
        var parent = document.getElementsByName("IFrameLayer")[0];
    	var action = "fileDownload.do";
    	var params = [];
    	params[0] = new Parameter("subPath", control.subPath);
    	params[1] = new Parameter("fileNameSvr", value.substring(0, 11));
    	params[2] = new Parameter("fileName", text);
    	params[3] = new Parameter("noftp", control.noftp);
    	params[4] = new Parameter("nozip", control.nozip);

    	var iFrame_DownLoad = new IFrame_DownLoad(parent, control.controlName + timeEncodeString(), action, params);
    	iFrame_DownLoad.submit();
    }
    
    return true;
};



/*
 *	Dataset Binding
 */
ListBoxW.prototype._updateLists = function(pLists){
	// functionname : [ListBox._updateLists]
	
	var listLength = 0;
	
	//예외처리
	if( !(pLists instanceof Array) ) return;
	if( (listLength = pLists.length) == 0) return;
	
	var optItem = null;
	var i = 0;
	
	for(i = 0; i < listLength; i++){
		this.options.add(pLists[i]);
	}
	
	while(pLists.length > 0){
		optItem = pLists.pop();
		optItem = null;
	}
	pLists = null;
	
	return;
};/**                                                                                         
*       @class          CheckBox 컨트롤 클래스                                                     
*       @constructor                                                    
*                                                                                           
*       @param          controlId     {String}      해당 컨트롤의 ID를 지정합니다.                              
*       @param          controlName   {String}      해당 컨트롤의 Name을 지정합니다.                            
*       @param          tagObject     {Object}      해당 컨트롤의 태그 객체를 지정합니다.  
*                                                                                           
*       @return         객체 생성 성공하면 객체의 errorMsg 필드가 null 입니다.<br>만약 에러가 발생한다면 errorMsg 필드에 에러메시지를 반환합니다.
*      
*       @example        var wControl = controls["chkbox1"] = new CheckBox("chkbox1", "chkbox1", document.getElementsByName("chkbox1")[0]);
*        if(wControl.errorMsg != null){
*            //객체 생성 실패하였습니다. 에러처리 코드를 입력해주세요.
*        }
*
*        // 후속코드 생략...
*/        
function CheckBox(controlId, controlName, tagObject){
	// 상속선언부
	this.base = ControlBase;						//부모클래스 지정
	this.base(controlId, controlName, tagObject);	//부모클래스 생성자호출
	
	// 상수 선언부
	
	// 속성 선언부	
    /**
     *   @description    체크박스의 체크 설정 값을 나타냅니다.<br>
     *                   기본값 : 0 (체크 안함)<br><br>
     *                   <table width="500">
     *                       <caption>value Variable Value</caption>
     *                       <thead>
     *                            <tr>
     *                              <th align="left">Value</th>
     *                              <th align="left">Description</th>
     *                           </tr>
     *                        </thead>
     *                        <tbody>
     *                           <tr>
     *                              <td> 1 </td>
     *                              <td> 체크박스에 체크합니다. </td>
     *                           </tr>
     *                           <tr>
     *                              <td> 0 </td>
     *                              <td> 체크박스에 체크하지 않습니다. </td>
     *                           </tr>
     *                   </table><br>
     */   
	this.value = 0;				//check : 1 / uncheck : 0
	this.checkedValue = 1;		//참값 속성 설정시
	this.unCheckedValue = 0;	//거짓값 속성 설정시
    /**    
     *   @description      사용자가 입력한 컨트롤 데이터에 대한 타입을 설정합니다.<br>
     *                     타입은 상수로 선언된 CHECKTYPE으로 설정합니다.<br>
     *                     기본값 : 0<br><br>
     */ 
	this.checkType = parseInt(tagObject.getAttribute("checktype"));
	this.enabled = true;
	
	 /**
     *   @description    사용자가 컨트롤에 입력한 값이 확정되었을 때, 컨트롤에 입력된 값을 Key로 하여 데이터를 조회합니다.<br>
     *                   기본값 : false<br><br>
     *                   <table width="500">
     *                       <caption>isKeyControl Variable Value</caption>
     *                       <thead>
     *                            <tr>
     *                              <th align="left">Value</th>
     *                              <th align="left">Description</th>
     *                           </tr>
     *                        </thead>
     *                        <tbody>
     *                           <tr>
     *                              <td> true </td>
     *                              <td> 컨트롤 값에 의해 자료를 조회합니다. </td>
     *                           </tr>
     *                           <tr>
     *                              <td> false </td>
     *                              <td> 컨트롤 값에 의해 자료를 조회하지 않습니다. </td>
     *                           </tr>
     *                   </table><br>
     */   
	this.isKeyControl  = (tagObject.getAttribute("iskeycontrol")  == "true");
    /**
     *   @description      조회한 자료에서 Key 필드와 함께 추가로 조건을 주기위해 사용합니다.<br>
     *                     컨트롤에 화면채우기 설정이 되어있다면 Key필드와 컨트롤의 값에 만족하는 데이터를 화면에 채웁니다.<br>
     *                     기본값 : false<br><br>
     *                     <table width="500">
     *                       <caption>isFillControl Variable Value</caption>
     *                       <thead>
     *                          <tr>
     *                              <th align="left">Value</th>
     *                              <th align="left">Description</th>
     *                           </tr>
     *                        </thead>
     *                        <tbody>
     *                           <tr>
     *                              <td> true </td>
     *                              <td> 컨트롤에 값을 채웁니다. </td>
     *                           </tr>
     *                           <tr>
     *                              <td> false </td>
     *                              <td> 컨트롤에 값을 채우지 않습니다. </td>
     *                           </tr>
     *                     </table><br>
     */  
	this.isFillControl = (tagObject.getAttribute("isfillcontrol")  == "true");
    /**    
     *   @description      Clear나 확인버튼을 클릭하여 실행시키고 난 후 후속작업을 위해 컨트롤의 데이터를 비울지 설정합니다.<br>
     *                     기본값 : false<br><br>
     *                     <table width="500">
     *                       <caption>isClearControl Variable Value</caption>
     *                       <thead>
     *                            <tr>
     *                                <th align="left">Value</th>
     *                              <th align="left">Description</th>
     *                           </tr>
     *                        </thead>
     *                        <tbody>
     *                           <tr>
     *                               <td> true </td>
     *                              <td> Clear 기능 실행 후 컨트롤의 값을 비웁니다. </td>
     *                           </tr>
     *                           <tr>
     *                                <td> false </td>
     *                              <td> Clear 기능 실행하더라도 컨트롤의 값을 유지합니다. </td>
     *                           </tr>
     *                     </table><br>
     */ 
	this.isClearControl = (tagObject.getAttribute("isclearcontrol")  == "true");
    /**
     *   @description      입력/조회 시트에서 줄추가/삭제시 컨트롤의 값을 비울지 설정합니다.<br>
     *                     줄 단위로 다른 값이 들어갈 데이터에 적용됩니다.<br>기본값 : false<br><br>
     *                     <table width="500">
     *                       <caption>isSeqClearControl Variable Value</caption>
     *                       <thead>
     *                            <tr>
     *                                <th align="left">Value</th>
     *                              <th align="left">Description</th>
     *                           </tr>
     *                        </thead>
     *                        <tbody>
     *                           <tr>
     *                               <td> true </td>
     *                              <td> 줄추가/삭제시 컨트롤의 값을 비웁니다. </td>
     *                           </tr>
     *                           <tr>
     *                              <td> false </td>
     *                              <td> 줄추가/삭제를 하더라도 컨트롤의 값은 유지됩니다. </td>
     *                           </tr>
     *                     </table><br>
     */    
	this.isSeqClearControl = (tagObject.getAttribute("isseqclearcontrol")  == "true");
	
	if( tagObject ){
		this.enabled = !((this.tagObject.getElementsByTagName("input")[0]).disabled);	//CheckBox의 경우 div 내 input 태그에 disabled 속성이 추가되어 있으므로 추가 작업 필요
		
		//참값 속성 설정
		var checkedValue = this.tagObject.getAttribute("checkedvalue");
		if( checkedValue != null && (typeof checkedValue == "string" && checkedValue.length > 0) ){
			if( checkedValue == "true" )				this.checkedValue = true;
			else if( checkedValue == "false" )			this.checkedValue = false;
			else if( /^[0-9]+$/.test(checkedValue) )	this.checkedValue = (1 * checkedValue);
		}
		checkedValue = null;
		
		//거짓값 속성 설정
		var unCheckedValue = this.tagObject.getAttribute("uncheckedvalue");
		if( unCheckedValue != null && (typeof unCheckedValue == "string" && unCheckedValue.length > 0) ){
			if( unCheckedValue == "true" )				this.unCheckedValue = true;
			else if( unCheckedValue == "false" )		this.unCheckedValue = false;
			else if( /^[0-9]+$/.test(unCheckedValue) )	this.unCheckedValue = (1 * unCheckedValue);
		}
		unCheckedValue = null;
		
		//체크 설정
		this.value = ((this.tagObject.getElementsByTagName("input")[0]).checked) ? this.checkedValue : this.unCheckedValue;
	}
	
	// 사용자 이벤트
	this.hasChangeEvent = false;	this.fncChangeEvent = null;
	this.hasClickEvent = false;		this.fncClickEvent = null;
	
	if( this.controlId.length > 0 ){
		this.hasChangeEvent = (typeof self[this.controlId + "_onchange"] == "function");
		if( this.hasChangeEvent ){
			this.fncChangeEvent = new Function("return function(){ return " + this.controlId + "_onchange(); }")();
		}
		
		this.hasClickEvent = (typeof self[this.controlId + "_onclick"] != "undefined");
		if( this.hasClickEvent ){
			this.fncClickEvent = new Function("return function(){ return " + this.controlId + "_onclick(); }")();
		}
	}
	
//	this.tagObject.getElementsByTagName("span")[0].onclick = checkLabel_Click; 
//	this.tagObject.getElementsByTagName("input")[0].onclick = checkbox_Click; 
	
	// 이벤트 선언부
	setEventHandler(tagObject.getElementsByTagName("span")[0], "click", checkLabel_Click);
	if( typeof (tagObject.getElementsByTagName("span")[1]) != undefined ){
		setEventHandler(tagObject.getElementsByTagName("span")[1], "click", checkLabel_Click);
	}
	else{
//		this.image = tagObject.className;
		this.tagObject.classList.remove(this.image);
		this.tagObject.classList.add(this.image+"-classic");
	}
	setEventHandler(tagObject.getElementsByTagName("input")[0], "click", checkbox_Click);
	setEventHandler(tagObject, "keydown", checkbox_KeyDown);
};

CheckBox.prototype = new ControlBase(); // 의미없음 코딩 편의기능을 활용하기 위함

/**
*       @description    체크박스 컨트롤을 찾습니다.
*       @param          em        {Object}      컨트롤의 태그 객체를 입력합니다.
*       @return         체크박스 컨트롤을 찾는다면 체크박스의 컨트롤 ID를 반환하고, 찾지 못한다면 null을 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*       @example        var wControl = searchControl_CheckBox( document.getElementsByName("chkbox1")[0] )
*        if(wControl == null){  // 체크박스 컨트롤을 찾는데 실패하였습니다. }
*        if(wControl == false){ // searchControl_CheckBox 함수 동작 중 에러가 발생하였습니다. }
*
*        // 후속코드 생략...
*/
function searchControl_CheckBox(em){
	var pEm = em;
	var image = pEm.getAttribute("image");
	var wReturn = null;
	
//	while (pEm.parentNode && !pEm.className.startsWith("CheckBox")) 
//		pEm = pEm.parentNode;
//	if (pEm.className.startsWith("CheckBox")) 
//		wReturn = getControlById(pEm.id);
	
	while(pEm.parentNode && image !== "CheckBox"){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}
	
	if( pEm.getAttribute("image") === "CheckBox" ){
		wReturn = getControlById(pEm.id);
	}
	else{
		pEm = null;
		pEm = em;
		
		while(pEm.parentNode && !pEm.className.startsWith("CheckBox")) 
			pEm = pEm.parentNode;
		
		if( pEm.className.startsWith("CheckBox") ) 
			wReturn = getControlById(pEm.id);
	}
	
	image = null;
	pEm = null;
	
	return wReturn;
};

/* 포커스 주기*/
/**
*       @description    체크박스에 포커스를 지정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*       @return         체크박스 포커스를 성공한다면 true를 반환하고, 실패한다면 false를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*       @example        var wControl = controls["chkbox1"];
*        // 체크박스에 포커스를 지정합니다.
*        if(wControl.focus() == false){
*           //체크박스 포커스 지정 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //포커스 지정을 실패하거나 에러 발생시 focus 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
*        }
*/
CheckBox.prototype.focus = function(){
	// functionname : [CheckBox.focus]
	var wReturn = true;
	
	try{
		this.tagObject.getElementsByTagName("input")[0].focus();
	}
	catch(e){
		wReturn = false;
	}
	
	return wReturn;
};
/**
*       @description    체크박스에 체크 값을 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*       @param          value        {Number}      1 : 체크합니다. / 0 : 체크 안합니다.
*       @return         체크 값 설정에 성공한다면 true를 반환합니다.<br>만약 실패하거나 에러가 발생한다면 false를 반환합니다.
*       @example        var wControl = controls["chkbox1"];
*        // 체크박스에 데이터를 설정합니다.
*        if(wControl.setValue(1) == false){
*           //체크박스 데이터 설정 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //데이터 설정을 실패하거나 에러 발생시 setValue 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
*        }
*/
CheckBox.prototype.setValue = function(value){
	// functionname : [CheckBox.setValue]
	
	var ctrl = this.tagObject.querySelector("input");
	var oldChecked = ctrl.checked;
	var oldValue = this.value;
	var result = true;
	
	if( "" + oldValue == "" + value ){
		oldValue = null; ctrl = null; //메모리 해제
		return true;
	}
	
	//컨트롤 값 갱신
	this.value = value;
	
	//컨트롤 태그 갱신
	if( (this.value == this.checkedValue && !ctrl.checked) || (this.value == this.unCheckedValue && ctrl.checked) ){
		ctrl.checked = (this.value == this.checkedValue);
	}
	
	//체크조건
	if( !this.checkError() ){
		this.value = oldValue;			//컨트롤 값 복구
		ctrl.checked = oldChecked;		//컨트롤 태그 상태 복구
		oldValue = null; ctrl = null;	//메모리 해제
		return false;
	}
	
	//데이터셋 갱신
	if( typeof(ControlBase.prototype._UpdateDataset) != "undefined" ){
		result = this._UpdateDataset();
		
		if( typeof result == "boolean" && !result ){
			this.value = oldValue;			//컨트롤 값 복구
			ctrl.checked = oldChecked;		//컨트롤 태그 상태 복구
			oldValue = null; ctrl = null;	//메모리 해제
			return false;
		}
	}
	
	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if( this.hasChangeEvent ){
			result = this.fncChangeEvent();
			
			if( (typeof result == "boolean" && !result) ){
				// 컨트롤 값 복구
				this.value = oldValue;
				// dataset 갱신 기능
				if( typeof ControlBase.prototype._UpdateDataset != "undefined" ) this._UpdateDataset();
				//컨트롤 태그 상태 복구
				ctrl.checked = oldChecked;
				//메모리 해제
				oldValue = null; ctrl = null;
				return false;
			}
		}
	}
	
	//메모리 해제
	oldValue = null;
	ctrl = null;
	
	// 관련객체 프로퍼티 채우기
	// this.setLinkedProperties(value);
	
	/*
	// 데이터 가저오기
	if (this.isKeyControl){
	    if (this.isFillControl){
	    	mustFillScreenAfterLoad = true;
	    }
	    objectManager.fillkeyFieldValue = this.value;
	 	objectManager.loadData();
	}
	// 데이터 채우기
	if (!this.isKeyControl && this.isFillControl){
		objectManager.fillData();
	}
	*/
	
	return true;
};

/**
 * @description   미결
 * @return  {boolean}
 * @example   미결
 */
CheckBox.prototype.toggle = function(){
	return this.setValue((this.value == this.checkedValue ? this.unCheckedValue : this.checkedValue));
};

/**
 * @description   미결
 * @param   {objects}   alignment
 * @return  {undefined}
 * @example   미결
 */
CheckBox.prototype.setAlignment = function(alignment){
	// functionname : [CheckBox.setAlignment]
	
	this.alignment = alignment;
	this.tagObject.getElementsByTagName("span")[0].style.textAlign = alignment;
};

/**
*       @description    체크박스 컨트롤의 표시문자열 글자 굵기를 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*       @param          fontBold   {Boolean}    true : 글자 굵기를 굵게합니다. / false : 글자 굵기를 굵게하지 않습니다.
*       @return         글자 굵기 설정에 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*       @example        var wControl = controls["chkbox1"];
*        //체크박스의 표시문자열 글자 굵기를 굵게합니다.
*        if( wControl.setFontBold(true) == false ){
*           //글자 굵기 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //글자 굴기 설정을 실패하거나 에러 발생시 setFontBold 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
*        }
*/
CheckBox.prototype.setFontBold = function(fontBold){
	// functionname : [CheckBox.setFontBold]
	
	this.fontBold = fontBold;
	
	wValue = (fontBold == "true" ? "bold" : "normal");
	this.tagObject.getElementsByTagName("span")[0].style.fontWeight = wValue;
};

/**
*       @description    체크박스 컨트롤의 표시문자열 글자 기울기를 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*       @param          fontItalic  {boolean}   true : 글자 굵기를 굵게합니다. / false : 글자 굵기를 굵게하지 않습니다.
*       //@return         var wControl = controls["chkbox1"];
*        //체크박스의 표시문자열 글자를 기울게합니다.
*        if( wControl.setFontItalic(true) == false ){
*           //글자 기울기 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //글자 기울기 설정을 실패하거나 에러 발생시 setFontItalic 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
*        }
*/
CheckBox.prototype.setFontItalic = function(fontItalic){
	// functionname : [CheckBox.setFontItalic]
	
	this.fontItalic = fontItalic;
	
	wValue = (fontItalic == "true" ? "italic" : "normal");
	this.tagObject.getElementsByTagName("span")[0].style.fontStyle = wValue;
};

/**
*       @description    체크박스 컨트롤의 폰트를 지정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*       @param          setFontName     {String}   체크박스 컨트롤에 사용할 폰트를 입력합니다.
*       //@return         var wControl = controls["chkbox1"];
*        //체크박스의 표시문자열 폰트를 돋움체로 설정합니다.
*        if( wControl.setFontName("돋움체") == false ){
*           //폰트 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //폰트 설정을 실패하거나 에러 발생시 setFontName 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
*        }
*/
CheckBox.prototype.setFontName = function(fontName){
	// functionname : [CheckBox.setFontName]
	
	this.fontName = fontName;
	this.tagObject.getElementsByTagName("span")[0].style.fontFamily = fontName;
};

/**
*       @description    체크박스 컨트롤의 폰트크기를 지정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*       @param          fontSize     {Number}   체크박스 컨트롤에 사용할 폰트크기를 입력합니다.
*       @return         폰트크기 설정에 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*       @example        var wControl = controls["chkbox1"];
*        //체크박스의 표시문자열 폰트크기를 9로 설정합니다.
*        if( wControl.setFontSize(9) == false ){
*           //폰트 크기 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //폰트 크기 설정을 실패하거나 에러 발생시 setFontSize 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
*        }
*/
CheckBox.prototype.setFontSize = function(fontSize){
	// functionname : [CheckBox.setFontSize]
	
	this.fontSize = fontSize;
	this.tagObject.getElementsByTagName("span")[0].style.fontSize = fontSize + "pt";
};

/**
*       @description    체크박스 컨트롤의 표시문자열에 취소선을 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*       @param          fontStrikethru  {boolean}   true : 취소선을 긋습니다. / false : 취소선을 긋지 않습니다.
*       @return         취소선 설정에 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*       @example        var wControl = controls["chkbox1"];
*        //체크박스의 표시문자열에 취소선을 긋습니다.
*        if( wControl.setFontStrikethru(true) == false ){
*           //취소선 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //취소선 설정을 실패하거나 에러 발생시 setFontStrikethru 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
*        }
*/
CheckBox.prototype.setFontStrikethru = function(fontStrikethru){
	// functionname : [CheckBox.setFontStrikethru]
	
	this.fontStrikethru = fontStrikethru;
	
	if( fontStrikethru )
		this.tagObject.getElementsByTagName("span")[0].style.textDecoration = "line-through";
	else
		this.tagObject.getElementsByTagName("span")[0].textDecoration = "none";
};

/**
*       @description    체크박스 컨트롤의 표시문자열에 밑줄 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*       @param          fontUnderline   {Boolean}   true : 밑즐을 긋습니다. / false : 밑줄을 긋지 않습니다.
*       @return         밑줄 설정에 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*       @example        var wControl = controls["chkbox1"];
*        //체크박스의 표시문자열에 밑줄을 긋습니다.
*        if( wControl.setFontUnderline(true) == false ){
*           //밑줄 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //밑줄 설정을 실패하거나 에러 발생시 setFontUnderline 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
*        }
*/
CheckBox.prototype.setFontUnderline = function(fontUnderline){
	// functionname : [CheckBox.setFontUnderline]
	
	this.fontUnderline = fontUnderline;
	
	if( fontUnderline )
		this.tagObject.getElementsByTagName("span")[0].style.textDecoration = "underline";
	else
		this.tagObject.getElementsByTagName("span")[0].style.textDecoration = "none";
};

/**
*       @description    체크박스 컨트롤의 표시문자열을 지정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*       @param          caption     {String}    체크박스 표시문자열을 입력합니다.
*       @return         표시문자열 설정에 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*       @example        var wControl = controls["chkbox1"];
*        //체크박스 표시문자열을 '사용구분'로 설정합니다.
*        if( wControl.setCaption("사용구분") == false ){
*           //표시문자열 지정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //표시문자열 지정을 실패하거나 에러 발생시 setCaption 메소드는 false 를 반환합니다.
*           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
*        }
*/
CheckBox.prototype.setCaption = function(caption){
	// functionname : [CheckBox.setCaption]
	
	this.caption = caption;
	this.tagObject.getElementsByTagName("span")[0].innerText = caption;
};

/**
*       @description    체크박스 컨트롤을 체크시 컨트롤의 값을 설정합니다.<br>만약 설정하지 않는다면 기본값은 1입니다. 
*       @param          checkedValue	{Number|String|Boolean}		체크시 체크박스 컨트롤의 값입니다.
*       @return         설정에 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*       @example        var wControl = controls["chkbox1"];
*        //컨트롤을 체크시 컨트롤의 값을 설정합니다.
*        if( wControl.setCheckedValue(10) == false ){
*           //컨트롤을 체크시 컨트롤의 값 지정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //컨트롤을 체크시 컨트롤의 값 지정을 실패하거나 에러 발생시 setCheckedValue 메소드는 false 를 반환합니다.
*        }
*/
CheckBox.prototype.setCheckedValue = function(checkedValue){
	// functionname : [CheckBox.setCheckedValue]
	
	var oldCheckedValue = this.checkedValue;
	
	//참값 설정
	this.checkedValue = checkedValue;
	
	//체크 설정
	if( oldCheckedValue == this.value && ((this.tagObject.getElementsByTagName("input")[0]).checked) ){
		this.setValue(this.checkedValue);
	}
	
	//메모리 해제
	oldCheckedValue = null;
};

/**
*       @description    체크박스 컨트롤을 체크 해제시 컨트롤의 값을 설정합니다.<br>만약 설정하지 않는다면 기본값은 0입니다. 
*       @param          unCheckedValue	{Number|String|Boolean}		체크 해제시 체크박스 컨트롤의 값입니다.
*       @return         설정에 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
*       @example        var wControl = controls["chkbox1"];
*        //컨트롤을 체크 해제시 컨트롤의 값을 설정합니다.
*        if( wControl.setUnCheckedValue(10) == false ){
*           //컨트롤을 체크 해제시 컨트롤의 값 지정을 실패하였습니다. 에러처리 코드를 입력해주세요.
*           //컨트롤을 체크 해제시 컨트롤의 값 지정을 실패하거나 에러 발생시 setUnCheckedValue 메소드는 false 를 반환합니다.
*        }
*/
CheckBox.prototype.setUnCheckedValue = function(unCheckedValue){
	// functionname : [CheckBox.setUnCheckedValue]
	
	var oldUnCheckedValue = this.unCheckedValue;
	
	//참값 설정
	this.unCheckedValue = unCheckedValue;
	
	//체크 설정
	if( oldUnCheckedValue == this.value && !((this.tagObject.getElementsByTagName("input")[0]).checked) ){
		this.setValue(this.unCheckedValue);
	}
	
	//메모리 해제
	oldUnCheckedValue = null;
};

/**
 * @name CheckBox#checkLabel_Click
 * @event
 * @return   {boolean}
 * @description   미결
 */
function checkLabel_Click(e){
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_CheckBox(em);
	
	control.tagObject.getElementsByTagName("input")[0].click();
	
	stopPropagation(e);
	
	return true;
};

/**
 * @name CheckBox#checkbox_Click
 * @event
 * @return   {boolean}
 * @description   미결
 */
function checkbox_Click(e){
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_CheckBox(em);

	var oldValue = control.value;
	var newValue = (em.checked ? control.checkedValue : control.unCheckedValue);
	
	// 임시로 값을 채우고 클릭 사용자 이벤트 터리 후 복구 시킴
	control.value = newValue;
	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		if( control.hasClickEvent ){
			var result = control.fncClickEvent();
			
			if( typeof result == "boolean" && result == false ){
				control.value = oldValue;
				em.checked = (oldValue == control.checkedValue ? true : false);
				em.focus();
				stopEvent(e);
				//메모리 해제
				newValue = null; oldValue = null;
				control = null; em = null;
				return false;
			}
		}
	}
	// 컨트롤 값 복구
	control.value = oldValue;
	
	// 컨트롤 값 변경이벤트 호출
	control.setValue(newValue);
	
	//메모리 해제
	newValue = null; oldValue = null;
	control = null; em = null;
	
	stopPropagation(e);
	
	return true;
};

/**
 * @name CheckBox#checkbox_KeyDown
 * @event
 * @return   {boolean}
 * @description   미결
 */
function checkbox_KeyDown(e){
	//F5새로고침 방지 추가
	if(e.keyCode == 116) {
		if(typeof e.preventDefault == "function") 
			e.preventDefault();
		else
			e.returnValue = false; // for IE
		return false;
	}
	
    e = window.event || e;
    
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_CheckBox(em);
	var wKeyCode = e.keyCode;
	
	if( wKeyCode == 9 ){
		if( getShiftKeyPressed(e) ){
			stopEvent(e);
			setTimeout("setFocusToFormerControl(\"" + control.controlName + "\")", 0);
			return true;
		}
		else{
			stopEvent(e);
			setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
			return true;
		}
	}
	else if( wKeyCode == 13 ){
		stopEvent(e);
		setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
		return true;
	}
    
	stopPropagation(e);
	
	return true;
};
/**
 *       @class          OptionButton 컨트롤 클래스                                                     
 *       @constructor    OptionButton
 *
 *       @param          controlId       해당 컨트롤의 ID를 지정합니다.
 *       @param          controlName     해당 컨트롤의 Name을 지정합니다.
 *       @param          tagObject       해당 컨트롤의 태그 객체를 지정합니다.
 *
 *       @return         객체 생성 성공하면 객체의 errorMsg 필드가 null 입니다.<br>만약 에러가 발생한다면 errorMsg 필드에 에러메시지를 반환합니다.
 *
 *       @example        var wControl = controls["optionbox_5"] = new OptionButton("optionbox_5", "optionbox_5", document.getElementsByName("optionbox_5")[0] );
 *        if(wControl.errorMsg != null ){
 *           //객체 생성 실패하였습니다. 에러처리 코드를 입력해주세요.
 *        }
 *
 *        //후속코드 생략..
 */
function OptionButton(controlId, controlName, tagObject){
	// 상속선언부
	this.base = ControlBase;						//부모클래스 지정
	this.base(controlId, controlName, tagObject);	//부모클래스 생성자호출
	
	// 상수 선언부
	
	// 속성 선언부
	/**
	 *   @description    옵션버튼의 선택 값(여부)을 나타냅니다.<br>
	 *                   기본값 : 0 (선택 안함)<br><br>
	 *                   <table width="500">
	 *                       <caption>value Variable Value</caption>
	 *                       <thead>
	 *                 	        <tr>
	 *                 			    <th align="left">Value</th>
	 *                 			    <th align="left">Description</th>
	 *                 		    </tr>
	 *                 	    </thead>
	 *                 	    <tbody>
	 *                 		    <tr>
	 *                 			    <td> 1 </td>
	 *                 			    <td> 선택 </td>
	 *                 		    </tr>
	 *                 		    <tr>
	 *                 			    <td> 0 </td>
	 *                 			    <td> 선택 안함 </td>
	 *                 		    </tr>
	 *               
	 *                   </table><br>
	 */
	this.value = 0;				//check : 1/ uncheck : 0
	/**
	 *   @description    옵션버튼의 기본값입니다.<br>옵션버튼의 기본값은 데이터베이스에 저장할 경우 matchUpValue 값이 저장이 됩니다.<br>데이터베이스에서 값을 가져올 경우 matchUpValue로 값을 비교하여 옵션버튼을 선택합니다.<br>
	 *                   기본값 : 이지메이커 속성창에서 입력한 디폴트 값입니다.<br><br>
	 */
	this.matchUpValue = 0;		//기본값
	/**
	 *   @description    옵션버튼의 그룹명을 나타냅니다.<br>그룹명을 기준으로 그룹내 하나의 옵션버튼이 선택된다면 그룹내 다른 옵션버튼은 선택하지 않게 됩니다.<br>
	 */
	this.optionGroupName = "";
	/**
	 *   @description    사용자가 입력한 값에 대한 체크조건입니다.<br>
	 *                   기본값 : 태그 객체 생성시 지정한 설정값을 가져옵니다.<br><br>
	 */
	this.checkType = parseInt(tagObject.checktype);
	
	if( tagObject ){
		/**
		 * @description    미결 
		 */
		this.enabled = !((this.tagObject.getElementsByTagName("input")[0]).getAttribute("disabled"));	//OptionButton의 경우 div 내 input 태그에 disabled 속성이 추가되어 있으므로 추가 작업 필요
		this.tagObject.style.lineHeight = getStyle(this.tagObject).height;
	}
	
	// 이벤트 선언부
//	this.tagObject.getElementsByTagName("span")[0].onclick = optionLabel_Click;
//	this.tagObject.getElementsByTagName("input")[0].onclick = optionbutton_Click;
	
	setEventHandler(tagObject.getElementsByTagName("span")[0], "click", optionLabel_Click);
	if (tagObject.getElementsByTagName("span")[1] != undefined){
		setEventHandler(tagObject.getElementsByTagName("span")[1], "click", optionLabel_Click);
	}
	else {
//		this.image = tagObject.className;
		this.tagObject.classList.remove(this.image);
		this.tagObject.classList.add(this.image+"-classic");
	}
	setEventHandler(tagObject.getElementsByTagName("input")[0], "click", optionbutton_Click);
	setEventHandler(tagObject, "keydown", optionbutton_KeyDown);
};

OptionButton.prototype = new ControlBase(); // 의미없음 코딩 편의기능을 활용하기 위함

/* 포커스 주기*/
/**
 *       @description  옵션 버튼 컨트롤에 포커스를 지정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *       @return       컨트롤에 포커스를 지정하였다면 true를 반환합니다.<br> 만약 에러가 발생하였다면 false를 반환합니다.
 *       @example      var wControl= controls["optionbox_5"];
 *        //옵션버튼에 포커스를 지정합니다.
 *        if( false == wControl.focus() ){
 *           //포커스 지정을 실패하였습니다. 에러처리 코드를 입력해주세요.
 *           //포커스 지정을 실패하거나 에러 발생시 focus 메소드는 false 를 반환합니다.
 *           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
 *        }
 */
OptionButton.prototype.focus = function(){
	// functionname : [OptionButton.focus]
	var wReturn = true;
	
	try{
		this.tagObject.getElementsByTagName("input")[0].focus();
	}
	catch(e){
		wReturn = false;
	}
	
	return wReturn;
};
/**
 *       @description    옵션 버튼의 컨트롤 ID를 찾아 반환합니다.
 *       @param          em        {Object}      컨트롤의 태그 객체입니다.
 *       @return         옵션버튼 컨트롤를 찾았다면 컨트롤 ID를 반환하지만, 찾지 못한 경우 null을 반환합니다. 만약 에러가 발생하였다면 false를 반환합니다.
 *       @example        var wControl = searchControl_OptionButton( document.getElementsByName("optionbox_5")[0] );
 *        if(wControl == null){  //옵션 버튼 컨트롤을 찾는데 실패하였습니다. }
 *        if(wControl == false){ //searchControl_OptionButton 함수 동작 중 에러가 발생하였습니다. }
 *
 *        // 후속코드 생략...
 */
/**
 * @description 미결
 * @param		{String} 미결
 * @return		{Object}
 * @example		미결
 */
function searchControl_OptionButton(em){
	var pEm = em;
	var image = pEm.getAttribute("image");
	var wReturn = null;
	
//	while(pEm.parentNode && !pEm.className.startsWith("OptionButton")) 
//		pEm = pEm.parentNode;
//	if( pEm.className.startsWith("OptionButton") ) 
//		wReturn = getControlById(pEm.id);
	
	while(pEm.parentNode && image !== "OptionButton"){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}

	if( pEm.getAttribute("image") === "OptionButton" ){
		wReturn = getControlById(pEm.id);
	}
	else{
		pEm = null;
		pEm = em;
		
		while(pEm.parentNode && !pEm.className.startsWith("OptionButton")) 
			pEm = pEm.parentNode;
		
		if( pEm.className.startsWith("OptionButton") )
			wReturn = getControlById(pEm.id);
	}
	
	image = null;
	pEm = null;
	
	return wReturn;
};
/**
 *       @description    파라메터 값과 컨트롤의 디폴트 값이 같은지 비교하여 같다면 해당 그룹내 옵션버튼을 선택합니다.<br>그룹내 다른 옵션버튼은 선택하지 않게 됩니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *       @param          value   {Numbrt/String}     옵션버튼의 디폴트 값과 비교할 값입니다.
 *       @return         matchUpWith 함수가 정상적으로 동작한다면 true를 반환합니다.<br> 만약 에러가 발생하였다면 false를 반환합니다.
 *       @example        var wControl= controls["optionbox_5"];
 *        //디폴트 값이 5인지 비교하여 같다면 옵션버튼을 선택합니다.
 *        if( false == wControl.matchUpWith(5) ){
 *           //matchUpWith 함수 동작 실패하였습니다. 에러처리 코드를 입력해주세요.
 *           //matchUpWith 함수 실패하거나 에러 발생시 matchUpWith 메소드는 false 를 반환합니다.
 *           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
 *        }
 */
OptionButton.prototype.matchUpWith = function(value){
	// functionname : [OptionButton.matchUpWith]
	
	if( this.matchUpValue == value ){
		this.setValue(1);
	}
	else{
		this.setValue(0);
	}
	
	return;
};
/**
 *     @description  옵션버튼의 선택값을 지정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *     @param        value        {Int}      1 : 선택함. / 0 : 선택안함.
 *     @return       선택값 지정하는데 성공했다면 true를 반환합니다.<br> 만약 에러가 발생하였다면 false를 반환합니다.
 *     @example      var wControl= controls["optionbox_5"];
 *      //옵션버튼을 선택합니다.
 *      if( false == wControl.setValue(1) ){
 *           //포커스 지정을 실패하였습니다. 에러처리 코드를 입력해주세요.
 *           //포커스 지정을 실패하거나 에러 발생시 setValue 메소드는 false 를 반환합니다.
 *           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
 *      }
 */
OptionButton.prototype.setValue = function(value){
	// functionname : [OptionButton.setValue]
	
	var oldValue = this.value;
	
	if( "" + oldValue == "" + value )
		return true;
	
	var ctl = this.tagObject.getElementsByTagName("input")[0];
	
	if( (value == 1 && !ctl.checked) ){
		ctl.checked = true;
		//ctl.click();
	}
	else if( (value == 0 && ctl.checked) ){
		ctl.checked = false;
		//ctl.click();
	}
	
	this.value = value;
	
	if( !this.checkError() ){
		this.value = oldValue;
		ctl.checked = (this.value == 1);
		ctl.focus();
		return false;
	}
	
	//먼저 다른 콘트롤의 값을 0으로 한다
	this.setOtherOptionValue();
	
	// dataset 갱신 기능 
	if( typeof(ControlBase.prototype._UpdateDataset) != "undefined" ){
		this._UpdateDataset();
	}
	
	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		var checkEvent = false;
		try{
			if( eval(this.id + "_onchange") ) checkEvent = true;
		} catch(e){}
		
		if( checkEvent ){
			var result = eval(this.id + "_onchange();");
			if( typeof(result)=="boolean" && !result ){
				this.value = oldValue;
				ctl.checked = (oldValue == 1);
				ctl.focus();
				return false;
			}
		}
	}
	
	/*
	// 데이터 가저오기
	if (this.isKeyControl){
	    if (this.isFillControl){
	    	mustFillScreenAfterLoad = true;
	    }
	    objectManager.fillkeyFieldValue = this.value;
	 	objectManager.loadData();
	}
	
	// 데이터 채우기
	if (!this.isKeyControl && this.isFillControl){
		objectManager.fillData();
	}
	*/
	
	return true;
};

OptionButton.prototype.setOtherOptionValue = function(){
	// functionname : [OptionButton.setOtherOptionValue]
	
	for(var key in controls){
		if( typeof(controls[key])=="function" )						continue;
		if( !(controls[key] instanceof OptionButton) )				continue;
		if( controls[key] == this )									continue;
		if( controls[key].optionGroupName != this.optionGroupName )	continue;
		
		controls[key].value = 0;
	}
	
	return;
};

/**
 *     @description  옵션버튼 라벨의 정렬을 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *     @param        alignment       {String}        <br>left : 왼쪽정렬 / right : 오른쪽정렬 / center : 가운데정렬<br>(대,소문자 구분안함.)
 *     @return       선택값 지정하는데 성공했다면 true를 반환합니다.<br> 만약 에러가 발생하였다면 false를 반환합니다.
 *     @example      var wControl= controls["optionbox_5"];
 *      //옵션버튼의 라벨을 가운데 정렬합니다.
 *      if( false == wControl.setAlignment("center") ){
 *           //라벨을 정렬을 실패하였습니다. 에러처리 코드를 입력해주세요.
 *           //라벨을 정렬을 실패하거나 에러 발생시 setAlignment 메소드는 false 를 반환합니다.
 *           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
 *      }
 */
OptionButton.prototype.setAlignment = function(alignment){
	// functionname : [OptionButton.setAlignment]
	
	this.alignment = alignment;
	this.tagObject.getElementsByTagName("span")[0].style.textAlign = alignment;
};

/**
 *       @description    옵션버튼 라벨의 글씨 굵기를 설정합니다. <br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *       @param          fontBold    {Boolean}       true : 글씨를 굵게합니다. / false : 글자를 굵게하지 않습니다.
 *       @return         굵기 설정을 성공했다면 true를 반환합니다.<br> 만약 에러가 발생한다면 false를 반환합니다.
 *       @example        var wControl= controls["optionbox_5"];
 *        //옵션버튼 라벨의 글씨를 굵게합니다.
 *        if( false == wControl.setFontBold(true) ){
 *             //라벨의 굵게 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
 *             //라벨의 굵기 설정을 실패하거나 에러 발생시 setFontBold 메소드는 false 를 반환합니다.
 *             //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
 *        }
 */
OptionButton.prototype.setFontBold = function(fontBold){
	// functionname : [OptionButton.setFontBold]
	
	this.fontBold = fontBold;
	wValue = (fontBold == "true" ? "bold" : "normal");
	this.tagObject.getElementsByTagName("span")[0].style.fontWeight = wValue;
};

/**
 *       @description    옵션버튼 라벨의 글씨 기울기를 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *       @param          fontBold    {Boolean}       true : 글씨를 기울게한다. / false : 글자를 기울게하지 않는다.
 *       @return         기울기 설정을 성공했다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
 *       @example        var wControl= controls["optionbox_5"];
 *        //옵션버튼 라벨의 글씨를 기울게 합니다.
 *        if( false == wControl.setFontItalic(true) ){
 *             //라벨의 글씨 기울기 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
 *             //라벨의 글씨 기울기 설정을 실패하거나 에러 발생시 setFontItalic 메소드는 false 를 반환합니다.
 *             //에러에 관한 메세지는 optBox.errorMsg 필드로 확인할 수 있습니다.
 *        }
 */
OptionButton.prototype.setFontItalic = function(fontItalic){
	// functionname : [OptionButton.setFontItalic]
	
	this.fontItalic = fontItalic;
	wValue = (fontItalic == "true" ? "italic" : "normal");
	this.tagObject.getElementsByTagName("span")[0].style.fontStyle = wValue;
};

/**
 *       @description    옵션버튼 라벨의 폰트를 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *       @param          fontName    {String}    폰트명을 입력합니다.
 *       @return         폰트 설정에 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
 *       @example        var wControl= controls["optionbox_5"];
 *        //옵션버튼 라벨의 폰트를 "돋움체"로 설정합니다.
 *        if( false == wControl.setFontName("돋움체") ){
 *             //라벨폰트 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
 *             //라벨폰트 설정을 실패하거나 에러 발생시 setFontName 메소드는 false 를 반환합니다.
 *             //에러에 관한 메세지는 optBox.errorMsg 필드로 확인할 수 있습니다.
 *        }
 */
OptionButton.prototype.setFontName = function(fontName){
	// functionname : [OptionButton.setFontName]
	
	this.fontName = fontName;
	this.tagObject.getElementsByTagName("span")[0].style.fontFamily = fontName;
};

/**
 *       @description    옵션버튼 라벨의 폰트 크기를 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *       @param          fontSize    {Int}   폰트의 크기를 입력합니다.
 *       @return         폰트 크기 설정에 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
 *       @example        var wControl= controls["optionbox_5"];
 *        //옵션버튼 라벨의 폰트크기를 16으로 설정합니다.
 *        if( false == wControl.setFontSize(16) ){
 *             //라벨 폰트크기 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
 *             //라벨 폰트크기 설정을 실패하거나 에러 발생시 setFontSize 메소드는 false 를 반환합니다.
 *             //에러에 관한 메세지는 optBox.errorMsg 필드로 확인할 수 있습니다.
 *        }
 */
OptionButton.prototype.setFontSize = function(fontSize){
	// functionname : [OptionButton.setFontSize]
	
	this.fontSize = fontSize;
	this.tagObject.getElementsByTagName("span")[0].style.fontSize = fontSize + "pt";
};

/**
 *       @description    옵션버튼 라벨에 취소선을 그을지 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *       @param          fontUnderline   {Boolean}   true : 취소선을 긋습니다. / false : 취소선을 긋지 않습니다.
 *       @return         취소선 설정에 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
 *       @example        var wControl= controls["optionbox_5"];
 *        //옵션버튼 라벨에 취소선을 긋습니다.
 *        if( false == wControl.setFontStrikethru(true) ){
 *             //취소선 긋기를 실패하였습니다. 에러처리 코드를 입력해주세요.
 *             //취소선 긋기를 실패하거나 에러 발생시 setFontStrikethru 메소드는 false 를 반환합니다.
 *             //에러에 관한 메세지는 optBox.errorMsg 필드로 확인할 수 있습니다.
 *        }
 */
OptionButton.prototype.setFontStrikethru = function(fontStrikethru){
	// functionname : [OptionButton.setFontStrikethru]
	
	this.fontStrikethru = fontStrikethru;
	if( fontStrikethru )
		this.tagObject.getElementsByTagName("span")[0].style.textDecoration = "line-through";
	else
		this.tagObject.getElementsByTagName("span")[0].textDecoration = "none";
};

/**
 *       @description    옵션버튼 라벨에 밑줄을 그을지 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *       @param          fontUnderline   {Boolean}   true : 밑줄을 긋습니다. / false : 밑줄을 긋지 않습니다.
 *       @return         밑줄 설정에 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
 *       @example        var wControl= controls["optionbox_5"];
 *        //옵션버튼 라벨에 밑줄을 긋습니다.
 *        if( false == wControl.setFontUnderline(true) ){
 *             //밑줄 긋기를 실패하였습니다. 에러처리 코드를 입력해주세요.
 *             //밑줄 긋기를 실패하거나 에러 발생시 setFontUnderline 메소드는 false 를 반환합니다.
 *             //에러에 관한 메세지는 optBox.errorMsg 필드로 확인할 수 있습니다.
 *        }
 */
OptionButton.prototype.setFontUnderline = function(fontUnderline){
	// functionname : [OptionButton.setFontUnderline]
	
	this.fontUnderline = fontUnderline;
	if( fontUnderline )
		this.tagObject.getElementsByTagName("span")[0].style.textDecoration = "underline";
	else
		this.tagObject.getElementsByTagName("span")[0].style.textDecoration = "none";
};

/**
 *       @description    옵션버튼 라벨의 표시문자열을 설정합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *       @param          caption     {String}        표시문자열에 보여줄 문자열을 입력합니다.
 *       @return         표시문자열 설정에 성공한다면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
 *       @example        var wControl= controls["optionbox_5"];
 *        //옵션버튼 라벨의 표시문자열을 "옵션버튼2"로 설정합니다.
 *        if( false == wControl.setCaption("옵션버튼2") ){
 *             //옵션버튼 라벨 설정을 실패하였습니다. 에러처리 코드를 입력해주세요.
 *             //옵션버튼 라벨 설정 실패하거나 에러 발생시 setCaption 메소드는 false 를 반환합니다.
 *             //에러에 관한 메세지는 optBox.errorMsg 필드로 확인할 수 있습니다.
 *        }
 */
OptionButton.prototype.setCaption = function(caption){
	// functionname : [OptionButton.setCaption]
	
	this.caption = caption;
	this.tagObject.getElementsByTagName("span")[0].innerText = caption;
};

OptionButton.prototype.setValueToDefault = function(){
	// functionname : [OptionButton.setCaption]
	
	this.matchUpWith(0);
};

/**
 * @description    미결
 * @return         {String}
 * @example        미결
 */
OptionButton.prototype.addOptionGroup = function(){
	// functionname : [OptionButton.setCaption]
	
	//var optionGroupName = this.controlName.substring(0, this.controlName.length-1);
	var optionGroupName = (this.tagObject.getElementsByTagName("input")[0]).name;
	
	if( typeof controls[optionGroupName] == "undefined" )
		controls[optionGroupName] = new OptionGroup(optionGroupName, optionGroupName, this.tagObject.parentElement);
	
	return optionGroupName;
};

/**
 * @name 			OptionButton#optionLabel_Click
 * @event
 * @return			{boolean}
 * @description   	미결
 */
function optionLabel_Click(e){
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_OptionButton(em);
	
	control.tagObject.getElementsByTagName("input")[0].click();
	
	stopPropagation(e);
	
	return true;
};

/**
 * @name 			OptionButton#optionbutton_Click
 * @event
 * @description   	미결
 */
function optionbutton_Click(e){
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_OptionButton(em);
	var oldValue = control.value;
	var newValue = (control.tagObject.getElementsByTagName("input")[0].checked ? 1 : 0);
	
	if( "" + oldValue == "" + newValue )
		return true;
	
	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		checkEvent = false;
		try{
			if (eval(control.controlId + "_onclick")) checkEvent = true;
		} catch(e){}
		
		if( checkEvent ){
			var result = eval(control.controlId + "_onclick();");
			if( typeof(result)=="boolean" && result == false )
				return result;
		}
	}
	
	control.setValue(newValue);
	
	stopPropagation(e);
	
	return true;
};
/**
 * @name 			OptionButton#optionbutton_KeyDown
 * @event
 * @return			{boolean}
 * @description   	미결
 */
function optionbutton_KeyDown(e){
	//F5새로고침 방지 추가
	if( e.keyCode == 116 ){
		if( typeof e.preventDefault == "function" )
			e.preventDefault();
		else
			e.returnValue = false; // for IE
		
		return false;
	}
	
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var wKeyCode = e.keyCode;
	var control = searchControl_OptionButton(em);
	
	if( wKeyCode == 9 ){
		if( getShiftKeyPressed(e) ){
			stopEvent(e);
			setTimeout("setFocusToFormerControl(\"" + control.controlName + "\")", 0);
			return true;
		}
		else{
			stopEvent(e);
			setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
			return true;
		}
	}
	else if( wKeyCode == 13 ){
		stopEvent(e);
		control.tagObject.getElementsByTagName("input")[0].click();
		setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
		return true;
	}
	
	stopPropagation(e);
	
	// e.returnValue = true;
	
	return true;
};


///////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *       @class          OptionGroup 컨트롤 클래스                                                     
 *       @constructor    OptionGroup
 *
 *       @param          controlId       해당 컨트롤의 ID를 지정합니다.
 *       @param          controlName     해당 컨트롤의 Name을 지정합니다.
 *       @param          tagObject       해당 컨트롤의 태그 객체를 지정합니다.
 *
 *       @return         반환값 없음
 *
 *       @example        미결
 */
function OptionGroup(controlId, controlName, tagObject){
	// 상속선언부
	this.base = ControlBase;						//부모클래스 지정
	this.base(controlId, controlName, tagObject);	//부모클래스 생성자호출
	
	this.name = controlName;
	
	this.columnCount = 0;
	
	// 하위콘트롤정보 세팅
	
	// 이벤트 처리 
	// rad_coni_OnChanged(obj,strCode,strText,nOldIndex,nNewIndex)
};

OptionGroup.prototype = new ControlBase(); // 의미없음 코딩 편의기능을 활용하기 위함

/**
 * @description	미결
 * @param 		{String}	value
 * @return		{undefined}
 * @example		미결
 */
OptionGroup.prototype.setValue = function(value){
	for(var key in controls){
		var ctl = controls[key];
		
		if( typeof(ctl)=="function" )			continue;
		if( !(ctl instanceof OptionButton) )	continue;
		if( ctl.optionGroupName != this.name )	continue;
		
		if( !this.passEvent )
			ctl.passEvent = true;
		
		if( "" + ctl.matchUpValue == "" + value )
			ctl.setValue(1);
		else
			ctl.setValue(0);
		
		if( !this.passEvent )
			ctl.passEvent = false;
	}
};

/**
 * @description	미결
 * @param 		{String}	text
 * @return		{undefined}
 * @example		미결
 */
OptionGroup.prototype.setText = function(text){
	for(var key in controls){
		var ctl = controls[key];
		
		if( typeof(ctl)=="function" )			continue;
		if( !(ctl instanceof OptionButton) )	continue;
		if( ctl.optionGroupName != this.name )	continue;

		var tagText = "" + ctl.tagObject.parentElement.innerText;
		tagText = tagText.trim();

		if( !this.passEvent )
			ctl.passEvent = true;
		
		if( tagText.trim() == text.trim() )
			ctl.setValue(1);
		else
			ctl.setValue(0);
		
		if( !this.passEvent )
			ctl.passEvent = false;
	}
};

/**
 * @description	미결
 * @return		{void}
 * @example		미결
 */
OptionGroup.prototype.getValue = function(){
	for(var key in controls){
		var ctl = controls[key];
	
		if( typeof(ctl)=="function" )			continue;
		if( !(ctl instanceof OptionButton) )	continue;
		if( ctl.optionGroupName != this.name )	continue;
		
		if( ctl.value == 1 )
			return ctl.matchUpValue;
	}
};

/**
 * @description	미결
 * @param 		{String}	index
 * @return		{undefined}
 * @example		미결
 */
OptionGroup.prototype.setIndex = function(index){
	var idx = 1;

	for(var key in controls){
		var ctl = controls[key];
	
		if( typeof(ctl)=="function" )			continue;
		if( !(ctl instanceof OptionButton) )	continue;
		if( ctl.optionGroupName != this.name )	continue;
		
		if( idx == index && index > 0 ){
			if( !this.passEvent )
				ctl.passEvent = true;
			
			ctl.setValue(1);
			
			if( !this.passEvent )
				ctl.passEvent = false;
			
			return;
		}
		else{
			ctl.value = 0;
			ctl.tagObject.getElementsByTagName("input")[0].checked = false;
		}
		
		idx++;
	}
};

/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
OptionGroup.prototype.getText = function(){
	for(var key in controls){
		var ctl = controls[key];
		
		if( typeof(ctl)=="function" )			continue;
		if( !(ctl instanceof OptionButton) )	continue;
		if( ctl.optionGroupName != this.name )	continue;
		
		if( ctl.value == 1 )
			return ("" + ctl.tagObject.innerText).trim();
	}
	
	return "";
};

/**
 * @description	미결
 * @return		{number}
 * @example		미결
 */
OptionGroup.prototype.getIndex = function(){
	var idx = 1;

	for(var key in controls){
		var ctl = controls[key];
		
		if( typeof(ctl)=="function" ) 			continue;
		if( !(ctl instanceof OptionButton) ) 	continue;
		if( ctl.optionGroupName != this.name )	continue;
	
		if( ctl.value == 1 )
			return idx;
		
		idx++;
	}
	
	return -1;
};

/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
OptionGroup.prototype.getColumnCount = function(){
	var cnt = 0;
	
	for(var key in controls){
		var ctl = controls[key];
		
		if( typeof(ctl)=="function" ) 			continue;
		if( !(ctl instanceof OptionButton) ) 	continue;
		if( ctl.optionGroupName != this.name )	continue;
		
		cnt++;
	}
	
	return cnt;
};

/**
 * @description	미결
 * @return		{void}
 * @example		미결
 */
OptionGroup.prototype.setFocus = function(){
	for(var key in controls){
		var ctl = controls[key];
		
		if( typeof(ctl)=="function" )			continue;
		if( !(ctl instanceof OptionButton) )	continue;
		if( ctl.optionGroupName != this.name )	continue;
		
		if( ctl.value == 1 )
			ctl.tagObject.focus();
	}
	
	return;
};


var dialogPopupItems = {};
/**
	* @class CommandButton 기능키
	* @constructor    
	* @description ControlBase를 상속받고 해당 컨트롤의 ID, Name, 태그속성을 설정합니다.<br>
*  상수, 속성 선언 및 클릭 이벤트를 선언<br>
* @param {string} controlId 해당 컨트롤의 ID
* @param {string} controlName 해당 컨트롤의 Name
* @param {object} tagObject 해당 컨트롤의 태그 속성
* @return 반환값 없음
* @property {number} value 버튼 클릭시 0(default : 1)
* @property {boolean} mouseover 마우스 오버시 true(default : false)
* @property {number} commandType 버튼의 타입(default : 0)
* @property {array} objectNames 연결된 객체명들
* @property {number} FORM_CLEAR  버튼타입 1 : Clear
* @property {number} FORM_DEL 버튼타입 2 : 삭제
* @property {number} FORM_WRITE 버튼타입 3 : 확인
* @property {number} FORM_END 버튼타입 4 : 종료
* @property {number} GW_ROUTE 버튼타입 5 : 결재경로
* @property {number} SEARCH 버튼타입 6 : 찾기
* @property {number} CHECK 버튼타입 7 : 체크
* @property {number} ADDROW 버튼타입 8 : 신규항목추가
* @property {number} DELROW 버튼타입 9 : 현재항목삭제
* @property {number} MOVEUP 버튼타입 10 : 한줄위로
* @property {number} MOVEDOWN 버튼타입 11 : 한줄아래로
* @property {number} FORM_APPLY 버튼타입 12 : 값넘겨주기
* @property {number} FORM_CALL 버튼타입 13 : 다른화면부르기
* @property {number} BATCH_CALL 버튼타입 14 : 서비스(Batch)호출
* @property {number} GW_CALLCAT 버튼타입 15 : 그룹웨어분류코드
* @property {number} REPORTCALL 버튼타입 16 : 레포트(Report)보기
* @property {number} MAKENUM 버튼타입 17 : 번호부여하기
* @property {number} BAT_REPORT 버튼타입 18 : 배치+레포트
* @property {number} BRINGDATA 버튼타입 19 : 전단계조회키
* @property {number} CROSSVIEW_X 버튼타입 20 : CrossTab 보기(사용안함)
* @property {number} SELSVRFILE 버튼타입 21 : 화일선택(FTP서버,중복방지 이름변경)
* @property {number} CHARTVIEW 버튼타입 22 : Chart 보기
* @property {number} CROSSPRT_X 버튼타입 23 : CrossTab 인쇄(사용안함)
* @property {number} CROSSVIEW 버튼타입 24 : 분석레포트(Cross)보기
* @property {number} SAVE_XLS 버튼타입 25 : 엑셀(Excel)로 저장
* @property {number} SELBINARY 버튼타입 26 : 화일선택(FTP 이진데이타)
* @property {number} GW_RETURN 버튼타입 27 : 반송
* @property {number} CROSSPREVW 버튼타입 28 : 분석시트미리보기
* @property {number} CROSSPRINT 버튼타입 29 : 분석시트인쇄
* @property {number} CROSS_XLS 버튼타입 30 : 분석시트엑셀저장
* @property {number} EXCELBATCH 버튼타입 31 : 엑셀배치
* @property {number} SELCLIFILE 버튼타입 33 : 화일선택(그림파일 파일명만)
* @property {number} EXECOMMAND 버튼타입 34 : EXE실행
* @property {number} DWNLOADXLS 버튼타입 35 : 엑셀다운로드
* @property {number} DWNLOADFILE 버튼타입 36 : 파일받기
* @property {number} SHOWCALNDR 버튼타입 37 : 칼렌더보기
* @property {number} FLASH_ACT 버튼타입 38 : 플레시동작 호출
* @property {number} OBJECTLOAD 버튼타입 39 : 객체채우기
* @property {number} UPLOADCLIP 버튼타입 40 : 클립보드업로드
* @property {number} SHOWHELP 버튼타입 41 : 도움말표시
* @property {number} ETC 버튼타입 99 : 버튼타입 ETC
*/
function CommandButton(controlId, controlName, tagObject){
    // 상속선언부
    /**
	    * @description	미결
	    */
    this.base = ControlBase;              			//부모클래스 지정
    this.base(controlId, controlName, tagObject);   //부모클래스 생성자호출
    
    // 상수 선언부
    this.COMMANDTYPE = {
    		FORM_CLEAR : 1	, // Clear
    		FORM_DEL   : 2	, // 삭제
    		FORM_WRITE : 3	, // 확인
    		FORM_END   : 4	, // 종료
    		GW_ROUTE   : 5	, // 결재경로
    		SEARCH     : 6	, // 찾기
    		CHECK      : 7	, // 체크
    		ADDROW     : 8	, // 신규항목추가
    		DELROW     : 9	, // 현재항목삭제
    		MOVEUP     : 10,  // 한줄위로
    		MOVEDOWN   : 11,  // 한줄아래로
    		FORM_APPLY : 12,  // 값넘겨주기
    		FORM_CALL  : 13,  // 다른화면부르기
    		BATCH_CALL : 14,  // 서비스(Batch)호출
    		GW_CALLCAT : 15,  // 그룹웨어분류코드
    		REPORTCALL : 16,  // 레포트(Report)보기
    		CROSSVIEW  : 24,  // 분석레포트(Cross)보기
    		MAKENUM    : 17,  // 번호부여하기
    		BAT_REPORT : 18,  // 배치+레포트
    		BRINGDATA  : 19,  // 전단계조회키
    		CROSSVIEW_X: 20,  // CrossTab 보기:사용안함
    		CROSSPRT_X : 23,  // CrossTab 인쇄:사용안함
    		SELSVRFILE : 21,  // 화일선택(FTP서버,중복방지 이름변경)
    		CHARTVIEW  : 22,  // Chart 보기
    		SAVE_XLS   : 25,  // 엑셀(Excel)로 저장
    		SELBINARY  : 26,  // 화일선택(FTP 이진데이타)
    		GW_RETURN  : 27,  // 반송
    		CROSSPREVW : 28,  // 분석시트미리보기
    		CROSSPRINT : 29,  // 분석시트인쇄
    		CROSS_XLS  : 30,  // 분석시트엑셀저장
    		EXCELBATCH : 31,  // 엑셀배치
    		SELCLIFILE : 33,  // 화일선택 (그림파일 파일명만)
    		EXECOMMAND : 34,  // EXE실행
    		DWNLOADXLS : 35,  // 엑셀다운로드
    		DWNLOADFILE: 36,  // 파일받기
    		SHOWCALNDR : 37,  // 칼렌더보기
    		FLASH_ACT  : 38,  // 플레시동작 호출
    		OBJECTLOAD : 39,  // 객체채우기
    		UPLOADCLIP : 40,  // 클립보드업로드
    		SHOWHELP   : 41,  // 도움말표시
    		ETC: 99};
    
    // 속성 선언부

	this.value = 1; // (1/0)
	this.mouseover = false; 
    this.commandType = 0;
    this.objectNames = [];
    
    this.uploadFrame = null;
    this.uploadSWF = null;
    
    if (tagObject.getAttribute("linkedobjectnames") != null && tagObject.getAttribute("linkedobjectnames") != ""){
    	this.objectNames = tagObject.getAttribute("linkedobjectnames").split(",");
    }
    // 이벤트 선언부
     setEventHandler(this.tagObject, "click",    commandbutton_Click);
    
    // DIV 버튼의 처리부
    if (this.tagObject.tagName != "BUTTON"){
    	var childDiv = this.tagObject.getElementsByTagName("div")[0];
        setEventHandler(this.tagObject, "focus",     commandbutton_Focus);
        setEventHandler(this.tagObject, "blur",      commandbutton_Blur);
        setEventHandler(this.tagObject, "mousemove", commandbutton_MouseMove);
        setEventHandler(this.tagObject, "mousedown", commandbutton_MouseDown);
        setEventHandler(this.tagObject, "mouseup",   commandbutton_MouseUp);
        setEventHandler(this.tagObject, "mouseout",  commandbutton_MouseOut);
        setEventHandler(this.tagObject, "keydown",   commandbutton_KeyDown);
        setEventHandler(this.tagObject, "keyup",     commandbutton_KeyUp);
    }
    
    if(tagObject){
    	/*수정일:2018.01.08 
    	 *수정자:김재익
    	 *IE에서 높이를 계산할때 보더라인을 제외한 높이가 계산되어 텍스트라벨이 중앙에 오지 않음
    	 *화면 CSS 에서 lineHeight을 넣어줌
    	 **/
    	//버튼 line-height 설정
//    	this.tagObject.style.lineHeight = getStyle(this.tagObject).height; 
    	//버튼 탭인덱스 설정
    	this.tagObject.setAttribute("tabIndex", "999");
    }

    // 안에  DIV가 있으면 클릭이벤트에 blur가 호출 되는 IE버그 해결용
    /**
     * @description	미결
     */
    this.stateMouseDown = false;
    
//	this.image = tagObject.className;
    /**
	 * 2016-06-23 김재익
     * 버튼동작 투명도 조정
     */
    if (tagObject.getAttribute("disabled") == "true") {
//    	tagObject.style.opacity = "0.6";
//    	tagObject.style.filter = 'Alpha(Opacity=60)';
    	this.tagObject.classList.remove(this.image);
		this.tagObject.classList.add(this.image+"-disabled");
    }
};

CommandButton.prototype = new ControlBase(); // 의미없음 코딩 편의기능을 활용하기 위함

/* 포커스 주기*/
/**
 * @description 컨트롤에 포커스를 지정합니다.
 * @return {boolean} wReturn  true : 포커스 얻음, false : 포커스 잃음
 * @return {boolean} true를 리턴합니다. 에러발생시 false 리턴
 */
CommandButton.prototype.focus = function(){
	// functionname : [CommandButton.focus]
	                   
   	var wReturn = true;
	try {
		this.tagObject.focus();
	} catch (e){
		wReturn = false;
	}
	return wReturn;
};

/**
 * @description 버튼의 타입을 설정합니다.
 * @param {number} commandType 버튼의 타입 상수값이 들어있는 속성
 * @return 반환값 없음
 */
CommandButton.prototype.setCommandType = function(commandType){
	// functionname : [CommandButton.setCommandType]
		               	
	this.commandType = commandType;
};
/**
 * @description 버튼의 활성화/비활성화 설정입니다.
 * @param {string} enabled 활성화상태(비활성화 : disabled)
 * @return 반환값 없음
 */
CommandButton.prototype.setEnabled = function(enabled){
	// functionname : [Control.setEnabled]
	                   this.enabled = enabled;
	// 하위 테그들의 글자색 조정
    this.tagObject.disabled = !enabled;
	for (var i = 0; i < this.tagObject.children.length;i++){
		childTag = this.tagObject.children[i];
		childTag.disabled = !enabled;
		for (var j = 0; j < childTag.children.length;j++){
			childTag.children[j].disabled = !enabled;
		}
	}
	if (this.uploadFrame != null) {
		this.uploadFrame.setEnabled(enabled);
	}
	
	if (enabled){
	    this.tagObject.setAttribute("tabIndex", "999");
	} else {
	    this.tagObject.setAttribute("tabIndex", "-1");
	}
	setCommonButton(this);
	
	/**
	 * 2016-06-23 김재익
     * 버튼동작 투명도 조정
     */
	if (!enabled) {
//		this.tagObject.style.opacity = "0.6";
//		this.tagObject.style.filter = "Alpha(Opacity=60)";
		this.tagObject.classList.remove(this.image);
		this.tagObject.classList.add(this.image+"-disabled");
    } else {
//    	this.tagObject.style.opacity = "";
//    	this.tagObject.style.filter = "";
    	this.tagObject.classList.remove(this.image+"-disabled");
    	this.tagObject.classList.add(this.image);
    }
};

/**
 * @description 해당 버튼 컨트롤을 찾아 ID값을 반환합니다.
 * @param {object} em 해당 컨트롤 태그객체
 * @return wReturn 컨트롤의 ID값을 저장
 */
function searchControl_CommandButton(em){
	var pEm = null;
	var image = null;
	var wReturn = null;
	
	try{
		pEm = em;
		image = pEm.getAttribute("image");
		
//		while (pEm.parentNode && !pEm.className.startsWith("CommandButton")) 
//			pEm = pEm.parentNode;
//		if (pEm.className.startsWith("CommandButton")) 
//		    wReturn = getControlById(pEm.id);
		
		while( pEm.parentNode && pEm.tagName.toLowerCase() != "body" && image !== "CommandButton" ){
			pEm = pEm.parentNode;
			image = pEm.getAttribute("image");
		}
		
		if( pEm.getAttribute("image") === "CommandButton" ){
			wReturn = getControlById(pEm.id);
		}
		else{
			pEm = null;
			pEm = em;
			
			while(pEm.parentNode && !pEm.className.startsWith("CommandButton"))
				pEm = pEm.parentNode;
			
			if( pEm.className.startsWith("CommandButton") ) 
				wReturn = getControlById(pEm.id);
		}
		
		image = null;
		pEm = null;
	}
	catch(e){}
	
	return wReturn;
};

/**
 * @description 버튼 컨트롤의 텍스트 정렬상태를 설정합니다(왼쪽정렬, 오른쪽정렬, 가운데정렬)
 * @param {string} alignment 텍스트 정렬 값(right, left, center)
 * @return 반환값 없음
 */
CommandButton.prototype.setAlignment = function(alignment){
	// functionname : [CommandButton.setAlignment]
		               	
	this.alignment = alignment;
    this.tagObject.getElementsByTagName("span")[0].style.textAlign = alignment;
};
/**
 * @description 버튼 컨트롤의 텍스트 굵기를 설정합니다.
 * @param {boolean} fontBold 텍스트 굵기 설정 값(true : bold, false : normal)
 * @return 반환값 없음
 */
CommandButton.prototype.setFontBold = function(fontBold){
	// functionname : [CommandButton.setFontBold]
		               	
	this.fontBold = fontBold;
    wValue = (fontBold == "true" ? "bold" : "normal");
    this.tagObject.getElementsByTagName("span")[0].style.fontWeight = wValue;
};
/**
 * @description 버튼 컨트롤 텍스트의 이텔릭체 적용여부를 설정합니다.
 * @param {boolean} fontItalic 이텔릭체 설정 값(true : italic, false : normal)
 * @return 반환값 없음
 */
CommandButton.prototype.setFontItalic = function(fontItalic){
	// functionname : [CommandButton.setFontItalic]
		               	
	this.fontItalic = fontItalic;
    wValue = (fontItalic == "true" ? "italic" : "normal");
    this.tagObject.getElementsByTagName("span")[0].style.fontStyle = wValue;
};
/**
 * @description 버튼 컨트롤 텍스트의 글꼴을 설정합니다.
 * @param {string} fontName 글꼴이름
 * @return 반환값 없음
 */
CommandButton.prototype.setFontName = function(fontName){
	// functionname : [CommandButton.setFontName]
		               	
	this.fontName = fontName;
    this.tagObject.getElementsByTagName("span")[0].style.fontFamily = fontName;
};
/**
 * @description 버튼 컨트롤 텍스트의 글씨 사이즈를 설정합니다.
 * @param {number} fontSize 글씨 사이즈 값
 * @return 반환값 없음
 */
CommandButton.prototype.setFontSize = function(fontSize){
	// functionname : [CommandButton.setFontSize]
		               	
	this.fontSize = fontSize;
    this.tagObject.getElementsByTagName("span")[0].style.fontSize = fontSize + "pt";
};
/**
 * @description 버튼 컨트롤 텍스트의 취소선을 설정합니다.
 * @param {boolean} fontStrikethru 취소선 설정 값(true : line-through, false : none)
 * @return 반환값 없음
 */
CommandButton.prototype.setFontStrikethru = function(fontStrikethru){
	// functionname : [CommandButton.setFontStrikethru]
		               	
	this.fontStrikethru = fontStrikethru;
	if (fontStrikethru){
		this.tagObject.getElementsByTagName("span")[0].style.textDecoration = "line-through";
	} else {
		this.tagObject.getElementsByTagName("span")[0].textDecoration = "none";
	}
};
/**
 * @description 버튼 컨트롤 텍스트의 밑줄을 설정합니다.
 * @param {boolean} fontunderline 밑줄 설정 값(true : underline, false : none)
 * @return 반환값 없음
 */
CommandButton.prototype.setFontUnderline = function(fontUnderline){
	// functionname : [CommandButton.setFontUnderline]
		               	
	this.fontUnderline = fontUnderline;
	if (fontUnderline){
        this.tagObject.getElementsByTagName("span")[0].style.textDecoration = "underline";
	} else {
        this.tagObject.getElementsByTagName("span")[0].style.textDecoration = "none";
	}
};
/**
 * @description 단축키로 지정한 버튼의 텍스트에 핫키로 지정한 문자에 밑줄을 넣어줍니다.<br>
 * 단축키 지정 문자 앞에 &를 넣어주면 &앞의 문자에 밑줄을 넣은 후 텍스트에서 &를 빼고 반환합니다.
 * @param {string} pStr 버튼의 텍스트 문자열
 * @param {string} pKey 핫키 지정 문자
 * @example getAccessText(Se&arch,a)	return Se<u>a</u>rch
 * @return {string} wStr 밑줄을 넣은 문자를 반환한다.
 */
CommandButton.prototype.getAccessText = function(pStr, pKey){
	// functionname : [CommandButton.getAccessText]

	var wIndex = pStr.indexOf("&");
    if (wIndex == -1) return pStr;
    
    pKey = pStr.substring(wIndex + 1, wIndex + 2);
    var wStr = pStr.substring(0,wIndex);
    wStr += "<u>";
    wStr +=  pStr.substring(wIndex + 1, wIndex + 2);
    wStr += "</u>";
    wStr +=  pStr.substring(wIndex + 2);
    
    return wStr;
};
/**
 * @description 버튼 컨트롤의 핫키를 지정합니다.<br>
 * 단축키로 지정할 문자 앞에 &를 넣어주면 &앞의 문자를 핫키로 지정합니다.
 * @param {string} pStr 버튼의 텍스트 문자열
 * @exaple getAccessKey(Se&arch)	return : a
 * @return 지정된 핫키 문자값
 * 
 */
CommandButton.prototype.getAccessKey = function(pStr){
	// functionname : [CommandButton.getAccessKey]

    var wIndex = pStr.indexOf("&");
    if (wIndex == -1) return pStr;
    
    var wKey = pStr.substring(wIndex + 1, wIndex + 2);
    return wKey;
};
/**
 * @description 핫키에 툴팁을 달아줍니다.
 * @param {string} caption 툴팁 설명글
 * @return 반환값 없음
 */
CommandButton.prototype.setCaption = function(caption){
	// functionname : [CommandButton.setCaption]

	this.caption = caption;
	
    var wKey = this.getAccessKey(caption);
    var wStr = this.getAccessText(caption);
    this.tagObject.getElementsByTagName("span")[1].innerHTML = wStr;
    if (wKey.length > 0) this.tagObject.setAttribute("accessKey", wKey);
};
/**
 * @description	미결
 * @param	{string}	linkname
 * @param	{string}	picname
 * @param	{string}	ftpDir
 * @param	{string}	noftp
 * @param	{string}	nozip
 * @param	{Object}	directUploadGu
 * @return	{undefined}
 * @example	미결
 */
CommandButton.prototype.selectFile = function(linkname, picname, ftpDir, noftp, nozip, directUploadGu){
	// functionname : [CommandButton.selectFile]

    if (jUploadPrefix.length == 0) jUploadPrefix = timeEncodeString();
    var IFrameLayer = document.getElementById("IFrameLayer");  
    this.uploadFrame = new IFrame_Upload(IFrameLayer, jUploadPrefix + this.controlName, linkname, picname, ftpDir, noftp, nozip, directUploadGu);
    
    this.uploadFrame.selectFile();

};
/**
 * @description 선택된 파일을 삭제합니다.
 * @param {string} fileName 삭제할 파일 네임
 * @return 반환값 없음
 */
CommandButton.prototype.removeUploadFile = function(fileName){
	// functionname : [CommandButton.removeUploadFile]
	                   
	if (this.uploadFrame)
		this.uploadFrame.deleteFileControl(fileName);
	if (this.uploadSWF)
		removeFile_SWF(this.uploadSWF, fileName);
};
/**
 * @description 업로드 버튼 입니다.
 * @return 반환값 없음
 */
CommandButton.prototype.uploadFile = function(){
	// functionname : [CommandButton.uploadFile]

	if (this.uploadFrame)
		this.uploadFrame.uploadFile();
	if (this.uploadSWF)
		uploadFile_SWF(this.uploadSWF);
	};

var clipFileNameControlName = "";
var clipFilePicControlName = "";

/**
 * @description 캡처한 화면을 저장합니다(윈도우 클립보드에 저장되어 있는 파일 업로드)<br>
 * iframe 태그객체(Name, id = upClip) src 속성에 파일경로가 입력됩니다. 
 * @param {string} picnamectlname 사진컨트롤명
 * @param {string} filenamrctlname 파일컨트롤 네임
 * @param {string} subDir 그림위치
 * @return 반환값 없음 
 */
CommandButton.prototype.uploadClipBoard = function(picnamectlname , filenamrctlname, subDir){
	// functionname : [CommandButton.uploadClipBoard]
	                   
	//if (jUploadPrefix.length == 0) {
	    // 무조건 새로딴다 USER_PERSONALID, USER_USERID둘다 없는 경우를 대비
		jUploadPrefix = timeEncodeString();
	//}

    var uploadPrefix = jUploadPrefix.substring(1,jUploadPrefix.length - 1);
    var picTag = controls[picnamectlname].tagObject;	
    var width  = parseIntSize(picTag.style.width) - 2;
    var height = parseIntSize(picTag.style.height) - 2;

    var src = getContextPath() + "/pages/groupware/clipboard/uploadClip.jsp";
    var id = (USER_USERID.length == 0 ? USER_PERSONALID : USER_USERID);
    var param = "?subDir=" + subDir + "&picName=" + uploadPrefix + id + ".jpg&width=" + width + "&height=" + height;

    controls[picnamectlname].tagObject.innerHTML = "<iframe name='upClip' id='upClip' src='" + src + param + "'></iframe>";
    
    clipFileNameControlName = filenamrctlname;
    clipFilePicControlName = picnamectlname;

    return;
};
/**
 * @description	미결
 * @return	{void}
 * @example	미결
 */
function clipUpload_Completed(){
    var id = (USER_USERID.length == 0 ? USER_PERSONALID : USER_USERID);
    var uploadPrefix = jUploadPrefix.substring(1,jUploadPrefix.length - 1);
	controls[clipFileNameControlName].setValue(uploadPrefix + id + ".jpg");
	return;
};

/**
 * @description	미결
 * @return	{void}
 * @example	미결
 */
function clipUpload_Failed(){
	controls[clipFileNameControlName].setValue("");
	controls[clipFilePicControlName].clear();
	return;
};
/**
 * @description 그림파일을 업로드해줍니다.
 * @param {string} filenamrctlname 업로드할 그림이 채워져있는 컨트롤네임입니다.
 * @param {string} picnamectlname 업로드할 파일 네임입니다.
 * @param {string} subDir 업로드할 파일의 경로입니다.
 * @return 반환값 없음
 */
CommandButton.prototype.loadPicture = function(filenamrctlname, picnamectlname , subDir){
	// functionname : [CommandButton.loadPicture]

    var svrFileName = controls[filenamrctlname].value;
    
    if (svrFileName == null || picnamectlname == null || subDir == null){
    	return;
    }
    if (svrFileName.trim().length == 0 || picnamectlname.trim().length == 0 || subDir.trim().length == 0){
    	return;
    }
    controls[picnamectlname].loadPicture(svrFileName, subDir);
    return;
};
/**
 * @description 시트에 있는 파일을 엑셀파일로 바꿔서 서버에 올립니다
 * @param {string} linkname 엑셀파일로 바꿀 시트의 네임
 * @return 반환값 없음
 */
CommandButton.prototype.makeExcelFile = function(linkname, templateXLSFileName, paramsJXLS, downFileName){
	// functionname : [CommandButton.makeExcelFile]
	
	downFileName = (typeof downFileName == "undefined") ? __FORM__NAME__ : downFileName;
	
	// AUIGrid 일때 엑셀 다운로드
	if(controls[linkname].auiGridProps) {
		controls[linkname].excelDownLoad(true, downFileName);
		return;
	}

	var generationInfo = controls[linkname].getDataForExcel();

    var IFrameLayer = document.getElementById("IFrameLayer");  
    var iframe = new IFrame_Excel(IFrameLayer, timeEncodeString() + this.controlName, generationInfo, templateXLSFileName, paramsJXLS, downFileName);
    iframe.submit();
};

CommandButton.prototype.makeExcelData = function(sqlnum, paramInfo, permitNull, environmentInfo, templateXLSFileName, paramsJXLS){
	// functionname : [CommandButton.makeExcelData]

	var parent = document.getElementsByName("IFrameLayer")[0];
	var action = "makeExcel.do" ;
	var params = [new Parameter("lang", USER_LANGUAGE),
	              new Parameter("cogu", USER_COGU),
	              new Parameter("personalId", USER_PERSONALID),
	              new Parameter("formid", USER_FORMID),
	              new Parameter("sqlnum", sqlnum),
	              new Parameter("permitNull", permitNull),
	              new Parameter("environmentInfo", environmentInfo),
	              new Parameter("paramInfo", paramInfo),
	              new Parameter("templateXLSFileName", templateXLSFileName),
	              new Parameter("paramsJXLS", paramsJXLS),
	              new Parameter("formName", document.title),
	              new Parameter("tm", (new Date()).valueOf())];
	
	var iFrame_DownLoad = new IFrame_DownLoad(parent, timeEncodeString() + this.controlName, action, params);
	iFrame_DownLoad.submit();

};
/**
 * @description 인쇄미리보기 버튼 입니다.
 * @param {string} linkname 인쇄할 파일 네임
 * @return 반환값 없음
 */
CommandButton.prototype.preview = function(linkname){
	// functionname : [CommandButton.preview]

	controls[linkname].preview();
};
/**
 * @description 인쇄 버튼 입니다.
 * @param {string} linkname 인쇄할 파일 네임
 * @return 반환값 없음
 */
CommandButton.prototype.print = function(linkname){
	// functionname : [CommandButton.print]

	controls[linkname].print();
};
/**
 * @description 달력버튼 입니다.
 * @param {string} linkname 날짜선택 결과가 들어갈 텍스트박스 네임 입니다.
 * @param {string} calendarType 달력의 타입입니다(yyymmdd, yyyymm, yyyy)
 * @return 반환값 없음
 */
CommandButton.prototype.showCalendar = function(linkname, calendarType){
	// functionname : [CommandButton.print]
	
	var control = controls[linkname];
	
	if( !control.enabled ) return false;
	
	var em = control.tagObject;
   	if (calendarType == 1){
		try {
	        popUpCalendar(em, control,'yyyymmdd',calendarType);
	    } catch (e){}
	} else if (calendarType == 2){
		try {
			//popUpMonthCalendar(em);
	        popUpCalendar(em, control,'yyyymm',calendarType);
	    } catch (e){}
	} else if (calendarType == 3){
		try {
			//popUpYear(em);
	        popUpCalendar(em, control,'yyyy',2);
	    } catch (e){} 
	}
    
   	return true;
};
/**
 * @description 숏컷키 입니다.
 * @param {string} pShortCutStr 선택된 숏컷키 문자 입니다.
 * @return 반환값 없음
 */
CommandButton.prototype.setShortCutKey = function(pShortCutStr){
	// functionname : [CommandButton.setShortCutKey]
	                   
	var controlName = this.controlName;
	shortcut.add(pShortCutStr, function() {
		controls[controlName].click();
	});
	return;
};
/**
 * @description 가져오기로 버튼 클릭시 발생하는 이벤트 입니다.
 * @event
 * 
 */
CommandButton.prototype.click = function(){
	// functionname : [CommandButton.click]
       // 사용자 코딩 추가영역을 호출한다
	if (!this.enabled) return false;
	
    var checkEvent = false;
   	try {
       	if (eval(this.controlId + "_onclick")) checkEvent = true;
    } catch(e){};

    if (checkEvent){
      var result = eval(this.controlId + "_onclick();");
      if (typeof(result)=="boolean") return result;
    };
    
    return true;

};

/*
 * 	2016-04-21 추가(차중훈)
 */
/**
 * @description	미결
 * @return  {boolean}
 * @example	미결
 */
CommandButton.prototype.uploadButtonClick = function(){
	// functionname : [CommandButton.excelUploadClick]
	
	if( !this.enabled )
		return false;
	
	var uploadFrame = null;
	var inputObjects = null;
	var inputObject = null;
	var isClicked = false;
	var i = 0;
	
	// 엑셀업로드, 파일업로드 버튼인 경우 버튼을 클릭하면 업로드 파일 선택창이 뜨도록 수정
	uploadFrame = this.uploadFrame;
	
	if( typeof uploadFrame != "undefined"
		&& uploadFrame != null
		&& (uploadFrame instanceof IFrame_UploadXL_Command 
			|| uploadFrame instanceof IFrame_UploadXL_CommandA
			|| uploadFrame instanceof IFrame_Upload_Command
			|| uploadFrame instanceof IFrame_UploadFRD_Command) 
	){
		//링크 컨트롤 체크
		var iframeName = uploadFrame.frm.getAttribute("target");
		var iframeObject = document.getElementsByName(iframeName)[0];
		var linkName = null;
		var linkObject = null;
		var isListBox = false;
		
		if( iframeObject != null && typeof iframeObject != "undefined" ){
			linkName = iframeObject.getAttribute("linkname");
			linkObject = document.getElementsByName(linkName)[0];
			
			if( linkObject != null && typeof linkObject != "undefined" )
				isListBox = /^ListBox.*/.test(linkObject.getAttribute("class"));
			
			//메모리 해제
			linkObject = null; linkName = null;
		}
		
		inputObjects = uploadFrame.frm.getElementsByTagName("input");
		
		for(i = 0; i < inputObjects.length && !isClicked; i++, inputObject = null){
			inputObject = inputObjects[i];
			
			//타입이 파일이면서 아직 파일을 선택하지 않은  inputObject를 클릭
			if( inputObject.getAttribute("type") == "file" && isListBox && inputObject.files.length <= 0 ){
				inputObject.click();
				isClicked = true;
			}
			else if( inputObject.getAttribute("type") == "file" && !isListBox ){
				inputObject.click();
				isClicked = true;
			}
		}
		
		//메모리 해제
		iframeObject = null; iframeName = null; inputObjects = null;
	}
	
	//메모리 해제
	uploadFrame = null;
    
    return isClicked;
};
/*
 * 	2016-04-21 추가(차중훈)
 */
/**
 * @description	미결
 * @param	{string}	formID
 * @param	{number}	width
 * @param	{number}	height
 * @return	{void}
 * @example	미결
 */
CommandButton.prototype.openDialogPopup = function(formID, width, height){
	
	//2. 파라메터 설정
    var queryString = "lang=" + USER_LANGUAGE + "&";
    queryString += "userId=" + USER_USERID + "&";
    if (typeof window.top != "undefined" && typeof window.top.tmpl != "undefined") queryString += "tmpl=" + window.top.tmpl + "&";
	
	//1. 화면 사이즈 & 위치 정보 계산
	var left = 0;
	var top = 0;
	// IE 6 이하 버전의 경우 너비와 높이를 재설정
   	if (BrowserDetect.browser == "Explorer" && !isNaN(parseFloat(BrowserDetect.version)) && parseFloat(BrowserDetect.version) < 7 ) {
   		width += 10;
   		height += 35;
   	}
   	
   	// 팝업의 위치를 브라우저의 중앙으로 이동
   	left = Math.ceil( (window.screen.width - width) / 2 );
    top = Math.ceil( (window.screen.height - height) / 2 );
	
    var paramKeyStr = USER_FORMID + "." + this.controlId;
    var paramKeyLength = paramKeyStr.length;
    var params = null;
    var key = null;
    
    // localstorage를 지원하지 않은 경우 또는 기존 소스의 호환이 필요한 경우
    if( !IS_AVAILABLE_LOCALSTORAGE && typeof PARAMETER != "undefined" ){
    	params = {};
    	for(key in PARAMETER.parameterItems){
    		if( key.substring(0, paramKeyLength) != paramKeyStr ) continue;
    		
    		params[key.substring(paramKeyLength + 1)] = PARAMETER.getParameter(key);
    		key = null;
    	}
    }
    // localstorage가 사용 가능한 경우 : 파라메터 키를 URL로 전달
    else{
    	queryString += "paramKey=" + paramKeyStr + "&";
    }
    
    //3. URL 설정
    var url = getContextPath() + "/FlexForm_" + formID + "_Load.do?";
    // 테스트 모드(WebRun실행)인 경우 URL 재설정
    if( typeof TEST_MODE != undefined && TEST_MODE ){
		url = getContextPath() + "/test/FlexForm_" + formID + "_Load.do?";
	}
    
    // URL로 전달되는 파라메터 추가
    url += queryString + "tm=" + (new Date()).valueOf();
    
    //4. 화면 호출
    var str = "";
	str += "<html>";
	str += "<head>";
	str += "</head>"
	str += "<body>";
	str += "	<form id='callpopup' name='callpopup' method='post' action='" + url + "'>";
	if( params != null ){
		str += "		<input type='hidden' name='params' id='params' value=\"" + encodeURIComponent( JSON.stringify(params) ) + "\"/>";
	}
	str += "	</form>";
	str += "</body>";
	str += "<script>";
	str += " 	/*alert('callform');*/";
	str += " 	setTimeout(function(){ document.getElementsByName('callpopup')[0].submit(); }, 0);";
	str += "</script>";
	str += "</html>";
	
	modalCommandId = this.controlId;
	// 빈 팝업 다이얼로그 오픈
	if( typeof dialogPopupItems[modalCommandId] == "undefined" || (typeof dialogPopupItems[modalCommandId] != "undefined" && dialogPopupItems[modalCommandId].closed == true) ){
		if( !IS_IE9_OR_LOWER_VERSION ){
			var args = "width=" + width + ",height=" + height + ",toolbar=0,left=" + left + ",top=" + top + ",location=0,status=0,menubar=0,scrollbars=1,resizable=0";
			dialogPopupItems[modalCommandId] = modalDialogWindow = window.open("about:blank", "popup_" + this.controlId, args);
		}
		else{
			var winstyle = "status=no,width=" + width + ",height=" + height + ",menubar=no,scrollbars=no,left=" + left + ",top=" + top;
			window.margs = [this.controlId, "NO"];
			dialogPopupItems[modalCommandId] = modalDialogWindow = window.open(url, "popup_" + this.controlId, winstyle);
		}
	}
	//팝업내 소스 적용 및 화면 호출
	dialogPopupItems[modalCommandId].document.write("");
	dialogPopupItems[modalCommandId].document.write(str);
	
	// 팝업 다이얼로그 포커스 이동
	try { modalDialogWindow.focus(); } catch(e) { }
	
	return;
};
/**
 * @description	미결
 * @param	{string}	formID
 * @param	{number}	width
 * @param	{number}	height
 * @return	{void}
 * @example	미결
 */
CommandButton.prototype.openLayerPopup = function(formID, width, height){
	//레이어팝업 최대 크기(기본값)
	var MAX_WIDTH = 1024;
	var MAX_HEIGHT = 768;
	//레이어팝업 컨트롤
	var wControl = controls["layerPopupIframe"];
	//레이어팝업 파라메터 초기화
	delete wControl.parameters;
	
	//1. 파라메터 설정
	var queryString = "lang=" + USER_LANGUAGE + "&";   
	queryString += "userId=" + USER_USERID + "&";
    if (typeof top.tmpl != "undefined") queryString += "tmpl=" + top.tmpl + "&";
    
    var paramKeyStr = USER_FORMID + "." + this.controlId;
    var paramKeyLength = paramKeyStr.length;
    var params = null;
    var key = null;
    
    // localstorage를 지원하지 않은 경우 또는 기존 소스의 호환이 필요한 경우
    if( !IS_AVAILABLE_LOCALSTORAGE && typeof PARAMETER != "undefined" ){
    	wControl.parameters = [];
    	
    	for(key in PARAMETER.parameterItems){
    		if( key.substring(0, paramKeyLength) != paramKeyStr ) continue;
    		
    		wControl.parameters[key.substring(paramKeyLength + 1)] = PARAMETER.getParameter(key);
    		key = null;
    	}
    }
    // localstorage가 사용 가능한 경우 : 파라메터 키를 URL로 전달
    else{
    	queryString += "paramKey=" + paramKeyStr + "&";
    }
		
    //2. URL 설정
    wControl.action = getContextPath() + "/FlexForm_" + formID + "_Load.do?" + queryString + "tm=" + (new Date()).valueOf();
	if (TEST_MODE != undefined && TEST_MODE){
        wControl.action = getContextPath() + "/test/FlexForm_" + formID + "_Load.do?" + queryString + "tm=" + (new Date()).valueOf();
    }
	
	//3. 페이지 호출
	if (window.postMessage){
        modalCommandId = this.controlId;
        modalDialogWindow = wControl.iframe.contentWindow;
	}
	
	// 페이지 이동
    wControl.moveToPage();
    wControl.tagObject.getElementsByTagName("IFRAME")[0].style.height = height + 'px';
    
    //4. 레이어팝업 위치 및 사이즈 설정
    // 너비, 높이 설정
    var frameWidth  = width + 20;
    var frameHeight = height + 20;
    if (width > MAX_WIDTH){
    	frameWidth = MAX_WIDTH + 20;
    }
    if (height > MAX_HEIGHT){
    	frameHeight = MAX_HEIGHT;
    	document.getElementById("layerPopupIframe").style.overflow = "auto";
    }
    // 위치 설정
    var wLeft =(getVisibleDocWidth() - frameWidth) / 2;
    var wTop  = (getVisibleDocHeight() - frameHeight) / 2;
    
    // 레이어팝업 이동
    controls["layerPopup"].moveWindow(wLeft, wTop, frameWidth, frameHeight);
    // 레이어팝업 보이기
    controls["layerPopup"].setVisible(true);
    
    return;
};
/**
 * @description	미결
 * @param	{string}	formID
 * @return	{void}
 * @example	미결
 */
CommandButton.prototype.openNewWindow = function(formID){
	//1. 파라메터 설정
	var queryString = "lang=" + USER_LANGUAGE + "&";   
	queryString += "userId=" + USER_USERID + "&";
    if (typeof top.tmpl != "undefined") queryString += "tmpl=" + top.tmpl + "&";
	
	var paramKeyStr = USER_FORMID + "." + this.controlId;
    var paramKeyLength = paramKeyStr.length;
    var params = null;
    var key = null;
    
	// localstorage를 지원하지 않은 경우 또는 기존 소스의 호환이 필요한 경우
    if( !IS_AVAILABLE_LOCALSTORAGE && typeof PARAMETER != "undefined" ){
    	params = {};
    	for(key in PARAMETER.parameterItems){
    		if( key.substring(0, paramKeyLength) != paramKeyStr ) continue;
    		
    		params[key.substring(paramKeyLength + 1)] = PARAMETER.getParameter(key);
    		key = null;
    	}
    }
    // localstorage가 사용 가능한 경우 : 파라메터 키를 URL로 전달
    else{
    	queryString += "paramKey=" + paramKeyStr + "&";
    }
    
    //2. URL 설정
	var url = getContextPath() + "/FlexForm_" + formID + "_Load.do?" + queryString + "tm=" + (new Date()).valueOf();
	if (TEST_MODE != undefined && TEST_MODE){
		url = getContextPath() + "/test/FlexForm_" + formID + "_Load.do?" + queryString + "tm=" + (new Date()).valueOf();
	}
	
	// 새창 팝업명 설정
	var popupName = formID + (new Date()).valueOf();

	//3. 화면 호출
	var frm = null;
	var input = null;
	frm = document.createElement("form");
	document.body.appendChild(frm);
	frm.method = "POST" ;
	frm.name   = frm.id = (new Date()).valueOf();
	frm.action = url;
	frm.target = popupName;
	
	if( params != null ){
		// hidden타입 input 생성 및 form에 추가, 설정
		input = document.createElement("input");
		frm.appendChild(input);
		input.type = "hidden";
		input.name = "params";
		input.value = encodeURIComponent( JSON.stringify(params) );
	}
	
	window.open("about:blank", popupName);
    
    frm.submit();
    
    return;
};
/**
 * @description	미결
 * @param	{string}	formName
 * @param	{string}	formID
 * @return  {undefined}
 * @example	미결
 */
CommandButton.prototype.openNewTab = function(formName, formID){
	//1. 파라메터 설정
	var queryString = "";
	var paramKeyStr = USER_FORMID + "." + this.controlId;
    var paramKeyLength = paramKeyStr.length;
    var params = null;
    var key = null;
    
    // URL 쿼리 추가
    queryString = "lang=" + USER_LANGUAGE + "&";
    queryString += "userId=" + USER_USERID + "&";
    if (typeof top.tmpl != "undefined") queryString += "tmpl=" + top.tmpl + "&";
    queryString += "t=" + encodeURI(encodeURIComponent(formName)) + "&";
    
	// localstorage를 지원하지 않은 경우 또는 기존 소스의 호환이 필요한 경우
    if( !IS_AVAILABLE_LOCALSTORAGE && typeof PARAMETER != "undefined" ){
    	params = {};
    	for(key in PARAMETER.parameterItems){
    		if( key.substring(0, paramKeyLength) != paramKeyStr ) continue;
    		
    		params[key.substring(paramKeyLength + 1)] = PARAMETER.getParameter(key);
    		key = null;
    	}
    }
    // localstorage가 사용 가능한 경우 : 파라메터 키를 URL로 전달
    else{
    	queryString += "paramKey=" + paramKeyStr + "&";
    }
    
    // 데이터셋 전달을 위해 top에 데이터셋을 추가
    for(key in PARAMETER.parameterItems){
    	if( key.substring(0, paramKeyLength) != paramKeyStr ) continue;	
    	if( ("" + PARAMETER.parameterInfo[key].type).toLocaleLowerCase() == "dataset" ) top[key.substring(paramKeyLength + 1)] = dataSets[PARAMETER.getParameter(key)];
    }
    
    //2. URL 설정
    formID = (formID.substring(0, 3) == "Dlg") ? formID.substring(3) : formID;
    var url = getContextPath() + "/FlexForm_" + formID + "_Load.do?" + queryString + "tm=" + (new Date()).valueOf();
	if (TEST_MODE != undefined && TEST_MODE){
		url = getContextPath() + "/test/FlexForm_" + formID + "_Load.do?" + queryString + "tm=" + (new Date()).valueOf();
	}
	
	//3. 화면 호출
	var tabNum = -1;
	var tab_document = null;
	var frm = null;
	var input = null;
	
	// 새 탭을 빈 페이지로 추가
	top.addFramePage(formName, "about:blank", formID);
	
	// 추가한 탭의 document 받음
	tabNum = top.frames[top.frames.length - 1].searchTab(formID);
	if( tabNum < 0 ) alert(getText("message_commandbutton_001", "추가된 탭을 찾을 수 없습니다."));
	
	tab_document = top.frames[tabNum].document;
	
	// 추가한 탭의 document에 form을 추가 및 페이지 호출
	frm = document.createElement("form");  
    tab_document.body.appendChild(frm);
    frm.method = "POST" ;
    frm.name   = frm.id = (new Date()).valueOf();
    frm.action = url;
    
    // 로컬스토리지를 지원하지 않은 경우, 파라메터 추가
    if( params != null ){
    	// hidden타입 input 생성 및 form에 추가, 설정
    	input = document.createElement("input");
    	frm.appendChild(input);
    	input.type = "hidden";
    	input.name = "params";
    	input.value = encodeURIComponent( JSON.stringify(params) );
    }
    
    frm.submit();
};
/**
 * @description	미결
 * @return	{void}
 * @example	미결
 */
CommandButton.prototype.applyAndExit = function(){
	var i = 0;
	var key = null;
	
	//
	var returnArg = "";
	returnArg += "{";
	for(key in PARAMETER.parameterInfo){
		if( PARAMETER.parameterInfo[key].isreturn && PARAMETER.parameterInfo[key].type != "Dataset" ){
			returnArg += "\"" + key + "\":\"" + PARAMETER.getParameter(key) + "\",";
		}
		
		key = null;
	}
	if( returnArg.substring(returnArg.length - 1) == "," ) returnArg = returnArg.substring(0, returnArg.length - 1);
	returnArg += "}";
	
	//
	var dlgAruments = null;
	var id = null;
	var result = false;
	var callCommand = null;
	
	//
	if( IS_AVAILABLE_LOCALSTORAGE ){
		paramKey = PARAMETER.getParameter("paramKey");
		paramKeyLength = paramKey.length;
		callCommand = ("" + PARAMETER.getParameter("paramKey")).split(".")[1];
		
		if( opener !== window && parent === window ){
			if( typeof opener["setReturnValue_" + callCommand] == "undefined" ){ // 새창으로 부르기한 경우
				alert(getText("message_commandbutton_002", "새창을 호출하는 경우 먼저 창을 닫을 수 있기 떄문에 \n반환값을 처리하지 않도록 하고 있습니다. \n다이얼로그창 또는 레이어팝업을 이용하세요."));
				return;
			}
			//다이얼로그 팝업으로 부르기한 경우
			result = opener["setReturnValue_" + callCommand](USER_FORMID);				
		}
		else if( parent !== window && opener === null ){
			if( typeof parent["setReturnValue_" + callCommand] == "undefined" ){ // 새창으로 부르기한 경우
				alert(getText("message_commandbutton_003", "현재창(새탭)을 호출하는 경우 반환값을 처리하지 않도록 하고 있습니다. \n다이얼로그창 또는 레이어팝업을 이용하세요."));
				return;
			}
			//레이어팝업 호출한 경우
			result = parent["setReturnValue_" + callCommand](USER_FORMID);
		}
	}
	else{
		dlgAruments = [];
		
		try {
			if( modalArguments.length > 1 ){
				dlgAruments = modalArguments.split(";");
			}
			else if( modalArguments.length == 1 ){ // 새창으로 부르기한경우
				alert(getText("message_commandbutton_004", "새창을 호출하는 경우 먼저 창을 닫을 수 있기 떄문에 \n반환값을 처리하지 않도록 하고 있습니다. \n다이얼로그창을 이용하세요."));
				return;
				//dlgAruments = [command,"POST"];
			}
			else if( window.dialogArguments != undefined ){
				dlgAruments = window.dialogArguments;
			}
			else if( dlgAruments == undefined ){
				dlgAruments = opener.margs;
			}
		}
		catch(e){
			dlgAruments = opener.margs;
		}
		
		id = dlgAruments[0];
		
		if( dlgAruments[1] == "YES" ){
			if( window.opener )
				window.opener.returnValue = returnArg; 
			window.returnValue = returnArg;
			result = true;
		}
		else if( dlgAruments[1] == "NO" ){
			try{
				result = window.opener["setReturnValue_" + id](returnArg);
			}
			catch(e){
				result = eval("window.opener.setReturnValue_" + id + "(returnArg);");
			}
		}
		else if( dlgAruments[1] == "POST" ){
			if( thisIsIframe ){
				if( window.postMessage ){
//					result = window.parent.postMessage(returnArg, '*');
					window.parent.postMessage(returnArg, '*');
					result = true;
				}
				else{
					result = eval("window.parent.setReturnValue_" + id + "(returnArg);");
				}
			}
			else{
				if( typeof window.opener["setReturnValue_" + id] == "function" && !IS_IE9_OR_LOWER_VERSION ){
					//result = window.opener.postMessage(returnArg, '*');
					result = window.opener["setReturnValue_" + id](returnArg);
				}
				else{
					result = eval("window.opener.setReturnValue_" + id + "(returnArg);");
				}
			}
		}
	}
	
	//
	if( !result ){
		alert(getText("message_commandbutton_005", "반환 파라메터 전달 중 오류가 발생하였습니다."));
	}
	else{
		//팝업창에서 사용한 파라메터 삭제 및 로컬스토리지 클리어
		for(key in PARAMETER.parameterInfo){
			PARAMETER.remove(key);
		}
		//팝업창 닫기
		setTimeout(function(){ callWindowClose(); }, 0);
	}
	
	return;
};
/**
 * @description	미결
 * @param	{string}	url
 * @param	{string}	name
 * @return  {undefined}
 * @example	미결
 */
CommandButton.prototype.openManualDialog = function(url, name){
	
	window.open(url, name, 'width=1200px, height=730px, toolbar=no, location=no,scrollbars=yes, status=yes, directories=no,menubar=no,resizable=no,left=0,top=0');
	
	return;
};

/**
 * @description			시트에 시작 번호부터 마지막 번호까지 번호를 자동 생성(증가)하여 번호를 부여합니다. 시작 번호는 설정하지 않거나 컨트롤이 비어있는 경우 1부터 시작하고, 마지막 번호보다 시트 행이 더 많은 경우 마지막 번호까지만 생성하고 더이상 생성하지 않습니다.
 * @param	{string}	targetSheet		번호를 생성 및 부여할 시트 명
 * @param	{Array}		targetColumn	번호를 생성 및 부여할 시트의 컬럼 타이틀
 * @param	{string}	startNum		생성 및 부여할 번호의 시작 번호 컨트롤 명
 * @param	{string}	endNum			생성 및 부여할 번호의 마지막 번호 컨트롤 명
 * @return  {boolean}	정상적으로 동작이 완료되었다면 true를 리턴합니다. 만약 동작 중 오류가 발생하였다면 false가 리턴됩니다.
 * @example	controls["Command_1"].makeSheetNumbering("Sheet_1", ["seqNum"], "StartNum", "EndNum");
 */
CommandButton.prototype.makeSheetNumbering = function(targetSheet, targetColumn, startNum, endNum){
	var sheet = null;
	var startNumControl = null;
	var endNumControl = null;
	var targetColId = null;
	var targetColCount = 0;
	var maxRow = 0
	var number = 0;
	var i = 0; var j = 0; var n = "";
	
	//시트 컨트롤이 없거나 설정한 시트가 없는 경우, 설정한 시트 컨트롤이 시트가 아닌 경우, 예외처리
	sheet = controls[targetSheet];
	if( typeof EasySheet != "function" && sheet instanceof EasySheet ){ sheet = null; return false; }
	maxRow = sheet.maxRows;
	
	//설정한 컬럼의 길이가 0인 경우, 예외처리
	if( !(targetColumn instanceof Array) ){ sheet = null; return false; }
	targetColCount = targetColumn.length;
	if( targetColCount <= 0 ){ sheet = null; return false; }
	
	//텍스트 박스 컨트롤이 없거나 시작 번호 컨트롤이 설정되어 있지만 설정한 시작 번호 컨트롤이 텍스트박스 컨트롤이 닌 경우, 예외처리 
	if( typeof startNum != "undefined" && startNum != null ){
		startNumControl = controls[startNum];
		if( typeof TextBox != "function" && startNumControl instanceof TextBox ){ startNumControl = null; sheet = null; return false; }
		startNum = 1 * startNumControl.value;
		if( isNaN(startNum) ){ startNumControl = null; sheet = null; return false; }
		startNum = (startNum <= 0) ? 1 : startNum;
		startNumControl = null;
	}
	else startNum = 1;
	
	//텍스트 박스 컨트롤이 없거나 마지막 번호 컨트롤이 설정되어 있지만 설정한 마지막 번호 컨트롤이 텍스트박스 컨트롤이 닌 경우, 예외처리 
	if( typeof endNum != "undefined" && endNum != null ){
		endNumControl = controls[endNum];
		if( typeof TextBox != "function" && endNumControl instanceof TextBox ){ endNumControl = null; startNumControl = null; sheet = null; return false; }
		endNum = 1 * endNumControl.value;
		if( isNaN(endNum) ){ endNumControl = null; startNumControl = null; sheet = null; return false; }
		endNum = (endNum <= 0) ? -1 : endNum;
		endNumControl = null;
	}
	else endNum = -1;
	
	//번호 자동 생성(증가) 및 부여
	for(i = 0, number = startNum; i < maxRow; i++, number++, n = null){
		//
		n = (endNum > 0 && number > endNum) ? "" : number;
		//
		for(j = 0; j < targetColCount; j++, targetColId = null){
			targetColId = targetColumn[j];
			sheet.setValue(i, targetColId, n);
		}
	}
	
	return true;
};

/**
 * @name CommandButton#commandbutton_Click
 * @event 
 * @description 버튼 클릭 이벤트입니다.
 */
function commandbutton_Click(e)
{
  e=window.event || e;
    // 동작중이면 컴맨드 버튼은 눌려지지 않는다 
    if (jobControler.hasJob()) {
     	alert("Please Wait for completing current running job.");
    	return false;
    }
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? event.target : event.srcElement);
	var control = searchControl_CommandButton(em);
	
    return control.click();
};

/* *****************************************************************************
*  MAKE FILE UPLOAD AGENT
   arguments : parentNode: iframe's parentName name:iframe's name
               linkname: textbox controlName for filename
               picname : picture controls name for preeview
               ftpDir  : ftp upload directory under gw root dir 
* *****************************************************************************/
/**
 * @description 파일업로드 버튼 입니다.
 * @param {object} parentNode
 * @param {string} name
 * @param {string} linkname
 * @param {string} picname
 * @param {string} ftpDir
 * @param {string} noftp
 * @param {string} nozip
 * @param {number} directUploadGu
 * @param {number} buttonControl
 * @param {number} multiFileGu
 * @return 반환값 없음
 */
function IFrame_Upload_Command(parentNode, name, linkname, serverfilename, picname, ftpDir, noftp, nozip, directUploadGu, buttonControl, multiFileGu, selectMultiple, limitSize, allowExt) {
	this.noftp = (typeof noftp == "undefined" ? false : noftp);
	this.nozip = (typeof nozip == "undefined" ? false : nozip);
	selectMultiple = (typeof selectMultiple == "undefined" ? false : selectMultiple);
	this.limitSize = (typeof limitSize == "undefined" ? false : limitSize);
	this.allowExt = (typeof allowExt == "undefined" ? false : allowExt);
	
	var doc = buttonControl.ownerDocument;
	
	var container = doc.createElement("div");
	
	// zindex 주가
	var zi = 0, ziparsed;
	var obj = buttonControl;
	var comp = null;
	var i = 0;
	
	var positionObject = getBoundsObject(buttonControl);
	var buttonTop = positionObject.top + "px";
	var buttonLeft = positionObject.left + "px";
	var buttonWidth = positionObject.width + "px";
	var buttonHeight = positionObject.height + "px";
	
	//#egov 수정
	while (obj.tagName != 'BODY')
	{
		comp = obj.currentStyle ? obj.currentStyle : getComputedStyle(obj, null);
		ziparsed = parseInt(comp.zIndex);
		ziparsed = isNaN(ziparsed) ? 0 : ziparsed;
		zi += ziparsed + 1;
		obj = obj.parentNode
	}
	container.style.zIndex = zi;
	container.style.position = 'absolute';
	container.style.overflow = 'hidden';
	container.style.padding = 0;
	container.style.margin = 0;
	container.style.visiblity = 'hidden';
	container.style.width = '0px';
	container.style.height = '0px';
	container.style.opacity = 0;
	container.style.filter = 'alpha(opacity=100)';
	
	doc.body.insertBefore(container, doc.body.firstChild);
	
	container.innerHTML = "<iframe name='" + name + "' id='" + name + "' src='about:blank'></iframe>";
	var iframe = container.childNodes[0];
	iframe.setAttribute("linkname", linkname);
	iframe.setAttribute("picname",  picname);
	iframe.setAttribute("directUploadGu", directUploadGu);
	
	//iframe.style.display = 'none';
	iframe.marginHeight = 0;
	iframe.marginWidth = 0;
	
	iframe.setAttribute("doc", null);
	if( iframe.contentDocument ){					// Firefox, Opera
		iframe.doc = iframe.contentDocument;
	}  
	else if( iframe.contentWindow ){				// Internet Explorer
    	iframe.doc = iframe.contentWindow.document;
    }
    else if( iframe.document ){						// Others?
    	iframe.doc = iframe.document;
    }
	
    if(iframe.doc == null){
    	throw "Document not found, append the parent element to the DOM before creating the IFrame";  
    }
    
    iframe.doc.open();  
    iframe.doc.close();  
    
	var frm = iframe.doc.createElement("form");
	iframe.doc.body.appendChild(frm);
	
	frm.method = 'post';
	//frm.charset = 'euc-kr';
	//frm.onsubmit="document.charset='euc-kr';"
	frm.name = name + "_frm";
	frm.enctype = 'multipart/form-data';
	frm.encoding = 'multipart/form-data';
	frm.target = name ;
	frm.setAttribute('target', name );
	frm.action='fileUpload.do?id='+encodeURIComponent(name);
	frm.style.margin = 0;
	frm.style.padding = 0;
	frm.style.height = buttonHeight;
	frm.style.width = '40px';
	frm.runat = 'server';
	
	this.frm = frm;
	
	var inputctltemp = iframe.doc.createElement("input");
	inputctltemp.name = inputctltemp.id  ="upload["+0+"]";	// ["+0+"] egov 배열로받기위해
	inputctltemp.type = "file";  
	inputctltemp.size='1';
	inputctltemp.runat = 'server';
	inputctltemp.style.position = 'absolute';
	inputctltemp.style.top = -10000;
	inputctltemp.style.left = -10000;
	inputctltemp.style.visiblity = 'hidden';
	
	var inputctl = iframe.doc.createElement("input");
	inputctl.name = inputctl.id  ="upload["+0+"]";			// ["+0+"] egov 배열로받기위해
	inputctl.type = "file";  
	inputctl.size='1';
	inputctl.runat = 'server';
	inputctl.setAttribute("linkname", linkname);
	inputctl.setAttribute("picname", picname);
	inputctl.setAttribute("serverfilename", serverfilename);
	inputctl.setAttribute("directuploadgu", directUploadGu);
	if(selectMultiple) inputctl.setAttribute("multiple", true);
	inputctl.disabled = !searchControl_CommandButton(buttonControl).enabled;
	
	frm.appendChild(inputctl);
	this.inputctl = inputctl;
	
	inputctl.style.position = 'absolute';
	inputctl.style.display = 'block';
	inputctl.style.top = "-2px";
	inputctl.style.left = "-10px";
	inputctl.style.height = '25px';
	inputctl.style.width = '100px';
	inputctl.style.fontSize = 8;
	inputctl.style.zIndex = 1;
	inputctl.style.visiblity = 'hidden';
	inputctl.style.marginLeft = '-40px'; // hide IE text field
	
	var dirctl = iframe.doc.createElement("input");
	dirctl.type = "hidden";  
	dirctl.name="uploadSubDir" ;
	dirctl.id  ="uploadSubDir" ;
	dirctl.value = ftpDir;
	
	frm.appendChild(dirctl);
	
	var filenamectl = iframe.doc.createElement("input");
	filenamectl.type = "hidden";  
	filenamectl.name="uploadfilename" ;
	filenamectl.id  ="uploadfilename" ;
	filenamectl.value = "";
	
	frm.appendChild(filenamectl);
	
	var uploadPrefixctl = iframe.doc.createElement("input");
	uploadPrefixctl.type = "hidden";  
	uploadPrefixctl.name="uploadPrefix" ;
	uploadPrefixctl.id  ="uploadPrefix" ;
	uploadPrefixctl.value = jUploadPrefix;
	
	frm.appendChild(uploadPrefixctl);
	
	var uploadsuffixctl = iframe.doc.createElement("input");
	uploadsuffixctl.type = "hidden";  
	uploadsuffixctl.name="uploadSuffix" ;
	uploadsuffixctl.id  ="uploadSuffix" ;
	uploadsuffixctl.value = "";
	
	frm.appendChild(uploadsuffixctl);
	
	var noftpctl = iframe.doc.createElement("input");
	noftpctl.type = "hidden";  
	noftpctl.name="noftp" ;
	noftpctl.id  ="noftp" ;
	noftpctl.value = noftp;
	
	frm.appendChild(noftpctl);
	
	var nozipctl = iframe.doc.createElement("input");
	nozipctl.type = "hidden";  
	nozipctl.name="nozip" ;
	nozipctl.id  ="nozip" ;
	nozipctl.value = nozip;
	
	frm.appendChild(nozipctl);
	
	var lang = iframe.doc.createElement("input");
	lang.type = "hidden";  
	lang.name="lang" ;
	lang.id  ="lang" ;
	lang.value = USER_LANGUAGE;
	
	frm.appendChild(lang);
	
	var parentidctl = iframe.doc.createElement("input");
	parentidctl.type = "hidden";  
	parentidctl.name="parentid" ;
	parentidctl.id  ="parentid" ;
	parentidctl.value = buttonControl.id;
	
	frm.appendChild(parentidctl);
	
	if( jUploadPrefix.length == 0 ){
		jUploadPrefix = timeEncodeString();
		if( em.document ){
			em.document.getElementsByName("uploadPrefix")[0].value = jUploadPrefix;
		} else {
			uploadPrefixctl.value = jUploadPrefix;
		}
	}
	
	iframe.onload = function(){
		// functionname : [IFrame_Upload.onload]
	};
	iframe.onreadystatechange = function(){
		// functionname : [IFrame_Upload.onreadystatechange]
	};
	/**
	*     @description	미결
	*     @param	{string}	chileNodes
	*     @param	{string}	strId
	*     @return	{string}
	*     @example	미결
	*/
	function getChildNodeById(childNodes, strId){
		var childNode = null;
		var childCount = childNodes.length;
		var i = 0;
		
		for(i = 0; i < childCount; i++, childNode = null){
			childNode = childNodes[i];
			
			if( childNode ==  null || childNode == "undefined" )
				continue;
			
			if( childNode.getAttribute('id') == strId )
				break;
		}
		
		return childNode;
	}
	/**
	*     @description	미결
	*     @return	{undefined}
	*     @example	미결
	*/
	function getTimeFlag(){
		var now = new Date();
		var milliseconds = "" + now.getMilliseconds();
		
		if( milliseconds.length == 1 ){
			milliseconds= ["00", milliseconds].join("");
		}
		else if( milliseconds.length == 2 ){
			milliseconds= ["0", milliseconds].join("");
		}
		
		return "_V" + DateString(now) + TimeString(now) + milliseconds;
	}
	/**
	*     @description	미결
	*     @event
	*     @return	{undefined}
	*     @name	CommandButton#inputct1_onchange
	*/
	function inputctl_onchange(e){
		// functionname : [IFrame_Upload.onchange]
		if( !e ) e = window.event;
		
		var em = getSrcElement(e);
		e.target = e.target || e.srcElement;
		
		var controlId = (em.document ? em.document.getElementsByName("parentid")[0].value
										: getChildNodeById(em.parentNode.childNodes, "parentid").value);
		var uploadSubDir = (em.document ? em.document.getElementsByName("uploadSubDir")[0].value
										: getChildNodeById(em.parentNode.childNodes, "uploadSubDir").value);
		var uploadPrefix = (em.document ? em.document.getElementsByName("uploadPrefix")[0].value
										: getChildNodeById(em.parentNode.childNodes, "uploadPrefix").value);
		var uploadSuffix = (USE_FILE_SUFFIX != undefined && USE_FILE_SUFFIX ? getTimeFlag() : "");
		
		if( em.document ){
			em.document.getElementsByName("uploadSuffix")[0].value = uploadSuffix;
		}
		else{
			getChildNodeById(em.parentNode.childNodes, "uploadSuffix").value = uploadSuffix;
		}
		
		var func = self.parent[controlId + "_onselectcompleted"];
		if( typeof func == "undefined" ) func = self[controlId + "_onselectcompleted"];
		
		var tagObject = document.querySelector("div#" + controlId);
		var controlName = (tagObject != null) ? tagObject.getAttribute("ctlname") : "";
		var control = controls[controlName];
		
		if( typeof control == "undefined" || control == null ){
			control = null; controlName = null; tagObject = null; func = null;
			uploadSuffix = null; uploadPrefix = null; uploadSubDir = null; controlId = null; em = null;
			return false;
		}
		
		var checkResult = true;
		var limitFileSize = control.uploadFrame.limitSize;
		var allowFileExt = control.uploadFrame.allowExt; 
		var allowFileExtList = (typeof allowFileExt == "string") ? allowFileExt.toLowerCase().split("|") : null;
		
		var arrFileNames = []; var arrUploadFileNames = []; var arrSvrFileNames = []; var arrFileSizes = [];
		var fileName = null; fileExtension = null; fileSize = 0;
		var fileCount = e.target.files.length;
		var dotIndex = -1;
		var i = 0;
		
		for(i = 0; i < fileCount; i++){
			fileName = e.target.files.item(i).name;
			fileExtension = fileName.substring(fileName.lastIndexOf(".") + 1);
			
			arrFileNames[i]				= fileName;
			arrUploadFileNames[i]		= jUploadPrefix + fileName;
			arrFileSizes[i] = fileSize	= e.target.files.item(i).size;
			
			//파일 크기 체크
			if( typeof limitFileSize == "number" && limitFileSize > 0 ){
				if( fileSize > limitFileSize ){
					//alert("업로드 가능한 파일 크기를 초과하였습니다.\r\n(업로드 가능한 크기 : " + (limitSize / 1024) + "KB)");
					alert(getText("message_commandbutton_017", "업로드 가능한 파일 크기를 초과하였습니다.\r\n(업로드 가능한 크기 : {0}KB)", [(limitSize / 1024)]));
					checkResult = false;
					break;
				}
			}
			//파일 확장자 체크
			if( allowFileExt !== false && allowFileExtList != null ){
				if( allowFileExtList.indexOf(fileExtension.toLowerCase()) < 0 ){
					//alert("업로드 가능한 파일 확장자가 아닙니다.\r\n\(업로드 가능한 목록 : " + allowFileExtList.join(", ") + ")");
					alert(getText("message_commandbutton_018", "업로드 가능한 파일 확장자가 아닙니다.\r\n\(업로드 가능한 목록 : {0})", [(allowFileExtList.join(", "))]));
					checkResult = false;
					break;
				}
			}
			
			if( USE_FILE_SUFFIX != undefined && USE_FILE_SUFFIX ){
				dotIndex = fileName.lastIndexOf(".");
				
				if( dotIndex < 0 )	arrSvrFileNames[i] = fileName + uploadSuffix ;
				else				arrSvrFileNames[i] = fileName.substring(0, dotIndex) + uploadSuffix + fileName.substring(dotIndex);
			}
			else{
				arrSvrFileNames[i] = jUploadPrefix + fileName;
			}
		}
		
		if( checkResult && typeof func != "undefined" ){
			if( !func(arrFileNames, arrUploadFileNames, arrSvrFileNames, arrFileSizes, uploadSubDir) ){
				// 2016-06-07 수정
				// em.parentElement.removeChild(em); 취소시 콘트롤 없어져 임시호 막음 
				// return false;
				checkResult = false;
			}
		}
		
		//파일 크기 제한, 업로드 가능한 확정자 체크, 사용자 이벤트 중 하나라도 걸린 경우
		if( !checkResult ){
			//메모리 해제
			fileExtension = null; fileName = null; allowFileExtList = null; allowFileExt = null;
			arrFileSizes = null; arrSvrFileNames = null; arrSvrFileNames = null; arrFileNames = null;
			control = null; controlName = null; tagObject = null; func = null;
			uploadSuffix = null; uploadPrefix = null; uploadSubDir = null; controlId = null; em = null;
			return false;
		}
        
		var filePath = em.value;
		var fileName = "";
		
		if( filePath.indexOf("\\") > 0 )
			fileName = filePath.split("\\")[filePath.split("\\").length -1];
		else
			fileName = filePath;
		
		var fileTag = timeEncodeString();
		if( em.document ){
			em.document.getElementsByName("uploadfilename")[0].value = fileName;
		}
		else{
			//em.parentNode.childNodes.item("uploadfilename").setAttribute("value",fileName);
			getChildNodeById(em.parentNode.childNodes, "uploadfilename").value = fileName;
		}
		
		var wndw = self;
		for(i = 0; i < 10; i++){
			try {
				if( eval(wndw.getControlById) ) break;
			}
			catch(e){ wndw = wndw.parent; }
		}
		
		var wControl = wndw.getControlById(iframe.getAttribute("linkname"));
		if( multiFileGu ){
			var target = em.parentNode.getAttribute("target");
			
			if( wControl.textFound(fileName) ){
				uploadControls[target].deleteFileControl(fileName);
				wControl.updateItem(fileName, jUploadPrefix + fileName);
			}
			else{
				wControl.addItem(fileName, jUploadPrefix + fileName);
			}
			
			uploadControls[target].addNewFileControl();
			
			if( em.getAttribute("directuploadgu") == "true" ){
				if (jUploadPrefix.length == 0) {
					jUploadPrefix = timeEncodeString();
				}
				if( em.document ){
					em.document.getElementsByName("uploadPrefix")[0].value = jUploadPrefix;
				}
				else{
					getChildNodeById(em.parentNode.childNodes, "uploadPrefix").value =jUploadPrefix;
				}
				
				showAjaxBox(getText("message_commandbutton_016", "{0} 파일을 업로드하는 중입니다.", [fileName]), 0);
				
				em.parentNode.submit();
			}
		}
		else{
			wControl.setValue(fileName);
			controls[inputctl.getAttribute("serverfilename")].setValue(jUploadPrefix + fileName);
//			wControl.setValue(jUploadPrefix + fileName);
//			wControl.tag = filePath;
			
            if( em.getAttribute("directuploadgu") == "true" ){
            	if( jUploadPrefix.length == 0 ){
            		jUploadPrefix = timeEncodeString();
            	}
            	if( em.document ){
            		em.document.getElementsByName("uploadPrefix")[0].value = jUploadPrefix;
            	}
            	else{
            		getChildNodeById(em.parentNode.childNodes, "uploadPrefix").value = jUploadPrefix;
            	}
            	
            	showAjaxBox(getText("message_commandbutton_016", "{0} 파일을 업로드하는 중입니다.", [fileName]), 0);
            	
            	em.parentNode.submit();
            }
		}
	};
	
	setEventHandler(inputctl, "change", inputctl_onchange);
	
	/**
	 * @name CommandButton#container_onmouseout
	 * @event
	 * @return	{undefined}
	 * @description	미결
	 */
	function container_onmouseout(e){
		if( !e ) e = window.event;
		
		var receiver = doc.elementFromPoint(e.clientX, e.clientY);
		
		if( receiver === buttonControl ){
			container.style.width = '20px';
			container.style.height = buttonHeight;
		}
		else{
			container.style.width = '0px';
			container.style.height = '0px';
		}
	};
	
//	setEventHandler(container, "mouseout", container_onmouseout);
	
	/**
	 * @name CommandButton#buttonControl_onmousemove
	 * @event
	 * @description	미결
	 */
	function buttonControl_onmousemove(e) {
		if (!e) e = window.event;
		
		var positionObject = getBoundsObject(getSrcElement(e));
		buttonTop = positionObject.top + "px";
		buttonLeft = positionObject.left + "px";
		buttonWidth = positionObject.width + "px";
		buttonHeight = positionObject.height + "px";
		
		var x = 0; var y = 0;
		
		if( e.pageX )
			x = e.pageX;
		else if( e.clientX )
			x = e.clientX + (doc.documentElement.scrollLeft ? doc.documentElement.scrollLeft : doc.body.scrollLeft);
		
		if( e.pageY )
			y = e.pageY;
		else if( e.clientY )
			y = e.clientY + (doc.documentElement.scrollTop ? doc.documentElement.scrollTop : doc.body.scrollTop);
		
		// move listener
		container.style.left =(parseIntSize(buttonLeft) > x - 10 ? buttonLeft : x - 10 + 'px');
		container.style.top = buttonTop;
		container.style.width = '20px';
		container.style.height = '25px';
	};
	
//	setEventHandler(buttonControl, "mousemove", buttonControl_onmousemove);
	
	this.addNewFileControl = function(){
		this.inputctl.style.zIndex = (-1) * (this.frm.childNodes.length - 5) ; // 5는 화일 콘트롤이 아닌 콘트롤수
		var inputctl = iframe.doc.createElement("input");
		i = i + 1;  //egov
		inputctl.name = inputctl.id = "upload[" + i + "]" ; //egov
		inputctl.type = "file";  
		inputctl.size='1';
		inputctl.runat = 'server';
		inputctl.setAttribute("linkname", linkname);
		inputctl.setAttribute("picname", picname);
		inputctl.setAttribute("directuploadgu", directUploadGu);
		if(selectMultiple) inputctl.setAttribute("multiple", true);
		inputctl.disabled = !searchControl_CommandButton(buttonControl).enabled;
		
		frm.appendChild(inputctl);
		this.inputctl = inputctl;
		
		inputctl.style.position = 'absolute';
		inputctl.style.display = 'block';
		inputctl.style.top = "-2px";
		inputctl.style.left = "-10px";
		inputctl.style.height = buttonHeight;
		inputctl.style.width = '100px';
		inputctl.style.fontSize = 8;
		inputctl.style.zIndex = 1;
		inputctl.style.visiblity = 'hidden';
		inputctl.style.marginLeft = '-40px'; // hide IE text field
		
		setEventHandler(inputctl, "change", inputctl_onchange);
	};
	
	this.deleteFileControl = function(fileName){
		var wEm = null; var em = null;
		var filePath = null;
		var fileName0 = null;
		var count = 0;
		var i = 0;
		
		for(i = this.frm.childNodes.length - 1; i >= 0; i--){
			em = this.frm.childNodes.item(i);
			
			if( em.getAttribute("type") != "file" ) continue;
			
			filePath = em.value;
			fileName0 = "";
			
			if( filePath.indexOf("\\") > 0 ){
				fileName0 = filePath.split("\\")[filePath.split("\\").length -1];
			}
			else{
				fileName0 = filePath;
			}
			
			if( fileName0 == fileName ){
				wEm = em;
				count++;
			}
		}
		
		if( count > 1 ) this.frm.removeChild(wEm);
	};
	
	this.uploadFile = function(){
		// functionname : [IFrame_Upload.uploadFile]
		
		this.frm.uploadPrefix.value = jUploadPrefix;
		
		var wEm = null; var em = null;
		var filePath = null;
		var count = 0;
		var i = 0;
		
		for(i = this.frm.childNodes.length - 1; i >= 0; i--){
			em = this.frm.childNodes.item(i);
			filePath= em.value;
			
			if( em.getAttribute("type")=="file" && em.value && em.value.length > 0 ) count++;
		}
		
		if( count > 0 ) this.frm.submit();
	};
	
	this.setEnabled = function(enabled){
		this.inputctl.disabled = !enabled;
	};
	
	this.clearInfo = function(){
		container.innerHTML = "";
		removeTag(container);
	};
};

/* *****************************************************************************
*  MAKE EXCEL UPLOAD AGENT
* *****************************************************************************/
//function IFrame_UploadXL_Command(parentNode, name, linkname, picname, ftpDir, noftp, nozip, directUploadGu, buttonControl, multiFileGu) {
/**
*     @description	미결
*     @param	{string}	name
*     @param	{string}	commandName
*     @param	{string}	sheetName
*     @return	{undefined}
*     @example	미결
*/
function IFrame_UploadXL_Command(name, commandName, sheetName) {
	
	var buttonControl = controls[commandName].tagObject;
	var doc = buttonControl.ownerDocument;
	var container = doc.createElement("div");
	
    // zindex 주기
    var zi=0, ziparsed;
    var obj = buttonControl;
    var comp;

    var positionObject = getBoundsObject(buttonControl);
    var buttonTop = positionObject.top + "px";
    var buttonLeft = positionObject.left + "px";
    var buttonWidth = positionObject.width + "px";
    var buttonHeight = positionObject.height + "px";

    while (obj.tagName != 'BODY')
    {
        comp = obj.currentStyle ? obj.currentStyle : getComputedStyle(obj, null);
        ziparsed = parseInt(comp.zIndex);
        ziparsed = isNaN(ziparsed) ? 0 : ziparsed;
        zi += ziparsed + 1;
        obj = obj.parentNode
    }
    container.style.zIndex = zi;
    container.style.position = 'absolute';
    container.style.overflow = 'hidden';
    container.style.padding = 0;
    container.style.margin = 0;
    container.style.visiblity = 'hidden';
    container.style.width = '0px';
    container.style.height = '0px';
    container.style.opacity = 0;
    container.style.filter = 'alpha(opacity=0)';

    doc.body.insertBefore(container, doc.body.firstChild);

    container.innerHTML = "<iframe name='" + name + "' id='" + name + "' src='about:blank'></iframe>";
    var iframe = container.childNodes[0];
    iframe.setAttribute("cmdname", commandName);
    iframe.setAttribute("shtname", sheetName);
    

    //iframe.style.display = 'none';
    iframe.marginHeight = 0;
    iframe.marginWidth = 0;
   
    iframe.setAttribute("doc", null);
    if(iframe.contentDocument)                // Firefox, Opera  
       iframe.doc = iframe.contentDocument;

    else if(iframe.contentWindow)             // Internet Explorer  
       iframe.doc = iframe.contentWindow.document;

    else if(iframe.document)                  // Others?  
       iframe.doc = iframe.document;  

    if(iframe.doc == null)  
       throw "Document not found, append the parent element to the DOM before creating the IFrame";  

    iframe.doc.open();  
    iframe.doc.close();  
    
    var frm = iframe.doc.createElement("form");
    iframe.doc.body.appendChild(frm);  
            frm.method = 'post';
            frm.name = name + "_frm";
            frm.enctype = 'multipart/form-data';
            frm.encoding = 'multipart/form-data';
            frm.target = name ;
            frm.setAttribute('target', name );
            frm.action='excelUpload.do?id='+encodeURIComponent(name) 
            frm.style.margin = 0;
            frm.style.padding = 0;
            frm.style.height = buttonHeight;
            frm.style.width = '40px';
            frm.runat = 'server';
    
    this.frm = frm;
    
    var inputctltemp = iframe.doc.createElement("input");
    inputctltemp.name = inputctltemp.id  ="upload" ;
    inputctltemp.type = "file";  
    inputctltemp.size='1';
    inputctltemp.runat = 'server';
    inputctltemp.style.position = 'absolute';
    inputctltemp.style.top = -10000;
    inputctltemp.style.left = -10000;
    inputctltemp.style.visiblity = 'hidden';
    
    var inputctl = iframe.doc.createElement("input");
    inputctl.name = inputctl.id  ="upload" ;
    inputctl.type = "file";  
    inputctl.size='1';
    inputctl.runat = 'server';
    inputctl.disabled = !searchControl_CommandButton(buttonControl).enabled;
    //setEventHandler(inputctl, "click", controls[commandName].click()); 의미없는 코드이고, IE낮은 버전 오류
    
    
    frm.appendChild(inputctl);
    this.inputctl = inputctl;
    
    inputctl.style.position = 'absolute';
    inputctl.style.display = 'block';
    inputctl.style.top = "-2px";
    inputctl.style.left = "-10px";
    inputctl.style.height = '25px';
    inputctl.style.width = '100px';
    inputctl.style.fontSize = 8;
    inputctl.style.zIndex = 1;
    inputctl.style.visiblity = 'hidden';
    inputctl.style.marginLeft = '-40px'; // hide IE text field

    
    var filenamectl = iframe.doc.createElement("input");
    filenamectl.type = "hidden";  
    filenamectl.name="uploadfilename" ;
    filenamectl.id  ="uploadfilename" ;
    filenamectl.value = "";
     
    frm.appendChild(filenamectl);
    
    /**
     * @name CommandButton#inputct1_onchange
     * @event
     * @description	미결
     */
    function inputctl_onchange(e){
    	// functionname : [IFrame_Upload.onchange]
        if (!e) e = window.event;
        var em = getSrcElement(e)
        
        var filePath = em.value;
 
        if (filePath == "" || filePath.substring(filePath.length-4) != ".xls") {
            alert(getText("message_commandbutton_006", "Excel 파일을 등록하세요."));
            return;
        } 
        
        var fileName = "";
        if (filePath.indexOf("\\") > 0) {
            fileName = filePath.split("\\")[filePath.split("\\").length -1];
        } else {
        	fileName = filePath;
        }
        
        var fileTag = timeEncodeString();
        if (em.document){
            em.document.getElementsByName("uploadfilename")[0].value = fileName;
        } else {
            //em.parentNode.childNodes.item("uploadfilename").setAttribute("value",fileName);
        	getChildNodeById(em.parentNode.childNodes, "uploadfilename").value = fileName;
        }
        
        var wndw = self;
        for (var i = 0; i < 10; i++) {
        	try {
        		if (eval(wndw.getControlById)) break;
        	} catch(e) {
        		wndw = wndw.parent;
        	}
        }
        em.parentNode.submit();
        
	};

	setEventHandler(inputctl, "change", inputctl_onchange);

	/**
	 * @name CommandButton#container_onmouseout
	 * @event
	 * @description	미결
	 */
    function container_onmouseout(e){
        if (!e) e = window.event;

        var receiver = doc.elementFromPoint(e.clientX, e.clientY);

        if (receiver === buttonControl)
        {
        	container.style.width = '20px';
            container.style.height = buttonHeight;
        } else {
            container.style.width = '0px';
            container.style.height = '0px';
        }
    };
	
	//setEventHandler(container, "mouseout", container_onmouseout);
    
    /**
     * @name CommandButton#buttonControl_onmousemove
     * @event
     * @description	미결
     */
    function buttonControl_onmousemove(e) {
            if (!e) e = window.event;
            
            var positionObject = getBoundsObject(getSrcElement(e));
            buttonTop = positionObject.top + "px";
            buttonLeft = positionObject.left + "px";
            buttonWidth = positionObject.width + "px";
            buttonHeight = positionObject.height + "px";

            var x = 0; var y = 0;

            if (e.pageX) x = e.pageX;
            else if (e.clientX)
               x = e.clientX + (doc.documentElement.scrollLeft ? doc.documentElement.scrollLeft : doc.body.scrollLeft);

            if (e.pageY) y = e.pageY;
            else if (e.clientY)
               y = e.clientY + (doc.documentElement.scrollTop ? doc.documentElement.scrollTop : doc.body.scrollTop);

            // move listener
            container.style.left =(parseIntSize(buttonLeft) > x - 10 ? buttonLeft : x - 10 + 'px');
            container.style.top = buttonTop;
            container.style.width = '20px';
            container.style.height = '25px';
        };
        
    //setEventHandler(buttonControl, "mousemove", buttonControl_onmousemove);
        
    this.setEnabled = function(enabled){
    	this.inputctl.disabled = !enabled;
    };
    this.clearInfo = function(){
         container.innerHTML = "";
    };
};

/*
 *		신규 엑셀 업로드 : 시트 외의 컨트롤에도 엑셀 데이터를 업로드 
 */

/**
*     @description	미결
*     @param	{string}	name
*     @param	{string}	commandName
*     @param	{number}	startRow
*     @param	{object}	colnmnOrder
*     @param	{string}	outputCotrolName
*     @param	{number}	limitSize
*     @param	{string}	allowFileName
*     @return	{string}
*     @example	미결
*/
function IFrame_UploadXL_CommandA(name, commandName, startRow, columnOrder, outputControlName, limitSize, allowFileName) {
	
	this.commandName = commandName;
	this.fileName = "";
	this.fimeNameOutputControlName = outputControlName ? outputControlName : "";
	this.limitSize = limitSize ? limitSize : -1;
	this.allowFileName = allowFileName ? allowFileName : "";
	
	var buttonControl = getControlById(commandName).tagObject;
	var doc = buttonControl.ownerDocument;
	var container = doc.createElement("div");
	
    // zindex 주기
    var zi=0, ziparsed;
    var obj = buttonControl;
    var comp;
    
    var positionObject = getBoundsObject(buttonControl);
    var buttonTop = positionObject.top + "px";
    var buttonLeft = positionObject.left + "px";
    var buttonWidth = positionObject.width + "px";
    var buttonHeight = positionObject.height + "px";

    zi = findHighestZIndex() + 1;
    
    container.style.zIndex = zi;
    container.style.position = 'absolute';
    container.style.overflow = 'hidden';
    container.style.padding = 0;
    container.style.margin = 0;
    container.style.visiblity = 'hidden';
    container.style.width = '0px';
    container.style.height = '0px';
    container.style.opacity = 0;
    container.style.filter = 'alpha(opacity=0)';

    doc.body.insertBefore(container, doc.body.firstChild);

    container.innerHTML = "<iframe name='" + name + "' id='" + name + "' src='about:blank'></iframe>";
    var iframe = container.childNodes[0];
    iframe.setAttribute("cmdname", commandName);
    //iframe.setAttribute("shtname", sheetName);
    
    //iframe.style.display = 'none';
    iframe.marginHeight = 0;
    iframe.marginWidth = 0;
   
    iframe.setAttribute("doc", null);
    if(iframe.contentDocument)                // Firefox, Opera  
       iframe.doc = iframe.contentDocument;

    else if(iframe.contentWindow)             // Internet Explorer  
       iframe.doc = iframe.contentWindow.document;

    else if(iframe.document)                  // Others?  
       iframe.doc = iframe.document;  

    if(iframe.doc == null)  
       throw "Document not found, append the parent element to the DOM before creating the IFrame";  

    iframe.doc.open();  
    iframe.doc.close();  
    
    var frm = iframe.doc.createElement("form");
    iframe.doc.body.appendChild(frm);  
            frm.method = 'post';
            frm.name = name + "_frm";
            frm.enctype = 'multipart/form-data';
            frm.encoding = 'multipart/form-data';
            frm.target = name ;
            frm.setAttribute('target', name );
            frm.action='excelUpload.do?id='+encodeURIComponent(name);
            frm.style.margin = 0;
            frm.style.padding = 0;
            frm.style.height = buttonHeight;
            frm.style.width = '40px';
            frm.runat = 'server';
    
    this.frm = frm;
    
    var inputctltemp = iframe.doc.createElement("input");
    inputctltemp.name = inputctltemp.id  ="upload" ;
    inputctltemp.type = "file";  
    inputctltemp.size='1';
    inputctltemp.runat = 'server';
    inputctltemp.style.position = 'absolute';
    inputctltemp.style.top = -10000;
    inputctltemp.style.left = -10000;
    inputctltemp.style.visiblity = 'hidden';
    
    var inputctl = iframe.doc.createElement("input");
    inputctl.name = inputctl.id  ="upload" ;
    inputctl.type = "file";  
    inputctl.size='1';
    inputctl.runat = 'server';
    inputctl.disabled = !searchControl_CommandButton(buttonControl).enabled;
    //setEventHandler(inputctl, "click", controls[commandName].click()); 의미없는 코드이고, IE낮은 버전 오류
    
    
    frm.appendChild(inputctl);
    this.inputctl = inputctl;
    
    inputctl.style.position = 'absolute';
    inputctl.style.display = 'block';
    inputctl.style.top = "-2px";
    inputctl.style.left = "-10px";
    inputctl.style.height = '25px';
    inputctl.style.width = '100px';
    inputctl.style.fontSize = 8;
    inputctl.style.zIndex = 1;
    inputctl.style.visiblity = 'hidden';
    inputctl.style.marginLeft = '-40px'; // hide IE text field

    
    var filenamectl = iframe.doc.createElement("input");
    filenamectl.type = "hidden";  
    filenamectl.name="uploadfilename" ;
    filenamectl.id  ="uploadfilename" ;
    filenamectl.value = "";
     
    frm.appendChild(filenamectl);
    
    var startrowctl = iframe.doc.createElement("input");
    startrowctl.type = "hidden";  
    startrowctl.name="r" ;
    startrowctl.id  ="r" ;
    startrowctl.value = startRow;
     
    frm.appendChild(startrowctl);
    
    var columnorderctl = iframe.doc.createElement("input");
    columnorderctl.type = "hidden";  
    columnorderctl.name="columnOrder" ;
    columnorderctl.id  ="columnOrder" ;
    columnorderctl.value = columnOrder;
     
    frm.appendChild(columnorderctl);
    
    var infoctl = iframe.doc.createElement("input");
    infoctl.type = "hidden";  
    infoctl.name="info" ;
    infoctl.id  ="info" ;
    infoctl.value = "";
     
    frm.appendChild(infoctl);
    
    /**
     *     @description	미결
     *     @param	{string}	childNodes
     *     @param	{string}	strId
     *     @return	{string}
     *     @example	미결
     */
    function getChildNodeById(childNodes, strId){
		for (var i=0; i < childNodes.length; i++){
			if (childNodes[i].getAttribute('id') == strId){
				return childNodes[i];
			}
		}
		return null;
	}

    /**
     * @name CommandButton#inputct1_onchange
     * @event
     * @description	미결
     */
    function inputctl_onchange(e){
    	// functionname : [IFrame_Upload.onchange]
        if (!e) e = window.event;
        var em = getSrcElement(e)
        var filePath = em.value; 
        
        //파일 확장자 체크
        if (filePath == "" || (filePath.substring(filePath.length-4) != ".xls" && filePath.substring(filePath.length-5) != ".xlsx")) {
            alert(getText("message_commandbutton_006", "Excel 파일을 등록하세요."));
            return;
        } 
        
        var fileName = "";
        if (filePath.indexOf("\\") > 0) {
            fileName = filePath.split("\\")[filePath.split("\\").length -1];
        } else {
        	fileName = filePath;
        }
        
        var wndw = self;
        for (var i = 0; i < 10; i++) {
        	try {
        		if (eval(wndw.getControlById)) break;
        	} catch(e) {
        		wndw = wndw.parent;
        	}
        }
        
        var commandName = "";
        var fimeNameOutputControlName = "";
        var limitSize = -1;
        var allowFileName = "";
        var cmdCtrl = null;
        
        try {
        	var iframeNodeList = wndw.document.getElementsByTagName("iframe");
        	var iframeNode = null;
        	for(var i = 0; i < iframeNodeList.length; i++){
        		iframeNode = iframeNodeList[i];
        		if( (iframeNode.getAttribute("id") + "") == (em.parentElement.getAttribute("target") + "") ){
        			cmdCtrl = wndw.getControlById( iframeNode.getAttribute("cmdname") );
        			fimeNameOutputControlName = cmdCtrl.uploadFrame.fimeNameOutputControlName;
        			limitSize = cmdCtrl.uploadFrame.limitSize;
        			allowFileName = cmdCtrl.uploadFrame.allowFileName;
        			break;
        		}
        	}
        } catch(e){}
        
        try {
        	//파일 사이즈 체크
        	if(limitSize > 0 && e.target != undefined && e.target != null){
        		if(e.target.files != undefined && e.target.files != null){
        			//파일 크기 단위 : 바이트
        			if(e.target.files.item(0).size * 1 > limitSize * 1){
        				alert(getText("message_commandbutton_007", "허용된 파일 크기를 초과하였습니다.\n(허용된 파일 크기 : {0}KB)", [(limitSize / 1024)]));
        				return ;
        			}
        		}
        	}
        	//파일명 체크
        	if(allowFileName.length > 0){
        		var fname = "";
        		//확장자를 체크하여 확장자 길이에 맞게 잘라내 파일명만 남김
        		if( /.*\.xls$/.test(fileName) )			fname = fileName.substring(0, fileName.length - 4);
        		else if( /.*\.xlsx$/.test(fileName) )	fname = fileName.substring(0, fileName.length - 5);
        		//확장자를 제외한 파일명이 다름
        		if(allowFileName != fname){
        			alert(getText("message_commandbutton_008", "허용된 파일명이 아닙니다.\n(허용된 파일명 : xls, xlsx)"));
        			return ;
        		}
        	}
        	//파일명 출력
        	cmdCtrl.uploadFileName = fileName;
        	cmdCtrl.uploadFrame.fileName = fileName;
        	//controls["ExcelFilePath"].setValue(em.value);
        	if(fimeNameOutputControlName.length > 0){
        		controls[fimeNameOutputControlName].setValue(fileName);
        	}
        } catch(e){}
        
        var fileTag = timeEncodeString();
        if (em.document){
            em.document.getElementsByName("uploadfilename")[0].value = fileName;
        } else {
            //em.parentNode.childNodes.item("uploadfilename").setAttribute("value",fileName);
        	getChildNodeById(em.parentNode.childNodes, "uploadfilename").value = fileName;
       }
        
        showAjaxBox(getText("message_commandbutton_009", "{0} 엑셀자료를 업로드하는 중입니다.", [fileName]), 0);
        
        em.parentNode.submit();
        
	};

	setEventHandler(inputctl, "change", inputctl_onchange);

	/**
	 * @name CommandButton#container_onmouseout
	 * @event
	 * @description	미결
	 */
    function container_onmouseout(e){
        if (!e) e = window.event;

        var receiver = doc.elementFromPoint(e.clientX, e.clientY);

        if (receiver === buttonControl)
        {
        	container.style.width = '20px';
            container.style.height = buttonHeight;
        } else {
            container.style.width = '0px';
            container.style.height = '0px';
        }
    };
	
	//setEventHandler(container, "mouseout", container_onmouseout);
    
    /**
     * @name CommandButton#buttonControl_onmousemove
     * @event
     * @description	미결
     */
    function buttonControl_onmousemove(e) {
            if (!e) e = window.event;
            
            var positionObject = getBoundsObject(getSrcElement(e));
            buttonTop = positionObject.top + "px";
            buttonLeft = positionObject.left + "px";
            buttonWidth = positionObject.width + "px";
            buttonHeight = positionObject.height + "px";

            var x = 0; var y = 0;

            if (e.pageX) x = e.pageX;
            else if (e.clientX)
               x = e.clientX + (doc.documentElement.scrollLeft ? doc.documentElement.scrollLeft : doc.body.scrollLeft);

            if (e.pageY) y = e.pageY;
            else if (e.clientY)
               y = e.clientY + (doc.documentElement.scrollTop ? doc.documentElement.scrollTop : doc.body.scrollTop);

            // move listener
            container.style.left =(parseIntSize(buttonLeft) > x - 10 ? buttonLeft : x - 10 + 'px');
            container.style.top = buttonTop;
            container.style.width = '20px';
            container.style.height = '25px';
        };
        
    //setEventHandler(buttonControl, "mousemove", buttonControl_onmousemove);
    
    this.setEnabled = function(enabled){
    	this.inputctl.disabled = !enabled;
    };
    this.clearInfo = function(){
         container.innerHTML = "";
    };
    this.setOptionInfo = function(optonInfo){
    	var arrInputControls = this.frm.getElementsByTagName("INPUT");
    	for (var i = 0; i < arrInputControls.length; i++){
    		if (arrInputControls[i].id == "info"){
    			arrInputControls[i].value = optonInfo;
    			break;
    		}
    	}
    };
    
};

/**
*     @description	미결
*     @param	{object}	jsonArrayObject
*     @param	{string}	message
*     @param	{string}	commandName
*     @param	{string}	frameName
*     @return	{void}
*     @example	미결
*/
function setExcelDataA(jsonArrayObject, message, commandName, frameName){
	//오류 메시지 먼저 파악 
	if (jsonArrayObject == null){
       alert(getText("message_commandbutton_010", "오류발생:") +  message);
		this.errInfo = message;
		hideAjaxBox();
		return;
	}
	
	//데이터 업로드
	var startRow = jsonArrayObject.row;
	var startCol = jsonArrayObject.col;
	var orderKey = jsonArrayObject.orderKey;
	var columnOrder = jsonArrayObject.columnOrder;
	var paramOrder = jsonArrayObject.paramOrder;
	var data = jsonArrayObject.data;
	
	//키 정보 정리 : 일반 컨트롤과 시트 컨트롤로 나누어 시트컨트롤은 시트의 기존 업로드 함수를 사용
	var commonControlKey = new Array();
	var sheetControlKey = new Array();
	var orderKeyLength = orderKey.length;
	for(var i = 0; i < orderKeyLength; i++){
		var key = orderKey[i];
		var controlName = key.split(".")[0];
		var control = controls[controlName];
		//컨트롤이 null 또는 undefined 인 경우
		if( control == undefined || control == null){
			continue;
		}
		//컨트롤이 시트인 경우 시트 키 배열에 추가
		if( (control.controlId + "").toLowerCase().indexOf("sheet_") >= 0 ){
			sheetControlKey.push(key);
		}
		//컨트롤이 시트가 아닌 경우 일반 컨트롤 키 배열에 추가
		else{
			commonControlKey.push(controlName);
		}
	}
	
	//컨트롤에 엑셀 데이터 업로드
	var keyLength = commonControlKey.length;
	for(var i = 0; i < keyLength; i++){
		var controlName = commonControlKey[i];
		var coord = columnOrder[controlName + "."];
		var row = coord.split(",")[0] - 1;
		var col = coord.split(",")[1] - 1;
		controls[controlName].setValue(data[row][col]);
	}
	//시트에 엑셀 데이터 업로드
	keyLength = sheetControlKey.length;
	sheetControlKey.sort();
	var jsonObj = 	{
						"row" : 0,
						"col" : 0,
						"columnOrder" : null,
						"data" : null
					};
	var order = "";
	for(var i = 0; i < keyLength; i++){
		var key = sheetControlKey[i];
		var controlName = key.split(".")[0];
		var sheetCol = key.split(".")[1];
		var controlNameNext = (i + 1 < keyLength) ? sheetControlKey[i + 1].split(".")[0] : "";
		//뒷 배열의 시트명이 같다면 같은 시트이므로 순서 추가
		if(controlName == controlNameNext){
			order += "\"" + sheetCol + "\":" + "\"" + columnOrder[key] + "\"" + ",";
		}
		//뒷 배열의 시트명이 다르다면 현재 배열까지가 하나의 시트 
		else{
			//마지막 순서 추가
			order += "\"" + sheetCol + "\":" + "\"" + columnOrder[key] + "\"";
			//시트 엑셀 채우기 JSON 객체 갱신
			jsonObj.row = startRow;
			jsonObj.col = startCol;
			jsonObj.columnOrder = eval ("({" + order+ "})");
			jsonObj.data = data;
			//시트 엑셀 채우기
//			controls[controlName].setArrayData(jsonObj, "excel");
			controls[controlName].setExcelData(jsonObj, "excel");
			//엑셀 업로드 컬럼 순서 초기화
			order = "";
		}
	}

	//다시 엑셀 업로드 프레임 초기화 세팅
	var wControl = getControlById(commandName);
	//엑셀 업로드 설정값 가져옴
	var outputControlName = wControl.uploadFrame.fimeNameOutputControlName;
	var limitSize = wControl.uploadFrame.limitSize;
	var allowFileName = wControl.uploadFrame.allowFileName;
	
	uploadControls[frameName].clearInfo();
	uploadControls[frameName] = null;
	wControl.uploadFrame = null;
	wControl.uploadFrame = uploadControls[frameName] = new IFrame_UploadXL_CommandA(frameName, commandName, startRow, paramOrder, outputControlName, limitSize, allowFileName);
	
	var resultRowCount = jsonArrayObject.data.length - startRow + 1;
	
	hideAjaxBox();

	if (message.length > 0){
		//alert(message);
	} else {
		alert(getText("message_commandbutton_011", "총 {0}건의 데이터를 붙여 넣었습니다.", [resultRowCount]));
	}
	
	//업로드완료 이벤트 함수 호출
	var controlId = wControl.id;
	var checkEvent = false;
	try {
		if(eval(controlId + "_onuploadcompleted")) checkEvent = true;
	}catch(e){ /**/ };
	if (checkEvent){
		var result = eval(controlId + "_onuploadcompleted();");
	};

	return;
};

/**
*     @description	미결
*     @param	{string}	frameName
*     @return	{void}
*     @example	미결
*/
function clearUploadedLists(frameName){
	var controlname = frameName.split("[")[0];
	var controlId = controls[controlname].id;
	
	hideAjaxBox();
	
    var checkEvent = false;
   	try {
       	if (eval(controlId + "_onuploadcompleted")) checkEvent = true;
    } catch(e){};
   
    if (checkEvent){
      var result = eval(controlId + "_onuploadcompleted(\"" + frameName + "\");");
    };

	return;
};





/*
 *		2016-08-19(차중훈) 추가 - 업로드 파일 읽기 : txt, csv 파일을 업로드 하여 파일의 내용을 읽는다.
 */

/**
*     @description	미결
*     @param	{string}	name
*     @param	{string}	commandName
*     @param	{string}	outputControlName
*     @param	{number}	limitSize
*     @param	{string}	allowFileName
*     @return	{string}
*     @example	미결
*/
function IFrame_UploadFRD_Command(name, commandName, outputControlName, limitSize, allowFileName) {
	
	this.commandName = commandName;
	this.fileName = "";
	this.fimeNameOutputControlName = outputControlName ? outputControlName : "";
	this.limitSize = limitSize ? limitSize : -1;
	this.allowFileName = allowFileName ? allowFileName : "";
	
	var buttonControl = getControlById(commandName).tagObject;
	var doc = buttonControl.ownerDocument;
	var container = doc.createElement("div");
	
    // zindex 주기
    var zi=0, ziparsed;
    var obj = buttonControl;
    var comp;
    
    var positionObject = getBoundsObject(buttonControl);
    var buttonTop = positionObject.top + "px";
    var buttonLeft = positionObject.left + "px";
    var buttonWidth = positionObject.width + "px";
    var buttonHeight = positionObject.height + "px";

    zi = findHighestZIndex() + 1;
    
    container.style.zIndex = zi;
    container.style.position = 'absolute';
    container.style.overflow = 'hidden';
    container.style.padding = 0;
    container.style.margin = 0;
    container.style.visiblity = 'hidden';
    container.style.width = '0px';
    container.style.height = '0px';
    container.style.opacity = 0;
    container.style.filter = 'alpha(opacity=0)';

    doc.body.insertBefore(container, doc.body.firstChild);

    container.innerHTML = "<iframe name='" + name + "' id='" + name + "' src='about:blank'></iframe>";
    var iframe = container.childNodes[0];
    iframe.setAttribute("cmdname", commandName);
    //iframe.setAttribute("shtname", sheetName);
    
    //iframe.style.display = 'none';
    iframe.marginHeight = 0;
    iframe.marginWidth = 0;
   
    iframe.setAttribute("doc", null);
    if(iframe.contentDocument)                // Firefox, Opera  
       iframe.doc = iframe.contentDocument;

    else if(iframe.contentWindow)             // Internet Explorer  
       iframe.doc = iframe.contentWindow.document;

    else if(iframe.document)                  // Others?  
       iframe.doc = iframe.document;  

    if(iframe.doc == null)  
       throw "Document not found, append the parent element to the DOM before creating the IFrame";  

    iframe.doc.open();  
    iframe.doc.close();  
    
    var frm = iframe.doc.createElement("form");
    iframe.doc.body.appendChild(frm);  
            frm.method = 'post';
            frm.name = name + "_frm";
            frm.enctype = 'multipart/form-data';
            frm.encoding = 'multipart/form-data';
            frm.target = name ;
            frm.setAttribute('target', name );
            frm.action='uploadFileRead.do?id='+name;
            frm.style.margin = 0;
            frm.style.padding = 0;
            frm.style.height = buttonHeight;
            frm.style.width = '40px';
            frm.runat = 'server';
    
    this.frm = frm;
    
    var inputctltemp = iframe.doc.createElement("input");
    inputctltemp.name = inputctltemp.id  ="upload" ;
    inputctltemp.type = "file";  
    inputctltemp.size='1';
    inputctltemp.runat = 'server';
    inputctltemp.style.position = 'absolute';
    inputctltemp.style.top = -10000;
    inputctltemp.style.left = -10000;
    inputctltemp.style.visiblity = 'hidden';
    
    var inputctl = iframe.doc.createElement("input");
    inputctl.name = inputctl.id  ="upload" ;
    inputctl.type = "file";  
    inputctl.size='1';
    inputctl.runat = 'server';
    inputctl.disabled = !searchControl_CommandButton(buttonControl).enabled;
    //setEventHandler(inputctl, "click", controls[commandName].click()); 의미없는 코드이고, IE낮은 버전 오류
    
    
    frm.appendChild(inputctl);
    this.inputctl = inputctl;
    
    inputctl.style.position = 'absolute';
    inputctl.style.display = 'block';
    inputctl.style.top = "-2px";
    inputctl.style.left = "-10px";
    inputctl.style.height = '25px';
    inputctl.style.width = '100px';
    inputctl.style.fontSize = 8;
    inputctl.style.zIndex = 1;
    inputctl.style.visiblity = 'hidden';
    inputctl.style.marginLeft = '-40px'; // hide IE text field

    
    var filenamectl = iframe.doc.createElement("input");
    filenamectl.type = "hidden";  
    filenamectl.name="uploadfilename" ;
    filenamectl.id  ="uploadfilename" ;
    filenamectl.value = "";
     
    frm.appendChild(filenamectl);
    
    function getChildNodeById(childNodes, strId){
		for (var i=0; i < childNodes.length; i++){
			if (childNodes[i].getAttribute('id') == strId){
				return childNodes[i];
			}
		}
		return null;
	}
    /**
     * @name CommandButton#inputct1_onchange
     * @event
     * @description	미결
     */
    function inputctl_onchange(e){
    	// functionname : [IFrame_Upload.onchange]
        if (!e) e = window.event;
        var em = getSrcElement(e)
        var filePath = em.value; 
        
        //파일 확장자 체크
        if (filePath == "" || (filePath.substring(filePath.length-4) != ".txt" && filePath.substring(filePath.length-4) != ".csv")) {
            alert(getText("message_commandbutton_012", "텍스트 또는 CSV 파일을 등록하세요."));
            return;
        } 
        
        var fileName = "";
        if (filePath.indexOf("\\") > 0) {
            fileName = filePath.split("\\")[filePath.split("\\").length -1];
        } else {
        	fileName = filePath;
        }
        
        var wndw = self;
        for (var i = 0; i < 10; i++) {
        	try {
        		if (eval(wndw.getControlById)) break;
        	} catch(e) {
        		wndw = wndw.parent;
        	}
        }
        
        var commandName = "";
        var fimeNameOutputControlName = "";
        var limitSize = -1;
        var allowFileName = "";
        var cmdCtrl = null;
        
        try {
        	var iframeNodeList = wndw.document.getElementsByTagName("iframe");
        	var iframeNode = null;
        	for(var i = 0; i < iframeNodeList.length; i++){
        		iframeNode = iframeNodeList[i];
        		if( (iframeNode.getAttribute("id") + "") == (em.parentElement.getAttribute("target") + "") ){
        			cmdCtrl = wndw.getControlById( iframeNode.getAttribute("cmdname") );
        			fimeNameOutputControlName = cmdCtrl.uploadFrame.fimeNameOutputControlName;
        			limitSize = cmdCtrl.uploadFrame.limitSize;
        			allowFileName = cmdCtrl.uploadFrame.allowFileName;
        			break;
        		}
        	}
        } catch(e){}
        
        try {
        	//파일 사이즈 체크
        	if(limitSize > 0 && e.target != undefined && e.target != null){
        		if(e.target.files != undefined && e.target.files != null){
        			//파일 크기 단위 : 바이트
        			if(e.target.files.item(0).size * 1 > limitSize * 1){
        				alert(getText("message_commandbutton_007", "허용된 파일 크기를 초과하였습니다.\n(허용된 파일 크기 : {0}KB)", [(limitSize / 1024)]));
        				return ;
        			}
        		}
        	}
        	//파일명 체크
        	if(allowFileName.length > 0){
        		var fname = "";
        		//확장자를 체크하여 확장자 길이에 맞게 잘라내 파일명만 남김
        		fname = fileName.substring(0, fileName.length - 4);
        		//확장자를 제외한 파일명이 다름
        		if(allowFileName != fname){
        			alert(getText("message_commandbutton_013", "허용된 파일명이 아닙니다.\n(허용된 파일명 : txt, csv)"));
        			return ;
        		}
        	}
        	//파일명 출력
        	cmdCtrl.uploadFileName = fileName;
        	cmdCtrl.uploadFrame.fileName = fileName;
        	//controls["ExcelFilePath"].setValue(em.value);
        	if(fimeNameOutputControlName.length > 0){
        		controls[fimeNameOutputControlName].setValue(fileName);
        	}
        } catch(e){}
        
        var fileTag = timeEncodeString();
        if (em.document){
            em.document.getElementsByName("uploadfilename")[0].value = fileName;
        } else {
            //em.parentNode.childNodes.item("uploadfilename").setAttribute("value",fileName);
        	getChildNodeById(em.parentNode.childNodes, "uploadfilename").value = fileName;
       }
        
        showAjaxBox(getText("message_commandbutton_014", "{0} 파일을 읽는 중입니다.", [fileName]), 0);
        
        em.parentNode.submit();
        
	};

	setEventHandler(inputctl, "change", inputctl_onchange);

	/**
	 * @name CommandButton#container_onmouseout
	 * @event
	 * @description	미결
	 */
    function container_onmouseout(e){
        if (!e) e = window.event;

        var receiver = doc.elementFromPoint(e.clientX, e.clientY);

        if (receiver === buttonControl)
        {
        	container.style.width = '20px';
            container.style.height = buttonHeight;
        } else {
            container.style.width = '0px';
            container.style.height = '0px';
        }
    };
	
	//setEventHandler(container, "mouseout", container_onmouseout);
    
    /**
     * @name CommandButton#buttonControl_onmousemove
     * @event
     * @description	미결
     */
    function buttonControl_onmousemove(e) {
            if (!e) e = window.event;
            
            var positionObject = getBoundsObject(getSrcElement(e));
            buttonTop = positionObject.top + "px";
            buttonLeft = positionObject.left + "px";
            buttonWidth = positionObject.width + "px";
            buttonHeight = positionObject.height + "px";

            var x = 0; var y = 0;

            if (e.pageX) x = e.pageX;
            else if (e.clientX)
               x = e.clientX + (doc.documentElement.scrollLeft ? doc.documentElement.scrollLeft : doc.body.scrollLeft);

            if (e.pageY) y = e.pageY;
            else if (e.clientY)
               y = e.clientY + (doc.documentElement.scrollTop ? doc.documentElement.scrollTop : doc.body.scrollTop);

            // move listener
            container.style.left =(parseIntSize(buttonLeft) > x - 10 ? buttonLeft : x - 10 + 'px');
            container.style.top = buttonTop;
            container.style.width = '20px';
            container.style.height = '25px';
        };
        
    //setEventHandler(buttonControl, "mousemove", buttonControl_onmousemove);
    
    this.setEnabled = function(enabled){
    	this.inputctl.disabled = !enabled;
    };
    this.clearInfo = function(){
         container.innerHTML = "";
    };
    this.setOptionInfo = function(optonInfo){
    	var arrInputControls = this.frm.getElementsByTagName("INPUT");
    	for (var i = 0; i < arrInputControls.length; i++){
    		if (arrInputControls[i].id == "info"){
    			arrInputControls[i].value = optonInfo;
    			break;
    		}
    	}
    };
    
};

/**
*     @description	미결
*     @param	{string}	uploadFileContent
*     @param	{string}	message
*     @param	{string}	commandName
*     @param	{string}	frameName
*     @return	{void}
*     @example	미결
*/
function setFileReadData(uploadFileContent, message, commandName, frameName){
	//오류 메시지 먼저 파악 
	if (uploadFileContent == null){
		alert(getText("message_commandbutton_010", "오류발생:") +  message);
		this.errInfo = message;
		hideAjaxBox();
		return;
	}
	
	var fileContent = uploadFileContent;

	//다시 엑셀 업로드 프레임 초기화 세팅
	var wControl = getControlById(commandName);
	//엑셀 업로드 설정값 가져옴
	var outputControlName = wControl.uploadFrame.fimeNameOutputControlName;
	var limitSize = wControl.uploadFrame.limitSize;
	var allowFileName = wControl.uploadFrame.allowFileName;
	
	uploadControls[frameName].clearInfo();
	uploadControls[frameName] = null;
	wControl.uploadFrame = null;
	wControl.uploadFrame = uploadControls[frameName] = new IFrame_UploadFRD_Command(frameName, commandName, outputControlName, limitSize, allowFileName);
	
	hideAjaxBox();

	if (message.length > 0){
		//alert(message);
	} else {
		alert(getText("message_commandbutton_015", "파일 읽기가 완료되었습니다."));
	}
	
	//업로드완료 이벤트 함수 호출
	var controlId = wControl.id;
	var checkEvent = false;
	try {
		if(eval(controlId + "_onuploadcompleted")) checkEvent = true;
	}catch(e){ /**/ };
	if (checkEvent){
		var result = eval(controlId + "_onuploadcompleted(fileContent);");
	};
	
	
	//파일 데이터 메모리 해제
	fileContent.clear();
	fileContent = null;

	return;
}





// ========DIV BUTTON EVENT====================================================

/**
 * @name CommandButton#commandbutton_Focus
 * @event 
 * @description 버튼에 포커스가 잡혔을때 발생하는 이벤트입니다.
 */
function commandbutton_Focus(e)
{
    e=window.event || e;
	var em = getSrcElement(e);
	var control = searchControl_CommandButton(em);
    if (control.style && control.style.length > 0){
//    	control.tagObject.className="CommandButton focused " + control.style; 
//    	control.addClass("focused " + control.style);
    } else {
//    	control.tagObject.className="CommandButton focused"; 
//    	control.addClass("focused");
    }
    stopPropagation(e);
    return true;
};

/**
 * @name CommandButton#commandbutton_Blur
 * @event 
 * @description 버튼이 포커스를 잃었을때 발생하는 이벤트 입니다.
 */
function commandbutton_Blur(e)
{
    e=window.event || e;
	var em = getSrcElement(e);
	var control = searchControl_CommandButton(em);
	if (control.stateMouseDown) return false;
	
    if (control.style && control.style.length > 0){
//    	control.tagObject.className="CommandButton " + control.style; 
//    	control.removeClass("focused " + control.style);
    } else {
//    	control.tagObject.className="CommandButton"; 
//    	control.removeClass("focused");
    }
    
    stopPropagation(e);
    return true;
};

/**
 * @name CommandButton#commandbutton_MouseMove
 * @event 
 * @description 버튼에서 마우스가 움직일때 발생하는 이벤트 입니다.
 */
function commandbutton_MouseMove(e)
{
    e=window.event || e;
	var em = getSrcElement(e);
	var control = searchControl_CommandButton(em);
    
	if (!control.mouseover){
	    var coords = { x: 0, y: 0, w: 0, h: 0 };
	    var element = control.tagObject;

	    coords.w = element.offsetWidth;
		coords.h = element.offsetHeight;
		while (element && element.tagName != "BODY") {
			coords.x += element.offsetLeft;
			coords.y += element.offsetTop;
			element = element.offsetParent;
		}    

	    if (e.x >= coords.x && e.x <= (coords.x + coords.w) && e.y >= coords.y && e.y <= (coords.y + coords.h)){
		    if (control.style && control.style.length > 0){
//		    	control.tagObject.className="CommandButton focused " + control.style;
//		    	control.addClass("focused " + control.style);
		    } else {
//		    	control.tagObject.className="CommandButton focused";
//		    	control.addClass("focused");
		    }
	    }
	    control.mouseover = true;
	}
	
	stopPropagation(e);
    return true;
};

/**
 * @name CommandButton#commandbutton_MouseDown
 * @event 
 * @description 버튼을 마우스로 누르는 순간 발생하는 이벤트 입니다.
 */
function commandbutton_MouseDown(e)
{
    e=window.event || e;
	var em = getSrcElement(e);
	var control = searchControl_CommandButton(em);
    if (control.style && control.style.length > 0){
//    	control.tagObject.className="CommandButton pressed " + control.style; 
//    	control.addClass("pressed " + control.style);
    } else {
//    	control.tagObject.className="CommandButton pressed";
//    	control.addClass("pressed");
    }
    
    control.stateMouseDown = true;
    
    stopPropagation(e);
    return true;
};

/**
 * @name CommandButton#commandbutton_MouseUp
 * @event 
 * @description 버튼을 마우스로 눌렀다 때는 순간 발생하는 이벤트 입니다.(마우스 왼쪽,오른쪽 구분없음)
 */
function commandbutton_MouseUp(e)
{
    e=window.event || e;
	var em = getSrcElement(e);
	var control = searchControl_CommandButton(em);
	
	try {
		if (control.style && control.style.length > 0){
//	    	control.tagObject.className="CommandButton focused " + control.style; 
//			control.addClass("focused "+ control.style);
	    } else {
//	    	control.tagObject.className="CommandButton focused"; 
//	    	control.addClass("focused");
	    }
	    control.stateMouseDown = false;
	    
	    stopPropagation(e);
	} catch (e) {}
	
    return true;
};

/**
 * @name CommandButton#commandbutton_MouseOut
 * @event 
 * @description 버튼에서 마우스커서가 나갔을때 발생하는 이벤트 입니다.
 */
function commandbutton_MouseOut(e)
{
    e=window.event || e;
	var em = getSrcElement(e);
	var control = searchControl_CommandButton(em);

    var coords = { x: 0, y: 0, w: 0, h: 0 };
    var element = control.tagObject;
	coords.w = element.offsetWidth;
	coords.h = element.offsetHeight;
	while (element && element.tagName != "BODY") {
		coords.x += element.offsetLeft;
		coords.y += element.offsetTop;
		element = element.offsetParent;
	}    

    if (e.x < coords.x || e.x > (coords.x + coords.w) || e.y < coords.y || e.y > (coords.y + coords.h)){
        if (control.style && control.style.length > 0){
//        	control.tagObject.className="CommandButton " + control.style;
//        	control.removeClass("focused " + control.style);
        } else {
//        	control.tagObject.className="CommandButton";
//        	control.removeClass("focused");
        }
    }
    
    control.mouseover = false;
	control.stateMouseDown = false;
	
	stopPropagation(e);
    return true;
};


//function commandbutton_KeyDown(e)
//{
//    e=window.event || e;
//	var em = getSrcElement(e);
//	var wKeyCode = e.keyCode;
//	var control = searchControl_CommandButton(em);
//
//    if (wKeyCode == 13 || wKeyCode == 40){
//        return control.click();
//    } else if (wKeyCode != 9){
//    	stopEvent(e);
//        return false;
//    }
//    
//    stopPropagation(e);
//};
/**
 * @name CommandButton#commandbutton_MouseOut
 * @event 
 * @description 버튼에 포커스가 있는 상태에서  키를 눌렀을때 발생하는 이벤트 입니다.
 */
function commandbutton_KeyDown(e)
{
	//F5새로고침 방지 추가
	if(e.keyCode == 116) {
		if(typeof e.preventDefault == "function") {
			e.preventDefault();
		} else {
			e.returnValue = false; // for IE
		}
		return false;
	}	
	 	
    e = window.event || e;
    var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
    var wKeyCode = e.keyCode;
	var control = searchControl_CommandButton(em);
	if (wKeyCode == 9){
		if (getShiftKeyPressed(e)){
			stopEvent(e);
			setTimeout("setFocusToFormerControl(\"" + control.controlName + "\")", 0);
	   		return true;
		} else {
    		stopEvent(e);
    		setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
    		return true;
		}
    } else if (wKeyCode == 13){
		stopEvent(e);
		return control.click();
		setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
		return true;
    }

    stopPropagation(e);
    
    // e.returnValue = true;
    return true;
};
/**
 * @name CommandButton#commandbutton_KeyUp
 * @event 
 * @description 버튼에 포커스가 있는 상태에서  키를 눌렀다가 땔때 발생하는 이벤트 입니다.
 */
function commandbutton_KeyUp(e)
{
    e=window.event || e;
	var em = getSrcElement(e);
	var wKeyCode = e.keyCode;
	var control = searchControl_CommandButton(em);

    if (wKeyCode == 13){
        if (control.style && control.style.length > 0){
//        	control.tagObject.className="CommandButton focused " + control.style; 
//        	control.addClass("focused " + control.style);
        } else {
//        	control.tagObject.className="CommandButton focused";
//        	control.addClass("focused");
    
        }
        return true;
    }
    
    stopPropagation(e);
    return true;
};/**
 * http://www.openjs.com/scripts/events/keyboard_shortcuts/
 * Version : 2.01.B
 * By Binny V A
 * License : BSD
 */
shortcut = {
	'all_shortcuts':{},//All the shortcuts are stored in this array
	'add': function(shortcut_combination,callback,opt) {
		//Provide a set of default options
		var default_options = {
			'type':'keydown',
			'propagate':false,
			'disable_in_input':false,
			'target':document,
			'keycode':false
		}
		if(!opt) opt = default_options;
		else {
			for(var dfo in default_options) {
				if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
			}
		}

		var ele = opt.target
		if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
		var ths = this;
		shortcut_combination = shortcut_combination.toLowerCase();

		//The function to be called at keypress
		var func = function(e) {
			e = e || window.event;
			
			if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
				var element;
				if(e.target) element=e.target;
				else if(e.srcElement) element=e.srcElement;
				if(element.nodeType==3) element=element.parentNode;

				if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
			}
	
			//Find Which key is pressed
			if (e.keyCode) code = e.keyCode;
			else if (e.which) code = e.which;
			var character = String.fromCharCode(code);
			
			if(code == 188) character=","; //If the user presses , when the type is onkeydown
			if(code == 190) character="."; //If the user presses , when the type is onkeydown

			var keys = shortcut_combination.split("+");
			//Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
			var kp = 0;
			
			//Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
			var shift_nums = {
				"`":"~",
				"1":"!",
				"2":"@",
				"3":"#",
				"4":"$",
				"5":"%",
				"6":"^",
				"7":"&",
				"8":"*",
				"9":"(",
				"0":")",
				"-":"_",
				"=":"+",
				";":":",
				"'":"\"",
				",":"<",
				".":">",
				"/":"?",
				"\\":"|"
			}
			//Special Keys - and their codes
			var special_keys = {
				'esc':27,
				'escape':27,
				'tab':9,
				'space':32,
				'return':13,
				'enter':13,
				'backspace':8,
	
				'scrolllock':145,
				'scroll_lock':145,
				'scroll':145,
				'capslock':20,
				'caps_lock':20,
				'caps':20,
				'numlock':144,
				'num_lock':144,
				'num':144,
				
				'pause':19,
				'break':19,
				
				'insert':45,
				'home':36,
				'delete':46,
				'end':35,
				
				'pageup':33,
				'page_up':33,
				'pu':33,
	
				'pagedown':34,
				'page_down':34,
				'pd':34,
	
				'left':37,
				'up':38,
				'right':39,
				'down':40,
	
				'f1':112,
				'f2':113,
				'f3':114,
				'f4':115,
				'f5':116,
				'f6':117,
				'f7':118,
				'f8':119,
				'f9':120,
				'f10':121,
				'f11':122,
				'f12':123
			}
	
			var modifiers = { 
				shift: { wanted:false, pressed:false},
				ctrl : { wanted:false, pressed:false},
				alt  : { wanted:false, pressed:false},
				meta : { wanted:false, pressed:false}	//Meta is Mac specific
			};
                        
			if(e.ctrlKey)	modifiers.ctrl.pressed = true;
			if(e.shiftKey)	modifiers.shift.pressed = true;
			if(e.altKey)	modifiers.alt.pressed = true;
			if(e.metaKey)   modifiers.meta.pressed = true;
                        
			for(var i=0; k=keys[i],i<keys.length; i++) {
				//Modifiers
				if(k == 'ctrl' || k == 'control') {
					kp++;
					modifiers.ctrl.wanted = true;

				} else if(k == 'shift') {
					kp++;
					modifiers.shift.wanted = true;

				} else if(k == 'alt') {
					kp++;
					modifiers.alt.wanted = true;
				} else if(k == 'meta') {
					kp++;
					modifiers.meta.wanted = true;
				} else if(k.length > 1) { //If it is a special key
					if(special_keys[k] == code) kp++;
					
				} else if(opt['keycode']) {
					if(opt['keycode'] == code) kp++;

				} else { //The special keys did not match
					if(character == k) kp++;
					else {
						if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
							character = shift_nums[character]; 
							if(character == k) kp++;
						}
					}
				}
			}
			
			if(kp == keys.length && 
						modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
						modifiers.shift.pressed == modifiers.shift.wanted &&
						modifiers.alt.pressed == modifiers.alt.wanted &&
						modifiers.meta.pressed == modifiers.meta.wanted) {
				callback(e);
	
				if(!opt['propagate']) { //Stop the event
					//e.cancelBubble is supported by IE - this will kill the bubbling process.
					e.cancelBubble = true;
					e.returnValue = false;
	
					//e.stopPropagation works in Firefox.
					if (e.stopPropagation) {
						e.stopPropagation();
						e.preventDefault();
					}
					return false;
				}
			}
		}
		this.all_shortcuts[shortcut_combination] = {
			'callback':func, 
			'target':ele, 
			'event': opt['type']
		};
		//Attach the function with the event
		if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
		else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
		else ele['on'+opt['type']] = func;
	},

	//Remove the shortcut - just specify the shortcut and I will remove the binding
	'remove':function(shortcut_combination) {
		shortcut_combination = shortcut_combination.toLowerCase();
		var binding = this.all_shortcuts[shortcut_combination];
		delete(this.all_shortcuts[shortcut_combination])
		if(!binding) return;
		var type = binding['event'];
		var ele = binding['target'];
		var callback = binding['callback'];

		if(ele.detachEvent) ele.detachEvent('on'+type, callback);
		else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
		else ele['on'+type] = false;
	}
};/**
 * @class AUIDataAction
 * @constructor AUIDataAction
 * 
 * @param controlId
 *            {String} 해당 컨트롤의 ID를 지정합니다.
 * @param controlName
 *            {String} 해당 컨트롤의 Name을 지정합니다.
 * @param tagObject
 *            {Object} 해당 컨트롤의 태그 객체를 지정합니다.
 * 
 * @return 객체 생성 성공하면 객체의 errorMsg 필드가 null 입니다.<br>
 *         만약 에러가 발생한다면 errorMsg 필드에 에러메시지를 반환합니다.
 * 
 * @example var wControl = controls["link_1"] = new Linker("link_1", "Link_1",
 *          document.getElementsByName("link_1")[0]); if(wControl.errorMsg !=
 *          null){ //객체 생성 실패하였습니다. 에러처리 코드를 입력해주세요. }																								
 *  // 후속코드 생략...
 */

/**
 * @description	미결
 * @param		{Object}	recordset
 * @param		{String}	fieldName
 * @param		{String}	dataType
 * @return		{Undefined}
 * @example		미결
 */
function Field(recordset, fieldName, dataType){
    this.recordset = recordset;
    this.fieldName = fieldName.toLowerCase();
    this.dataType = dataType;
    
    this.datas = [];
};

/**
 * @description	미결
 * @returns		{Object}
 * @example		미결
 */
Field.prototype.value = function(){
    // functionname : [Field.value]

	var wValue;
	if (this.dataType == SQL_TYPE_INTEGER ||
	    this.dataType == SQL_TYPE_SMALLINT){
		    if (this.datas[this.recordset.currentRow] == undefined){
	    		wValue = 0;
		    } else {
	    		wValue = parseInt(1 * this.datas[this.recordset.currentRow]);
		    }
    } else if (this.dataType == SQL_TYPE_NUMERIC ||
	        this.dataType == SQL_TYPE_DECIMAL ||
	        this.dataType == SQL_TYPE_FLOAT ||
	        this.dataType == SQL_TYPE_REAL ||
	        this.dataType == SQL_TYPE_DOUBLE ){
	    if (this.datas[this.recordset.currentRow] == undefined){
    		wValue = 0.0;
	    } else {
	    	wValue = parseFloat(1.0 * this.datas[this.recordset.currentRow]);
	    }
    } else {
	    if (this.datas[this.recordset.currentRow] == undefined){
    		wValue = "";
	    } else {
	    	wValue = this.datas[this.recordset.currentRow];
	    }
    }
	
    return wValue; 
};

/**
 * @description	미결
 * @returns		{Object}
 * @example		미결
 */
Field.prototype.setValue = function(){
    // functionname : [Field.setValue]

    return this.datas[this.recordset.currentRow] = Value; 
};

/**
 * @description	미결
 * @returns		{Void}
 * @example		미결
 */
Field.prototype.destroy = function(){
    // functionname : [Field.destroy]

    this.recordset = null;
    
    this.datas.clear();
    this.datas = null;
	return;
};

/**
 * @description	미결
 * @param		{Object}	recordset
 * @returns		{Void}
 * @example		미결
 */
Recordset.prototype.AUIopen = function(/*AUIControlId, */recordset){
	
	showAjaxBox(getText("message_AUIDataAction_001", "자료를 조회하는 중입니다."), 0);
	
    // 데이터를 리턴받는 경우 레코드셋을 미리 만들어 두고 이 루틴을 호출할 것
    var recordsetId = this.id;
    this.casheKey = ""; var ndx = 0;
    for (var wKey in this.parameters){
    	if (this.parameters[wKey] instanceof Function) continue;
    	this.casheKey += (ndx++ > 0 ? ":" : "");
    	this.casheKey += this.parameters[wKey].value();
    }
    
    if (this.id.length > 9 && this.id.substring(0,9) == "fillList_"){
        if (dataCashes[this.sqlnum + ":" + this.casheKey] != undefined){
        	this.setCashedData();
        	return;
        }
    }
    
    
    // 파라메터 정보에는 콜론이 하나 더 붙는다.
    var wParamInfo = this.casheKey + ":";

    var wQueryString = "lang=" + USER_LANGUAGE
                     + "&cogu=" + USER_COGU
                     + "&personalId=" + USER_PERSONALID
			         + "&sqlnum=" + this.sqlnum
			         + "&pageNum=" + this.pageNum
			         + "&pageSize=" + this.pageSize
			         + "&permitNull=" + this.permitNullParam
			         + "&smode=" + this.smode
			         + "&paramInfo=" + encodeURIComponent(wParamInfo)
			         + "&formid=" + USER_FORMID
			         + "&tm=" + (new Date()).valueOf() + (Math.floor(Math.random() * 1000) + 1);
    
	ajax( {
		url : getContextPath()+((TEST_MODE == undefined || !TEST_MODE) ? "/AUIquery.do" : "/test/AUIquery.do"),
		type : "POST",
		data : wQueryString, // 쿼리
		async: false, // false 일땐 동기방식으로 요청 ( cross-domain 에서는 지원하지 않는다)
		complete : function(){
			alert(getText("message_AUIDataAction_002", "s"));
		},
		onSuccess : function(jsonActionObject) {
			//-- 서버 사이드에서 보낸 메세지 (에러 등 메세지를 출력시킴)
//			if(typeof jsonActionObject == "string" || !jsonActionObject) {
			if (jsonActionObject.errorMsg.length > 0){
				hideAjaxBox();
				callEvent(recordsetId + "_OnReceiveErr", jsonActionObject.errorMsg);
				return;
			}
			
			// 서버데이터 분석
			recordset.rowCount= jsonActionObject.recordList.length;

			recordset.AUIrecordList = jsonActionObject.recordList;
		   
		    // 결과값 분석, 두번쨰 페이지 부터는 안 넘어온다. 처음 조회내용 유지
		    if (recordset.smode == "N" && jsonActionObject.rowCount > 0){
		    	recordset.totalRowCount = jsonActionObject.rowCount;
		    } else if (recordset.smode == "Y"){
		    	recordset.totalRowCount = 9999999;
		    }
		    
		    recordset.EOF = (recordset.AUIrecordList.length == 0);
		    
		    // 이벤트일으키기
		    var checkFunction = false;
			try {
		    	if (eval(recordsetId + "_OnReceive")) checkFunction = true;
		    } catch(e){}
		    if (checkFunction) eval(recordsetId + "_OnReceive()");
		    
		    hideAjaxBox();
		},
		onError : function(request,status,error) {
			hideAjaxBox();
			callEvent(recordsetId + "_OnReceiveErr", error);
			return;
		}
	});
    
    return;
};


//ajax 요청 전역 함수...기본적으로 XMLHttpRequest 를 사용하며
//IE인 경우 저버전(XMLHttpRequest 지원하지 않는 브라우저) 체크하여 XMLHTTP 로 요청하는 모듈

/**
 * @description	미결
 * @param		{Object}	props
 * @returns		{Undefined}
 * @example		미결
 */
function ajax(props) {
 var target = props.target ? props.target : null;
 var currentTarget = props.currentTarget ? props.currentTarget : null;
 var isLocal =  location.href.indexOf("http") >= 0  && location.href.indexOf("http") <= 3 ? false : true;
 props = {
     type: props.type || "GET", // 요청 메소드(get or post)
	    url: props.url || "", // 요청 URL
	    timeout: props.timeout || 30000, // 응답 타임아웃
	    onError: props.onError || function() {}, // 에러 핸들러
	    onSuccess: props.onSuccess || function() {}, // 성공 핸들러
	    data: props.data || "" // 요청 시 보낼 데이터(파라메터)
 };
 var i, xhr, activeXObjects = ["MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"];
 if ("ActiveXObject" in window) {
     if (isLocal) {
         xhr = new ActiveXObject("Microsoft.XMLHTTP");
     }
 }
 if (!xhr) {
     try {
         xhr = new XMLHttpRequest();
     } catch (e) {
         for (i = 0; i < activeXObjects.length; i++) {
             try {
                 xhr = new ActiveXObject(activeXObjects[i]);
                 break;
             } catch (e) {}
         }
     }
 }
 var timeout = props.timeout;
 var isTimeout = false;
 setTimeout(function() {
     isTimeout = true;
 }, timeout);
 xhr.onreadystatechange = function() {
     if (xhr.readyState == 4 && !isTimeout) {
         var e = {};
         if (target) {
             e.target = target;
         }
         if (currentTarget) {
             e.currentTarget = currentTarget;
         }
         if (isSuccess(xhr)) {
             var contentType = xhr.getResponseHeader("content-type");
             var resultData = null;
             if( contentType && contentType.indexOf("xml") >= 0 ) {
                 resultData = xhr.responseXML;
             } else if(xhr.responseText){
                 resultData = parseJSON(xhr.responseText);
             }
             props.onSuccess.call(xhr, resultData, e);
         } else {
             props.onError.call(xhr, xhr.status, e);
         }
         xhr = null;
     }
 };
 try {
     xhr.open(props.type, props.url, true);
     xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");
     xhr.send(props.data);
 } catch (e) {
     props.onError(e.message);
 }

 /**
  * @description	미결
  * @param			{Object}	xhr
  * @returns		{Boolean}
  * @example		미결
  */
 function isSuccess(xhr) {
     try {
         return !xhr.status && isLocal || (xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || navigator.userAgent.indexOf("Safari") >= 0 && Cs(xhr.status);
     } catch (e) {}
     return false;
 };
 
 /**
  * @description	미결
  * @param			{String}	data
  * @returns		{String}
  * @example		미결
  */
 function parseJSON(data) {
 	var obj;
		if ( window.JSON && window.JSON.parse ) {
			try {
				obj = window.JSON.parse( data + "" );
			} catch(e) {
				obj = data;
			}
		} else {
			try {
				obj = (function() { return eval(data); })();
			} catch (e) {
				obj = data;
			}
		}
 	return obj;
	};
};
/**
 *   @autor   winnersoft korea
 *   @version 5.0
 *   @see     winnersoft.co.kr
 */

/**
 * @description 
 *     EasyMaker Vertical Data Sheet For Big Data.
 * 
 * @constructor
 * 
 * @param {string} 	 controlId 	 - 콘트롤 고유 아이디 (영문)
 * @param {string} 	 controlName - 콘트롤 명 (사용자 고유 언어)
 * @param {HTMLNode} tagObject   - HTML 본문중의 매칭되는 HTML DOM Node. 
 * @return {Object} - 생성된 EasySheet 개체
 * @exception 널값 예외
 * 
 * @example 
 * var sheet = new EasySheet("Sheet_1", "sheet_1", document.getElementsByName("XX")[0]);
 */
function EasySheet(controlId, controlName, tagObject) // constructor
{
	/* 물리적인 시트 연결 정보 */   
	this.sheetRenderer = new EasySheetRenderer(controlId, controlName, tagObject);
	this.sheetRenderer.sheet = this;
	
	/* 그루핑 및 피벗팅개체 */
	this.pivot = null;
	this.sumUp = null; 
	this.needGrouping = false;
	this._pivotCaptionSettings = null; //피벗용 추가헤더 정보
	
	this.displayInfo = {
		startRow: 0
		, endRow: 0
		, dataCount: 0
		, rowsPerDataRow: 1
		, leftFrozens: 0
		, rightFrozens: 0
		, topFrozens: 0
		, bottomFrozens: 0
	};	// 여기서 Row는 모두 레코드 기준, 사이즈가 줄면 이것도 조정된다 
	
	/** [읽기 전용] 메모리 데이터 셋 <br/> dataSet은 고유값으로서 변경될 수 없다.
	 *  @type {DataSet}  
	 *  */
	this.sheetRenderer.dataSet = this.dataSet = new WsDataSet();
	
	/** [읽기 전용] 콘트롤명 <br/> 콘트롤 명은 고유값으로서 변경될 수 없다.
	 *  @type {String}  
	 *  */
	this.controlName = controlName || "";
	
	/** [읽기 전용] 콘트롤ID <br/> 콘트롤 ID는 고유값으로서 변경될 수 없다. <br/> sheet.controlId는 sheet.id와 같다.
	 *  @type {String}  
	 *  */
	this.controlId = controlId || "";
	
	/*  콘트롤ID  */   
	/** [읽기 전용] 시트의 ID <br/> 시트 ID는 고유값으로서 변경될 수 없다. <br/>sheet.id는 sheet.controlId와 같다.
	 *  @type {String}  
	 *  */
	this.id   = this.controlId; //콘트롤 아이디와 같다.
	
	/** [읽기 전용] HTML 컨테이너가 되는 DIV 태그 <br/> 태그값은 기본설정이므로 변경될 수 없다. 
	 *  @type {Element}  
	 *  */
	this.tagObject = tagObject || null;
	
	/*   */   
	/** [읽기 전용] 읽기 전용 시트인지 구분 <br/>SHEETTYPE_DATASHEET: 입력가능 시트, SHEETTYPE_LISTSHEET: 읽기 전용시트 
	 *  @type {Number}  
	 *  */
	this.sheetType = SHEETTYPE_DATASHEET; //시트유형 - SHEETTYPE_DATASHEET(입력가능) / SHEETTYPE_LISTSHEET(읽기전용)
	
	
	/* {EasyObject[]} 연결 객체  */
	this.linkedObjects = [];    // 반드시 0번 부터 시작된다
	
	/* {DataSet[]} 연결 데이터셋  */
	this.linkedDataset = null;
	this.dataBinds = [];     	// 데이터 링크된 콘트롤들 
	this.bindDataset = "";

	this.startRowColNum = 0;	// 1부터 행번호가 동작하려면  this.startRowNum = 1
	
	this.columns = [];			// 반드시 0번 부터 시작된다
	this.footers = [];			// 반드시 0번 부터 시작된다
	
	this.maxCols = 0;			// Logical 데이터의 최대칼럼수
	this.maxRows = 0;			// Logical 데이터의 최대줄수
	
	this.currentRow = 0;		// Logical (this.startRowColNum이 반영된 줄번호이다)
	this.currentCol = 0;		// Logical (this.startRowColNum이 반영된 열번호이다)
	
	
	// 연결된 렌더러를 리프래시함 
	this.instantUpdateControl = true;
	
	// 이벤트를 일으킬 것인지 여부
	this.FireEvent = true;
	
	// RowChange 이벤트를 스킵하는 용도로 사용된다
	this.inClearMode = false;
    
    // 리스트 시트를 한번 선택한적이 있으면 Dirty이다, currentRow, currentCol을 주기위해 사용된다 
	this.dirty = false;	// 필요성 차선책 검토필요
	
	//스마트 그리드 용 속성
	this.noMoreData = false;
	
	// 마지막줄에서 더이상 갈 수 없을때 줄추가 여부를 다루는 부분이다 
    this.addRowAtEnd = false;
	
	// addRow, setValue, setText 에서 사용된다.
	this.inputMode = SHEETMODE_SETCELL; //SHEETMODE_SETCELL : GUI만 수정, SHEETMODE_SETDATA : GUI는 수정 안되고 데이터 만 채움
	
	
	/** [읽기 전용] boolean 동작가능 여부 <br/>변경은 controls["시트명"].setEnabled(설정값) 을 활용한다. 
	 *  @type {boolean}  
	 *  */
	this.enabled = true;
	
	/** [읽기 전용] 보이기 여부 <br/>변경은 controls["시트명"].setVisible(설정값) 을 활용한다.
	 *  @type {boolean}  
	 *  */
	this.visible = true;
	
	// 편집 가능
	this.permitEditable = true;
	
	// 역순행번호
	this.rowNumOrder = true;		// true : 정방향 행번호 | false : 역방향 행번호
	// 행열 타이틀
	this.rowColHeaderTitle = "";
	
	// 컬럼 리사이즈, 이동
	this.permitCellResize = true;	// 마우스로 셀 조정
	this.permitColumnMove = false;	// 마우스로 컬럼 이동, ???
	
	// 고정셀 수정 가능
	this.permitEditFixedColumn = true;
	
	// 마우스 휠 반응도
	this.wheelMovementRows = 1;
	
	//탭키 동작
	this.tabKeyAction = 0;			// 다음 컨트롤 : 0-SHEET_TAB_TONEXTCTRL
	
	// 팝업 메뉴 사용여부
	this.useContextMenu = true;		// 헤더 우클릭시 팝업메뉴 사용 여부
	
	// 정렬
	this.sortOnHeaderClick = true;	// 선택정렬
	this.sortSpecialColumn = false;	// 이지메이커 에서 정렬 기준 컬럼 , ???: 여러 칼럼 기준 소트 추가
	
	// 필터링 정보
	this._filterState = {};   		// 형식: {colId:{formula:"", func:function()}, ... }
	
	// 스크롤바
	this.displayScrollBar = true;	// 스크롤바 보이기 여부, false인 경우 무조건 스크롤바는 생성되지 않음
	
	//셀 선택 모드
	this.selectMode = SHEET_SELECT_CELL; // SHEET_SELECT_NONE : 선택안함 | SHEET_SELECT_CELL : 셀단위 선택 | SHEET_SELECT_ROW : 행단위 선택
	
	//
	this.rowClass = null;
	
	//줄 색깔 구분
	this.displayOddEven = true;
	
	//행, 열타이틀 숨기기
//	this.displayRowNum = true;
	this.hideRowHeader = false; 	// 줄타이틀 숨기기
	this.hideColHeader = false; 	// 열타이틀 숨기기
	
	// 머지상태점검변수  SHEET_MERGE_UNFIXED(=0): 아직모른다  SHEET_MERGE_NEED_NOT(=1): 머지가 불필요하다  SHEET_MERGE_NEED(=2): 머지가 필요하다
	this.needMerge = SHEET_MERGE_UNFIXED;
	
	// 시트 디자인 속성
	this.displayRowCount = this.sheetRenderer.displayMaxRowCount;
	this.displayInfo.endRow = this.displayRowCount - 1;
	this.displayInfo.dataCount = this.displayRowCount;
	this.displayInfo.rowsPerDataRow = this.sheetRenderer.rowsPerDataRow;
	this.displayInfo.colsPerRow = this.sheetRenderer.colsPerRow;
	
//	this.sheetFontName = "";		// 시트 글꼴
//	this.sheetFontBold = "";		// 시트 글자 bold
//	this.sheetFontItalic = "";		// 시트 글자 기울기
//	this.sheetFontUnderLine = "";	// 시트 글자 밑줄
//	this.sheetFontStrike = "";		// 시트 글자 취소선
//	this.sheetFontColor = "";		// 시트의 글자색
//	this.sheetFontSize = "";		// 시트의 글자 크기
//	this.sheetBorderColor = "#CCC";	// 시트의 border 색
	
//	this.headRows = 1;
//	this.headCols = 1;
//	this.addHeaderRows = 0;
	
//	this.frozenColsLeftCnt = 0;		// 좌측고정열의 열 수
//	this.frozenColsRightCnt = 0;	// 우측고정열의 열 수
	
	// 셀의 선택동작용 변수들, 차대리: BlockSelect Event 일으켜야 사용 
	this.blockMode = false;
	this.col = -1; this.col2 = -1;  // Logical, -1 은 전체 선택
	this.row = -1; this.row2 = -1;  // Logical, -1 은 전체 선택
	
	// 산식정보 셀들 : 참조되는 셀들을 기준으로 나열된다
	this._formulaRefs = {};	// 참조 관계를 기억 FormulaInfo 객체들어감
	this._calcOrders = [];	// 연산 순서를 기억 "R1C1"형 데이터 들어감  
	this.autoCalc = true;
	
	// 시트의 외양에 관한 변수들
	this.colSpanCells = null;			// 가로 병합정보
	this.rowspancells = null;			// 세로 병합정보
	this.spanEndColNums = null;
	this.spanStartColNums = null;
	this._moveReferenceRange = null;	// 컬럼이동시 이동 함수를 호출할만큼 충분히 마우스 이동이 일어났는지를 체크한다.[0] : X, [1] : Y
	this.moveTorowSpanPrevRow = -1;		// 병합된 시트에서 키보드로 셀 이동시에 필요한 함수
	this.moveTorowSpanPrevCol = -1;		// 병합된 시트에서 키보드로 셀 이동시에 필요한 함수
	
	this.logicalRowHeights = 0;			// ??? 논리적인 데이터 한줄의 높이 (this.rowHeights[] 배열 값들의 합)
	this.headSpanInfo = [];				// ??? 각 요소는 2차원 배열임 cellSpanInfo가 들어감
	
	
	this.hasTreeCell = false;			// cellTree: 머지된 셀의 트리동작
	
	
	// 시트 렌더러에 초기화된 상태값을 읽어 시트 속성에 설정
	if( (typeof this.sheetRenderer != undefined) && (this.sheetRenderer instanceof EasySheetRenderer) ){
		// SHEETTYPE_DATASHEET(입력가능) / SHEETTYPE_LISTSHEET(읽기전용)
		this.sheetType = ((this.sheetRenderer.isListSheet) ? SHEETTYPE_LISTSHEET : SHEETTYPE_DATASHEET);
		// SHEET_SELECT_NONE : 선택안함 | SHEET_SELECT_CELL : 셀단위 선택 | SHEET_SELECT_ROW : 행단위 선택
		this.selectMode = this.sheetRenderer.selectMode;
		// 줄타이틀 숨기기
		this.hideRowHeader = !(this.sheetRenderer.isShowRowHeader);
		// 열타이틀 숨기기
		this.hideColHeader = !(this.sheetRenderer.isShowColHeader);
	}
	
	// 시트가 비어있는 경우 빈 한 줄을 추가
	if( this.dataSet.data.length != 1 ){
		this.dataSet.clear();
		this.dataSet.insertData(this.startRowColNum);
		this.maxRows++;
		this.dataSet.setState(this.startRowColNum, "rowNum", this.maxRows);
		this.dataSet.setState(this.startRowColNum, "objectSeq", 1);
	}
	
	// 화면상 시트갱신, 데이터만 갱신
    this.updateScreen(SHEET_RESET_DATA);
	
	//이벤트 처리
	this.hasDelRowEvent = false;			this.fncDelRowEvent = null;
	this.hasAddRowEvent = false;			this.fncAddRowEvent = null;
	this.hasRowChangeEvent = false;			this.fncRowChangeEvent = null;
	this.hasColChangeEvent = false;			this.fncColChangeEvent = null;
	this.hasChangeEvent = false;			this.fncChangeEvent = null;
	this.hasChangeComboTextEvent = false;	this.fncChangeComboTextEvent = null;
	this.hasClearEvent = false;				this.fncClearEvent = null;
	this.hasClickEvent = false;				this.fncClickEvent = null;
	this.hasValidateEvent = false;			this.fncValidateEvent = null;
	this.hasCommandClickEvent = false;		this.fncCommandClickEvent = null;
	this.hasScrollEvent = false;			this.fncScrollEvent = null;
	this.hasDblClickEvent = false;			this.fncDblClickEvent = null;
	this.hasSortedEvent = false;			this.fncSortedEvent = null;
	this.hasKeyDownEvent = false;			this.fncKeyDownEvent = null;
	this.hasKeyPressEvent = false;			this.fncKeyPressEvent = null;
	this.hasKeyUpEvent = false;				this.fncKeyUpEvent = null;
	
	if( this.controlId.length > 0 ){
		this.hasDelRowEvent = (typeof self[this.controlId + "_ondelrow"] != "undefined");
		if( this.hasDelRowEvent ){
			/**
			 * 줄 삭제(DelRow) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_delrow
			 * @type {Object}
			 * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
			 * @property {Number} atRowNum - 삭제된 줄번호
			 */
			this.fncDelRowEvent = new Function("return function (atRowNum) { return " + this.controlId + "_ondelrow(atRowNum); }")();
		}
		
		this.hasAddRowEvent = (typeof self[this.controlId + "_onaddrow"] != "undefined");
		if( this.hasAddRowEvent ){
			/**
			 * 줄 추가(AddRow) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_addrow
			 * @type {Object}
			 * @property {Number} atRowNum - 추가될 위치의 줄번호 
			 */
			this.fncAddRowEvent = new Function("return function (atRowNum) { return " + this.controlId + "_onaddrow(atRowNum); }")();
		}
		
		this.hasRowChangeEvent = (typeof self[this.controlId + "_onrowchange"] != "undefined");
		if( this.hasRowChangeEvent ){
			/**
			 * 줄 선택 (RowChange) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_rowchange
			 * @type {Object}
			 * @property {Number} rowNumFrom - 줄 선택전 상태의 줄번호
			 * @property {Number} rowNumTo   - 선택된 새로운 줄번호
			 * @property {Number} objectSeq  - 연경된 객체의 순번 
			 */
			this.fncRowChangeEvent = new Function("return function (rowNumFrom, rowNumTo, objectSeq) { return " + this.controlId + "_onrowchange(rowNumFrom, rowNumTo, objectSeq); }")();
		}
		
		this.hasColChangeEvent = (typeof self[this.controlId + "_oncolchange"] != "undefined");
		if( this.hasColChangeEvent ){
			/**
			 * 행 선택 (ColChange) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_colchange
			 * @type {Object}
			 * @property {Number} colNumFrom - 칼럼 변경 전 상태의 칼럼번호
			 * @property {Number} colNumTo   - 선택된 칼럼번호
			 */
			this.fncColChangeEvent = new Function("return function (colNumFrom, colNumTo) { return " + this.controlId + "_oncolchange(colNumFrom, colNumTo); }")();
		}
		
		this.hasChangeEvent = (typeof self[this.controlId + "_onchange"] != "undefined");
		if( this.hasChangeEvent ){
			/**
			 * 셀 내용 변경 (Change) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_EasySheet_change
			 * @type {Object}
			 * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
			 * @property {Number} rowNum   - 수정된 줄번호
			 * @property {Number} colNum   - 수정된 열번호
			 * @property {Number} value    - 수정 후 셀값
			 * @property {Number} oldValue - 수정 전 셀값
			 */
			this.fncChangeEvent = new Function("return function (rowNum, colNum, value, oldValue) { return " + this.controlId + "_onchange(rowNum, colNum, value, oldValue); }")();
		}
		
		this.hasChangeComboTextEvent = (typeof self[this.controlId + "_onchangeCombotext"] != "undefined");
		if( this.hasChangeComboTextEvent ){
			/**
			 * 콤보 셀 선택 변경(ChangeComboText) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_changeCombotext
			 * @type {Object}
			 * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
			 * @property {Number} rowNum   - 수정된 줄번호
			 * @property {Number} colNum   - 수정된 열번호
			 * @property {Number} value    - 수정 후 셀값
			 * @property {Number} oldValue - 수정 전 셀값
			 */
			this.fncChangeComboTextEvent = new Function("return function (rowNum, colNum, value, oldValue) { return " + this.controlId + "_onchangeCombotext(rowNum, colNum, value, oldValue); }")();
		}
		
		this.hasClearEvent = (typeof self[this.controlId + "_onclear"] != "undefined");
		if( this.hasClearEvent ){
			/**
			 * 시트 클리어(Clear) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_clear
			 * @type {Object}
			 */
			this.fncClearEvent = new Function("return function () { return " + this.controlId + "_onclear(); }")();
		}
		
		this.hasClickEvent = (typeof self[this.controlId + "_onclick"] != "undefined");
		if( this.hasClickEvent ){
			/**
			 * 시트 클릭(Click) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_click
			 * @type {Object}
			 * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
			 * @property {Number} rowNum   - 선택된 줄번호
			 * @property {Number} colNum   - 선택된 열번호
			 */
			this.fncClickEvent = new Function("return function (rowNum, colNum) { return " + this.controlId + "_onclick(rowNum, colNum); }")();
		}
		
		this.hasValidateEvent = (typeof self[this.controlId + "_onvalidate"] != "undefined");
		if( this.hasValidateEvent ){
			/**
			 * 셀값 체크(Validate) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_validate
			 * @type {Object}
			 * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
			 * @property {Number} colNum   - 수정된 열번호
			 * @property {Number} value    - 수정 후 셀값
			 */
			this.fncValidateEvent = new Function("return function (colNum, value) { return " + this.controlId + "_onvalidate(colNum, value); }")();
		}
		
		this.hasCommandClickEvent = (typeof self[this.controlId + "_oncommandclick"] != "undefined");
		if( this.hasCommandClickEvent ){
			/**
			 * 버튼 클릭(Command Click) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_commandclick
			 * @type {Object}
			 * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
			 * @property {Number} rowNum   - 선택된 줄번호
			 * @property {Number} colNum   - 선택된 열번호
			 */
			this.fncCommandClickEvent = new Function("return function (rowNum, colNum) { return " + this.controlId + "_oncommandclick(rowNum, colNum); }")();
		}
		
		this.hasImageClickEvent = (typeof self[this.controlId + "_onimageclick"] != "undefined");
		if( this.hasImageClickEvent ){
			/**
			 * 이미지 클릭(Image Click) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_imageclick
			 * @type {Object}
			 * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
			 * @property {Number} rowNum   - 선택된 줄번호
			 * @property {Number} colNum   - 선택된 열번호
			 */
			this.fncImageClickEvent = new Function("return function (rowNum, colNum) { return " + this.controlId + "_onimageclick(rowNum, colNum); }")();
		}
		
		this.hasScrollEvent = (typeof self[this.controlId + "_onscroll"] != "undefined");
		if( this.hasScrollEvent ){
			/**
			 * 시트 스크롤(Scroll) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_scroll
			 * @type {Object}
			 * @property {Number} oldTopIndex   - 스크롤 이전 최상위 행의 인덱스
			 * @property {Number} newTopIndex   - 스크롤 후 최상위 행의 인덱스
			 * @property {Number} lastIndex     - 마지막 행의 인덱스
			 * @property {Number} pageSize      - 화면에 표시된 레코드 수
			 */
			this.fncScrollEvent = new Function("return function (oldTopIndex, newTopIndex, lastIndex, pageSize) { return " + this.controlId + "_onscroll(oldTopIndex, newTopIndex, lastIndex, pageSize); }")();
		}
		
		this.hasDblClickEvent = (typeof self[this.controlId + "_ondblclick"] != "undefined");
		if( this.hasDblClickEvent ){
			/**
			 * 셀 더블클릭 (Double Click) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_dblclick
			 * @type {Object}
			 * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
			 * @property {Number} rowNum   - 선택된 줄번호
			 * @property {Number} colNum   - 선택된 열번호
			 */
			this.fncDblClickEvent = new Function("return function (rowNum, colNum) { return " + this.controlId + "_ondblclick(rowNum, colNum); }")();
		}
		
		this.hasSortedEvent = (typeof self[this.controlId + "_onsorted"] != "undefined");
		if( this.hasSortedEvent ){
			/**
			 * 시트 정렬시 (Sort) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_sorted
			 * @type {Object}
			 */
			this.fncSortedEvent = new Function("return function () { return " + this.controlId + "_onsorted(); }")();
		}
		
		this.hasKeyDownEvent = (typeof self[this.controlId + "_onkeydown"] != "undefined");
		if( this.hasKeyDownEvent ){
			/**
			 * 키 다운(Key Down) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_keydown
			 * @type {Object}
			 * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
			 * @property {Number} rowNum   - 선택된 줄번호
			 * @property {Number} colNum   - 선택된 열번호
			 * @property {Number} KeyCode  - 눌려진 키코드
			 * @property {Number} Shift    - Shift 키 동시 누르기 여부
			 */
			this.fncKeyDownEvent = new Function("return function (rowNum, colNum, KeyCode, Shift) { return " + this.controlId + "_onkeydown(rowNum, colNum, KeyCode, Shift); }")();
		}
		
		this.hasKeyPressEvent = (typeof self[this.controlId + "_onkeypress"] != "undefined");
		if( this.hasKeyPressEvent ){
			/**
			 * 키 프래스(Key Press) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_keypress
			 * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
			 * @property {Number} rowNum   - 선택된 줄번호
			 * @property {Number} colNum   - 선택된 열번호
			 * @property {Number} KeyAscii - 눌려진 ASCII 키코드
			 */
			this.fncKeyPressEvent = new Function("return function (rowNum, colNum, KeyAscii) { return " + this.controlId + "_onkeypress(rowNum, colNum, KeyAscii); }")();
		}
		
		this.hasKeyUpEvent = (typeof self[this.controlId + "_onkeyup"] != "undefined");
		if( this.hasKeyUpEvent ){
			/**
			 * 키 업(Key Up) 이벤트 .
			 *
			 * @event EasySheet#EasySheet_keyup
			 * @type {Boolean}	
			 * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
			 * @property {Number} rowNum   - 선택된 줄번호
			 * @property {Number} colNum   - 선택된 열번호
			 * @property {Number} KeyCode  - 눌려진 키코드
			 * @property {Number} Shift    - Shift 키 동시 누르기 여부
			 */
			this.fncKeyUpEvent = new Function("return function (rowNum, colNum, KeyCode, Shift) { return " + this.controlId + "_onkeyup(rowNum, colNum, KeyCode, Shift); }")();
		}
	}
};

// 인수는 this.startRowColNum이 반영된 줄번호이다.
EasySheet.prototype.rows = function(rowNum){
	// 성능을 위해 여기서는 체크하지 않는다.
	// if (this._isUnvalidRowNum(rowNum, "sheet.rows")){ return null;}
	
	var rowNum0 = rowNum - this.startRowColNum;
	var row = this.dataSet.data[rowNum0]["__STATE__"];
	
	if( typeof row == "undefined" ){
		row = this.dataSet.data[rowNum0]["__STATE__"] = {cells:{}};
	}
	else if( typeof row["cells"] == "undefined" ){
		row["cells"] = {};
	}
	
	return row;
};

function EXOColumn(columnOnject){
	this.colId = "";			//컬럼 ID(=field)
	this.colDataType = "string";//컬럼 데이터 타입
	
	this.sheetRow = 1;          // 반드시 1부터 시작  
	this.sheetCol = 1;          // 반드시 1부터 시작  
	this.sheetRowSpan = 1;
	this.sheetColSpan = 1;
	
	this.linkedPropertys = [];	//연결객체 프로퍼티 정보
	this.linkedColumn = null;	//연결 데이터셋 컬럼 정보
	
	this.caption = "";			//헤더 타이틀
	this.captionTooltip = "";	//헤더 마우스 오버시 표시할 툴팁 내용
	this.tag = "";
	this.tooltip = false;		//TRUE 일때 마우스 오버시 툴팁표시 (기본값 : false)
	
	this.align = SHEET_ALIGN_LEFT;		//수평정렬
	this.vAlign = SHEET_VALIGN_MIDDLE;	//수직정렬
	this.backColor = "";				//셀의 배경색
	this.foreColor = "";				//셀의 글자색
	
	this.maxLength = -1;			//입력가능 최대 길이
	this.lockMode = false;			//잠금
	this.hidden = false;			//숨김
	
	this.displayFormat = ""; 		//표시형식
//	this.defaultValue = undefined;	//기본값
//	this.defaultValue = (this.colDataType == "number" ? 0 : "");	//기본값
	this.defaultValue = null;		//기본값
	this.prefix = "";				//접두사
	this.suffix = "";				//접미사
	this.formula = "";				//셀 산식
	
	this.checkType = 0;				//체크타입
	this.checkFormula = null;		//체크산식
	this.checkFunction = null;		//체크함수
	this.checkMessage = null;		//체크메세지
	
	this.columnClass = null;		//컬럼 스타일 클래스
	this.columnTitleClass = null;	//컬럼 타이틀 스타일 클래스
	
	this.width = "81px";			//셀 너비
	this.minWidth = "81px";			//셀 최소 너비
	
	//셀타입
	this.cellType = CELLTYPE_EDIT;
	
	//셀타입 : 체크
	this.checkShapeType = "default";//체크박스 타입
	this.valueWhenChecked = "1";	//체크하였을 때의 값
	this.valueWhenUnchecked = "0";	//크하지 않았을 때의 값
	
	//셀타입 : 콤보
	this.linkComboName = null;		//링크 콤보 컨트롤명
	this.fillList = null;			//콤보 채우기 배열
	this.fillFunction = null;		//콤보 채우기 함수
	this.comboValueColId = "";
	
	//셀타입 : 정수/실수
	this.maxValue = 9999999999; 	//최대값
	this.minValue = -9999999999;	//최소값
	this.negativeRed = 0;			//1 로 설정한 경우 값이 음수이면 글자색 Red 로 변경 (기본 : 0)
	this.decimalPlaces = null;			
	
	//셀타입 : 퍼센트
	this.percentSet = 0;			//퍼센트 소수점 설정 (0: 설정없음, 1: 올림, 2:내림, 3:반올림) 기본값 0
	this.percentDecimalPoint = 0;	//퍼센트 소수점 자릿수 (기본값 : 0)
	
	//셀타입 : 버튼
	this.buttonType = "text";		//버튼 타입
	this.buttonCaption = "";		//텍스트 버튼 캡션
	this.buttonOverCaption = null;	//버튼 타입에 따른 텍스트 캡션 또는 이미지 src 를 함수의 리턴 값으로 처리
//	this.buttonImage1 = new Image(); this.buttonImage1.src = CONTEXT_ROOT + "/winnersoft/images/sheet/sheetbtn.jpg"; 
//  this.buttonImage2 = new Image(); this.buttonImage2.src = CONTEXT_ROOT + "/winnersoft/images/sheet/sheetbtnR.jpg";
	
	//셀타입 : 이미지
	this.imageAlt = ""; 			//이미지 태그 alt 속성
	this.imageZoom = false;			//true 로 설정한 경우 셀의 이미지에 마우스 오버시 확대된 이미지를 보여줌
	
	//셀타입 : 링크
	this.linkCaption = "";			//링크 태그 캡션
	
	//셀타입 : 날짜
	this.checkFormat = 0; 			//Date 타입 셀 년월일 체크 옵션
	this.dateFormat = "";			//날짜 표시형식
	this.timeFormat = "";			//시간타입 표시형식
//	this.cellMask = ""; 			//사용안함 - mask타입 셀 형식 문자열 ex(____-__-__) 기본값 : ""
	
	this.sortDirection = ""; 				// 헤더클릭시 소트방향 정보, 차대리 Renderer 반영, sort호출 이벤트로 EasySheet에 넘겨준다.
	this.sortGu = "";						// sheet.sortOut 이벤트에 사용  "ASC", "DESC"
	this.cellMerge = SHEET_CELL_MERGE_NOT;  // 셀머지 SHEET_CELL_MERGE_NOT(0) 머지 안함,  SHEET_CELL_MERGE_ALWAYS(1) : 윗데이터로만 판단, SHEET_CELL_MERGE_RESTRICT(2):앞데이터, 윗데이터 동시 판단 
	this.cellTree = false;   				// 머지셀의 트리동작
	
	// 그루핑에 필요한 변수
	this._isGroupKeyField = false;
	this.sumMethod = "";  // "SUM", "AVG", "MIN", "COUNT", "MAX", "TEXT:소계"
	this._sumText = "";    // sumMethod의 뒷부분을 반복적으로 파싱 하지 않기 위한 임시필드, 그룹핑 단계에서 미리 분해 한다. 텍스트인 경우
	this._sumFormula = "";     // sumMethod의 뒷부분을 반복적으로 파싱 하지 않기 위한 임시필드, 그룹핑 단계에서 미리 분해 한다. 산식인 경우
	this._sumField = "";   // sumMethod의 뒷부분을 반복적으로 파싱 하지 않기 위한 임시필드, 그룹핑 단계에서 미리 분해 한다. 필드인 경우
	
	// 피벗팅에 필요한 변수
	this._pivotColId = "";	// 피벗시트에 연결된 칼럼 아이디 
	
//  this.hiddenWidth  = 0; //[삭제]
//	this.ComboTextLinked = false; //[삭제]
//	this.ComboDataLinked = false; //[삭제]
//  this.fillLists = []; //[삭제]
//  this.comboLists = [null]; //[삭제] EXOListItem이 들어간다, 0번인덱스는 사용하지 않는다
//  this.defaultCheckCenter = false;   // [삭제]
//  this.defaultTypedateformat = "yyyy-mm-dd"; // 날자 타입 셀 표시 형식
	
	if( typeof columnOnject != "undefined" && columnOnject != null ){
		var key = null;
		
		//컬럼 속성 세팅
		for(key in columnOnject){
			this[key] = columnOnject[key];
		}
		
		//메모리 해제
		key = null;
	}
	
	//체크박스 기본값 세팅
	if( this.cellType == CELLTYPE_CHECKBOX ){
		this.defaultValue = (this.defaultValue == "" ? "0" : this.defaultValue);
	}
	
	//콤보타입 fillList 속성이 문자열인 경우
	if( typeof this.fillList == "string" ){
		var items = this.fillList.split(",");
		var i = 0;
		
		//fillList 초기화
		this.fillList = null;
		this.fillList = [];
		
		for(i = 0; i < items.length; i++){
			this.fillList[i] = {value: items[i], text: items[i]}; 
		}
		
		items = null;
	}
};

function EXOFooter(footerOnject){
	this.colId = "";					//컬럼 ID(=field)
	this.colDataType = "string";		//컬럼 데이터 타입
//	this.cellType = CELLTYPE_EDIT;		//셀타입
	
	this.sheetRow = 1;
	this.sheetCol = 1;
	this.sheetRowSpan = 1;
	this.sheetColSpan = 1;
	
	this.align = SHEET_ALIGN_LEFT;		//수평정렬
	this.vAlign = SHEET_VALIGN_MIDDLE;	//수직정렬
	this.backColor = "";				//셀의 배경색
	this.foreColor = "";				//셀의 글자색
	this.columnClass = null;			//컬럼 스타일 클래스
	
	this.showFooter = true;				//푸터 숨김여부
	
//	this.width = "81px";				//셀 너비
//	this.minWidth = "81px";				//셀 최소 너비
	
	this.formula = "";
	this.value = null;
	
	if( typeof footerOnject != "undefined" && footerOnject != null ){
		var key = null;
		//컬럼 속성 세팅
		for(key in footerOnject){
			this[key] = footerOnject[key];
			key = null; //메모리 해제
		}
	}
};

EasySheet.prototype.refreshColumns = function(doResize, doRedraw){
	//doResize - 속성값 : true|false / 기본값 : true
	doResize = (typeof doResize == "undefined") ? true : (typeof doResize == "boolean" && doResize === true) ? true : false;
	//doRedraw - 속성값 : true|false / 기본값 : true
	doRedraw = (typeof doRedraw == "undefined") ? true : (typeof doRedraw == "boolean" && doRedraw === true) ? true : false;
	
	//시트 리사이징
	if( doResize ){
		this.sheetRenderer.resize();
	}
	
	//시트 다시 그리기
	if( doRedraw ){
		var colNum0 = 0;
		var column = null;
		
		// 컬럼 개수 설정
		this.maxCols = this.columns.length;
		
		// 데이터셋 필드 초기화
		for(colNum0 = 0; colNum0 < this.dataSet.fieldInfos; colNum0++){
			column = this.dataSet.fieldInfos[colNum0];
			column = null;
		}
		this.dataSet.fieldInfos = {};
		
		//컬럼 정보 정리
		this.sheetRenderer.resetColumnInfo(this.columns);
		//푸터 정보 정리
		this.sheetRenderer.resetFooterInfo(this.footers);
		
		// 각 컬럼 정보를 렌더러에 세팅
		for(colNum0 = 0; colNum0 < this.maxCols; colNum0++, column = null){
			column = this.columns[colNum0];
			
			//데이터셋 필드정보 추가
			this.dataSet.addField({
				field : column.colId,
				fieldName : (column.caption.length > 0) ? column.caption : column.colId,
				dataType : column.colDataType
			});
		}
		
		//시트 외양 디자인 속성 설정
		this.sheetRenderer.selectMode = this.selectMode;
		
		if( this.pivot == null && this.maxRows == 1 && this.isEmptyRow(this.startRowColNum) ){
			this.clearRow(this.startRowColNum);
		}
		
		//시트 다시 그리기
		this.updateScreen(SHEET_RESET_DESIGN);
		//
		this.updateScreen(SHEET_RESET_DATA);
	}
	
	if( this.linkedDataset != null ){
		var datasetId = this.linkedDataset.id;
		var sheetName = this.controlName;
		var sheetType = (this.sheetType == SHEETTYPE_DATASHEET) ? "Sheet" : "lstSheet";
		var bindInfo = null; var linkedColumn = null; var column = null;
		var sheetCol = 0; var colCount = 0;
		var i = 0;
		
		for(i = 0, colCount = this.maxCols; i < colCount; i++){
			column = this.columns[i];
			sheetCol = column.sheetCol;
			linkedColumn = column.linkedColumn;
			
			bindInfo = new BindInfo(datasetId, linkedColumn, sheetType, sheetName, sheetCol - 1 + this.startRowColNum);
			this.dataBinds[datasetId + "_" + sheetCol] = bindInfo;
			dataSets[datasetId].dataBinds[sheetName + "_" + sheetCol] = bindInfo;
			
			//메모리 해제
			bindInfo = null; linkedColumn = null; column = null;
		}
		
		//메모리 해제
		sheetType = null; sheetName = null; datasetId = null;
	}
	
	return true;
};

EasySheet.prototype.getColumns = function(){
	// functionname : [EasySheet.getColumns]
	
	return JSON.parse(JSON.stringify(this.columns));
};

EasySheet.prototype.getFooters = function(){
	// functionname : [EasySheet.getFooters]
	
	return JSON.parse(JSON.stringify(this.footers));
};

EasySheet.prototype.setFooters = function(footers){
	// functionname : [EasySheet.setFooters]
	
	//예외처리
	if( footers == null || typeof footers == "undefined" || !(footers instanceof Array) ){
		return false;
	}
	
	var footerCount = this.footers.length;
	var i = 0;
	
	//
	if( footerCount > 0 ){
		this.footers.clear();
	}
	
	//
	for(i = 0, footerCount = footers.length; i < footerCount; i++){
		this.footers[i] = new EXOColumn(footers[i]);
	}
	
	//
	wControl.refreshColumns(false, true);
	
	return true;
};

/**
 * @description             - 시트를 활성화 또는 비활성화 시킨다
 * @param {Boolean} enabled - 활성화 하여 동작이 가능는하게 할 것인지 구분 (true: 활성화, false: 비활성화)
 * @returns {Void}
 * 
 * @example
 * sheet.setEnabled(true);   // 시트를 활성화한다
 */
EasySheet.prototype.setEnabled = function(enabled){
	// functionname : [EasySheet.setEnabled]
	
	if (this.enabled == enabled) return;
	
	//이전 활성화 상태 기록
	var oldValue = this.enabled;
	//활성화 상태 변경
	this.enabled = enabled;
	
	//활성화 상태 적용
	if( !this.sheetRenderer.setEnabled(enabled) ){
		//활성화 상태 적용이 실패한 경우 이전 활성화 상태로 복구
		this.enabled = oldValue;
	}
	
	oldValue = null;
	
	return;
};

/**
 * @description 			- 시트를 보이거나 숨긴다.
 * @param {Boolean} visible - 시트를 보이게 할 것인지 구분 (true: 보임, false: 숨김)
 * @returns {Void}
 * 
 * @example
 * sheet.setVisible(true);       // 시트를 보인다
 */
EasySheet.prototype.setVisible = function(visible){
	// functionname : [EasySheet.setVisible]
	
	//현재 보이기 상태와 같다면 함수를 더이상 실행하지 않음
	if (this.visible == visible) return;
	
	//이전 보이기 상태 기록
	var oldValue = this.visible;
	//보이기 상태 변경
	this.visible = visible;
	
	//보이기 상태 적용
	if( !this.sheetRenderer.setVisible(visible) ){
		//보이기 상태 적용이 실패한 경우 이전 보이기 상태로 복구
		this.visible = oldValue;
	}
	
	//메모리 해제
	oldValue = null;
	
	return;
};

/**
 * @description 				- 시트 셀 병합 여부를 설정한다. 이 속성이 컬럼 병합 속성보다 선행되는 속성이다. 
 * @param {Number} needMerge	- 시트 셀 병합 (SHEET_MERGE_UNFIXED: 병합 설정 미정, 컬럼 병합 설정에 따름, SHEET_MERGE_NEED_NOT: 병합 안함, SHEET_MERGE_NEED: 병합 함)
 * @returns {Void}
 * 
 * @example
 * sheet.setNeedMerge(SHEET_MERGE_NEED_NOT); // 시트 병합 안함
 */
EasySheet.prototype.setNeedMerge = function(needMerge){
	// functionname : [EasySheet.setNeedMerge]
	
	//현재 시트 셀 병합 여부와 같다면 함수를 더이상 실행하지 않음
	if (this.needMerge == needMerge) return;
	
	//이전 시트 셀 병합 여부 기록
	var oldValue = this.needMerge;
	//시트 셀 병합 여부 변경
	this.needMerge = needMerge;
	
	//시트 셀 병합 여부 적용
	if( !this.sheetRenderer.setNeedColumnMerge(needMerge) ){
		//시트 셀 병합 여부 적용이 실패한 경우 이전 시트 셀 병합 여부로 복구
		this.needMerge = needMerge;
	}
	
	//메모리 해제
	oldValue = null;
	
	return;
};

/**
 * @description 				- 시트의 편집 가능 여부를 설정한다.
 * @param {Boolean} editable	- 시트의 편집 가능 여부 (true: 편집가능, false: 편집 불가능)
 * @returns {Void}
 * 
 * @example
 * sheet.setPermitEditable(false);	// 시트 편집 불가능
 */
EasySheet.prototype.setPermitEditable = function(editable){
	// functionname : [EasySheet.setPermitEditable]
	
	//현재  편집가능 상태와 같다면 함수를 더이상 실행하지 않음
	if( this.permitEditable == editable ) return;
	
	//이전 편집가능 상태 기록
	var oldValue = this.permitEditable;
	//편집가능 상태 변경
	this.permitEditable = editable;
	
	//편집가능 상태 적용
	if( !this.sheetRenderer.setPermitEditable(editable) ){
		//편집가능  상태 적용이 실패한 경우 이전 편집가능  상태로 복구
		this.permitEditable = oldValue;
	}
	
	//메모리 해제
	oldValue = null;
	
	return;
};

/**
 * @description 				- 시트의 열 너비 사이즈 조정 가능 여부를 설정한다.
 * @param {Boolean} permitable	- 시트의 열 너비 사이즈 조정 가능 여부 (true: 조정 가능, false: 조정 불가능)
 * @returns {Void}
 * 
 * @example
 * sheet.setPermitCellResize(true);	// 시트 열 너비를 조정 가능
 */
EasySheet.prototype.setPermitCellResize = function(permitable){
	// functionname : [EasySheet.setPermitCellResize]
	
	//현재 보이기 상태와 같다면 함수를 더이상 실행하지 않음
	if (this.permitCellResize == permitable) return;
	
	//이전 열 너비 조정 가능여부 기록
	var oldValue = this.permitCellResize;
	//시트 열 너비 조정 가능여부 변경
	this.permitCellResize = permitable;
	
	//렌더러 열 너비 조정 가능여부 적용
	if( !this.sheetRenderer.setPermitCellResize(permitable) ){
		//열 너비 조정 가능여부 적용이 실패한 경우 이전 열 너비 조정 가능여부 복구
		this.permitCellResize = oldValue;
	}
	
	//메모리 해제
	oldValue = null;
	
	return;
};

/**
 * @description 				- 시트 고정 열의 편집 가능 여부를 설정합니다.
 * @param {Boolean} permitable	- 시트 고정 열의 편집 가능 여부 (true: 편집 가능, false: 편집 불가능)
 * @returns {Void}
 * 
 * @example
 * sheet.setPermitEditFixedColumn(true);	// 시트 열 너비를 조정 가능
 */
EasySheet.prototype.setPermitEditFixedColumn = function(permitable){
	// functionname : [EasySheet.setPermitEditFixedColumn]
	
	//현재 보이기 상태와 같다면 함수를 더이상 실행하지 않음
	if (this.permitEditFixedColumn == permitable) return;
	
	//이전 열 너비 조정 가능여부 기록
	var oldValue = this.permitCellResize;
	//시트 열 너비 조정 가능여부 변경
	this.permitEditFixedColumn = permitable;
	
	//렌더러 열 너비 조정 가능여부 적용
	if( !this.sheetRenderer.setPermitEditFixedColumn(permitable) ){
		//열 너비 조정 가능여부 적용이 실패한 경우 이전 열 너비 조정 가능여부 복구
		this.permitEditFixedColumn = oldValue;
	}
	
	//메모리 해제
	oldValue = null;
	
	return;
};

/**
 * @description 				- 마우스 휠의 반응도를 결정합니다.
 * @param {Number} rowCount		- 마우스 휠에 반응하는 행의 개수
 * @returns {Void}
 * 
 * @example
 * sheet.setWheelMovementRows(2);	// 마우스 휠 동작시 2행씩 이동함
 */
EasySheet.prototype.setWheelMovementRows = function(rowCount){
	// functionname : [EasySheet.setWheelMovementRows]
	
	//현재 보이기 상태와 같다면 함수를 더이상 실행하지 않음
	if (this.wheelMovementRows == rowCount) return;
	
	//이전 열 너비 조정 가능여부 기록
	var oldValue = this.wheelMovementRows;
	//시트 열 너비 조정 가능여부 변경
	this.wheelMovementRows = rowCount;
	
	//렌더러 열 너비 조정 가능여부 적용
	if( !this.sheetRenderer.setWheelMovementRows(rowCount) ){
		//열 너비 조정 가능여부 적용이 실패한 경우 이전 열 너비 조정 가능여부 복구
		this.wheelMovementRows = oldValue;
	}
	
	return;
};

/**
 * @description 				- 헤더 우클릭시 컨텍스트 메뉴 사용 여부를 설정합니다.
 * @param {Boolean} usable		- 헤더 우클릭시 컨텍스트 메뉴 사용 여부(true: 사용, false: 사용 안함)
 * @returns {Void}
 * 
 * @example
 * sheet.setUseContextMenu(false);	// 컨텍스트 메뉴 사용 안함
 */
EasySheet.prototype.setUseContextMenu = function(usable){
	// functionname : [EasySheet.setUseContextMenu]
	
	//현재 컨텍스트 메뉴 사용 여부와 같다면 함수를 더이상 실행하지 않음
	if (this.useContextMenu == usable) return;
	
	//컨텍스트 메뉴 사용 여부 기록
	var oldValue = this.useContextMenu;
	//컨텍스트 메뉴 사용 여부 변경
	this.useContextMenu = usable;
	
	//렌더러 컨텍스트 메뉴 사용 여부 적용
	if( !this.sheetRenderer.setUseContextMenu(usable) ){
		//컨텍스트 메뉴 사용 여부 적용이 실패한 경우 이전 컨텍스트 메뉴 사용 여부 복구
		this.useContextMenu = oldValue;
	}
	
	//메모리 해제
	oldValue = null;
	
	return;
};

/**
 * @description 				- 헤더 클릭 또는 컨텍스트 메뉴를 통해 시트 정렬 사용 여부를 설정합니다.
 * @param {Boolean} sortable	- 시트 정렬 사용 여부(true: 사용, false: 사용 안함)
 * @returns {Void}
 * 
 * @example
 * sheet.setSortOnHeader(false);	// 헤더 클릭 또는 컨텍스트 메뉴를 통해 시트 정렬 사용안함
 */
EasySheet.prototype.setSortOnHeader = function(sortable){
	// functionname : [EasySheet.setSortOnHeader]
	
	//현재 시트 정렬 사용 여부와 같다면 함수를 더이상 실행하지 않음
	if (this.sortOnHeaderClick == sortable) return;
	
	//시트 정렬 사용 여부 기록
	var oldValue = this.sortOnHeaderClick;
	//시트 정렬 사용 여부 변경
	this.sortOnHeaderClick = sortable;
	
	//렌더러 시트 정렬 사용 여부 적용
	if( !this.sheetRenderer.setSortOnHeader(sortable) ){
		//시트 정렬 사용 여부 적용이 실패한 경우 이전 시트 정렬 사용 여부 복구
		this.sortOnHeaderClick = oldValue;
	}
	
	//메모리 해제
	oldValue = null;
	
	return;
};

/**
 * @description 				- 행열 타이틀을 설정합니다.
 * @param {String} title		- 행열 타이틀에 설정할 문자열
 * @returns {Void}
 * 
 * @example
 * sheet.setRowColHeaderTitle("No");	// 행열타이틀을 "No"로 설정
 */
EasySheet.prototype.setRowColHeaderTitle = function(title){
	// functionname : [EasySheet.setRowColHeaderTitle]
	
	//현재 컨텍스트 메뉴 사용 여부와 같다면 함수를 더이상 실행하지 않음
	if (this.rowColHeaderTitle == title) return;
	
	//컨텍스트 메뉴 사용 여부 기록
	var oldValue = this.rowColHeaderTitle;
	//컨텍스트 메뉴 사용 여부 변경
	this.rowColHeaderTitle = title;
	
	//렌더러 컨텍스트 메뉴 사용 여부 적용
	if( !this.sheetRenderer.setRowColHeaderTitle(title) ){
		//컨텍스트 메뉴 사용 여부 적용이 실패한 경우 이전 컨텍스트 메뉴 사용 여부 복구
		this.rowColHeaderTitle = oldValue;
	}
	
	//메모리 해제
	oldValue = null;
	
	return;
};

/**
 * @description 				- 시트의 행번호 출력 방향을 설정
 * @param {Boolean} order		- 시트의 행번호 출력 방향(true: 정방향, false: 역방향)
 * @returns {Void}
 * 
 * @example
 * sheet.setRowNumOrder(true);	// 행번호를 역방향 행번호로 출력
 */
EasySheet.prototype.setRowNumOrder = function(order){
	// functionname : [EasySheet.setRowNumOrder]
	
	//현재 시트의 행번호 출력 방향과 같다면 함수를 더이상 실행하지 않음
	if (this.rowNumOrder == order) return;
	
	//시트의 행번호 출력 방향 기록
	var oldValue = this.rowNumOrder;
	//시트의 행번호 출력 방향 변경
	this.rowNumOrder = order;
	
	//렌더러 시트의 행번호 출력 방향 적용
	if( !this.sheetRenderer.setRowNumOrder(order) ){
		//시트의 행번호 출력 방향 적용이 실패한 경우 이전 시트의 행번호 출력 방향 복구
		this.rowNumOrder = oldValue;
	}
	
	//메모리 해제
	oldValue = null;
	
	return;
};

/**
 * @description 				- 시트의 홀수행과 짝수행의 배경색을 구분할 것인지 선택합니다.
 * @param {Boolean} display		- 행 배경색 구분(true: 구분함, false: 구분안함)
 * @returns {Void}
 * 
 * @example
 * sheet.setDisplayOddEven(false);	// 시트의 홀수행과 짝수행 배경색 구분하지 않음
 */
EasySheet.prototype.setDisplayOddEven = function(display){
	// functionname : [EasySheet.setDisplayOddEven]
	
	//현재 시트의행 배경색 구분과 같다면 함수를 더이상 실행하지 않음
	if (this.displayOddEven == display) return;
	
	//시트의 행 배경색 구분 기록
	var oldValue = this.displayOddEven;
	//시트의 행 배경색 구분 변경
	this.displayOddEven = display;
	
	//렌더러 시트의 행 배경색 구분 적용
	if( !this.sheetRenderer.setDisplayOddEven(display) ){
		//시트의 행 배경색 구분 적용이 실패한 경우 이전 시트의 행 배경색 구분 복구
		this.displayScrollBar = oldValue;
	}
	
	//메모리 해제
	oldValue = null;
	
	return;
};

/**
 * @description 				- 시트의 스크롤을 보이거나 숨긴다.
 * @param {Boolean} display		- 시트의 스크롤을 보이게 할 것인지 구분 (true: 보임, false: 숨김)
 * @returns {Void}
 * 
 * @example
 * sheet.setDisplayReverseRowNum(false);	// 시트의 스크롤을 숨김
 */
EasySheet.prototype.setDisplayScrollBar = function(display){
	// functionname : [EasySheet.setDisplayScrollBar]
	
	//현재 시트의 행번호 출력 방향과 같다면 함수를 더이상 실행하지 않음
	if (this.displayScrollBar == display) return;
	
	//시트의 행번호 출력 방향 기록
	var oldValue = this.displayScrollBar;
	//시트의 행번호 출력 방향 변경
	this.displayScrollBar = display;
	
	//렌더러 시트의 행번호 출력 방향 적용
	if( !this.sheetRenderer.setDisplayScrollBar(display) ){
		//시트의 행번호 출력 방향 적용이 실패한 경우 이전 시트의 행번호 출력 방향 복구
		this.displayScrollBar = oldValue;
	}
	
	//메모리 해제
	oldValue = null;
	
	return;
};

/**
 * @description 				- 탭키 동작을 설정합니다.
 * @param {Number} tabKeyAction	- 탭키 동작(다음 컨트롤 : SHEET_TAB_TONEXTCTRL / 다음 셀 : SHEET_TAB_TONEXTCELL)
 * @returns {Void}
 * 
 * @example
 * sheet.setTabKeyAction(SHEET_TAB_TONEXTCELL); // 탭키 동작을 다음 셀로 이동하도록 설정
 */
EasySheet.prototype.setTabKeyAction = function(tabKeyAction){
	// functionname : [EasySheet.setTabKeyAction]
	
	//현재 탭키 동작과 같다면 함수를 더이상 실행하지 않음
	if (this.tabKeyAction == tabKeyAction) return;
	
	//이전 탭키 동작 기록
	var oldValue = this.tabKeyAction;
	//시트 탭키 동작 변경
	this.tabKeyAction = tabKeyAction;
	
	//렌더러 탭키 동작 적용
	if( !this.sheetRenderer.setTabKeyAction(tabKeyAction) ){
		//탭키 동작 적용이 실패한 경우 이전 탭키 동작 복구
		this.tabKeyAction = oldValue;
	}
	
	return;
};

/**
 * @description 			- 새로운 줄을 선택하여 포커스를 이동한다.
 * @param {Number} rowNum 	- 선택할 줄번호 (첫 줄 번호: startRowColNum 기준)
 * @returns {Void}
 * 
 * @example
 * sheet.setCurrentRow(sheet.startRowColNum);       // 첫 줄로 이동한다
 */
EasySheet.prototype.setCurrentRow = function(rowNum){
	// functionname : [EasySheet.setCurrentRow]
	
	if( this._isUnvalidRowNum(rowNum, "sheet.setCurrentRow") )
		return;
	
    var rowNum0 = rowNum - this.startRowColNum;

	//현재 선택한 행번호와 같다면 함수를 더이상 실행하지 않음
	if( this.currentRow == rowNum ){
		console.info("skip same Value.\n this.currentRow == rowNum:" + this.currentRow + " == " + rowNum);
		return;
	}
	
	//이전 행번호 기록
	var oldRowNum = this.currentRow;
	//새 행번호 설정
	this.currentRow = rowNum;
	
	//포커스 동작 호출
	if( !this.sheetRenderer.setSelectedRowIndex(rowNum0) ){
		//포커스 이동 실패한 경우 이전 행번호로 복구
		this.currentRow = oldRowNum;
	}
	
	//데이터셋 처리
	if( this.linkedDataset != null && typeof this._UpdateDatasetRowPos != "undefined" ){
		var rowId = this.rows(rowNum).rowId;
		//해당 행의 레코드가 존재할 경우
		if( typeof rowId != "undefined" && rowId != null )
			this._UpdateDatasetRowPos(rowId);
		//메모리 해제
		rowId = null;
	}
	
	//메모리 해제
	oldRowNum = null;
	
	return;
};

/**
 * @description 			- 새로운 칼럼을 선택하여 포커스를 이동한다.
 * @param {Number} rowNum 	- 선택할 열번호 (첫 열 번호: 0)
 * @returns {Void}
 * 
 * @example
 * setCurrentCol(1);       // 두번째 칼럼으로 이동한다
 */
EasySheet.prototype.setCurrentCol = function(colNum){
	// functionname : [EasySheet.setCurrentCol]
	
	if( this._isUnvalidColNum(colNum, "sheet.setCurrentCol") )
		return;
	
	var colNum0 = colNum - this.startRowColNum;
	
	//현재 선택한 열번호와 같다면 함수를 더이상 실행하지 않음
	if( this.currentCol == colNum ){
		console.info("skip same Value.\n this.currentCol == colNum:" + this.currentCol + " == " + colNum);
		return;
	}
	
	//이전 열번호 기록
	var oldColNum = this.currentCol;
	//새 열번호 설정
	this.currentCol = colNum;
	
	//포커스 동작 호출 
	if( !this.sheetRenderer.setSelectedColumnIndex(colNum0) ){
		//포커스 이동 실패한 경우 이전 열번호로 복구
		this.currentCol = oldColNum;
	}
	
	//메모리 해제
	oldColNum = null;
	
	return;
};

/**
 * @description 			- 시트를 초기화 한다.<br/>
 *                            데이터를 지우는 것이 아니고 시트를 다시 계산한다.<br/>
 *                            이때 선택열은 맨 마지막 열을 가리키게 된다.
 * @returns {Void}
 * 
 * @example
 * refresh();       
 */
EasySheet.prototype.refresh = function(){
	// functionname : [EasySheet.refresh]
	
	// 줄수 재설정
	this.maxRows = this.dataSet.data.length;   // WsDataSet
	
	// 소트칼럼 정리 
	this.sortOut();
	
	// 현재줄 포인터 정리 
	var currentRowNum0  = this.currentRow - this.startRowColNum;
	if( currentRowNum0 >= this.maxRows ){
		this.setCurrentRow(this.maxRows - 1 + this.startRowColNum);
	}
	
	this.dirty = false;
	
	// 산식재정비
	this.refreshFormulaRefs(); // true는 산식정비후 재계산까지 한다는 뜻
	
	// 그루핑 처리
	if( this.needGrouping ) 
		this.sumUp.resetGroup();
	
	this.updateScreen(SHEET_RESET_DESIGN);
	
	return;
};

/** 
 * @deprecated since version 5.0, 칼럼정보를 JSON으로 대체 
 * */
EasySheet.prototype.setColSpanInfo = function(colSpanInfo){
    // functionname : [EasySheet.setColSpanInfo]

	// 칼럼정보를 JSON으로 대체 ??? 호환성 검토 
};

/**
 * @description 
 *     시트에 칼럼정보를 추가한다, 생성자로 행열위치와 셀확장 정보를 준다<br/>
 *     사용방법은 시트의 줄처리 방식에 따라 다르다)<br/>
 *     colId를 생략하면 colId에는 "f" + colNum과 같은 값이 들어간다 <br/>
 *     이함수는 다음 형태로 사용된다.<br/>
 *     sheet.addColumn()<br/>
 *     sheet.addColumn(colNum1)<br/>
 *     sheet.addColumn(colId)<br/>
 *     sheet.addColumn(colAttribute);<br/>
 *     sheet.addColumn(colAttribute);<br/>
 *     sheet.addColumn(colNum1, colId)<br/>
 *     sheet.addColumn(rowNum1, colNum1, colId)<br/>
 *     sheet.addColumn(rowNum1, colNum1, colAttribute)<br/>
 *     sheet.addColumn(rowNum1, colNum1, colId, colAttribute)<br/>
 *     sheet.addColumn(rowNum1, colNum1, rowSpan, colSpan)<br/>
 *     heet.addColumn(rowNum1, colNum1, rowSpan, colSpan, colId)<br/>
 *     sheet.addColumn(rowNum1, colNum1, rowSpan, colSpan, colAttribute)<br/>
 *     sheet.addColumn(rowNum1, colNum1, rowSpan, colSpan, colId, colAttribute)<br/>
 *     
 * @param {Number|undefined}	[rowNum1=1]						- 시트의 물리적인 줄번호    1번 부터 시작
 * @param {Number|undefined}	[colNum1]=Next Column Number	- 시트의 물리적인 칼럼번호   1번 부터 시작
 * @param {Number|undefined}	[rowSpan=1]						- 시트의 물리적인 줄 확장 셀수
 * @param {Number|undefined}	[colSpan=1]						- 시트의 물리적인 칼럼 확장 셀수
 * @param {String|undefined}	[colId=f + Next Column Number]	- 칼럼의 고유 아이디 (영문)
 * @param {Object|undefined}	[colAttribute=Empty JSON] 		- 칼럼의 속성을 지정하는 JSON 정보
 * 
 * @return {EXOColumn} 			- 생성된 EXOColumn 개체
 *     
 * @example
 * sheet.addColumn(1); sheet.addColumn(1, "abc"); // Single Row 인 경우
 * sheet.addColumn(2,3,3,4); sheet.addColumn(2,3,3,4, "abc"); Multi  Row인 경우
 * 
 *          // Single Row 인 경우
 * 			sheet.addColumn();
 * 			sheet.addColumn(2);
 * 			sheet.addColumn('field3');
 *          sheet.addColumn({colId: 'field6'});
 * 			sheet.addColumn(5, 'field4');
 * 			sheet.addColumn(6, {colId: 'field6'});
 * 			sheet.addColumn(1, 7, 'field5');
 * 			sheet.addColumn(1, 8, {colId: 'field6'});
 * 			sheet.addColumn(1, 9, 'field7', {rowSpan: 1, colSpan: 1});
 * 			sheet.addColumn(1, 10, 1, 1);
 * 			sheet.addColumn(1, 11, 1, 1, 'field9');
 * 			sheet.addColumn(1, 12, 1, 1, {colId: 'field10'});
 * 			sheet.addColumn(1, 13, 1, 1, 'field11', {width: "100px"});
 * 
 */
EasySheet.prototype.addColumn = function(/* rowNum1, colNum1, rowSpan, colSpan, colId, colAttribute */){
	// functionname : [EasySheet.addColumn]
	
	var colIdIndex = this.columns.length;
	var rowNum1 = this.displayInfo.rowsPerDataRow;
	var colNum1 = 1;
	var colId = "add_column_";
	var rowSpan = 1;
	var colSpan = 1;
	var colAttr = null;
	var column = null;
	
	if( arguments.length == 0 ){
//		colNum1 = this.columns.length + this.startRowColNum;
//		colId = "add_column_" + colNum1;
		colNum1 += this.columns.length;
		colId += colIdIndex;
	}
	else if( arguments.length == 1 ){
		if( typeof arguments[0] == "number" ){
			colNum1 = arguments[0];
//			colId = "add_column_" + colNum1;
			colId += colIdIndex;
		}
		else if( typeof arguments[0] == "object" ){
//			colNum1 = this.columns.length + this.startRowColNum;
//			colId = "add_column_" + colNum1;
			colNum1 += this.columns.length;
			colId += colIdIndex;
			colAttr = arguments[0];
		}
		else{
//			colNum1 = this.columns.length + this.startRowColNum;
			colNum1 += this.columns.length;
			colId = arguments[0];
		}
	}
	else if( arguments.length == 2 ){
		colNum1 = arguments[0];
		
		if( typeof arguments[1] == "object" ){
//			colId = "add_column_" + colNum1;
			colId += colIdIndex;
			colAttr = arguments[1];
		}
		else{
			colId = arguments[1];
		}
	}
	else if( arguments.length == 3 ){
		rowNum1 = arguments[0];
		colNum1 = arguments[1];
		
		//세번째 파라메터가 객체인 경우 파라메터는 컬럼 속성 객체임
		if( typeof arguments[2] == "object" ){
//			colId = "add_column_" + colNum1;
			colId += colIdIndex;
			colAttr = arguments[2];
		}
		else{
			colId =  arguments[2];
		}
	}
	else if (arguments.length == 4){
		rowNum1 = arguments[0];
		colNum1 = arguments[1];
		
		if( typeof arguments[2] == "number" ){
//			colId = "add_column_" + colNum1;
			colId += colIdIndex;
			rowSpan = arguments[2];
			colSpan = arguments[3];
		}
		else{
			colId = arguments[2];
			colAttr = arguments[3];
		}
	}
	else if (arguments.length == 5){
		rowNum1 = arguments[0];
		colNum1 = arguments[1];
		rowSpan = arguments[2];
		colSpan = arguments[3];
		
		if( typeof arguments[4] == "object" )
			colAttr = arguments[4];
		else
			colId =  arguments[4];
	}
	else if( arguments.length == 6 ){
		rowNum1 = arguments[0];
		colNum1 = arguments[1];
		rowSpan = arguments[2];
		colSpan = arguments[3];
		colId = arguments[4];
		colAttr = arguments[5];
	}
	else{
		alert(getText(	"message_EasySheet_003", 
						"EasySheet.addColumn의 인수의 갯수가 {0}입니다. \n" + 
						"addColumn(colNum) 또는 addColumn(colNum, colId) 또는\n" + 
						"addColumn(rowNum, colNum, rowSpan, colSpan)  또는\n" + 
						"addColumn(rowNum, colNum, rowSpan, colSpan, colId) ",
						arguments.length
		));
		return null;
	}
	
	// 오류처리 
	if( rowNum1 < 1 || colNum1 < 1 ){
		alert(getText(	"message_EasySheet_041", 
						"추가할 줄번호/열번호는 1 이상이어야 합니다.\n{0}", 
						JSON.stringify({ rowNum: rowNum1, colNum: colNum1, rowSpan: rowSpan, colSpan: colSpan})
		));
		return null;
	}
	else if( rowSpan < 1 || colSpan < 1 ){
		alert(getText(	"message_EasySheet_042", 
						"추가할 줄확장/열확장수는 1 이상이어야 합니다.\n{0}", 
						JSON.stringify({ rowNum: rowNum1, colNum: colNum1, rowSpan: rowSpan, colSpan: colSpan})
		));
		return null;
	}
	else if( colNum1 > colIdIndex + 1 ){
		alert(getText(	"message_EasySheet_044", 
				"추가할 열 번호가 컬럼 범위를 벗어났습니다.\n{0}", 
				JSON.stringify({ rowNum: rowNum1, colNum: colNum1, rowSpan: rowSpan, colSpan: colSpan})
		));
		return null;
	}
	
//	var rowNum0 = rowNum1 - 1 + this.startRowColNum;
//	var colNum0 = colNum1 - 1 + this.startRowColNum;
//	var column = null;
	
	if( colAttr == null ){
		colAttr = {colId : colId, caption : colId};
	}
	
	if( typeof colAttr.colId == "undefined" ) colAttr.colId = colId;
	if( typeof colAttr.title == "undefined" ) colAttr.title = colId;
	if( typeof colAttr.sheetRow == "undefined" ) colAttr.sheetRow = rowNum1;
	if( typeof colAttr.sheetCol == "undefined" ) colAttr.sheetCol = colNum1;
	if( typeof colAttr.sheetRowSpan == "undefined" ) colAttr.sheetRowSpan = rowSpan;
	if( typeof colAttr.sheetColSpan == "undefined" ) colAttr.sheetColSpan = colSpan;
	
	// 컬럼 생성
	column = new EXOColumn(colAttr);
	
	// 컬럼 추가
//	this.columns.splice(colNum0, 0, column);
//	for(var i = colNum0; i < this.columns.length; i++){
//		this.columns[i].sheetCol = i + 1;
//	}
	this.columns.push(column);
	
	// 데이터셋 필드 추가
	this.dataSet.addField({
		field : column.colId,
		fieldName : (column.caption.length > 0) ? column.caption : column.colId,
		dataType : column.colDataType
	});
	
	// this.displayInfo.rowsPerDataRow 갱신 
	if( colAttr.sheetRow + colAttr.sheetRowSpan - 1 > this.displayInfo.rowsPerDataRow ){
		this.displayInfo.rowsPerDataRow = colAttr.sheetRow + colAttr.sheetRowSpan - 1;
	}
	
	// 순서가 뒤섞여 함수가 호출되면 Sorting이 필요하게 된다 
	this.columns.sort(function(a, b){
		if( a.sheetRow != b.sheetRow ){
			return a.sheetRow - b.sheetRow;
		}
		return a.sheetCol - b.sheetCol;
	});
	
	// 컬럼 갯수 갱신
	this.maxCols = this.columns.length;
	
	// 렌더러 컬럼 추가 반영
	if( this.pivot == null ){
		var colNum0 = this.maxCols;
		var exoColumn = null;
		var i = 0;
		
		for(i = 0; i < this.maxCols; i++, exoColumn = null){
			exoColumn = this.columns[i];
			if( exoColumn === column ){
				colNum0 = i;
				exoColumn = null;
				break;
			}
		}
		
		this.sheetRenderer.addColumn(colNum0, column);
	}
	
	// 산식 재계산
	this.refreshFormulaRefs();
	
	// 메모리 해제
	column = null; colAttr = null; colId = null;
	
	return column;
};

/**
 * @description 
 *     시트의 칼럼정보를 삭제한다, 파라메터로 행열위치 또는 칼럼의 아이디 정보를 준다<br/>
 *     사용방법은 시트의 줄처리 방식에 따라 다르다)<br/>
 *     이함수는 다음 형태로 사용된다.<br/>
 *     sheet.delColumn()<br/>
 *     sheet.delColumn(colNum1)<br/>
 *     sheet.delColumn(colId)<br/>
 *     sheet.delColumn(rowNum1, colNum1)<br/>
 *     
 * @param {Number|undefined}	[rowNum1=startRowColNum]		- 시트의 논리적인 줄번호    시트의 시작 줄번호부터 시작
 * @param {Number|undefined}	[colNum1]=Column Number			- 시트의 논리적인 칼럼번호   시트의 시작 줄번호부터 시작
 * @param {String|undefined}	[colId]=Column Id				- 칼럼의 고유 아이디 (영문)
 * 
 * @return {Boolean} 			- 시트의 칼럼정보 삭제처리 결과
 *     
 * @example
 * 
 * 			// Single Row 인 경우
 * 			sheet.delColumn();
 * 			sheet.delColumn("columnA");
 * 			sheet.delColumn(1);
 * 			// Multi  Row인 경우
 * 			sheet.delColumn();
 * 			sheet.delColumn("columnA");
 * 			sheet.delColumn(3);
 * 			sheet.delColumn(2,3); 
 * 
 */
EasySheet.prototype.delColumn = function(/* rowNum1, colNum1, colId */){
	// functionname : [EasySheet.addColumn]
	
	var isIncorrectParam = false;
	var column = null;
	var rowNum1 = 1
	var colNum1 = 1;
	var colId = null;
	
	if( arguments.length == 0 ){
		//마지막 컬럼 삭제
		column = this.columns[this.columns.length - 1];
		rowNum1 = column.sheetRow;
		colNum1 = column.sheetCol;
		column = null;
	}
	else if( arguments.length == 1 ){
		//컬럼 번호 또는 컬럼 아이디
		if( typeof arguments[0] == "number" )
			 colNum1 = arguments[0];
		else if( typeof arguments[0] == "string" )
			 colId = arguments[0];
		else isIncorrectParam = true;
	}
	else if( arguments.length == 2 ){
		//행번호
		if( typeof arguments[0] == "number" )
			rowNum1 = arguments[0];
		else isIncorrectParam = true;
		//열번호
		if( typeof arguments[1] == "number" )
			 colNum1 = arguments[0];
		else isIncorrectParam = true;
	}
	else{
		colId = null;
		
		//인수의 갯수가 맞지 않음
		alert(getText(	"message_EasySheet_003", 
						"EasySheet.delColumn 인수의 갯수가 {0}입니다.\n" + 
						"delColumn() 또는 delColumn(colId) 또는\n" + 
						"delColumn(colNum)  또는\n" + 
						"delColumn(rowNum, colNum)",
						arguments.length
		));
		return false;
	}
	
	// 오류처리 
	if( isIncorrectParam ){
		colId = null;
		
		alert(getText(	"message_EasySheet_003", 
						"EasySheet.delColumn 인수가 올바르지 않습니다.\n" + 
						"delColumn() 또는 delColumn(colId) 또는\n" + 
						"delColumn(colNum) 또는\n" + 
						"delColumn(rowNum, colNum)"
		));
		return false;
	}
	if( rowNum1 < this.startRowColNum || colNum1 < this.startRowColNum ){
		colId = null;
		
		alert(getText(	"message_EasySheet_041", 
						"추가할 줄번호/열번호는 " + this.startRowColNum + " 이상이어야 합니다.\n{0}", 
						JSON.stringify({ rowNum: rowNum1, colNum: colNum1, rowSpan: rowSpan, colSpan: colSpan})
		));
		return false;
	}
	
	var rowNum0 = rowNum1 - this.startRowColNum;
	var colNum0 = 0;
	var colCount = 0;
	var i = 0;
	
	// 파라메터를 컬럼 아이디로 받은 경우, 컬럼 아이디로 컬럼 인덱스를 찾음 
	if( colId != null ){
		colNum0 = this.getColNum(colId);
	}
	else{
		var sheetRow = 0;
		var sheetCol = 0;
		
		for(i = 0; i < this.maxCols; i++, exocolumnColumn = null){
			column = this.columns[i];
			sheetRow = column.sheetRow;
			sheetCol = column.sheetCol;
			
			if( rowNum1 == sheetRow && colNum1 == sheetCol )
				break;
		}
		
		if( column == null ){
			return false;
		}
		else{
			column = null;
			colNum0 = i;
		}
	}
	
//	// 컬럼 번호 정리
//	for(i = colNum0 + 1, colCount = this.maxCols; i < colCount; i++){
//		column = this.columns[i];
//		column.sheetCol = column.sheetCol - 1;
//		column = null;
//	}
	
	// 컬럼 삭제
	this.columns.splice(colNum0, 1);
	
	// 데이터셋 필드 삭제
//	this.dataSet.addField({
//		field : column.colId,
//		fieldName : (column.caption.length > 0) ? column.caption : column.colId,
//		dataType : column.colDataType
//	});
	
	// 순서가 뒤섞여 함수가 호출되면 Sorting이 필요하게 된다 
	this.columns.sort(function(a, b){
		if( a.sheetRow != b.sheetRow ){
			return a.sheetRow - b.sheetRow;
		}
		return a.sheetCol - b.sheetCol;
	});
	
	// 컬럼 갯수 갱신
	this.maxCols = this.columns.length;
	
	// 렌더러 컬럼 추가 반영
	this.sheetRenderer.delColumn(colNum0);
	
	// 산식 재계산
	this.refreshFormulaRefs();
	
	// 메모리 해제
	column = null; colAttr = null; colId = null;
	
	return true;
};

/**
 * @description 
 *     시트에 푸터칼럼정보를 추가한다, 생성자로 행열위치와 셀확장 정보를 준다<br/>
 *     사용방법은 시트의 줄처리 방식에 따라 다르다)<br/>
 *     colId를 생략하면 colId에는 "f" + colNum과 같은 값이 들어간다 <br/>
 * 
 * @param {Number}	rowNum1		- 시트의 물리적인 줄번호 1번 부터 시작
 * @param {Number}	colNum1		- 시트의 물리적인 칼럼번호 1번 부터 시작
 * @param {Number}	rowSpan		- 시트의 물리적인 줄 확장 셀수
 * @param {Number}	colSpan		- 시트의 물리적인 칼럼 확장 셀수
 * @param {String}	colId		- 푸터칼럼의 고유 아이디 (영문)
 * @param {Object|undefined}	[colAttribute=Empty JSON] 		- 푸터의 속성을 지정하는 JSON 정보
 * 
 * @return {EXOColumn} 			- 생성된 EXOColumn 개체
 *     
 * @example
 * sheet.addFooter(1); sheet.addFooter(1, "abc"); // Single Row 인 경우
 * sheet.addFooter(2,3,3,4); sheet.addFooter(2,3,3,4, "abc"); Multi  Row인 경우
 */
EasySheet.prototype.addFooter = function(/* rowNum1, colNum1, rowSpan, colSpan, colId, colAttribute */){
	// functionname : [EasySheet.addFooter]
	
	var rowNum1 = this.startRowColNum;
	var colNum1 = this.startRowColNum;
	var colId = "add_column_" + this.startRowColNum;
	var rowSpan = 1;
	var colSpan = 1;
	var colAttr = null;
	
	if( arguments.length == 0 ){
		colNum1 = this.columns.length + this.startRowColNum;
		colId = "add_column_" + colNum1;
	}
	else if( arguments.length == 1 ){
		if( typeof arguments[0] == "number" ){
			colNum1 = arguments[0];
			colId = "add_column_" + colNum1;
		}
		else if( typeof arguments[0] == "object" ){
			colNum1 = this.columns.length + this.startRowColNum;
			colId = "add_column_" + colNum1;
			colAttr = arguments[0];
		}
		else{
			colNum1 = this.columns.length + this.startRowColNum;
			colId = arguments[0];
		}
	}
	else if( arguments.length == 2 ){
		colNum1 = arguments[0];
		
		if( typeof arguments[1] == "object" ){
			colId = "add_column_" + colNum1;
			colAttr = arguments[1];
		}
		else{
			colId = arguments[1];
		}
	}
	else if( arguments.length == 3 ){
		rowNum1 = arguments[0];
		colNum1 = arguments[1];
		
		//세번째 파라메터가 객체인 경우 파라메터는 컬럼 속성 객체임
		if( typeof arguments[2] == "object" ){
			colId = "add_column_" + colNum1;
			colAttr = arguments[2];
		}
		else{
			colId =  arguments[2];
		}
	}
	else if (arguments.length == 4){
		rowNum1 = arguments[0];
		colNum1 = arguments[1];
		
		if( typeof arguments[2] == "number" ){
			colId = "add_column_" + colNum1;
			rowSpan = arguments[2];
			colSpan = arguments[3];
		}
		else{
			colId = arguments[2];
			colAttr = arguments[3];
		}
	}
	else if (arguments.length == 5){
		rowNum1 = arguments[0];
		colNum1 = arguments[1];
		rowSpan = arguments[2];
		colSpan = arguments[3];
		
		if( typeof arguments[4] == "object" )
			colAttr = arguments[4];
		else
			colId =  arguments[4];
	}
	else if( arguments.length == 6 ){
		rowNum1 = arguments[0];
		colNum1 = arguments[1];
		rowSpan = arguments[2];
		colSpan = arguments[3];
		colId = arguments[4];
		colAttr = arguments[5];
	}
	else{
		alert(getText(	"message_EasySheet_003", 
						"EasySheet.addColumn의 인수의 갯수가 {0}입니다. \n" + 
						"addColumn(colNum) 또는 addColumn(colNum, colId) 또는\n" + 
						"addColumn(rowNum, colNum, rowSpan, colSpan)  또는\n" + 
						"addColumn(rowNum, colNum, rowSpan, colSpan, colId) ",
						arguments.length
		));
		return null;
	}
	
	// 오류처리 
	if( rowNum1 < this.startRowColNum || colNum1 < this.startRowColNum ){
		alert(getText(	"message_EasySheet_041", 
						"추가할 줄번호/열번호는 " + this.startRowColNum + " 이상이어야 합니다.\n{0}", 
						JSON.stringify({ rowNum: rowNum1, colNum: colNum1, rowSpan: rowSpan, colSpan: colSpan})
		));
		return null;
	}
	else if( rowSpan < 1 || colSpan < 1 ){
		alert(getText(	"message_EasySheet_042", 
						"추가할 줄확장/열확장수는 1 이상이어야 합니다.\n{0}", 
						JSON.stringify({ rowNum: rowNum1, colNum: colNum1, rowSpan: rowSpan, colSpan: colSpan})
		));
		return null;
	}
	
	var rowNum0 = rowNum1 - this.startRowColNum;
	var colNum0 = colNum1 - this.startRowColNum;
	var column = null;
	
	if (colAttr == null){
		colAttr = {colId : colId, caption : colId};
	}
	else{
		if( typeof colAttr.colId == "undefined" ) colAttr.colId = colId;
		if( typeof colAttr.title == "undefined" ) colAttr.title = colId;
		if( typeof colAttr.sheetRow == "undefined" ) colAttr.sheetRow = rowNum0;
		if( typeof colAttr.sheetCol == "undefined" ) colAttr.sheetCol = colNum0;
		if( typeof colAttr.sheetRowSpan == "undefined" ) colAttr.sheetRowSpan = rowSpan;
		if( typeof colAttr.sheetColSpan == "undefined" ) colAttr.sheetColSpan = colSpan;
	}
	
	// 컬럼 생성
	column = new EXOColumn(colAttr);
	
	// 컬럼 추가
	this.footers.splice(colNum0, 0, column);
	
//	// 데이터셋 필드 추가
//	this.dataSet.addField({
//		field : column.colId,
//		fieldName : (column.caption.length > 0) ? column.caption : column.colId,
//		dataType : column.colDataType
//	});
	
//	// this.displayInfo.rowsPerDataRow 갱신 
//	if( colAttr.sheetRow + colAttr.sheetRowSpan - 1 > this.displayInfo.rowsPerDataRow )
//		this.displayInfo.rowsPerDataRow = colAttr.sheetRow + colAttr.sheetRowSpan - 1;
	
	// 순서가 뒤섞여 함수가 호출되면 Sorting이 필요하게 된다 
	this.footers.sort(function(a, b){
		if( a.sheetRow != b.sheetRow ){
			return a.sheetRow - b.sheetRow;
		}
		return a.sheetCol - b.sheetCol;
	});
	
//	// 컬럼 갯수 갱신
//	this.maxCols = this.footers.length;
	
	// 렌더러 컬럼 추가 반영
	this.sheetRenderer.addColumn(colNum0, column);
	
//	// 산식 재계산
//	this.refreshFormulaRefs();
	
	// 메모리 해제
	column = null; colAttr = null; colId = null;
	
	return column;
};

/**
 * @description 
 *     칼럼정보에 설정된 디폴트 값으로 전체 시트를 채움<br/>
 *     
 * @return {void}	
 * 		
 * @example
 * sheet.setDefaultData(); 
 * 
 */
EasySheet.prototype.setDefaultData = function(){
	// functionname : [EasySheet.setDefaultData]
	// 기존사용처: 없음


	// 피벗에는 적용되지 않음
	if (this.pivot != null){  
		this.pivot._warnUnsupport("setDefaultData");
		return;
	}	
	
	var rowNum0 = 0;
	var colNum0 = 0;
	var datas = this.dataSet.data;
	var data = null;
	var record = null;
	var column = null;
	
	for(rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++){
		if( this.rows(rowNum0).rowType == "Logical" ) continue;
		
		data = datas[rowNum0];
		record = {};
		
		//기본값 레코드 생성
		for(colNum0 = 0; colNum0 < this.maxCols; colNum0++){
			column = this.columns[colNum0];
			
			//컬럼의 defaultValue 속성이 있다면 defaultValue 로 설정
			if( column["defaultValue"] != null && typeof column["defaultValue"] != "undefined" ){
				record[column.colId] = (typeof column.defaultValue == "function") ? column.defaultValue() : column.defaultValue;
			}
			//컬럼의 defaultValue 속성이 없다면 컬럼의 데이터 타입에 따라 기본값 설정
			else{
				if( column["colDataType"] == "string" || column["colDataType"] == "number" ) //문자열 or 숫자
					record[column.colId] = "";
				else if( column["colDataType"] == "boolean" )
					record[colId] = false;
				else											//그 외
					record[column.colId] = null;
			}
			
			//메모리 해제
			column = null;
		}
		
		//데이터 갱신
		this.dataSet.updateData(rowNum0, record);
		
		//메모리 해제
		record = null; data = null;
	}
	
	// 산식갱신
	if( this.autoCalc && JSON.stringify(this._formulaRefs) !== "{}" )
		this.refreshFormulaRefs();
	
	// 그루핑 처리
	if( this.needGrouping )
		this.sumUp.resetGroup();
	
	// 화면상 시트갱신, 데이터만 변경 
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
	this.updateScreen(SHEET_RESET_DATA);
	
	// 메모리 해제
	record = null; data = null; datas = null;
};



/**
 * @description 
 *     배열로된 데이터를 시트에 부어준다 <br/>
 *     열번호에 할당된 colId를 기준으로 데이터가 들어가며 열수가 부족한 경우 나머지 필드는 디폴트 데이터를 채우게 된다 <br/>
 *     첫줄에 부여된 산식과 칼럼에 부여된 산식을 제외하고 각 줄이나 하단의 셀에 부여된 산식은 모두 지워진다. <br/>
 * 
 * @param {Object[][]}	arrData		- 2차원 배열 데이터  
 * 
 * @return {void} 

 * @example
 * sheet.setArrayData([[1,2,3], [4,5,6]]);
 * sheet.setArrayData([{a:1, b:2}, {a:3, b:4}]);
 */
EasySheet.prototype.setArrayData = function(arrData){
	// functionname : [EasySheet.setArrayData]
	// 기존사용처: 없음
	
	if( typeof arrData == "undefined" || !(arrData instanceof Array )){
		alert(	getText("message_EasySheet_004",
				"EasySheet.setArrayData() 함수의 사용이 잘못 되었습니다.\n"
				+ "  setData([[...], [...]])"
		));
		return;
	}
	
	// 피벗이면 데이터를 교체
	if (this.pivot != null){  
		this.pivot.dataSet.setDataArray();
        this.pivot.refreshPivot();
		return;
	}
	
	//필터 해제
	this.unfilter();
	
	var rowNum0 = 0; var colNum0 = 0;
	var arrLength = arrData.length;
	var arrRecord = null; var value = null;
	var records = null; var record = null; var state = null;
	var column = null; var colId = null; var colDataType = null;
	
	if( Array.isArray(arrData[0]) ){
		records = [];
		
		for(rowNum0 = 0; rowNum0 < arrLength; rowNum0++){
			// 레코드 생성
			record = {};
			// 배열 데이터 저장
			arrRecord = arrData[rowNum0];
			// 데이터 추가
			for(colNum0 = 0; colNum0 < this.maxCols; colNum0++){
				column = this.columns[colNum0];
				colId = column.colId;
				colDataType = column.colDataType;
				value = arrRecord[colNum0];
				//
				record[colId] = (colDataType == "number") ? 1 * value : value;
				// 메모리 해제
				value = null;
				colDataType = null; colId = null; column = null;
			}
			// 레코드 갱신
			records[rowNum0] = record;
			// 레코드 상태 갱신
			state = record["__STATE__"] = {};
			state.objectSeq = 1;
			state.updateGu = "I";
			// 메모리 해제
			state = null;
			record = null;
			arrRecord = null;
		}
		
		this.dataSet.setDataArray(records);

		// 메모리 해제
		records = null;
	}
	else{
		for(rowNum0 = 0; rowNum0 < arrLength; rowNum0++){
			record = arrData[rowNum0];
			// 레코드 상태 갱신
			state = record["__STATE__"] = {};
			state.objectSeq = 1;
			state.updateGu = "I";
			// 메모리 해제
			state = null;
			record = null;
		}
		
		this.dataSet.setDataArray(arrData);
	}
	
	this.currentRow = this.startRowColNum;
	this.maxRows = arrLength; /**@ 맥스 로우 지정*/
	
	//편집 컨트롤 닫음
	this.completeEditing(false);
	//현재 선택된 셀 또는 로우를 해제함
	this.clearSelection();
	
	// 연결된 객체 갱신
	var linkedObejctCount = this.linkedObjects.length;
	if( linkedObejctCount > 0 ){
		var linkedObejct = null;
		var remakeDataset = null;
		var linkedObjectMaxSeq = 0;
		var recordLength = 0;
		var rowNum = 0;
		var i = 0;
		
		//객체 데이터 갱신
		for(i = 0; i < linkedObejctCount; i++){
			linkedObejct = this.linkedObjects[i];
			remakeDataset = this._remakeDataToObject(linkedObejct, this.dataSet);
			
			if( remakeDataset == null ) continue;
			
			linkedObejct.setDataSet(remakeDataset);
			recordLength = remakeDataset.getCount();
			
			//메모리 해제
			if( this.dataSet !== remakeDataset ) remakeDataset.clear();
			remakeDataset = null; linkedObejct = null;
		}
		//객체 Seq 갱신
		for(rowNum = this.startRowColNum, linkedObjectMaxSeq = this.linkedObjects[0].startSeq; rowNum < recordLength; rowNum++){
			this.rows(rowNum).objectSeq = linkedObjectMaxSeq;
			for(i = 0; i < linkedObejctCount; i++){
				this.linkedObjects[i].updateSeqField(linkedObjectMaxSeq, linkedObjectMaxSeq);
			}
			linkedObjectMaxSeq++;
		}
		for(i = 0; i < linkedObejctCount; i++){
			this.linkedObjects[i].maxSeq = linkedObjectMaxSeq - 1;
		}
	}
	
	//데이터셋 처리
	if( this.linkedDataset != null ){
		var args = Array.prototype.slice.call(arguments);
		var update = (args.length < 2) ? true : args[1];
		if( (typeof update == "undefined" || update) && typeof this._UpdateDatasetList != "undefined" ){
			this._UpdateDatasetList();
		}
		args = null;
	}
	
	// 소트칼럼 정리
	this.sortOut(SHEET_RESET_DATA);
	
	// 칼럼에 부여된 산식 재 부여
	this.refreshFormulaRefs();
	
	// 그루핑 처리
	if( this.needGrouping ) this.sumUp.resetGroup();
	
	// 화면상 시트갱신 , 데이터만 변경
	this.updateScreen(SHEET_RESET_DATA);
	
	return;
};

/**
 * @description 
 *     가져오기 또는 객체로드의 JsonObject 데이터를 시트에 부어준다 <br/>
 * 
 * @param 	{Object}	jsonObject		- JSON 객체 <br/>
 * 							  			{fieldList:[], recordList:[], rowCount:n}
 * 
 * @return {void} 

 * @example
 * sheet.setData({
 * 		fieldList : [{field : "field1", fieldName : "필드1", dataType : "string"}, {field : "field2", fieldName : "필드2", dataType : "number"}, {field : "fieldN", fieldName : "필드N", dataType : "number"}]
 * 		, recordList : [{field1: "AAA", field2: 123, fieldN: 100}, {field1: "BBB", field2: 234, fieldN: 200}, {field1: "CCC", field2: 345, fieldN: 300}]
 * 		, rowCount : 3
 * });
 */
EasySheet.prototype.setData = function( jsonObject ){
	// functionname : [EasySheet.setData]
	
	//파라메터 없을 경우 예외처리
	if( typeof jsonObject == "undefined" || jsonObject == null ){
		alert(getText(	"message_EasySheet_005", 
						"EasySheet.setData() 함수의 사용이 잘못 되었습니다.\n" + 
						"  setData()"
		));
		return ;
	}
	
	//잘못된 파라메터가 전달된 경우 예외처리
	if( (typeof jsonObject.fieldList == "undefined" || !Array.isArray(jsonObject.fieldList)) 
		|| (typeof jsonObject.recordList == "undefined" || !Array.isArray(jsonObject.recordList)) 
		|| (typeof jsonObject.rowCount != "number")
	){
		alert(getText("message_EasySheet_005", "EasySheet.setData() 함수의 파라메터가 올바르지 않습니다.\n"));
		return;
	}
	
	//편집 컨트롤 닫음
	this.completeEditing(false);
	//시트 메세지 박스 닫음
	this.setMessageBox(false);
	//현재 선택된 셀 또는 로우를 해제함
	this.clearSelection();
	
 	// 피벗이면 데이터를 채움
 	if (this.pivot != null){  
		this.pivot.dataSet.setData(jsonObject);
        this.pivot.refreshPivot();
		return;
	}

 	//필터 해제
	this.unfilter();
	
	//데이터 갱신
	var resultObject = this.dataSet.setData(jsonObject);
	if( resultObject.result == false ){
		alert(resultObject.errorMsg);
		return ;
	}
	
	this.currentRow = this.startRowColNum;
	this.maxRows = jsonObject.rowCount; /**@ 맥스 로우 지정*/
	
//	//편집 컨트롤 닫음
//	this.completeEditing(false);
//	//현재 선택된 셀 또는 로우를 해제함
//	this.clearSelection();
	
	// 연결된 객체 갱신
	var linkedObejctCount = this.linkedObjects.length;
	if( linkedObejctCount > 0 ){
		var linkedObejct = null;
		var remakeDataset = null;
		var linkedObjectMaxSeq = 0;
		var recordLength = 0;
		var rowNum = 0;
		var i = 0;
		
		//객체 데이터 갱신
		for(i = 0; i < linkedObejctCount; i++){
			linkedObejct = this.linkedObjects[i];
			remakeDataset = this._remakeDataToObject(linkedObejct, this.dataSet);
			
			if( remakeDataset == null ) continue;
			
			linkedObejct.setDataSet(remakeDataset);
			recordLength = remakeDataset.getCount();
			
			//메모리 해제
			if( this.dataSet !== remakeDataset ) remakeDataset.clear();
			remakeDataset = null; linkedObejct = null;
		}
		//객체 Seq 갱신
		for(rowNum = this.startRowColNum, linkedObjectMaxSeq = this.linkedObjects[0].startSeq; rowNum < recordLength; rowNum++){
			this.rows(rowNum).objectSeq = linkedObjectMaxSeq;
			for(i = 0; i < linkedObejctCount; i++){
				this.linkedObjects[i].updateSeqField(linkedObjectMaxSeq, linkedObjectMaxSeq);
			}
			linkedObjectMaxSeq++;
		}
		for(i = 0; i < linkedObejctCount; i++){
			this.linkedObjects[i].maxSeq = linkedObjectMaxSeq - 1;
		}
	}
	
//	//연결된 데이터셋이 있다면 모든 레코드의 업데이트 상태를 N으로 변경
//	if( this.linkedDataset != null && typeof this.linkedDataset != "undefined" ){
//		var recordLength = this.dataSet.getCount();
//		var i = 0;
//		
//		for(i = this.startRowColNum; i < recordLength; i++){
//			this.dataSet.setState(i, "updateGu", "N");
//		}
//	}
	
	//데이터셋 처리
	if( this.linkedDataset != null ){
		var args = Array.prototype.slice.call(arguments);
		var update = (args.length < 2) ? true : args[1];
		if( (typeof update == "undefined" || update) && typeof this._UpdateDatasetList != "undefined" ){
			this._UpdateDatasetList();
		}
		args = null;
	}
	
	// 소트칼럼 정리 
	this.sortOut(SHEET_RESET_DATA);
	
	// 칼럼에 부여된 산식 재 부여
	this.refreshFormulaRefs();
	
	// 그루핑 처리
	if( this.needGrouping ) this.sumUp.resetGroup();
	
	//화면상 시트갱신 , 데이터만 변경
	this.updateScreen(SHEET_RESET_DATA);
	
    return;
};

EasySheet.prototype.setDataSet = function( dataset ){
	// functionname : [EasySheet.setDataSet]
	
	//파라메터 없을 경우 예외처리
	if( typeof dataset == "undefined" || dataset == null ){
		alert(getText(	"message_EasySheet_005", 
						"EasySheet.setDataSet() 함수의 사용이 잘못 되었습니다.\n" + 
						"  setData()"
		));
		return ;
	}
	
	//잘못된 파라메터가 전달된 경우 예외처리
	if( (typeof dataset.fieldInfos == "undefined" || !(dataset.fieldInfos instanceof Object))
		|| (typeof dataset.data == "undefined"|| !Array.isArray(dataset.data))
		|| (typeof dataset.deletedData == "undefined" || !Array.isArray(dataset.deletedData))
	){
		alert(getText("message_EasySheet_005", "EasySheet.setDataSet() 함수의 파라메터가 올바르지 않습니다.\n"));
		return ;
	}
	
	//편집 컨트롤 닫음
	this.completeEditing(false);
	//시트 메세지 박스 닫음
	this.setMessageBox(false);
	//현재 선택된 셀 또는 로우를 해제함
	this.clearSelection();
	
 	// 피벗이면 데이터를 채움
 	if (this.pivot != null){  
		this.pivot.dataSet.setDataSet(dataset);
        this.pivot.refreshPivot();
		return;
	}
	
	//필터 해제
	this.unfilter();
	
	//데이터 갱신
	var resultObject = this.dataSet.setDataSet(dataset);
	if( resultObject.result == false ){
		alert(resultObject.errorMsg);
		return ;
	}
	
	this.currentRow = this.startRowColNum;
	this.maxRows = dataset.getCount(); /**@ 맥스 로우 지정*/
	
//	//편집 컨트롤 닫음
//	this.completeEditing(false);
//	//현재 선택된 셀 또는 로우를 해제함
//	this.clearSelection();
	
	// 연결된 객체 갱신
	var linkedObejctCount = this.linkedObjects.length;
	if( linkedObejctCount > 0){
		var linkedObejct = null;
		var remakeDataset = null;
		var linkedObjectMaxSeq = 0;
		var recordLength = 0;
		var rowNum = 0;
		var i = 0;
		
		//객체 데이터 갱신
		for(i = 0; i < linkedObejctCount; i++){
			linkedObejct = this.linkedObjects[i];
			remakeDataset = this._remakeDataToObject(linkedObejct, this.dataSet);
			
			if( remakeDataset == null ) continue;
			
			linkedObejct.setDataSet(remakeDataset);
			recordLength = remakeDataset.getCount();
			
			//메모리 해제
			if( this.dataSet !== remakeDataset ) remakeDataset.clear();
			remakeDataset = null; linkedObejct = null;
		}
		//객체 Seq 갱신
		for(rowNum = this.startRowColNum, linkedObjectMaxSeq = this.linkedObjects[0].startSeq; rowNum < recordLength; rowNum++){
			this.rows(rowNum).objectSeq = linkedObjectMaxSeq;
			for(i = 0; i < linkedObejctCount; i++){
				this.linkedObjects[i].updateSeqField(linkedObjectMaxSeq, linkedObjectMaxSeq);
			}
			linkedObjectMaxSeq++;
		}
		for(i = 0; i < linkedObejctCount; i++){
			this.linkedObjects[i].maxSeq = linkedObjectMaxSeq - 1;
		}
	}
	
	//데이터셋 처리
	if( this.linkedDataset != null ){
		var args = Array.prototype.slice.call(arguments);
		var update = (args.length < 2) ? true : args[1];
		if( (typeof update == "undefined" || update) && typeof this._UpdateDatasetList != "undefined" ){
			this._UpdateDatasetList();
		}
		args = null;
	}
	
	// 소트칼럼 정리 
	this.sortOut(SHEET_RESET_DATA);
	
	// 칼럼에 부여된 산식 재 부여
	this.refreshFormulaRefs();
	
	// 그루핑 처리
	if( this.needGrouping ) this.sumUp.resetGroup();
	
	// 화면상 시트갱신 , 데이터만 변경
	this.updateScreen(SHEET_RESET_DATA);
	
	return;
};

EasySheet.prototype.appendDataSet = function( dataset ){
	// functionname : [EasySheet.appendDataSet]

	// 파라메터 없을 경우 예외처리
	if( typeof dataset == "undefined" || dataset == null ){
		alert(getText(	"message_EasySheet_005", 
						"EasySheet.appendDataSet() 함수의 사용이 잘못 되었습니다.\n" + 
						"  setData()"
		));
		return;
	}
	
	// 잘못된 파라메터가 전달된 경우 예외처리
	if( (typeof dataset.fieldInfos == "undefined" || !(dataset.fieldInfos instanceof Object)) || (typeof dataset.data == "undefined" || !Array.isArray(dataset.data)) || (typeof dataset.deletedData == "undefined" || !Array.isArray(dataset.deletedData)) ){
		alert(getText("message_EasySheet_005", "EasySheet.appendDataSet() 함수의 파라메터가 올바르지 않습니다.\n"));
		return ;
	}
	
 	// 피벗이면 데이터를 채움
 	if (this.pivot != null){  
		this.pivot.dataSet.appendDataSet(dataset);
        this.pivot.refreshPivot();
		return;
	}	
	
	var addStartIndex = this.maxRows + this.startRowColNum;
	
	// 데이터 추가
	var resultObject = this.dataSet.appendDataSet(dataset);
	if( resultObject.result == false ){
		alert(resultObject.errorMsg);
		return;
	}
	
	var lastRow = this.maxRows - 1;
	this.maxRows += dataset.getCount(); /** @ 맥스 로우 지정 */
	
	// 연결된 객체 갱신
	var linkedObejctCount = this.linkedObjects.length;
	if( linkedObejctCount > 0){
		var linkedObejct = null;
		var remakeDataset = null;
		var linkedObjectMaxSeq = 0;
		var recordLength = 0;
		var rowNum = 0;
		var i = 0; var j = 0;
		
		//객체 데이터 갱신
		for(i = 0; i < linkedObejctCount; i++){
			linkedObejct = this.linkedObjects[i];
			remakeDataset = this._remakeDataToObject(linkedObejct, dataset);
			
			if( remakeDataset == null ) continue;
			
			linkedObejct.appendDataSet(remakeDataset);
			recordLength = remakeDataset.getCount();
			
			//메모리 해제
			if( this.dataSet !== remakeDataset ) remakeDataset.clear();
			remakeDataset = null; linkedObejct = null;
		}
		//객체 Seq 갱신
		for(j = 0, rowNum = addStartIndex, linkedObjectMaxSeq = this.linkedObjects[0].maxSeq + 1; j < recordLength; j++, rowNum++){
			this.rows(rowNum).objectSeq = linkedObjectMaxSeq;
			for(i = 0; i < linkedObejctCount; i++){
				this.linkedObjects[i].updateSeqField(linkedObjectMaxSeq, linkedObjectMaxSeq);
			}
			linkedObjectMaxSeq++;
		}
		for(i = 0; i < linkedObejctCount; i++){
			this.linkedObjects[i].maxSeq = linkedObjectMaxSeq - 1;
		}
	}
	
	//데이터셋 처리
	if( this.linkedDataset != null ){
		var args = Array.prototype.slice.call(arguments);
		var update = (args.length < 2) ? true : args[1];
		if( (typeof update == "undefined" || update) && typeof this._UpdateDatasetList != "undefined" ){
			this._UpdateDatasetList();
		}
		args = null;
	}
	
	// 소트칼럼 정리
	this.sortOut();
	
	// 칼럼에 부여된 산식 재 부여
	this.refreshFormulaRefs();
	
	// 그루핑 처리
	if( this.needGrouping ) this.sumUp.resetGroup();
	
	// 화면상 시트갱신 , 데이터만 변경
	this.updateScreen();
	
	return;
};

EasySheet.prototype._remakeDataToObject = function( linkedObejct, wsdataset ){
	if( typeof linkedObejct == "undefined" || linkedObejct == null )
		return null;
	if( typeof wsdataset == "undefined" || wsdataset == null )
		return null;
	
	var remakeDataset = null;
	var recordLength = wsdataset.getCount();
	var recordList = null;
	var recordItem = null;
	var oldRecordItem = null;
	
	var linkedObjectId = linkedObejct.id;
	var propertyCount = linkedObejct.propertyCount;
	var columnCount = this.columns.length;
	var property = null;
	var columnInfo = null;
	var defaultValue = null;
	var key = null;
	var needMappingData = false;
	var i = 0, j = 0;
	
	//매핑데이터 필요여부 판단(객체 프로퍼티 기본값 체크 > 객체 프로퍼티와 열결된 시트 컬럼ID 체크
	//1. 객체 프로퍼티 기본값 체크
	for(i = 0; i < propertyCount && !needMappingData; i++){
		property = linkedObejct.propertyInfos[i];
		defaultValue = property.defaultValue;
		
		//데이터 생성하는데 기본값이 필요한 경우 매핑데이터 생성 필요
		if( typeof defaultValue == "function" )
			needMappingData = true;
		else if( typeof defaultValue != "undefined" && defaultValue != null && ("" + defaultValue).length > 0 )
			needMappingData = true;
		
		//메모리 해제
		property = null; defaultValue = null;
	}
	//기본값 체크에서 데이터 생성이 필요하다고 판단된 경우 객체 프로퍼티와 연결된 시트 컬럼ID 체크하지 않음 
	//2. 객체 프로퍼티와 열결된 시트 컬럼ID 체크
	if( !needMappingData ){
		for(i = 0; i < columnCount && !needMappingData; i++){
			columnInfo = this.columns[i];
			
			//객체 프로퍼티와 연결된 컬럼이 없는 경우
			if( !(linkedObjectId in columnInfo.linkedPropertys) )
				continue;
			//객체 프로퍼티와 연결된 컬럼의 아이디가 다르면 매핑데이터 생성 필요
			if( columnInfo.colId != columnInfo.linkedPropertys[linkedObjectId] )
				needMappingData = true;	
			
			//메모리 해제
			columnInfo = null;
		}
	}
	//매핑데이터 생성 여부 체크하여 데이터 생성
	//3. 데이터 생성
	if( needMappingData ){
		remakeDataset = new WsDataSet();
		remakeDataset.deleteDataPolicy = WSDATASET_DELETE_POLICY.LEAVE_RECORD_IN_DATA;
		recordList = [];
		
//		for(i = 0, oldRecordItem = {}; i < propertyCount; i++, property = null){
//			property = linkedObejct.propertyInfos[i];
//			oldRecordItem[property.id] = null;
//		}
		
		for(i = 0; i < recordLength; i++, recordItem = null, oldRecordItem = null){
			recordItem = recordList[i] = {};
			recordItem.__STATE__ = {updateGu : "X"};
			
			oldRecordItem = {};
			
			//기본값 세팅
			for(j = 0; j < propertyCount; j++){
				property = linkedObejct.propertyInfos[j];
				defaultValue = (typeof property.defaultValue == "function") ? property.defaultValue() : property.defaultValue;
				recordItem[property.id] = defaultValue;
				oldRecordItem[property.id] = defaultValue;
				defaultValue = null; property = null;
			}
			//시트 데이터 세팅
			for(j = 0; j < columnCount; j++){
				columnInfo = this.columns[j];
				if( linkedObjectId in columnInfo.linkedPropertys ){
					key = columnInfo.linkedPropertys[linkedObjectId];
					recordItem[key] = wsdataset.data[i][columnInfo.colId];
					oldRecordItem[key] = wsdataset.data[i].__STATE__.oldData[columnInfo.colId];
					key = null;
				}
				columnInfo = null;
			}
			//
			if( typeof wsdataset.data[i].__STATE__ != "undefined" ){
				recordItem.__STATE__.rowId = wsdataset.data[i].__STATE__.rowId;
				recordItem.__STATE__.updateGu = wsdataset.data[i].__STATE__.updateGu;
//				recordItem.__STATE__.oldData = JSON.parse(JSON.stringify(oldRecordItem));
				recordItem.__STATE__.oldData = oldRecordItem;
			}
		}
		
		remakeDataset.setDataArray(recordList);
		
		//메모리 해제
//		oldRecordItem = null;
		recordList.clear(); recordList = null;
		linkedObjectId = null;
		
		return remakeDataset;
	}
	else{
		//메모리 해제
		linkedObjectId = null;
		
		return wsdataset;
	}
	
	return null;
};

EasySheet.prototype._updateDataSetByLinkedObject = function( dataset ){
	// functionname : [EasySheet._updateDataSetByLinkedObject]
	// 데이터셋으로 시트 데이터를 업데이트 함, 객체에서 호출하는 함수이므로 객체 데이터는 업데이트 안함
	
	//파라메터 없을 경우 예외처리
	if( typeof dataset == "undefined" || dataset == null ){
		alert(getText(	"message_EasySheet_005", 
						"EasySheet._updateDataSetByLinkedObject() 함수의 사용이 잘못 되었습니다.\n" + 
						"  _updateDataSetByLinkedObject()"
		));
		return ;
	}
	
	//잘못된 파라메터가 전달된 경우 예외처리
	if( (typeof dataset.fieldInfos == "undefined" || !(dataset.fieldInfos instanceof Object))
		|| (typeof dataset.data == "undefined"|| !Array.isArray(dataset.data))
		|| (typeof dataset.deletedData == "undefined" || !Array.isArray(dataset.deletedData))
	){
		alert(getText("message_EasySheet_005", "EasySheet._updateDataSetByLinkedObject() 함수의 파라메터가 올바르지 않습니다.\n"));
		return ;
	}
	
	//필터 해제
	this.unfilter();
	
	//데이터 갱신
	var resultObject = this.dataSet.setDataSet(dataset);
	if( resultObject.result == false ){
		alert(resultObject.errorMsg);
		return ;
	}
	
	this.currentRow = this.startRowColNum;
	this.maxRows = dataset.getCount(); /**@ 맥스 로우 지정*/
	
	//편집 컨트롤 닫음
	this.completeEditing(false);
	//시트 메세지 박스 닫음
	this.setMessageBox(false);
	//현재 선택된 셀 또는 로우를 해제함
	this.clearSelection();
	
	// 소트칼럼 정리 
	this.sortOut(SHEET_RESET_DATA);
	
	// 그루핑 처리
	if( this.needGrouping )
		this.sumUp.resetGroup();
	
	// 화면상 시트갱신 , 데이터만 변경
	this.updateScreen(SHEET_RESET_DATA);
	
	return;
};



/**
 * @description 
 *     범위를 정하여 셀값을 채우는 명령이다.
 *     1. 블록모드를 준후 setValueToCell(value) 또는 
 *     2. 블록모드를 피하여 setValueToCell(value, rowRange, colRange)<br/>
 * 
 * @param {Number|String}								value					- 데이터
 * @param {Number|Number[]|undefined}	                [rowRange=Block Rage]	- 변경하게 될 셀영역이다. this.startRowColNum이 반영된 줄번호이다<br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. this.startRowColNum이 반영된 열번호이다<br/>
 * @param {Boolean|undefined}							[outerGu=false]			- value가 겉값을 갱신하는 경우  
 * 
 * @return {void} 

 * @example
 * // 칼럼 구간을 주어 셀값을 설정할 경우 
 * sheet.col = 1;                    // 첫번째 칼럼 부터
 * sheet.col2 = 2;                   // 두번째 칼럼까지 
 * sheet.blockMode = true;           // 블럭지정
 * sheet.setValueToCell('A');        // 1번, 2번 칼럼 전체의 칼럼값을 "A"로 부여
 * sheet.blockMode = false;          // 블럭해제    
 * 

 * // 특정칼럼을 지정할 경우 
 * sheet.setValueToCell('A', 2, 3);      		 // 2번줄 3번 칼럼값을 "A"로 부여 
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setValueToCell('A', [3. 4, 5], 3);     // 3, 4, 5번  칼럼값을 "A"로 부여
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setValueToCell('A', 2, "id");            			   // "id"  칼럼값을 "A"로 부여
 * sheet.setValueToCell('A', [3. 4, 5], ["id", "name"], true); // "id", "name"  칼럼값을 "A"로 부여
 */
EasySheet.prototype.setValueToCell = function(/* value, rowRange,  colRange,  outerGu */){
	// functionname : [EasySheet.setValueToCell]
	
	var colRange = null; var rowRange = null; var outerGu = true;
	var value = ""; var oldValue = null;
	var rowNum = 0; var rowNum0 = 0;
	var colNum = 0; var colNum0 = 0;
	var column = null; var colId = null; var data = null;
	var i = 0; var j = 0;
	var args = Array.prototype.slice.call(arguments);
	
	if( args.length == 1 ){
		if( this.blockMode ){
			rowRange = [];
			colRange = [];
			
			if( this.row == -1 ){
				for(rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++)
					rowRange.push(rowNum0 + this.startRowColNum);
			}
			else{
				for(rowNum = this.row; rowNum <= this.row2; rowNum++)
					rowRange.push(rowNum);
			}
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
			}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" + 
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.", "setValueToCell"
			));
			return;
		}
		
		value = args[0];
	}
	else if( args.length == 2 ){
		alert(getText(	"message_EasySheet_009",
						"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" + 
						"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.", "setValueToCell"
		));
		return;
	}
	else if( args.length == 3 ){
		value = args[0];
		rowRange = args[1];
		colRange = args[2];
	}
	else{
		value = args[0];
		rowRange = args[1];
		colRange = args[2];
		outerGu = args[3];
	}
	
	var colRangeObj = this.getColRange(colRange, "setValueToCell"); 
	if( colRangeObj == null )
		return;
	
	var rowRangeObj = this.getRowRange(rowRange, "setValueToCell"); 
	if( rowRangeObj == null )
		return;
	
	var targetColIds = colRangeObj.targetColIds;
	var targetColNums = colRangeObj.targetColNums;
	var targetRowNums = rowRangeObj.targetRowNums;
	
	if( typeof value == "undefined" || value == null )
		value = "";
 	// 피벗이면 데이터를 지움
 	if (this.pivot != null){  
 		// 그루핑 또는 피벗팅 칼럼이면 수정이 불가능 하다 
        for (var i = 0; i < targetColNums.length; i++){
        	var colNum = targetColNums[i];
            var colNum0 = colNum - this.startRowColNum;
            if (!this.pivot._checkIfValidColNum(colNum0)){
            	return;
            }
        }
        for  (var i = 0; i < targetRowNums.length; i++){
        	var rowNum = targetRowNums[i];
            var rowNum0 = rowNum - this.startRowColNum;
            if (!this.pivot._checkIfValidRowNum(rowNum0)){
            	return;
            }
            
        } 		
    	sheet.instantUpdateControl = false;
    	
        for  (var i = 0; i < targetRowNums.length; i++){
        	var rowNum = targetRowNums[i];
            var rowNum0 = rowNum - this.startRowColNum;
            
            for (var j = 0; j < targetColNums.length; j++){
            	var colNum = targetColNums[j];
                var colNum0 = colNum - this.startRowColNum;
                
                this.pivot.updatePivotCell(rowNum0, colNum0, value);
            }
        }    	
    	
        sheet.instantUpdateControl = true;
        this.pivot.refreshPivot();
		return;
	}
    
	for(i = 0; i < targetRowNums.length; i++){
		rowNum = targetRowNums[i];
		rowNum0 = rowNum - this.startRowColNum;
		
		if( this.rows(rowNum0).rowType == "Logical" ){
			alert(getText(	"message_EasySheet_057",
							"{0}번 줄은 집계된 줄입니다.\n값을 변경할 수 없습니다.",
							rowNum
			));
			continue;
		}
		
//		data = this.dataSet.data[rowNum0];
		data = JSON.parse(JSON.stringify(this.dataSet.data[rowNum0]));
		
		for(j = 0; j < targetColNums.length; j++){
			colId = targetColIds[j];
			colNum = targetColNums[j];
			colNum0 = colNum - this.startRowColNum;
			
			column = this.columns[colNum0];
			oldValue = data[colId];
//			oldValue = this.dataSet.getOldValue(rowNum0, colId);

			if( "" + oldValue == "" + value ) continue;

			data[colId] = value;
			this.dataSet.updateData(rowNum0, data);

			if( column.cellType == CELLTYPE_COMBOBOX ){
//				if( column.comboValueColId != "" ){
//					data[column.comboValueColId] = column.getComboValue(value);
//					
//					// 여기에 코드셀을 채우는 후속동작 
//					// 데이터셋에 한필드수정과 , 그에 따른 이벤트 필요
//				}
				var text = null;
				//
				if( typeof column.linkComboName == "string" && (column.linkComboName in controls) ){
					text = controls[column.linkComboName].textOfData(value);
				}
				else if( (typeof column.fillList == "object" && column.fillList instanceof Array) ||
						 (typeof column.fillFunction == "function")
				){
					var list = null;
					var listSize = 0;
					
					if( typeof column.fillFunction == "function" )
						 list = column.fillFunction();
					else list = column.fillList;
					
					for(r = 0, listSize = list.length; r < listSize; r++){
						if( value == list[r].value ){
							text = list[r].text; break;
						}
					}
					list = null;
				}
				else text = "";
				//
				this.dataSet.setState(rowNum0, colId + ".TEXT", text);
				//메모리 해제
				text = null;
			}
			
			// 데이터셋 처리
			if( this.linkedDataset != null ){
				var update = (typeof outerGu == "undefined") ? true : outerGu;
				if( update && typeof this._UpdateDataset != "undefined" ){
					var rowId = this.rows(rowNum).rowId;
					if( typeof rowId != "undefined" && rowId != null ){
						this._UpdateDataset(rowId, colNum);
					}
					rowId = null;
				}
			}
			
			// 사용자 이벤트 처리
			if( this.hasChangeEvent && this.FireEvent ){
				var wResult = this.fncChangeEvent(rowNum, colNum, value, oldValue);
				if( typeof(wResult)=="boolean" && !wResult ){
//					data[colId] = oldValue;
					this.dataSet.updateData(rowNum0, {colId: oldValue});
				}
			}
			
			// 산식계산 다시
			if (this.autoCalc && JSON.stringify(this._formulaRefs) !== "{}")
				this._calculateRelatedCell(rowNum, colNum);
			
			// 그루핑 처리
			if (this.needGrouping) 
				this.sumUp._UpdateColumnValueToGroup(rowNum, colId, oldValue, value);

			// 메모리 해제
			column = null; colId = null; oldValue = null;
		}
    }
	
	//
	data = null; targetRowNums = null; targetColNums = null; targetColIds = null;
	rowRangeObj = null; colRangeObj = null; rowRange = null; colRange = null; value = "";
	
	// 화면범위 내이면 Display 다시 화면상 시트갱신, 데이터만 변경 
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
	this.updateScreen();
	
	return;
};

/**@
셀에 데이터만 넣어준다.
*/
/** 
 * @deprecated since version 5.0, 폐기 
 * */
EasySheet.prototype.setDataToCell = function(value, rowNum, colNum, calcMode, outerGu){ // this.startRowColNum이 반영된 줄번호를 인자로 받는다.
	// functionname : [EasySheet.setDataToCell]
	
	this.setValueToCell(value, rowNum, colNum, outerGu);
	
	return;
	
};

/**
 * @description 
 *     범위를 정하여 셀값을 채우는 명령이다.
 *     1. 블록모드를 준후 setValue(value) 또는 
 *     2. 블록모드를 피하여 setValueT(value, rowNum, colNum)<br/>
 * 
 * @param {Number|String}		value				- 2차원 배열 데이터  
 * @param {Number|undefined}	[rowNum=currentRow]	- 변경하게 될 셀영역이다. this.startRowColNum이 반영된 줄번호이다<br/>
 * @param {Number|undefined}	[colNum=currentCol]	- 변경하게 될 셀영역이다. this.startRowColNum이 반영된 열번호이다<br/>
 * 
 * @return {void} 

 * @example
 * sheet.setValue('A');         // 현재줄, 현재 칼럼의 칼럼값을 "A"로 부여
 * sheet.setValue('A', 2);      // 2번줄, 현재 칼럼의 칼럼값을 "A"로 부여 
 * sheet.setValue('A', 2, 3);   // 2번줄 3번 칼럼값을 "A"로 부여 
 * 
 */
EasySheet.prototype.setValue = function(){   // this.startRowColNum이 반영된 줄번호를 인자로 받는다.
	// functionname : [EasySheet.setValue]
	
	// 인수는 Logical 줄,열번호이다
	// 콤보 스타일에서 인수는 Logical 줄,열번호이다
	var rowNum = this.currentRow;
	var colNum = this.currentCol;
	var value = null;
	var args = Array.prototype.slice.call(arguments);
	
	if( args.length == 1 ){
		value = args[0];
	}
	else if( args.length == 2 ){
		colNum = args[0];
		value = args[1];
	}
	else{
		rowNum = args[0];
		colNum = args[1];
		value = args[2];
	}
	
	if( this._isUnvalidRowNum(rowNum, "sheet.setValue") )
		return;
	
	var rowNum0 = rowNum - this.startRowColNum;
	var colNum0 = 0;
	var colId = null;
	
	if( typeof colNum == "string" ){
		if( this._isUnvalidColId(colNum, "sheet.setValue") )
			return undefined;
		
		colId = colNum;
		colNum0 = this.getColNum(colId);
	}
	else{
		if( this._isUnvalidColNum(colNum, "sheet.setValue") )
			return;
		
		colNum0 = colNum - this.startRowColNum;
		colId = this.getColId(colNum);			//this.startRowColNum이 반영된 줄번호를 인자로 받는다.
	}
	
	if( colId == null || typeof colNum0 == "undefined" )
		return;
	
   	// 피벗인 경우 처리 
 	if (this.pivot != null){  
 		// 그루핑 또는 피벗팅 칼럼이면 수정이 불가능 하다 
        if (!this.pivot._checkIfValidColNum(colNum0)){
        	return;
        }
        if (!this.pivot._checkIfValidRowNum(rowNum0)){
        	return;
        }
 		
        // 렌더러 오류로 임시적으로 막음
        // 셀을 모두 편집 안되게 할 것 
        // this.pivot.updatePivotCell(rowNum0, colNum0, value);
		return;
	}
	
	var record = this.dataSet.data[rowNum0];
	var oldValue = record[colId];
	var column = this.columns[colNum0];
	var cellType = column.cellType;
	
	var isNumberCell = ([CELLTYPE_NUMBER, CELLTYPE_PERCENT, CELLTYPE_INTEGER
	                     , CELLTYPE_BAR, CELLTYPE_CURRENCY, CELLTYPE_FLOAT].indexOf(cellType) >= 0);
	
	// 타입별 처리
	if( cellType == CELLTYPE_EDIT ){
		value = "" + value;	 
	}
	else if( cellType == CELLTYPE_CHECKBOX ){
		if( column.colDataType == "number" ) value = 1 * value;
		if( column.colDataType == "string" ) value = "" + value;
		if( value !== "" && value !== column.valueWhenChecked && value !== column.valueWhenUnchecked ){
			alert(getText(	"message_EasySheet_020", 
							"체크박스 셀의 값은 {0} 또는 {1} 값이 되도록 설정 되어 있습니다.\n" + 
							"{2} 값은 처리될 수 없습니다." ,
							[column.valueWhenChecked, column.valueWhenUnchecked, value]
			));
			return;
		}
	}
	else if( cellType == CELLTYPE_INTEGER ){
		value = parseInt(1 * value, 10);
	}
	else if( isNumberCell ){
		value = 1.0 * value;
	}
	
	//메모리 해제
	column = null; record = null;
	
	/**
	 * @ 대량 데이터일 경우 데이터모드로 설정 후 다시 셀모드로 변경. 속도 차이 많이남
	 */
	var oldRowNum = 0;
	var oldObjectSeq = 0;
	var objectSeq = 0;
	var i = 0;
	
	if( this.inputMode == SHEETMODE_SETCELL ){
		oldRowNum = this.currentRow;
		oldObjectSeq = (this.currentRow < 0) ? 0 : this.getRowAttribute(this.currentRow, "objectSeq"); // this.startRowColNum이 반영된 줄번호를 인자로 받음
		
		if( rowNum != this.currentRow ){
			this.currentRow = rowNum;
			objectSeq = this.getRowAttribute(rowNum, "objectSeq"); // this.startRowColNum이 반영된 줄번호를 인자로 받음
    		 
			for(i = 0; i < this.linkedObjects.length; i++)
				this.linkedObjects[i].seq = objectSeq;
		}
		 
		this.setValueToCell(value, rowNum, colNum);
    	 
		if( oldRowNum != rowNum ){
			this.currentRow = oldRowNum;
			
			for(var i = 0; i < this.linkedObjects.length; i++)
				this.linkedObjects[i].seq = oldObjectSeq;
		}
	}
	else if( this.inputMode == SHEETMODE_SETDATA ){
		this.setDataToCell(value, rowNum, colNum);
	}
	 
    // 그루핑 처리
    if (this.needGrouping){ 
        this.sumUp._UpdateColumnValueToGroup(rowNum0, colId, oldValue, value);
    }

    //??? 객체처리 코딩 점검 
    
    //메모리 해제
	oldValue = null; colId = null;
	
	return;
};

/** 
 * @deprecated since version 5.0, 칼럼정보를 sheet.setValue()으로 대체 
 * */
EasySheet.prototype.setText = function(){
	// functionname : [EasySheet.setText]
	
	var args = Array.prototype.slice.call(arguments);
	
	if( args.length == 1 ){
		value = args[0];
		this.setValue(value);
	}
	else if( args.length == 2 ){
		colNum = args[0];
		value = args[1];
		this.setValue(colNum, value);
	}
	else{
		rowNum = args[0];
		colNum = args[1];
		value = args[2];
		this.setValue(rowNum, colNum, value);
	}
	
	return;
};

/**
 * @description 
 *     칼럼 전체를 범위로 정하여 셀값을 채우는 명령이다.
 * 
 * @param {Number|undefined}	colNum	- 변경하게 될 셀영역이다. this.startRowColNum이 반영된 열번호이다<br/>
 * @param {Number|String}		value	- 2차원 배열 데이터  
 * 
 * @return {void} 

 * @example
 * sheet.setValueAll(2, 'A');         // 2번 칼럼의 칼럼값을 "A"로 부여
 * 
 */
EasySheet.prototype.setValueAll = function(colNum, value) {
	// functionname : [EasySheet.setValueAll]
	
	if( this._isUnvalidColNum(colNum, "sheet.setValueAll") )
		return;
	
	// 그룹연산처리 보류
	if( this.needGrouping )
		this.sumUp._suspand = true;
	
	var rowNum = 0;
	var rowNum0 = 0;
	
	var rowState = null;
	var oldSeqs = null;
	var linkedObjectCnt = this.linkedObjects.length;
	var i = 0;
	
	//연결 객체의 각각의 현재 Seq를 기억
	for(i = 0, oldSeqs = []; i < linkedObjectCnt; i++){
		oldSeqs[i] = this.linkedObjects[i].seq;
	}
	
	// 인수는 Logical 줄,열번호이다
	// 콤보 스타일에서 인수는 Logical 줄,열번호이다
	for(rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
		rowNum = rowNum0 + this.startRowColNum;
		rowState = this.rows(rowNum0);
		
		if( rowState.rowType == "Logical" ) continue;
		
		//시트 행의 seq로 각 객체의 seq를 변경
		for(i = 0; i < linkedObjectCnt; i++){
			this.linkedObjects[i].seq = rowState.objectSeq;
		}
		
		if( this.inputMode == SHEETMODE_SETCELL ){
			this.setValueToCell(value, rowNum, colNum);
		}
		else if( this.inputMode == SHEETMODE_SETDATA ){
			this.setDataToCell(value, rowNum, colNum);
		}
	}
	
	//이전 Seq로 복구
	for(i = 0; i < linkedObjectCnt; i++){
		this.linkedObjects[i].seq = oldSeqs[i];
	}
	
	// 그루핑 처리
    if( this.needGrouping ){ 
    	// 그룹연산 보류 해제 
		this.sumUp._suspand = false;  
    	this.sumUp.resetGroup();
    }
    
    //메모리 해제
    oldSeqs.clear(); oldSeqs = null;
};

/**
 * @description 
 *     줄 전체를 범위로 정하여 셀값을 채우는 명령이다.
 *     인수로 "1,2,3,4", [1,2,3,4], {a: 1, b: 2, c: 3, D:4} 가능
 * 
 * @param {String} 				value   -"1,2,3,4" 와 같이 문자열로 연결된 값
 * @param {Number[]|String[]}	value	- [1,2,3,4] 와 같은 배열값
 * @param {Object}				value	- {a: 1, b: 2, c: 3, D:4} 와 같이 칼럼과 값으로 구성된 객체   
 * 
 * @return {void} 

 * @example
 * sheet.setRowData({a: 1, b: 2, c: 3, D:4}); 
 * 
 */
EasySheet.prototype.setRowData = function(value){
	// functionname : [EasySheet.setRowData]
	
	var args = Array.prototype.slice.call(arguments);
	var argsCount = args.length;
	var rowNum = this.currentRow;
	var value = null;
	
	if( argsCount == 1 ){
		value = args[0];
	}
	else if( argsCount == 2 ){
		rowNum = args[0];
		value = args[1];
	}
	else{
		alert(getText(	"message_EasySheet_009",
						"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" + 
						"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.", "setRowData"
		));
		return;
	}
	
	if( rowNum < this.startRowColNum ){
		alert(getText(	"message_EasySheet_012",
						"현재 선택된 줄없이 데이터를 넣을 수 없습니다.\n" + 
						"데이터가 입룍될 줄을 먼저 선택해 주세요.\n"
		));
		return;    
	}
	
    if( typeof value == "undefined" ){
    	alert(getText(	"message_EasySheet_017",
    					"sheet.setRowData(value) 함수의 인자가 없습니다. \n" + 
    					"value 값을 넣어주세요\n"));
    	return;
    }
    
	// 피벗에는 적용되지 않음
	if( this.pivot != null ){  
		this.pivot._warnUnsupport("setRowData");
		return;
	}	
    
	var arrValues = null;
	var jsonValue = null;
	
	if( typeof value == "string" ){
		if( value.indexOf(",") < 0 )
			arrValues= [value];
		else
			arrValues = JSON.parse(escapeJSON("[" + value + "]"));
	}
	else if( Array.isArray(value) ){
		arrValues = value;
	}
	else if( typeof value == "object" ){
		jsonValue = value;
	}
	
	var rowNum0 = rowNum - this.startRowColNum;
	var colNum0 = 0;
	var colId = null;
	var data = JSON.parse(JSON.stringify(this.dataSet.data[rowNum0]));
	var oldValue = null;
	var value = null;
	var groupKeyChanged = false;
	
	if( this.needGrouping ){
		for(colNum0 = 0 ; colNum0 < this.maxCols; colNum0++){
			// 받은 값 배열크기를 초과하면 스킵한다.
			if( arrValues != null && colNum0 >= arrValues.length ) break;
			if( groupKeyChanged ) break;
			
			colId = this.columns[colNum0].colId;
			
			if( !this.sumUp._isKeyColumn(colId) ) continue;
			
			oldValue = data[colId];
			value = (arrValues != null ? arrValues[colNum0] : (jsonValue != null ? jsonValue[colId] : undefined));
			
			if( typeof value == "undefined" ) continue;
				
			groupKeyChanged = ("" + oldValue !== "" + value);
		}
	}
	
	// 그루핑 처리
	if( this.needGrouping && groupKeyChanged ) 
		this.sumUp._deleteOneRecord(rowNum0);
	
	var colNum = 0;
	var column = null;
	var colId = null;
	var oldValue = null;
	var cellType = null;
	var isNumberCell = null;
	
	for(colNum0 = 0; colNum0 < this.maxCols; colNum0++){
		// 받은 값 배열크기를 초과하면 스킵한다.
		if( arrValues != null && colNum0 >= arrValues.length ) break;
		
		colNum  = colNum0 + this.startRowColNum;
		column = this.columns[colNum0];
		colId = column.colId;
		
		if( arrValues != null )
			value = arrValues[colNum0];
 	    
		if( jsonValue != null ){
			value = jsonValue[colId];
			if( typeof value == "undefined" ) continue;
		}
		
		oldValue = data[colId];
		
 	    if( "" + oldValue == "" + value ) continue;
 	    
 	    cellType = column.cellType;
 	    isNumberCell = ([CELLTYPE_NUMBER, CELLTYPE_PERCENT, CELLTYPE_INTEGER, CELLTYPE_BAR, 
 	                    CELLTYPE_CURRENCY, CELLTYPE_FLOAT].indexOf(cellType) >= 0);
 	    
		// 타입별 처리
		if( cellType == CELLTYPE_EDIT )
			data[colId] = "" + value;
		else if( cellType == CELLTYPE_CHECKBOX )
			data[colId] = value;
		else if( cellType == CELLTYPE_INTEGER )
			data[colId] = parseInt(1 * value, 10);
		else if( isNumberCell )
			data[colId] = 1.0 * value;
		else
			data[colId] = value;
	}
	
	//
	this.dataSet.updateData(rowNum0, data);
	
	//
	isNumberCell = null; column = null; data = null; oldValue = null; value = null;
	arrValues = null; jsonValue = null;
	
	this.recalcurateRow(rowNum);
	
	// 그루핑 처리
	if( this.needGrouping ){ 
		if( groupKeyChanged ){
			this.sumUp._InsertToGroup(rowNum0);
			this.sumUp._refreshGroupCation(false);
		}
		else
			this.sumUp._RefreshGroupByOneData(rowNum0);
	}
	
	// 6단계 : 레더러 처리, 데이터만 변경 
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
	this.updateScreen();
	
	return;
};

/** 
 * @deprecated since version 5.0, 칼럼정보를 sheet.setRowData()으로 대체 
 * */
EasySheet.prototype.setValues = function(value){
	// functionname : [EasySheet.setValues]
	this.setRowData(value);
};

/**
 * @description 
 *     범위를 정하여 칼럼값을 가져오는 명령이다
 * 
 * @param {Number|undefined}	[rowNum=currentRow]	- 변경하게 될 셀영역이다. this.startRowColNum이 반영된 줄번호이다<br/>
 * @param {Number|undefined}	[colNum=currentCol]	- 변경하게 될 셀영역이다. this.startRowColNum이 반영된 열번호이다<br/>
 * 
 * @return {void} 

 * @example
 * var value = sheet.getValue();       // 현재줄, 현재 칼럼의 칼럼값을 가져옴
 * var value = sheet.getValue(2);      // 2번줄, 현재 칼럼의 칼럼값을 가져옴 
 * var value = sheet.getValue(2, 3);   // 2번줄 3번 칼럼값을 가져옴 
 * 
 */
EasySheet.prototype.getValue = function(){
	// functionname : [EasySheet.getValue]
	
	// 콤보 스타일에서 인수는 Logical 줄,열번호이다
	var args = Array.prototype.slice.call(arguments);
	var rowNum = this.currentRow;
	var rowNum0 = rowNum - this.startRowColNum;
	var colNumOrId = this.currentCol; 
	var value = null;
	
	if( args.length == 1 ){
		colNumOrId = args[0];
	}
	else if( args.length >= 2 ){
		rowNum0 = args[0] - this.startRowColNum;
		colNumOrId = args[1];
	}
	
	var colId = (typeof colNumOrId == "string") ? colNumOrId : this.getColId(colNumOrId);
	
	//예외처리
	if( this._isUnvalidColId(colId, "sheet.getValue") ){
		args = null;	//메모리 해제
		return value;
	}
	
	value = this.dataSet.data[rowNum0][colId];
	
	//만약 데이터가 null 또는 undefined 라면 빈 문자열로 수정함
	if( value == null || typeof value == "undefined" )
		value = "";
	
//    // 피벗인 경우 처리 
// 	if (this.pivot != null){  
// 		var colNum = (typeof colNumOrId == "number") ? colNumOrId : this.getColNum(colNumOrId);
// 		var colNum0 = colNum - this.startRowColNum;
//        
//		return this.pivot.getPivotValue(rowNum0, colNum0);
//	}
	
	//메모리 해제
	colNumOrId = null; args = null;
	
	return value;
};

/** 
 * @deprecated since version 5.0, 칼럼정보를 sheet.getValue()으로 대체 
 * */
EasySheet.prototype.getText = function(){
	// functionname : [EasySheet.getText]
	
	var args = Array.prototype.slice.call(arguments);
	
	if( args.length == 1 ){
		colNum = args[0];
		return this.getValue(colNum);
	}
	else{
		rowNum = args[0];
		colNum = args[1];
		return this.getValue(rowNum, colNum);
	}
	
	return null;
};

/**
 * @description 
 *     칼럼 값을 가져오는 명령이다.
 *     인수가 하나만 넘어왔을 경우 컬럼번호로 인식하고 해당 컬럼의 모든 데이터를 배열로 리턴한다.

 * @param {Number|undefined}	[rowNum=currentRow]	- 변경하게 될 셀영역이다. this.startRowColNum이 반영된 줄번호이다<br/>
 * @param {Number|undefined}	[colNum=currentCol]	- 변경하게 될 셀영역이다. this.startRowColNum이 반영된 열번호이다<br/>
 * 
 * @return {void} 

 * @example
 * var value = sheet.getColumnValue();       // 현재줄, 현재 칼럼의 칼럼값을 가져옴
 * var array = sheet.getColumnValue(2);      // 2칼럼의 칼럼값을 가져옴  결과 값이 배열로 리턴 된다.
 * var value = sheet.getColumnValue(2, 3);   // 2번줄 3번 칼럼값을 가져옴 
 * 
 */
EasySheet.prototype.getColumnValue = function(){
	// functionname : [AUIEasySheet.getValue]
	
	// 피벗에는 적용되지 않음
	if (this.pivot != null){  
		this.pivot._warnUnsupport("getColumnValue");
		return;
	}	
	
	var rowNum = this.currentRow;
	var colNum = this.currentCol;
	var args = Array.prototype.slice.call(arguments);
	var needArray = args.length == 1 ? true : false;
	
	if( args.length == 0 ){
		// 통과 
	}
	else if( args.length == 1 ){
		colNum = args[0];
	}
	else{
		rowNum = args[0];
		colNum = args[1];
	}
	
	// 콤보 스타일에서 인수는 Logical 줄,열번호이다
	var rowNum0 = 0;
	var colNum0 = colNum - this.startRowColNum;
	var colId = this.columns[colNum0].colId;
	var arrIndex = 0;
	var arrValues = null;
	var value = null;
	
	if( needArray ){
		var result = this.dataSet.getData();
		var data = result.resultData;
		var row = null;
		
		for(rowNum0 = 0, arrIndex = 0, arrValues = []; rowNum0 < this.maxRows; rowNum0++, value = null, row = null){
			row = data[rowNum0];
			value = row[colId];
			
			if( row.__STATE__.rowType == "Logical" ) continue;
			if( typeof value == "undefined" || value == null ) value = "";
			
//			arrValues[rowNum0] = value;
			arrValues[arrIndex++] = value;
		}
		
		data = null;
		result = null;
	}
	else{
		rowNum0 = rowNum - this.startRowColNum;
		
		value = this.dataSet.data[rowNum0][colId];
		
		if( typeof value == "undefined" || value == null ) value = "";
	}
	
	//메모리 해제
	args = null;
	
	return (arrValues != null ? arrValues : value);
};

/**
 * @description 
 *     인덱스에 맞는 행 데이터를 리턴한다.
 * 
 * @param {Number}	rowNum	- 시트 행 번호
 * 
 * @return {Object} 

 * @example
 * sheet.getRowData(2);	// 리턴 : {a: 1, b: 2, c: 3, D:4}
 * 
 */
EasySheet.prototype.getRowData = function(rowNum){
	// functionname : [EasySheet.getRowData]
	
	//예외처리
	if( this._isUnvalidRowNum(rowNum, "sheet.getRowData") ){
		return;
	}
    
	// 피벗에는 적용되지 않음
	if (this.pivot != null){  
		this.pivot._warnUnsupport("getRowData");
		return;
	}
	
	//행 데이터 리턴
	return JSON.parse(JSON.stringify(this.dataSet.data[rowNum - this.startRowColNum]));
};

EasySheet.prototype.toJSON = function(){
	// functionname : [EasySheet.toJSON]

	// 아래 로직은 첫칼럼부터 기계적으로 주어 담는 것으로 this.startRowColNum 반영이 필요 없다.
	var jsonStr = "{\"name\":\"" + this.controlName + "\", \"data\":[";
	var rowNum0 = 0;
	var rowNum = 0;
	var colNum0 = 0;
	var colId = null;
		
	for(rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++){
		rowNum  = rowNum0 + this.startRowColNum;
		
		if( this.isEmptyRow(rowNum) ) continue;
		
		jsonStr += (rowNum0 > 0 ? ", " : "") + "[";
		
		for(colNum0 = 0; colNum0 < this.maxCols; colNum0++){
			colId = this.columns[colNum0].colId;
			jsonStr += (colNum0 > 0 ? ", " : "") + "\"" + this.dataSet.data[rowNum0][colId] + "\"";
			colId = null;
		}
		
		jsonStr += "]";
	}
	
	jsonStr += "]}";
	
	return jsonStr;
};

EasySheet.prototype.getJsonData = function(){
	// functionname : [EasySheet.getJsonData]
	
	var wReturn = null; var list = null; var record = null;
	var dataItems = null; var dataItem = null; var dataOldItem = null;
	var column = null; var fieldId = null; var value = null;
	var dataCount = 0; var columnCount = 0;
	var i = 0; var j = 0;
	
	list = [];
	dataItems = this.dataSet.data;
	dataCount = dataItems.length;
	columnCount = this.maxCols;
	
	for(i = 0; i < dataCount; i++, updateGu = null){
		updateGu = this.dataSet.getState(i, "updateGu");
		
		//삭제된데이터 제외
		if( ["X", "E"].indexOf(updateGu) >= 0 )
			continue;
		
		dataItem = dataItems[i];
		dataOldItem = dataItem.__STATE__.oldData;
		record = {"IUDFlag" : updateGu}; //레코드 업데이트 구분 추가
		
		//레코드에 데이터 추가
		for(j = 0; j < columnCount; j++, column = null, fieldId = null, value = null){
			column = this.columns[j];
			fieldId = column.colId;
			value = dataItem[fieldId];
			
			//null, NaN, undefined 인 경우, 빈문자열로 대체
			if( value == "NaN" || value == null || typeof value == "undefined" )
				value = "";
			
			//디폴트값을 대입한 후에도 값이 ""이면 필요한 조치
			if( ("" + value).trim() == "" ){
				if( column.colDataType == "number" ) value = 0;
			}
			
			//데이터 추가
			record[fieldId] = value;
			record[fieldId + "Old"] = dataOldItem[fieldId];
		}
		
		//리스트에 추가
		list[i] = record;
		
		//메모리 해제
		record = null;
		dataOldItem = null;
		dataItem = null;
	}
	
	//메모리와 서버에서 데이터 변형 문제로 문자열로 변환
	wReturn = JSON.stringify(list);
	
	//메모리 해제
	list.clear(); list = null;
	dataItems = null;
	
	return wReturn;
};

EasySheet.prototype.getData = function(){
	// functionname : [EasySheet.getData]
	
	return JSON.parse(JSON.stringify(this.dataSet.data));
};

EasySheet.prototype.getDataForExcel = function(){
	// functionname : [EasySheet.getDataForExcel]
	
	var arrFromStrings	= [",", ":", ";", "&", "%", "?"];
	var arrToStrings	= ["<COMMA>", "<COLON>", "<SEMICOLON>", "<AMP>", "<PERCENT>", "<QUESTION>"];
	
	var generationInfo = null;
	
	//EasySheet 렌더러의 getDataForExcel 함수가 있는 경우
	if( this.sheetRenderer != null && typeof this.sheetRenderer.getDataForExcel == "function" ){
		generationInfo = this.sheetRenderer.getDataForExcel();
	}
	//EasySheet 렌더러가 있는 경우(렌더러 버전이 다르거나, 이전 데이터 시트)
	else{
		var recordList = []; var record = null; var data = null;
		var decimalList = []; var decimal = null; var pointIndex = -1;
		var column = null; var value = null;
		var dataCount = this.dataSet.data.length;
		var colCount = this.columns.length;
		var i = 0; var j = 0;
		
		//엑셀정보 초기화
		generationInfo = new xlGenerationInfo();
		generationInfo.sheetType = 0;								// EasySheet
		generationInfo.rowsNum = this.hideRowHeader ? 0 : 1;		// Row Header's Depth
		generationInfo.colsNum = this.displayInfo.rowsPerDataRow;	// Column Header's Depth
		generationInfo.rowsColors = "";
		generationInfo.colsWidth = "";
		generationInfo.align = "";		//SHEET_ALIGN_LEFT:0, SHEET_ALIGN_RIGHT:1, SHEET_ALIGN_CENTER:2
		generationInfo.data = "";
		generationInfo.decimal = "";
		
		//컬럼 사이즈
		for(i = 0; i < colCount; i++, column = null){
			column = this.columns[i];
			
			generationInfo.colsWidth += (i == 0 ? "7\t" : "\t") + Math.ceil(parseFloat(1 * ("" + column.minWidth).replace("px", "")) / 7,5);
			generationInfo.align += (i == 0 ? SHEET_ALIGN_CENTER + "\t" : "\t") + column.align;
			generationInfo.align += "\t" + (column.displayFormat !== "" ? column.displayFormat : " ");
		}
		
		//시트 행열타이틀 추가
		data = (this.hideRowHeader ? [] : [" "]);
		//시트 행열타이틀 소수점 정보 추가
		decimal = (this.hideRowHeader ? [] : [0]);
		
		//컬럼 타이틀 추가
		for(i = 0; i < colCount; i++, column = null){
			column = this.columns[i];
			//컬럼 타이틀이 비어있다면 공백으로 추가
			if( typeof column.caption == "string" && column.caption.length <= 0 ){
				data.push(" ");
				decimal.push(0);
			}
			//컬럼 타이틀 추가
			else{
				data.push(column.caption);
				decimal.push(0);
			}
		}
		
		//타이틀 추가
		recordList[0] = data.join("\t");
		//타이틀 소수점 정보 추가
		decimalList[0] = decimal.join("\t");
		
		//메모리 해제
		decimal = null;
		data = null;
		
		//시트 데이터
		for(i = 0; i < dataCount; i++, data = null, decimal = null, record = null){
			record = this.dataSet.data[i];
			//행번호 추가
			data = (this.hideRowHeader ? [] : [(i + 1)]);
			//행번호 소수점 정보 추가
			decimal = (this.hideRowHeader ? [] : [0]);
			
			//컬럼 데이터 추가
			for(j = 0; j < colCount; j++){
				column = this.columns[j];
				value = record[column.colId];
				value = (value === "" ? " " : "" + value);
				
				//데이터 추가
				data.push(value);
				//소수점 정보 추가
				if( value.isNum() ){
					pointIndex = value.lastIndexOf(".");
					decimal.push( pointIndex < 0 ? 0 : (value.length - (value.lastIndexOf(".") + 1)) );
				}
				
				//메모리 해제
				value = null; column = null;
			}
			
			//행 데이터 추가
			recordList.push(data.join("\t"));
			//소수점 정보 추가
			decimalList.push(decimal.join("\t"));
		}
		
		//엑셀데이터 추가
		generationInfo.data += recordList.join("<<%ENTER%>>");
		//엑셀 데이터의 소수점 정보 추가
		generationInfo.decimal += decimalList.join("<<%ENTER%>>");
		
		//메모리 해제
		decimalList = null;
		recordList = null;
	}
	
	return generationInfo;
};

// 인수가 1부터 시작됨 
/**
 * @description 
 *     차트그리기에 필요한 정보를 작성한다 <br/>
 *     인수가 1부터 시작됨에 주의 한다. <br/>
 *     
 *     Object[][] 형식으로 들어온 경우 setArrayData() 명령과 같다. <br/>  
 *     객페의 속성값을 기준으로 데이터가 들어가며 부족한 경우 나머지 필드는 디폴트 데이터를 채우게 된다 <br/>
 *     
 *		<table style="width: 100%">
 *			<tr bgcolor="#808080"><td>품목</td>                  <td>1M</td><td>2M</td><td>3M</td><td>4M</td><td>5M</td><td>6M</td></tr>
 *			<tr bgcolor="#FFFF00"><td bgcolor="#C0C0C0">국어</td><td>10</td><td>20</td><td>30</td><td>40</td><td>50</td><td>60</td></tr>
 *			<tr>                  <td bgcolor="#C0C0C0">영어</td><td>20</td><td>35</td><td>45</td><td>55</td><td>65</td><td>75</td></tr>
 *			<tr>                  <td bgcolor="#C0C0C0">수학</td><td>30</td><td>23</td><td>53</td><td>89</td><td>41</td><td>96</td></tr>
 *		</table>
 *		<p>&nbsp;</p>
 *		<table style="width: 100%">
 *			<tr><td bgcolor="#808080" style="width: 153px">&nbsp;&nbsp;</td><td>포인트 타이틀</td></tr>
 *			<tr><td bgcolor="#C0C0C0" style="width: 153px">&nbsp;&nbsp;</td><td>시리즈 타이들</td></tr>
 *			<tr><td bgcolor="#FFFF00" style="width: 153px">&nbsp;&nbsp;</td><td>계열값 </td></tr>
 *		</table>
 *     
 *     
 *     
 * 
 * @param {String}	graphSeries		시트 칼럼중에서 차트그리기에 필요한 데이터를 지정한다 .<br/>
 *                                  - 차트에 사용회는 칼럼은 "1", 사용되지 않는 칼럼은 "0"으로 표현한다  
 *                                  - 예제에서 1M, 2M, 3M 칼럼이 사용된다면 "0111000" 로 표현된다, 여기서 맨앞의 "0"은 1열 즉 타이틀행을 가리키므로 "0"이다
 * @param {Number}	graphTitleNum1	시트 칼럼중에서 데이터 계열의 이름을 지정하는 열을 말한다 예제에서 "품목"열을 의미하는경우 1 값이 지정된다.<br/>
 *                                  - 열번호는 첫 칸이 1부터 시작된다, 0이 아님을 주의 하여야 한다
 *                                  - 열번호 0인 경우 줄번호난의 캡션을 의미한다.  
 * @param {Number}	graphPointNum1	시트 줄중에서 X축에 표시될 데이터 값을 지정하는줄번호 이다 예제에서 첫줄에 타이틀들이 있고, 1 값이 지정된다.<br/>
 *                                  - 줄번호는 첫 줄이 1부터 시작된다, 0이 아님을 주의 하여야 한다
 *                                  - 줄번호 0인 경우 열타이틀난의 캡션을 의미한다.  
 * @param {Number}	graphDataStart1	시트 줄중에서 데이터 값을 사용하기 시작하는 줄번호 이다 예제에서 두쨰 줄부터 데이터가 있고, 2 값이 지정된다.<br/>
 *                                  - 쥴번호는 첫 줄이 1부터 시작된다, 0이 아님을 주의 하여야 한다
 * 
 * @return {String} 				문자열로 통합된 차트에 필요한 정보 

 * @example
 *  var chartData = sheet.getChartData("0111000",1, 1, 2);  // 예제의 경우
 */

EasySheet.prototype.getChartData = function(graphSeries, graphTitleNum1, graphPointNum1, graphDataStart1, graphx, graphy, graphz, graphopen, graphhigh, graphlow, graphclose, graphvolume){
    // functionname : [EasySheet.getChartData]

	// 피벗에는 적용되지 않음
	if (this.pivot != null){  
		this.pivot._warnUnsupport("getChartData");
		return;
	}	

	// 그래프 각 시리즈(예:선)의  이름으로, 
	// 디자인시 편의를 위하여  줄타이틀은 1번 칼럼값으로 강제한다. 
	if (graphTitleNum1 == 0) {
		graphTitleNum1 = 1;
	}
	
    var seriesTitle = []; 
    var pointTitle = []; 
	var chartValue = [];
	
	// 콤마 콜론등을 위험회피하기위한 함수 
	var esc = function(value){return escapeCharacter(value, ARRAY_ESCAPING_FROM_STRINGS, ARRAY_ESCAPING_TO_STRINGS)};
    
    var colIds = [];
	for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++) {  // 첫줄부터 기계적으로 주어 담는 것으로 this.startRowColNum 반영이 필요 없다.
		colIds.push(this.columns[colNum0].colId);
	}
	
    var ColumnTitles = [];
	for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++) {
		ColumnTitles.push(this.getColumnTitle(colNum0 + this.startRowColNum));
	}    
    
	for (var rowNum1 = graphDataStart1; rowNum1 <= this.maxRows; rowNum1++) { 	// graphDataStart1는 무조건 1부터 시작하는 변수이다.
		var rowNum0 = rowNum1 - 1;
    	var colNum1 = graphTitleNum1;												// graphTitleNum1는 무조건 1부터 시작하는 변수이다. 
        var colNum0 = colNum1 - 1;
    	var colId = colIds[colNum0];
    	
    	var value = this.dataSet.data[rowNum0][colId];
        seriesTitle.push(esc(value));
    }

    for (var colNum0 = 0; colNum0 < graphSeries.length; colNum0++){
    	if (graphSeries.charAt(colNum0) != "1") continue;  
    	var colId = colIds[colNum0];
        
    	var value = graphPointNum1 == 0 ? ColumnTitles[colNum0] : this.dataSet.data[graphPointNum1 - 1][colId];
    	pointTitle.push(esc(value));
    }

	for (var rowNum1 = graphDataStart1; rowNum1 <= this.maxRows; rowNum1++) {
	    var rowNum0 = rowNum1 - 1;
		var data = this.dataSet.data[rowNum0];
		
		var arr = [];
		for (var colNum0 = 0; colNum0 < graphSeries.length; colNum0++) {
	    	if (graphSeries.charAt(colNum0) != "1") continue;  // 데이터가 100100111
	    	
	    	var colId = colIds[colNum0];
	    	var value = data[colId];
	    	
	    	arr.push(typeof value == "number" ? value : esc(value));
		}
		
		// Scattle
		if (1*graphx && 1*graphy && !(1*graphz)) {
			var colId = colIds[graphx-1];
	    	var value = data[colId];
	    	arr.push(typeof value == "number" ? value : esc(value));
			
			var colId = colIds[graphy-1];
	    	var value = data[colId];
	    	arr.push(typeof value == "number" ? value : esc(value));
		}
		
		// Bubble
		else if (1*graphx && 1*graphy && 1*graphz) {
			var colId = colIds[graphx-1];
	    	var value = data[colId];
	    	arr.push(typeof value == "number" ? value : esc(value));
		
			var colId = colIds[graphy-1];
	    	var value = data[colId];
	    	arr.push(typeof value == "number" ? value : esc(value));
		
			var colId = colIds[graphz-1];
	    	var value = data[colId];
	    	arr.push(typeof value == "number" ? value : esc(value));
		}
		
		// Gantt
		else if (1*graphopen && !(1*graphhigh) && !(1*graphlow) && 1*graphclose) {
			var colId = colIds[graphopen-1];
	    	var value = data[colId];
	    	arr.push(typeof value == "number" ? value : esc(value));
						
			var colId = colIds[graphclose-1];
	    	var value = data[colId];
	    	arr.push(typeof value == "number" ? value : esc(value));
	    	
	    	if (1*graphvolume) {
				var colId = colIds[graphvolume-1];
		    	var value = data[colId];
		    	arr.push(typeof value == "number" ? value : esc(value));
			}
		}
		
		// Candle or Open-High-Low-Close
		else if (1*graphopen && 1*graphhigh && 1*graphlow && 1*graphclose) {
			var colId = colIds[graphopen-1];
	    	var value = data[colId];
	    	arr.push(typeof value == "number" ? value : esc(value));
		
			var colId = colIds[graphhigh-1];
	    	var value = data[colId];
	    	arr.push(typeof value == "number" ? value : esc(value));
		
			var colId = colIds[graphlow-1];
	    	var value = data[colId];
	    	arr.push(typeof value == "number" ? value : esc(value));
		
			var colId = colIds[graphclose-1];
	    	var value = data[colId];
	    	arr.push(typeof value == "number" ? value : esc(value));
			
			if (1*graphvolume) {
				var colId = colIds[graphvolume-1];
		    	var value = data[colId];
		    	arr.push(typeof value == "number" ? value : esc(value));
			}
		}
		
		// High-Low-Close
		else if (!(1*graphopen) && 1*graphhigh && 1*graphlow && 1*graphclose) {			
			var colId = colIds[graphhigh-1];
	    	var value = data[colId];
	    	arr.push(typeof value == "number" ? value : esc(value));
		
			var colId = colIds[graphlow-1];
	    	var value = data[colId];
	    	arr.push(typeof value == "number" ? value : esc(value));
		
			var colId = colIds[graphclose-1];
	    	var value = data[colId];
	    	arr.push(typeof value == "number" ? value : esc(value));			
		}
		
		chartValue.push(arr.join(","));
		arr.clear();
	}
	
	// ",1월,2월,3월,4월,5월,합계:"
	var wChartInfoStr = "";
	if (pointTitle.length > 0) {
		wChartInfoStr = "," + pointTitle.join(",");  // 첫칸은 비칸으로 한다
	    wChartInfoStr += ":";
	}
    
    // "김치밥,23,58,71,24,35,142:" + "참치밥,13,48,71,14,25,132:"
    for (var i = 0; i < chartValue.length ; i++){
    	wChartInfoStr += seriesTitle[i];
        wChartInfoStr += ",";
    	wChartInfoStr += chartValue[i];
        wChartInfoStr += ":";
    }
   
    pointTitle.clear();
    seriesTitle.clear();
    chartValue.clear();
    
    return wChartInfoStr;
	
};

EasySheet.prototype.setExcelData = function(jsonArrayObject, type){
	// functionname : [EasySheet.setExcelData]
	var startRow = 0;
	var startCol = 0;
	var columnOrder = null;	var order = null;	var column = null;
	var data = null;		var rowData = null;
	var recordList = null;	var record = null;	var oldRecord = null;
	var dataset = null;
	var rowCount = 0;		var colCount = 0;	var index = 0;
	var i = 0;				var j = 0;
	
	if( type == "excel" ){
		startRow = 1 * jsonArrayObject.row;
//		startRow = (1 * jsonArrayObject.row) - 1;
		startCol = 1 * jsonArrayObject.col;
		columnOrder = jsonArrayObject.columnOrder;
		data = jsonArrayObject.data;
	}
	else{
		startRow = 0;
		startCol = 0;
		data = jsonArrayObject;
	}

	// 서버데이터 분석
	if( data.length == 0 ){
		alert("엑셀로 변환된 결과값이 없습니다.");
		return;
	}
	if( data[0].length == 0 ){
		alert("엑셀로 변환된 결과값이 없습니다.");
		return;
	}
	
	// 컬럼 순서가 없는 경우 순서대로 1부터 생성
	if( columnOrder == null ){
		rowData = data[0];
		order = "";
		
		// 컬럼 순서 생성
		for(i = 1, colCount = rowData.length; i <= colCount; i++)
			order += "\"" + i + "\":" + "\"" + i + "\"";
		columnOrder = eval ("({" + order+ "})");
		
		// 메모리 해제
		rowData = null; order = null;
	}
	
	dataset = new WsDataSet();
	recordList = [];
	
	if( startRow < 0 ) startRow = 0;
	if( typeof startCol == "undefined" ) startCol = 0;
	var regExp = /^[0-9]+$/
	
	// 엑셀 데이터 생성
	for(i = startRow, rowCount = data.length; i < rowCount; i++){
		rowData = data[i];
		record = {};
		oldRecord = {};
		
		// 레코드 생성
		for(j in columnOrder){
			if( typeof j == "string" && regExp.test(j) ) j = 1 * j;
			
			if( typeof j != "number" ) continue;
			if( this.maxCols < j ) continue;
			
			index = (1 * columnOrder[j]);
			column = this.columns[j - 1];
			if( typeof column == "undefined" ){ column = null; continue; }
			if( typeof rowData[index + startCol] == "undefined" ){ column = null; continue; }
//			index = (1 * columnOrder[j]) - 1;
//			if( typeof this.columns[index] == "undefined" ) continue;
//			if( typeof rowData[j + startCol] == "undefined" ) continue;
//			if( typeof rowData[index + startCol] == "undefined" ) continue;
			
			record[column.colId] = rowData[index + startCol];
//			record[this.columns[index].colId] = rowData[j + startCol];
//			record[this.columns[index].colId] = rowData[index + startCol];
			
			oldRecord[column.colId] = (column.colDataType == "number") ? 0 : "";
			
			//메모리 해제
			column = null;
		}
		
		record["__STATE__"] = {"objectSeq": 1, "rowNum": i, "updateGu": "I", "oldData": oldRecord};
		// 레코드 추가
		recordList.push(record);
		
		// 메모리 해제
		oldRecord = null; record = null; rowData = null;
	}
	
	// 엑셀 데이터용 데이터셋 생성 및 데이터 추가
	dataset.fieldInfos = JSON.parse(JSON.stringify(this.dataSet.fieldInfos));
	dataset.setDataArray(recordList);
	// 데이터 입력
	this.setDataSet(dataset);
	
	// 데이터셋 처리 : 엑셀 업로드시 데이터셋의 레코드(버퍼 포함)의 RowType은 Insert가 되야함
	if( this.linkedDataset != null ){
		var dataset = this.linkedDataset;
		var rCount = dataset.getRowCount();
		var filterExpr = dataset.FilterExpr;
		//필터 해제
		dataset.unFilter();
		//레코드의 RowType을 Insert로 변경
		for(i = 0; i < rCount; i++){
			dataset.buffer[i].RowType = "Insert"; 
			dataset.records[i].RowType = "Insert";
		}
		//필터 적용
		dataset.filter(filterExpr);
		//메모리 해제
		filterExpr = null;
		dataset = null;
	}
	
	// 메모리 해제
	dataset = null; recordList = null; columnOrder = null;
};





/* 시트내부 함수 HARD는 사라짐 */
//데이터 넘겨줄 때와 렌더러에서 이벤트 받았을 떄마만 사용예상 
//렌더러의 줄번호는 무조건 0 부터 시작됨 , 시트줄번호는 0 또는 1로 시작 
EasySheet.prototype.rowNumOf = function(rowNum, colNum, convGu){
	// functionname : [EasySheet.rowNumOf]
	
	if( convGu == CONV_LOGICAL_SHEET ){
		var colNum0 = colNum - this.startRowColNum;
		var rowNum0 = rowNum - this.startRowColNum;
		
		var unitRow = this.columns[colNum0].sheetRow - 1 + this.displayInfo.startRow;   // sheetRow: 무조건 1부터 시작된다 
		var hiddenShtRows = this.displayInfo.startRow -1;
		
		// this.displayInfo.startRow: 첫줄의 줄순번으로 23이라면 위로 보이지 않는 물리적인 줄(TR)이 22 개 있다. (hiddenRow = 22)
		// 첫 줄의 논리번호는 base가 0이라면   23 / 2(줄단위수) -> 11.5 + 0 -> 절사 -> 논리적으로 11번째 줄이다. 
		
		// 거꾸로 
		//  base가 0이라면 논리 12번 줄은  13번째 레코드 (12 + 1 - base 0) 
		//      -> 줄단위 2를 곱하면 2번줄은 26번줄 1번줄은 25번째불이 된다  2 * (13번째 레코드 - 1) + 1, (13번째 레코드 - 1) + 2
		//      -> 숨은 줄을 제하면  25- 22,  26 - 22 -> 3번, 4번 줄이다  -> 0부터 시작하는 것으로 바꾸면 2번 3번줄이 된다.
		
		//  base가 1이라면 논리 12번 줄은  12번째 레코드 (12 + 1 - base 1)이고 이하 같다. 
		
		// 결과 ((rowNum + 1 - this.startRowColNum) - 1) * this.rowsPerDataRow + unitRow - hiddenShtRows - 1;
		// 결과 rowNum0 * this.rowsPerDataRow + unitRow - hiddenShtRows - 1;
		
		var resultRow = (this.displayInfo.rowsPerDataRow * rowNum0) + unitRow - hiddenShtRows;
		var resultRow0 = resultRow - 1;  // 0 부터 시작
		
		return resultRow0;
	}
	else if( convGu == CONV_SHEET_LOGICAL ){
		var rowNum0 = rowNum;
		return Math.ceil((this.displayInfo.startRow + rowNum0 - 1) / this.displayInfo.rowsPerDataRow) + this.startRowColNum; 
	}
	
	return 0;
};

/* 시트내부 함수    SHEET: 무조건 0부터,   LOGICAL: startRowColNum을 기준 */
EasySheet.prototype.colNumOf = function(rowNum, colNum, convGu){
	// functionname : [EasySheet.colNumOf]

	/** 논리적인 colNum 을 받아 해당 colNum의 "sheetCol"(현재바라보고 있는 실제 ColNum) 속성을 찾는다. **/
	if( convGu == CONV_LOGICAL_SHEET ){
		var colNum0 = colNum - this.startRowColNum;
		var resultCol = this.columns[colNum0].sheetCol - 1;  // .sheetCol은 무조건 1부터 시작된다.
		
		return resultCol; // 리턴하는 SHEETCOL은 무조건 0부터 시작되는 값이다
	}
	/** 0 부터 시작되는 시트 colNum 을 받아서 논리적인 colNum 을 찾는다.**/
	else if( convGu == CONV_SHEET_LOGICAL ){
		var rowNum1 = rowNum + 1;
		rowNum1 = rowNum1 % this.displayInfo.rowsPerDataRow;
		
		if( rowNum1 == 0 ) rowNum1 = this.displayInfo.rowsPerDataRow;
		
		var colNum1 = colNum + 1;
		for( var colNum0 = 1; colNum0 < this.columns.length; colNum0++){
			if( this.columns[colNum0].sheetCol == colNum1 && this.columns[colNum0].sheetRow == rowNum1 ){
				var resultCol = colNum0 + this.startRowColNum;
				return resultCol;
			}
		}
	}
	
	return 0;
};

//Logical 좌표를 받아 물리적인 셀을 리턴한다
//EasySheet.prototype.cellOf = function(rowNum, colNum){
// // functionname : [EasySheet.cellOf]
//}

//하단셀의 Logical 좌표를 받아 물리적인 셀을 리턴한다
//EasySheet.prototype.bottomCellOf = function(rowNum, colNum){
////functionname : [EasySheet.bottomCellOf]
//}

//시트동작 메서드 선언부 (Logical)
//EasySheet.prototype.setBlock = function(rowNum, colNum, rowNum2, colNum2){
// // functionname : [EasySheet.setBlock]
//};

//EasySheet.prototype.releaseBlock = function(){
// // functionname : [EasySheet.releaseBlock]
//};

/**
 * @description 
 *    시트의 칼럼수를 변경한다 <br/>
 *     
 *     - MultiLine Sheet는 RunTime 중에 칼럼수를 변경시킬 수 없다.<br/>  
 *     - 이함수는 시글라인 시트인 경우에만 적용된다<br/>  
 *     - 현재의 칼럼수 보다 칼럼수를 더 증가시킬 경우 칼럼이 추가된다   <br/>  
 *     - 현재의 칼럼수 보다 칼럼수를 더 감소시킬 경우 칼럼이 감소되고 데이터가 제외된다 <br/>
 * 
 * @param {Number}		colCount						- 변경된 후 칼럼 숫자
 * @param {String[]}	[colIds=Array with "fn" ...]	- 추가된 칼럼정보<br/>예: ["col3", "col4"]
 * 
 * @return {void}

 * @example
 * sheet.setMaxCols(10); // 칼럼수를 10개로 지정
 * sheet.setMaxCols(10, ["col3", "col4"]); // 칼럼수를 10개로 지정, 
 *                                         // 추가된 두 칼럼의 칼럼 ID는 "col3", "col4"
 */
EasySheet.prototype.setMaxCols = function(colCount, colIds){
	// functionname : [EasySheet.setMaxCols]
	
	// rowsPerDataRow = 1 일때만 작동한다
	if( this.displayInfo.rowsPerDataRow > 1 ){
		alert(getText(	"message_EasySheet_006", 
						"EasySheet.setMaxCols() 함수의 사용이 잘못 되었습니다.\n" + 
						"  싱글라인 데이터 시트에서만 가능합니다.\n" + 
						"  '{0}' 줄의 멀티라인 으로 설정된 시트입니다.",
						this.displayInfo.rowsPerDataRow
		));
		return;
	}
	
	// 우측 고정열이 있을 경우는 컬럼수 조작 불가
	if( this.displayInfo.rightFrozens > 0 ){
		alert(getText(	"message_EasySheet_007", 
						"EasySheet.setMaxCols() 함수의 사용이 잘못 되었습니다.\n" + 
						"  우측 고정 셀이 '{0}' 줄 설정되어 있습니다.\n" + 
						" 우측으로 칼럼 수를 변경할 수 없습니다.",
						this.displayInfo.rightFrozens
		));
		return;
	}
	
	// 좌측 고정열이 있을 경우는 그 이하로 컬럼수 조작 불가
	if( colCount < this.displayInfo.leftFrozens ){
		alert(getText(	"message_EasySheet_008",
						"EasySheet.setMaxCols() 함수의 사용이 잘못 되었습니다.\n" + 
						" 좌측 고정 셀이 '{0}' 줄 설정되어 있습니다.\n" + 
						" 그 이하로 칼럼 수를 변경할 수 없습니다.",
						this.displayInfo.rightFrozens
		));
		return;
	}
	
    if( this.maxCols == colCount )
    	return;
	
	// 산식 계산의 과부하를 줄인다
    var colNum0 = 0;
    var colIndex = 0;
	var autoCalcurate = this.autoCalc;
	this.autoCalc = false;
	
	if(this.maxCols > colCount){
		// 데이터셋 조절
		for(colNum0 = this.maxCols - 1; colNum0 > colCount - 1; colNum0--){			// 0번 부터 시작되는 colNum
			//시트 컬럼 제거
			this.columns[colNum0] = null;
			this.columns.pop();
			//렌더러 컬럼 제거
			this.sheetRenderer.delColumn(colNum0);
		}
    }
	else if( this.maxCols < colCount ){
		// 데이터셋 조절
		for(colNum0 = this.maxCols, colIndex = 0; colNum0 < colCount; colNum0++){	// 0번 부터 시작되는 colNum
			if( typeof colIds != "undefined" )
				this.addColumn(colNum0, colIds[colIndex++]);
			else
				this.addColumn();
		}
	}
	
	this.maxCols = colCount;
	
	// 산식을 정비한다
	this.refreshFormulaRefs();
	this.autoCalc = autoCalcurate;
	
	// 그루핑 처리
	if( this.needGrouping )
		this.sumUp.resetGroup();
	
	return;
};

/**
 * @description 
 *    시트의 레코드수를 변경한다.  <br/>
 *     
 *     - 최대줄수는 절대로 고정 줄수보다 작을 수 없다
 *     - objectSeq는 데이터 순번으로 선택항목이다<br/>  
 *     - 현재의 레코드수 보다 레코드수를 더 증가시킬 경우 추가된 줄수 만큼 빈 레코드가 추가된다   <br/>  
 *     - 현재의 레코드수 보다 레코드수를 더 감소시킬 경우 레코드수가 감소되고 데이터가 제외된다 <br/>
 * 
 * @param {Number}	rows	- 변경된 후 라인 숫자, 두줄 MultiLine인 경우에 한라인을 추가하면 화면에는 두줄이 추가된 것으로 보이게 된다
 * 
 * @return {void} 	
 * 		
 * @example
 * sheet.setMaxCols(10); // 칼럼수를 10개로 지정
 */
EasySheet.prototype.setMaxRows = function(rows){
	// functionname : [EasySheet.setMaxRows]

	// 피벗에는 적용되지 않음
	if (this.pivot != null){  
		this.pivot._warnUnsupport("setMaxRows");
		return;
	}	

	if( rows <= 0 ){
		alert(getText(	"message_EasySheet_043",  
						"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" + 
						"0보다 큰 줄수를 지정해 주십시오.",
						"setMaxRows"
		));
		return;
	}

	var linkedObejctCount = this.linkedObjects.length;
	var rowNum0 = 0;
	var colNum0 = 0;
	var objectSeq = 0;
	var i = 0;
//	this.autoCalc = false;
	
	if( this.maxRows > rows ){
		for(rowNum0 = this.maxRows - 1; rowNum0 > rows - 1; rowNum0--){
			objectSeq = this.rows(rowNum0).objectSeq;
			this.dataSet.deleteData(rowNum0);
			
			// 연결된 객체 갱신
			if( linkedObejctCount > 0){
				for(i = 0; i < linkedObejctCount; i++){
					this.linkedObjects[i].deleteSeq(objectSeq);
				}
			}
		}
		
		this.maxRows = rows;
	}
	else if( this.maxRows < rows ){
		var data = null;
		var column = null;
		
		for(rowNum0 = this.maxRows; rowNum0 < rows; rowNum0++){
			this.dataSet.insertData(rowNum0);
			this.maxRows++;
			this.dataSet.setState(rowNum0, "rowNum", this.maxRows);
			
			data = [];
			for(colNum0 = 0; colNum0 < this.maxCols; colNum0++, column = null){
				column = this.columns[colNum0];
				
				if( column["defaultValue"] != null && typeof column["defaultValue"] != "undefined" )
					data[column.colId] = (typeof column.defaultValue == "function") ? column.defaultValue() : column.defaultValue;
			}
			
			this.dataSet.updateData(rowNum0, data);
			
			//연결된 객체 갱신
			if( linkedObejctCount > 0 ){
				for(i = 0, objectSeq = 0; i < linkedObejctCount; i++){
					objectSeq = this.linkedObjects[i].addNewData();
					
					if( objectSeq > 0 ) this.dataSet.setState(rowNum0, "objectSeq", objectSeq);
				}
			}
			
			// 메모리 해제
			column = null; data = null;
		}
	}
	
	// 산식정비
	if( this.autoCalc && JSON.stringify(this._formulaRefs) !== "{}" )
		this.refreshFormulaRefs();
	
	// 그루핑 처리
	if( this.needGrouping )
		this.sumUp.resetGroup();
	
	// 화면상 시트갱신 데이터만 생신
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
	this.updateScreen();
	
	return;
};

/**
 * @description 
 *    시트에 레코드를 추가한다.  <br/>
 *     
 *     - 선택한 레코드 뒤로 줄이 추가된다. rowNum이 생략된다면 마지막 레코드 다음에 추가된다<br/>  
 *     - 현재의 레코드수 보다 레코드수를 더 증가시킬 경우 추가된 줄 수 만큼 빈 레코드가 추가된다   <br/>  
 *     - 단순히 데이터만 추가하고 시트를 갱신하거나, 이벤트를 일으킬 필요가 없는 경우 이함수를 사용하지 않고, 데이터 셋을 갱신한다. <br/>  
 *     - 데이터가 추가된 후 AddRow 이벤트가 발생한다 <br/>  
 * 
 * @param {Number}	[rowNum=last Row]	- 변경된 후 라인 숫자,<br/> 
 *                                        두줄 MultiLine인 경우에 한라인을 추가하면 화면에는 두줄이 추가된 것으로 보이게 된다.<br/>
 *                                        this.startRowColNum이 반영된 줄번호이다
 * 
 * @return {void} 
 * 			
 * @example
 * sheet.addRow(); 					// 시트 마지막에 레코드 추가
 * sheet.addRow(1); 				// 1번줄 다음에 레코드 추가
 */
EasySheet.prototype.addRow = function(rowNum){ 
	// functionname : [EasySheet.addRow]
	// 주의: 기존 사용방법 addRow(rowNum, updateSheet) 에서 updateSheet 을 제거했음

	// 피벗에는 적용되지 않음
	if (this.pivot != null){  
		this.pivot._warnUnsupport("addRow");
		return;
	}	
	
	var maxRowNum = this.maxRows - 1 + this.startRowColNum;			// 0 Base 줄번호로 변경
	var rowNum0 = 0;
	var newRowNum = 0;	// 현재줄에 하나 더한 것 
	var record = null;
	var colNum = null;
	var column = null;
	var colId = null;
	var value = null;
	var oldRowNum = null;
	var resultObject = null;
	
	var rowType = null;
	var refRowNum0 = null;
	var refRecord = null;
	var refGroupKeyValue = null;
	var oldUpdateControl = null;
	
//	maxRowNum = (maxRowNum < 0) ? 0 : maxRowNum;
	rowNum = (typeof rowNum == "undefined") ? maxRowNum : rowNum;	// 0 Base 줄번호로 변경
	rowNum0 = rowNum - this.startRowColNum;							// 0 Base 줄번호로 변경

	//예외처리
	if( this.needGrouping ){ 
		if( !this.sumUp._canAddRow(rowNum0) ){
			alert(getText(	"message_EasySheet_058",  
							"EasySheet.addRow({0}) 함수의 사용이 잘못 되었습니다.\n" + 
							"줄을 추가할 수 없는 집계줄 번호입니다.",
							rowNum
			));
			return;
		}
	}
	if( rowNum != maxRowNum && this._isUnvalidRowNum(rowNum, "sheet.addRow") ){
		return;		
	}
	
	oldRowNum = this.currentRow;
	newRowNum = rowNum + 1;	// 현재줄에 하나 더한 것 
	newRowNum0 = rowNum0 + 1;
	record = {};
	
	if( this.needGrouping ){
		rowType = this.rows(rowNum0).rowType;
		refRowNum0 = (typeof rowType != "undefined" && rowType == "Logical") ? rowNum0 + 1 : rowNum0;
//		refRowNum0 = rowNum0;
//		rowType = this.rows(refRowNum0).rowType;
//		while(rowType === "Logical"){
//			rowType = null;
//			rowType = this.rows(--refRowNum0).rowType;
//		}
		refRecord = this.dataSet.data[refRowNum0];
		refGroupKeyValue = this.rows(refRowNum0)._jsonGroupKeyValue;
	}
	
	oldUpdateControl = this.instantUpdateControl;
	
	//새 레코드 추가
	resultObject = this.dataSet.insertData(newRowNum0);
	//레코드/행 수 증가
	this.maxRows++;
	//레코드 행 번호 설정
	this.dataSet.setState(resultObject.recordIndex, "rowNum", this.maxRows);
	
	//데이터셋 처리
	if( this.linkedDataset != null ){
		var args = Array.prototype.slice.call(arguments);
		var update = true;
		if( args.length >= 3 ){
			update = args[2];
		}
		if( (typeof update == "undefined" || update) && typeof this._UpdateDatasetAddRow != "undefined" ){
			if( newRowNum >= 0 ) this._UpdateDatasetAddRow(newRowNum);
		}
		update = null;
		args = null;
	}
	
	//레코드 추가 이벤트 호출
	if( this.inputMode == SHEETMODE_SETCELL ){
		if( this.hasAddRowEvent && this.FireEvent ){
			this.currentRow = newRowNum;	// 현재줄에 하나 더한 것 
			this.fncAddRowEvent(newRowNum);
			this.currentRow = oldRowNum;
		}
	}
	
	//기본값 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//기본값 세팅
	for(colNum0 = 0; colNum0 < this.maxCols; colNum0++){
		column = this.columns[colNum0];
		colId = column.colId;
		value = record[colId];
		
		if( value == null || typeof value == "undefined" || (typeof value == "string" && value.length <= 0) ){
			if( column["defaultValue"] != null && typeof column["defaultValue"] != "undefined" ){
				//기본값으로 산식을 사용한 경우를 위해 임시로 현재행 새 레코드 행번호로 설정
				this.currentRow = newRowNum;
				//기본값 계산
				value = record[colId] = (typeof column.defaultValue == "function") ? column.defaultValue() : column.defaultValue;
				//임시로 변경한 현재 행 인덱스 복구
				this.currentRow = oldRowNum;
				
				this.setValue(newRowNum, colId, value);
			}
		}
		
		if( this.needGrouping ){
			if( this.sumUp._isKeyColumn(colId) ) record[colId] = refRecord[colId];
		}
		
		value = null; colId = null; column = null;
	}
	//레코드에 기본값 갱신
	this.dataSet.updateData(newRowNum0, record);
	
	//기본값 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//그룹핑 정보 설정
	if( this.needGrouping ){ 
		var row = this.rows(newRowNum);
		row._jsonGroupKeyValue = refGroupKeyValue;
		row._rowLevel = 0;
		row = null;
	}
	
//	this.setCurrentRow(newRowNum);
	
	// 추가된 셀을 참조하는 산식 수정  
	this._updateFormulaWhenRowInsertAfter(rowNum);
	
	// 산식재정비 
	if( this.autoCalc && JSON.stringify(this._formulaRefs) !== "{}" )
		this.refreshFormulaRefs();
	
	// 그루핑 처리
	if( this.needGrouping )
		this.sumUp._InsertToGroup(newRowNum0);
	
	// 화면상 시트갱신, 데이터만 갱신  
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
	this.updateScreen();
	
	//메모리 해제
	refGroupKeyValue = null; refRecord = null; rowType = null;
	column = null; record = null; resultObject = null;
	
	return newRowNum;
};

/** 
 * @deprecated since version 5.0, 칼럼정보를 sheet.addRow()으로 대체 
 * */
EasySheet.prototype.increaseRow = function(rowNum){
	this.addRow(rowNum);
};

EasySheet.prototype.addRows = function(rows){
	// functionname : [EasySheet.addRows]
	
	if( rows <= 0 ){
		alert(getText(	"message_EasySheet_043",  
						"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" + 
						"0보다 큰 줄수를 지정해 주십시오.",
						"setMaxRows"
		));
		return;
	}
	
	var wRow = this.maxRows - 1 + this.startRowColNum;	// 0 Base 줄번호로 변경
	var lastRoNum = wRow;
	
	while(wRow > (this.startRowColNum - 1) && this.isEmptyRow(wRow))
		wRow--;

	wRow = wRow + 1 - this.startRowColNum;
	
	this.setMaxRows(wRow + rows);
	
	return ++lastRoNum;
};

/**
 * @description 
 *    지정줄 삭제 (rowNum 위치의 레코드를 삭제한다)  <br/>
 *     
 *     - 선택한 줄의 레코드가 추가된다. prowNum가 생략된다면 마지막 레코드가 삭제된다<br/>  
 *     - 단순히 데이터만 추가하고 시트를 갱신하거나, 이벤트를 일으킬 필요가 없는 경우, 이함수를 사용하지 않고, 데이터 셋을 갱신한다. <br/>  
 *     - 레코드가 삭제되기 전 DelRow 이벤트가 발생한다 <br/>  
 *     - 레코드가 삭제된 후 현재 줄 위치에 새로 자리한 레코드로 포커스가 이동하며, 마지막줄이 삭제된 경우 한줄의의 레코드로 포커스가 이동한다.<br/> 이동후에 RowChange 이벤트가 발생한다 <br/>  
 *     <br/>
 *     - 레코드가 한줄인 상태라면 삭제시 현재줄이 Clear 되고 레코드는 초기화 된다. <br/>
 *     - 이때는 AddRow 이벤트와 RowChange 이벤트가 순차적으로 발생된다.<br/>
 * 
 * @param {Number}	[rowNum=current Row] 	- 변경된 후 라인 숫자,<br/> 
 *                                          두줄 MultiLine인 경우에 한라인을 추가하면 화면에는 두줄이 추가된 것으로 보이게 된다.<br/>
 *                                          this.startRowColNum이 반영된 줄번호이다
 * 
 * @return {void} 	
 * 		
 * @example
 * sheet.delRow();  // 현재 포커싱된 레코드 삭제
 * sheet.delRow(1); // 1번줄 레코드 삭제
 */
EasySheet.prototype.delRow = function(rowNum){
	// functionname : [EasySheet.delRow]
	// 주의: 기존 사용방법 delRow(rowNum, noDecoration) 에서 noDecoration 을 제거했음
	
	// 피벗에는 적용되지 않음
	if (this.pivot != null){  
		this.pivot._warnUnsupport("delRow");
		return;
	}	
	
	if( this.maxRows == 0 )	// 이론상 MaxRows 0은 있을 수없다.
		return;
	
	// Logical한 삭제위치
	rowNum = (typeof rowNum == "undefined" ? this.currentRow : rowNum);
	
	if( this._isUnvalidRowNum(rowNum, "sheet.delRow") )
		return;
	
	var rowNum0 = rowNum - this.startRowColNum;
	var rowId = this.rows(rowNum).rowId;
	var approved = false;
	
	if( this.needGrouping ){ 
		if( this.sumUp._isLogicalRow(rowNum0) ){
			alert(getText(	"message_EasySheet_059",  
							"EasySheet.delRow({0}) 함수의 사용이 잘못 되었습니다.\n" + 
							"줄을 삭제할 수 없는 집계줄 번호입니다.",
							rowNum
			));
			return;
		}
	}
	
	// 데이터셋 처리
	if( this.linkedDataset != null ){
		var args = Array.prototype.slice.call(arguments);
		var update = (args.length < 3) ? true : args[2];
		if( (typeof update == "undefined" || update) && typeof this._UpdateDatasetDelRow != "undefined" ){
			var rowId = this.rows(rowNum).rowId;
			if( typeof rowId != "undefined" && rowId != null ){
				this._UpdateDatasetDelRow(rowId);
			}
			rowId = null;
		}
		update = null; args = null;
	}
	
    // 이벤트단계 : 객체.줄삭제
	if( this.hasDelRowEvent && this.FireEvent ){
		approved = this.fncDelRowEvent(rowNum);
		
    	if( typeof approved == "boolean" && !approved ){
			approved = null; //메모리 해제
			return;
    	}
	}
	
	// 한줄인 경우 비우기 만한다
	if( this.maxRows == 1 ){
		// 데이터셋 처리
		if( this.linkedDataset != null ){
			var rowCount = this.linkedDataset.getRowCount();
			//데이터셋 레코드가 남은 경우 레코드 삭제
			if( rowCount == 1 && typeof this._UpdateDatasetDelRow != "undefined" ){
				var rowId = this.rows(rowNum).rowId;
				if( typeof rowId != "undefined" && rowId != null )
					this._UpdateDatasetDelRow(rowId);
				rowId = null;
			}
			//시트는 기본적으로 1행은 기본적으로 남아있어야 하므로 1행 추가함
			if( typeof this._UpdateDatasetAddRow != "undefined" ){
				this._UpdateDatasetAddRow(this.startRowColNum);
			}
		}
		
		//행을 비운 후 1행 추가 이벤트 호출
		if( this.hasAddRowEvent && this.FireEvent ){
			this.fncAddRowEvent(this.startRowColNum);
		}
		
		this.currentRow = this.startRowColNum - 1;
		
		this.clearRow(this.startRowColNum);
		
		//행을 첫번째 행으로 이동 이벤트 호출
		if( this.hasRowChangeEvent && !this.inClearMode ){
			this.fncRowChangeEvent(this.currentRow, this.startRowColNum, this.rows(this.startRowColNum).objectSeq);
		}
		
		return;
	}
	
	// 그루핑 처리
	if( this.needGrouping ){
		this.sumUp._deleteOneRecord(rowNum0); // data는 삭제된 정보 
	}
	
	var recordRowNum = this.dataSet.getState(rowNum0, "rowNum");
	
	this.dataSet.deleteData(rowNum0);
	this.maxRows--;
	
	for(var i = rowNum0; i < this.maxRows; i++){
		if( this.dataSet.getState(rowNum0, "rowType") === "Logical" ) continue;
		this.dataSet.setState(i, "rowNum", recordRowNum++);
	}
	
	if( this.currentRow > this.maxRows - 1 + this.startRowColNum ){
		this.setCurrentRow(this.maxRows - 1 + this.startRowColNum);
	}
	
	if( rowNum0 == this.sheetRenderer.selectedRowIndex ){
		//현재 선택된 셀 또는 로우를 해제함
		this.clearSelection();
	}
	
	// 추가된 셀을 참조하는 산식 수정  
	this._updateFormulaWhenRowDeleteAt(rowNum);
	
	// 산식재정비
	if( rowNum <= this.maxRows ){
		if( this.autoCalc && JSON.stringify(this._formulaRefs) !== "{}" )
			this.refreshFormulaRefs();
	}
	
	// 화면상 시트갱신 , 데이터만 생신 
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
	this.updateScreen();
	
	// 삭제후 객체 포커스 이동
	if( rowNum0 > this.maxRows - 1 + this.startRowColNum ){
		rowNum = this.maxRows - 1 + this.startRowColNum;
	}
	// 삭제후 객체 포커스 이동 이벤트 처리
	if( this.hasRowChangeEvent && !this.inClearMode ){
		this.fncRowChangeEvent(rowNum, rowNum, this.rows(rowNum).objectSeq);
	}
	
	return;
};

/** 
 * @deprecated since version 5.0, 칼럼정보를 sheet.delRow()으로 대체 
 * */
EasySheet.prototype.removeRow = function(rowNum){
	// functionname : [EasySheet.removeRow]
	this.delRow(rowNum);
};

EasySheet.prototype.clearRow = function(rowNum){
	// functionname : [EasySheet.clearRow]
	
	// 피벗에는 적용되지 않음
	if (this.pivot != null){  
		this.pivot._warnUnsupport("clearRow");
		return;
	}	
	
	if( this._isUnvalidRowNum(rowNum, "sheet.clearRow") )
		return;
	
	var rowNum0 = rowNum - this.startRowColNum;
	
	// 클리어 되는 동안 산식연산을 막고
	var oldRowNum = -1;
	var colNum0 = null;
	var colNum = null;
	var row = null;
	var record = null;
	var column = null;
	var value = null;
	
	record = this.dataSet.data[rowNum0];
	
	// 행을 비움
	if( record != null && typeof record != "undefined" && typeof record == "object" ){
		for(var key in record){
			if( key == "__STATE__" ) continue;
			//데이터 삭제
			record[key] = (typeof record[key] == "number") ? 0 : "";
			//콤보의 경우 표시값 삭제
			if( typeof record.__STATE__[key + ".TEXT"] != "undefined" ){
				delete record.__STATE__[key + ".TEXT"];
			}
		}
	}
	
	row = this.rows(rowNum);
	
	// 행의 상태정보를 초기화 함
	if( row != null && typeof row == "undefined" && typeof row == "object" ){
		row.updateGu = "X";
		row.rowNum = 1;
	}
	
	// 메모리 해제
	oldRecord = null; row = null;

	for(colNum0 = 0; colNum0 < this.maxCols; colNum0++){
		colNum = colNum0 + this.startRowColNum;
		column = this.columns[colNum0];

		// 컬럼의 기본값이 있다면 시트에 기본값을 설정(입력)하여 이벤트를 일으키면서 레코드의 업데이트 구분을 갱신
		if( column.defaultValue != null && typeof column.defaultValue != "undefined" ){
			//기본값 구함
			oldRowNum = this.currentRow;
			this.currentRow = rowNum;
			value = (typeof column.defaultValue == "function" ? column.defaultValue() : column.defaultValue);
			this.currentRow = oldRowNum;
			
			//기본값 설정
			this.setValue(rowNum, colNum, value);
		}
		
		// 메모리 해제
		column = null; colNum1 = null;
	}

	this.recalcurateRow(rowNum);

	// 그루핑 처리
	if (this.needGrouping)
		this.sumUp._RefreshGroupByOneData(rowNum0);
	
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
	this.updateScreen();
	
	return;
};

/** 
 * @deprecated since version 5.0, clearRow()로 이동 
 * */
EasySheet.prototype.clearCurrentSeq = function(){
    this.clearRow(this.currentRow);
};

EasySheet.prototype.isEmptyRow = function(rowNum) {
	// functionname : [EasySheet.isEmptyRow]
	
	if( this._isUnvalidRowNum(rowNum, "sheet.isEmptyRow") )
		return;
	
	var rowNum0 = 0; var colNum0 = 0;
	var data = null; var value = null;
	var column = null; var cellType = null;
	var isEmpty = true;
	var isNumberCell = false;
	var hasLinkedObject = false;
	
	hasLinkedObject = (this.sheetType == SHEETTYPE_DATASHEET && this.linkedObjects.length > 0)
	rowNum0 = rowNum - this.startRowColNum;
	data = this.dataSet.data[rowNum0];	

	for(colNum0 = 0; colNum0 < this.columns.length && isEmpty; colNum0++){
		column = this.columns[colNum0];
		cellType = column.cellType;
		value = data[column.colId];
		isNumberCell = ([CELLTYPE_NUMBER, CELLTYPE_PERCENT, CELLTYPE_INTEGER, CELLTYPE_BAR	// 마스크 타입일때, 숫자필드일때 value 값 처리
		                 , CELLTYPE_CURRENCY, CELLTYPE_FLOAT].indexOf(cellType) >= 0);
		
		// 타입별 처리
		if( typeof value == "undefined" || value == null || value == "" ){
			isEmpty = isEmpty && true;
		}
		else if( column.defaultValue != null && typeof column.defaultValue != "undefined" ){
			isEmpty = isEmpty && (value == (typeof column.defaultValue == "function" ? column.defaultValue() : column.defaultValue));
		}
		else if( hasLinkedObject ){
			var linkedObjects = this.linkedObjects;
			var linkedObject = null;
			var linkedPropertys = column.linkedPropertys;
			var linkedObjectCount = linkedObjects.length;
			var defaultAttribute = null;
			var defaultValue = null;
			
			for(i = 0; i < linkedObjectCount && isEmpty; i++, linkedObject = null, defaultAttribute = null, defaultValue = null){
				linkedObject = linkedObjects[i];
				defaultAttribute = linkedObject.propertyInfosById[linkedPropertys[linkedObject.id]].defaultValue;
				
				if( typeof defaultAttribute == "function" ){
					defaultValue = "" + defaultAttribute();
				}
				else{
					defaultValue = "" + defaultAttribute;
				}
				
				isEmpty = isEmpty && (("" + value) == defaultValue);
			}
			
			//메모리 해제
			linkedPropertys = null; linkedObjects = null;
		}
		else if( cellType == CELLTYPE_CHECKBOX ){
			isEmpty = isEmpty && (("" + value) == ("" + column.valueWhenUnchecked));
		}
		else if( cellType == CELLTYPE_INTEGER ){
			isEmpty = isEmpty && (0 == parseInt(1 * value, 10));
		}
		else if( isNumberCell ){
			isEmpty = isEmpty && (0 == parseFloat(1.0 * value, 10));
		}
		else{
			isEmpty = false; 
		}
		
		//메모리 해제
		value = null; cellType = null; column = null;
		
		if( !isEmpty ) break;
	}
	
	//메모리 해제
	data = null;
	
	return isEmpty;
};

EasySheet.prototype.upRow = function(){
	// functionname : [EasySheet.upRow]

	// 피벗에는 적용되지 않음
	if (this.pivot != null){  
		this.pivot._warnUnsupport("upRow");
		return;
	}	
	
	var msg = null;
	var _datas = null;
	var rowNum = 0;
	var rowNum0 = 0;
	
	// 그룹관련 처리
	if( this.needGrouping ){
		msg = getText("message_EasySheet_056", "그룹핑이 된 경우에는 {0}동작을 호출할 수  없습니다.", "sheet.upRow");
		
		alert(msg);
		console.warn(msg);
		msg = null;
		
		return;
	}
	
	rowNum = this.currentRow;
	rowNum0 = rowNum - this.startRowColNum;
	
	if( this.maxRows <= 1 || rowNum <= this.startRowColNum )
		return;
	
	// Data의 이동
	_datas = this.dataSet.data.splice(rowNum0, 1);
	this.dataSet.data.splice(rowNum0 - 1, 0, _datas[0]);
	this.currentRow--;
	rowNum0--;
	
	if( !this.sheetRenderer.setSelectedRowIndex(rowNum0) ){
		this.currentRow = rowNum;
		//메모리 해제
		oldRowNum = null; _datas = null;
		return;
	}
	
	// 데이터셋 처리
	if( this.linkedDataset != null && typeof this._UpdateDatasetUpRow != "undefined" ){
		if( this.currentRow > 0 ) this._UpdateDatasetUpRow(this.currentRow);
	}
	
	// 추가된 셀을 참조하는 산식 수정
	this._updateFormulaWhenRowMove(rowNum - 1, rowNum);

	// 산식재정비
	if( this.autoCalc && JSON.stringify(this._formulaRefs) !== "{}" )
		this.refreshFormulaRefs();
	
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
	this.updateScreen();
	
	//메모리 해제
	_datas = null;
	
	return;
};

EasySheet.prototype.downRow = function(){
	// functionname : [EasySheet.downRow]
	
	// 피벗에는 적용되지 않음
	if (this.pivot != null){  
		this.pivot._warnUnsupport("downRow");
		return;
	}	

	var msg = null;
	var _datas = null;
	var rowNum = 0;
	var rowNum0 = 0;
	
	// 그룹관련 처리
	if( this.needGrouping ){
		msg = getText("message_EasySheet_056", "그룹핑이 된 경우에는 {0}동작을 호출할 수  없습니다.", "sheet.downRow");
		
		alert(msg);
		console.warn(msg);
		
		return;
	}
	
	rowNum = this.currentRow;
	rowNum0 = rowNum - this.startRowColNum;
	
	if( this.maxRows <= this.startRowColNum || rowNum0 + 1 == this.maxRows )
		return;
	
	// Data의 이동
	_datas = this.dataSet.data.splice(rowNum0 + 1, 1);
	this.dataSet.data.splice(rowNum0, 0, _datas[0]);
	this.currentRow++;
	rowNum0++;

	if( !this.sheetRenderer.setSelectedRowIndex(rowNum0) ){
		this.currentRow = oldRowNum;
		//메모리 해제
		_datas = null;
		return;
	}
	
	// 데이터셋 처리
	if( this.linkedDataset != null && typeof this._UpdateDatasetDownRow != "undefined" ){
		if( this.currentRow > 0 ) this._UpdateDatasetDownRow(this.currentRow);
	}
	
	// 추가된 셀을 참조하는 산식 수정
	this._updateFormulaWhenRowMove(rowNum, rowNum + 1);
	
	// 산식재정비
	if( this.autoCalc && JSON.stringify(this._formulaRefs) !== "{}" )
		this.refreshFormulaRefs();
	
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
	this.updateScreen();
	
	//메모리 해제
	_datas = null;
	
	return;
};

EasySheet.prototype.clear = function(){
	// functionname : [EasySheet.clear]
	
	// 피벗이면 데이터를 지움, _skipFlag: 상호 순환호출 방지 
	if (this.pivot != null && this.pivot._skipFlag == false){
		this.pivot.dataSet.clearData();
        this.pivot.clear();
        this.pivot.refreshPivot();
		return;
	}
	
	// 예외처리 : 시트가 데이터셋과 연결된 경우, 시트 헤코드 수가 0이면 클리어 함수 동작을 더이상 진행하지 않음
	if( this.linkedDataset != null && this.maxRows <= 0 ){
		return;
	}
		
	// 1단계 : 산식정비
	var autoCalcurate = this.autoCalc;
	this.autoCalc = false;
	  
    var rowNumFrom = this.startRowColNum + 1;
    var colNumFrom = this.startRowColNum + 1;
    var rowNumTo = this.maxRows - 1 + this.startRowColNum;
    var colNumTo = this.maxCols - 1 + this.startRowColNum;
    this._removeFromFormulaRefs(rowNumFrom, colNumFrom, rowNumTo, colNumTo);
    
	// 2단계 : 데이터를 한줄로 줄인다(의사결정사항: 빈줄을 어찌할 것인가 )
    // 스크롤 조정 
    var oldFireEvent = this.FireEvent;
    this.FireEvent = false;
    this.moveToRow(this.startRowColNum);
    this.FireEvent = oldFireEvent;
    
	//편집 종료
	this.completeEditing(false);
    
	this.inClearMode = true;
	this.currentRow = this.startRowColNum;
	this.displayInfo.startRow = this.startRowColNum;
	this.maxRows = 1;
	
	// 데이터 모두 비움
	this.dataSet.clearData();
	// 빈줄한줄 추가
	this.dataSet.insertData();
	// 빈줄 객체 rowNum 설정
	this.rows(this.startRowColNum).rowNum = this.maxRows;
	// 빈줄 객체 seq 설정
	this.rows(this.startRowColNum).objectSeq = 1;
	
	// 그루핑 처리
	if( this.needGrouping ){
		this.sumUp.resetNeedGroup();
	}
	
	// 데이터셋 처리
	if( this.linkedDataset != null && typeof this._UpdateDatasetClear != "undefined" ){
		this._UpdateDatasetClear();
		
		if( typeof this._UpdateDatasetAddRow != "undefined" )
			this._UpdateDatasetAddRow(this.startRowColNum);
	}
	
	// clear 이벤트를 호출하고 거기서는 연결된 객체의 시퀀스를 1로한다
	if( this.hasClearEvent && this.FireEvent ){
		this.fncClearEvent();
	}
	
	// 3단계 : 셀의 내용을 초기화한다
	this.autoCalc = autoCalcurate;
	this.dirty = false;
	this.noMoreData = false;
	
	// 첫 줄 초기화
	this.clearRow(this.startRowColNum);
	
	// 4단계 : 산식재정비
	if( this.autoCalc && JSON.stringify(this._formulaRefs) !== "{}" )
		this.recalcurateRow(this.startRowColNum);
	
	// 5단계 : 메모리 초기화
	this.blockMode = false;
	this.col = -1; this.col2 = -1;  // Logical
	this.row = -1; this.row2 = -1;  // Logical
	this.dirty = false;             // 리스트 시트를 한번 선택한적이 있으면 Dirty이다
	this.callerFncName = "";  // Blur이벤트의 중복방지
	this.inputMode = SHEETMODE_SETCELL;
	this.inClearMode = false;
	
	// 6단계 : 그루핑 처리
	if( this.needGrouping ){
		this.sumUp.resetGroup();
//		this.updateScreen(SHEET_RESET_DATA_ONLY);
		this.updateScreen(SHEET_RESET_DATA);
	}
	
//	// 7단계 : 현재 포커스 행 이동(필요없는 코드이므로 막음)
//	this.setCurrentRow(this.startRowColNum);
	
	return;
};

EasySheet.prototype.getSelectedRow = function(){
	// functionname : [EasySheet.getSelectedRow]
	
	return this.sheetRenderer.selectedRowIndex;
};

EasySheet.prototype.getSelectedCol = function(){
	// functionname : [EasySheet.getSelectedCol]
	
	return this.sheetRenderer.selectedColumnIndex;
};

//rowRange는 startRowColNum이 반영된 줄/열번호이다
EasySheet.prototype.getRowRange = function(rowRange, functionName){
	// functionname : [EasySheet.getRowRange]
	
	if( (typeof rowRange == "undefined" || rowRange == null) && !this.blockMode ){
		alert(getText(	"message_EasySheet_009",
						"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
						"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
						functionName
		));
		return null;
	}
	
	if( Array.isArray(rowRange) && rowRange.length == 0 ){
		alert(getText(	"message_EasySheet_010",
						"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
						" 빈상태의 범위를 지정하셨습니다.",
						functionName
		));
		return null;
	}
	
	var targetRowNums = [];
	var rowNum0 = 0;
	var rowNum = 0;
	var i = 0;
	
	if( this.blockMode ){
		if( this.row == -1 ){
			for(rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++)
				targetRowNums.push(rowNum0 + this.startRowColNum);
		}
		else {
			for(rowNum = this.row; rowNum <= this.row2; rowNum++)
				targetRowNums.push(rowNum);
		}
	}
	else if( typeof rowRange == "number" ){
		rowNum0 = rowRange - this.startRowColNum;
		
		if( rowNum0 < this.maxRows )
			targetRowNums = [rowRange];
	}
	else if( Array.isArray(rowRange) ){
		for(i = 0; i < rowRange.length; i++){
			rowNum = rowRange[i];
			rowNum0 = rowNum - this.startRowColNum;
			
			if( rowNum0 < this.maxRows )
				targetRowNums.push(rowNum);
		}
	}
	
	return {targetRowNums : targetRowNums};
};

// colRange는 startRowColNum이 반영된 줄/열번호이다
EasySheet.prototype.getColRange = function(colRange, functionName){
	// functionname : [EasySheet.getColRange]

	if( (typeof colRange == "undefined" || colRange == null) && !this.blockMode ){
		alert(getText(	"message_EasySheet_009",
						"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
						" 블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
						functionName
		));
		return null;
	}
	if( Array.isArray(colRange) && colRange.length == 0 ){
		alert(getText(	"message_EasySheet_010",
						"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
						" 빈상태의 범위를 지정하셨습니다.",
						functionName
		));
		return null;
	}
	
	var targetColIds = [];
	var targetColNums = [];
	var colNum0 = 0;
	var colNum = 0;
	var colId = null;
	var i = 0;

	if( typeof colRange == "undefined" ){	// this.blockMode
		if( this.col == -1 ){
			for(colNum0 = 0; colNum0 < this.maxcols; colNum0++){
				colNum = colNum0 + this.startRowColNum;
				
				targetColIds.push(this.columns[colNum0].colId);
				targetColNums.push(colNum);
				
				colRange.push(colNum0 + this.startcolColNum);
			}
		}
		else {
			for(colNum = this.col ; colNum <= this.col2; colNum++){
				colNum0 = colNum - this.startRowColNum;
				
				targetColIds.push(this.columns[colNum0].colId);
				targetColNums.push(colNum);
			}
		}
	}
	else if( Array.isArray(colRange) ){
		if( typeof colRange[0] == "number" ){
			for(i = 0; i < colRange.length; i++){
				colNum = colRange[i];
				colNum0 = colNum - this.startRowColNum;
				
				if( colNum0 < this.maxCols ){
					targetColIds.push(this.columns[colNum0].colId);
					targetColNums.push(colNum);
				}
			}
		}
		else{
			for(colNum0 = 0; colNum0 < this.maxCols; colNum0++){
				colNum = colNum0 + this.startRowColNum;
				colId = this.columns[colNum0].colId;
				
				for(i = 0; i < colRange.length; i++){
					if( colId == colRange[i] ){
						targetColIds.push(colId);
						targetColNums.push(colNum);
						break;
					}
				}
			}
		}
	}
	else{
		if( typeof colRange == "number" ){
			colNum = colRange;
			colNum0 = colNum - this.startRowColNum;
			
			if( colNum0 < this.maxCols ){
				targetColIds.push(this.columns[colNum0].colId);
				targetColNums.push(colNum);
			}
		}
		else{
			for(colNum0 = 0; colNum0 < this.maxCols; colNum0++){
				colNum = colNum0 + this.startRowColNum;
				colId = this.columns[colNum0].colId;
				
				if( colId == colRange ){
					targetColIds.push(colId);
					targetColNums.push(colNum);
					break;
				}
			}
		}
	}
	
	return {targetColIds : targetColIds, targetColNums : targetColNums};
};

EasySheet.prototype.getColNum = function(colId){
	// functionname : [EasySheet.getColNum]
	
	if( colId == null || typeof colId == "undefined" ){
		alert(getText(	"message_EasySheet_019", 
						"sheet.{0}({1}) 함수의 인자가 없습니다.\n{1} 값을 넣어주세요", 
						["getColNum", "colId"]
		));
		return null;
	}
	
	var colRange = null;
	var colNums = null;
	
	colRange = this.getColRange(colId, "getColNum");
	
	if( colRange == null )
		return null;
	
	colNums = colRange.targetColNums[0];
	
	//메모리 해제
	colRange = null;
	
	return colNums;
};

//this.startRowColNum이 반영된 줄번호를 인자로 받는다.
EasySheet.prototype.getColId = function(colNum){
	// functionname : [EasySheet.getColId]
	
	if( colNum == null || typeof colNum == "undefined" ){
		alert(getText(	"message_EasySheet_019",
						"sheet.{0}({1}) 함수의 인자가 없습니다.\n{1} 값을 넣어주세요",
						["getColId", "colNum"]
		));
		return null;
	}
	
	var colRange = null;
	var colIds = null;
	
	colRange = this.getColRange(colNum, "getColId");
	
	if( colRange == null )
		return null;
	
	colIds = colRange.targetColIds[0];
	
	//메모리 해제
	colRange = null;
	
	return colIds;
};


EasySheet.prototype.isColId = function(colId){
	// functionname : [EasySheet.isColId]
	
	return (colId in this.dataSet.fieldInfos);
};

EasySheet.prototype.getAttribute = function(attributeName){
	// functionname : [EasySheet.getAttribute]
	
	return this[attributeName];
};

//this.startRowColNum이 반영된 줄번호를 인자로 받는다.
EasySheet.prototype.getCellAttribute = function(rowNum, colNumOrId, attributeName){
	// functionname : [EasySheet.getCellAttribute]
	
	var colId = null;
	var row = null;
	var cell = null;
	var attr = null;
	
	colId = (typeof colNumOrId == "string") ? colNumOrId : this.getColId(colNumOrId);
	
	if( this._isUnvalidColId(colId, "sheet.getCellAttribute") )
		return undefined;
	
	row = this.rows(rowNum);	// this.startRowColNum이 반영된 줄번호를 인자로 받는다.
	cell = row.cells[colId];
	
	if( typeof cell == "undefined" )
		return undefined;
	
	attr = cell[attributeName];
	
	//메모리 해제
	cell = null; row = null; colId = null;
	
	return attr;
};

//this.startRowColNum이 반영된 줄번호를 인자로 받는다.
EasySheet.prototype.setCellAttribute = function(rowNum, colNumOrId, attributeName, attributeValue){
	// functionname : [EasySheet.setCellAttribute]
	
	var colId = null;
	var row = null;
	var cell = null;
	
	colId = (typeof colNumOrId == "string") ? colNumOrId : this.getColId(colNumOrId);
	
	if( this._isUnvalidColId(colId, "sheet.setCellAttribute") )
		return;
	
	row = this.rows(rowNum);	// this.startRowColNum이 반영된 줄번호를 인자로 받는다.
	cell = row.cells[colId];
	
	if( typeof cell == "undefined" )
		cell = row.cells[colId] = {};
	
	cell[attributeName] = attributeValue;
	
	//메모리 해제
	cell = null; row = null; colId = null;

	return;
};

//this.startRowColNum이 반영된 줄번호를 인자로 받는다.
EasySheet.prototype.setCellAttributes = function(rowNums, colNums, attributeName, attributeValue){
	// functionname : [EasySheet.setCellAttributes]
	
	var rowNum0 = 0;
	var colNum0 = 0;
	var i = 0;
	var j = 0;
	
	for(j = 0; j < rowNums.length; j++){
		rowNum0 = rowNums[j] - this.startRowColNum;
		
		for(i = 0; i < colNums.length; i++){
			colNum0 = colNums[i] - this.startRowColNum;
			
			this.setCellAttribute(rowNum0, colNum0, attributeName, attributeValue);
		}
	}
};

EasySheet.prototype.getColumnAttribute = function(colNum, attributeName){
	// functionname : [EasySheet.setColumnAttribute]
	
	var colNum0 = colNum - this.startRowColNum;
	
	if( colNum0 < this.startRowColNum || colNum0 >= this.columns.length )
		return undefined;
	
	return this.columns[colNum][attributeName];
};

EasySheet.prototype.setColumnAttribute = function(colNum, attributeName, attributeValue){
	// functionname : [EasySheet.setColumnAttribute]
	
	if( Array.isArray(colNum) )
		return;
	
	colNum = (typeof colNum == "string") ? this.getColNum(colNum) : colNum;
	
	if( typeof colNum != "number" )
		return;
	
	var colNum0 = colNum - this.startRowColNum;
	var colAttr = null;

	if( colNum0 < this.startRowColNum || colNum0 >= this.columns.length )
		return;

	this.columns[colNum0][attributeName] = attributeValue;
	
	colAttr = {};
	colAttr[attributeName] = attributeValue;
	
	this.sheetRenderer.setColumnInfo(colNum0, colAttr, this.instantUpdateControl);
	
	colAttr = null;
	
//	//렌더러 디자인 변경
//	if( this.instantUpdateControl )
//		this.updateScreen(SHEET_RESET_DESIGN_TOO);

	return;
};

EasySheet.prototype.setColumnAttributes = function(colNums, attributeName, attributeValue){
	// functionname : [EasySheet.setColumnAttributes]
	
	var colNum = 0;
	var i = 0;

	if( !Array.isArray(colNums) ){
		colNum = colNums;
		this.setColumnAttribute(colNum, attributeName, attributeValue);
	}
	else{
		for(i = 0; i < colNums.length; i++) {
			colNum = colNums[i];
			
			this.setColumnAttribute(colNum, attributeName, attributeValue);
		}
	}
};

//this.startRowColNum이 반영된 줄번호를 인자로 받는다.
EasySheet.prototype.getRowAttribute = function(rowNum, attributeName){
	// functionname : [EasySheet.getRowAttribute]
	
	if( this._isUnvalidRowNum(rowNum, "sheet.delRow") )
		return;
	
	var row = this.rows(rowNum);	// this.startRowColNum이 반영된 줄번호를 인자로 받는다.
	var attr = null;
	
	if( typeof row[attributeName] == "undefined" ){
		if( ["hidden", "filterd"].indexOf(attributeName) >= 0 )
			row[attributeName] =  false;
		
		if( ["formula", "tag"].indexOf(attributeName) >= 0 )
			row[attributeName] =  "";
		
		if( ["treeInfo"].indexOf(attributeName) >= 0 )
			row[attributeName] =  null; 
	}
	
	attr = row[attributeName];
	
	//메모리 해제
	row = null;
	
	return attr;
};

//this.startRowColNum이 반영된 줄번호를 인자로 받는다.
EasySheet.prototype.setRowAttributes = function(rowNums, attributeName, attributeValue){
	// functionname : [EasySheet.setRowAttributes]
	
	var rowNum = 0;
	var i = 0;
	
	if (!Array.isArray(rowNums)) {
		rowNum = rowNums;
		this.setRowAttribute(rowNum, attributeName, attributeValue);
	}
	else{
	    for (i = 0; i < rowNums.length; i++) {
    		rowNum = rowNums[i];
    		this.setRowAttribute(rowNum, attributeName, attributeValue);
    	}
    }
};

//this.startRowColNum이 반영된 줄번호를 인자로 받는다.
EasySheet.prototype.setRowAttribute = function(rowNum, attributeName, attributeValue){
	// functionname : [EasySheet.setRowAttribute]
	
	if( this._isUnvalidRowNum(rowNum, "sheet.delRow") )
		return;
	
	var row = this.rows(rowNum);	// this.startRowColNum이 반영된 줄번호를 인자로 받는다.
	
	row[attributeName] = attributeValue;
	
	//메모리 해제
	row = null;
	
	return;
};

/**
 * @description 
 *    칼럼의 데이터 타입을 변경한다.  <br/>
 *     
 *     - 블럭을 지정해서 타입을 변경할 수도 잆고, 칼럼번호를 정해서 타입을 변경할 수 도 있다.<br/>  
 *     - 칼럼 정보의 셀타입을 변경하고, 데이터 셋의 셀타입을 변경한다.<br/>
 *     - 기존의 데이터는 형변환을 하며, 이미 컨버전 할 수 없는 데이터가 있으면 작업은 취소된다<br/>
 * <table>
 *     <tr style="background-color: #ddd;"><td>COSTANTS</td>
 *     <td>CELLTYPE_EDIT</td><td>CELLTYPE_NUMBER</td><td>CELLTYPE_PERCENT</td><td>CELLTYPE_INTEGER</td>
 *     <td>CELLTYPE_BUTTON</td><td>CELLTYPE_PICTURE</td><td>CELLTYPE_COMBOBOX</td><td>CELLTYPE_CHECKBOX</td>
 *     <td>CELLTYPE_TIME</td><td>CELLTYPE_DATE</td>
 *     </tr>
 *     <tr><td>script</td>
 *     <td>string</td><td>number</td><td>number</td><td>number</td>
 *     <td>null</td><td>string</td><td>string</td><td>string</td><td>string</td><td>string</td>
 *     </tr>
 *     <tr><td>default</td>
 *     <td>&quot;&quot;</td><td>0</td><td>0</td><td>0</td>
 *     <td>null</td><td>&quot;&quot;</td><td>&quot;&quot;</td>
 *     <td>&quot;&quot;</td><td>&quot;&quot;</td><td>&quot;&quot;</td>
 *     </tr>
 * </table>
 * 
 * @param {Number}										cellType	            - 변경하게 될 셀타입이다. <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- startRowColNum이 반영된 열범위이다. <br/>
 *                                                                               
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                    // 첫번째 칼럼 부터
 * sheet.col2 = 2;                   // 두번째 칼럼까지 
 * sheet.blockMode = true;           // 블럭지정
 * sheet.setCellType(CELLTYPE_EDIT); // 칼럼을 텍스트 타입으로 변경
 * sheet.blockMode = false;          // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setCellType(CELLTYPE_EDIT, 3);             // 3번 칼럼을 텍스트 타입으로 변경
 * sheet.setCellType(CELLTYPE_EDIT, [3. 4, 5]);     // 3, 4, 5번 칼럼을 텍스트 타입으로 변경
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setCellType(CELLTYPE_INTEGER, "id");        // "id" 칼럼을 정수타입으로 변경
 * sheet.setCellType(CELLTYPE_EDIT, ["id", "name"]); // "id", "name" 칼럼을 문자타입으로 변경
 */
EasySheet.prototype.setCellType = function(cellType, colRange){
	// functionname : [EasySheet.setCellType]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = 0;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setCellType"
			));
			return;
		}
	}
	
	colRangeObj = this.getColRange(colRange, "setCellType");
	
	if( colRangeObj == null )
		return;
	
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "cellType", cellType);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColIds = null; targetColNums = null; colRangeObj = null;
	
	return;
	
//	var colRangeObj = null;
//	var targetColIds = null;
//	var targetColNums = null;
//	var oldUpdateControl = true;
//	var newColumn = null;
//	var oldColumn = null;
//	var newColInfo = null;
//	var oldCellType = null;
//	var key = null;
//	var colNum = 0;
//	var colNum0 = 0;
//	var i = 0;
//	
//	// 데이터 상태 체크
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		oldColumn = this.columns[colNum0];
//		oldCellType = oldColumn.cellType;
//		
//		//셀타입이 같다면 넘어감
//		if( oldCellType == cellType && (typeof columnAttr == "undefined" && columnAttr == null) ){
//			//메모리 해제
//			oldColumn = null; oldCellType = null;
//			continue;
//		}
//		
//		//셀타입 변경을 위한 컬럼 객체 생성
//		newColumn = new EXOColumn();
//		newColInfo = {};
//		
//		//기존 컬럼의 공통속성 적용
//		newColumn.colId = oldColumn.colId;
//		newColumn.colDataType = oldColumn.colDataType;
//		newColumn.sheetRow = oldColumn.sheetRow;
//		newColumn.sheetCol = oldColumn.sheetCol;
//		newColumn.sheetRowSpan = oldColumn.sheetRowSpan;
//		newColumn.sheetColSpan = oldColumn.sheetColSpan;
//		newColumn.caption = oldColumn.caption;
//		newColumn.captionTooltip = oldColumn.captionTooltip;
//		newColumn.tag = oldColumn.tag;
//		newColumn.tooltip = oldColumn.tooltip;
//		newColumn.align = oldColumn.align;
//		newColumn.vAlign = oldColumn.vAlign;
//		newColumn.backColor = oldColumn.backColor;
//		newColumn.foreColor = oldColumn.foreColor;
//		newColumn.maxLength = oldColumn.maxLength;
//		newColumn.lockMode = oldColumn.lockMode;
//		newColumn.hidden = oldColumn.hidden;
//		newColumn.displayFormat = oldColumn.displayFormat;
//		newColumn.defaultValue = oldColumn.defaultValue;
//		newColumn.prefix = oldColumn.prefix;
//		newColumn.suffix = oldColumn.suffix;
//		newColumn.formula = oldColumn.formula;
//		newColumn.width = oldColumn.width;
//		newColumn.minWidth = oldColumn.minWidth;
//		
//		//생성한 컬럼 객체에 셀 타입 설정
//		newColumn.cellType = cellType;
//		
//		//체크박스 기본 추가 설정
//		if( cellType == CELLTYPE_CHECKBOX ){
//			//체크 값
//			if( newColumn.colDataType == "number" ){
//				newColumn.valueWhenChecked = 1; newColumn.valueWhenUnchecked = "0";
//			}
//			else if( newColumn.colDataType == "boolean" ){
//				newColumn.valueWhenChecked = true; newColumn.valueWhenUnchecked = false;
//			}
//			else{
//				newColumn.valueWhenChecked = "1"; newColumn.valueWhenUnchecked = "0";
//			}
//		}
//		
//		//새로 추가한 설정 적용
//		for(key in columnAttr){
//			newColumn[key] = columnAttr[key];
//			key = null;
//		}
//
//		//시트 컬럼 교체
//		this.columns[colNum0] = null;
//		this.columns[colNum0] = newColumn;
//		//렌더러 컬럼 교체
//		this.sheetRenderer.setColumnInfo(colNum0, newColumn);
//
//		//메모리 해제
//		oldColumn = null; oldCellType = null; newColumn = null; newColInfo = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
};

/**
 * @description 
 *    칼럼의 좌우 정렬 타입을 변경한다.  <br/>
 *     
 *     - 블럭을 지정해서 정렬타입을 변경할 수도 잆고, 칼럼번호를 정해서정렬 타입을 변경할 수 도 있다.<br/>  
 *     - 정렬기준이 변경되면 시트를 갱신한다.
 * <table>
 *     <tr style="background-color: #ddd;"><td>COSTANTS</td>
 *     <td>SHEET_ALIGN_LEFT</td><td>SHEET_ALIGN_RIGHT</td><td>SHEET_ALIGN_CENTER</td>
 *     </tr>
 *     <tr><td>string</td>
 *     <td>&quot;left&quot;</td><td>&quot;right&quot;</td><td>&quot;center&quot;</td>
 *     </tr>
 *     <tr><td>number</td>
 *     <td>0</td><td>1</td><td>2</td>
 *     </tr>
 * </table>
 * 
 * @param {String|Number}								align	- 좌우 정렬타입을 SHEET_ALIGN_XXX 상수, 또는 "right"와 같은 문자열로  <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                         // 첫번째 칼럼 부터
 * sheet.col2 = 2;                        // 두번째 칼럼까지 
 * sheet.blockMode = true;                // 블럭지정
 * sheet.setAlign(SHEET_ALIGN_LEFT);      // 칼럼을 왼쪽 정렬 타입으로 변경
 * sheet.blockMode = false;               // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setAlign(SHEET_ALIGN_RIGHT, 3);              // 3번 칼럼을 오른쪽 정렬 타입으로 변경
 * sheet.setAlign(SHEET_ALIGN_CENTER, [3. 4, 5]);     // 3, 4, 5번 칼럼을 가운데 정렬 타입으로 변경
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setAlign(SHEET_ALIGN_LEFT, "id");            // "id" 칼럼을 왼쪽 정렬 타입으로 변경
 * sheet.setAlign(SHEET_ALIGN_RIGHT, ["id", "name"]); // "id", "name" 칼럼을 오른쪽 정렬 타입으로 변경
 */
EasySheet.prototype.setAlign = function(align, colRange){
	// functionname : [EasySheet.setAlign]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = 0;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setAlign"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setAlign");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "align", align);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	if (align == SHEET_ALIGN_LEFT)        {align = "left";}
//	else if (align == SHEET_ALIGN_RIGHT)  {align = "right";}
//	else if (align == SHEET_ALIGN_CENTER) {align = "center";}
//	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//
//		//시트
//		this.setColumnAttributes(colNum, "align", align);
//		//렌더러
//		this.sheetRenderer.setColumnInfo(colNum0, {"align": align});
//
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/** 
 * @deprecated since version 5.0, sheet.setAlign()으로 대체 
 * */
EasySheet.prototype.setTypeHAlign = function(align, colRange){
	// functionname : [EasySheet.setTypeHAlign]
	
	EasySheet.prototype.setAlign.apply(this, arguments);
};

/**
 * @description 
 *    체크칼럼의 중앙 정렬 여부를 변경한다.  <br/>
 *     
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 정렬기준이 변경되면 시트를 갱신한다.
 * <table>
 *     <tr style="background-color: #ddd;"><td>COSTANTS</td>
 *     <td>SHEET_VALIGN_MIDDLE</td><td>SHEET_VALIGN_BASELINE</td><td>SHEET_VALIGN_BOTTOM</td><td>SHEET_VALIGN_TOP</td>
 *     </tr>
 *     <tr><td>string</td>
 *     <td>&quot;middle&quot;</td><td>&quot;baseline&quot;</td><td>&quot;bottom&quot;</td><td>&quot;top&quot;</td>
 *     </tr>
 *     <tr><td>number</td>
 *     <td>0</td><td>1</td><td>2</td><td>3</td>
 *     </tr>
 * </table>
 * 
 * @param {String|Number}								vAlign	- 상하 정렬타입을 SHEET_VALIGN_XXX 상수, 또는 "bottom"와 같은 문자열로  <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                            // 첫번째 칼럼 부터
 * sheet.col2 = 2;                           // 두번째 칼럼까지 
 * sheet.blockMode = true;                   // 블럭지정
 * sheet.setVAlign(SHEET_VALIGN_MIDDLE); // 칼럼을 상하 중앙 정렬 타입으로 변경
 * sheet.blockMode = false;                  // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setVAlign(SHEET_VALIGN_BASELINE, 3);              // 3번 칼럼을 기준선 정렬 타입으로 변경
 * sheet.setVAlign(SHEET_VALIGN_BOTTOM, [3. 4, 5]);        // 3, 4, 5번 칼럼을 하단 정렬 타입으로 변경
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setVAlign(SHEET_VALIGN_TOP, "id");              // "id" 칼럼을 상단 정렬 타입으로 변경
 * sheet.setVAlign(SHEET_VALIGN_MIDDLE, ["id", "name"]); // "id", "name" 칼럼을 상하 중앙 정렬 타입으로 변경
 */
EasySheet.prototype.setVAlign = function(vAlign, colRange){
	// functionname : [EasySheet.setVAlign]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = 0;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];

			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else {
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setAlign"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setVAlign");
	
	//열 범위를 못 구한 경우
	if (colRangeObj == null) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "vAlign", vAlign);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;

//	if (vAlign == SHEET_VALIGN_MIDDLE)        { vAlign = "middle";}
//	else if (vAlign == SHEET_VALIGN_BASELINE) { vAlign = "baseline";}
//	else if (vAlign == SHEET_VALIGN_BOTTOM)   { vAlign = "bottom";}
//	else if (vAlign == SHEET_VALIGN_TOP)      { vAlign = "top";}
//
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "vAlign", vAlign);
//		//렌더러
//		this.sheetRenderer.setColumnInfo(colNum0, {"vAlign": vAlign});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/** 
 * @deprecated since version 5.0, sheet.setVAlign()으로 대체 
 * */
EasySheet.prototype.setTypeVAlign = function(vAlign, colRange){
	// functionname : [EasySheet.setTypeVAlign]
	
	EasySheet.prototype.setVAlign.apply(this, arguments);
};

/**
 * @description 
 *    칼럼의 최대 허용 길이를 변경한다.  <br/>
 *     
 *     - 블럭을 지정해서 최대 허용길이를  변경할 수도 잆고, 칼럼번호를 정해서정렬 최대 허용길이를 변경할 수 도 있다.<br/>  
 *     - 최대 허용길이가 변경되면 시트를 갱신한다.
 * 
 * @param {Number}										maxLength	- 최대 허용길이 (디폴트: 100)  <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                         // 첫번째 칼럼 부터
 * sheet.col2 = 2;                        // 두번째 칼럼까지 
 * sheet.blockMode = true;                // 블럭지정
 * sheet.setMaxLength(50);            // 쵀대 50바이트로 셀길이를 한정 
 * sheet.blockMode = false;               // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setMaxLength(60, 3);              // 3번 칼럼을 쵀대 60바이트로 셀길이를 한정 
 * sheet.setMaxLength(70, [3. 4, 5]);     // 3, 4, 5번 칼럼을 쵀대 70바이트로 셀길이를 한정 
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setMaxLength(80, "id");            // "id" 칼럼을 쵀대 80바이트로 셀길이를 한정 
 * sheet.setMaxLength(90, ["id", "name"]); // "id", "name" 칼럼을 쵀대 90바이트로 셀길이를 한정 
 */
EasySheet.prototype.setMaxLength = function(maxLength, colRange){
	// functionname : [EasySheet.setMaxLength]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = null;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){ 
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",  
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" + 
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setMaxLength"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setMaxLength");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "maxLength", maxLength);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "maxLength", maxLength);
//		//렌더러
//		//this.sheetRenderer.setColumnInfo(targetColNums[i], {cellType: this.columns[targetColNums[i]].cellType, "maxLength": maxLength});
//		this.sheetRenderer.setColumnInfo(colNum0, {"maxLength": maxLength});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//디자인에 반영되는 속성이 아니므로 시트를 다시 그리지 않음
////	this.updateScreen(SHEET_RESET_DATA_ONLY);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/** 
 * @deprecated since version 5.0, sheet.setMaxLength()으로 대체 
 * */
EasySheet.prototype.setTypeMaxLength = function(maxLength, colRange){
	// functionname : [EasySheet.setTypeCheckCenter]
	
	EasySheet.prototype.setMaxLength.apply(this, arguments);
};

/** 
 * @description 
 *     셀값을 표시할 표시형식을 설정한다 <br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * 
 * @param {String}										format	            - 표시형식 문자열 <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                            // 첫번째 칼럼 부터
 * sheet.col2 = 2;                           // 두번째 칼럼까지 
 * sheet.blockMode = true;                   // 블럭지정
 * sheet.setDisplayFormat("0000-00-00");     // 칼럼 칼럼 표시형식을 "0000-00-00"의 형태로 지정함.
 * sheet.blockMode = false;                  // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setDisplayFormat("0000-00-00", 3);              // 3번 칼럼 칼럼 표시형식을 "0000-00-00"의 형태로 지정함.
 * sheet.setDisplayFormat("0000-00-00", [3. 4, 5]);      // 3, 4, 5번 칼럼 칼럼 표시형식을 "0000-00-00"의 형태로 지정함.
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setDisplayFormat("0000-00-00", "id");           // "id" 칼럼 칼럼 표시형식을 "0000-00-00"의 형태로 지정함.
 * sheet.setDisplayFormat("0000-00-00", ["id", "name"]); // "id", "name" 칼럼 칼럼 표시형식을 "0000-00-00"의 형태로 지정함.
 */
EasySheet.prototype.setDisplayFormat = function(format, colRange){
    // functionname : [EasySheet.setDisplayFormat]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = null;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){ 
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setDisplayFormat"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setDisplayFormat");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "displayFormat", format);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//
//		//시트
//		this.setColumnAttributes(colNum, "displayFormat", format);
//		//렌더러
//		this.sheetRenderer.setColumnInfo(colNum0, {"displayFormat": format});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//    this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/**
 * @description 
 *    칼럼의 스타일을 변경한다.  <br/>
 *     
 *     - {"스타일속성명": "스타일속성값", "스타일속성명": "스타일속성값", ...} 의 형태로 스타일을 지정한다. <br/>  
 *     - 만들어진 스타일을 지우려면 : wSheet.setTypeStyle({"text-align":""});
 * 
 * @param {Object}	styleJSON	- 스타일 속성과 값의 조합으로 JSON 형태, <br/>&#123;"text-align":"left", "font": "normal 12pt 굴림,Courier"&#125;   <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                                // 첫번째 칼럼 부터
 * sheet.col2 = 2;                               // 두번째 칼럼까지 
 * sheet.blockMode = true;                       // 블럭지정
 * sheet.setStyle({"text-align":"left"});    // 칼럼 "text-align" 스타일을 "left"로 변경
 * sheet.blockMode = false;                      // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setStyle({"text-align":"left"}, 3);             // 3번 칼럼 "text-align" 스타일을 "left"로 변경
 * sheet.setStyle({"text-align":"left"}, [3. 4, 5]);     // 3, 4, 5번 칼럼 "text-align" 스타일을 "left"로 변경
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setStyle({"text-align":"left"}, "id");           // "id" 칼럼 "text-align" 스타일을 "left"로 변경
 * sheet.setStyle({"text-align":"left"}, ["id", "name"]); // "id", "name" 칼럼 "text-align" 스타일을 "left"로 변경
 */
EasySheet.prototype.setStyle = function(styleJSON, colRange){
	// functionname : [EasySheet.setStyle]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var colNum = null;
	var colNum0 = null;
	var i = 0;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",  
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" + 
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setStyle"
			));
			return;
		}
	}
	
	// 열 범위 구함
	colRangeObj = this.getColRange(colRange, "setStyle");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	// 열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	
	// 컬럼정보 속성 적용
	for(i = 0; i < targetColNums.length; i++){
		colNum0 = targetColNums[i] - this.startRowColNum;
		
		// ???
		
		// 렌더러
		this.sheetRenderer.setCellStyle(colNum0, styleJSON);
		
		// 메모리 해제
		colNum0 = null;
	}
	
	// 렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
	this.updateScreen(SHEET_RESET_DESIGN);
	
	// 메모리 해제
	targetColNums = null;
	targetColIds = null;
	colRangeObj = null;
	
	return;
};

/** 
 * @deprecated since version 5.0, sheet.setStyle()으로 대체 
 * */
EasySheet.prototype.setTypeStyle = function(styleJSON, colRange){
	// functionname : [EasySheet.setTypeStyle]
	
	EasySheet.prototype.setStyle.apply(this, arguments);
};

/** 
 * @description 
 *     셀의 배경색을 지정한다 <br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 *
 * <table>
 * <tr style="background-color: #ddd;"><th >Color Name</th><th>HEX</th><th>Color</th><th >Color Name</th><th>HEX</th><th>Color</th></tr>
 * <tr><td>AliceBlue&nbsp;</td><td>#F0F8FF</td><td style="background-color:#F0F8FF">&nbsp;</td><td>AntiqueWhite&nbsp;</td><td>#FAEBD7</td><td style="background-color:#FAEBD7">&nbsp;</td></tr>
 * <tr><td>Aqua&nbsp;</td><td>#00FFFF</td><td style="background-color:#00FFFF">&nbsp;</td><td>Aquamarine&nbsp;</td><td>#7FFFD4</td><td style="background-color:#7FFFD4">&nbsp;</td></tr>
 * <tr><td>Azure&nbsp;</td><td>#F0FFFF</td><td style="background-color:#F0FFFF">&nbsp;</td><td>Beige&nbsp;</td><td>#F5F5DC</td><td style="background-color:#F5F5DC">&nbsp;</td></tr>
 * <tr><td>Bisque&nbsp;</td><td>#FFE4C4</td><td style="background-color:#FFE4C4">&nbsp;</td><td>Black&nbsp;</td><td>#000000</td><td style="background-color:#000000">&nbsp;</td></tr>
 * <tr><td>BlanchedAlmond&nbsp;</td><td>#FFEBCD</td><td style="background-color:#FFEBCD">&nbsp;</td><td>Blue&nbsp;</td><td>#0000FF</td><td style="background-color:#0000FF">&nbsp;</td></tr>
 * <tr><td>BlueViolet&nbsp;</td><td>#8A2BE2</td><td style="background-color:#8A2BE2">&nbsp;</td><td>Brown&nbsp;</td><td>#A52A2A</td><td style="background-color:#A52A2A">&nbsp;</td></tr>
 * <tr><td>BurlyWood&nbsp;</td><td>#DEB887</td><td style="background-color:#DEB887">&nbsp;</td><td>CadetBlue&nbsp;</td><td>#5F9EA0</td><td style="background-color:#5F9EA0">&nbsp;</td></tr>
 * <tr><td>Chartreuse&nbsp;</td><td>#7FFF00</td><td style="background-color:#7FFF00">&nbsp;</td><td>Chocolate&nbsp;</td><td>#D2691E</td><td style="background-color:#D2691E">&nbsp;</td></tr>
 * <tr><td>Coral&nbsp;</td><td>#FF7F50</td><td style="background-color:#FF7F50">&nbsp;</td><td>CornflowerBlue&nbsp;</td><td>#6495ED</td><td style="background-color:#6495ED">&nbsp;</td></tr>
 * <tr><td>Cornsilk&nbsp;</td><td>#FFF8DC</td><td style="background-color:#FFF8DC">&nbsp;</td><td>Crimson&nbsp;</td><td>#DC143C</td><td style="background-color:#DC143C">&nbsp;</td></tr>
 * <tr><td>Cyan&nbsp;</td><td>#00FFFF</td><td style="background-color:#00FFFF">&nbsp;</td><td>DarkBlue&nbsp;</td><td>#00008B</td><td style="background-color:#00008B">&nbsp;</td></tr>
 * <tr><td>DarkCyan&nbsp;</td><td>#008B8B</td><td style="background-color:#008B8B">&nbsp;</td><td>DarkGoldenRod&nbsp;</td><td>#B8860B</td><td style="background-color:#B8860B">&nbsp;</td></tr>
 * <tr><td>DarkGray&nbsp;</td><td>#A9A9A9</td><td style="background-color:#A9A9A9">&nbsp;</td><td>DarkGrey&nbsp;</td><td>#A9A9A9</td><td style="background-color:#A9A9A9">&nbsp;</td></tr>
 * <tr><td>DarkGreen&nbsp;</td><td>#006400</td><td style="background-color:#006400">&nbsp;</td><td>DarkKhaki&nbsp;</td><td>#BDB76B</td><td style="background-color:#BDB76B">&nbsp;</td></tr>
 * <tr><td>DarkMagenta&nbsp;</td><td>#8B008B</td><td style="background-color:#8B008B">&nbsp;</td><td>DarkOliveGreen&nbsp;</td><td>#556B2F</td><td style="background-color:#556B2F">&nbsp;</td></tr>
 * <tr><td>DarkOrange&nbsp;</td><td>#FF8C00</td><td style="background-color:#FF8C00">&nbsp;</td><td>DarkOrchid&nbsp;</td><td>#9932CC</td><td style="background-color:#9932CC">&nbsp;</td></tr>
 * <tr><td>DarkRed&nbsp;</td><td>#8B0000</td><td style="background-color:#8B0000">&nbsp;</td><td>DarkSalmon&nbsp;</td><td>#E9967A</td><td style="background-color:#E9967A">&nbsp;</td></tr>
 * <tr><td>DarkSeaGreen&nbsp;</td><td>#8FBC8F</td><td style="background-color:#8FBC8F">&nbsp;</td><td>DarkSlateBlue&nbsp;</td><td>#483D8B</td><td style="background-color:#483D8B">&nbsp;</td></tr>
 * <tr><td>DarkSlateGray&nbsp;</td><td>#2F4F4F</td><td style="background-color:#2F4F4F">&nbsp;</td><td>DarkSlateGrey&nbsp;</td><td>#2F4F4F</td><td style="background-color:#2F4F4F">&nbsp;</td></tr>
 * <tr><td>DarkTurquoise&nbsp;</td><td>#00CED1</td><td style="background-color:#00CED1">&nbsp;</td><td>DarkViolet&nbsp;</td><td>#9400D3</td><td style="background-color:#9400D3">&nbsp;</td></tr>
 * <tr><td>DeepPink&nbsp;</td><td>#FF1493</td><td style="background-color:#FF1493">&nbsp;</td><td>DeepSkyBlue&nbsp;</td><td>#00BFFF</td><td style="background-color:#00BFFF">&nbsp;</td></tr>
 * <tr><td>DimGray&nbsp;</td><td>#696969</td><td style="background-color:#696969">&nbsp;</td><td>DimGrey&nbsp;</td><td>#696969</td><td style="background-color:#696969">&nbsp;</td></tr>
 * <tr><td>DodgerBlue&nbsp;</td><td>#1E90FF</td><td style="background-color:#1E90FF">&nbsp;</td><td>FireBrick&nbsp;</td><td>#B22222</td><td style="background-color:#B22222">&nbsp;</td></tr>
 * <tr><td>FloralWhite&nbsp;</td><td>#FFFAF0</td><td style="background-color:#FFFAF0">&nbsp;</td><td>ForestGreen&nbsp;</td><td>#228B22</td><td style="background-color:#228B22">&nbsp;</td></tr>
 * <tr><td>Fuchsia&nbsp;</td><td>#FF00FF</td><td style="background-color:#FF00FF">&nbsp;</td><td>Gainsboro&nbsp;</td><td>#DCDCDC</td><td style="background-color:#DCDCDC">&nbsp;</td></tr>
 * <tr><td>GhostWhite&nbsp;</td><td>#F8F8FF</td><td style="background-color:#F8F8FF">&nbsp;</td><td>Gold&nbsp;</td><td>#FFD700</td><td style="background-color:#FFD700">&nbsp;</td></tr>
 * <tr><td>GoldenRod&nbsp;</td><td>#DAA520</td><td style="background-color:#DAA520">&nbsp;</td><td>Gray&nbsp;</td><td>#808080</td><td style="background-color:#808080">&nbsp;</td></tr>
 * <tr><td>Grey&nbsp;</td><td>#808080</td><td style="background-color:#808080">&nbsp;</td><td>Green&nbsp;</td><td>#008000</td><td style="background-color:#008000">&nbsp;</td></tr>
 * <tr><td>Shades</td><td>#ADFF2F</td><td style="background-color:#ADFF2F">&nbsp;</td><td>HoneyDew&nbsp;</td><td>#F0FFF0</td><td style="background-color:#F0FFF0">&nbsp;</td></tr>
 * <tr><td>HotPink&nbsp;</td><td>#FF69B4</td><td style="background-color:#FF69B4">&nbsp;</td><td>IndianRed &nbsp;</td><td>#CD5C5C</td><td style="background-color:#CD5C5C">&nbsp;</td></tr>
 * <tr><td>Indigo  &nbsp;</td><td>#4B0082</td><td style="background-color:#4B0082">&nbsp;</td><td>Ivory&nbsp;</td><td>#FFFFF0</td><td style="background-color:#FFFFF0">&nbsp;</td></tr>
 * <tr><td>Khaki&nbsp;</td><td>#F0E68C</td><td style="background-color:#F0E68C">&nbsp;</td><td>Lavender&nbsp;</td><td>#E6E6FA</td><td style="background-color:#E6E6FA">&nbsp;</td></tr>
 * <tr><td>LavenderBlush&nbsp;</td><td>#FFF0F5</td><td style="background-color:#FFF0F5">&nbsp;</td><td>LawnGreen&nbsp;</td><td>#7CFC00</td><td style="background-color:#7CFC00">&nbsp;</td></tr>
 * <tr><td>LemonChiffon&nbsp;</td><td>#FFFACD</td><td style="background-color:#FFFACD">&nbsp;</td><td>LightBlue&nbsp;</td><td>#ADD8E6</td><td style="background-color:#ADD8E6">&nbsp;</td></tr>
 * <tr><td>LightCoral&nbsp;</td><td>#F08080</td><td style="background-color:#F08080">&nbsp;</td><td>LightCyan&nbsp;</td><td>#E0FFFF</td><td style="background-color:#E0FFFF">&nbsp;</td></tr>
 * <tr><td>LightGoldenRodYellow&nbsp;</td><td>#FAFAD2</td><td style="background-color:#FAFAD2">&nbsp;</td><td>LightGray&nbsp;</td><td>#D3D3D3</td><td style="background-color:#D3D3D3">&nbsp;</td></tr>
 * <tr><td>LightGrey&nbsp;</td><td>#D3D3D3</td><td style="background-color:#D3D3D3">&nbsp;</td><td>LightGreen&nbsp;</td><td>#90EE90</td><td style="background-color:#90EE90">&nbsp;</td></tr>
 * <tr><td>LightPink&nbsp;</td><td>#FFB6C1</td><td style="background-color:#FFB6C1">&nbsp;</td><td>LightSalmon&nbsp;</td><td>#FFA07A</td><td style="background-color:#FFA07A">&nbsp;</td></tr>
 * <tr><td>LightSeaGreen&nbsp;</td><td>#20B2AA</td><td style="background-color:#20B2AA">&nbsp;</td><td>LightSkyBlue&nbsp;</td><td>#87CEFA</td><td style="background-color:#87CEFA">&nbsp;</td></tr>
 * <tr><td>LightSlateGray&nbsp;</td><td>#778899</td><td style="background-color:#778899">&nbsp;</td><td>LightSlateGrey&nbsp;</td><td>#778899</td><td style="background-color:#778899">&nbsp;</td></tr>
 * <tr><td>LightSteelBlue&nbsp;</td><td>#B0C4DE</td><td style="background-color:#B0C4DE">&nbsp;</td><td>LightYellow&nbsp;</td><td>#FFFFE0</td><td style="background-color:#FFFFE0">&nbsp;</td></tr>
 * <tr><td>Lime&nbsp;</td><td>#00FF00</td><td style="background-color:#00FF00">&nbsp;</td><td>LimeGreen&nbsp;</td><td>#32CD32</td><td style="background-color:#32CD32">&nbsp;</td></tr>
 * <tr><td>Linen&nbsp;</td><td>#FAF0E6</td><td style="background-color:#FAF0E6">&nbsp;</td><td>Magenta&nbsp;</td><td>#FF00FF</td><td style="background-color:#FF00FF">&nbsp;</td></tr>
 * <tr><td>Maroon&nbsp;</td><td>#800000</td><td style="background-color:#800000">&nbsp;</td><td>MediumAquaMarine&nbsp;</td><td>#66CDAA</td><td style="background-color:#66CDAA">&nbsp;</td></tr>
 * <tr><td>MediumBlue&nbsp;</td><td>#0000CD</td><td style="background-color:#0000CD">&nbsp;</td><td>MediumOrchid&nbsp;</td><td>#BA55D3</td><td style="background-color:#BA55D3">&nbsp;</td></tr>
 * <tr><td>MediumPurple&nbsp;</td><td>#9370DB</td><td style="background-color:#9370DB">&nbsp;</td><td>MediumSeaGreen&nbsp;</td><td>#3CB371</td><td style="background-color:#3CB371">&nbsp;</td></tr>
 * <tr><td>MediumSlateBlue&nbsp;</td><td>#7B68EE</td><td style="background-color:#7B68EE">&nbsp;</td><td>MediumSpringGreen&nbsp;</td><td>#00FA9A</td><td style="background-color:#00FA9A">&nbsp;</td></tr>
 * <tr><td>MediumTurquoise&nbsp;</td><td>#48D1CC</td><td style="background-color:#48D1CC">&nbsp;</td><td>MediumVioletRed&nbsp;</td><td>#C71585</td><td style="background-color:#C71585">&nbsp;</td></tr>
 * <tr><td>MidnightBlue&nbsp;</td><td>#191970</td><td style="background-color:#191970">&nbsp;</td><td>MintCream&nbsp;</td><td>#F5FFFA</td><td style="background-color:#F5FFFA">&nbsp;</td></tr>
 * <tr><td>MistyRose&nbsp;</td><td>#FFE4E1</td><td style="background-color:#FFE4E1">&nbsp;</td><td>Moccasin&nbsp;</td><td>#FFE4B5</td><td style="background-color:#FFE4B5">&nbsp;</td></tr>
 * <tr><td>NavajoWhite&nbsp;</td><td>#FFDEAD</td><td style="background-color:#FFDEAD">&nbsp;</td><td>Navy&nbsp;</td><td>#000080</td><td style="background-color:#000080">&nbsp;</td></tr>
 * <tr><td>OldLace&nbsp;</td><td>#FDF5E6</td><td style="background-color:#FDF5E6">&nbsp;</td><td>Olive&nbsp;</td><td>#808000</td><td style="background-color:#808000">&nbsp;</td></tr>
 * <tr><td>OliveDrab&nbsp;</td><td>#6B8E23</td><td style="background-color:#6B8E23">&nbsp;</td><td>Orange&nbsp;</td><td>#FFA500</td><td style="background-color:#FFA500">&nbsp;</td></tr>
 * <tr><td>OrangeRed&colRange</td><td>#FF4500</td><td style="background-color:#FF4500">&nbsp;</td><td>Orchid&nbsp;</td><td>#DA70D6</td><td style="background-color:#DA70D6">&nbsp;</td></tr>
 * <tr><td>PaleGoldenRod&nbsp;</td><td>#EEE8AA</td><td style="background-color:#EEE8AA">&nbsp;</td><td>PaleGreen&nbsp;</td><td>#98FB98</td><td style="background-color:#98FB98">&nbsp;</td></tr>
 * <tr><td>PaleTurquoise&nbsp;</td><td>#AFEEEE</td><td style="background-color:#AFEEEE">&nbsp;</td><td>PaleVioletRed&nbsp;</td><td>#DB7093</td><td style="background-color:#DB7093">&nbsp;</td></tr>
 * <tr><td>PapayaWhip&nbsp;</td><td>#FFEFD5</td><td style="background-color:#FFEFD5">&nbsp;</td><td>PeachPuff&nbsp;</td><td>#FFDAB9</td><td style="background-color:#FFDAB9">&nbsp;</td></tr>
 * <tr><td>Peru&nbsp;</td><td>#CD853F</td><td style="background-color:#CD853F">&nbsp;</td><td>Pink&nbsp;</td><td>#FFC0CB</td><td style="background-color:#FFC0CB">&nbsp;</td></tr>
 * <tr><td>Plum&nbsp;</td><td>#DDA0DD</td><td style="background-color:#DDA0DD">&nbsp;</td><td>PowderBlue&nbsp;</td><td>#B0E0E6</td><td style="background-color:#B0E0E6">&nbsp;</td></tr>
 * <tr><td>Purple&nbsp;</td><td>#800080</td><td style="background-color:#800080">&nbsp;</td><td>RebeccaPurple&nbsp;</td><td>#663399</td><td style="background-color:#663399">&nbsp;</td></tr>
 * <tr><td>Red&nbsp;</td><td>#FF0000</td><td style="background-color:#FF0000">&nbsp;</td><td>RosyBrown&nbsp;</td><td>#BC8F8F</td><td style="background-color:#BC8F8F">&nbsp;</td></tr>
 * <tr><td>RoyalBlue&nbsp;</td><td>#4169E1</td><td style="background-color:#4169E1">&nbsp;</td><td>SaddleBrown&nbsp;</td><td>#8B4513</td><td style="background-color:#8B4513">&nbsp;</td></tr>
 * <tr><td>Salmon&nbsp;</td><td>#FA8072</td><td style="background-color:#FA8072">&nbsp;</td><td>SandyBrown&nbsp;</td><td>#F4A460</td><td style="background-color:#F4A460">&nbsp;</td></tr>
 * <tr><td>SeaGreen&nbsp;</td><td>#2E8B57</td><td style="background-color:#2E8B57">&nbsp;</td><td>SeaShell&nbsp;</td><td>#FFF5EE</td><td style="background-color:#FFF5EE">&nbsp;</td></tr>
 * <tr><td>Sienna&nbsp;</td><td>#A0522D</td><td style="background-color:#A0522D">&nbsp;</td><td>Silver&nbsp;</td><td>#C0C0C0</td><td style="background-color:#C0C0C0">&nbsp;</td></tr><tr>
 * <td>SkyBlue&nbsp;</td><td>#87CEEB</td><td style="background-color:#87CEEB">&nbsp;</td><td>SlateBlue&nbsp;</td><td>#6A5ACD</td><td style="background-color:#6A5ACD">&nbsp;</td></tr>
 * <tr><td>SlateGray&nbsp;</td><td>#708090</td><td style="background-color:#708090">&nbsp;</td><td>SlateGrey&nbsp;</td><td>#708090</td><td style="background-color:#708090">&nbsp;</td></tr>
 * <tr><td>Snow&nbsp;</td><td>#FFFAFA</td><td style="background-color:#FFFAFA">&nbsp;</td><td>SpringGreen&nbsp;</td><td>#00FF7F</td><td style="background-color:#00FF7F">&nbsp;</td></tr>
 * <tr><td>SteelBlue&nbsp;</td><td>#4682B4</td><td style="background-color:#4682B4">&nbsp;</td><td>Tan&nbsp;</td><td>#D2B48C</td><td style="background-color:#D2B48C">&nbsp;</td></tr>
 * <tr><td>Teal&nbsp;</td><td>#008080</td><td style="background-color:#008080">&nbsp;</td><td>Thistle&nbsp;</td><td>#D8BFD8</td><td style="background-color:#D8BFD8">&nbsp;</td></tr>
 * <tr><td>Tomato&nbsp;</td><td>#FF6347</td><td style="background-color:#FF6347">&nbsp;</td><td>Turquoise&nbsp;</td><td>#40E0D0</td><td style="background-color:#40E0D0">&nbsp;</td></tr>
 * <tr><td>Violet&nbsp;</td><td>#EE82EE</td><td style="background-color:#EE82EE">&nbsp;</td><td>Wheat&nbsp;</td><td>#F5DEB3</td><td style="background-color:#F5DEB3">&nbsp;</td></tr>
 * <tr><td>White&nbsp;</td><td>#FFFFFF</td><td style="background-color:#FFFFFF">&nbsp;</td><td>WhiteSmoke&nbsp;</td><td>#F5F5F5</td><td style="background-color:#F5F5F5">&nbsp;</td></tr>
 * <tr><td>Yellow&nbsp;</td><td>#FFFF00</td><td style="background-color:#FFFF00">&nbsp;</td><td>YellowGreen&nbsp;</td><td>#9ACD32</td><td style="background-color:#9ACD32">&nbsp;</td></tr>
 * </table>
 * 
 * @param {String|Number}					cellColor	-  시간 타입 셀표시 형식 <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                            // 첫번째 칼럼 부터
 * sheet.col2 = 2;                           // 두번째 칼럼까지 
 * sheet.blockMode = true;                   // 블럭지정
 * sheet.setBackColor("yyyy-mm-dd");// 칼럼을 "yyyy-mm-dd" 형식으로 표시
 * sheet.blockMode = false;                  // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setBackColor("yyyy-mm-dd", 3);              // 3번 칼럼을  "yyyy-mm-dd" 형식으로 표시
 * sheet.setBackColor("yyyy-mm-dd", [3. 4, 5]);      // 3, 4, 5번 칼럼을  "yyyy-mm-dd" 형식으로 표시
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setBackColor("yyyy-mm-dd", "id");           // "id" 칼럼을  "yyyy-mm-dd" 형식으로 표시
 * sheet.setBackColor("yyyy-mm-dd", ["id", "name"]); // "id", "name" 칼럼을  "yyyy-mm-dd" 형식으로 표시
 */
EasySheet.prototype.setBackGroundColor = function(color, colRange){
	// functionname : [EasySheet.setBackColor]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = null;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setBackGroundColor"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setBackGroundColor");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "backColor", color);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;

	return;

//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "backColor", color);
//		//렌더러
//		this.sheetRenderer.setColumnInfo(colNum0, {"backColor": color});
//		
//		//메모리해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//
//	return;
};
/** 
 * @deprecated since version 5.0, sheet.setBackGroundColor()으로 대체 
 * */
EasySheet.prototype.setTypeCellColor = function(color, colRange){
    // functionname : [EasySheet.setTypeCellColor]

	EasySheet.prototype.setBackGroundColor.apply(this, arguments);
};

/** 
 * @description 
 *     셀의 배경색을 지정한다 <br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 *	   - 색상값은 setTypeCellColor 참조
 * 
 * @param {String|Number}					cellColor	-  시간 타입 셀표시 형식 <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                            // 첫번째 칼럼 부터
 * sheet.col2 = 2;                           // 두번째 칼럼까지 
 * sheet.blockMode = true;                   // 블럭지정
 * sheet.setTypeCellColor("yyyy-mm-dd");// 칼럼을 "yyyy-mm-dd" 형식으로 표시
 * sheet.blockMode = false;                  // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setTypeCellColor("yyyy-mm-dd", 3);              // 3번 칼럼을  "yyyy-mm-dd" 형식으로 표시
 * sheet.setTypeCellColor("yyyy-mm-dd", [3. 4, 5]);      // 3, 4, 5번 칼럼을  "yyyy-mm-dd" 형식으로 표시
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setTypeCellColor("yyyy-mm-dd", "id");           // "id" 칼럼을  "yyyy-mm-dd" 형식으로 표시
 * sheet.setTypeCellColor("yyyy-mm-dd", ["id", "name"]); // "id", "name" 칼럼을  "yyyy-mm-dd" 형식으로 표시
 */
EasySheet.prototype.setTypeForeColor = function(color, colRange){
	// functionname : [EasySheet.setTypeCellColor]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = null;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setTypeForeColor"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setTypeForeColor");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "foreColor", color);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	return;
	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "foreColor", color);
//		//렌더러
//		this.sheetRenderer.setColumnInfo(colNum0, {"foreColor": color});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};
/** 
 * @deprecated since version 5.0, 칼럼정보를 sheet.setTypeForeColor()으로 대체 
 * */
EasySheet.prototype.setTypeCellFontColor = function(color, colRange){
	this.setTypeForeColor();
};

/** 
 * @description 
 *     셀에 마우스가 이동했을 경우 보여줄 툴팁을 설정한다 <br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * 
 * @param {String}										tooltip	-  툴팁 문장 <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                            // 첫번째 칼럼 부터
 * sheet.col2 = 2;                           // 두번째 칼럼까지 
 * sheet.blockMode = true;                   // 블럭지정
 * sheet.setTooltip("click here!");  // 칼럼 마우스 이동시 툴팁 "click here!"를 보여 줌.
 * sheet.blockMode = false;                  // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setTooltip("click here!", 3);              // 3번 칼럼 마우스 이동시 툴팁 "click here!"를 보여 줌.
 * sheet.setTooltip("click here!", [3. 4, 5]);      // 3, 4, 5번 칼럼 마우스 이동시 툴팁 "click here!"를 보여 줌.
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setTooltip("click here!", "id");           // "id" 칼럼 마우스 이동시 툴팁 "click here!"를 보여 줌.
 * sheet.setTooltip("click here!", ["id", "name"]); // "id", "name" 칼럼 마우스 이동시 툴팁 "click here!"를 보여 줌.
 */
EasySheet.prototype.setTooltip = function(tooltip, colRange){
	// functionname : [EasySheet.setTooltip]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = null;

	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setTooltip"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setTooltip");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "tooltip", tooltip);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "tooltip", tooltip);
//		//렌더러
//		this.sheetRenderer.setColumnInfo(colNum0, {"tooltip": tooltip});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/** 
 * @deprecated since version 5.0, sheet.setTooltip()으로 대체 
 * */
EasySheet.prototype.setTypeCellTooltip = function(tooltip, colRange){
	// functionname : [EasySheet.setTypeCellTooltip]
	
	EasySheet.prototype.setTooltip.apply(this, arguments);
};

/** 
 * @description 
 *     셀에 입력된 산식을 건증할 기중을 등록한다 <br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 산식타입이 아닌 경우에도 체크산식과 메시지를 병행 할 수 있다 
 *     
 *		<table style="width: 100%">
 *			<tr bgcolor="#808080">     
 *              <td>체크명</td>        <td>상수</td>               <td>Number</td></tr>
 *			<tr><td>기본체크</td>      <td>CEHCK_TYPE_NONE</td>    <td>0</td></tr>
 *			<tr><td>산식체크</td>      <td>CEHCK_TYPE_FORMULA</td> <td>1</td></tr>
 *			<tr><td>년도체크</td>      <td>CEHCK_TYPE_YYYY</td>    <td>2</td></tr>
 *			<tr><td>년월체크</td>      <td>CEHCK_TYPE_YM</td>      <td>3</td></tr>
 *			<tr><td>일자체크</td>      <td>CEHCK_TYPE_YMD</td>     <td>4</td></tr>
 *			<tr><td>주민등록번호</td>  <td>CEHCK_TYPE_RESINUM</td> <td>5</td></tr>
 *			<tr><td>사업자등록번호</td><td>CEHCK_TYPE_TAXNUM</td>  <td>6</td></tr>
 *			<tr><td>우편번호</td>      <td>CEHCK_TYPE_POSTNUM</td> <td>7</td></tr>
 *			<tr><td>금액</td>          <td>CEHCK_TYPE_AMOUNT</td>  <td>9</td></tr>
 *			<tr><td>숫자</td>          <td>CEHCK_TYPE_NUMBER</td>  <td>10</td></tr>
 *			<tr><td>한글</td>          <td>CEHCK_TYPE_IMEMODE</td> <td>11</td></tr>
 *			<tr><td>영숫자</td>        <td>CEHCK_TYPE_ENGLNUM</td> <td>12</td></tr>
 *			<tr><td>바코드</td>        <td>CEHCK_TYPE_BARCODE</td> <td>13</td></tr>
 *			<tr><td>패스워드</td>      <td>CEHCK_TYPE_PASSWORD</td><td>14</td></tr>
 *		</table>
 *     
 * 
 * @param {Number}										checkType	        	- 체크타입상수 <br/>
 * @param {String}										checkFormula	        - 체크산식 <br/>
 * @param {String}										checkMessage	        - 오류세 체크 메시지 <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 체크조건을 부여할 셀영역이다. <br/>
 * 
 * @return {void} 	
 */
EasySheet.prototype.setValitionType = function(checkType, checkFormula, checkMessage, colRange){
	// functionname : [EasySheet.setValitionType]
	
	//열 범위 구함
	var colRangeObj = this.getColRange(colRange, "setValitionType");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;

	var targetColNums = colRangeObj.targetColNums;
	var controlString = getText("message_str_control", "콘트롤");
	var formula = null;
	var colNum = 0;
	var colNum1 = 0;
	var i = 0;
	
	//컬럼정보 속성 적용
	for(i = 0; i < targetColNums.length; i++){
		colNum = targetColNums[i];
		colNum1 = colNum - this.startRowColNum + 1;;
		
		this.setColumnAttributes(colNum, "checkType", checkType);
		this.setColumnAttributes(colNum, "checkFormula", checkFormula);
		this.setColumnAttributes(colNum, "checkMessage", checkMessage);
		
		formula = checkFormula.replace(new RegExp(escapeRegExp("[" + controlString + "." + this.controlName + "." + colNum1 + "]"), "ig"), "newValue");
		
		this.setColumnAttributes(colNum, "checkFunction"
				, new Function("return function (sheet, rowNum, colNum, oldValue, newValue) { return " + this._updateFormula(formula) + "; }")()
		);
		
		//메모리 해제
		formula = null;
	}
	
	//메모리 해제
	formula = null; controlString = null; targetColNums = null; colRangeObj = null;
	
	return;
};

/**
 * @description 
 *    칼럼의 허용가능한 최대값을 변경한다.  <br/>
 *     
 *     - 블럭을 지정해서 최대값을 설정할 수도 잆고, 칼럼번호를 정해서 최대값을 설정할 수 도 있다.<br/>  
 *     - 최대값을 설정기준이 변경되면 시트를 갱신한다.
 * 
 * @param {Number}										maxValue	- 최대 허용길이 (디폴트: 100)  <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                         // 첫번째 칼럼 부터
 * sheet.col2 = 2;                        // 두번째 칼럼까지 
 * sheet.blockMode = true;                // 블럭지정
 * sheet.setMaxValue(1000);             // 칼럼 최대값을 1,000으로 변경
 * sheet.blockMode = false;               // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setMaxValue(10000, 3);              // 3번 칼럼 최대값을 10,000으로 변경
 * sheet.setMaxValue(100000, [3. 4, 5]);     // 3, 4, 5번 칼럼 최대값을 100,000으로 변경
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setMaxValue(1000000, "id");            // "id" 칼럼 최대값을 1,000,000으로 변경
 * sheet.setMaxValue(10000000, ["id", "name"]); // "id", "name" 칼럼 최대값을 10,000,000으로 변경
 */
EasySheet.prototype.setMaxValue = function(maxValue, colRange){
	// functionname : [EasySheet.setMaxValue]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = null;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
					"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
					"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
					"setMaxValue"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setMaxValue");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "maxValue", maxValue);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "maxValue", maxValue);
//		//렌더러
//		//this.sheetRenderer.setColumnInfo(targetColNums[i], {cellType: this.columns[targetColNums[i]].cellType, "maxValue": maxValue});
//		this.sheetRenderer.setColumnInfo(colNum0, {"maxValue": maxValue});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
////	//디자인에 반영되는 속성이 아니므로 시트를 다시 그리지 않음
////	this.updateScreen(SHEET_RESET_DATA_ONLY);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/** 
 * @deprecated since version 5.0, sheet.setMaxValue()으로 대체 
 * */
EasySheet.prototype.setTypeNumMax = function(maxValue, colRange){
	// functionname : [EasySheet.setTypeNumMax]
	
	EasySheet.prototype.setMaxValue.apply(this, arguments);
};

/**
 * @description 
 *    칼럼의 허용가능한 최소값을 변경한다.  <br/>
 *     
 *     - 블럭을 지정해서 최소값을 설정할 수도 잆고, 칼럼번호를 정해서 최소값을 설정할 수 도 있다.<br/>  
 *     - 최소값을 설정기준이 변경되면 시트를 갱신한다.
 * 
 * @param {Number}										minValue	- 최소 허용길이 (디폴트: 100)  <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                         // 첫번째 칼럼 부터
 * sheet.col2 = 2;                        // 두번째 칼럼까지 
 * sheet.blockMode = true;                // 블럭지정
 * sheet.setMinValue(0);                // 칼럼 최소값을 0으로 변경
 * sheet.blockMode = false;               // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setMinValue(1, 3);                  // 3번 칼럼 최소값을 1로 변경
 * sheet.setMinValue(-100, [3. 4, 5]);     // 3, 4, 5번 칼럼 최소값을 -100으로 변경
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setMinValue(-9999, "id");            // "id" 칼럼 최소값을 -9,999으로 변경
 * sheet.setMinValue(-999999, ["id", "name"]); // "id", "name" 칼럼 최소값을 -999,999로 변경
 */
EasySheet.prototype.setMinValue = function(minValue, colRange){
	// functionname : [EasySheet.setMinValue]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = null;

	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setMinValue"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setMinValue");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "minValue", minValue);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "minValue", minValue);
//		//렌더러
//		//this.sheetRenderer.setColumnInfo(targetColNums[i], {cellType: this.columns[targetColNums[i]].cellType, "minValue": minValue});
//		this.sheetRenderer.setColumnInfo(colNum0, {"minValue": minValue});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
////	//디자인에 반영되는 속성이 아니므로 시트를 다시 그리지 않음
////	this.updateScreen(SHEET_RESET_DATA_ONLY);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

EasySheet.prototype.setTypeNumMin = function(minValue, colRange){
	// functionname : [EasySheet.setTypeNumMin]
	
	EasySheet.prototype.setMinValue.apply(this, arguments);
};

/**
 * @description 
 *    음수인 경우 빨간색으로 표시할 지 여부를 지정한다.  <br/>
 *     
 *     - 블럭을 지정해서 표시형태를 변경할 수도 잆고, 칼럼번호를 정해서 표시형태를 변경할 수 도 있다.<br/>  
 *     - 표시형태가 변경되면 시트를 갱신한다.
 * 
 * @param {Boolean|Number}								redded	- 빨간색이 필요한 경우 true 또는 1, 아니면 false 또는 0  <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                         // 첫번째 칼럼 부터
 * sheet.col2 = 2;                        // 두번째 칼럼까지 
 * sheet.blockMode = true;                // 블럭지정
 * sheet.setNegativeRed(true);         	  // 칼럼을 음수인 경우 빨간색으로 표시
 * sheet.blockMode = false;               // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setNegativeRed(false, 3);              // 3번 칼럼을 음수인 경우 빨간색으로 표시
 * sheet.setNegativeRed(true, [3. 4, 5]);     // 3, 4, 5번 칼럼을 음수인 경우 빨간색으로 표시
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setNegativeRed(false, "id");            // "id" 칼럼을 음수인 경우 빨간색으로 표시
 * sheet.setNegativeRed(true, ["id", "name"]); // "id", "name" 칼럼을 음수인 경우 빨간색으로 표시
 */
EasySheet.prototype.setNegativeRed = function(redded, colRange){
	// functionname : [EasySheet.setNegativeRed]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = null;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setNegativeRed"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setNegativeRed");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	if( typeof redded == "number" )
		redded = (redded == 1 ? true : false);
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "negativeRed", redded);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "negativeRed", redded);
//		//렌더러
//		//this.sheetRenderer.setColumnInfo(targetColNums[i], {cellType: this.columns[targetColNums[i]].cellType, "negativeRed": redded});
//		this.sheetRenderer.setColumnInfo(colNum0, {"negativeRed": redded});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/** 
 * @deprecated since version 5.0, sheet.setNegativeRed()으로 대체 
 * */
EasySheet.prototype.setTypeNegativeRed = function(redded, colRange){
	// functionname : [EasySheet.setTypeNegativeRed]
	
	EasySheet.prototype.setNegativeRed.apply(this, arguments);
};

/** 
 * @description 
 *     숫자 칼럼값을 소수점 이하 자릿수를 설정한다 <br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * 
 * 
 * 
 * @param {Number}										digits	-  툴팁 문장 <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                            // 첫번째 칼럼 부터
 * sheet.col2 = 2;                           // 두번째 칼럼까지 
 * sheet.blockMode = true;                   // 블럭지정
 * sheet.setDecimalPlaces(2);                // 칼럼값을 소수점 이하 두자리까지 표시함.
 * sheet.blockMode = false;                  // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setDecimalPlaces(2, 3);              // 3번 칼럼값을 소수점 이하 두자리까지 표시함.
 * sheet.setDecimalPlaces(2, [3. 4, 5]);      // 3, 4, 5번 칼럼값을 소수점 이하 두자리까지 표시함.
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setDecimalPlaces(2, "id");           // "id" 칼럼값을 소수점 이하 두자리까지 표시함.
 * sheet.setDecimalPlaces(2, ["id", "name"]); // "id", "name" 칼럼값을 소수점 이하 두자리까지 표시함.
 */
EasySheet.prototype.setDecimalPlaces = function(digits, colRange){
	// functionname : [EasySheet.setDecimalPlaces]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = null;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setDecimalPlaces"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setDecimalPlaces");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "decimalPlaces", digits);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "decimalPlaces", digits);
//		//렌더러
//		//this.sheetRenderer.setColumnInfo(targetColNums[i], {cellType: this.columns[targetColNums[i]].cellType, "decimalPlaces": digits});
//		this.sheetRenderer.setColumnInfo(colNum0, {"decimalPlaces": digits});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/**
 * @description 
 *     백분율 계산에서 자릿수 처리방침을 설정한다. <br/>
 *     
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * 
 * @param {Number}										digits	- 소수점이하 표시 자릿수  <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                            // 첫번째 칼럼 부터
 * sheet.col2 = 2;                           // 두번째 칼럼까지 
 * sheet.blockMode = true;                   // 블럭지정
 * sheet.setPercentDecimalPoint(2);        // 칼럼을 소수점이하 2자리까지 백분비 표시 
 * sheet.blockMode = false;                  // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setPercentDecimalPoint(2, 3);              // 3번 칼럼을 소수점이하 2자리까지 백분비 표시 
 * sheet.setPercentDecimalPoint(2, [3. 4, 5]);        // 3, 4, 5번 칼럼을 소수점이하 2자리까지 백분비 표시 
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setPercentDecimalPoint(2, "id");              // "id" 칼럼을 소수점이하 2자리까지 백분비 표시 
 * sheet.setPercentDecimalPoint(2, ["id", "name"]); // "id", "name" 칼럼을 소수점이하 2자리까지 백분비 표시 
 */
EasySheet.prototype.setPercentDecimalPoint = function(digits, colRange){
	// functionname : [EasySheet.setPercentDecimalPoint]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var colNum = null;
	var oldUpdateControl = true;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setNegativeRed"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setPercentDecimalPoint");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "percentDecimalPoint", digits);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "percentDecimalPoint", digits);
//		//렌더러
//		//this.sheetRenderer.setColumnInfo(targetColNums[i], {cellType: this.columns[targetColNums[i]].cellType, "percentDecimalPoint": digits});
//		this.sheetRenderer.setColumnInfo(colNum0, {"percentDecimalPoint": digits});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/** 
 * @deprecated since version 5.0, sheet.setPercentDecimalPoint()으로 대체 
 * */
EasySheet.prototype.setTypePercentDecimalNum = function(digits, colRange){
	// functionname : [EasySheet.setTypePercentDecimalNum]
	
	EasySheet.prototype.setPercentDecimalPoint.apply(this, arguments);
};

/**
 * @description 
 *     백분율 계산 에서 정해진 자릿수 이하의 처리방침을 설정한다. <br/>
 *     
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * <table>
 *     <tr style="background-color: #ddd;"><td>COSTANTS</td>
 *     <td>SHEET_PERCENT_CEIL</td><td>SHEET_PERCENT_FLOOR</td><td>SHEET_PERCENT_ROUNDUP</td>
 *     </tr>
 *     <tr><td>string</td>
 *     <td>&quot;ceil&quot;</td><td>&quot;floor&quot;</td><td>&quot;roundUp&quot;</td>
 *     </tr>
 *     <tr><td>number</td>
 *     <td>1</td><td>2</td><td>3</td>
 *     </tr>
 * </table>
 * 
 * @param {String|Number}								decemalCalcType	- SHEET_PERCENT_XXX 상수, 또는 "ceil"와 같은 문자열로 정한다 <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                            // 첫번째 칼럼 부터
 * sheet.col2 = 2;                           // 두번째 칼럼까지 
 * sheet.blockMode = true;                   // 블럭지정
 * sheet.setPercentSet(SHEET_PERCENT_CEIL); // 칼럼을 백분비 계산시 올림 연산
 * sheet.blockMode = false;                  // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setPercentSet(SHEET_PERCENT_FLOOR, 3);              // 3번 칼럼을 백분비 계산시 내림 연산
 * sheet.setPercentSet(SHEET_PERCENT_ROUND, [3. 4, 5]);        // 3, 4, 5번 칼럼을 백분비 계산시 반올림 연산
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setPercentSet(SHEET_PERCENT_CEIL, "id");              // "id" 칼럼을 백분비 계산시 올림 연산
 * sheet.setPercentSet(SHEET_PERCENT_FLOOR, ["id", "name"]); // "id", "name" 칼럼을 백분비 계산시 내림 연산
 */
EasySheet.prototype.setPercentSet = function(decemalCalcType, colRange){
	// functionname : [EasySheet.setPercentSet]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = null;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setPercentSet"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setPercentSet");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "percentSet", decemalCalcType);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	if (decemalCalcType.toLowerCase() == "ceil")         { decemalCalcType = SHEET_PERCENT_CEIL;}
//	else if (decemalCalcType.toLowerCase() == "floor")   { decemalCalcType = SHEET_PERCENT_FLOOR;}
//	else if (decemalCalcType.toLowerCase() == "roundup") { decemalCalcType = SHEET_PERCENT_ROUND;}
//	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "percentSet", decemalCalcType);
//		//렌더러
//		//this.sheetRenderer.setColumnInfo(targetColNums[i], {cellType: this.columns[targetColNums[i]].cellType, "percentSet": decemalCalcType});
//		this.sheetRenderer.setColumnInfo(colNum0, {"percentSet": decemalCalcType});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/** 
 * @deprecated since version 5.0, sheet.setPercentSet()으로 대체 
 * */
EasySheet.prototype.setTypePercentSet = function(decemalCalcType, colRange){
	// functionname : [EasySheet.setTypePercentSet]
	
	EasySheet.prototype.setPercentSet.apply(this, arguments);
};

/**
 * @description 
 *    체크 칼럼의 좌우 정렬 타입을 변경한다.  <br/>
 *     
 *     - 블럭을 지정해서 정렬타입을 변경할 수도 잆고, 칼럼번호를 정해서정렬 타입을 변경할 수 도 있다.<br/>  
 *     - 정렬기준이 변경되면 시트를 갱신한다.
 * 
 * @param {Boolean}										isCenter	- 가운데 정렬인 경우 true, 좌측정렬이면 false  <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                         // 첫번째 칼럼 부터
 * sheet.col2 = 2;                        // 두번째 칼럼까지 
 * sheet.blockMode = true;                // 블럭지정
 * sheet.setCheckCenter(true); 		  // 칼럼을 중앙 정렬 타입으로 변경
 * sheet.blockMode = false;               // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setCheckCenter(false, 3);              // 3번 칼럼을 왼쪽 정렬 타입으로 변경
 * sheet.setCheckCenter(true, [3. 4, 5]);     // 3, 4, 5번 칼럼을 중앙 정렬 타입으로 변경
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setCheckCenter(false, "id");            // "id" 칼럼을 왼쪽 정렬 타입으로 변경
 * sheet.setCheckCenter(true, ["id", "name"]); // "id", "name" 칼럼을 중앙 정렬 타입으로 변경
 */
EasySheet.prototype.setCheckCenter = function(isCenter, colRange){
	// functionname : [EasySheet.setCheckCenter]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var align = null;
	var colNum = null;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else {
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setCheckCenter"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setCheckCenter");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//정렬 설정
	align = isCenter ? SHEET_ALIGN_CENTER : SHEET_ALIGN_LEFT;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "align", align);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	align = null; targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	//컬럼정보 속성 적용(셀 타입이 체크박스인 경우에만 적용)
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		if( this.columns[colNum0].cellType == CELLTYPE_CHECKBOX ){
//			//시트
//			this.setColumnAttributes(colNum, "align", align);
//			//렌더러
//			this.sheetRenderer.setColumnInfo(colNum0, {"align": align} );
//		}
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	align = null; targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/** 
 * @deprecated since version 5.0, sheet.setTypeCheckCenter()으로 대체 
 * */
EasySheet.prototype.setTypeCheckCenter = function(isCenter, colRange){
	// functionname : [EasySheet.setTypeCheckCenter]
	
	EasySheet.prototype.setCheckCenter.apply(this, arguments);
};

/** 
 * @description 
 *     체크박스가 선택되었을 때와 선택되지 않았을 때의 값을 설정한다 <br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 열번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * 
 * @param {String|Number|Boolean}			valueWhenChecked	    - 체크박스가 선택되었을 때 셀값 <br/>
 * @param {String|Number|Boolean}			valueWhenUnchecked	    - 체크박스가 선택해제되었을 때 셀값 <br/>
 * @param {Number|Number[]|undefined}	    [colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 줄번호호로 지정할 경우 
 * sheet.setCheckValue( "1", "0", 2);         // 2번 칼럼 체크박스가 선택되었을 때 "1", 선택되지 않았을 때 "0"의 값을 갖도록 변경 
 * sheet.setCheckValue( true, false, [1, 2]); // 1번, 2번 칼럼 체크박스가 선택되었을 때 "1", 선택되지 않았을 때 "0"의 값을 갖도록 변경 
 * 
 */
EasySheet.prototype.setCheckValue = function(valueWhenChecked, valueWhenUnchecked, colRange){
	// functionname : [EasySheet.setRowTag]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = 0;
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setCheckValue");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;

	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "valueWhenChecked", valueWhenChecked);
	this.setColumnAttributes(targetColNums, "valueWhenUnchecked", valueWhenUnchecked);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;

//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "valueWhenChecked", valueWhenChecked);
//		this.setColumnAttributes(colNum, "valueWhenUnchecked", valueWhenUnchecked);
//		//렌더러
//		//this.sheetRenderer.setColumnInfo(targetColNums[i], {cellType: this.columns[targetColNums[i]].cellType, "valueWhenChecked": valueWhenChecked, "valueWhenUnchecked": valueWhenUnchecked});
//		this.sheetRenderer.setColumnInfo(colNum0, {"valueWhenChecked": valueWhenChecked, "valueWhenUnchecked": valueWhenUnchecked});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/**
 * @description 
 *    버튼 칼럼의 표시 이미지를 변경한다.  <br/>
 *     
 *     - 이미지는 어플리메이션의 ROOT를 기준으로한 상대 경로이다 <br/>  
 *     - 예를 들어 http://www.abcd.com/groupware라면 
 *               "images/btn/abc.jpg" 는 "http://www.abcd.com/groupware/images/btn/abc.jpg"를 의미한다.
 * 
 * @param {String}										imagePathNormal	- 눌리지 않은 정상 상태에서의 버튼셀의 이미지   <br/>
 * @param {String}										imagePathDown	- 눌링 상태에서의 버튼셀의 이미지   <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                                // 첫번째 칼럼 부터
 * sheet.col2 = 2;                               // 두번째 칼럼까지 
 * sheet.blockMode = true;                       // 블럭지정
 * sheet.setButtonImage("a.png","b.jpg");    // 칼럼 정상상태에서의 버튼이미지를 "a.png", 눌렸을때는 "b.jpg"로 변경
 * sheet.blockMode = false;                      // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setButtonImage("a.png","b.jpg", 3);             // 3번 칼럼 정상상태에서의 버튼이미지를 "a.png", 눌렸을때는 "b.jpg"로 변경
 * sheet.setButtonImage("a.png","b.jpg", [3, 4, 5]);     // 3, 4, 5번 칼럼 정상상태에서의 버튼이미지를 "a.png", 눌렸을때는 "b.jpg"로 변경
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setButtonImage("a.png","b.jpg", "id");           // "id" 칼럼 정상상태에서의 버튼이미지를 "a.png", 눌렸을때는 "b.jpg"로 변경
 * sheet.setButtonImage("a.png","b.jpg", ["id", "name"]); // "id", "name" 칼럼 정상상태에서의 버튼이미지를 "a.png", 눌렸을때는 "b.jpg"로 변경
 */
EasySheet.prototype.setButtonImage = function(imagePathNormal, imagePathDown, colRange){
	// functionname : [EasySheet.setButtonImage]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var msg = null;
	var colNum = 0;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setButtonImage"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setButtonImage");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	for(i = 0; i < targetColNums.length; i++){
		colNum = targetColNums[i] - this.startRowColNum;
		
		if( this.columns[colNum].cellType != CELLTYPE_BUTTON ){
			msg = getText("message_EasySheet_021", "버튼타입의 셀이 아니면 버튼 캡션을 설정할 수 없습니다.");
			alert(msg);
			console.warn(msg);
			continue;
		}
		
		this.setColumnAttributes(colNum, "buttonCaption", imagePathNormal);
		this.setColumnAttributes(colNum, "buttonOverCaption", (typeof imagePathDown == "undefined") ? imagePathNormal : imagePathDown);
	}
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();

//	colInfo = {cellType: this.columns[targetColNums[i]].cellType};
//	
//	if( imagePathNormal != null )
//		colInfo["buttonCaption"] = imagePathNormal;
//	if( imagePathDown != null )
//		colInfo["buttonOverCaption"] = imagePathDown;
//
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		column = this.columns[colNum0];
//		
//		if( column.cellType != CELLTYPE_BUTTON ){
//			msg = getText("message_EasySheet_021", "버튼타입의 셀이 아니면 버튼 캡션을 설정할 수 없습니다.");
//			
//			alert(msg);
//			console.warn(msg);
//			
//			continue;
//		}
//		
//		//시트
//		if( imagePathNormal != null )	this.setColumnAttributes(colNum, "buttonCaption", imagePathNormal);
//		if( imagePathDown != null )		this.setColumnAttributes(colNum, "buttonOverCaption", imagePathDown);
//		//렌더러
//		this.sheetRenderer.setColumnInfo(colNum0, colInfo);
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
	
	//메모리 해제
	colInfo = null; targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
};

/** 
 * @deprecated since version 5.0, sheet.setButtonImage()으로 대체 
 * */
EasySheet.prototype.setTypeButtonImage = function(imagePathNormal, imagePathDown, colRange){
	// functionname : [EasySheet.setTypeButtonImage]
	
	EasySheet.prototype.setButtonImage.apply(this, arguments);
};

/**
 * @description 
 *    이미지 칼럼의 대체 텍스트를 변경한다.  <br/>
 *     
 *     - 이미지를 표시하기 어려운 경우나 웹접근성을 위하여 대체 표시될 텍스트 속성을 지정한다.
 * 
 * @param {String}										imageAlt	- 이미지를 대신 할 alt 속성 (String)  <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                                // 첫번째 칼럼 부터
 * sheet.col2 = 2;                               // 두번째 칼럼까지 
 * sheet.blockMode = true;                       // 블럭지정
 * sheet.setTypeImageAlt("대체 텍스트");    	     // 이미지 칼럼 뎇[텍스트를 "대체 텍스트"로 변경
 * sheet.blockMode = false;                      // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setImageAlt("대체 텍스트", 3);             // 3번 이미지 칼럼 뎇[텍스트를 "대체 텍스트"로 변경
 * sheet.setImageAlt("대체 텍스트", [3. 4, 5]);     // 3, 4, 5번 이미지 칼럼 뎇[텍스트를 "대체 텍스트"로 변경
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setImageAlt("대체 텍스트", "id");           // "id" 이미지 칼럼 뎇[텍스트를 "대체 텍스트"로 변경
 * sheet.setImageAlt("대체 텍스트", ["id", "name"]); // "id", "name" 이미지 칼럼 뎇[텍스트를 "대체 텍스트"로 변경
 */
EasySheet.prototype.setImageAlt = function(imageAlt, colRange){
	// functionname : [EasySheet.setImageAlt]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = 0;

	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setImageAlt"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setImageAlt");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "imageAlt", imageAlt);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "imageAlt", imageAlt);
//		//렌더러
//		//this.sheetRenderer.setColumnInfo(targetColNums[i], {cellType: this.columns[targetColNums[i]].cellType, "imageAlt": imageAlt});
//		this.sheetRenderer.setColumnInfo(colNum0, {"imageAlt": imageAlt});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};
/** 
 * @deprecated since version 5.0, sheet.setImageAlt()으로 대체 
 * */
EasySheet.prototype.setTypeImageAlt = function(imageAlt, colRange){
	// functionname : [EasySheet.setTypeImageAlt]
	
	EasySheet.prototype.setImageAlt.apply(this, arguments);
};

/**
 * @description 
 *     mask타입 셀 형식 문자열을 지정한다  예를들어 "____-__-__"  <br/>
 *     
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * 
 * @param {String}										maskText	- mask타입 셀 형식 문자열 기본값 : ""  <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                            // 첫번째 칼럼 부터
 * sheet.col2 = 2;                           // 두번째 칼럼까지 
 * sheet.blockMode = true;                   // 블럭지정
 * sheet.setCellMask("____-__-__"); // mask타입 "____-__-__"을 지정 
 * sheet.blockMode = false;                  // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setCellMask("____-__-__", 3);              // 3번 칼럼 mask타입 "____-__-__"을 지정 
 * sheet.setCellMask("____-__-__", [3. 4, 5]);        // 3, 4, 5번 칼럼 mask타입 "____-__-__"을 지정 
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setCellMask("____-__-__", "id");              // "id" 칼럼 mask타입 "____-__-__"을 지정 
 * sheet.setCellMask("____-__-__", ["id", "name"]); // "id", "name" 칼럼 mask타입 "____-__-__"을 지정 
 */
EasySheet.prototype.setCellMask = function(maskText, colRange){
	// functionname : [EasySheet.setCellMask]

//	var colRangeObj = this.getColRange(colRange, "setCellMask"); 
//	if (colRangeObj == null) return;
//
//	var targetColIds = colRangeObj.targetColIds;
//	var targetColNums = colRangeObj.targetColNums;
//
//	this.setColumnAttributes(targetColNums, "cellMask", maskText);
//
//	// 화면상 시트갱신
//	this.sheetRenderer.setColumnInfo({"CellMask": maskText}, targetColIds);
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);

	return;
};

/** 
 * @deprecated since version 5.0, sheet.setCellMask()으로 대체 
 * */
EasySheet.prototype.setTypeCellMaskTypeValue = function(maskText, colRange){
	// functionname : [EasySheet.setTypeCellMaskTypeValue]
	
	EasySheet.prototype.setCellMask.apply(this, arguments);
};

/**
 * @description 
 *     시간 타입 셀표시 형식을 지정한다 <br/>
 *     - 첫자리(1 : 12시 , 2: 24시), <br/>
 *     - 두번째자리(2 : 시, 4: 분, 6: 초) <br/>
 *     - 23 : 24시간 표시, <br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * 
 * <table>
 *     <tr style="background-color: #ddd;"><td>COSTANTS</td><td>내부값</td><td>적용 CASE</td></tr>
 *     <tr><td>SHEET_TIME_FORMAT_12HR_DISPLAY_HOUR</td><td>12</td><td>12시 단위표시하고, 시간까지 표시</td></tr>
 *     <tr><td>SHEET_TIME_FORMAT_12HR_DISPLAY_MINS</td><td>14</td><td>12시 단위표시하고, 분단위까지 표시</td></tr>
 *     <tr><td>SHEET_TIME_FORMAT_12HR_DISPLAY_SCNDS</td><td>16</td><td>12시 단위표시하고, 초단위까지 표시</td></tr>
 *     <tr><td>SHEET_TIME_FORMAT_24HR_DISPLAY_HOUR</td><td>22</td><td>12시 단위표시하고, 시간까지 표시</td></tr>
 *     <tr><td>SHEET_TIME_FORMAT_24HR_DISPLAY_MINS</td><td>24</td><td>12시 단위표시하고, 분단위까지 표시</td></tr>
 *     <tr><td>SHEET_TIME_FORMAT_24HR_DISPLAY_SCNDS</td><td>26</td><td>12시 단위표시하고, 초단위까지 표시</td></tr>
 * </table>
 * 
 * 
 * @param {Number}										timeDisplayFormat	-  시간 타입 셀표시 형식 <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                            // 첫번째 칼럼 부터
 * sheet.col2 = 2;                           // 두번째 칼럼까지 
 * sheet.blockMode = true;                   // 블럭지정
 * sheet.setTimeFormat(SHEET_TIME_FORMAT_24HR_DISPLAY_SCNDS); // 칼럼을 24시 기준 초단위까지 표시
 * sheet.blockMode = false;                  // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setTimeFormat(SHEET_TIME_FORMAT_24HR_DISPLAY_SCNDS, 3);              // 3번 칼럼을 24시 기준 초단위까지 표시
 * sheet.setTimeFormat(SHEET_TIME_FORMAT_24HR_DISPLAY_SCNDS, [3. 4, 5]);      // 3, 4, 5번 칼럼을 24시 기준 초단위까지 표시
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setTimeFormat(SHEET_TIME_FORMAT_24HR_DISPLAY_SCNDS, "id");           // "id" 칼럼을 24시 기준 초단위까지 표시
 * sheet.setTimeFormat(SHEET_TIME_FORMAT_24HR_DISPLAY_SCNDS, ["id", "name"]); // "id", "name" 칼럼을 24시 기준 초단위까지 표시
 */
EasySheet.prototype.setTimeFormat = function(timeDisplayFormat, colRange){
	// functionname : [EasySheet.setTimeFormat]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = null;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setTimeFormat"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setTimeFormat");
	
	//열 범위를 못 구한 경우
	if (colRangeObj == null) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "timeFormat", timeDisplayFormat);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "timeFormat", timeDisplayFormat);
//		//렌더러
//		//this.sheetRenderer.setColumnInfo(targetColNums[i], {cellType: this.columns[targetColNums[i]].cellType, "timeFormat": timeDisplayFormat});
//		this.sheetRenderer.setColumnInfo(colNum0, {"timeFormat": timeDisplayFormat});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/** 
 * @deprecated since version 5.0, 칼럼정보를 sheet.setTimeFormat()으로 대체 
 * */
EasySheet.prototype.setTypeCellTime1224 = function(timeDisplayFormat){
	// functionname : [EasySheet.setTypeCellTime1224]
	
	this.setTimeFormat(timeDisplayFormat);
};

/**
 * @description 
 *     날자 타입 셀표시 형식을 지정한다 <br/>
 *     년도는 yyyy, 월은 mm, 일자는 dd 로 표시한다.
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * 
 * 
 * @param {String}										dateDisplayFormat	-  시간 타입 셀표시 형식 <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                            // 첫번째 칼럼 부터
 * sheet.col2 = 2;                           // 두번째 칼럼까지 
 * sheet.blockMode = true;                   // 블럭지정
 * sheet.setDateFormat("yyyy-mm-dd");// 칼럼을 "yyyy-mm-dd" 형식으로 표시
 * sheet.blockMode = false;                  // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setDateFormat("yyyy-mm-dd", 3);              // 3번 칼럼을  "yyyy-mm-dd" 형식으로 표시
 * sheet.setDateFormat("yyyy-mm-dd", [3. 4, 5]);      // 3, 4, 5번 칼럼을  "yyyy-mm-dd" 형식으로 표시
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setDateFormat("yyyy-mm-dd", "id");           // "id" 칼럼을  "yyyy-mm-dd" 형식으로 표시
 * sheet.setDateFormat("yyyy-mm-dd", ["id", "name"]); // "id", "name" 칼럼을  "yyyy-mm-dd" 형식으로 표시
 */
EasySheet.prototype.setDateFormat = function(dateDisplayFormat, colRange){
	// functionname : [EasySheet.setDateFormat]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = null;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setDateFormat"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setDateFormat");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "dateFormat", dateDisplayFormat);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "dateFormat", dateDisplayFormat);
//		//렌더러
//		//this.sheetRenderer.setColumnInfo(targetColNums[i], {cellType: this.columns[targetColNums[i]].cellType, "dateFormat": dateDisplayFormat});
//		this.sheetRenderer.setColumnInfo(colNum0, {"dateFormat": dateDisplayFormat});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/** 
 * @deprecated since version 5.0, sheet.setDateFormat()으로 대체 
 * */
EasySheet.prototype.setTypeCellDateFormat = function(dateDisplayFormat, colRange){
	// functionname : [EasySheet.setTypeCellDateFormat]
	
	EasySheet.prototype.setDateFormat.apply(this, arguments);
};

/** 
 * @deprecated since version 5.0, 칼럼정보를 sheet.setDateFormat()으로 대체 
 * */
EasySheet.prototype.setTypeTypedateformat = function(dateDisplayFormat){
	// functionname : [EasySheet.setTypeTypedateformat]
	
	this.setTypeCellDateFormat(dateDisplayFormat);
};

/** 
 * @description 
 *     Date 타입 셀 년월일 체크 옵션을 지정한다 <br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * 
 * <table>
 *     <tr style="background-color: #ddd;"><td>COSTANTS</td><td>내부값</td><td>적용 CASE</td></tr>
 *     <tr><td>SHEET_DATE_CHECK_FORMAT_YYYYMMDD</td>      <td>0</td><td>년월일 체크</td></tr>
 *     <tr><td>SHEET_DATE_CHECK_FORMAT_YYYYMM</td>        <td>1</td><td>년월 체크</td></tr>
 *     <tr><td>SHEET_DATE_CHECK_FORMAT_YYYY</td>          <td>2</td><td>년도 체크</td></tr>
 *     <tr><td>SHEET_DATE_CHECK_FORMAT_YYYYMMDDHHNNSS</td><td>3</td><td>년월일시분초 체크</td></tr>
 *     <tr><td>SHEET_DATE_CHECK_FORMAT_YYYYMMDDHHNN</td>  <td>4</td><td>년월일시분 체크</td></tr>
 *     <tr><td>SHEET_DATE_CHECK_FORMAT_YYYYMMDDHH</td>    <td>5</td><td>년월일시 체크</td></tr>
 *     <tr><td>SHEET_DATE_CHECK_FORMAT_HHNNSS</td>        <td>6</td><td>시분초 체크</td></tr>
 *     <tr><td>SHEET_DATE_CHECK_FORMAT_HHNN</td>          <td>7</td><td>시분 체크</td></tr>
 *     <tr><td>SHEET_DATE_CHECK_FORMAT_HH</td>            <td>8</td><td>시간 체크</td></tr>
 * </table>
 * 
 * 
 * @param {Number}										dateCheckFormat	-  시간 타입 셀표시 형식 <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;                            // 첫번째 칼럼 부터
 * sheet.col2 = 2;                           // 두번째 칼럼까지 
 * sheet.blockMode = true;                   // 블럭지정
 * sheet.setCheckFormat(SHEET_DATE_CHECK_FORMAT_YYYYMMDD);// 칼럼을 년월일 체크
 * sheet.blockMode = false;                  // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setCheckFormat(SHEET_DATE_CHECK_FORMAT_YYYYMMDD, 3);              // 3번 칼럼을  년월일 체크
 * sheet.setCheckFormat(SHEET_DATE_CHECK_FORMAT_YYYYMMDD, [3. 4, 5]);      // 3, 4, 5번 칼럼을  년월일 체크
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setDateCheckFormat(SHEET_DATE_CHECK_FORMAT_YYYYMMDD, "id");           // "id" 칼럼을  년월일 체크
 * sheet.setCheckFormat(SHEET_DATE_CHECK_FORMAT_YYYYMMDD, ["id", "name"]); // "id", "name" 칼럼을  년월일 체크
 */
EasySheet.prototype.setCheckFormat = function(dateCheckFormat, colRange){
	// functionname : [EasySheet.setCheckFormat]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = null;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setCheckFormat"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setCheckFormat");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "checkFormat", dateCheckFormat);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "checkFormat", dateCheckFormat);
//		//렌더러
//		//this.sheetRenderer.setColumnInfo(targetColNums[i], {cellType: this.columns[targetColNums[i]].cellType, "checkFormat": dateCheckFormat});
//		this.sheetRenderer.setColumnInfo(colNum0, {"checkFormat": dateCheckFormat});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};
/** 
 * @deprecated since version 5.0, sheet.setAlign()으로 대체 
 * */
EasySheet.prototype.setTypeCheckFormat = function(dateCheckFormat, colRange){
	// functionname : [EasySheet.setTypeCheckFormat]
	
	EasySheet.prototype.setCheckFormat.apply(this, arguments);
};

/** 
 * @description 
 *     칼럼의 값을 편집 불가능하게 하여 데이터를 보호한다.<br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * 
 * @param {Boolean}										lockMode	            - 표시형식 문자열 <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;               // 첫번째 칼럼 부터
 * sheet.col2 = 2;              // 두번째 칼럼까지 
 * sheet.blockMode = true;      // 블럭지정
 * sheet.setLockMode(true);     // 칼럼 값을 편집 불가능하게 편집기능을 잠금
 * sheet.blockMode = false;     // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setLockMode(true, 3);              // 3번 칼럼 값을 편집 불가능하게 편집기능을 잠금
 * sheet.setLockMode(true, [3. 4, 5]);      // 3, 4, 5번 칼럼 값을 편집 불가능하게 편집기능을 잠금
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setLockMode(true, "id");           // "id" 칼럼 값을 편집 불가능하게 편집기능을 잠금
 * sheet.setLockMode(true, ["id", "name"]); // "id", "name" 칼럼 값을 편집 불가능하게 편집기능을 잠금
 */
EasySheet.prototype.setLockMode = function(lockMode, colRange){
	// functionname : [EasySheet.setLockMode]
	
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var oldUpdateControl = true;
	var colNum = null;
	
	if( typeof colRange == "undefined" ){
		if( this.blockMode ){
			colRange = [];
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setLockMode"
			));
			return;
		}
	}
	
	//열 범위 구함
	colRangeObj = this.getColRange(colRange, "setLockMode");
	
	//열 범위를 못 구한 경우
	if( colRangeObj == null ) return;
	
	//열 정보
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(targetColNums, "lockMode", lockMode);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null;
	
	return;
	
//	//컬럼정보 속성 적용
//	for(i = 0; i < targetColNums.length; i++){
//		colNum = targetColNums[i];
//		colNum0 = colNum - this.startRowColNum;
//		
//		//시트
//		this.setColumnAttributes(colNum, "lockMode", lockMode);
//		//렌더러
//		this.sheetRenderer.setColumnInfo(colNum0, {"lockMode": lockMode});
//		
//		//메모리 해제
//		colNum = null; colNum0 = null;
//	}
//	
//	//렌더러 디자인 변경
//	this.updateScreen(SHEET_RESET_DESIGN_TOO);
//	
//	//메모리 해제
//	targetColNums = null; targetColIds = null; colRangeObj = null;
//	
//	return;
};

/** 
 * @deprecated since version 5.0,  
 * */
EasySheet.prototype.rowLocked = function(rowNum){
	// functionname : [EasySheet.rowLocked]
	
	return false;
};

/** 
 * @description 
 *     셀의 연산에 필요한 산식을 문자열로 등록한다<br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * 
 * @param {String}										formula	                - 산식 문자열 <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * @param {Number|Number[]|undefined}	                [rowRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 셀타입을 설정할 경우 
 * sheet.col = 1;               // 첫번째 칼럼 부터
 * sheet.col2 = 2;              // 두번째 칼럼까지 
 * sheet.bformula = true;       // 블럭지정
 * sheet.setFormula( "1 + 1" ); // 칼럼 산식을 "1 + 1"로 변경 
 * sheet.bformula = false;      // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setFormula( 3, "1 + 1");              // 3번 칼럼 산식을 "1 + 1"로 변경 
 * sheet.setFormula( [3. 4, 5], "1 + 1");      // 3, 4, 5번 칼럼 산식을 "1 + 1"로 변경 
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setFormula( "id", "1 + 1");           // "id" 칼럼 산식을 "1 + 1"로 변경 
 * sheet.setFormula( ["id", "name"], "1 + 1"); // "id", "name" 칼럼 산식을 "1 + 1"로 변경 
 * 
 * // 줄번호, 칼럼번호로 지정할 경우 
 * sheet.setFormula( 2, 3, "1 + 1");              // 2번줄 3번 칼럼 산식을 "1 + 1"로 변경 
 * sheet.setFormula( [1,2], [3. 4, 5]"1 + 1");  // 1번, 2번줄 3, 4, 5번 칼럼 산식을 "1 + 1"로 변경 
 * 
 * // 줄번호, 칼럼명으로 지정할 경우  
 * sheet.setFormula( 3, "id", "1 + 1");                // 3번줄 "id" 칼럼 산식을 "1 + 1"로 변경 
 * sheet.setFormula( [4, 5], ["id", "name"], "1 + 1"); // 4번, 5번줄 "id", "name" 칼럼 산식을 "1 + 1"로 변경 
 */
EasySheet.prototype.setFormula = function(/* formula, rowRange, colRange */){
	// functionname : [EasySheet.setFormula]
	
	var args = Array.prototype.slice.call(arguments);
	var rowRange = null;
	var colRange = null;
	var formula = "";
	var rowNum0 = 0; var colNum0 = 0;
	var rowNum = 0; var colNum = 0;
	
	if( args.length == 1 ){
		if( this.blockMode ){ 
			rowRange = [];
			colRange = [];
			
			if( this.row == -1 ){
				for(rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++)
					rowRange.push(rowNum0 + this.startRowColNum);
			}
			else{
				for(rowNum = this.row; rowNum <= this.row2; rowNum++)
					rowRange.push(rowNum);
			}
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",  
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" + 
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setFormula"
			));
			return;
		}
		
		formula = args[0];
	}
	else if( args.length == 2 ){
		colRange = args[0];
		formula = args[1];
	}
	else{
		rowRange = args[0];
		colRange = args[1];
		formula = args[2];
	}
	
	var rowRangeObj = null;
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	var rowNums = null;
	var colNums = null;
	var found = false;
	var added = null;
	var removed = null;
	var i = 0, j = 0;
	
	colRangeObj = this.getColRange(colRange, "setFormula");
	
	if( colRangeObj == null ){
		//메모리 해제
		formula = null;
		colRange = null;
		rowRange = null;
		args = null;
		return;
	}
	
	formula = this._convertColumnToRCofFormula(formula);
	
	rowRangeObj = (rowRange == null || typeof rowRange == "undefined") ? null: this.getRowRange(rowRange, "setFormula");
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	rowNums = [];
	colNums = targetColNums;
	
	if( rowRangeObj == null ){
		this.setColumnAttributes(targetColNums, "formula", formula);	// 칼럼단위 산식인 경우
		
		for(rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) rowNums.push(rowNum0 + this.startRowColNum);
	}
	else{
		this.setCellAttributes(rowRangeObj.targetRowNums, targetColNums, "formula", formula);	// 셀단위 산식인 경우 
		
		rowNums = rowRangeObj.targetRowNums;
	}
	
	for (i = 0; i < rowNums.length; i++) {
		rowNum = rowNums[i];
		rowNum0 = rowNum - this.startRowColNum;
		found = true;
		
		if( this._isUnvalidRowNum(rowNum, "sheet.setFormula") )
			continue;
		
		if( this.needGrouping && this.sumUp._isLogicalRow(rowNum0) )
			continue;
		
		for(j = 0; j < colNums.length; j++){
			colNum = colNums[j];
			
			// 산식이 있으면 산식을 계산하고
			if( formula.trim().length > 0 ){
				added = this._addToFormulaRefs(rowNum, colNum, formula);
				
				if( this.autoCalc && added )
					this.calculateCell(rowNum, colNum);
			}
			else{
				// 있는데 없에면 지운다 
				removed = this._removeFormula(rowNum, colNum);
				
				if( removed ){
					colNum0 = colNum - this.startRowColNum;
					column = this.columns[colNum0];
					
					if( [CELLTYPE_NUMBER, CELLTYPE_PERCENT, CELLTYPE_INTEGER, CELLTYPE_BAR
					     , CELLTYPE_CURRENCY, CELLTYPE_FLOAT, CELLTYPE_CHECKBOX].indexOf(column.cellType) >= 0 )
						this.setValueToCell(0, rowNum, colNum);
					else
						this.setValueToCell("", rowNum, colNum);
				}
			}
		}
	}
	
	if( this.needGrouping && found ){ 
		if( rowNums.length > 1 )
			this.sumUp.resetGroup();	// 여러줄 변경된 경우 
		else
			this.sumUp._RefreshGroupByOneData(rowNums[0]);	// 한셀만 변경된 경우 
	}
	
	//메모리 해제
	colRangeObj = null; rowRangeObj = null;
	targetColIds = null; targetColNums = null; colNums = null; rowNums = null;
	formula = null; colRange = null; rowRange = null; args = null;
	
	return;
};

/** 
 * @description 
 *     셀의 연산에 필요한 산식을 문자열로 등록한다<br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 열번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * 
 * @param {Number|Number[]|undefined}	                [rowRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * @param {String}										formula	                - 산식 문자열 <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 줄번호호로 지정할 경우 
 * sheet.setRowFormula( 2, "1 + 1");       // 2번줄 산식을 "1 + 1"로 변경 
 * sheet.setRowFormula( [1, 2], "1 + 1");  // 1번, 2번줄 산식을 "1 + 1"로 변경 
 * 
 */
EasySheet.prototype.setRowFormula = function(rowRange, formula){
	// functionname : [EasySheet.setRowFormula]
	
	var rowRangeObj = null;
	var rowNums = null;
	var added = null;
	var rowNum0 = 0;
	var colNum0 = 0;
	var rowNum = 0;
	var colNum = 0;
	var i = 0;
	
	rowRangeObj = this.getRowRange(rowRange, "setRowFormula");
	
	if( rowRangeObj == null ) return;

	rowNums = rowRangeObj.targetRowNums;
	
	this.setRowAttributes(rowRangeObj.targetRowNums, "formula", formula);
	
	for(colNum0 = 0; colNum0 < this.maxCols; colNum0++) {
		colNum = colNum0 - this.startRowColNum;

		for(i = 0; i < rowNums.length; i++) {
			rowNum = rowNums[i];
			rowNum0 = rowNum - this.startRowColNum;
			
			if( this.needGrouping && this.sumUp._isLogicalRow(rowNum0) )
				continue;

			added = this._addToFormulaRefs(rowNum, colNum, formula);
			
			if( this.autoCalc && added )
				this.calculateCell(rowNum, colNum);
		}
	}
	
	if( this.needGrouping ){
		if( rowNums.length > 1 )
			this.sumUp.resetGroup();	// 여러줄 변경된 경우
		else
			this.sumUp._RefreshGroupByOneData(rowNums[0]);	// 한셀만 변경된 경우
	}
	
	//메모리 해제
	rowNums = null; rowRangeObj = null;
	
	return;
};

/** 
 * @description 
 *     셀의 연산에 필요한 태그 메모값을 문자열로 등록한다<br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * 
 * @param {String}										tag	                - 태그 메모값 문자열 <br/>
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	    - 변경하게 될 셀영역이다. <br/>
 * @param {Number|Number[]|undefined}	                [rowRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 칼럼 구간을 주어 태그 메모값을 설정할 경우 
 * sheet.col = 1;           // 첫번째 칼럼 부터
 * sheet.col2 = 2;          // 두번째 칼럼까지 
 * sheet.btag = true;       // 블럭지정
 * sheet.setTag( "this is memo" ); // 칼럼 태그 메모값을 "this is memo"로 변경 
 * sheet.btag = false;      // 블럭해제    
 * 
 * // 칼럼번호로 지정할 경우 
 * sheet.setTag( "this is memo", 3);              // 3번 칼럼 태그 메모값을 "this is memo"로 변경 
 * sheet.setTag( "this is memo", [3. 4, 5]);      // 3, 4, 5번 칼럼 태그 메모값을 "this is memo"로 변경 
 * 
 * // 칼럼명으로 지정할 경우  
 * sheet.setTag( "this is memo", "id");           // "id" 칼럼 태그 메모값을 "this is memo"로 변경 
 * sheet.setTag( "this is memo", ["id", "name"]); // "id", "name" 칼럼 태그 메모값을 "this is memo"로 변경 
 * 
 * // 줄번호, 칼럼번호로 지정할 경우 
 * sheet.setTag( "this is memo", 2, 3);              // 2번줄 3번 칼럼 태그 메모값을 "this is memo"로 변경 
 * sheet.setTag( "this is memo", [1,2], [3. 4, 5]);  // 1번, 2번줄 3, 4, 5번 칼럼 태그 메모값을 "this is memo"로 변경 
 * 
 * // 줄번호, 칼럼명으로 지정할 경우  
 * sheet.setTag( "this is memo", 3, "id");                // 3번줄 "id" 칼럼 태그 메모값을 "this is memo"로 변경 
 * sheet.setTag( "this is memo", [4, 5], ["id", "name"]); // 4번, 5번줄 "id", "name" 칼럼 태그 메모값을 "this is memo"로 변경 
 */
EasySheet.prototype.setTag = function(/* tag, rowRange, colRange */){
	// functionname : [EasySheet.setTag]
	
	var args = Array.prototype.slice.call(arguments);
	var rowRange = null;
	var colRange = null;
	var tag = "";
	
	if( args.length == 1 ){
		tag = args[0];
		
		if( this.blockMode ){
			rowRange = [];
			colRange = [];
			
			if( this.row == -1 ){
				for(rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++)
					rowRange.push(rowNum0 + this.startRowColNum);
			}
			else{
				for(rowNum = this.row; rowNum <= this.row2; rowNum++)
					rowRange.push(rowNum);
			}
			
			for(colNum = this.col; colNum <= this.col2; colNum++)
				colRange.push(colNum);
		}
		else{
			alert(getText(	"message_EasySheet_009",
							"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.\n" +
							"블럭모드로 범위를 지정하거나 인수를 사용하여 범위를 지정해 주십시오.",
							"setTag"
			));
			return;
		}
	}
	else if( args.length == 2 ){
		tag = args[0];
		colRange = args[1];
	}
	else{
		tag = args[0];
		rowRange = args[1];
		colRange = args[2];
	}
	
	var rowRangeObj = null;
	var colRangeObj = null;
	var targetColIds = null;
	var targetColNums = null;
	
	colRangeObj = this.getColRange(colRange, "setTag");
	
	if (colRangeObj == null){
		//메모리 해제
		tag = null; colRange = null; rowRange = null; args = null;
		return;
	}
	
	targetColIds = colRangeObj.targetColIds;
	targetColNums = colRangeObj.targetColNums;
	
	rowRangeObj = this.getRowRange(rowRange, "setTag");
	
	if( rowRangeObj == null )
		this.setColumnAttributes(targetColNums, "tag", tag);
	else
		this.setCellAttributes(rowRangeObj.targetRowNums, targetColNums, "tag", tag);	// 셀단위 태그 메모값인 경우
	
	//메모리 해제
	targetColNums = null; targetColIds = null; colRangeObj = null; rowRangeObj = null;
	tag = null; colRange = null; rowRange = null; args = null;
	
	return;
};

/**
 * @description 
 *     범위를 정하여 메모된 테그값을 가져오는 명령이다
 * 
 * @param {Number|undefined}	[rowNum=currentRow]	- 변경하게 될 셀영역이다. this.startRowColNum이 반영된 줄번호이다<br/>
 * @param {Number|undefined}	[colNum=currentCol]	- 변경하게 될 셀영역이다. this.startRowColNum이 반영된 열번호이다<br/>
 * 
 * @return {void} 

 * @example
 * var tag = sheet.getTag();       // 현재줄, 현재 칼럼의 메모된 테그값을 가져옴
 * var tag = sheet.getTag(2);      // 2번줄, 현재 칼럼의 메모된 테그값을 가져옴 
 * var tag = sheet.getTag(2, 3);   // 2번줄 3번 메모된 테그값을 가져옴 
 * 
 */
EasySheet.prototype.getTag = function(){
	// functionname : [EasySheet.getTag]
	
	var args = Array.prototype.slice.call(arguments);
	
	// 콤보 스타일에서 인수는 Logical 줄,열번호이다
	var rowNum = this.currentRow;
	var rowNum0 = rowNum - this.startRowColNum;
	var colNumOrId = this.currentCol;
	var colId = null;
	var tag = null;
	
	if( args.length == 1 ){
		colNumOrId = args[0];
	}
	else if( args.length >= 2 ){
		rowNum0 = args[0] - this.startRowColNum;
		colNumOrId = args[1];
	}
	
	colId = (typeof colNumOrId == "string") ? colNumOrId : this.getColId(colNumOrId);
	
	if( this._isUnvalidColId(colId, "sheet.getTag") )
		tag = null;
	else
		tag = this.getCellAttribute(rowNum0, colId, "tag");
	
	//메모리 해제
	colId = null;
	
	return tag;
};

/** 
 * @description 
 *     셀의 연산에 필요한 태그 메모값을 문자열로 등록한다<br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 열번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 연산기준이 변경되면 시트를 갱신한다.
 * 
 * @param {String}										tag	                - 태그 메모값 문자열 <br/>
 * @param {Number|Number[]|undefined}	                [rowRange=Block Rage]	- 변경하게 될 셀영역이다. <br/>
 * 
 * @return {void} 	
 * 		
 * @example
 * // 줄번호호로 지정할 경우 
 * sheet.setRowTag( "this is memo" , 2);       // 2번줄 태그 메모값을 "this is memo"로 변경 
 * sheet.setRowTag( "this is memo" , [1, 2]);  // 1번, 2번줄 태그 메모값을 "this is memo"로 변경 
 * 
 */
EasySheet.prototype.setRowTag = function(tag, rowRange){
	// functionname : [EasySheet.setRowTag]
	
	var rowRangeObj = this.getRowRange(rowRange, "setRowTag");
	
	if( rowRangeObj == null ) return;
	
	this.setRowAttributes(rowRangeObj.targetRowNums, "tag", tag);
	
	//메모리 해제
	rowRangeObj = null;
	
	return;
};

/** 
 * @description 
 *     범위를 정하여 Row에 메모된 테그값을 가져오는 명령이다
 * 
 * 
 * @param {Number|undefined}	[rowNum=currentRow]	- 변경하게 될 셀영역이다. this.startRowColNum이 반영된 줄번호이다<br/>
 * 
 * @return {void} 

 * @example
 * var tag = sheet.getRowTag();       // 현재줄의 메모된 테그값을 가져옴
 * var tag = sheet.getRowTag(2);      // 2번줄의 메모된 테그값을 가져옴 
 * 		
 * @example
 * // 줄번호호로 지정할 경우 
 * sheet.setRowTag( "this is memo" , 2);       // 2번줄 태그 메모값을 "this is memo"로 변경 
 * sheet.setRowTag( "this is memo" , [1, 2]);  // 1번, 2번줄 태그 메모값을 "this is memo"로 변경 
 * 
 */
EasySheet.prototype.getRowTag = function(rowNum){
	// functionname : [EasySheet.getRowTag]

	var args = Array.prototype.slice.call(arguments);
	var tag = null;
	
	if( typeof rowNum == "undefined" ){
		rowNum = this.currentRow;
	}
	
	tag = this.getRowAttribute(rowNum, "tag");
	
	//메모리 해제
	args = null;

	return tag;
};

//Renderer 이관영역 =================================================

//deprecated since version 5.0, 렌더러로 이동 
//EasySheet.prototype._canFocusToControl = function(){
//	return this.sheetRenderer._canFocusToControl();
//};

//deprecated since version 5.0, 렌더러로 이동 
//EasySheet.prototype._hideCellEdit = function(){
//	this.sheetRenderer.hideCellEdit();	
//};

//deprecated since version 5.0, 렌더러로 이동 
//EasySheet.prototype._hideCellCombo = function(){
//	this.sheetRenderer.hideCellCombo();
//};

//deprecated since version 5.0, 렌더러로 이동 
//EasySheet.prototype._getSetPosition= function(rowNum, colNum){
//	this.sheetRenderer.moveTo(rowNum, colNum);
//};

//deprecated since version 5.0, 렌더러로 이동 
//EasySheet.prototype._setEditControlPosition = function(){
//	this.sheetRenderer._setEditControlPosition();
//};

EasySheet.prototype.getColumnTitle = function(colNumOrId){
	// functionname : [EasySheet.getColumnTitle]
	
	// 단일행 헤더의 경우에만 가능
	var colNum = (typeof colNumOrId == "string") ? this.getColNum(colNumOrId) : colNumOrId;
	
	// 컬럼 ID 를 구하지 못한 경우
	if( this._isUnvalidColNum(colNum, "sheet.getColumnTitle") )
		return null;

//	return this.columns[colNum - this.startRowColNum].caption;
	return this.getColumnAttribute(colNum, "caption");
};

EasySheet.prototype.setColumnTitle = function(colNumOrId, captionHTML){
	// functionname : [EasySheet.setColumnTitle]
	
	// 단일행 헤더의 경우에만 가능
	var oldUpdateControl = this.instantUpdateControl;
	var colNum = (typeof colNumOrId == "string") ? this.getColNum(colNumOrId) : colNumOrId;
	
	//컬럼 ID 를 구하지 못한 경우
	if( this._isUnvalidColNum(colNum, "sheet.setColumnTitle") )
		return;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
//	this.setColumnAttributes(colNum, "caption", captionHTML);
	this.setColumnAttribute(colNum, "caption", captionHTML);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
};

EasySheet.prototype.getHeaderTitle = function(rowNum, colNum){
	// functionname : [EasySheet.getAddedHeaderTitle]
	
	if( typeof rowNum != "number" ) return null;
	rowNum = rowNum - this.startRowColNum;
	
	if( typeof colNum != "number" ) return null;
	colNum = colNum - this.startRowColNum;
	
	return this.sheetRenderer.getTitle(rowNum, colNum);
};

EasySheet.prototype.setHeaderTitle = function(rowNum, colNum, captionHTML){
	// functionname : [EasySheet.setAddedHeaderTitle]
	
	if( typeof rowNum != "number" ) return null;
	rowNum = rowNum - this.startRowColNum;
	
	if( typeof colNum != "number" ) return null;
	colNum = colNum - this.startRowColNum;
	
	return this.sheetRenderer.setTitle(rowNum, colNum,captionHTML);
};

EasySheet.prototype.hideColumn = function(colNumOrId){
	// functionname : [EasySheet.hideColumn]
	
	var oldUpdateControl = this.instantUpdateControl;
	var colNum = (typeof colNumOrId == "string") ? this.getColNum(colNumOrId) : colNumOrId;
	
	//컬럼 ID 변환 실패한 경우
	if( this._isUnvalidColNum(colNum, "sheet.hideColumn") )
		return;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(colNum, "hidden", true);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
};

EasySheet.prototype.showHiddenColumn = function(colNumOrId){
	// functionname : [EasySheet.showHiddenColumn]
	
	var oldUpdateControl = this.instantUpdateControl;
	var colNum = (typeof colNumOrId == "string") ? this.getColNum(colNumOrId) : colNumOrId;
	
	//컬럼 ID 변환 실패한 경우
	if( this._isUnvalidColNum(colNum, "sheet.hideColumn") )
		return;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(colNum, "hidden", false);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
	if( this.instantUpdateControl )
		this.sheetRenderer.redraw();
};

EasySheet.prototype.hideRow = function(rowNum){
	// functionname : [EasySheet.hideRow]
	
	var oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	this.setRowAttribute(rowNum, "hidden", true);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
//	//
//	if( this.displayInfo.startRow + this.displayInfo.dataCount > this.getVisibleRowCount() ){
//		this.displayInfo.startRow--;
//	}
	
	//렌더러 디자인 변경
//	if( this.instantUpdateControl ) this.updateScreen(SHEET_RESET_DESIGN_TOO);
	if( this.instantUpdateControl ) this.updateScreen();
};

EasySheet.prototype.showHiddenRow = function(rowNum){
	// functionname : [EasySheet.showHiddenRow]
	
	var oldUpdateControl = this.instantUpdateControl;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;

	this.setRowAttribute(rowNum, "hidden", false);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	//렌더러 디자인 변경
//	if( this.instantUpdateControl ) this.updateScreen(SHEET_RESET_DESIGN_TOO);
	if( this.instantUpdateControl ) this.updateScreen();
};

/** 
 * @deprecated since version 5.0, 폐기, 스타일 처리 
 * */
EasySheet.prototype.getOddEvenStyle = function(hardRowNum){
	// functionname : [EasySheet.getOddEvenStyle]
	
	return this.sheetRenderer.getOddEvenStyle(hardRowNum);
};

/** 
 * @deprecated since version 5.0, 폐기, 스타일 처리 
 * */
EasySheet.prototype.refreshOddEven = function(){
	// functionname : [EasySheet.refreshOddEven]
	
	this.sheetRenderer.refreshOddEven();
};

/** 
 * @deprecated since version 5.0, 폐기, 렌더러에서 처리 
 * */
//EasySheet.prototype._getRealHeight = function(hardRowNum){
//	return this.sheetRenderer._getRealHeight(hardRowNum);
//};
/** 
 * @deprecated since version 5.0, 렌더러에서 처리 
 * */
EasySheet.prototype.isVisibleCol = function(colNum){
	// functionname : [EasySheet.isVisibleCol]
	
	return !this.columns[colNum - this.startRowColNum].hidden;
};
/** 
 * @deprecated since version 5.0, 렌더러에서 처리 
 * */
EasySheet.prototype.isVisibleRow = function(rowNum){
	// functionname : [EasySheet.isVisibleRow]
	
	return !this.rows(rowNum - this.startRowColNum).hidden;
};

EasySheet.prototype.moveToFirstCell = function(rowNum){
	// functionname : [EasySheet.moveToFirstCell]
	
	if( this._isUnvalidRowNum(rowNum, "sheet.moveToFirstCell") )
		return;
	
	this.sheetRenderer.moveToFirstCell(rowNum - this.startRowColNum);
};

EasySheet.prototype.moveToNextCell = function(rowNum, colNum){
	// functionname : [EasySheet.moveToNextCell]
	
	if( typeof rowNum == "undefined" )
		rowNum = this.currentRow;
	if( typeof colNum == "undefined" )
		colNum = this.currentCol;
	
	if( this._isUnvalidRowNum(rowNum, "sheet.moveToNextCell") || this._isUnvalidColNum(colNum, "sheet.moveToNextCell") )
		return;
	
	var rowNum0 = rowNum - this.startRowColNum;
	var colNum0 = colNum - this.startRowColNum;
	
	this.sheetRenderer.moveToNextCell(rowNum0, colNum0);
};
EasySheet.prototype.moveToFormerCell = function(rowNum, colNum){
	// functionname : [EasySheet.moveToNextCell]
	
	if( typeof rowNum == "undefined" )
		rowNum = this.currentRow;
	if( typeof colNum == "undefined" )
		colNum = this.currentCol;
	
	if( this._isUnvalidRowNum(rowNum, "sheet.moveToFormerCell") || this._isUnvalidColNum(colNum, "sheet.moveToFormerCell") )
		return;
	
	var rowNum0 = rowNum - this.startRowColNum;
	var colNum0 = colNum - this.startRowColNum;
	
	this.sheetRenderer.moveToFormerCell(rowNum0, colNum0);
};
EasySheet.prototype.moveToUpperCell = function( rowNum, colNum){
	// functionname : [EasySheet.moveToUpperCell]
	
	if( typeof rowNum == "undefined" )
		rowNum = this.currentRow;
	if( typeof colNum == "undefined" )
		colNum = this.currentCol;
	
	if( this._isUnvalidRowNum(rowNum, "sheet.moveToUpperCell") || this._isUnvalidColNum(colNum, "sheet.moveToUpperCell") )
		return;
	
	var rowNum0 = rowNum - this.startRowColNum;
	var colNum0 = colNum - this.startRowColNum;
	
	this.sheetRenderer.moveToUpperCell(rowNum0, colNum0);
};

EasySheet.prototype.moveToLowerCell = function(rowNum, colNum){
	// functionname : [EasySheet.moveToLowerCell]
	
	if( typeof rowNum == "undefined" )
		rowNum = this.currentRow;
	if( typeof colNum == "undefined" )
		colNum = this.currentCol;
	
	if( this._isUnvalidRowNum(rowNum, "sheet.moveToLowerCell") || this._isUnvalidColNum(colNum, "sheet.moveToLowerCell") )
		return;
	
	var rowNum0 = rowNum - this.startRowColNum;
	var colNum0 = colNum - this.startRowColNum;
	
	this.sheetRenderer.moveToLowerCell(rowNum0, colNum0);
};
EasySheet.prototype.moveToLeftCell = function(rowNum, colNum){
	// functionname : [EasySheet.moveToLeftCell]
	
	if( typeof rowNum == "undefined" )
		rowNum = this.currentRow;
	if( typeof colNum == "undefined" )
		colNum = this.currentCol;
	
	if( this._isUnvalidRowNum(rowNum, "sheet.moveToLeftCell") || this._isUnvalidColNum(colNum, "sheet.moveToLeftCell") )
		return;
	
	var rowNum0 = rowNum - this.startRowColNum;
	var colNum0 = colNum - this.startRowColNum;
	
	this.sheetRenderer.moveToLeftCell(rowNum0, colNum0);
};
EasySheet.prototype.moveToRightCell = function(rowNum, colNum){
	// functionname : [EasySheet.moveToRightCell]
	
	if( typeof rowNum == "undefined" )
		rowNum = this.currentRow;
	if( typeof colNum == "undefined" )
		colNum = this.currentCol;
	
	if( this._isUnvalidRowNum(rowNum, "sheet.moveToRightCell") || this._isUnvalidColNum(colNum, "sheet.moveToRightCell") )
		return;
	
	var rowNum0 = rowNum - this.startRowColNum;
	var colNum0 = colNum - this.startRowColNum;
	
	this.sheetRenderer.moveToRightCell(rowNum0, colNum0);
};

EasySheet.prototype.moveTo = function(rowNum, colNum){
	// functionname : [EasySheet.moveTo]
	
	if( this._isUnvalidRowNum(rowNum, "sheet.moveTo") || this._isUnvalidColNum(colNum, "sheet.moveTo") )
		return;
	
	var rowNum0 = rowNum - this.startRowColNum;
	var colNum0 = colNum - this.startRowColNum;
	
	this.sheetRenderer.moveTo(rowNum0, colNum0);
};

EasySheet.prototype.scrollTo = function(rowNum, colNum){
	// functionname : [EasySheet.scrollTo]
	
	if( typeof rowNum == "undefined" )
		rowNum = this.currentRow;
	if( typeof colNum == "undefined" )
		colNum = this.currentCol;
	
	if( this._isUnvalidRowNum(rowNum0 + this.startRowColNum, "sheet.scrollTo") || this._isUnvalidColNum(colNum0 + this.startRowColNum, "sheet.scrollTo") )
		return;
	
	var rowNum0 = rowNum - this.startRowColNum;
	var colNum0 = colNum - this.startRowColNum;
	var redraw = false;
	
	if( rowNum != this.currentRow || colNum != this.currentCol )
		redraw = true;
	
	this.sheetRenderer.moveTo(rowNum0, colNum0);
	
	if( redraw )
		this.sheetRenderer.redraw();
};

EasySheet.prototype.moveToRow = function(rowNum){
	// functionname : [EasySheet.moveToRow]
	
	if( this._isUnvalidRowNum(rowNum, "sheet.moveToRow") )
		return;
	
	var rowNum0 = rowNum - this.startRowColNum;
//	var colNum0 = (this.currentCol < this.startRowColNum) ? this.startRowColNum : this.currentCol;	//임시조치
	var colNum0 = (this.currentCol < this.startRowColNum) ? this.startRowColNum : ((this.currentCol + 1 - this.startRowColNum > this.maxCols) ? this.startRowColNum : this.currentCol);
	
	this.moveTo(rowNum0, colNum0);
	
//	this.sheetRenderer.redraw();
};


EasySheet.prototype.selectRow = function(rowNum){
	// functionname : [EasySheet.selectRow]
	
	if( this._isUnvalidRowNum(rowNum, "sheet.moveToRow") )
		return;
	
	if( this.currentRow == rowNum )
		return;
	
	this.moveToRow(rowNum);
	
	if( this.hasClickEvent && this.FireEvent ){
		this.fncClickEvent(this.currentRow, this.currentCol);
	}
};

//가져오기에서 채운후 사용한다 
EasySheet.prototype.selectFirstRow = function(){
	// functionname : [EasySheet.selectFirstRow]

	// 강제로 object의 1번 데이터로 키퀀스 변경시 동작을 일으킨다
	if( this.currentRow == this.startRowColNum ){
		var objectSeq = this.getRowAttribute(this.startRowColNum, "objectSeq");   // this.startRowColNum이 반영된 줄번호를 인자로 받는다.
		var dataObject = null;
		var dataObjectCount = this.linkedObjects.length;
		var rowId = null;
		var i = 0;
		
		for(i = 0; i < dataObjectCount; i++){
			dataObject = this.linkedObjects[i];
			
			if( dataObject.hasSeqChangeEvent ){
				dataObject.fncSeqChangeEvent(this.startRowColNum, objectSeq);
			}
			
			dataObject = null;
		}
		
		//데이터셋 처리
		if( this.linkedDataset != null && typeof this._UpdateDatasetRowPos != "undefined" ){
			rowId = this.rows(this.startRowColNum).rowId;
			//해당 행의 레코드가 존재할 경우
			if( typeof rowId != "undefined" && rowId != null ){
				this._UpdateDatasetRowPos(rowId);
			}
			//메모리 해제
			rowId = null;
		}
	}
	
//	// 시트의 디스플레이를 갱신한다
//	this.currentRow = this.startRowColNum;
//	this.currentCol = this.startRowColNum;
	
	this.moveTo(this.startRowColNum, this.startRowColNum);
};

EasySheet.prototype.clearSelection = function(){
	return this.sheetRenderer.clearSelection();
};

EasySheet.prototype.completeEditing = function(applyEditingValue){
	//파라메터가 없는 경우 현재 편집중인 데이터를 적용 후 편집 상태를 종료함
	if( typeof applyEditingValue == "undefined" ) applyEditingValue = true;
	//파라메터 예외처리
	if( typeof applyEditingValue != "boolean" ) return false;
	
	//편집 상태 종료
	return this.sheetRenderer.completeSheetEditing(applyEditingValue);
};

/** 
 * @deprecated since version 5.0, 폐기, 렌더러에서 처리 
 * */
//EasySheet.prototype._focusableRightColNum = function(rowNum, colNum) {
//  var rowNum0 = rowNum - this.startRowColNum;
//  var colNum0 = colNum - this.startRowColNum;
//	this.sheetRenderer._focusableRightColNum(rowNum0, colNum0);
//};
/** 
 * @deprecated since version 5.0, 폐기, 렌더러에서 처리 
 * */
//EasySheet.prototype._focusableLeftColNum = function(rowNum, colNum) {
//  var rowNum0 = rowNum - this.startRowColNum;
//  var colNum0 = colNum - this.startRowColNum;
//	this.sheetRenderer._focusableLeftColNum(rowNum0, colNum0);
//};

/** 
 * @description 
 *     시트의 스크롤시 상단에 고장되어 움직이지 않는 줄수를 의미한다<br/>논리적인 줄수로 레코드수를 의미한다 
 *
 * @param {Number}	count	- 논리적인 줄수로 레코드수를 의미한다
 *     
 * @return 	{Void}									
 * 		
 * @example
 * sheet.setTopFrozenCount(2);  // 상단에 두개의 레코드가 고정된다 
 */
EasySheet.prototype.setTopFrozenCount = function(count){
	// functionname : [EasySheet.setTopFrozenCount]
	
	if( typeof count == "undefined" )
		return false;;
	
	this.sheetRenderer.setTopFrozenCount(count);
	
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
//	this.updateScreen();
	
	return true;
};

EasySheet.prototype.setSelectMode = function(selectMode){
	// functionname : [EasySheet.setTopFrozenCount]
	
	if( selectMode == SHEET_SELECT_NONE || selectMode == SHEET_SELECT_CELL || selectMode == SHEET_SELECT_ROW ){
		this.sheetRenderer.selectMode = selectMode;
	}
};

EasySheet.prototype.setRowClass = function(rowStyleClass, doRedraw){
	// functionname : [EasySheet.setRowClass]
	
	this.rowClass = rowStyleClass;
	this.sheetRenderer.rowStyleClass = rowStyleClass;
	
	if( doRedraw === true )
		this.sheetRenderer.redraw();
};

EasySheet.prototype.setColClass = function(colNumOrId, columnStyleClass, doRedraw){
	// functionname : [EasySheet.setColClass]
	
	var oldUpdateControl = this.instantUpdateControl;
	var colNum = (typeof colNumOrId != "number") ? colNumOrId : this.getColNum(colNumOrId);
	
	if( this._isUnvalidColNum(colNum, "sheet.getColumnTitle") )
		return null;
	
	//셀 타입 수정 중 시트 디자인에 반영하지 않음
	this.instantUpdateControl = false;
	
	//컬럼정보 속성 적용
	this.setColumnAttributes(colNum, "columnClass", columnStyleClass);
	
	//셀타입 수정 완료 후 이전 상태로 복구
	this.instantUpdateControl = oldUpdateControl;
	
	if( doRedraw === true )
		this.sheetRenderer.redraw();
};

EasySheet.prototype.setColumnClass = function(colNumOrId, columnStyleClass, doRedraw){
	// functionname : [EasySheet.setColumnClass]
	
	this.setColClass(colNumOrId, columnStyleClass, doRedraw);
};

//EasySheet.prototype.setColHeadClass = function(em){
//	this.sheetRenderer.setColHeadClass(em);
//};

//EasySheet.prototype.setPickHeaderClass = function(rowNum, colNum, className){
//  var rowNum0 = rowNum - this.startRowColNum;
//  var colNum0 = colNum - this.startRowColNum;
//	this.sheetRenderer.setPickHeaderClass(rowNum0, colNum0, className);
//};

//EasySheet.prototype.setCellClass = function(em, rowNum, colNum){
//  var rowNum0 = rowNum - this.startRowColNum;
//  var colNum0 = colNum - this.startRowColNum;
//	this.sheetRenderer.setPickHeaderClass(em, rowNum0, colNum0);
//};

//EasySheet.prototype._setFocusToNonEditableCell = function(rowNum, colNum){
//  var rowNum0 = rowNum - this.startRowColNum;
//  var colNum0 = colNum - this.startRowColNum;
//	this.sheetRenderer.moveTo(rowNum0, colNum0);
//};

EasySheet.prototype.shtControlSet = function(rowNum, colNumOrId){
	// functionname : [EasySheet.shtControlSet]
	
	// 행번호 체크
	if( typeof rowNum == "undefined" ){
		rowNum = this.currentRow;
	}
	else{
		if( this._isUnvalidRowNum(rowNum, "sheet.moveToFirstCell") )
			return;
	}
	
	if( typeof colNumOrId == "undefined" ){
		colNumOrId = this.currentCol;
	}
	else if( typeof colNumOrId == "string" ){
		if( this._isUnvalidColId(colNumOrId, "sheet.getCellAttribute") )
			return undefined;
		
		colNumOrId = this.getColNum(colNumOrId);
	}
	else{
		if( this._isUnvalidColNum(colNumOrId, "sheet.getColumnTitle") )
			return null;
	}
	
	var rowNum0 = rowNum - this.startRowColNum;
	var colNum0 = colNumOrId - this.startRowColNum;
	
	this.sheetRenderer.setSheetEditControl(rowNum0, colNum0);
};

EasySheet.prototype.focus = function(){
	// functionname : [EasySheet.focus]
	
	if( typeof this.sheetRenderer.focus != "undefined" ) 
		this.sheetRenderer.focus();
};

EasySheet.prototype.resetScroll = function(realRowCount){
	this.sheetRenderer.resetScroll();
};

EasySheet.prototype.resetRowNum = function(startRowNum){
	if( typeof startRowNum == "undefined" )
		startRowNum = 1;
	
	this.sheetRenderer.resetRowNum(startRowNum);
};

EasySheet.prototype.renumRows = function(startRowNum){
	this.resetRowNum(startRowNum);
};

//deprecated since version 5.0, 폐기 
//EasySheet.prototype.renumCols = function(){
//	this.sheetRenderer.renumCols();
//};

//deprecated since version 5.0, 폐기 
//EasySheet.prototype.scrollAction = function(scrollTop, scrollLeft){
//	this.sheetRenderer.scrollAction(scrollTop, scrollLeft);
//};

EasySheet.prototype.setPosition = function(left, top, width, height){
	this.sheetRenderer.setPosition(left, top, width, height);
};

EasySheet.prototype.updateScreen = function(needReset){
	// functionname : [EasySheet.updateScreen]
	
	if( !this.instantUpdateControl ) return;
	
//	var needReset = typeof needReset == "undefined" ? false : needReset;  // 디자인이 바뀌면 true, 데이터만 바뀌면 false
	
	if( this.pivot != null ){
		//json["footers"] = this.pivot.footerInfos;
		//this.sheetRenderer.update(json, needReset);
		//json.footers = null;
		
		if( typeof this.createPivotSheet == "function" ){
			this.createPivotSheet(needReset);
		}
	}
	else{
		var json = {
			displayInfo: this.displayInfo
			, columns: []
			/*, rowNums: []*/
			, footers: null
		};
		
		this.columns.forEach(
			function(column, colIndex){
				json.columns.push({
					colId : column.colId,
					colIndex : colIndex,		// 0부터 시작
					cellType : column.cellType,
					sheetRow : column.sheetRow,
					sheetCol : column.sheetCol,
					sheetRowSpan : column.sheetRowSpan,
					sheetColSpan : column.sheetColSpan
				});
			}, this);
		
		// 참고: Array.prototype.forEach() -> IE 9+, FF 1.5+, common.js에 foreach 추가됨
		// 피벗이 있는 경우 피벗에서 이미 leftFrozens, rightFrozens, bottomFrozens 대입했음 
		if (this.pivot == null){  
			this.displayInfo.leftFrozens = this.sheetRenderer.leftFixColumnCount;
			this.displayInfo.rightFrozens = this.sheetRenderer.rightFixColumnCount;
		}
		
		var footerInfos = null; var footerInfo = null;
		var footer = null; var func = null; var value = null;
		var footerCount = this.footers.length;
		var i = 0;
		
		if( footerCount > 0 ){
			footers = json["footers"] = [];
			
			for(i = 0; i < footerCount; i++, footer = null, footerInfo = null){
				footer = this.footers[i];
				footerInfo = footers[i] = {};
				
				if( typeof footer.sheetRow != "undefined" )		footerInfo.sheetRow = footer.sheetRow;
				if( typeof footer.sheetCol != "undefined" )		footerInfo.sheetCol = footer.sheetCol;
				if( typeof footer.sheetRowSpan != "undefined" )	footerInfo.sheetRowSpan = footer.sheetRowSpan;
				if( typeof footer.sheetColSpan != "undefined" )	footerInfo.sheetColSpan = footer.sheetColSpan;
				
				if( typeof footer.colId != "undefined" )		footerInfo.colId = footer.colId;
				if( typeof footer.colDataType != "undefined" )	footerInfo.colDataType = footer.colDataType;
				if( typeof footer.align != "undefined" )		footerInfo.align = footer.align;
				if( typeof footer.vAlign != "undefined" )		footerInfo.vAlign = footer.vAlign;
				if( typeof footer.foreColor != "undefined" )	footerInfo.foreColor = footer.foreColor;
				if( typeof footer.backColor != "undefined" )	footerInfo.backColor = footer.backColor;
				if( typeof footer.showFooter != "undefined" )	footerInfo.showFooter = footer.showFooter;
				
				if( typeof footer.columnClass != "undefined" && footer.columnClass != null ){
					func = new Function("return function (sheet, rowNum) { return " + this._updateFormula(footer.columnClass) + "; }")();
					footerInfo.columnStyleClass = func(this, -1);
					func = null;
				}
				
				if( typeof footer.formula != "undefined" && footer.formula != null ){
					func = new Function("return function (sheet, rowNum) { return " + this._updateFormula(footer.formula) + "; }")();
					value = footerInfo.value = (this.pivot == null ? func(this, -1) : this.pivot.footerInfos[i].value);
					if( value == null || typeof value == "undefined" || (typeof value == "number" && isNaN(value) == true) ) footerInfo.value = "";
					func = null; value = null;
				}
			}
			
			footers = null;
		}
		
		this.sheetRenderer.update(json, needReset);
		
		//메모리 해제
		//푸터
		if( typeof json.footers != "undefined" && json.footers != null ){
			json.footers.clear();
			json.footers = null;
		}
		//컬럼
		if( typeof json.columns != "undefined" && json.columns != null ){
			json.columns.clear();
			json.columns = null;
		}
		//디스플레이 정보
		json.displayInfo = null;
		json = null;
	}
	
	return;
	
	/*
	var rowCountOfFrozenTop = this.displayInfo.topFrozens;
	var rowNumOfBottom = this.displayInfo.bottomFrozens;
	var rowCountOfData = this.displayInfo.dataCount;
	var rowNumToStart = this.displayInfo.startRow;
	var rowNumToEnd = 0;
	var emptyCount = 0;
	var rowNum0 = 0;
	var rowNum = 0;
	var i = 0;
	
	var data = this.dataSet.data;
	var footers = null;
	var footer = null;
	var column = null;
	var func = null;
	
	// 시작줄이 고정 줄수 보다 큰경우 
	if( this.displayInfo.startRow >= rowCountOfFrozenTop ){
		this.displayInfo.endRow = rowNumToStart + rowCountOfData - 1 - rowCountOfFrozenTop;
//		this.displayInfo.endRow = rowNumToStart + rowCountOfData - rowCountOfFrozenTop;
	}
	else if( this.displayInfo.startRow < rowCountOfFrozenTop ){
		rowNumToStart = rowCountOfFrozenTop;	// 고정줄 다음줄을 StartRow로 한다.
		this.displayInfo.endRow = rowCountOfData - 1;
	}
	
	// footer를 찍게 되면 데이터 한개를 더 못찍게 된다 
	if( this.footers.length > 0 ){
		this.displayInfo.endRow--;
	}
	
	// 마지막줄번호가 최대 레코드 번호를 초과하면 마지막 줄번호 대입
	if( this.displayInfo.endRow >= this.dataSet.data.length ){
		emptyCount = this.displayInfo.endRow - this.dataSet.data.length + 1;
		this.displayInfo.endRow = this.dataSet.data.length - 1;
	}
	
	rowNumToEnd = this.displayInfo.endRow;
	
	// 상단 고정 데이터 보내기
	this.dataSet.data.forEach(
			function(row, rowIndex){
				if( rowIndex >= rowCountOfFrozenTop ) return;
				json.rowNums.push(rowIndex);
			}, this);
	
	// 메인 데이터
	for(rowNum0 = rowNumToStart; rowNum0 <= rowNumToEnd && rowNum0 < data.length; rowNum0++){
		rowNum = rowNum0 + this.startRowColNum;
		
		// this.startRowColNum이 반영된 줄번호를 인자로 받는다.
		if( this.getRowAttribute(rowNum, "hidden") || this.getRowAttribute(rowNum,  "filterd") ){
			++rowNumToEnd;
			continue;
		}
		
		json.rowNums.push(rowNum0);
	}
	
//	this.displayInfo = {startRow:0, endRow:0, dataCount:20, rowsPerDataRow:2, 
//						leftFrozens:0, rightFrozens:0, topFrozens:0, bottomFrozens:0};	// 여기서 Row는 모두 레코드 기준, 사이즈가 줄면 이것도 조정된다 
	
	// 머지정보를 렌더러로 보내기 전에 갱신 
	this.refreshCellMerge();
	
	// 만약에 뿌릴 데이터가 없으면 null을 넣어준다.
	for(i = 0; i < emptyCount; i++){
		json.rowNums.push(null);
	}
	
	// 하단고정데이터
	if( this.pivot != null ){  
		json["footers"] = this.pivot.footerInfos;
	}
	else{
		footers = json["footers"] = [];
		
		for(i = 0; i < this.footers.length; i++){
			column = this.footers[i];
			func = new Function("return function (sheet, rowNum) { return " + this._updateFormula(column.formula) + "; }")();
			footer = footers[i] = {};
			
			if( typeof column.sheetRow != "undefined" )		footer.sheetRow = column.sheetRow;
			if( typeof column.sheetCol != "undefined" )		footer.sheetCol = column.sheetCol;
			if( typeof column.sheetRowSpan != "undefined" )	footer.sheetRowSpan = column.sheetRowSpan;
			if( typeof column.sheetColSpan != "undefined" )	footer.sheetColSpan = column.sheetColSpan;
			if( typeof column.showFooter != "undefined" )	footer.showFooter = column.showFooter;
			if( typeof column.footerHeight != "undefined" )	footer.footerHeight = column.footerHeight;
			if( typeof column.align != "undefined" )		footer.align = column.align;
			if( typeof column.colWidth != "undefined" )		footer.colWidth = column.colWidth;
			
			footer.value = (this.pivot == null ? func(this, -1) : this.pivot.footerInfos[i].value);
			
			//메모리 해제
			footer = null; func = null; column = null;
		}
	}
	
	if( typeof TEST_MODE_JSON != "undefined" )
		TEST_MODE_JSON = json;
	
	this.sheetRenderer.updateScreen(this, json, needReset);
	
	//메모리 해제
	footers = null; data = null; json = null; needReset = null;
	*/
};

/*
* TD 객체로 데이터 셀을 찾음
*/
EasySheet.prototype.getDataCell = function(em){
	// functionname : [EasySheet.getDataCell]
	
	var row = em.parentNode;
	
	// 현재 줄번호를 서칭해서 대입하고
	var rowNum = this.rowNumOf(row.rowIndex, getCellIndex(em), CONV_HARD_LOGICAL);
	var colNum = this.colNumOf(row.rowIndex, getCellIndex(em), CONV_HARD_LOGICAL);
	var rowNum0 = rowNum - this.startRowColNum;
	var colNum0 = colNum - this.startRowColNum;
	
	var colId = this.columns[colNum0].colId;
	
	return this.dataSet.data[rowNum0][colId];
};

/**@
데이터를 물리적인셀에 뿌려준다.
*/
EasySheet.prototype.displayCell = function(rowNum, colNum){
	// functionname : [EasySheet.displayCell]
	
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
	this.updateScreen();
};

EasySheet.prototype.displayBlock = function(colRange){
	// functionname : [EasySheet.displayBlock]
	
	var colRangeObj = this.getColRange(colRange, "displayBlock"); 
	
	if( colRangeObj == null )
		return;
	
	var targetColIds = colRangeObj.targetColIds;
	
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
	this.updateScreen();
};

//EasySheet.prototype.writeTopCaption = function(height, data, capStyle){
//	
//	// ??? 
//	this.sheetRenderer.writeTopCaption(height, data, capStyle);
//};
//
//EasySheet.prototype.writeBottomCaption = function(height, data, capStyle){
//	
//	// ??? 
//	this.sheetRenderer.writeBottomCaption(height, data, capStyle);
//};

//Renderer 이벤트 영역 =================================================
//렌더러에서 이벤트 일으킨다. 여기서는 삭제
//function cmbCell_onBlur(e){}
//function call_cmbCell_onBlur(em){} 

//function cell_onBlur(e){}
//function call_cell_onBlur(em){}

//function cell_onChange(e){}

//function cell_onKeyPress(e){}
//function cell_onKeyDown(e){}
//function cell_onKeyUp(e){}

//function cell_onCommandMouseOut(em){}
//function cell_onCommandMouseOver(em){}
//function cell_onCommandClick(em, rowNum, colNum){}
//function cell_onImageClick(em, rowNum, colNum){}

//function cell_onTreeClick(e){}
//function cell_onClick(em, value){}


//EasySheet.prototype.click = function(em){
//	// Renderer로 옮기고 데이터에 과련한 돈작은 Renderer가 호출하는 catchEvent() 에서 해결한다. 
//};

//function keyAction(name, direction){
//	// Renderer로 옮기고 데이터에 과련한 돈작은 Renderer가 호출하는 catchEvent() 에서 해결한다. 
//};

/*
EasySheet.prototype.addComboInfo = function(colNum, text, value){
	
};

EasySheet.prototype.clsComboInfo = function(colNum){
	
};

function clearLists(element){
	// 차대리: clearLists 소스젠 xsl 변경
};

function copyLists(element1, element2){
	// 차대리: clearLists 소스젠 xsl 변경
};
*/

/*	Renderer 이벤트 받는 부분  =================================================
 * 	startRowColNum이 반영된 줄번호 리턴
 */
EasySheet.prototype._catchEvent = function(eventInfo){
	var result = true;
	
	if( eventInfo.event == "click" ){
		/* {event:"click", row:1, col:1, newRow:3, newCol:3} */
		// CHECKBOX 일경우 처리부분은 "valuechange" 도 넘어온다
		
		this.currentRow = eventInfo.newRow + this.startRowColNum;
		this.currentCol = eventInfo.newCol + this.startRowColNum;
		
		// 시트 이벤트 : click 호출(시작)
		if( this.hasClickEvent && this.FireEvent){
			// 이벤트 호출
			result = this.fncClickEvent(this.currentRow, this.currentCol);
		}
		
		return result;
	}
	else if( eventInfo.event == "dblclick" ){
		var rowNum1 = eventInfo.row + this.startRowColNum;
		var colNum1 = eventInfo.col + this.startRowColNum;
		
		// 시트 이벤트 : double click 호출(시작)
		if( this.hasDblClickEvent && this.FireEvent){
			// 이벤트 호출
			result = this.fncDblClickEvent(rowNum1, colNum1);
		}
		
		return result;
	}
	else if( eventInfo.event == "cmdclick" ){
		this.currentRow = eventInfo.newRow + this.startRowColNum;
		this.currentCol = eventInfo.newCol + this.startRowColNum;
		
		// 시트 이벤트 : CommandClick 호출(시작)
		if( this.hasCommandClickEvent && this.FireEvent){
			// 이벤트 호출
			result = this.fncCommandClickEvent(this.currentRow, this.currentCol);
		}
		
		return result;
	}
	else if( eventInfo.event == "change" ){
		/* {event:"change", row:1, col:1, oldValue:3, newValue:3} */
		
		var rowNum = eventInfo.row + this.startRowColNum;
		var colId = this.columns[eventInfo.col].colId;
//		var isCombo = (this.columns[eventInfo.col].cellType == CELLTYPE_COMBOBOX);
//		var record = {};
		
//		// 데이터 갱신을 위함 레코드 생성
//		record[colId] = eventInfo.newValue;
//		// 데이터 및 updateGu 갱신
//		this.dataSet.updateData(eventInfo.row, record);
//		//
//		if( isCombo ) this.dataSet.setState(eventInfo.row, colId + ".TEXT", eventInfo.newText);
		
//		//시트 이벤트 : Chnage 호출(시작)
//		if( this.hasChangeEvent && this.FireEvent){
//			//이벤트 호출
//			result = this.fncChangeEvent(
//						eventInfo.row + this.startRowColNum
//						, eventInfo.col + this.startRowColNum
//						, eventInfo.newValue
//						, eventInfo.oldValue
//					 );
//			
//			//이벤트 처리 결과가 false 인 경우 데이터를 다시 oldValue 로 복구
//			if( typeof result == "boolean" && result != true ){
//				//데이터 복구을 위함 레코드 생성
//				record[colId] = eventInfo.oldValue;
//				//데이터 및 updateGu 복구
//				this.dataSet.updateData(eventInfo.row, record);
//				//
//				if( isCombo ) this.dataSet.setState(eventInfo.row, colId + ".TEXT", eventInfo.oldText);
//			}
//		}
		
		//데이터 갱신, 그루핑 등 후속 처리 및 이벤트 발생
		this.setValue(rowNum, colId, eventInfo.newValue);
		
		//메모리 해제
//		record = null;
		colId = null;
		
		return result;
	}
	else if( eventInfo.event == "sort" ){
		/* {event:"sort", colId:"a1", colNum:3, order:SHEET_SORT_ORDER_ASCENDING} */
		
		return this.sort(eventInfo, false);
	}
	else if( eventInfo.event == "filter" ){
		/* {event:"filter", colId:"a1", colNum:3, filteringType:, formula: 'a==1'} */
		
		return this.filter(eventInfo, false);
	}
	else if( eventInfo.event == "unfilter" ){
		/*{event:"unfilter", colId:"a1", colNum:3}*/
		
		return this.unfilter(eventInfo, false);
	}
	else if( eventInfo.event == "expandTree" ){
		/*{event:"expandTree", rowNum:3, colId:"a1"}*/
		
		return this.treeCellOpen(eventInfo.rowNum, eventInfo.colId);
	}
	else if( eventInfo.event == "foldTree" ){
		/* {event:"foldTree", colId:"a1", colNum:3} */
		
		return this.treeCellClose(eventInfo.rowNum, eventInfo.colId);
	}
	else if( eventInfo.event == "scroll" ){
		/* {event:"scroll", oldTopIndex: 99, newTopIndex: 100, lastIndex: 120, pageSize: 15} */
		
		if( this.hasScrollEvent ){
			result = this.fncScrollEvent(eventInfo.oldTopIndex, eventInfo.newTopIndex, eventInfo.lastIndex, eventInfo.pageSize); 
		}
		
		return result;
		
//		this.displayInfo.startRow = eventInfo.topRowIndex;
//		this.displayInfo.endRow = eventInfo.topRowIndex + eventInfo.pageSize;
		
		// 단일 열 인 경우, 렌더러에서 데이터 이동
//		this.updateScreen(SHEET_RESET_DATA_ONLY);
	}
	else if( eventInfo.event == "rowChange" ){
		/*{event:"rowChange", rowNum: 100}*/
		
		var oldRowNum0 = eventInfo.row;
		var oldRowNum1 = oldRowNum0 + this.startRowColNum;
		
//		this.currentRow = eventInfo.newRow + this.startRowColNum;
		this.setCurrentRow(eventInfo.newRow + this.startRowColNum);
		
		// 시트 사용자 이벤트가 있는 경우
		if( this.hasRowChangeEvent && this.FireEvent){
			//이벤트 호출
			result = this.fncRowChangeEvent(oldRowNum1, this.currentRow, this.rows(this.currentRow).objectSeq);
//			result = this.fncRowChangeEvent(oldRowNum1, this.currentRow, this.getObjectSeqOfRowNum(this.currentRow));
			
			// 시트 이벤트 : RowChange 사용자 추가 로직 동작까지 정상적으로 완료되지 않았다면 행 인덱스를 이전으로 복구
			if( typeof result == "boolean" && result != true ){
				this.currentRow = oldRowNum1;
			}
		}
		
		return result;
	}
	else if( eventInfo.event == "colChange" ){
		/* {event:"scroll", newCol: 20} */
		var colNum0 = eventInfo.newCol;
		var oldColNum0 = eventInfo.col;
		var oldColNum1 = oldColNum0 + this.startRowColNum;
		
		this.currentCol = colNum0 + this.startRowColNum;
		
		//시트 이벤트 : ColChange 호출(시작)
		if( this.hasColChangeEvent && this.FireEvent){
			//이벤트 호출
			result = this.fncColChangeEvent(oldColNum1, this.currentCol);

			//시트 이벤트 : ColChange 사용자 추가 로직 동작까지 정상적으로 완료되지 않았다면 열 인덱스를 이전으로 복구
			if( typeof result == "boolean" && result != true ){
				this.currentCol = oldColNum1;
			}
		}
		
		return result;
	}
//	else if( eventInfo.event == "initialized" ){
//		/* {event:"initialized", pageSize: 15} */
//		this.displayInfo.startRow = 0;
//		this.displayInfo.endRow = pageSize;
//	}
	
	return result;
};

EasySheet.prototype._catchValidate = function(rowNum0, colNumOrId0, value) {
	// functionname : [EasySheet._catchValidate]
	
	// 차대리: 일자타입, 시간 타입 오류 체크 --> Renderer
	// 차대리: 숫자값 MAX, Min, MaxLength 체크 --> Renderer
	
	var rowNum = rowNum0 + this.startRowColNum;
	var colNum = (typeof colNumOrId0 == "number") ? colNumOrId0  + this.startRowColNum : this.getColNum(colNumOrId0);
	var colNum0 = colNum - this.startRowColNum;
	var column = null;
	var oldValue = null;
	var msg = null;
	var correct = true;
	
	// 컬럼을 찾을 수 없는 경우 예외처리
	if( colNum == null ) return false;
	
	// 유효성 검증할 데이터가 비어있다면 톻과
	if( ("" + value).length == 0 ) return true;
	
	column = this.columns[colNum0];
	oldValue = this.getValue(rowNum, colNum);
	
	// 체크조건에 따른 유효성 체크
	try{
		switch(column.checkType){
		case CEHCK_TYPE_NONE :				//체크없음: 통과
			break;
		case CEHCK_TYPE_FORMULA :			//체크산식: 통과
			break;
		case CEHCK_TYPE_YYYY :				//년도
			if( hasHangul(value) )			throw CEHCK_TYPE_IMEMODE;	//한글 체크
			if( !CheckYear(value) )			throw CEHCK_TYPE_YYYY;		//년도 체크
			break;
		case CEHCK_TYPE_YM :				//년월
			if( hasHangul(value) )			throw CEHCK_TYPE_IMEMODE;	//한글 체크
			if( !CheckMonth(value) )		throw CEHCK_TYPE_YM;		//년월 체크
			break;
		case CEHCK_TYPE_YMD :				//년월일
			if( hasHangul(value) )			throw CEHCK_TYPE_IMEMODE;	//한글 체크
			if( !CheckDate(value) )			throw CEHCK_TYPE_YMD;		//년월일 체크
			break;
		case CEHCK_TYPE_RESINUM :			//주민등록번호
			if( hasHangul(value) )			throw CEHCK_TYPE_IMEMODE; 	//한글 체크
			if( !IsResidentNumber(value) )	throw CEHCK_TYPE_RESINUM; 	//주민등록번호 체크
			break;
		case CEHCK_TYPE_TAXNUM :			//사업자등록번호
			if( hasHangul(value) )			throw CEHCK_TYPE_IMEMODE;	//한글 체크
			if( !IsTaxNumber(value) )		throw CEHCK_TYPE_TAXNUM;	//사업자등록번호 체크
			break;
		case CEHCK_TYPE_POSTNUM :			//우편번호
			if( hasHangul(value) )			throw CEHCK_TYPE_IMEMODE; 	//한글 체크
			if( ("" + value).length != 6 )	throw CEHCK_TYPE_POSTNUM; 	//우편번호 자리수 체크
			break;
		case CEHCK_TYPE_AMOUNT :			//금액형태
		case CEHCK_TYPE_NUMBER :			//숫자
		case CEHCK_TYPE_BARCODE :			//바코드
			if( !(("" + value).isNum()) )	throw CEHCK_TYPE_NUMBER; 	//숫자 체크
			break;
		case CEHCK_TYPE_ENGLNUM :			//영어
		case CEHCK_TYPE_PASSWORD :			//패스워드
			if( hasHangul(value) )			throw CEHCK_TYPE_IMEMODE; 	//한글 체크
			break;
		case CEHCK_TYPE_IMEMODE :			//한글: 통과
			break;
		}
	}
	catch(e){
		msg = "";
		
		if( column.checkMessage == null
			|| typeof column.checkMessage == "undefined"
			|| (typeof column.checkMessage == "string" && column.checkMessage.length == 0)
		){
			switch(e){
			case CEHCK_TYPE_FORMULA :	msg = column.checkMessage; break;
			case CEHCK_TYPE_YYYY :		msg = getText("message_EasySheet_022", "입력한 년도가 올바르지 않습니다. 년도를 지우거나 고치십시오."); break;
			case CEHCK_TYPE_YM :		msg = getText("message_EasySheet_023", "입력한 년월이 올바르지 않습니다. 년월를 지우거나 고치십시오."); break;
			case CEHCK_TYPE_YMD :		msg = getText("message_EasySheet_024", "입력한 날짜가 올바르지 않습니다. 날짜를 지우거나 고치십시오."); break;
			case CEHCK_TYPE_RESINUM :	msg = getText("message_EasySheet_025", "입력한 주민등록번호가 올바르지 않습니다. 주민등록번호를 지우거나 고치십시오."); break;
			case CEHCK_TYPE_TAXNUM :	msg = getText("message_EasySheet_026", "입력한 사업자등록번호가 올바르지 않습니다. 사업자등록번호를 지우거나 고치십시오."); break;
			case CEHCK_TYPE_POSTNUM :	msg = getText("message_EasySheet_027", "입력한 우편번호가 올바르지 않습니다. 우편번호를 지우거나 고치십시오."); break;
			case CEHCK_TYPE_NUMBER :	msg = getText("message_EasySheet_028", "입력한 금액 또는 숫자가 올바르지 않습니다.");break;
			case CEHCK_TYPE_IMEMODE :	msg = getText("message_EasySheet_029", "한글이 입력되었습니다.");break;
			}
		}
		else{
			msg = column.checkMessage;
		}
		
		// 메세지가 없는 경우 기본값 메세지를 출력
		if( msg == null || typeof msg == "undefined" ) {
			msg = getText("message_EasySheet_029", "유효성 체크 실패하였습니다.");
		}
		
		// 메세지 출력
		this.setMessageBox(true, msg, rowNum0, colNum0);
		
		// 유효성 체크 결과
		correct = false;
		msg = null;
	}
	
	if( correct && column.checkFormula != null && typeof column.checkFormula == "function" && column.checkMessage.trim().length != 0 ){
//		oldValue = this.getValue(rowNum, colNum);
		
		if( column.checkFormula(this, rowNum, colNum, value, oldValue) ){
			correct = false;
			// 메세지 출력
			this.setMessageBox(true, column.checkMessage, rowNum0, colNum0);
		}
	}
	
	// 데이터셋 처리
	if( correct && column.cellType == CELLTYPE_CHECKBOX && this.linkedDataset != null && typeof this._UpdateCheckDataset != "undefined" )
		correct = this._UpdateCheckDataset(this.rows(rowNum).rowId, colNum, oldValue, value);
	
	// 사용자 이벤트 처리
	if( correct && this.hasValidateEvent && this.FireEvent)
		correct = this.fncValidateEvent(colNum, value);
	
	// 메모리 해제
	oldValue = null; column = null; colNum = null;
	
	return correct;
};

EasySheet.prototype.setMessageBox = function(isShow, message, rowNum1, colNum1){
	
	if( typeof rowNum1 == "undefined" )
		rowNum1 = this.currentRow;
	
	if( typeof colNum1 == "undefined" )
		colNum1 = this.currentCol;
	
	var rowNum0 = rowNum1 - this.startRowColNum;
	var colNum0 = colNum1 - this.startRowColNum;
	
	return this.sheetRenderer.setSheetMsgBox(isShow, message, rowNum0, colNum0);
};

/**
 * @deprecated since version 5.0, _catchValidate() 로 대체
 */
EasySheet.prototype.checkCell = function(rowNum, colNumOrId, value){
	// functionname : [EasySheet.checkCell]
	
	// 행번호 체크
	if( typeof rowNum == "undefined" ){
		rowNum = this.currentRow;
	}
	else{
		if( this._isUnvalidRowNum(rowNum, "sheet.moveToFirstCell") )
			return;
	}
	
	if( typeof colNumOrId == "undefined" ){
		colNumOrId = this.currentCol;
	}
	else if( typeof colNumOrId == "string" ){
		if( this._isUnvalidColId(colNumOrId, "sheet.getCellAttribute") )
			return undefined;
		
		colNumOrId = this.getColNum(colNumOrId);
	}
	else{
		if( this._isUnvalidColNum(colNumOrId, "sheet.getColumnTitle") )
			return null;
	}
	
	var rowNum0 = rowNum - this.startRowColNum;
	var colNum0 = colNumOrId - this.startRowColNum;
	
	return this._catchValidate(rowNum0, colNum0, value);
};

EasySheet.prototype._isUnvalidRowNum = function(rowNum, functionName){
	var msg = null;
	
	if( typeof rowNum == "undefined" ){
		msg = getText("message_EasySheet_033", "줄번호를 지정하지 않았습니다.\n{0}", functionName);
	}
	
	if( typeof rowNum == "null" ){
		msg = getText("message_EasySheet_034", "줄번호에 Null 값을 지정했습니다.\n{0}", functionName);
	}
	
	if( typeof rowNum != "number" ){
		msg = getText("message_EasySheet_035", "줄번호가 {0}입니다. 숫자형만 지정가능합니다.\n{1}", [rowNum, functionName]);
	}
	
	if( rowNum < this.startRowColNum ){
		msg = getText("message_EasySheet_031", "줄번호는 {0}보다 작을 수는 없습니다.\n줄번호가 {1}입니다.\n{2}", [this.startRowColNum, rowNum, functionName]);
	}
	
	if( (rowNum - this.startRowColNum) >= this.maxRows ){
		msg = getText("message_EasySheet_032", "현재의 줄 수 {0}보다 클 수는 없습니다.\n줄번호가 {1}입니다.\n{2}", [this.maxRows, rowNum, functionName]);
	}
	
	if( msg != null ){
		alert(msg);
		console.warn(msg);
		msg = null;
		return true;
	}
	
	return false;
};

EasySheet.prototype._isUnvalidColNum = function(colNum, functionName){
	var msg = null;
	
	if( typeof colNum == "undefined" ){
		msg = getText("message_EasySheet_038", "열번호를 지정하지 않았습니다.\n{0}", functionName);
	}
	
	if( colNum == null ){
		msg = getText("message_EasySheet_039", "열번호에 Null 값을 지정했습니다.\n{0}", functionName);
	}
	
	if( typeof colNum != "number" ){
		msg = getText("message_EasySheet_040", "열번호가 {0}입니다. 숫자형만 지정가능합니다.\n{1}", [colNum, functionName]);
	}
	
	if( colNum < this.startRowColNum ){
		msg = getText("message_EasySheet_036", "열번호는 {0}보다 작을 수는 없습니다.\n열번호가 {1}입니다.\n{2}", [this.startRowColNum, colNum, functionName]);
	}
	
	if( (colNum - this.startRowColNum) >= this.maxCols ){
		msg = getText("message_EasySheet_037", "현재의 열 수 {0}보다 클 수는 없습니다.\n열번호가 {1}입니다.\n{2}", [this.maxRows, colNum, functionName]);
	}
	
	if( msg != null ){
		alert(msg);
		console.warn(msg);
		msg = null;
		return true;
	}
	
	return false;
};

EasySheet.prototype._isUnvalidColId = function(colId, functionName){
	var msg = null;
	
	if( typeof colId == "undefined" ){
		msg = getText("message_EasySheet_051", "칼럼ID를 지정하지 않았습니다.\n{0}", functionName);
	}
	
	if( colId == null ){
		msg = getText("message_EasySheet_052", "칼럼ID에 Null 값을 지정했습니다.\n{0}", functionName);
	}
	
	if( !this.isColId(colId) ){
		msg = getText("message_EasySheet_053", "칼럼ID {0}은 정상적인 칼럼ID가 아닙니다.\n{1}", [colId, functionName]);
//		return null;
	}
	
	if( msg != null ){
		alert(msg);
		console.warn(msg);
		msg = null;
		return true;
	}
	
	return false;
};

/*	객체 처리부 이벤트 받는 부분  =================================================
 * 	startRowColNum이 반영된 줄번호 리턴
 */
EasySheet.prototype.updateSeqFieldOfLinkedObject = function(){
	// functionname : [EasySheet.updateSeqFieldOfLinkedObject]

	var newSeq = 0;
	var rowNum0 = 0;
	var rowNum = 0;
	var seq = 0;
	var object = null;
	var i = 0;

	for(rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++, newSeq++){
		rowNum = rowNum0 + this.startRowColNum;
		seq = this.getRowAttribute(rowNum, "objectSeq");
		
		for(i = 0; i < this.linkedObjects.length; i++, object = null){
			object = this.linkedObjects[i];
			
			object.updateSeqField(seq, newSeq + object.startSeq);
		}
	}
	
	return;
};

//시트 객체 시퀀스 재정렬
EasySheet.prototype.updateObjectSeq = function(){
	// functionname : [EasySheet.updateObjectSeq]
	
//	var newSeq = 1;
//	var sheetRows = this.rows;
//	var rowLength = sheetRows.length;
//	
//	for (var wRowNum = 1; wRowNum < rowLength; wRowNum++){
//		sheetRows.objectSeq = wRowNum;
//	}
};

EasySheet.prototype.getRowNumOfObjectSeq = function(seq){
	// functionname : [EasySheet.getRowNumOfObjectSeq]
	
	var rowNum = -1;
	var recordState = null;
	var i = 0;
	
	for(i = 0; i < this.maxRows; i++){
		recordState = this.dataSet.data[i].__STATE__;
		
		if( recordState.objectSeq == seq ){
			rowNum = i;
			recordState = null;
			break;
		}
		
		recordState = null;
	}
	
	return rowNum;
};

EasySheet.prototype.getObjectSeqOfRowNum = function(rowNum){
	// functionname : [EasySheet.getObjectSeqOfRowNum]
	
	return this.dataSet.data[rowNum].__STATE__.objectSeq;
};

/*	검색 적용영역 =================================================
 * 	startRowColNum이 반영된 줄번호 리턴
 */
EasySheet.prototype.rowOfSpread = function(colNumOrId, searchText, startRowNum){
	// functionname : [EasySheet.rowOfSpread]
	
	if( typeof colNumOrId != "number" && typeof colNumOrId != "string" ){
		alert(getText(	"message_EasySheet",
						"EasySheet.{0}() 함수의 사용이 잘못 되었습니다.",
						"rowOfSpread"
		));
		return;
	}
	else{
		if( typeof colNumOrId == "number" ){
			if( this._isUnvalidColNum(colNumOrId, "sheet.getColumnTitle") )
				return null;
		}
		else{
			if( this._isUnvalidColId(colNumOrId, "sheet.getCellAttribute") )
				return undefined;
			
			colNumOrId = this.getColNum(colNumOrId);
		}
	}
	
	if( typeof startRowNum != "number" )
		startRowNum = 0 + this.startRowColNum;
	
	var wReturn = -1;
	var startRowNum0 = startRowNum - this.startRowColNum;
	var rowNum0 = 0;
	var colNum0 = colNumOrId - this.startRowColNum;
	var column = this.columns[colNum0];
	var targetText = null;
	
	for(rowNum0 = startRowNum0; rowNum0 < this.maxRows && wReturn < 0; rowNum0++, targetText = null){
		targetText = "" + this.dataSet.data[rowNum0][column.colId];
		
		if( targetText && targetText.matchWord("" + searchText) ){
			wReturn = rowNum0 + this.startRowColNum;
			break;
		}
	}
	
	for(rowNum0 = 0; rowNum0 < startRowNum0 && rowNum0 < this.maxRows && wReturn < 0; rowNum0++, targetText = null){
		targetText = "" + this.dataSet.data[rowNum0][column.colId];
		
		if( targetText && targetText.matchWord("" + searchText) ){
			wReturn = rowNum0 + this.startRowColNum;
			break;
		}
	}
	
	//메모리 해제
	column = null; targetText = null;
	
	return wReturn;
};

EasySheet.prototype.searchTextByColTitle = function(searchText, colTitleStr, startRowNum){  
	// functionname : [EasySheet.searchTextByColName]
	
	var wReturn = -1;
	var colList = null;
	var i = 0;
	var j = 0;
	
	if( typeof colTitleStr == "string" && colTitleStr.length > 0 ){
		colTitleStr = colTitleStr.split(",");
		colList = [];
		
		for(i = 0; i < colTitleStr.length; i++){
			for(j = 0; j < this.maxCols; j++){
				if( colTitleStr[i] == this.columns[j].caption ){
					colList.push(this.columns[j].colId);
					break;
				}
			}
		}
	}
	
	if( colList instanceof Array && colList.length > 0 )
		wReturn = this.searchText(searchText, colList.join(","), startRowNum);
	
	colList = null;
	
	return wReturn;
};

EasySheet.prototype.searchText = function(searchText, colsStr, startRowNum){
	// functionname : [EasySheet.searchText]
	
	var wReturn = -1;
	var colList = null;
	var colId = null;
	var colNum = 0;
	var targetText = null;
	var startRowNum0 = 0;
	var rowNum0 = 0;
	var i = 0;
	
	if( typeof colsStr == "string" && colsStr.length > 0 ){
		colsStr = colsStr.split(",");
		colList = [];
		
		for(i = 0; i < colsStr.length; i++){
			if( /^[0-9]+$/.test(("" + colsStr[i])) ){
				colNum = 1 * colsStr[i];
				
				if( this._isUnvalidColNum(colNum, "sheet.searchText") )
					continue;
				
				colList.push(this.getColId(colNum - this.startRowColNum)); 
			}
			else{
				colId = colsStr[i];
				
				if( this._isUnvalidColId(colId, "sheet.searchText") )
					continue;
				
				colList.push(colId);
				
				colId = null;
			}
		}
	}
	
	if( typeof startRowNum != "number" )
		startRowNum = 0 + this.startRowColNum;
	
	startRowNum0 = startRowNum - this.startRowColNum;
	
	if( colList instanceof Array && colList.length > 0 ){
		for(rowNum0 = startRowNum0; rowNum0 < this.maxRows && wReturn < 0; rowNum0++){ 
			for(i = 0; i < colList.length && wReturn < 0; i++){
				targetText = "" + this.dataSet.data[rowNum0][colList[i]];
				
				if( targetText && targetText.matchWord("" + searchText) )
					wReturn = rowNum0 + this.startRowColNum;
				
				targetText = null;
			}
		}
	}
	
	//메모리 해제
	targetText = null; colList = null; colsStr = null;
	
	return wReturn;
};

/*	정렬 적용영역 =================================================
 * 	startRowColNum이 반영된 줄번호 리턴
 */

/** 
 * @description 
 *     복합적인 칼럼과 정렬기준을 조합하여 시트를 정렬하는 함수 <br/>
 *     
 * @param 	{String|String[]|Object[]}	sortInfo	    칼럼정정보와 소팅 정보가 들어 있는 정보  <br/>
 *                                      				- 문자열로 "칼럼명"이나 "칼럼명:소팅정보"를 받을 수 있다 <br/>
 *                                      				- 배열로 "칼럼명"이나 "칼럼명:소팅정보"의 배열을 받을 수 있다.   <br/>
 *                                      				- 배열로 {colId: "칼럼명", order:시트정렬상수}를 받을 수 있다.  <br/>
 *                                      				- 상수는 SHEET_SORT_ORDER_ASCENDING:오름차순, SHEET_SORT_ORDER_DESCENDING:내림차순
 * @param   {Boolean}	[nullLarger=false]				null 비교시 큰것으로 볼것인지 작은 것으로 볼것인지 여부 
 * 
 * @return 	{Boolean}									
 * 		
 * @example
 * sheet.sort("col1");							// col1 칼럼을 기준으로 오름차순(= 디폴트) 정렬한다. 
 * sheet.sort(["col2:ASC"]); 					// col2 칼럼을 기준으로 오름차순 정렬한다. 
 * sheet.sort("col3:D");   						// col3 칼럼을 기준으로 내림차순 정렬한다.     
 * sheet.sort("col4:ASC");						// col4 칼럼을 기준으로 오름차순 정렬한다.     
 * 
 * sheet.sort(["col1", "col2:D", "col3:ASC"]); 	// col1 칼럼은 오름차순, col2 칼럼은 내림차순, col1 칼럼은 오름차순 정렬한다.
 *            
 * sheet.sort([{colId: "col1", order: SHEET_SORT_ORDER_ASCENDING}, 
 *             {colId: "col2", order: SHEET_SORT_ORDER_DESCENDING}], true);  // col1 칼럼은 오름차순, col2 칼럼은 내림차순, null 데이터난 최상값으로 간주하고 소트한다.
 */
EasySheet.prototype.sort = function(sortInfo, nullLarger) {
	// functionname : [EasySheet.sort]
	
	// 피벗에는 적용되지 않음
	if (this.pivot != null){  
		this.pivot._warnUnsupport("sort");
		return;
	}	
	
	// 한줄 미만이면 소트가 필요없다.
	if( this.maxRows <= 1 ) return;
	
	var wResult = null;
	var msg = null;

	// 그룹관련 처리
	if( this.needGrouping ){
		msg = getText("message_EasySheet_056", "그룹핑이 된 경우에는 {0}동작을 호출할 수  없습니다.", getText("message_str_sort", "정렬"));
		alert(msg);
		console.warn(msg);
		return false;
	}
	
	//소트 설정 관련 처리
	if( typeof sortInfo == undefined )
		return false;
	else if( !((typeof sortInfo == "string" && sortInfo.length > 0) || (Array.isArray(sortInfo) && sortInfo.length > 0)) )
		return false;
	
	var sortOrders = [];
	var sortOrder = null;
	var column = null;
	var recordStateBef = null;
	var recordStateAft = null;
	var sheetRow = 0;
	var i = 0; var j = 0;
	
	//
	recordStateBef = this.rows(this.currentRow);
	
	//
	if( typeof sortInfo == "string" && sortInfo.length > 0 ){
		if( sortInfo.indexOf(":") > 0 )
			sortOrders.push({"colId" : sortInfo.substring(0, sortInfo.indexOf(":")) , "order" : sortInfo.substring(sortInfo.indexOf(":") + 1)});
		else
			sortOrders.push({"colId" : sortInfo, "order" : "asc"});
	}
	else if( Array.isArray(sortInfo) && sortInfo.length > 0 ){
		for(i = 0; i < sortInfo.length; i++){
			sortOrder = sortInfo[i];
			
			if( typeof sortOrder == "string" ){
				if( sortOrder.indexOf(":") > 0 )
					sortOrders.push({
						"colId" : sortOrder.substring(0, sortOrder.indexOf(":"))
						, "order" : sortOrder.substring(sortOrder.indexOf(":") + 1).toLocaleLowerCase()
					});
				else
					sortOrders.push({"colId" : sortOrder, "order" : "asc"});
			}
			else{
				sortOrders.push(sortOrder);
			}
			
			sortOrder = null;
		}
	}
	
	//
	for(i = 0; i < this.columns.length; i++, column = null){
		column = this.columns[i];
		
		for(j = 0; j < sortOrders.length; j++, sortOrder = null){
			sortOrder = sortOrders[j];
			
			if( column.colId != sortOrder.colId ) continue;
			
			column.sortGu = column.sortDirection = (typeof sortOrder.order == "boolean") ? sortOrder.order : ((sortOrder.order === "") ? "" : (sortOrder.order === "a" || sortOrder.order === "asc"));
		}
	}
	
	//
	this.dataSet.sort(sortOrders, nullLarger);
	
	//메모리 해제
	column = null;
	sortOrder = null;
	sortOrders = null;
	
	// 변경된 로직은
	// STEP1: 산식 재정비
	if( this.autoCalc && JSON.stringify(this._formulaRefs) !== "{}" ){
		this.refreshFormulaRefs();
	}
	
	// STEP2: 화면을 갱신하고
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
	this.updateScreen();
	
	//
	for(i = 0; i < this.maxRows; i++, recordStateAft = null){
		sheetRow = i + this.startRowColNum;
		recordStateAft = this.rows(sheetRow);
		//
		if( recordStateAft === recordStateBef ){
			this.setCurrentRow(sheetRow);
			break;
		}
	}
	
	//메모리 해제
	recordStateAft = null;
	recordStateBef = null;

	// STEP3: 사용자 코딩 추가영역을 호출한다
	if( this.hasSortedEvent && this.FireEvent ){
		wResult = this.fncSortedEvent();
		
		if( typeof wResult == "boolean" && !wResult ){
			stopEvent(e);
			return false;
		}
	}

	return true;
};

/** 
 * @description 
 *     단일 칼럼과 정렬기준을 조합하여 시트를 정렬하는 함수 <br/>
 *     테이블을 물리적으로 소트하고 바뀐순서를 문자열로 리턴한다 여러줄의 칼럼헤드가 존재하는 경우 반드시 맨아래 헤드를 클릭해야 작동한다<br/>
 *     데이터중에 병합된 칼럼이 있으면 오작동한다. 오류를 방지할것<br/>
 *     
 * @param 	{String}	colId	    					칼럼정정보와 소팅 정보가 들어 있는 정보  <br/>
 *                                      				- 문자열로 "칼럼명"을 받을 수 있다 
 *                                      
 * @param   {String}	[sortOrder="ASC"]				문자열로 단일한 "칼럼명"을 받은 경우 추가로 "ASC", "DESC" 또는 시트정렬상수를 전달할 수 있다 
 *                                      				- 상수는 SHEET_SORT_ORDER_ASCENDING:오름차순, SHEET_SORT_ORDER_DESCENDING:내림차순
 * 
 * @return 	{Boolean}									
 * 		
 * @example
 * 
 * sheet.sortTable("col1"); 
 * sheet.sortTable("col1", "ASC"); 
 * sheet.sortTable("col1", SHEET_SORT_ORDER_ASCENDING); 
 */
EasySheet.prototype.sortTable = function (colId, sortOrder) {
	// functionname : [EasySheet.sortTable]

	if( typeof sortOrder == "undefined" )
		sortOrder = SHEET_SORT_ORDER_ASCENDING;
	else if( typeof sortOrder == "string" )
		sortOrder = sortOrder == "ASC" ? SHEET_SORT_ORDER_ASCENDING : SHEET_SORT_ORDER_DESCENDING;
	
	return this.sort([{colId: colId, order: sortOrder}]);
};

// 폐기 
//EasySheet.prototype.setResultOfSort = function(orderString){
//    // functionname : [EasySheet.setResultOfSort]
//	
//    return;
//};

/** 
 * @description 
 *     소트설정된 칼럼의 데이터 변경시 시트를 sort하는 것 ,<br/> 데이터를 채우는 동작에만 적용되고 나머지는 수동으로 이 함수를 호출해야한다.  
 *     
 * @return 	{Void}									
 * 		
 * @example
 * sheet.sortOut(); 
 */
EasySheet.prototype.sortOut = function(){
    // functionname : [EasySheet.sortOut]
	
	var sortInfo = [];
    for (var colNum0 = 0 ; colNum0 < this.maxCols; colNum0++){
    	var column = this.columns[colNum0];
    	var colId = column.colId;
    	var sortGu = column.sortGu;
    	
    	if (typeof sortGu == "string"){
    		if (["ASC", "DESC"].indexOf(sortGu) >= 0){
    			sortInfo.push({colId: colId, order: sortGu === "ASC"});
    		}
    	}
    	if (typeof sortGu == "boolean" ){ 
    		sortInfo.push({colId: colId, order: sortGu});
    	}
    }
	
    // 소트된 칼럼이 없으면 빠진다 
    if (sortInfo.length > 0) {
    	this.sort(sortInfo);
    }
	
	return;
};

/** 
 * @description 
 *     시트헤더 클릭시 재정렬을 하기전  소트설정된 칼럼의 sort 상태를 지우는 동작  
 *     
 * @return 	{Void}									
 * 		
 * @example
 * sheet.sortClear(); 
 */
EasySheet.prototype.sortClear = function(designOption){
	// functionname : [EasySheet.sortOut]
	
	if( !this.sheetRenderer.removeAllSortDirection() )
		return false;
	
	for(var i = 0; i < this.columns.length; i++)
		this.columns[i].sortDirection = "";
	
	this.dataSet.sortOut();
	
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
	this.updateScreen(designOption);
	
	return true;
};

/*	필터 적용영역 =================================================
 * 	startRowColNum이 반영된 줄번호 리턴
 */

/*{event:"filter", colId:"a1", colNum:3, filteringType:, formula: 'a==1'}*/
EasySheet.prototype.filter = function (filterInfo){
	// functionname : [EasySheet.filter]
	
	var filterState = null;
	
	// 이미 있는  필터정보 제거
	if( typeof this._filterState[filterInfo.colId] != "undefined" ){
		filterState = this._filterState[filterInfo.colId];
		
		if( typeof filterState["func"] != "undefined" ){
			delete filterState["func"];
		}
		
		delete this._filterState[filterInfo.colId];
	}
	
	this._filterState[filterInfo.colId] = {
		formula: filterInfo.formula
		, func: new Function("return function (sheet, rowNum) { return " + this._updateFormula(filterInfo.formula) + "; }")()
	};
	
	// 칠터링 수행
//	this._dofilter();
	this.sheetRenderer.filter(this._filterState, this.startRowColNum);
	
	//필터 시 셀 및 행 정보 갱신
	this.maxRows = this.dataSet.getCount();
	this.currentRow = this.sheetRenderer.getSelectedRowIndex() + this.startRowColNum;
	this.currentCol = this.sheetRenderer.getSelectedColumnIndex() + this.startRowColNum;
	
	// 메모리 해제
	filterState = null;
	
	return true;
};

/*{event:"unfilter", colId:"a1", colNum:3}*/
EasySheet.prototype.unfilter = function (filterInfo){
	// functionname : [EasySheet.unfilter]
	
	var filterState = null;
	var key = null;
	var isFiltered = false;
	
	if( typeof filterInfo == "undefined" ){
		//모든 필터 해제
		for(key in this._filterState){
			filterState = this._filterState[key];
			
			if( typeof filterState["func"] != "undefined" )
				delete filterState["func"];
			
			delete this._filterState[key];
			
			filterState = null;
		}
	}
	else{
		//삭제된 필터정보 제거
		filterState = this._filterState[filterInfo.colId];
		
		if( filterState == null || typeof filterState == "undefined" )
			return false;
		
		if( typeof filterState["func"] != "undefined" )
			delete filterState["func"];
		
		delete this._filterState[filterInfo.colId];
	}
	
	//필터링 수행
//	this._dofilter();
	//필터 설정 체크
	for(key in this._filterState){
		isFiltered = true;
		break;
	}
	//필터 설정되어 있다면 필터링 수행하지만 모든 필터가 해제되어 있다면 필터링 해제
	if( isFiltered )
		this.sheetRenderer.filter(this._filterState, this.startRowColNum);
	else
		this.sheetRenderer.unfilter();
	
	//필터 해제시 셀 및 행 정보 갱신
	this.maxRows = this.dataSet.getCount();
	this.currentRow = this.sheetRenderer.getSelectedRowIndex() + this.startRowColNum;
	this.currentCol = this.sheetRenderer.getSelectedColumnIndex() + this.startRowColNum;
	
	// 메모리 해제
	filterState = null;
	
	return true;
};

/*
EasySheet.prototype._dofilter = function(){
	// functionname : [EasySheet._dofilter]
	
	var rowNum = 0;
	var rowNum0 = 0;
	var key = null;
	var filterd = false;
	
	for(rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++){ 
		rowNum = rowNum0 + this.startRowColNum;
		filterd = false;
		
		for(key in this._filterState){
			filterd = filterd || !this._filterState[key].func(this, rowNum);
			
			if( filterd ) break;
			
			key = null;
		}
		
		this.setRowAttribute(rowNum, "filterd", filterd);
	}
	
	//메모리 해제
	key = null;
	
	// 머지된  경우 updateScreen함수 안에서 이루어 진다
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
	this.updateScreen();
};
*/

EasySheet.prototype._updateFormula = function(formula){
	// functionname : [EasySheet._updateFormula]
	
	var colIds = null;
	var regExp = null;
	var id = null
	var control = null;
	var controlString = null;
	var controlName = null;
	var column = null;
	var strValue = null;
	var paramString = null;
	var object = null;
	var propertyId = null;
	var propertyName = null;
	var isSheet = true;
	var isNumberCell = false;
	var colNum0 = 0;
	var colNum = 0;
	var ndx = 0;
	var i = 0;
	
	colIds = [];
	
	for(colNum0 = 0; colNum0 < this.maxCols; colNum0++){
		colIds[colNum0] = this.columns[colNum0].colId;
	}
	
	colIds.sort(function(a,b){return a.length - b.length});
	
	formula = formula.replace(/ROWLEVEL/gi, "#999999#");
	
	for(i = 0; i < colIds.length; i++, regExp = null){
		regExp = new RegExp(colIds[i], "g");
		formula = formula.replace( regExp, "#" + i + "#");
	}
	
	formula = formula.replace(/CURROW/gi, this.id + ".Row")
				.replace(/=/g, "==")
				.replace(/====/g, "==")
				.replace(/<>/g, "!=")
				.replace(/>==/g, ">=")
				.replace(/<==/g, "<=");
	
	for(i = 0; i < colIds.length; i++, regExp = null){
		regExp = new RegExp("#" + i + "#", "g");
		formula = formula.replace(regExp, "sheet.getValue(rowNum, \"" + colIds[i] + "\")");
	}
	
	formula = formula.replace(/#999999#/g, "rowLevel");
	
	//메모리 해제
	colIds.clear();
	colIds = null;
	
	formula = formula.replace(new RegExp(escapeRegExp("[" + getText("message_usr_personalid", "사용자.사번")	+ "]"), "ig"), "USER_PERSONALID")
					 .replace(new RegExp(escapeRegExp("[" + getText("message_usr_personname", "사용자.성명")	+ "]"), "ig"), "USER_PERSONALNAME")
					 .replace(new RegExp(escapeRegExp("[" + getText("message_usr_cogu", "사용자.회사")		+ "]"), "ig"), "USER_COGU")
					 .replace(new RegExp(escapeRegExp("[" + getText("message_usr_bon", "사용자.사업장")		+ "]"), "ig"), "USER_BON")
					 .replace(new RegExp(escapeRegExp("[" + getText("message_usr_part", "사용자.부서")		+ "]"), "ig"), "USER_PART")
					 .replace(new RegExp(escapeRegExp("[" + getText("message_usr_organ", "사용자.조직")		+ "]"), "ig"), "USER_ORGANIZATION")
					 .replace(new RegExp(escapeRegExp("[" + getText("message_usr_date", "사용자.일자")		+ "]"), "ig"), "USER_DATE")
					 .replace(new RegExp(escapeRegExp("[" + getText("message_usr_month", "사용자.년월")		+ "]"), "ig"), "USER_MONTH")
					 .replace(new RegExp(escapeRegExp("[" + getText("message_usr_year", "사용자.년도")		+ "]"), "ig"), "USER_YEAR")
					 .replace(new RegExp(escapeRegExp("[" + getText("message_usr_seq", "사용자.순번")		+ "]"), "ig"), "USER_SEQ")
					 .replace(new RegExp(escapeRegExp("[" + getText("message_usr_time", "사용자.시간")		+ "]"), "ig"), "USER_TIME")
					 .replace(new RegExp(escapeRegExp("[" + getText("message_usr_userId", "사용자.아이디")	+ "]"), "ig"), "USER_USERID")
					 .replace(new RegExp(escapeRegExp("[" + getText("message_usr_ipAddr", "사용자.아이피주소")	+ "]"), "ig"), "USER_USERIP");
	
	for(id in controls){
		if( typeof controls[id] == "function" ) continue;
		
		control = controls[id];
		controlString = getText("message_str_control", "콘트롤");
		controlName = control.controlName;
		isSheet = typeof control.maxCols != "undefined" && typeof control.maxRows != "undefined";
		
		if( isSheet ){
			for(colNum0 = 0; colNum0 < control.maxCols; colNum0++){
				colNum = colNum0 + this.startRowColNum;
				column = control.columns[colNum0];
				
				isNumberCell = ([CELLTYPE_NUMBER, CELLTYPE_PERCENT, CELLTYPE_INTEGER, CELLTYPE_BAR, CELLTYPE_CURRENCY, CELLTYPE_FLOAT].indexOf(column.cellType) >= 0);
				
				strValue = "controls[\"" + id + "\"].getValue(rowNum, " + colNum + ")"; 
				
				if (isNumberCell){
					strValue = "(1 * " + strValue + ")";
				} else if ([CELLTYPE_NUMBER, CELLTYPE_CURRENCY, CELLTYPE_FLOAT].indexOf(column.cellType)){
					strValue = "(1.0 * " + strValue + ")";
				} else {
					strValue = "" + strValue;
				}
				
				formula = formula.replace(new RegExp(escapeRegExp("[" + controlString + "." + controlName + "." + colNum + "]"), "ig"), strValue);
				
				//메모리 해제
				isNumberCell = false; strValue = null; column = null;
			}
		}
		else if( typeof controls[id].value != "undefined" ){
			strValue = "controls[\"" + id + "\"].value";
			
			formula = formula.replace(new RegExp(escapeRegExp("[" + controlString + "." + controlName + "]"), "ig"), strValue);
			
			//메모리 해제
			strValue = null;
		}
		
		//메모리 해제
		controlName = null; controlString = null; control = null; id = null;
	}
	
	for(id in parameters){
		if( typeof parameters[id] == "function" ) continue;

		paramString = getText("message_str_parameter", "파라메터");
		strValue = "parameters[\"" + id + "\"]";
		
		formula = formula.replace(new RegExp(escapeRegExp("[" + paramString + "." + id + "]"), "ig"), strValue);
		
		//메모리 해제
		strValue = null; paramString = null; id = null;
	}
	
	for(id in objects){
		if( typeof objects[id] == "function" ) continue;
		
		object = objects[id];
		
		for(ndx = 0; ndx < object.propertyCount; ndx++){
			propertyId = object.propertyInfos[ndx].id;
			propertyName = object.propertyInfos[ndx].name;
			strValue = "objects[\"" + id + "\"].get" + propertyId.substring(0,1).toUpperCase() + propertyId.substring(1) + "()";
			
			formula = formula.replace(new RegExp(escapeRegExp("[" + object.name + "." + propertyName + "]"), "ig"), strValue);
			
			//메모리 해제
			strValue = null; propertyName = null; propertyId = null;
		}
		
		//메모리 해제
		object = null; id = null;
	}
	
	formula = formula.replace(/CELL[(]\s*\"(.+?)\"\s*[)]/ig, "CELL($1)")
				.replace(/CELL[(]\s*(.+?)\s*[)]/ig, "sheet.cell(\"$1\", rowNum, colNum)")
				.replace(new RegExp(escapeRegExp("&"), "g"), "+")
	
	
	
	
	return formula;
};

EasySheet.prototype._convertColumnToRCofFormula = function(formula){
	
	var controlString = getText("message_str_control", "콘트롤");
	var controlName = this.controlName;
	
	if (this.startRowColNum == 1){
		// 다음과 같이 변환한다 
		// controls["sheet_1"].getValue(1, 2)  -> R1C2
		var escapedName = escapeRegExp(controlName);
		var regex = new RegExp("controls\\s*\\[\\s*\"" + escapedName + "\"\\s*\\]\.getValue\\s*\\(\\s*([0-9]*?)\\s*,\\s*([0-9]*?)\\s*\\)", "ig");
		
		formula = formula.replace(regex, "CELL(\"R$1C$2\")");
		
		// 다음과 같이 변환한다 
		// controls["sheet_1"].getValue(3)  -> RC3	
		regex = new RegExp("controls\\s*\\[\\s*\"" + escapedName + "\"\\s*\\]\.getValue\\s*\\(\\s*([0-9]*?)\\s*\\)", "ig");
		formula = formula.replace(regex, "CELL(\"RC$1\")");
	} else {
		// 다음과 같이 변환한다 
		// controls["sheet_1"].getValue(1, 2)  -> R1C2
		var escapedName = escapeRegExp(controlName);
		var strRegExp = "controls\\s*\\[\\s*\"" + escapedName + "\"\\s*\\]\.getValue\\s*\\(\\s*([0-9]*?)\\s*,\\s*([0-9]*?)\\s*\\)";
		var regex = new RegExp(strRegExp, "ig");

		var matches = formula.match(regex);
		for (var i = 0;  matches != null && i < matches.length; i++){
		    var matchStr = matches[i];

		    var strRowNum = matchStr.replace(regex, "$1");
		    var strColNum = matchStr.replace(regex, "$2");
		    
		    var rowNum = parseInt(strRowNum, 10) + 1 - this.startRowColNum;
		    var colNum = parseInt(strColNum, 10) + 1 - this.startRowColNum;
		    
		    var regex = new RegExp(strRegExp, "i");   // 하나만 하기 위하여 를 뺀다 
		    formula = formula.replace(regex, "CELL(\"R" + rowNum + "C" + colNum + "\")");

		}		

		
		// 다음과 같이 변환한다 
		// controls["sheet_1"].getValue(3)  -> RC3	
		strRegExp = "controls\\s*\\[\\s*\"" + escapedName + "\"\\s*\\]\.getValue\\s*\\(\\s*([0-9]*?)\\s*\\)";
		regex = new RegExp(strRegExp, "ig");
		
		var matches = formula.match(regex);
		for (var i = 0; matches != null && i < matches.length; i++){
		    var matchStr = matches[i];

		    var strColNum = matchStr.replace(regex, "$1");
		    var colNum = parseInt(strColNum, 10) + 1 - this.startRowColNum;
		    
		    var regex = new RegExp(strRegExp, "i");
		    formula = formula.replace(regex, "CELL(\"RC" + colNum + "\")");


		}		
		
	}
	
	

	
	var colIds = [];
	
	for(colNum0 = 0; colNum0 < this.maxCols; colNum0++){
		colIds[colNum0] = {"colId": this.columns[colNum0].colId, 
				           "colNum1": colNum0 + 1};
	}
	colIds.sort(function(a,b){return a.colId.length - b.colId.length});
	
	for(i = 0; i < colIds.length; i++, regExp = null){
		// 칼럼아이디를 산식에 사용한 부분 RC변환
		var regExp = new RegExp(colIds[i].colId, "g");
		formula = formula.replace( regExp, "CELL(\"RC" + colIds[i].colNum1 + "\")");

		// EasyMaker "[ ... ]" 표기법 사용한 부분  RC변환
		var regExp = new RegExp(escapeRegExp("[" + controlString + "." + controlName + "." + colIds[i].colNum1 + "]"), "ig")
		formula = formula.replace( regExp, "CELL(\"RC" + colIds[i].colNum1 + "\")");
	}
	//메모리 해제
	colIds.clear();
	colIds = null;
	
	return formula;
}

/*	병합 적용영역 =================================================
 * 	startRowColNum이 반영된 줄번호 리턴
 */

EasySheet.prototype.getMergeInfo = function(){

	var cellCount = 0;
	for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++){
		var column = this.columns[colNum0];
		
		var maxCellNum = column.sheetCol + column.sheetColSpan - 1;
		cellCount = cellCount >= maxCellNum ? cellCount : maxCellNum;
	}
	
	
	// 비어 있는 2차원 배열 만들기 
	var mergeInfo = [];
	for (var rowNum0 = 0; rowNum0 < this.displayInfo.rowsPerDataRow; rowNum0++){
		mergeInfo.push( new Array(cellCount) );
	}
	
	for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++){
		var column = this.columns[colNum0];
		var rowNum0  = column.sheetRow - 1;
		
		// 처리된 셀, 머지된 셀을 제하고, 채워야할 셀번호 찾기 
		var cellNum = -1;
		
		for (var i=0; i < cellCount; i++){
			if (typeof mergeInfo[rowNum0][i] == "undefined"){
				cellNum = i;
				break;
			}
		}
		
		if (cellNum < 0) {
			// !!! 오류처리 
			return null;
		}
		
		// 자기셀은 채우고 
		var rowSpan = column.sheetRowSpan;
		var colSpan = column.sheetColSpan;
		var colId = column.colId;
		
		mergeInfo[rowNum0][cellNum] = { disp:true, 
									   rowSpan: rowSpan, 
									   colSpan: colSpan, 
									   colId:column.colId, 
									   icon: ""};
		
		if (typeof column.colIndex != "undefined") {
			mergeInfo[rowNum0][cellNum].colNum0 = column.colIndex;    // 0부터 시작
		}
		
		for (var cellNumToFill = cellNum; cellNumToFill < cellNum + colSpan; cellNumToFill++){
			for (var rowNumToFill = 0; rowNumToFill < rowSpan; rowNumToFill++){
				// 자기셀은 건너 뛴다 
				if (cellNumToFill == cellNum && rowNumToFill == rowNum0) continue;
				
				// 머지된 셀은 디폴트 처리한다 
				mergeInfo[rowNum0][cellNumToFill] = {disp:false};
			}
		}
	}
	return mergeInfo;
};

EasySheet.prototype.initializeCellMerge = function(){
	this.needMerge = SHEET_MERGE_NEED_NOT;
	
	var columnLength = this.columns.length;
	var colNum0 = 0;
	
	for(colNum0 = 0; colNum0 < columnLength; colNum0++){
		if( this.columns[colNum0].cellMerge > 0 ){
			this.needMerge = SHEET_MERGE_NEED;
			break;
		}
	}
};

/*
// refreshCellMerge는 UpdateScreen에서 호출되고 
// 아니면 반드시 this.displayInfo.endRow 가 지정된 상태에서 호출되어야 한다
EasySheet.prototype.refreshCellMerge = function(){
    // functionname : [EasySheet.refreshCellMerge]
	
	// 앞으로 시트를 계속 머지해야 하는지 메모해 준다, 
	// merge가 수시로 일어 나므로 불필요한 동작압지용 변수가 needMerge이다
	this.initializeCellMerge();
	
	if (this.needMerge == SHEET_MERGE_NEED_NOT) {
		return;
	}
	
	// 기본 머지정보 
	var mergeInfos = this.getMergeInfo();
	var rowsToRepeat = mergeInfos.length;
	var colCount = mergeInfos[0].length;
	
    var rowNumToStart = this.displayInfo.startRow;
    var rowNumToEnd = this.displayInfo.endRow;
    var datas = this.dataSet.data;
	
    for ( var rowNum0 = rowNumToStart; rowNum0 <= rowNumToEnd && rowNum0 < datas.length; rowNum0++){
        var rowNum  = rowNum0 + this.startRowColNum;
        
    	// 숨겨진 줄이면 스킵한다.
    	if (this.getRowAttribute(rowNum, "hidden") || this.getRowAttribute(rowNum,  "filterd")){ continue; }
    	
    	// 시트단위 머지정보를 읽어 데이터 단위 머지 정보로 복제 생성한다. 
    	var mergeInfo = datas[rowNum0].__STATE__.mergeInfo;
    	if (typeof mergeInfo == "undefined"){
    		mergeInfo = datas[rowNum0].__STATE__.mergeInfo = JSON.parse(JSON.stringify(mergeInfos));
    	}

    	// 자기줄과 윗줄의 데이터를 꺼낸다 
        var data0 = datas[rowNum0 - 1];
        var data1 = datas[rowNum0];
        
        // 줄단위 트리정보 사전 파악 
    	var treeInfos = this.getRowAttribute(rowNum, "treeInfo");  // this.startRowColNum이 반영된 줄번호를 인자로 받는다.
    	
    	// mergeInfo 내의 줄, 열별로 루핑하며 
        var restrictable = true;
    	for (var unitRowNum0=0; unitRowNum0 < rowsToRepeat; unitRowNum0++){
        	for (var unitColNum0=0; unitColNum0 < colCount; unitColNum0++){
        		var unitMergeInfo = mergeInfo[unitRowNum0][unitColNum0];
        		// 병합 설정된 셀은 스킵한다.
        		if (unitMergeInfo.disp == false){ continue;}
        		
        		// 칼럼정보 파악  
        		var colId  = unitMergeInfo.colId;
        		var colNum = this.getColNum(colId);
         		var colNum0 = colNum - this.startRowColNum;;
        		var column = this.columns[colNum0];
        		
        		if (column.cellMerge == SHEET_CELL_MERGE_ALWAYS){
            		// 위아래 데이터가 같은지 여부 
        			// 같으면 데이터를 숨긴다 
            		var isEqual = rowNum0 == rowNumToStart ? false : data0[colId] === data1[colId];
            		if (isEqual) unitMergeInfo.disp = false;
            		
            		restrictable = restrictable || isEqual;    // 앞의 머지셀 값이 변하면 RESTRICT셀은 머지할 수 없게 된다 
            		
        		}  else if (column.cellMerge == SHEET_CELL_MERGE_RESTRICT && restrictable){
            		var isEqual = rowNum0 == rowNumToStart ? false : data0[colId] === data1[colId];
            		if (isEqual) unitMergeInfo.disp = false;
        		}
        	}
    	}
    }

    return;
};
*/

/*	트리 적용영역 =================================================
 * 	startRowColNum이 반영된 줄번호 리턴
 */

EasySheet.prototype.initializeTreeCell = function(){
	
	// 피벗에는 적용되지 않음
	if (this.pivot != null){  
		this.pivot._warnUnsupport("initializeTreeCell");
		return;
	}	
		
	this.hasTreeCell = false;
    var tempValueInfo = {}; 
    for (var colNum0=0; colNum0 < this.columns.length; colNum0++){
    	var column = this.columns[colNum0];
    	if (column.cellTree == true){
    		tempValueInfo[column.colId] = {colNum0: colNum0, value: null};
    		this.hasTreeCell = true;
    	}
    }
	if (this.hasTreeCell == false) {
		return;
	}
	
	// 머지 설정 읽기 
 	var mergeInfos = this.getMergeInfo();
	var rowsToRepeat = mergeInfos.length;
	var colCount = mergeInfos[0].length;
	var jsonMergeInfo = {};

	for (var unitRowNum0 = 0; unitRowNum0 < rowsToRepeat; unitRowNum0++) {
		for (var unitColNum0 = 0; unitColNum0 < colCount; unitColNum0++) {
			var wMergeInfo = mergeInfos[unitRowNum0][unitColNum0];
			// 병합 설정된 셀은 스킵한다.
			if (wMergeInfo.disp == false) {
				continue;
			}

			jsonMergeInfo[wMergeInfo.colId] = {
				unitRowNum : unitRowNum0,
				unitColNum : unitColNum0
			};
		}
	}

    // 각 줄별로 레벨번호를 정한다. 그리고 디폴트로 0번 레벨이 아닌 것은 숨긴다. 
    var datas = this.dataSet.data; 
    for ( var rowNum0 = 0; rowNum0 < datas.length; rowNum0++){
        var rowNum  = rowNum0 + this.startRowColNum;
        var data = datas[rowNum0];
    	var mergeInfo = datas[rowNum0].__STATE__.mergeInfo;
    	if (typeof mergeInfo == "undefined"){
    		mergeInfo = datas[rowNum0].__STATE__.mergeInfo = JSON.parse(JSON.stringify(mergeInfos));
    	}
        
        // 몇레벨 동작의 기준이 되는지 메모
    	var treeInfo = [];
        var valueChanged = false;  // 상위 키값이 바뀐지 여부, 바뀌었으면 하위 키값이 바뀌어도 바뀐 데이터이다 
        var level = 0;
        for (var colId in tempValueInfo){
        	var unitRowNum = jsonMergeInfo[colId].unitRowNum;
        	var unitColNum = jsonMergeInfo[colId].unitColNum;

        	treeInfo[level] = {isTreeKey: false, expanded: false, colId: colId, colNum0: tempValueInfo[colId].colNum0};
    		
    		if (valueChanged || tempValueInfo[colId].value != data[colId]){
    			treeInfo[level].isTreeKey = true;
    			//treeInfo[level].expanded = (level == 0); // 디폴트로는 0레벨이 아니면 숨긴줄이다 
    			treeInfo[level].expanded = false; // 디폴트로는 0레벨이 아니면 숨긴줄이다 
   			
    			// Tree icon 추가 
    			mergeInfo[unitRowNum][unitColNum].icon = "+";
    			
    			// 데이터값 메모
    			tempValueInfo[colId].value = data[colId];
    			
    			valueChanged = true;
    		} else {
    			// Tree icon 추가 
    			mergeInfo[unitRowNum][unitColNum].icon = " ";
    		}
    		
    		level++;
    	}
        
        this.setRowAttribute(rowNum, "treeInfo", treeInfo);
        
        // 디폴트로는 0레벨이 아니면 숨긴줄이다 
        this.setRowAttribute(rowNum, "hidden", treeInfo[0].isTreeKey ? false : true);
    }
    
    // 숨김 줄 정보를 가지고 머지하고 화면을 다시 표시한다  
//	this.updateScreen(SHEET_RESET_DATA_ONLY); 
    this.updateScreen();
    
    return;
};

EasySheet.prototype.refreshTreeCell = function(){
    // functionname : [EasySheet.refreshTreeCell]
	
	if (this.hasTreeCell == false) {
    	alert(getText("message_EasySheet_014", 
                "트리형식을 설정하지 않았습니다./n sheet.{0}() 함수를 사용할 수 없습니다.\n", "refreshTreeCell"));
		return;
	}
	
	this.initializeTreeCell();
};

EasySheet.prototype.treeCellOpen = function(rowNum0, colNumOrId0){
    // functionname : [EasySheet.treeCellOpen]
	
    var rowNum  = rowNum0 + this.startRowColNum;
	
	if (this.hasTreeCell == false) {
    	alert(getText("message_EasySheet_014", 
                "트리형식을 설정하지 않았습니다./n sheet.{0}() 함수를 사용할 수 없습니다.\n", "treeCellOpen"));
		return;
	}
	
	var expanded = true;
	if (rowNum0 >= this.dataSet.data.length){
    	alert(getText("message_EasySheet_016", 
                "트리형식을 설정하지 않았습니다./n" + 
                "sheet.{0}(rowNum, colNum) 함수의 인자 rowNum값 {1}은 줄수 {2}를 초과할 수 없습니다.", 
                ["treeCellOpen", rowNum0, this.dataSet.data.length]));
		return;
	}
	
	var expanded = true;
	var hidden = false;
    var treeInfo = this.getRowAttribute(rowNum, "treeInfo");    // this.startRowColNum이 반영된 줄번호를 인자로 받는다.
    var colNum0 = typeof colNumOrId0 == "string" ? this.getColNum(colNumOrId0) - this.startRowColNum : colNumOrId0;
    var colId = typeof colNumOrId0 == "string" ? colNumOrId0 : this.getColId(colNumOrId0 + this.startRowColNum)
	
    // 클릭한 칼럼의 레벨을 파악한다 
    var currentLevel = -1;
    var levelCount = treeInfo.length;
    for (var level = 0; level < treeInfo.length; level++){
    	if (treeInfo[level].colNum0 == colNum0) {
    		currentLevel = level; 
    		break;
    	}
    }
    
    // 자기레벨의 expanded 속성을 준다 
    treeInfo[currentLevel].expanded = expanded;
	this.setRowAttribute(rowNum, "hidden", false);
	
	// Tree 아이콘설정 
	var mergeInfos = this.getMergeInfo();
	var rowsToRepeat = mergeInfos.length;
	var colCount = mergeInfos[0].length;
	
	var unitRowNum = -1;
	var unitColNum = -1;
	for (var unitRowNum0 = 0; unitRowNum0 < rowsToRepeat && unitRowNum < 0; unitRowNum0++) {
		for (var unitColNum0 = 0; unitColNum0 < colCount && unitColNum < 0; unitColNum0++) {
			var wMergeInfo = mergeInfos[unitRowNum0][unitColNum0];
			if (colId == wMergeInfo.colId) {
				unitRowNum = unitRowNum0;
				unitColNum = unitColNum0;
			}
		}
	}
	this.dataSet.data[rowNum0].__STATE__.mergeInfo[unitRowNum][unitColNum].icon = "-";
	
    //  자기레벨 처리 처리 
    this._displayTreeCell(rowNum0, colNum0, currentLevel, hidden)

    // 숨김 줄 정보를 가지고 머지하고 화면을 다시 표시한다  
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
    this.updateScreen();
    
    return;
};

EasySheet.prototype.treeCellClose = function(rowNum0, colNumOrId0){
    // functionname : [EasySheet.treeCellClose]

    var rowNum  = rowNum0 + this.startRowColNum;
	
	if (this.hasTreeCell == false) {
    	alert(getText("message_EasySheet_014", 
                "트리형식을 설정하지 않았습니다./n sheet.{0}() 함수를 사용할 수 없습니다.\n", "treeCellClose"));
		return;
	}

	var expanded = true;
	if (rowNum0 >= this.dataSet.data.length){
    	alert(getText("message_EasySheet_016", 
	                "트리형식을 설정하지 않았습니다./n" + 
	                "sheet.{0}(rowNum, colNum) 함수의 인자 rowNum값 {1}은 줄수 {2}를 초과할 수 없습니다.", 
	                ["treeCellClose", rowNum0, this.dataSet.data.length]));
	}
	
	var expanded = false;
	var hidden = true;
    var treeInfo = this.getRowAttribute(rowNum, "treeInfo");    // this.startRowColNum이 반영된 줄번호를 인자로 받는다.
    var colNum0 = typeof colNumOrId0 == "string" ? this.getColNum(colNumOrId0) - this.startRowColNum : colNumOrId0;
    var colId = typeof colNumOrId0 == "string" ? colNumOrId0 : this.getColId(colNumOrId0 + this.startRowColNum)
	
    // 클릭한 칼럼의 레벨을 파악한다 
    var currentLevel = -1;
    var levelCount = treeInfo.length;
    for (var level = 0; level < treeInfo.length; level++){
    	if (treeInfo[level].colNum0 == colNum0) {
    		currentLevel = level; 
    		break;
    	}
    }
    
    // 자기레벨의 expanded 속성을 준다 
    treeInfo[currentLevel].expanded = expanded;
	this.setRowAttribute(rowNum, "hidden", false);  // 클릭한 자기 자신은 항시 보이는 상태이다.
	
	// Tree 아이콘설정 
	var mergeInfos = this.getMergeInfo();
	var rowsToRepeat = mergeInfos.length;
	var colCount = mergeInfos[0].length;
	
	var unitRowNum = -1;
	var unitColNum = -1;
	for (var unitRowNum0 = 0; unitRowNum0 < rowsToRepeat && unitRowNum < 0; unitRowNum0++) {
		for (var unitColNum0 = 0; unitColNum0 < colCount && unitColNum < 0; unitColNum0++) {
			var wMergeInfo = mergeInfos[unitRowNum0][unitColNum0];
			if (colId == wMergeInfo.colId) {
				unitRowNum = unitRowNum0;
				unitColNum = unitColNum0;
			}
		}
	}
	this.dataSet.data[rowNum0].__STATE__.mergeInfo[unitRowNum][unitColNum].icon = "+";

    //  자기레벨 처리 처리 
    this._displayTreeCell(rowNum0, colNum0, currentLevel, hidden)
    
    // 숨김 줄 정보를 가지고 머지하고 화면을 다시 표시한다  
//	this.updateScreen(SHEET_RESET_DATA_ONLY);
    this.updateScreen();
    return;
};

EasySheet.prototype._displayTreeCell = function(selectedRowNum0, colNum0, parentLevel, hidden){
    // functionname : [EasySheet._displayTreeCell]
	
	// STEP1: 자기줄 처리 
	
	// 자기줄을 먼저 숨기거나, 보인다 
	var selectedRowNum = selectedRowNum0 + this.startRowColNum;
	var selectedColNum = colNum0 + this.startRowColNum;

	// 여기아래는 자식들 처리 
    var treeInfo = this.getRowAttribute(selectedRowNum, "treeInfo");    // this.startRowColNum이 반영된 줄번호를 인자로 받는다.
    var lastLevel = treeInfo.length - 1;   // 마지막 레벨 번호 
    var childLevel = parentLevel + 1;   // 마지막 레벨 번호 
	
	
	var parentValue = this.getValue(selectedRowNum, selectedColNum);
    
	// STEP2: 하위줄 처리 
	
    // 자기줄아래로 키가 같은 동안 , 하위레벨 데이터들의 자기레벨 expanded 속성을 같은 값으로 준다.
    // 바로 하위 레벨데이터의 hidden 속성을 조정한다.
    var levelExpanded = []; //  각레벨 별로 펼쳐짐 여부를 true/false로 기록
    var datas = this.dataSet.data;

    for (var rowNum0 = selectedRowNum0 + 1; rowNum0 < datas.length; rowNum0++){
        var rowNum  = rowNum0 + this.startRowColNum;
        var treeInfo = this.getRowAttribute(rowNum, "treeInfo");        // this.startRowColNum이 반영된 줄번호를 인자로 받는다.
       
        // 자기 레벨이 true인 데이터를 만나면 키가 달라진 것이다 
        // 어기를 통과하면 하위 데이터 만 남게 된다 
    	var childValue = this.getValue(rowNum, selectedColNum);
        var isNotChild = treeInfo[parentLevel].isTreeKey && parentValue !== childValue;
        if (isNotChild) break;
        
        // 마지막 레벨에 대한 작업인 경우, 곧바로 hidden 속성을 처리한다 
        if (parentLevel == lastLevel){ 
        	this.setRowAttribute(rowNum, "hidden", hidden);
        	continue;
        } else if (!treeInfo[childLevel].isTreeKey){
        	// 다음 레벨이 키인 것만 아래에서 처리한다 
        	continue;
        }
        
		var mustShow = !hidden;
		for (var i=0; i <= childLevel; i++){
			mustShow = mustShow || treeInfo[i].expanded;
		}
		this.setRowAttribute(rowNum, "hidden", !mustShow);
/*        
        // 마지막레벨이 아닌 경우 처리 
        // parentLevel이 마지막 레벨 이거나, 하위레벨이 키값인 자식데이터 이므로 통과한다 
        var childIsKeyItem = treeInfo[parentLevel].isTreeKey;
        if (!childIsKeyItem) continue;
    	
    	// 하위레벨에 대하여 재귀호출  
        var childColnum0 = treeInfo[childLevel].colNum0;
        
        // 숨김으로 넘어 오고 하위 레벨이 있는 경우, 무조건 하위 숨김
        // 보임으로 넘어 오고 하위 레벨이 있는 경우, expanded 상태에 따라 하위 숨김/보임 처리
        var childIsHidden = hidden ? true : treeInfo[childLevel].expanded;
*/        
//        this._displayTreeCell(rowNum0, childColnum0, childLevel, childIsHidden);
    }
};





/*  ===========  참조 =========================================
 *   dtatset의 "__STATE__" 속성은 데이터 셋에서 다음과 같은 구조를  모든항목은 OPTIONAL이다 반드시 있을 필요는 없다.
 *   __STATE__: { 
 *               	cells:{colid1:{formula: "", tag: ""}, ...},
 *               	formula: "", 
 *               	tag: "", 
 *               	hidden: false, 
 *               	objectSeq: 1, // ??? 객체부분 연결시 재조정
 *                  rowLevel: 0   // 그룹데이터에서 사용 rowLevel:0 이 물리적인 데이터이고 1부터는 레벨이다.
 *              } 
 * */

/*
    <!-- XSL를 아래처럼 바꿀것   -->
	<xsl:for-each select="COLFOOTER[../@sheetcontrol='1']"> <-- @sheetcontrol 정보 추가 -->
		<xsl:variable name="i" select="position()"/>
		wControl.footerObject[<xsl:value-of select="$i" /> - 1] = {
			positionField : "f<xsl:value-of select="$i" />",
			dataField : "f<xsl:value-of select="$i" />",<xsl:text/>
			style : "AUIGrid_Align_<xsl:value-of select="@align"/>",<xsl:text/>
			<xsl:if test="string-length(@formula)&gt;0">
			labelFunction : function(columnValues) {
				return <xsl:value-of select="@formula" />;
			}<xsl:text/>
			</xsl:if>
		}
   	</xsl:for-each>
   	
	<xsl:for-each select="COLFOOTER[../@sheetcontrol='2']"> <-- @sheetcontrol 정보 추가 -->
        var column = controls["<xsl:value-of select="../@name"/>"].addFooter(<xsl:value-of select="@row"/>,<xsl:text/> 
                                                                             <xsl:value-of select="@colnum"/>,<xsl:text/>
                                                                             <xsl:value-of select="@rowspan"/>);
        <xsl:if test="string-length(normalize-space(@formula)) &gt; 0">
        column.formula = "<xsl:value-of select="@formula"/>", <xsl:value-of select="@col"/>;
        </xsl:if>
        column["showFooter"] = <xsl:value-of select="../@showfooter"/>;
        column["footerHeight"] = <xsl:value-of select="../@footerheight/>;
        column["align"] = <xsl:value-of select="@align/>;
        column["colWidth"] = <xsl:value-of select="@colwidth/>;
   	</xsl:for-each>
*/
var BROWSER_LOWER_IE9 = (navigator.appVersion.indexOf("MSIE 7") >= 0 || navigator.appVersion.indexOf("MSIE 8") >= 0);
var IS_IE_BROWSER = (navigator.appVersion.indexOf("Trident/") >= 0 || navigator.appVersion.indexOf("MSIE ") >= 0 || navigator.appVersion.indexOf(" Edge") >= 0);

//스크롤 동작 관련 전역변수 선언
var _SheetHScrollArrowDownTimer = null;	// -수평 스크롤 타이머
var _SheetVScrollArrowDownTimer = null;	// -수직 스크롤 타이머
//시트 달력 관련 변수
var _SheetCalenderBtnOver = false;





function EasySheetRenderer(controlId, controlName, tagObject){
	this.controlId = controlId;
	this.controlName = controlName;
	this.sheet = (typeof controls[controlName] != "undefined") ? controls[controlName] : null;
	
	this.designTable = null;
	
	this.columnWidths = null;			//컬럼 너비(병합 이전 셀 기준)
	this.columnInfo = [];				//인덱스 기준
	this.columnIndexMapByField = {};	//키필드 기준
	this._lastVisibleColumnIndex = -1;
	this._cntResponsibleColumnWidth = false;
	this._sumResponsibleColumnWidth = 0;
	this._columnWidths = null;
	
	this.headerInfo = [];
	this.footerInfo = [];
	
	this.dataSet = null;				//시트의 WsDataSet을 연결
	this.data = [];						//화면에 출력된 데이터
	
	this.displayMaxRowCount = 0;
	this.wholeShownRowCount = 0;
	this.dataRowCount = 0;
	this.visibleRowCount = 0;
	this.displayedRowCount = 0;
	
	this.showedTopRowIndex = -1;
	this.selectedRowIndex = -1;
	this.selectedColumnIndex = -1;
	
	this.sheetHeaderDivWidth = 0;
	this.sheetHeaderDivHeight = 0;
	this.sheetHeaderTableLeft = 0;
	this.sheetHeaderTableWidth = 0;
	
	this.isShowFooter = false;
	this.isShowHeader = true;
	this.isShowColHeader = true;
	this.isShowRowHeader = true;
	this.sheetRowHeaderWidth = 40;
	this.sheetHeaderLastRowCells = null;
	this.sheetHeaderLefFixLastRowCells = null;
	this.sheetHeaderRightFixLastRowCells = null;
	this.maxColumnCount = 0;
	this.leftFixColumnCount = 0;
	this.rightFixColumnCount = 0;
	this.topFixRowCount = 0;
	this.footerRowCount = 0;
	
	this.rowsPerDataRow = 1;
	this.colsPerRow = 0;
	
	this.sheetContentDivWidth = 0;
	this.sheetContentDivHeight = 0;
	this.sheetContentTableLeft = 0;
	this.sheetContentTableWidth = 0;
	
	this.sheetLeftFixWidth = 0;
	this.sheetRightFixWidth = 0;
	
	this.headerHeight = 30;
	this.rowHeight = 30;
	this.footerHeight = 30;
	
	this.isShowVScroll = false;
	this.vScrollWidth = 0;
	this.vScrollTrackHeight = 0;
	this.vScrollFaceTop = 0;
	this.vScrollFaceHeight = 0;
	this.tableMovePerVScrollFaceMove = 0;
	this.vScrollPageSize = 0;
	this.vScrollWheelMoveRows = 1;
	
	this.isShowHScroll = false;
	this.hScrollHeight = 0;
	this.hScrollTrackWidth = 0;
	this.hScrollFaceLeft = 0;
	this.hScrollFaceWidth = 0;
	this.tableMovePerHScrollFaceMove = 0;
	
	this.isListSheet = false;
	this.isEditngSheet = false; //시트 편집 상태
	this.isIgnoreEditingControlBlurEvent = false; //blur 이벤트 동작 여부
	this.isApplyEditingControlChangedValue = true; //변경된 데이터 적용 여부
	this.switchMoveEnterAndTab = true; //탭과 엔터의 동작을 바꿈(true : Enter-다음 셀/Tab-아래 셀, false : Enter-아래 셀/Tab-다음 셀)
	this.tabKeyAction = 0; //탭키 동작(다음 컨트롤 : 0-SHEET_TAB_TONEXTCTRL / 다음 셀 : 1-SHEET_TAB_TONEXTCELL)
	this.editingCellObject = null; //현재 편집중인 셀(td) 객체
	
	this.needColumnMerge = SHEET_MERGE_UNFIXED;
	
	this.selectMode = SHEET_SELECT_NONE;
	this.selectedObject = null;	//현재 선택된 객체
	this.mouseOverObject = null; //현재 마우스가 위치해 있는 객체
	this.rowStyleClass = null;
	this.cellStyleClass = null;
	
	this.editableFixedColumn = true;
	this.useContextMenu = true;
	this.sortOnHeader = true;
	
	this.rowNumOrder = true;
	this.displayScrollBar = true;
	this.displayOddEven = true;
    
	//시트 각 파트별 태그 객체
	this.SheetObject = null;
	this.SheetHeaderObject = null;
	this.SheetContentObject = null;
	this.SheetFooterObject = null;
	this.SheetVScrollObject = null;
	this.SheetHScrollObject = null;
	//좌측고정열 관련 태그
	this.SheetHeaderLeftFixObject = null;
	this.SheetContentLeftFixObject = null;
	this.SheetFooterLeftFixObject = null;
	//우측고정열 관련 태그
	this.SheetHeaderRightFixObject = null;
	this.SheetContentRightFixObject = null;
	this.SheetFooterRightFixObject = null;
	//시트 편집 관련 태그
	this.SheetMsgBox = null;
	this.SheetZoomImgeBox = null;
	this.SheetControlTempDivObject = null;
	this.SheetEidtTextDivObject = null;
	this.SheetEidtCheckDivObject = null;
	this.SheetEidtComboDivObject = null;
	this.SheetEidtDateDivOBject = null;
	this.SheetEditCalenderObject = null;
	
	this.parentControlName = null;
	
	if( tagObject ){
		//최대 줄 수(멀티로우)
		this.rowsPerDataRow = tagObject.getAttribute("rowsperdatarow");
		this.rowsPerDataRow = (this.rowsPerDataRow == null || (typeof this.rowsPerDataRow == "string" && this.rowsPerDataRow.length <= 0)) ? 1 : (1 * this.rowsPerDataRow);
		//최대 열 수
		this.colsPerRow = tagObject.getAttribute("colsperrow");
		this.colsPerRow = (this.colsPerRow == null || (typeof this.colsPerRow == "string" && this.colsPerRow.length <= 0)) ? 1 : (1 * this.colsPerRow);
		//좌측고정열 수
		this.leftFixColumnCount = tagObject.getAttribute("leftfixedcount");
		this.leftFixColumnCount = (this.leftFixColumnCount == null || (typeof this.leftFixColumnCount == "string" && this.leftFixColumnCount.length <= 0)) ? 0 : (1 * this.leftFixColumnCount);
		//우측고정열 수
		this.rightFixColumnCount = tagObject.getAttribute("rightfixedcount");
		this.rightFixColumnCount = (this.rightFixColumnCount == null || (typeof this.rightFixColumnCount == "string" && this.rightFixColumnCount.length <= 0)) ? 0 : (1 * this.rightFixColumnCount);
		
		//시트 태그 생성
		if( typeof this._ResetSheet == "function" ){
			this._ResetSheet(tagObject);
		}
		
		var i = 0; var j = 0; var n = 0;
		
		//각 파트별 태그 객체 설정
		this.SheetObject = tagObject;
		this.SheetHeaderObject = document.getElementsByName(this.controlId + "_SheetHeader")[0];	//헤더 Div
		this.SheetContentObject = document.getElementsByName(this.controlId + "_SheetContent")[0];	//본문 Div
		this.SheetFooterObject = document.getElementsByName(this.controlId + "_SheetFooter")[0];	//푸터 Div
		this.SheetVScrollObject = document.getElementsByName(this.controlId + "_SheetVScroll")[0];	//수직스크롤 Div
		this.SheetHScrollObject = document.getElementsByName(this.controlId + "_SheetHScroll")[0];	//수평스크롤 Div
		
		this.SheetHeaderLeftFixObject = document.getElementsByName(this.controlId + "_SheetHeaderLeftFixDiv")[0];	//좌측고정 헤더 Div
		this.SheetContentLeftFixObject = document.getElementsByName(this.controlId + "_SheetContentLeftFixDiv")[0];	//좌측고정 본문 Div
		this.SheetFooterLeftFixObject = document.getElementsByName(this.controlId + "_SheetFooterLeftFixDiv")[0];	//좌측고정 푸터 Div
		
		this.SheetHeaderRightFixObject = document.getElementsByName(this.controlId + "_SheetHeaderRightFixDiv")[0];   //우측고정 헤더 Div
		this.SheetContentRightFixObject = document.getElementsByName(this.controlId + "_SheetContentRightFixDiv")[0]; //우측고정 본문 Div
		this.SheetFooterRightFixObject = document.getElementsByName(this.controlId + "_SheetFooterRightFixDiv")[0];   //우측고정 푸터 Div
		
		this.SheetMsgBox = document.getElementsByName(this.controlId + "_SheetMsgBox")[0]; //시트 메세지 알림 박스
		this.SheetZoomImgeBox = document.getElementsByName(this.controlId + "_SheetZoomImgeBox")[0]; //시트 이미지 셀 확대 이미지
		this.SheetControlTempDivObject = document.getElementsByName(this.controlId + "_SheetControlTempDiv")[0]; //임시 편집 컨트롤 교체 보관
		this.SheetEidtTextDivObject = document.getElementsByName(this.controlId + "_SheetEidtTextDiv")[0]; //시트 편집 텍스트 컨트롤
		this.SheetEidtCheckDivObject = document.getElementsByName(this.controlId + "_SheetEidtCheckDiv")[0]; //시트 편집 체크 컨트롤
		this.SheetEidtComboDivObject = document.getElementsByName(this.controlId + "_SheetEidtComboDiv")[0]; //시트 편집 콤보 컨트롤
		this.SheetEidtDateDivOBject = document.getElementsByName(this.controlId + "_SheetEidtDateDiv")[0]; //시트 편집 일자(날짜) 컨트롤
		this.SheetEditCalenderObject = document.getElementsByName(this.controlId + "_EasySheetCalender")[0]; //시트 편집 달력 컨트롤
		
		this.isShowFooter = (this.SheetFooterObject != null && typeof this.SheetFooterObject != "undefined"); //시트 푸터 보이기 여부 설정
		
//		this.leftFixColumnCount = tagObject.getAttribute("leftfixedcount");
//		this.leftFixColumnCount = (this.leftFixColumnCount == null || (typeof this.leftFixColumnCount == "string" && this.leftFixColumnCount.length <= 0)) ? 0 : (1 * this.leftFixColumnCount);
		
//		this.rightFixColumnCount = tagObject.getAttribute("rightfixedcount");
//		this.rightFixColumnCount = (this.rightFixColumnCount == null || (typeof this.rightFixColumnCount == "string" && this.rightFixColumnCount.length <= 0)) ? 0 : (1 * this.rightFixColumnCount);
		
//		this.rowsPerDataRow = tagObject.getAttribute("rowsperdatarow");
//		this.rowsPerDataRow = (this.rowsPerDataRow == null || (typeof this.rowsPerDataRow == "string" && this.rowsPerDataRow.length <= 0)) ? 1 : (1 * this.rowsPerDataRow);
		
//		this.colsPerRow = tagObject.getAttribute("colsperrow");
//		this.colsPerRow = (this.colsPerRow == null || (typeof this.colsPerRow == "string" && this.colsPerRow.length <= 0)) ? 1 : (1 * this.colsPerRow);
		
		var columnWidthStr = this.SheetHeaderObject.getAttribute("cellwidths");
		var columnMinWidthStr = this.SheetHeaderObject.getAttribute("cellminwidths");
		var columnWidthArr = null;
		var columnMinWidthArr = null;
		var columnWidthsSize = 0;
		if( typeof columnWidthStr == "string" ){
			if( columnWidthStr.match(/.+;$/) )
				columnWidthStr = columnWidthStr.substring(0, columnWidthStr.length - 1);
			if( columnMinWidthStr.match(/.+;$/) )
				columnMinWidthStr = columnMinWidthStr.substring(0, columnMinWidthStr.length - 1);
			
			columnWidthArr = columnWidthStr.split(";");
			columnMinWidthArr = columnMinWidthStr.split(";");
			columnWidthsSize = columnWidthArr.length;
			
			if( columnWidthsSize > 0 ){
				this.columnWidths = [];
				
				var colWidth = null; var colMinWidth = null;
				var pxRegexp = /[0-9]+\.?[0-9]*px$/;
				var perRegexp = /[0-9]+\.?[0-9]*%$/;
				
				for(i = 0; i < columnWidthsSize; i++, colWidth = null){
					colWidth = columnWidthArr[i];
					colMinWidth = columnMinWidthArr[i];
					
					//열 너비 정보 객체 설정
					if( pxRegexp.test(colWidth) ){			//고정형 열 너비
							this.columnWidths[i] = {
								"isFixed" : true
								, "width" : 1 * colWidth.replace("px", "")
								, "minWidth" : 1 * colMinWidth.replace("px", "")
							};
					}
					else if( perRegexp.test(colWidth) ){	//반응형 열 너비
							this.columnWidths[i] = {
								"isFixed" : false
								, "width" : 1 * colWidth.replace("%", "")
								, "minWidth" : 1 * colMinWidth.replace("px", "")
							};
					}
					else	this.columnWidths[i] = null;
				}
				
				//메모리 해제
				perRegexp = null; pxRegexp = null;
			}
			
			//메모리 해제
			columnWidthArr.clear(); columnWidthArr = null;
		}
		columnWidthStr = null;
		
		var sheetHeaderTable = null;
		var sheetHeaderTableRows = null;
		var cssStyleDeclaration = null;
		var isShowHeaderTableRowTitle = true;
		var isShowHeaderLeftFixTableRowTitle = true;
		
		sheetHeaderTable = document.getElementsByName(this.controlId + "_SheetHeaderTable")[0];
		if( typeof sheetHeaderTable != "undefined" ){
			sheetHeaderTableRows = sheetHeaderTable.getElementsByTagName("tr");
			
			//시트 헤더 정보 세팅
			this._InitializeHeaderInfo(sheetHeaderTableRows);
			//시트 헤더의 컬럼 개수를 설정
			this.maxColumnCount = this.headerInfo[this.headerInfo.length - 1].cellCount;
			//시트 행 별 컬럼 개수 세팅
			this.colsPerRow = this.rowsPerDataRow == 1 ? this.maxColumnCount : this.colsPerRow;
			//시트 헤더 첫번째 열의 display 상태가 none 이 아닌 경우 시트 헤더의 행 타이틀은 보이는 상태임
			isShowHeaderTableRowTitle = (getComputedStyle(sheetHeaderTableRows[0].getElementsByTagName("th")[0]).display != "none");
			//메모리 해제
			sheetHeaderTableRows = null;
		}
		sheetHeaderTable = null;
		
		sheetHeaderTable = document.getElementsByName(this.controlId + "_SheetHeaderLeftFixTable")[0];
		if( typeof sheetHeaderTable != "undefined"){
			//좌측 고정열 생성
			this._CreateLeftFixColumns();
			//시트 좌측고정 헤더 첫번째 열의 display 상태가 none 이 아닌 경우 시트 좌측고정 헤더의 행 타이틀은 보이는 상태임
			sheetHeaderTableRows = sheetHeaderTable.getElementsByTagName("tr");
			isShowHeaderLeftFixTableRowTitle = (getComputedStyle(sheetHeaderTableRows[0].getElementsByTagName("th")[0]).display != "none");
			//메모리 해제
			sheetHeaderTableRows = null;
		}
		sheetHeaderTable = null;
		
		sheetHeaderTable = document.getElementsByName(this.controlId + "_SheetHeaderRightFixTable")[0];
		if( typeof sheetHeaderTable != "undefined"){
			//우측 고정열 생성
			this._CreateRightFixColumns();
		}
		sheetHeaderTable = null;
		
        /*
            1. 속성 초기화 설정
        */
		
		//시트 푸터 설정
		if( this.isShowFooter ){
			cssStyleDeclaration = getComputedStyle(this.SheetFooterObject);
			this.footerHeight = 1 * (cssStyleDeclaration.height).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
			cssStyleDeclaration = null;
			
			cssStyleDeclaration = getComputedStyle(this.SheetObject.querySelector("div.SheetDiv"));
			this.SheetFooterObject.style.top = "calc(" + cssStyleDeclaration.height + " - " + this.footerHeight + "px)";
			cssStyleDeclaration = null;
			
			var footerRows = this.SheetFooterObject.querySelectorAll("div.SheetFooterDiv > table tr");
			this.footerRowCount = footerRows.length / this.rowsPerDataRow;
			footerRows = null;
		}
		else{
			this.footerHeight = 0;
			this.footerRowCount = 0;
		}
        
		//시트 타입 설정
		this.isListSheet = ((tagObject.getAttribute("islistsheet") == "true") ? true : false);
		this.selectMode = (this.isListSheet ? SHEET_SELECT_ROW : SHEET_SELECT_CELL);
		
		//헤더 숨김여부 설정
		this.isShowHeader = !(getComputedStyle(this.SheetHeaderObject).display == "none");
		//헤더 숨김여부에 따른 스타일 수정
        if( !this.isShowHeader ){
        	this.SheetContentObject.style.marginTop = "0px";
        	this.SheetContentObject.style.height = "calc(100% - 0px)";
        	this.SheetVScrollObject.querySelector("div.SheetVScrollBody").style.top = "0px";
        }
        //행 타이틀 숨김여부 설정
        this.isShowRowHeader = (isShowHeaderTableRowTitle && isShowHeaderLeftFixTableRowTitle);
		
		//시트 헤더 정보 초기화 설정
		cssStyleDeclaration = getComputedStyle(this.SheetHeaderObject);
		this.sheetHeaderDivWidth = 1 * (cssStyleDeclaration.width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
		this.sheetHeaderDivHeight = 1 * (cssStyleDeclaration.height).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
		if( !this.isShowHeader ) this.sheetHeaderDivHeight = 0;
		this.sheetHeaderTableWidth = 1 * (getComputedStyle(document.getElementsByName(this.controlId + "_SheetHeaderTable")[0]).width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
		cssStyleDeclaration = null;
		
		//시트 좌측고정 헤더 너비
		if( typeof this.SheetHeaderLeftFixObject != "undefined" && this.SheetHeaderLeftFixObject != null ){
			cssStyleDeclaration = getComputedStyle(this.SheetHeaderLeftFixObject);
			this.sheetLeftFixWidth = (1 * (cssStyleDeclaration.width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0)) + 1;
			cssStyleDeclaration = null;
		}
		
		//시트 우측고정 헤더 너비
		if( typeof this.SheetHeaderRightFixObject != "undefined" && this.SheetHeaderRightFixObject != null ){
			cssStyleDeclaration = getComputedStyle(this.SheetHeaderRightFixObject);		
			this.sheetRightFixWidth = (1 * (cssStyleDeclaration.width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0)) + 1;
			cssStyleDeclaration = null;
		}
		//시트 좌측고정 너비 + 우측고정 너비 만큼 시트 최소 너비 설정
		this.SheetObject.style.minWidth = (this.sheetLeftFixWidth + this.sheetRightFixWidth + 1) + "px";
        
        //시트 본문 정보 초기화 설정
        cssStyleDeclaration = getComputedStyle(this.SheetContentObject);
        this.sheetContentDivWidth = 1 * (cssStyleDeclaration.width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
        this.sheetContentDivHeight = 1 * (cssStyleDeclaration.height).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
        this.sheetContentTableWidth = 1 * (getComputedStyle(document.getElementsByName(this.controlId + "_SheetContentTable")[0]).width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
        cssStyleDeclaration = null;
		
		//헤더 높이 설정
		this.headerHeight = 1 * (getComputedStyle(this.SheetHeaderObject).height).replace("px", ""); // + (IS_IE_BROWSER ? 1 : 0);
		if( !this.isShowHeader ) this.headerHeight = 0;
		//헤더 열 타이틀 숨김 여부 설정
//		var headerTableHeight = 1 * (getComputedStyle(this.SheetHeaderObject.querySelector("div.SheetHeaderDiv > table")).height).replace("px", "");
//		this.isShowColHeader = ((this.headerHeight + 1) - headerTableHeight == 0);
		var headerTableHeight = Math.floor(1 * (getComputedStyle(this.SheetHeaderObject.querySelector("div.SheetHeaderDiv > table" + (IS_IE_BROWSER ? "" : " > tbody"))).height).replace("px", ""));
		this.isShowColHeader = (this.headerHeight + 1 >= headerTableHeight);
		//행 높이 설정
        this.rowHeight = 1 * (getComputedStyle(this.SheetContentObject.getElementsByTagName("tr")[0]).height).replace("px", ""); // + (IS_IE_BROWSER ? 1 : 0);
        //시트 본문 내 출력 가능한 최대 행수 설정
        this.displayMaxRowCount = Math.ceil(Math.ceil(this.sheetContentDivHeight / this.rowHeight) / this.rowsPerDataRow);
        this.wholeShownRowCount = Math.floor(Math.floor(this.sheetContentDivHeight / this.rowHeight) / this.rowsPerDataRow);
		
		//행 개수만큼 행 생성/복사
		if( this.displayMaxRowCount > 1 ){
			var sheetContentTable = null;
			var sheetContentTableTbody = null;
			var trObjects = null;
			//시트 좌측고정
			var sheetContentLeftFixTable = null;
			var sheetContentLeftFixTableTbody = null;
			var leftFixTrObjects = null;
			//시트 우측고정
			var sheetContentRightFixTable = null;
			var sheetContentRightFixTableTbody = null;
			var rightFixTrObjects = null;
			//행 객체
			var rowObject = null;
			var hasLeftFix = null;
			var hasRightFix = null;
			var trObjectCount = 0;
			
			hasLeftFix = (typeof this.SheetHeaderLeftFixObject != "undefined" && this.SheetHeaderLeftFixObject != null);
			hasRightFix = (typeof this.SheetHeaderRightFixObject != "undefined" && this.SheetHeaderRightFixObject != null);
			
			//시트 본문 설정
			sheetContentTable = document.getElementsByName(this.controlId + "_SheetContentTable")[0];
			sheetContentTableTbody = sheetContentTable.getElementsByTagName("tbody")[0];
			trObjects = sheetContentTable.getElementsByTagName("tr");
			trObjectCount = trObjects.length;
			//시트 좌측고정
			if( hasLeftFix ){
				sheetContentLeftFixTable = document.getElementsByName(this.controlId + "_SheetContentLeftFixTable")[0];
				sheetContentLeftFixTableTbody = sheetContentLeftFixTable.getElementsByTagName("tbody")[0];
				leftFixTrObjects = sheetContentLeftFixTable.getElementsByTagName("tr");
			}
			//시트 우측고정
			if( hasRightFix ){
				sheetContentRightFixTable = document.getElementsByName(this.controlId + "_SheetContentRightFixTable")[0];
				sheetContentRightFixTableTbody = sheetContentRightFixTable.getElementsByTagName("tbody")[0];
				rightFixTrObjects = sheetContentRightFixTable.getElementsByTagName("tr");
			}
			//행 타이틀 너비 설정
			if( this.isShowRowHeader && trObjectCount > 0 )
				this.sheetRowHeaderWidth = (1 * getComputedStyle(trObjects[0].querySelector("td.RowHeader")).width.replace("px", "")) + 1;
			else if( !this.isShowRowHeader && trObjectCount > 0 )
				this.sheetRowHeaderWidth = 0;
			
			for(i = trObjectCount / this.rowsPerDataRow; i < this.displayMaxRowCount; i++){
				for(j = 0; j < trObjectCount; j++){
					//행 복사(자식 포함)
					rowObject = trObjects[j].cloneNode(true);
					//행 인덱스 설정
					rowObject.setAttribute("rowIndex", i);
					//본문 테이블의 tbody 태그가 있다면 tbody 에 행을 추가하고, 없다면 table 에 추가
					if( typeof sheetContentTableTbody != "undefined" && sheetContentTableTbody != null )
						sheetContentTableTbody.appendChild(rowObject);
					else
						sheetContentTable.appendChild(rowObject);
					//메모리 해제
					rowObject = null;
					
					//좌측 고정열 
					if( hasLeftFix ){
						//행 복사(자식 포함)
						rowObject = leftFixTrObjects[j].cloneNode(true);
						//행 인덱스 설정
						rowObject.setAttribute("rowIndex", i);
						//본문 테이블의 tbody 태그가 있다면 tbody 에 행을 추가하고, 없다면 table 에 추가
						if( typeof sheetContentLeftFixTableTbody != "undefined" && sheetContentLeftFixTableTbody != null )
							sheetContentLeftFixTableTbody.appendChild(rowObject);
						else
							sheetContentLeftFixTable.appendChild(rowObject);
						//메모리 해제
						rowObject = null;
					}
					
					//우측 고정열
					if( hasRightFix ){
						//행 복사(자식 포함)
						rowObject = rightFixTrObjects[j].cloneNode(true);
						//행 인덱스 설정
						rowObject.setAttribute("rowIndex", i);
						//본문 테이블의 tbody 태그가 있다면 tbody 에 행을 추가하고, 없다면 table 에 추가
						if( typeof sheetContentRightFixTableTbody != "undefined" && sheetContentRightFixTableTbody != null )
							sheetContentRightFixTableTbody.appendChild(rowObject);
						else
							sheetContentRightFixTable.appendChild(rowObject);
						//메모리 해제
						rowObject = null;
					}
				}
			}
			
			//메모리 해제
			hasRightFix = null; hasLeftFix = null; rowObject = null;
			rightFixTrObjects = null; sheetContentRightFixTableTbody = null; sheetContentRightFixTable = null;
			leftFixTrObjects = null; sheetContentLeftFixTableTbody = null; sheetContentLeftFixTable = null;
			trObjects = null; sheetContentTableTbody = null; sheetContentTable = null;
		}
        
        //시트 수직스크롤 초기화 설정
        this.vScrollWidth = (1 * (getComputedStyle(this.SheetVScrollObject).width).replace("px", "")) + (IS_IE_BROWSER ? 1 : 0) + "px";
        this.vScrollTrackHeight = 1 * (getComputedStyle(document.getElementsByName(this.controlId + "_SheetVScrollTrack")[0]).height).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
        this.SheetVScrollObject.style.display = "none";
        
        //시트 수평스크롤 초기화 설정(수직스크롤은 로드시 행이 1행만 있으므로 따로 설정하지 않음)
        this.hScrollHeight =(1 * (getComputedStyle(this.SheetHScrollObject, null).height).replace("px", "")) + (IS_IE_BROWSER ? 1 : 0) + "px";
        //-수평스크롤 보이기 여부
        this.isShowHScroll = (this.sheetContentDivWidth < this.sheetContentTableWidth);
        //-시트 수평스크롤 Track, Face 너비 설정
        if( this.isShowHScroll ){
            this.hScrollTrackWidth = 1 * (getComputedStyle(document.getElementsByName(this.controlId + "_SheetHScrollTrack")[0]).width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
            this.hScrollFaceWidth = (this.hScrollTrackWidth * this.sheetContentDivWidth) / this.sheetContentTableWidth + (IS_IE_BROWSER ? 1 : 0);
            (document.getElementsByName(this.controlId + "_SheetHScrollFace")[0]).style.width = this.hScrollFaceWidth + "px";
            this.tableMovePerHScrollFaceMove = this.sheetContentDivWidth / this.hScrollFaceWidth;
        }
        else{
            this.SheetHScrollObject.style.display = "none";
        }
        
        /*
            2. 이벤트 처리
        */
		
        //시트 수평스크롤 이벤트 설정
        var sheetScrollArrow = null;
        var sheetScrollTrack = null;
        var sheetScrollFace = null;
        // -좌방향 버튼 클릭
        sheetScrollArrow = this.SheetHScrollObject.querySelector("div.SheetHScrollLeftArrow");
        setEventHandler(sheetScrollArrow, "mousedown", sheetHScrollLeftArrowDown);
        setEventHandler(sheetScrollArrow, "mouseup", sheetHScrollArrowUp);
        setEventHandler(sheetScrollArrow, "mouseout", sheetHScrollArrowUp);
        sheetScrollArrow = null;
        // -우방향 버튼 클릭
        sheetScrollArrow = this.SheetHScrollObject.querySelector("div.SheetHScrollRightArrow");
        setEventHandler(sheetScrollArrow, "mousedown", sheetHScrollRightArrowDown);
        setEventHandler(sheetScrollArrow, "mouseup", sheetHScrollArrowUp);
        setEventHandler(sheetScrollArrow, "mouseout", sheetHScrollArrowUp);
        sheetScrollArrow = null;
        // -스크롤 Track 클릭
        sheetScrollTrack = this.SheetHScrollObject.querySelector("div.SheetHScrollTrack");
        setEventHandler(sheetScrollTrack, "mousedown", sheetHScrollTrackClick);
        // -스크롤 Face 드래그
        sheetScrollFace = sheetScrollTrack.querySelector("div.SheetHScrollFace");
        setEventHandler(sheetScrollFace, "mousedown", sheetHScrollFaceMouseDown);
        setEventHandler(sheetScrollFace, "mousemove", sheetHScrollFaceMouseMove);
        setEventHandler(sheetScrollFace, "mouseup", sheetHScrollFaceMouseUp);
        setEventHandler(document, "mousemove", sheetHScrollFaceMouseMove);
        setEventHandler(document, "mouseup", sheetHScrollFaceMouseUp);
        sheetScrollTrack = null;
        sheetScrollFace = null;
		
		//시트 수직스크롤 이벤트 설정
		// -위방향 버튼 클릭
        sheetScrollArrow = this.SheetVScrollObject.querySelector("div.SheetVScrollBody > div.SheetVScrollUpArrow");
		setEventHandler(sheetScrollArrow, "mousedown", sheetVScrollUpArrowDown);
		setEventHandler(sheetScrollArrow, "mouseup", sheetVScrollArrowUp);
		setEventHandler(sheetScrollArrow, "mouseout", sheetVScrollArrowUp);
		sheetScrollArrow = null;
		// -아래방향 버튼 클릭
		sheetScrollArrow = this.SheetVScrollObject.querySelector("div.SheetVScrollBody > div.SheetVScrollDownArrow");
		setEventHandler(sheetScrollArrow, "mousedown", sheetVScrollDownArrowDown);
		setEventHandler(sheetScrollArrow, "mouseup", sheetVScrollArrowUp);
		setEventHandler(sheetScrollArrow, "mouseout", sheetVScrollArrowUp);
		sheetScrollArrow = null;
		// -스크롤 Track 클릭
		sheetScrollTrack = this.SheetVScrollObject.querySelector("div.SheetVScrollBody > div.SheetVScrollTrack");
        setEventHandler(sheetScrollTrack, "mousedown", sheetVScrollTrackClick);
		// -스크롤 Face 드래그
        sheetScrollFace = sheetScrollTrack.querySelector("div.SheetVScrollFace");
		setEventHandler(sheetScrollFace, "mousedown", sheetVScrollFaceMouseDown);
		setEventHandler(sheetScrollFace, "mousemove", sheetVScrollFaceMouseMove);
		setEventHandler(sheetScrollFace, "mouseup", sheetVScrollFaceMouseUp);
		setEventHandler(document, "mousemove", sheetVScrollFaceMouseMove);
		setEventHandler(document, "mouseup", sheetVScrollFaceMouseUp);
		sheetScrollFace = null;
		sheetScrollTrack = null;
		// -마우스 휠 동작
		setEventHandler(this.SheetContentObject, "wheel", sheetVScrollMouseWheel);
		setEventHandler(this.SheetVScrollObject.querySelector("div.SheetVScrollBody"), "wheel", sheetVScrollMouseWheel);
		
		//헤더 클릭 이벤트 설정(정렬,필터)
		// -헤더
		setEventHandler(this.SheetHeaderObject.querySelector("div.SheetHeaderDiv > table"), "mouseup", sheetHeaderTableMouseUp);
		// -좌측고정 헤더
		if( this.SheetHeaderLeftFixObject != null && typeof this.SheetHeaderLeftFixObject != "undefined" ){
			setEventHandler(this.SheetHeaderLeftFixObject.querySelector("table"), "mouseup", sheetHeaderTableMouseUp);
		}
		// -우측고정 헤더
		if( this.SheetHeaderRightFixObject != null && typeof this.SheetHeaderRightFixObject != "undefined" ){
			setEventHandler(this.SheetHeaderRightFixObject.querySelector("table"), "mouseup", sheetHeaderTableMouseUp);
		}
		
		//시트 편집 이벤트 설정
		var sheetContentTable = null;
		var sheetEditObject = null;
		// -본문
		sheetContentTable = this.SheetContentObject.querySelector("div.SheetContentDiv > table");
		setEventHandler(sheetContentTable, "click", sheetContentTableClick);
		setEventHandler(sheetContentTable, "dblclick", sheetContentTableDoubleClick);
		setEventHandler(sheetContentTable, "mouseover", sheetContentTableMouseOver);
		setEventHandler(sheetContentTable, "mouseout", sheetContentTableMouseOut);
		sheetContentTable = null;
		// -좌측고정열
		if( typeof this.SheetHeaderLeftFixObject != "undefined" && this.SheetHeaderLeftFixObject != null ){
			sheetContentTable = this.SheetContentLeftFixObject.querySelector("table");
			setEventHandler(sheetContentTable, "click", sheetContentTableClick);
			setEventHandler(sheetContentTable, "dblclick", sheetContentTableDoubleClick);
			setEventHandler(sheetContentTable, "mouseover", sheetContentTableMouseOver);
			setEventHandler(sheetContentTable, "mouseout", sheetContentTableMouseOut);
			sheetContentTable = null;
		}
		// -우측고정열
		if( typeof this.SheetHeaderRightFixObject != "undefined" && this.SheetHeaderRightFixObject != null ){
			sheetContentTable = this.SheetContentRightFixObject.querySelector("table");
			setEventHandler(sheetContentTable, "click", sheetContentTableClick);
			setEventHandler(sheetContentTable, "dblclick", sheetContentTableDoubleClick);
			setEventHandler(sheetContentTable, "mouseover", sheetContentTableMouseOver);
			setEventHandler(sheetContentTable, "mouseout", sheetContentTableMouseOut);
			sheetContentTable = null;
		}
		// -편집 텍스트박스 이벤트
		sheetEditObject = this.SheetEidtTextDivObject.querySelector("input.SheetEidtTextbox");
		setEventHandler(sheetEditObject, "blur", sheetEidtTextboxBlur);
		setEventHandler(sheetEditObject, "mouseup", sheetEidtTextboxMouseUp);
		setEventHandler(sheetEditObject, "click", sheetEidtTextboxMouseUp);
		setEventHandler(sheetEditObject, "keydown", sheetEidtTextboxKeydown);
		sheetEditObject = null;
		// -편집 체크박스 이벤트
		setEventHandler(this.SheetEidtCheckDivObject, "blur", sheetEidtCheckboxBlur);
		setEventHandler(this.SheetEidtCheckDivObject, "mouseup", sheetEidtCheckboxMouseUp);
		setEventHandler(this.SheetEidtCheckDivObject, "click", sheetEidtCheckboxClick);
		setEventHandler(this.SheetEidtCheckDivObject, "keydown", sheetEidtCheckboxKeydown);
		// -편집 콤보박스 이벤트
		sheetEditObject = this.SheetEidtComboDivObject.querySelector("select.SheetEidtCombobox");
		setEventHandler(sheetEditObject, "blur", sheetEidtComboboxBlur);
		setEventHandler(sheetEditObject, "change", sheetEditComboboxChange);
		setEventHandler(sheetEditObject, "mouseup", sheetEidtComboboxMouseUp);
		setEventHandler(sheetEditObject, "click", sheetEidtComboboxMouseUp);
		setEventHandler(sheetEditObject, "keydown", sheetEidtComboboxKeydown);
		sheetEditObject = null;
		// -편집 일자(날짜) 텍스트박스 이벤트
		setEventHandler(this.SheetEidtDateDivOBject, "mouseup", sheetEidtDateMouseUp);
		setEventHandler(this.SheetEidtDateDivOBject, "click", sheetEidtDateMouseUp);
//		sheetEditObject = document.getElementsByName(this.controlId + "_SheetEidtDateInput")[0];
		sheetEditObject = this.SheetEidtDateDivOBject.querySelector("input.SheetEidtDateInput");
		setEventHandler(sheetEditObject, "blur", sheetEidtDateInputBlur);
		setEventHandler(sheetEditObject, "keydown", sheetEidtDateInputKeydown);
		sheetEditObject = null;
//		sheetEditObject = document.getElementsByName(this.controlId + "_SheetEidtDateCalender")[0];
		sheetEditObject = this.SheetEidtDateDivOBject.querySelector("div.SheetEidtDateCalender");
		setEventHandler(sheetEditObject, "mouseover", sheetEidtDateCalenderMouseOver);
		setEventHandler(sheetEditObject, "mouseout", sheetEidtDateCalenderMouseOut);
		setEventHandler(sheetEditObject, "click", sheetEidtDateCalenderClick);
		sheetEditObject = null;
		
		//시트 동작가능 패널 이벤트
		var sheetDisabledPanelObj = this.SheetObject.querySelector("div.SheetDisabledPanel");
		if( sheetDisabledPanelObj != null && typeof sheetDisabledPanelObj != "undefined" ){
			setEventHandler(sheetDisabledPanelObj, "mousedown", sheetSheetDisabledPanelEvent);
			setEventHandler(sheetDisabledPanelObj, "mouseup", sheetSheetDisabledPanelEvent);
			setEventHandler(sheetDisabledPanelObj, "click", sheetSheetDisabledPanelEvent);
			setEventHandler(sheetDisabledPanelObj, "keydown", sheetSheetDisabledPanelEvent);
			setEventHandler(sheetDisabledPanelObj, "keyup", sheetSheetDisabledPanelEvent);
		}
		sheetDisabledPanelObj = null;
		
		//시트 컬럼 너비 리사이즈 이벤트
		// -컬럼 리사이저 마우스 다운(컬럼 너비 조정 시작) 이벤트
		var resizerObjects = this.SheetObject.querySelectorAll("div.resizer");
		var resizerObject = null;
		var resizerCount = resizerObjects.length;
		for(i = 0; i < resizerCount; i++){
			resizerObject = resizerObjects[i];
			setEventHandler(resizerObject, "mousedown", sheetResizerMousedown);
			resizerObject = null;
		}
		resizerObjects = null;
		// -컬럼 리사이저 마우스 업(컬럼 너비 조정 완료) 이벤트
		setEventHandler(this.SheetObject, "mouseup", sheetResizerMouseup);
		setEventHandler(this.SheetHeaderObject, "mouseup", sheetResizerMouseup);
		setEventHandler(this.SheetContentObject, "mouseup", sheetResizerMouseup);
		// -컬럼 리사이저 이동 이벤트
		setEventHandler(this.SheetObject, "mousemove", sheetResizerMousemove);
		setEventHandler(this.SheetHeaderObject, "mousemove", sheetResizerMousemove);
		setEventHandler(this.SheetContentObject, "mousemove", sheetResizerMousemove);
    }
};

EasySheetRenderer.prototype.destroy = function(){
	/*
	 *	1. 이벤트 제거
	 */
	//시트 수평스크롤 이벤트 제거
	var sheetScrollArrow = null;
	var sheetScrollTrack = null;
	var sheetScrollFace = null;
	// -좌방향 버튼 클릭
	sheetScrollArrow = this.SheetHScrollObject.querySelector("div.SheetHScrollLeftArrow");
	removeEventHandler(sheetScrollArrow, "mousedown", sheetHScrollLeftArrowDown);
	removeEventHandler(sheetScrollArrow, "mouseup", sheetHScrollArrowUp);
	removeEventHandler(sheetScrollArrow, "mouseout", sheetHScrollArrowUp);
	sheetScrollArrow = null;
	// -우방향 버튼 클릭
	sheetScrollArrow = this.SheetHScrollObject.querySelector("div.SheetHScrollRightArrow");
	removeEventHandler(sheetScrollArrow, "mousedown", sheetHScrollRightArrowDown);
	removeEventHandler(sheetScrollArrow, "mouseup", sheetHScrollArrowUp);
	removeEventHandler(sheetScrollArrow, "mouseout", sheetHScrollArrowUp);
	sheetScrollArrow = null;
	// -스크롤 Track 클릭
	sheetScrollTrack = this.SheetHScrollObject.querySelector("div.SheetHScrollTrack");
	removeEventHandler(sheetScrollTrack, "mousedown", sheetHScrollTrackClick);
	// -스크롤 Face 드래그
	sheetScrollFace = sheetScrollTrack.querySelector("div.SheetHScrollFace");
	removeEventHandler(sheetScrollFace, "mousedown", sheetHScrollFaceMouseDown);
	removeEventHandler(sheetScrollFace, "mousemove", sheetHScrollFaceMouseMove);
	removeEventHandler(sheetScrollFace, "mouseup", sheetHScrollFaceMouseUp);
	removeEventHandler(document, "mousemove", sheetHScrollFaceMouseMove);
	removeEventHandler(document, "mouseup", sheetHScrollFaceMouseUp);
	sheetScrollTrack = null;
	sheetScrollFace = null;
	
	//시트 수직스크롤 이벤트 제거
	// -위방향 버튼 클릭
	sheetScrollArrow = this.SheetVScrollObject.querySelector("div.SheetVScrollBody > div.SheetVScrollUpArrow");
	removeEventHandler(sheetScrollArrow, "mousedown", sheetVScrollUpArrowDown);
	removeEventHandler(sheetScrollArrow, "mouseup", sheetVScrollArrowUp);
	removeEventHandler(sheetScrollArrow, "mouseout", sheetVScrollArrowUp);
	sheetScrollArrow = null;
	// -아래방향 버튼 클릭
	sheetScrollArrow = this.SheetVScrollObject.querySelector("div.SheetVScrollBody > div.SheetVScrollDownArrow");
	removeEventHandler(sheetScrollArrow, "mousedown", sheetVScrollDownArrowDown);
	removeEventHandler(sheetScrollArrow, "mouseup", sheetVScrollArrowUp);
	removeEventHandler(sheetScrollArrow, "mouseout", sheetVScrollArrowUp);
	sheetScrollArrow = null;
	// -스크롤 Track 클릭
	sheetScrollTrack = this.SheetVScrollObject.querySelector("div.SheetVScrollBody > div.SheetVScrollTrack");
	removeEventHandler(sheetScrollTrack, "mousedown", sheetVScrollTrackClick);
	// -스크롤 Face 드래그
	sheetScrollFace = sheetScrollTrack.querySelector("div.SheetVScrollFace");
	removeEventHandler(sheetScrollFace, "mousedown", sheetVScrollFaceMouseDown);
	removeEventHandler(sheetScrollFace, "mousemove", sheetVScrollFaceMouseMove);
	removeEventHandler(sheetScrollFace, "mouseup", sheetVScrollFaceMouseUp);
	removeEventHandler(document, "mousemove", sheetVScrollFaceMouseMove);
	removeEventHandler(document, "mouseup", sheetVScrollFaceMouseUp);
	sheetScrollFace = null;
	sheetScrollTrack = null;
	// -마우스 휠 동작
	removeEventHandler(this.SheetContentObject, "wheel", sheetVScrollMouseWheel);
	removeEventHandler(this.SheetVScrollObject.querySelector("div.SheetVScrollBody"), "wheel", sheetVScrollMouseWheel);
	
	//헤더 클릭 이벤트 제거
	// -헤더
	removeEventHandler(this.SheetHeaderObject.querySelector("div.SheetHeaderDiv > table"), "mouseup", sheetHeaderTableMouseUp);
	// -좌측고정 헤더
	if( this.SheetHeaderLeftFixObject != null && typeof this.SheetHeaderLeftFixObject != "undefined" ){
		removeEventHandler(this.SheetHeaderLeftFixObject.querySelector("table"), "mouseup", sheetHeaderTableMouseUp);
	}
	// -우측고정 헤더
	if( this.SheetHeaderRightFixObject != null && typeof this.SheetHeaderRightFixObject != "undefined" ){
		removeEventHandler(this.SheetHeaderRightFixObject.querySelector("table"), "mouseup", sheetHeaderTableMouseUp);
	}
	
	//시트 편집 이벤트 제거
	var sheetContentTable = null;
	var sheetEditObject = null;
	// -본문
	sheetContentTable = this.SheetContentObject.querySelector("div.SheetContentDiv > table");
	removeEventHandler(sheetContentTable, "click", sheetContentTableClick);
	removeEventHandler(sheetContentTable, "dblclick", sheetContentTableDoubleClick);
	removeEventHandler(sheetContentTable, "mouseover", sheetContentTableMouseOver);
	removeEventHandler(sheetContentTable, "mouseout", sheetContentTableMouseOut);
	sheetContentTable = null;
	// -좌측고정열
	if( typeof this.SheetHeaderLeftFixObject != "undefined" && this.SheetHeaderLeftFixObject != null ){
		sheetContentTable = this.SheetContentLeftFixObject.querySelector("table");
		removeEventHandler(sheetContentTable, "click", sheetContentTableClick);
		removeEventHandler(sheetContentTable, "dblclick", sheetContentTableDoubleClick);
		removeEventHandler(sheetContentTable, "mouseover", sheetContentTableMouseOver);
		removeEventHandler(sheetContentTable, "mouseout", sheetContentTableMouseOut);
		sheetContentTable = null;
	}
	// -우측고정열
	if( typeof this.SheetHeaderRightFixObject != "undefined" && this.SheetHeaderRightFixObject != null ){
		sheetContentTable = this.SheetContentRightFixObject.querySelector("table");
		removeEventHandler(sheetContentTable, "click", sheetContentTableClick);
		removeEventHandler(sheetContentTable, "dblclick", sheetContentTableDoubleClick);
		removeEventHandler(sheetContentTable, "mouseover", sheetContentTableMouseOver);
		removeEventHandler(sheetContentTable, "mouseout", sheetContentTableMouseOut);
		sheetContentTable = null;
	}
	// -편집 텍스트박스 이벤트
	sheetEditObject = this.SheetEidtTextDivObject.querySelector("input.SheetEidtTextbox");
	removeEventHandler(sheetEditObject, "blur", sheetEidtTextboxBlur);
	removeEventHandler(sheetEditObject, "mouseup", sheetEidtTextboxMouseUp);
	removeEventHandler(sheetEditObject, "keydown", sheetEidtTextboxKeydown);
	sheetEditObject = null;
	// -편집 체크박스 이벤트
	removeEventHandler(this.SheetEidtCheckDivObject, "blur", sheetEidtCheckboxBlur);
	removeEventHandler(this.SheetEidtCheckDivObject, "mouseup", sheetEidtCheckboxMouseUp);
	removeEventHandler(this.SheetEidtCheckDivObject, "click", sheetEidtCheckboxClick);
	removeEventHandler(this.SheetEidtCheckDivObject, "keydown", sheetEidtCheckboxKeydown);
	// -편집 콤보박스 이벤트
	sheetEditObject = this.SheetEidtComboDivObject.querySelector("select.SheetEidtCombobox");
	removeEventHandler(sheetEditObject, "blur", sheetEidtComboboxBlur);
	removeEventHandler(sheetEditObject, "change", sheetEditComboboxChange);
	removeEventHandler(sheetEditObject, "mouseup", sheetEidtComboboxMouseUp);
	removeEventHandler(sheetEditObject, "keydown", sheetEidtComboboxKeydown);
	sheetEditObject = null;
	// -편집 일자(날짜) 텍스트박스 이벤트
	removeEventHandler(this.SheetEidtDateDivOBject, "mouseup", sheetEidtDateMouseUp);
	sheetEditObject = document.getElementsByName(this.controlId + "_SheetEidtDateInput")[0];
	removeEventHandler(sheetEditObject, "blur", sheetEidtDateInputBlur);
	removeEventHandler(sheetEditObject, "keydown", sheetEidtDateInputKeydown);
	sheetEditObject = null;
	sheetEditObject = document.getElementsByName(this.controlId + "_SheetEidtDateCalender")[0];
	removeEventHandler(sheetEditObject, "mouseover", sheetEidtDateCalenderMouseOver);
	removeEventHandler(sheetEditObject, "mouseout", sheetEidtDateCalenderMouseOut);
	removeEventHandler(sheetEditObject, "click", sheetEidtDateCalenderClick);
	sheetEditObject = null;
	
	//시트 동작가능 패널 이벤트 제거
	var sheetDisabledPanelObj = this.SheetObject.querySelector("div.SheetDisabledPanel");
	if( sheetDisabledPanelObj != null && typeof sheetDisabledPanelObj != "undefined" ){
		removeEventHandler(sheetDisabledPanelObj, "mousedown", sheetSheetDisabledPanelEvent);
		removeEventHandler(sheetDisabledPanelObj, "mouseup", sheetSheetDisabledPanelEvent);
		removeEventHandler(sheetDisabledPanelObj, "click", sheetSheetDisabledPanelEvent);
		removeEventHandler(sheetDisabledPanelObj, "keydown", sheetSheetDisabledPanelEvent);
		removeEventHandler(sheetDisabledPanelObj, "keyup", sheetSheetDisabledPanelEvent);
	}
	sheetDisabledPanelObj = null;
	
	//시트 컬럼 너비 리사이즈 이벤트 제거
	// -컬럼 리사이저 마우스 다운(컬럼 너비 조정 시작) 이벤트
	var resizerObjects = this.SheetObject.querySelectorAll("div.resizer");
	var resizerObject = null;
	var resizerCount = resizerObjects.length;
	for(var i = 0; i < resizerCount; i++){
		resizerObject = resizerObjects[i];
		removeEventHandler(resizerObject, "mousedown", sheetResizerMousedown);
		resizerObject = null;
	}
	resizerObjects = null;
	// -컬럼 리사이저 마우스 업(컬럼 너비 조정 완료) 이벤트
	removeEventHandler(this.SheetObject, "mouseup", sheetResizerMouseup);
	removeEventHandler(this.SheetHeaderObject, "mouseup", sheetResizerMouseup);
	removeEventHandler(this.SheetContentObject, "mouseup", sheetResizerMouseup);
	// -컬럼 리사이저 이동 이벤트
	removeEventHandler(this.SheetObject, "mousemove", sheetResizerMousemove);
	removeEventHandler(this.SheetHeaderObject, "mousemove", sheetResizerMousemove);
	removeEventHandler(this.SheetContentObject, "mousemove", sheetResizerMousemove);
	
	/*
	 *	2. 속성 초기화
	 */
	this.controlId = null;
	this.controlName = null;
	this.sheet = null;
	
	this.columnWidths.clear();	this.columnWidths = null;
	this._columnWidths.clear();	this._columnWidths = null;
	
	this.columnInfo.clear();	this.columnInfo = null;
	this.columnIndexMapByField = null;
	
	this.headerInfo.clear();	this.headerInfo = null;
	this.footerInfo.clear();	this.footerInfo = null;
	this.data.clear();			this.data = null;
	this.dataSet = null;
	
	this.editingCellObject = null;
	this.selectedObject = null;
	this.mouseOverObject = null;
	this.rowStyleClass = null;
	this.cellStyleClass = null;
	
	this.hScrollHeight = null;
	this.vScrollWidth = null;
	
	this.SheetObject = null;
	this.SheetHeaderObject = null;
	this.SheetContentObject = null;
	this.SheetFooterObject = null;
	this.SheetVScrollObject = null;
	this.SheetHScrollObject = null;
	this.SheetHeaderLeftFixObject = null;
	this.SheetContentLeftFixObject = null;
	this.SheetFooterLeftFixObject = null;
	this.SheetHeaderRightFixObject = null;
	this.SheetContentRightFixObject = null;
	this.SheetFooterRightFixObject = null;
	this.SheetMsgBox = null;
	this.SheetZoomImgeBox = null;
	this.SheetControlTempDivObject = null;
	this.SheetEidtTextDivObject = null;
	this.SheetEidtCheckDivObject = null;
	this.SheetEidtComboDivObject = null;
	this.SheetEidtDateDivOBject = null;
	this.SheetEditCalenderObject = null;
	this.parentControlName = null;
};

EasySheetRenderer.prototype.transformColumnInfo = function(column, columnIndex){
	//예외처리
	if( typeof column == "undefined" || column == null ){
		return null;
	}
	
	var colInfo = {};
	var row = -1;
	var col = -1;
	
	if( typeof column.colId != "undefined" ) colInfo.field = column.colId;
	if( typeof column.colDataType != "undefined" ) colInfo.fieldType = column.colDataType;
	
	if( typeof column.sheetRow != "undefined" ) row = (colInfo.row = column.sheetRow) - 1;
//	if( typeof column.sheetCol != "undefined" ) col = (colInfo.col = column.sheetCol) - 1;
	if( typeof column.sheetCol != "undefined" ) col = (colInfo.col = columnIndex);
	if( typeof column.sheetRowSpan != "undefined" ) colInfo.rowspan = column.sheetRowSpan;
	if( typeof column.sheetColSpan != "undefined" ) colInfo.colspan = column.sheetColSpan;

	if( typeof column.caption != "undefined" && ("" + column.caption).length > 0 ){
		colInfo.title = column.caption;
	}
	else{
		//
		if( row < 0 && col < 0 && typeof this.columnInfo[columnIndex] != "undefined" ){
			row = this.columnInfo[columnIndex].row - 1;
//			col = this.columnInfo[columnIndex].col - 1;
			col = columnIndex;
		}
		
		//
		var headRowIndex = 0;
		var headRowItem = null;
		var headColItem = null;
		var headerRowCount = this.headerInfo.length;
		var colsPerRow = this.colsPerRow;
		var i = 0; var j = 0;
		
		headRowIndex = headerRowCount - this.rowsPerDataRow + row;
		
		for(i = headRowIndex; i < headerRowCount; i++, headRowItem = null){
			headRowItem = this.headerInfo[i];
			
			for(j = 0; j < colsPerRow; j++, headColItem = null){
				headColItem = headRowItem[j];
				
				if( headColItem.colspanMax > 0 && headColItem.cellIndex == col ){
					colInfo.title = column.caption = headColItem.title;
					break;
				}
			}
			
			if( headColItem != null ) break;
		}
		
		headColItem = null; headRowItem = null;
	}
	if( typeof column.captionTooltip != "undefined" ) colInfo.tooltip = column.captionTooltip;
	if( typeof column.tooltip != "undefined" ) colInfo.showColumnTooltip = column.tooltip;

	if( typeof column.align != "undefined" ){
		switch( column.align ){			/* colInfo.align = column.align; */
			case SHEET_ALIGN_LEFT:		colInfo.align = "left";		break;
			case SHEET_ALIGN_RIGHT:		colInfo.align = "right";	break;
			case SHEET_ALIGN_CENTER:	colInfo.align = "center";	break;
			default:					colInfo.align = "left";
		}
	}
	if( typeof column.vAlign != "undefined" ){
		switch( column.vAlign ){		/* colInfo.valign = column.vAlign; */
			case SHEET_VALIGN_MIDDLE:	colInfo.valign = "middle";		break;
			case SHEET_VALIGN_BASELINE:	colInfo.valign = "baseline";	break;
			case SHEET_VALIGN_BOTTOM:	colInfo.valign = "bottom";		break;
			case SHEET_VALIGN_TOP:		colInfo.valign = "top";			break;
			default:					colInfo.valign = "middle";
		}
	}
	if( typeof column.backColor != "undefined" ) colInfo.backgroundColor = column.backColor;
	if( typeof column.foreColor != "undefined" ) colInfo.fontColor = column.foreColor;

	if( typeof column.maxLength != "undefined" ) colInfo.maxLength = column.maxLength;
	
	if( typeof column.lockMode != "undefined" ){
		if( typeof column.lockMode == "boolean" ) colInfo.enable = !column.lockMode;
		else if( typeof column.lockMode == "function" ) colInfo.enable = function(rowNum, colNum, rowData){ return !column.lockMode(rowNum, colNum, rowData) };
	}
	
	if( typeof column.hidden != "undefined" ) colInfo.hidden = column.hidden;

	if( typeof column.displayFormat != "undefined" ) colInfo.displayFormat = column.displayFormat;
	if( typeof column.defaultValue != "undefined" ) colInfo.defaultValue = column.defaultValue;
	if( typeof column.prefix != "undefined" ) colInfo.prefix = column.prefix;
	if( typeof column.suffix != "undefined" ) colInfo.suffix = column.suffix;
	
	//컬럼 클래스
	if( typeof column.columnClass != "undefined" ) colInfo.columnStyleClass = column.columnClass;
	if( typeof column.columnTitleClass != "undefined" ) colInfo.columnTitleClass = column.columnTitleClass;

	if( typeof column.width != "undefined" ) colInfo.width = column.width;
	if( typeof column.minWidth != "undefined" ) colInfo.minWidth = column.minWidth;

	if( typeof column.cellType != "undefined" ){
		switch( column.cellType ){
			case CELLTYPE_DATE:		colInfo.cellType = "date";		break;
			case CELLTYPE_EDIT:		colInfo.cellType = "text";		break;
			case CELLTYPE_INTEGER:	colInfo.cellType = "integer";	break;
			case CELLTYPE_TIME:		colInfo.cellType = "date";		break;
			case CELLTYPE_BUTTON:	colInfo.cellType = "button";	break;
			case CELLTYPE_COMBOBOX:	colInfo.cellType = "combobox";	break;
			case CELLTYPE_PICTURE:	colInfo.cellType = "image";		break;
			case CELLTYPE_CHECKBOX:	colInfo.cellType = "checkbox";	break;
			case CELLTYPE_NUMBER:	colInfo.cellType = "number";	break;
			case CELLTYPE_PERCENT:	colInfo.cellType = "percent";	break;
			case CELLTYPE_LINK:		colInfo.cellType = "link";		break;
//			case CELLTYPE_MASK:		colInfo.cellType = ""; break;	//미구현
//			case CELLTYPE_ICON:		colInfo.cellType = ""; break;	//미구현
//			case CELLTYPE_BAR:		colInfo.cellType = ""; break;	//미구현
//			case CELLTYPE_SIGNAL:	colInfo.cellType = ""; break;	//미구현
//			case CELLTYPE_PASSWORD:	colInfo.cellType = ""; break;	//미구현
			default: 				colInfo.cellType = "text";
		}
	}

	if( typeof column.checkShapeType != "undefined" ) colInfo.checkType = column.checkShapeType;
	if( typeof column.valueWhenChecked != "undefined" ) colInfo.checkedValue = column.valueWhenChecked;
	if( typeof column.valueWhenUnchecked != "undefined" ) colInfo.uncheckedValue = column.valueWhenUnchecked;
	
	if( typeof column.fillFunction != "undefined" || typeof column.linkComboName != "undefined" || typeof column.fillList != "undefined" ){
		colInfo.dataList = (column.fillFunction != null) ? column.fillFunction : ((column.linkComboName != null) ? column.linkComboName : ((column.fillList != null) ? column.fillList : null));
	}

	if( typeof column.maxValue != "undefined" ) colInfo.maxValue = column.maxValue;
	if( typeof column.minValue != "undefined" ) colInfo.minValue = column.minValue;
	if( typeof column.negativeRed != "undefined" ) colInfo.negativeRed = column.negativeRed;
	if( typeof column.decimalPlaces != "undefined" ) colInfo.decimalPlace = column.decimalPlaces;
	
	if( typeof column.percentSet != "undefined" ) colInfo.percentRound = column.percentSet;
	if( typeof column.percentDecimalPoint != "undefined" ) colInfo.percentDecimalPlace = column.percentDecimalPoint;

	if( typeof column.buttonType != "undefined" ) colInfo.buttonType = column.buttonType;
	if( typeof column.buttonCaption != "undefined" ) colInfo.buttonCaption = column.buttonCaption;
	if( typeof column.buttonIcon != "undefined" ) colInfo.buttonIcon = column.buttonIcon;
	if( typeof column.buttonOverCaption != "undefined" ) colInfo.buttonOverCaption = column.buttonOverCaption;
	
	if( typeof column.linkCaption != "undefined" ) colInfo.linkCaption = column.linkCaption;
	if( typeof column.captionFunction != "undefined" ) colInfo.captionFunction = column.captionFunction;

	if( typeof column.imageAlt != "undefined" ) colInfo.alt = column.imageAlt;
	if( typeof column.imageZoom != "undefined" ) colInfo.zoomImage = column.imageZoom;

	if( typeof column.checkFormat != "undefined" ) colInfo.dateType = column.checkFormat;
	if( typeof column.dateFormat != "undefined" || typeof column.timeFormat != "undefined" ){
		colInfo.dateFormat = (column.cellType == CELLTYPE_DATE) ? column.dateFormat : ((column.cellType == CELLTYPE_TIME) ? column.timeFormat : "");
	}
	
	if( typeof column.cellMerge != "undefined" ) colInfo.cellMerge = column.cellMerge;
	
	return colInfo;
};

EasySheetRenderer.prototype.setColumnInfo = function(columnIndex, columnInfo, doRedraw){
	//파라메터 예외처리
	if( typeof columnIndex != "number" || !(columnIndex >= 0 && columnIndex < this.columnInfo.length) )
		return false;
	if( typeof columnInfo == "undefined" || columnInfo == null )
		return false;
	
	//컬럼 속성 설정
	var column = this.columnInfo[columnIndex];
	var columnInfoObj = null;;
	
	var colWidth = null;
	var newColPercent = null;
	var oldColPercent = null;
	var i = 0;
	
	//파라메터 컬럼정보 렌더러의 컬럼정보에 맞게 변환
	try{
		columnInfoObj = this.transformColumnInfo(columnInfo, columnIndex);
	}
	catch(e){
		columnInfoObj = null; column = null;
		return false;
	}
	
	//
	if( typeof columnInfoObj.row != "undefined" ) column.row = columnInfoObj.row;
	if( typeof columnInfoObj.col != "undefined" ) column.col = columnInfoObj.col;
	if( typeof columnInfoObj.rowspan != "undefined" ) column.rowspan = columnInfoObj.rowspan;
	if( typeof columnInfoObj.colspan != "undefined" ) column.colspan = columnInfoObj.colspan;
	
	//컬럼 필드ID 설정
	if( typeof columnInfoObj.field != "undefined" ) column.field = columnInfoObj.field;
	
	//컬럼 너비 설정
	if( typeof columnInfoObj.width != "undefined" ){
		colWidth = "" + columnInfoObj.width;
		//1. 반응형 컬럼 여부 설정 : 컬럼 너비가 % 로 끝나면 반응형 컬럼임
		column.isFixedWidth = !(colWidth.substring(colWidth.length - 1) == "%");
		//2. 반응형 처리시 최소너비 여부 설정하는 속성
		column.minWidth = "" + (typeof columnInfoObj.minWidth == "undefined" ? "0px" : columnInfoObj.minWidth);
//		column.isSameMinWidth = false;
		column.isSameMinWidth = (column.minWidth == colWidth);
		//3. 반응형 컬럼인 경우 컬럼 너비의 비율 설정
		oldColPercent = column.percentWidth;
		if( !column.isFixedWidth ){
			newColPercent = (1 * colWidth.substring(0, colWidth.length - 1));
			column.percentWidth = newColPercent;

			this._sumResponsibleColumnWidth = (this._sumResponsibleColumnWidth - oldColPercent) + newColPercent;
		}
		else{
			column.width = colWidth;
			
			this._cntResponsibleColumnWidth--;
			this._sumResponsibleColumnWidth = this._sumResponsibleColumnWidth - oldColPercent;
		}
	}
	
	//컬럼 숨김 설정
	if( typeof columnInfoObj.hidden != "undefined" ) column.hidden = (typeof columnInfoObj.hidden != "undefined" && columnInfoObj.hidden === true) ? true : false;
	//숨김 컬럼이 아닌 실제 보여지는 마지막 컬럼의 인덱스를 구함
	for(i = this.columnInfo.length - 1; i >= 0 ; i--){
		if( !this.columnInfo[i].hidden )
			this._lastVisibleColumnIndex = i;
	}
	
	//컬럼 잠김 설정
	if( typeof columnInfoObj.enable != "undefined" ){
		if( typeof columnInfoObj.enable == "boolean" ) column.enable = (columnInfoObj.enable === true) ? true : false;
		else if( typeof columnInfoObj.enable == "function" ) column.enable = columnInfoObj.enable;
	}
	
	//컬럼 타입
	if( typeof columnInfoObj.fieldType != "undefined" ) column.fieldType = columnInfoObj.fieldType;

	//수평정렬
	if( typeof columnInfoObj.align != "undefined" ) column.align = columnInfoObj.align;
	
	//수직정렬(기본 : middle)
	if( typeof columnInfoObj.valign != "undefined" ) column.valign = columnInfoObj.valign;

	//배경색(기본 : "" / 속성 값이 있는 경우에만 적용)
	if( typeof columnInfoObj.backgroundColor != "undefined" ) column.backgroundColor = columnInfoObj.backgroundColor;

	//글자색(기본 : "" / 속성 값이 있는 경우에만 적용)
	if( typeof columnInfoObj.fontColor != "undefined" ) column.fontColor = columnInfoObj.fontColor;

	//입력 가능한 최대길이(기본 : -1 / 속성 값이 0보다 큰 경우에만 적용)
	if( typeof columnInfoObj.maxLength != "undefined" ) column.maxLength = columnInfoObj.maxLength;

	//기본값(기본 : "")
	if( typeof columnInfoObj.defalutValue != "undefined" ) column.defalutValue = columnInfoObj.defalutValue;

	//표시형식
	if( typeof columnInfoObj.displayFormat != "undefined" ) column.displayFormat = columnInfoObj.displayFormat;

	//접두사
	if( typeof columnInfoObj.prefix != "undefined" ) column.prefix = columnInfoObj.prefix;

	//접미사
	if( typeof columnInfoObj.suffix != "undefined" ) column.suffix = columnInfoObj.suffix;
	
	//타이틀
	if( typeof columnInfoObj.title != "undefined" ){
		column.title = columnInfoObj.title;
		
		//
		var row = column.row - 1;
		var col = columnIndex;
		var headRowCount = this.headerInfo.length
		var headColCount = this.colsPerRow; 
		var headRowIndex = headRowCount - this.rowsPerDataRow + row
		var headRowItem = this.headerInfo[headRowIndex];
		var headColItem = null;
		var i = 0; var j = 0;
		
		for(i = headRowIndex; i < headRowCount; i++, headRowItem = null){
			headRowItem = this.headerInfo[i];
			
			for(j = 0; j < headColCount; j++, headColItem = null){
				headColItem = headRowItem[j];
				
				if( headColItem.colspanMax > 0 && headColItem.cellIndex == col ){
					headColItem.title = column.title;
					break;
				}
			}
			
			if( headColItem != null ){
				headColItem = null;
				headRowItem = null;
				break;
			}
		}
	}
	
	//타이틀툴팁(기본 : "")
	if( typeof columnInfoObj.tooltip != "undefined" ) column.tooltip = columnInfoObj.tooltip;
	
	//컬럼 툴팁-데이터 출력,데이터 길이가 컬럼 너비를 초과하여 ...으로 표시되는 데이터 전체를 보기 위해 사용(기본 : false)
	if( typeof columnInfoObj.showColumnTooltip != "undefined" ) column.showColumnTooltip = columnInfoObj.showColumnTooltip;
	
	//병합
	if( typeof columnInfoObj.cellMerge != "undefined" ) column.cellMerge = columnInfoObj.cellMerge;
	
	//컬럼 클래스
	if( typeof columnInfoObj.columnStyleClass != "undefined" ) column.columnStyleClass = columnInfoObj.columnStyleClass;
	
	//컬럼 타이틀 클래스
	if( typeof columnInfoObj.columnTitleClass != "undefined" ) column.columnTitleClass = columnInfoObj.columnTitleClass;

	//셀 타입(기본: text)
	if( typeof columnInfoObj.cellType != "undefined" ) column.cellType = columnInfoObj.cellType;
	
	//컬럼 읽기전용 설정
	column.readOnly = (typeof columnInfoObj.readOnly == "undefined" || columnInfoObj.readOnly === false) ? false : true;
	
	//체크박스 셀타입 추가 설정
	if( columnInfoObj.cellType == "checkbox" ){
		//체크박스-체크타입 설정(기본: default / 원형체크: circle-fill-check / 원형: circle-fill / 사각형: square-fill)
		if( typeof columnInfoObj.checkType != "undefined" ){
			//체크박스 체크타입 설정에 따른 출력용 데이터 설정
			if( columnInfoObj.checkType == "circle-fill-check" ){
				column.checkedIcon = "&#xe9d4;"; column.uncheckedIcon = "&#xe9d5;";
//				column.checkedIcon = "icon-ok-circled-1"; column.uncheckedIcon = "icon-ok-circled2-1";
			}
			else if( columnInfoObj.checkType == "circle-fill" ){
				column.checkedIcon = "&#xf111;"; column.uncheckedIcon = "&#xf10c;";
//				column.checkedIcon = "icon-circle"; column.uncheckedIcon = "icon-circle-empty";
			}
			else if( columnInfoObj.checkType == "square-fill" ){
				column.checkedIcon = "&#xecf3;"; column.uncheckedIcon = "&#xecf2;";
//				column.checkedIcon = "icon-stop-5"; column.uncheckedIcon = "icon-stop-outline";
			}
			else{
				column.checkedIcon = "&#xe8f8;"; column.uncheckedIcon = "&#xe8f9;";
//				column.checkedIcon = "icon-check-1"; column.uncheckedIcon = "icon-check-empty-1";
			}
		}
		
		//체크박스-체크하였을 때의 값 설정
		if( typeof columnInfoObj.checkedValue != "undefined" ) column.checkedValue = columnInfoObj.checkedValue;
		
		//체크박스-체크하지 않았을 때의 값 설정
		if( typeof columnInfoObj.uncheckedValue != "undefined" ) column.uncheckedValue = columnInfoObj.uncheckedValue;
	}
	
	//콤보박스 셀타입 추가 설정
	if( columnInfoObj.cellType == "combobox" ){
//		column.fillDataValue = null;
//		column.fillDataLists = null;
		//콤보박스-콤보박스 데이터 리스트
		if( typeof columnInfoObj.dataList != "undefined") column.dataList = columnInfoObj.dataList
	}
	
	//버튼 셀타입 추가 설정
	if( columnInfoObj.cellType == "button" ){
		//컬럼 읽기전용 설정
		column.readOnly = true;
		//버튼 타입 설정
		if( typeof columnInfoObj.buttonType != "undefined" ) column.buttonType = columnInfoObj.buttonType;
		//버튼 캡션 설정
		if( typeof columnInfoObj.buttonCaption != "undefined" ) column.buttonCaption = columnInfoObj.buttonCaption;
		//버튼 캡션 설정
		if( typeof columnInfoObj.buttonIcon != "undefined" ) column.buttonIcon = columnInfoObj.buttonIcon;
		//버튼 마우스 오버시 캡션 설정
		if( typeof columnInfoObj.buttonOverCaption != "undefined" ) column.buttonOverCaption = columnInfoObj.buttonOverCaption;
	}
	
	//링크 셀타입 추가 설정
	if( columnInfoObj.cellType == "link" ){
		//컬럼 읽기전용 설정
		column.readOnly = true;
		//기본값 설정
		column.defalutValue = "about:blank";
		//버튼 타이틀 설정
		if( typeof columnInfoObj.linkCaption != "undefined" ) column.linkCaption = columnInfoObj.linkCaption;
	}

	//이미지 셀타입 추가 설정
	if( columnInfoObj.cellType == "image" ){
		//컬럼 읽기전용 설정
		column.readOnly = true;
		//확대 이미지 보이기 설정
		if( typeof columnInfoObj.zoomImage != "undefined" ) column.zoomImage = columnInfoObj.zoomImage;
		//alt 설정
		if( typeof columnInfoObj.alt != "undefined" ) column.alt = columnInfoObj.alt;
	}

	//날짜(일자) 셀타입 추가 설정
	if( columnInfoObj.cellType == "date" ){
		//날짜 타입 설정(년월일: 0 / 년월: 1 / 년도: 2 / 년월일시분초: 3 / 년월일시분: 4 / 년월일시: 5 / 시분초: 6 / 시분: 7 / 시간: 8)
		if( typeof columnInfoObj.dateType != "undefined" ) column.dateType = columnInfoObj.dateType;
		//날짜 표시형식 설정
		if( typeof columnInfoObj.dateFormat != "undefined" ) column.dateFormat = columnInfoObj.dateFormat;
	}
	
	//정수/실수 셀타입 추가설정
	if( columnInfoObj.cellType == "integer" || columnInfoObj.cellType == "number" ){
		//최대값 설정(기본 : "" / 속성값이 비어있는 경우 최대값 설정을 하지 않음)
		if( typeof columnInfoObj.maxValue != "undefined" ) column.maxValue = columnInfoObj.maxValue;
		//최소값 설정(기본 : "" / 속성값이 비어있는 경우 최소값 설정을 하지 않음)
		if( typeof columnInfoObj.minValue != "undefined" ) column.minValue = columnInfoObj.minValue;
		//음수 표시(기본 : false)
		if( typeof columnInfoObj.negativeRed != "undefined" ) column.negativeRed = columnInfoObj.negativeRed;
		//소수점 자리수(표시형식과 별개)
		if( typeof columnInfoObj.decimalPlace != "undefined" ) column.decimalPlace = columnInfoObj.decimalPlace;
	}

	//퍼센트 셀타입 추가설정
	if( columnInfoObj.cellType == "percent" ){
		//소수점 초과 자리수 반올림 설정(기본: none / 설정안함: none | 올림: ceil | 내림: floor | 반올림: round)
		if( typeof columnInfoObj.percentRound != "undefined" ) column.percentRound = columnInfoObj.percentRound;
		//소수점 자리수(표시형식과 별개)
		if( typeof columnInfoObj.percentDecimalPlace != "undefined" ) column.percentDecimalPlace = columnInfoObj.percentDecimalPlace;
	}
	
	//시트를 변경된 설정에 따라 다시 그림
	if( typeof doRedraw == "boolean" && doRedraw === true ){
		this.redraw();
	}
	
	//메모리 해제
	newColPercent = null;
	oldColPercent = null;
	colWidth = null;
	column = null;
	
	return true;
};

EasySheetRenderer.prototype.resetColumnInfo = function(columnInfoList){
	var columnInfoObj = null;
	var cntPercentColumn = 0;
	var sumPercentColumn = 0;
	var i = 0;
	
	//새로운 컬럼정보를 파라메터로 받았다면 기존 컬럼정보를 삭제하고 새로운 컬럼정보를 설정
	if( typeof columnInfoList != "undefined" && columnInfoList instanceof Array ){
		//기존 컬럼정보를 삭제
		for(i = this.columnInfo.length - 1; i >= 0; i--){
			columnInfoObj = this.columnInfo.pop();
			columnInfoObj = null;
		}
		
		//새 컬럼정보를 설정
		for(i = 0; i < columnInfoList.length; i++){
			this.columnInfo[i] = {
				index : i
				, width : "81px"
				, minWidth: "81px"
				, hidden : false
				, enable : true
				, fieldType : "string"
				, align : "left"
				, valign : "middle"
				, backgroundColor : ""
				, fontColor : ""
				, maxLength : -1
				, defalutValue : ""
				, displayFormat : ""
				, prefix : ""
				, suffix : ""
				, title : ""
				, tooltip : ""
				, showColumnTooltip : false
				, columnStyleClass : null
				, columnTitleClass : null
				, cellType : "text"
				, readOnly : false
				, row : 1
				, col : 1
				, rowspan : 1
				, colspan : 1
			};
			
			this.setColumnInfo(i, columnInfoList[i]);
		}
	}
	
	// 시트 추가 정리
	for(i = 0; i < this.columnInfo.length; i++){
		// 반응형 컬럼인 경우 컬럼 너비의 비율 설정
		if( !this.columnInfo[i].isFixedWidth ){
			//반응형 컬럼의 개수 구함
			cntPercentColumn++;
			//반응형 컬럼의 너비 총합을 구함
			sumPercentColumn += this.columnInfo[i].percentWidth;
		}
		
		// 컬럼 필드 기준으로 매칭되는 인덱스 매핑 정보 설정
		this.columnIndexMapByField["" + this.columnInfo[i].field] = i;
		
		// 숨김 컬럼이 아닌 실제 보여지는 마지막 컬럼의 인덱스를 구함
		if( !this.columnInfo[i].hidden )
			this._lastVisibleColumnIndex = i;
	}
	
	//시트의 반응형 컬럼의 개수와 총합
	this._cntResponsibleColumnWidth = cntPercentColumn; //cntPercentColumn == this.columnInfo.length;
	this._sumResponsibleColumnWidth = sumPercentColumn; //sumPercentColumn == 100;
};

EasySheetRenderer.prototype.getColumnIndexByField = function(field){
	if( !(("" + field) in this.columnIndexMapByField) )
		return null;
	
	return this.columnIndexMapByField["" + field];
};

EasySheetRenderer.prototype.getDisplayValueByCellType = function(colNum, value, text){
	//예외처리
	if( typeof colNum != "number" || !(colNum >= 0 && colNum < this.columnInfo.length) )
		return false;
	
	var cellType = null;
	var fieldType = null;
	var checkType = null;
	var prefixStr = null;
	var suffixStr = null;
	
	//셀타입 설정
	cellType = this.columnInfo[colNum].cellType;
	fieldType = this.columnInfo[colNum].fieldType;
	prefixStr = this.columnInfo[colNum].prefix;
	suffixStr = this.columnInfo[colNum].suffix;
	
	//셀타입별 필드타입에 맞는 값 구함
	if( cellType == "checkbox" ){
		//체크박스 체크 값 설정 : 필드타입과 체크값 모두 같아야 체크함
		//value = (typeof value == fieldType && value == this.columnInfo[colNum].checkedValue) ? this.columnInfo[colNum].checkedIcon : this.columnInfo[colNum].uncheckedIcon;
		value = (value == this.columnInfo[colNum].checkedValue) ? this.columnInfo[colNum].checkedIcon : this.columnInfo[colNum].uncheckedIcon;
	}
	else if( cellType == "combobox" ){
		if( typeof text != "undefined" && text != null ){
			value = text;
		}
		else{
			var dataList = null;
			var comboData = null;
			var isFound = false;
			//콤보 목록 설정
			dataList = this.columnInfo[colNum].dataList;
			if( typeof dataList == "object" && dataList instanceof Array ){
				comboData = dataList;
//				dataList.clear();
			}
			else if( typeof dataList == "function" ){
				comboData = dataList();
			}
			else if( typeof dataList == "string" ){
				if( typeof controls[dataList].getListArray != "undefined" ){
					comboData = controls[dataList].getListArray();
				}
				else if( typeof controls[dataList].getItemList != "undefined" ){
					comboData = controls[dataList].getItemList();
				}
			}
			//value 에 해당하는 텍스트 데이터 찾기
			for(i = 0; comboData != null && i < comboData.length; i++){
				if( value == comboData[i].value ){
					value = comboData[i].text;
					isFound = true;
					break;
				}
			}
			//텍스트 데이터를 찾지 못한 경우
			if( !isFound ) value = "";
			//메모리 해제
			isFound = null;
			comboData = null; dataList = null;
		}
	}
	else if( cellType == "date" ){
		//날짜 표시형식이 있다면 표시형식에 맞게 변환
		if( typeof this.columnInfo[colNum].dateFormat == "string" && this.columnInfo[colNum].dateFormat.length > 0 ){
			value = EasySheetUtil.format(this.columnInfo[colNum].dateFormat, value);
		}
	}
//	else if( cellType == "integer" || cellType == "number" ){
//		//소수점 자리수
//		if( this.columnInfo[colNum].decimalPlace != null && typeof this.columnInfo[colNum].decimalPlace == "number" && this.columnInfo[colNum].decimalPlace >= 0 ){
//			value = Math.floor(value * Math.pow(10, this.columnInfo[colNum].decimalPlace)) / Math.pow(10, this.columnInfo[colNum].decimalPlace);
//		}
//	}
	else if( cellType == "percent" ){
		//소수점 자리수 및 올림 설정
		if( this.columnInfo[colNum].percentDecimalPlace != null && typeof this.columnInfo[colNum].percentDecimalPlace == "number" && this.columnInfo[colNum].percentDecimalPlace >= 0 ){
			if( this.columnInfo[colNum].percentRound == SHEET_PERCENT_CEIL ){
				value = Math.ceil(value * Math.pow(10, this.columnInfo[colNum].percentDecimalPlace) * 100) / Math.pow(10, this.columnInfo[colNum].percentDecimalPlace);
			}
			else if( this.columnInfo[colNum].percentRound == SHEET_PERCENT_ROUND ){
				value = Math.round(value * Math.pow(10, this.columnInfo[colNum].percentDecimalPlace) * 100) / Math.pow(10, this.columnInfo[colNum].percentDecimalPlace);
			}
			else if( this.columnInfo[colNum].percentRound == SHEET_PERCENT_FLOOR ){
				value = Math.floor(value * Math.pow(10, this.columnInfo[colNum].percentDecimalPlace) * 100) / Math.pow(10, this.columnInfo[colNum].percentDecimalPlace);
			}
			else {
				//퍼센트 타입의 경우 100을 곱하여 퍼센트로 표기
				value = value * 100;
				
				if( ("" + value).indexOf(".") > 0 ){
					value = 1 * (("" + value).substring(0, ("" + value).indexOf(".") + 1 + this.columnInfo[colNum].percentDecimalPlace));
				}
			}
		}
		
		//% 를 접미사에 추가
		suffixStr = "%" + suffixStr;
	}
	else if( cellType == "text" ){
		value = (typeof value == "string") ? value.replace(/</g, "&lt;").replace(/>/g, "&gt;") : value;
	}
	
	//표시형식 처리
	if( this.columnInfo[colNum].displayFormat.length > 0 ){
		value = EasySheetUtil.format(this.columnInfo[colNum].displayFormat, value);
	}
	
	//접두사, 접미사 처리
	value = prefixStr + value + suffixStr;
	
	//메모리 해제
	suffixStr = null; prefixStr = null;
	checkType = null; fieldType = null; cellType = null;
	
	return value;
};

EasySheetRenderer.prototype.resetFooterInfo = function(footerInfoList){
	var footerInfoObj = null;
	var footerInfoSize = 0;
	var i = 0;
	
	//새로운 컬럼정보를 파라메터로 받았다면 기존 컬럼정보를 삭제하고 새로운 컬럼정보를 설정
	if( typeof footerInfoList != "undefined" && footerInfoList instanceof Array ){
		//기존 컬럼정보를 삭제
		for(i = this.footerInfo.length - 1; i >= 0; i--){
			footerInfoObj = this.footerInfo.pop();
			footerInfoObj = null;
		}
		
		//새 컬럼정보를 설정
		for(i = 0, footerInfoSize = footerInfoList.length; i < footerInfoSize; i++){
			//기존 컬럼 정보를 삭제하였으므로 새로운 푸터 정보 객체를 설정
			this.footerInfo[i] = {};
			
			//푸터 정보 설정
			this.setFooterInfo(i, footerInfoList[i]);
		}
	}
};

EasySheetRenderer.prototype.setFooterInfo = function(footerIndex, footerObj, doRedraw){
	if( typeof footerIndex != "number" || !(footerIndex >= 0 && footerIndex < this.footerInfo.length) )
		return false;
	if( typeof footerObj == "undefined" || footerObj == null )
		return false;
	
	//컬럼 속성 설정
	var footerInfo = this.footerInfo[footerIndex];
	
	if( typeof footerObj.field != "undefined" )
		footerInfo.field = footerObj.colId;
	
	if( typeof footerObj.colDataType != "undefined" )
		footerInfo.fieldType = footerObj.colDataType;
	
	if( typeof footerObj.sheetRow != "undefined" )
		footerInfo.row = footerObj.sheetRow;
	
	if( typeof footerObj.sheetCol != "undefined" )
		footerInfo.col = footerObj.sheetCol;
	
	if( typeof footerObj.sheetRowSpan != "undefined" )
		footerInfo.rowspan = footerObj.sheetRowSpan;
	
	if( typeof footerObj.sheetColSpan != "undefined" )
		footerInfo.colspan = footerObj.sheetColSpan;
	
	if( typeof footerObj.align != "undefined" ){
		switch( footerObj.align ){
			case SHEET_ALIGN_LEFT:		footerInfo.align = "left";		break;
			case SHEET_ALIGN_RIGHT:		footerInfo.align = "right";		break;
			case SHEET_ALIGN_CENTER:	footerInfo.align = "center";	break;
			default:					footerInfo.align = "left";
		}
	}
	if( typeof footerObj.vAlign != "undefined" ){
		switch( footerObj.vAlign ){
			case SHEET_VALIGN_MIDDLE:	footerInfo.valign = "middle";	break;
			case SHEET_VALIGN_BASELINE:	footerInfo.valign = "baseline";	break;
			case SHEET_VALIGN_BOTTOM:	footerInfo.valign = "bottom";	break;
			case SHEET_VALIGN_TOP:		footerInfo.valign = "top";		break;
			default:					footerInfo.valign = "middle";
		}
	}
	if( typeof footerObj.backColor != "undefined" )
		footerInfo.backgroundColor = footerObj.backColor;
	
	if( typeof footerObj.foreColor != "undefined" )
		footerInfo.fontColor = footerObj.foreColor;
	
	if( typeof footerObj.showFooter != "undefined" )
		footerInfo.hidden = !footerObj.showFooter;
	
	if( typeof footerObj.columnStyleClass != "undefined" )
		footerInfo.columnStyleClass = footerObj.columnStyleClass;
	
	if( typeof footerObj.value != "undefined" )
		footerInfo.value = footerObj.value;
	
	//시트를 변경된 설정에 따라 다시 그림
	if( typeof doRedraw == "boolean" && doRedraw === true ){
		this.redraw();
	}
	
	//메모리 해제
	footerInfo = null;
	
	return true;
};

EasySheetRenderer.prototype.setData = function( dataList ){
//	//data 파라메터가 없거나 베열이 아닌 경우 데이터를 채울 수 없음(시트를 비우려면 빈 배열을 data 파라메터로 전달해야함)
//	if( dataList != null && typeof dataList != "undefined" ){
//		if( !(dataList instanceof Array) ){
//			dataList = null; args = null;
//			return false;
//		}
//		
//		//메모리 해제 : 이전 데이터를 지움
//		this.data.clear();
//		this.data = null;
//		//새로 받은 데이터를 저장
//		this.data = dataList;
//		//dataRowCount 파라메터는 받은 데이터의 행 수가 아닌 시트 전체 데이터의 행 수를 전달받음(행 수가 없는 경우는 data 파라메터의 행 수로 처리)
//		this.dataRowCount = dataList.length;
//	}
//	
//	//데이터를 채운 후 resize 함수 호출 여부
//	doClear = (typeof doClear == "undefined" || doClear === true ) ? true : false;
//	//최상단 행의 인덱스
//	if( doClear ) this.showedTopRowIndex = 0;
//	this.showedTopRowIndex = (this.dataRowCount <= 0) ? 0 : (this.showedTopRowIndex > 0 ? this.showedTopRowIndex : 0);
	
	//data 파라메터가 없거나 베열이 아닌 경우 데이터를 채울 수 없음(시트를 비우려면 빈 배열을 data 파라메터로 전달해야함)
	if( typeof dataList == "undefined" || !(dataList instanceof Array) ){
		return false;
	}
	
	//메모리 해제 : 이전 데이터를 지움
	this.data.clear();
	this.data = null;
	//새로 받은 데이터를 저장
	this.data = dataList;
	
	var sheetContentRows = null;			//시트 본문의 행 객체배열(tr)
	var sheetContentLeftFixRows = null;		//시트 좌측고정 행 객체배열(tr)
	var sheetContentRightFixRows = null;	//시트 우측고정 행 객체배열(tr)
	var sheetContentRowCells = null;		//시트 본문 행의 열 객체배열(td)
	var sheetContentLeftFixRowCells = null;	//시트 좌측고정 행의 열 객체배열(td)
	var sheetContentRightFixRowCells = null;//시트 우측고정 행의 열 객체배열(td)
	var rowData = null;						//시트 행 데이터
	var mouseOverObejct = null;
	var rowObject = null;
	//좌/우측 고정여부
	var hasLeftFixColumn = null;
	var hasRightFixColumn = null;
	var rightFixGap = null;
	//행 번호
	var displayOddEven = this.displayOddEven;
	var startRowColNum = this.sheet.startRowColNum;
	var rowLevel = null;
	var rowClass = null;
	var cellClass = null;
	var sheetRowLength = 0;
	var sheetCellLength = 0;
	var sheetColCount = 0;
	var topIndex = this.showedTopRowIndex + 1;
	var rowNum = 0;
	//
	var headerInfos = null;
	var headerInfo = null;
	var rowRIndex = 0;	//실제 행(tr)의 인덱스
	var colRIndex = 0;	//실제 컬럼(td)의 인덱스
	var recordIndex = 0;
	var rightFixIndex = 0;
	//데이터
	var value = null;
	var text = null;
	var alt = null;
	
	var i = 0; var j = 0; var k = 0; var m = 0; var n = 0;
	
	//화면에 표시된 행 수 초기화
	this.displayedRowCount = 0;
	
	//행 표시 및 데이터 출력 처리
	sheetContentRows = (document.getElementsByName(this.controlId + "_SheetContentTable")[0]).getElementsByTagName("tr");
	sheetContentLeftFixRows = (typeof this.SheetHeaderLeftFixObject != "undefined" && this.SheetHeaderLeftFixObject != null) 
								? (document.getElementsByName(this.controlId + "_SheetContentLeftFixTable")[0]).getElementsByTagName("tr") : null;
	sheetContentRightFixRows = (typeof this.SheetHeaderRightFixObject != "undefined" && this.SheetHeaderRightFixObject != null)
								? (document.getElementsByName(this.controlId + "_SheetContentRightFixTable")[0]).getElementsByTagName("tr") : null;
	if( sheetContentRightFixRows != null ){
		rightFixGap = this.colsPerRow - this.rightFixColumnCount;
	}
	
	sheetRowLength = sheetContentRows.length / this.rowsPerDataRow;
	sheetColCount = this.columnInfo.length;
	
	for(i = 0; i < sheetRowLength && i < this.displayMaxRowCount; i++){
		if( i < this.data.length ){
			//화면에 표시된 행 수 증가
			this.displayedRowCount++;
			
			for(j = 0; j < this.rowsPerDataRow; j++){
				rowData = this.data[i]; //행 단위 데이터 저장
				rowRIndex = (i * this.rowsPerDataRow) + j;
				
				sheetContentRowCells = sheetContentRows[rowRIndex].getElementsByTagName("td"); //행 별 열 객체배열 저장
				//좌측고정 본문행 별 열 객체배열 저장
				if( sheetContentLeftFixRows != null ){
					sheetContentLeftFixRowCells = sheetContentLeftFixRows[rowRIndex].getElementsByTagName("td");
				}
				//우측고정 본문행 별 열 객체배열 저장
				if( sheetContentRightFixRows != null ){
					sheetContentRightFixRowCells = sheetContentRightFixRows[rowRIndex].getElementsByTagName("td");
				}
				
				//행번호 갱신
//				rowNum = topIndex + i;
				recordIndex = rowData.__STATE__._record_index;
//				rowNum = this.rowNumOrder ? (recordIndex + 1) : (this.dataRowCount - recordIndex);
				rowNum = (typeof rowData.__STATE__.rowNum == "undefined") ? "" : (this.rowNumOrder ? rowData.__STATE__.rowNum : (this.visibleRowCount - (rowData.__STATE__.rowNum - 1)));
				
				if( j == 0 ){
					sheetContentRowCells[0].getElementsByTagName("div")[0].innerHTML = rowNum;
					sheetContentRowCells[0].setAttribute("title", rowNum);
					//좌측고정열 행번호 갱신
					if( sheetContentLeftFixRowCells != null && sheetContentLeftFixRowCells.length > 0 ){
						sheetContentLeftFixRowCells[0].getElementsByTagName("div")[0].innerHTML = rowNum;
						sheetContentLeftFixRowCells[0].setAttribute("title", rowNum);
					}
				}
				
				//행 보이기
				sheetContentRows[rowRIndex].style.display = "table-row";
				sheetContentRows[rowRIndex].setAttribute("recordindex", "" + recordIndex);
				if( sheetContentLeftFixRows != null ){
					sheetContentLeftFixRows[rowRIndex].style.display = "table-row"; //좌측고정열
					sheetContentLeftFixRows[rowRIndex].setAttribute("recordindex", "" + recordIndex);
				}
				if( sheetContentRightFixRows != null ){
					sheetContentRightFixRows[rowRIndex].style.display = "table-row"; //우측고정열
					sheetContentRightFixRows[rowRIndex].setAttribute("recordindex", "" + recordIndex);
				}
				
				//행번호를 기준으로 홀수번째 행과 짝수번째 행 클래스 적용
				rowLevel = rowData.__STATE__._rowLevel;
				rowClass = (displayOddEven ? (rowNum % 2 == 0 ? "even-num-row " : "odd-num-row ") : "none-background-row ");
				rowClass += ("row-level-" + ((typeof rowLevel == "undefined") ? 0 : rowLevel) + "-style");
//				this.setRowClass(recordIndex - this.showedTopRowIndex, rowClass, true);
				this.setRowClass(rowRIndex, rowClass, true);
				//사용자 추가 클래스 적용
				if( this.rowStyleClass != null ){
					if( typeof this.rowStyleClass == "function" ){
						this.setRowClass(rowRIndex, (" " + this.rowStyleClass(rowData.__STATE__._record_index, rowData)), false);
					}
					else{
						this.setRowClass(rowRIndex, (" " + this.rowStyleClass), false);
					}
				}
				
				//행의 컬럼 데이터 갱신
				sheetCellLength = sheetContentRowCells.length;
				headerInfos = this.headerInfo[this.headerInfo.length - this.rowsPerDataRow + j];
				
				for(k = 0, colRIndex = (j > 0 ? 0 : 1); sheetColCount > 0 && k < this.colsPerRow && colRIndex < sheetCellLength; k++, headerInfo = null){
					headerInfo = headerInfos[k];
					if( headerInfo.colspan < 0 ) continue;
					
					m = headerInfo.cellIndex;
					if( m >= sheetColCount ){
						headerInfo = null; break;
					}
					
					//좌/우고정 열 체크
					hasLeftFixColumn = (sheetContentLeftFixRowCells != null && this.leftFixColumnCount > 0 && k < this.leftFixColumnCount);
					hasRightFixColumn = (sheetContentRightFixRowCells != null && this.rightFixColumnCount > 0 && k >= rightFixGap);
					//우고정 컬럼인 경우 우고정 컬럼의 실제 인덱스 계산
					if( hasRightFixColumn ) rightFixIndex = k - rightFixGap;
					
					//병합 설정
					if( typeof rowData.__STATE__.mergeInfo != "undefined" ){
						var sheetRow = this.columnInfo[m].row - 1;
						var sheetCol = k;
						var mergeInfo = (rowData.__STATE__.mergeInfo[sheetRow])[sheetCol];
						var rowspan = mergeInfo.rowSpan;
						var display = (mergeInfo.disp ? "" : "none");
						var canMerge = (rowspan == this.rowsPerDataRow);
						var rowMergeCnt = rowspan;
						var r = 0;
						
						//병합할 행 수 구함
						if( canMerge && display.length == 0 ){
							for(r = i + 1; r < this.data.length; r++){
								if( (this.data[r].__STATE__.mergeInfo[sheetRow])[sheetCol].disp ) break;
								rowMergeCnt += this.rowsPerDataRow;
							}
						}
						
						//본문
						sheetContentRowCells[colRIndex].style.display = display;
						sheetContentRowCells[colRIndex].setAttribute("rowspan", rowMergeCnt);
						//좌측고정
						if( hasLeftFixColumn ){
							sheetContentLeftFixRowCells[colRIndex].style.display = display;
							sheetContentLeftFixRowCells[colRIndex].setAttribute("rowspan", rowMergeCnt);
						}
						//우측고정
						if( hasRightFixColumn ){
							sheetContentRightFixRowCells[rightFixIndex].style.display = display;
							sheetContentRightFixRowCells[rightFixIndex].setAttribute("rowspan", rowMergeCnt);
						}
						
						//메모리 해제
						display = null; mergeInfo = null;
					}
					
					//현재 수정중인 셀은 다시 그리지 않음
					if( sheetContentRowCells[colRIndex] === this.editingCellObject && this.isEditngSheet ){ colRIndex++; continue; }
					if( hasLeftFixColumn && sheetContentLeftFixRowCells[colRIndex] === this.editingCellObject && this.isEditngSheet ){ colRIndex++; continue; }
					if( hasRightFixColumn && sheetContentRightFixRowCells[rightFixIndex] === this.editingCellObject && this.isEditngSheet ){ colRIndex++; continue; }
					
					//셀 클래스 적용
					cellClass = "";
					if( this.columnInfo[m].columnStyleClass != null ){
						if( typeof this.columnInfo[m].columnStyleClass == "function" )
							cellClass = ("" + this.columnInfo[m].columnStyleClass(rowData.__STATE__._record_index + startRowColNum, m + startRowColNum, rowData));
						else
							cellClass = ("" + this.columnInfo[m].columnStyleClass);
					}
					else if( this.cellStyleClass != null ){
						if( typeof this.cellStyleClass == "function" )
							cellClass = ("" + this.cellStyleClass(rowData.__STATE__._record_index + startRowColNum, m + startRowColNum, rowData));
						else
							cellClass = ("" + this.cellStyleClass);
					}
					this.setCellClass(sheetContentRowCells[colRIndex], cellClass, true);
					if( hasLeftFixColumn ) this.setCellClass(sheetContentLeftFixRowCells[colRIndex], cellClass, true); //좌측고정
					if( hasRightFixColumn ) this.setCellClass(sheetContentRightFixRowCells[rightFixIndex], cellClass, true); //우측고정
					
					//셀타입이 버튼인 경우
					if( this.columnInfo[m].cellType == "button" ){
						//버튼 캡션 구함
						if( this.showedTopRowIndex >= 0 ){
							if( typeof this.columnInfo[m].buttonCaption == "function" )
								value = this.columnInfo[m].buttonCaption(rowData.__STATE__._record_index, m);
							else
								value = "" + this.columnInfo[m].buttonCaption;
						}
						else	value = "";
						
						//버튼 세팅
//						this.setCellTypeButton(m, sheetContentRowCells[colRIndex].getElementsByTagName("input")[0], value);
						this.setCellTypeButton(m, sheetContentRowCells[colRIndex].querySelector("button.SheetCellButton"), value);
						//좌측고정열 버튼 세팅
//						if( hasLeftFixColumn ) this.setCellTypeButton(m, sheetContentLeftFixRowCells[colRIndex].getElementsByTagName("input")[0], value);
						if( hasLeftFixColumn ) this.setCellTypeButton(m, sheetContentLeftFixRowCells[colRIndex].querySelector("button.SheetCellButton"), value);
						//우측고정열 버튼 세팅
//						if( hasRightFixColumn ) this.setCellTypeButton(m, sheetContentRightFixRowCells[rightFixIndex].getElementsByTagName("input")[0], value);
						if( hasRightFixColumn ) this.setCellTypeButton(m, sheetContentRightFixRowCells[rightFixIndex].querySelector("button.SheetCellButton"), value);
						
						//메모리 초기화
						value = null;
					}
					//셀타입이 링크인 경우
					else if( this.columnInfo[m].cellType == "link" ){
						//링크 캡션 구함
						if( this.showedTopRowIndex >= 0 ){
							if( typeof this.columnInfo[m].linkCaption == "function" )
								value = this.columnInfo[m].linkCaption(rowData.__STATE__._record_index, k);
							else
								value = "" + this.columnInfo[m].linkCaption;
						}
						else	value = "";
						
						//링크 세팅
						this.setCellTypeLink(m, sheetContentRowCells[colRIndex].getElementsByTagName("a")[0], value);
						//좌측고정열 링크 세팅
						if( hasLeftFixColumn ) this.setCellTypeLink(m, sheetContentLeftFixRowCells[colRIndex].getElementsByTagName("a")[0], value);
						//우측고정열 링크 세팅
						if( hasRightFixColumn ) this.setCellTypeLink(m, sheetContentRightFixRowCells[rightFixIndex].getElementsByTagName("a")[0], value);
						
						//메모리 초기화
						value = null;
					}
					//셀타입이 이미지인 경우
					else if( this.columnInfo[m].cellType == "image" ){
						//이미지 소스 설정
						value = (typeof rowData != "undefined") ? rowData[this.columnInfo[m].field] : this.columnInfo[m].defalutValue;
						//이미지 alt 설정
						if( this.showedTopRowIndex >= 0 ){
							if( typeof this.columnInfo[m].alt == "function" )
								alt = this.columnInfo[m].alt(rowData.__STATE__._record_index, m);
							else
								alt = "" + this.columnInfo[m].alt;
						}
						else	alt = "";
						
						//이미지 세팅
						this.setCellTypeImage(m, sheetContentRowCells[colRIndex].getElementsByTagName("img")[0], value, alt);
						//시트 좌측고정 본문 이미지 세팅
						if( hasLeftFixColumn ) this.setCellTypeImage(m, sheetContentLeftFixRowCells[colRIndex].getElementsByTagName("img")[0], value, alt);
						//우측고정열 링크 세팅
						if( hasRightFixColumn ) this.setCellTypeImage(m, sheetContentRightFixRowCells[rightFixIndex].getElementsByTagName("img")[0], value, alt);

						//메모리 해제
						value = null;
						alt = null;
					}
					//그 외
					else{
						if( this.columnInfo[m].cellType == "combobox" ){
//							text = this.dataSet.getState(i, this.columnInfo[k].field + ".TEXT");
							text = rowData.__STATE__[this.columnInfo[m].field + ".TEXT"];
						}
						
						value = rowData[this.columnInfo[m].field];
						
						//데이터 가공(포맷, 데이터타입 등등)
						if( typeof value == "undefined" || value == null || ("" + value).length <= 0 )
							value = this.columnInfo[m].defalutValue;
						
						//표시 데이테로 변환
						value = this.getDisplayValueByCellType(m, value, text);
						
						//툴팁
						this.setCellTooltip(m, sheetContentRowCells[colRIndex], value);
						//데이터 갱신
						sheetContentRowCells[colRIndex].getElementsByTagName("div")[0].innerHTML = value;
						//좌측고정열
						if( hasLeftFixColumn ){
							this.setCellTooltip(m, sheetContentLeftFixRowCells[colRIndex], value);
							sheetContentLeftFixRowCells[colRIndex].getElementsByTagName("div")[0].innerHTML = value;
						}
						//우측고정열
						if( hasRightFixColumn ){
							this.setCellTooltip(m, sheetContentRightFixRowCells[rightFixIndex], value);
							sheetContentRightFixRowCells[rightFixIndex].getElementsByTagName("div")[0].innerHTML = value;
						}
						
						//메모리 초기화
						text = null; value = null;
					}
					
					//셀타입이 정수 또는 실수인 경우
					if( this.columnInfo[m].cellType == "integer" || this.columnInfo[m].cellType == "number" || this.columnInfo[m].cellType == "percent" ){
						//셀 값이 음수인 경우 글자색을 빨간색으로 변경
						if( this.columnInfo[m].negativeRed === true && typeof rowData != "undefined" && typeof rowData == "object" && this.columnInfo[m].field in rowData && (1 * rowData[this.columnInfo[m].field]) < 0 ){
							this.setCellFontColor(m, sheetContentRowCells[colRIndex], "#ff0000");
							if( hasLeftFixColumn ) this.setCellFontColor(m, sheetContentLeftFixRowCells[colRIndex], "#ff0000"); //좌측고정
							if( hasRightFixColumn ) this.setCellFontColor(m, sheetContentRightFixRowCells[rightFixIndex], "#ff0000"); //우측고정
						}
						else{
							this.setCellFontColor(m, sheetContentRowCells[colRIndex]);
							if( hasLeftFixColumn ) this.setCellFontColor(m, sheetContentLeftFixRowCells[colRIndex]); //좌측고정
							if( hasRightFixColumn ) this.setCellFontColor(m, sheetContentRightFixRowCells[rightFixIndex]); //우측고정
						}
					}
					
					//셀 인덱스 증가
					colRIndex++;
					
					//메모리 초기화
					cellClass = null; hasLeftFixColumn = null; hasRightFixColumn = null;
				}
				
				//메모리 초기화
				sheetContentRightFixRowCells = null;
				sheetContentLeftFixRowCells = null;
				sheetContentRowCells = null;
			}
			
			//메모리 초기화
			rowData = null;
			rowClass = null;
		}
		else{
			//행 숨기기
			for(j = 0; j < this.rowsPerDataRow; j++){
				rowRIndex = (i * this.rowsPerDataRow) + j;
				
				sheetContentRows[rowRIndex].style.display = "none";
				if( sheetContentLeftFixRows != null ){
					sheetContentLeftFixRows[rowRIndex].style.display = "none";
				}
				if( sheetContentRightFixRows != null ){
					sheetContentRightFixRows[rowRIndex].style.display = "none";
				}
			}
		}
	}
	
	//마우스오버 객체가 있다면 마우스오버 객체 적용
	if( this.mouseOverObject != null ){
		//시트 선택 모드가 셀 선택 모드인 경우
		if( this.selectMode == SHEET_SELECT_CELL ){
			mouseOverObejct = this.mouseOverObject;
			if( this.hasClass(mouseOverObejct, "mouse-over-col") <= 0 ) this.setCellClass(mouseOverObejct, "mouse-over-col", false);
		}
		//시트 선택 모드가 행 선택 모드인 경우
		else if( this.selectMode == SHEET_SELECT_ROW ){
			mouseOverObejct = this.mouseOverObject.parentNode;
			if( this.hasClass(mouseOverObejct, "mouse-over-row") <= 0 ) this.setRowClass(mouseOverObejct, "mouse-over-row", false);
		}
		//메모리 해제
		mouseOverObejct = null;
	}
	
	//선택된 객체가 있다면 선택 클래스 적용
	if( this.selectedObject != null ){
//		//파라메터가 행 인덱스로 동작하므로 selectedRowIndex 에서 showedTopRowIndex 를 빼야함
//		this.setSelectionClass(this.selectedRowIndex - this.showedTopRowIndex, this.selectedColumnIndex);
		//파라메터가 행 인덱스로 동작하므로 selectedRowIndex 값으로 TR객체를 찾아 rowIndex 속성 값을 전달함
		rowObject = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentDiv > table#" + this.controlId + "_SheetContentTable tr[recordindex='" + this.selectedRowIndex + "']");
		if( rowObject != null ) this.setSelectionClass((1 * rowObject.getAttribute("rowIndex")), this.selectedColumnIndex);
		//메모리 해제
		rowObject = null;
	}
	
	if( this.displayedRowCount <= 0 ){
		this.showedTopRowIndex = -1;
	}
	
	//푸터 세팅
	this.setFooter();
	
	//리사이즈
	this.resize();
	
	//메모리 해제
	hasLeftFixColumn = null; hasRightFixColumn = null;
	topIndex = null; rowNum = null; rowClass = null; cellClass = null;
	sheetContentRightFixRows = null;
	sheetContentLeftFixRows = null;
	sheetContentRows = null;
	dataList = null; args = null;
};

EasySheetRenderer.prototype.setFooter = function(){
	//예외처리
	//푸터 보이기 설정이 안 된 경우
	if( !this.isShowFooter ) return;
	//푸터 정보가 없는 경우
	var footerColCount = this.footerInfo.length;
	if( footerColCount <= 0 ) return;
	
	var rows = null; var leftFixRows = null; var rightFixRows = null;
	var cells = null; var leftFixCells = null; var rightFixCells = null;
	var cell = null; var cellDiv = null;
	var headRowItem = null; headColItem = null;
	var footerInfo = null;
	var align = null; var vAlign = null;
	var backColor = null; var fontColor = null; var display = null;
	var columnStyle = null; var value = null;
	var sheetRowCount = 0;
	var footerRowCount = this.footerRowCount;
	var rowsPerDataRow = this.rowsPerDataRow;
	var colsPerRow = this.colsPerRow;
	var cellCount = 0; var rightFixGap = 0;
	var headerStartRowIndex = this.headerInfo.length - this.rowsPerDataRow;
	var rowIndex = 0; var colIndex = 0;
	var i = 0; var j = 0; var k = 0; var c = 0;
	
	rows = this.SheetFooterObject.querySelectorAll("div.SheetFooterDiv tr");
	if( this.leftFixColumnCount > 0 ){
		leftFixRows = this.SheetFooterObject.querySelectorAll("div.SheetFooterLeftFixDiv tr");
	}
	if( this.rightFixColumnCount > 0 ){
		rightFixRows = this.SheetFooterObject.querySelectorAll("div.SheetFooterRightFixDiv tr");
		rightFixGap = colsPerRow - this.rightFixColumnCount;
	}
	
	//푸터 다시 그리기
	for(i = 0, rowIndex = 0, sheetRowCount = rows.length; i < sheetRowCount && i < footerRowCount; i++){
		for(j = 0, colIndex = 0; j < rowsPerDataRow; j++, headRowItem = null){
			rowIndex = (i * rowsPerDataRow) + j;
			
			cells = rows[rowIndex].getElementsByTagName("td");
			if( leftFixRows != null && leftFixRows.length > 0 ){
				leftFixCells = leftFixRows[rowIndex].getElementsByTagName("td");
			}
			if( rightFixRows != null && rightFixRows.length > 0 ){
				rightFixCells = rightFixRows[rowIndex].getElementsByTagName("td");
			}
			
			headRowItem = this.headerInfo[headerStartRowIndex + j];
			cellCount = cells.length;
			
			for(k = 0, colIndex = (j > 0 ? 0 : 1); k < colsPerRow && colIndex < cellCount; k++, headColItem = null, footerInfo = null){
				headColItem = headRowItem[k];
				if( headColItem.colspan < 0 ) continue;
				
				c = headColItem.cellIndex;
				if( c >= footerColCount ){
					headColItem = null;
					break;
				}
				
				//푸터 정보 세팅
				footerInfo = this.footerInfo[c];
				align = footerInfo.align;
				vAlign = footerInfo.valign;
				display = (footerInfo.hidden) ? "none" : "";
				backColor = footerInfo.backgroundColor;
				fontColor = footerInfo.fontColor;
				columnStyle = footerInfo.columnStyleClass;
				value = footerInfo.value;
				value = (typeof value == "undefined" || value == null) ? "" : value;
				
				//본문
				//스타일 설정
				cell = cells[colIndex];
				cell.style.textAlign = align;
				cell.style.verticalAlign = vAlign;
				cell.style.display = display;
				if( backColor.length > 0 ) cell.style.backgroundColor = backColor;
				if( fontColor.length > 0 ) cell.style.color = fontColor;
				if( typeof columnStyle != "undefined" && columnStyle != null ) cell.className = columnStyle;
				//데이터 설정
				cellDiv = cell.querySelector("div");
				cellDiv.innerHTML = value;
				//메모리 해제
				cellDiv = null; cell = null;
				
				//좌측고정
				if( leftFixCells != null && this.leftFixColumnCount > 0 && k < this.leftFixColumnCount ){
					//스타일 설정
					cell = leftFixCells[colIndex];
					cell.style.textAlign = align;
					cell.style.verticalAlign = vAlign;
					cell.style.display = display;
					if( backColor.length > 0 ) cell.style.backgroundColor = backColor;
					if( fontColor.length > 0 ) cell.style.color = fontColor;
					if( typeof columnStyle != "undefined" && columnStyle != null ) cell.className = columnStyle;
					//데이터 설정
					cellDiv = cell.querySelector("div");
					cellDiv.innerHTML = value;
					//메모리 해제
					cellDiv = null; cell = null;
				}
				//우측고정
				if( rightFixCells != null && this.rightFixColumnCount > 0 && k >= rightFixGap ){
					//스타일 설정
					cell = rightFixCells[k - rightFixGap]; //우고정 컬럼인 경우 우고정 컬럼의 실제 인덱스 계산
					cell.style.textAlign = align;
					cell.style.verticalAlign = vAlign;
					cell.style.display = display;
					if( backColor.length > 0 ) cell.style.backgroundColor = backColor;
					if( fontColor.length > 0 ) cell.style.color = fontColor;
					if( typeof columnStyle != "undefined" && columnStyle != null ) cell.className = columnStyle;
					//데이터 설정
					cellDiv = cell.querySelector("div");
					cellDiv.innerHTML = value;
					//메모리 해제
					cellDiv = null; cell = null;
				}
				
				//셀 인덱스 증가
				colIndex++;
				
				//메모리 해제
				value = null; fontColor = null; backColor = null;
				display = null; vAlign = null; align = null;
			}
			
			//메모리 해제
			rightFixCells = null; leftFixCells = null; cells = null;
		}
	}
	
	//메모리 해제
	rightFixRows = null; leftFixRows = null; rows = null;
};

EasySheetRenderer.prototype.redraw = function(){
	var headRowItem = null; var headColItem = null;
	var cellItem = null; var divItem = null;
	var headerStartRowIndex = 0; var headerInfoSize = 0;
	var isHeaderRow = false; var hasCaptionColumn = false;
	var title = null; var caption = null; var titleClass = null;
	var startRowColNum = this.sheet.startRowColNum;
	var i = 0; var j = 0; var k = 0; var c = 0;
	
	headerInfoSize = this.headerInfo.length;
	headerStartRowIndex = headerInfoSize - this.rowsPerDataRow;
	
	//헤더 다시 그리기
	for(i = 0; i < headerInfoSize; i++, headRowItem = null){
		headRowItem = this.headerInfo[i];
		isHeaderRow = (i >= headerStartRowIndex);
		
		for(j = 0, c = 0; j < this.colsPerRow; j++, headColItem = null){
			headColItem = headRowItem[j];
			
			if( headColItem.colspan < 0 ) continue;
			
			//
			if( isHeaderRow ){
				caption = this.columnInfo[c].tooltip;
				titleClass = this.columnInfo[c].columnTitleClass;
				hasCaptionColumn = (typeof caption != "undefined") || (typeof caption == "string" && caption.length <= 0);
				c++;
			}
			//
			title = headColItem.title;
			
			cellItem = headColItem.cells.header;
			if( isHeaderRow ){
				this.addClass(cellItem, titleClass);
				cellItem.querySelector("div").innerHTML = title;
				if( hasCaptionColumn ) cellItem.setAttribute("title", caption);
			}
			else{
				divItem = cellItem.querySelector("div");
				if( divItem != null ) divItem.innerHTML = title;
				else cellItem.innerHTML = title;
				divItem = null;
			}
			cellItem = null;
			
			if( typeof headColItem.cells.leftfix != "undefined" ){
				cellItem = headColItem.cells.leftfix;
				if( isHeaderRow ){
					this.addClass(cellItem, titleClass);
					cellItem.querySelector("div").innerHTML = title;
					if( hasCaptionColumn ) cellItem.setAttribute("title", caption);
				}
				else{
					divItem = cellItem.querySelector("div");
					if( divItem != null ) divItem.innerHTML = title;
					else cellItem.innerHTML = title;
					divItem = null;
				}
				cellItem = null;
			}
			
			if( typeof headColItem.cells.rightfix != "undefined" ){
				cellItem = headColItem.cells.rightfix;
				if( isHeaderRow ){
					this.addClass(cellItem, titleClass);
					cellItem.querySelector("div").innerHTML = title;
					if( hasCaptionColumn ) cellItem.setAttribute("title", caption);
				}
				else{
					divItem = cellItem.querySelector("div");
					if( divItem != null ) divItem.innerHTML = title;
					else cellItem.innerHTML = title;
					divItem = null;
				}
				cellItem = null;
			}
			
			//메모리 해제
			title = null; caption = null; titleClass = null;
			hasCaptionColumn = false;
		}
	}
	
	var rows = null; var leftFixRows = null; var rightFixRows = null;
	var cells = null; var leftFixCells = null; var rightFixCells = null;
	var cell = null; var leftFixCell = null; var rightFixCell = null;
	var cellDiv = null; var leftFixCellDiv = null; var rightFixCellDiv = null;
	var rowData = null; var cellValue = null; var columnInfo = null;
	var hasLeftFixColumn = false; var hasRightFixColumn = false;
	var displayOddEven = this.displayOddEven;
	var rowCount = 0; var colCount = 0; var columnCount = 0;
	var dataIndex = 0; var rowIndex = 0; var colIndex = 0;
	var rightFixGap = 0; var rightFixIndex = 0;
	var rowNum = 0; var rowLevel = 0; var rowClass = null;
	var cellClass = null; var recordIndex = -1;
	
	hasLeftFixColumn = (this.leftFixColumnCount > 0);
	hasRightFixColumn = (this.rightFixColumnCount > 0);
	columnCount = this.columnInfo.length;
	
	//본문 다시 그리기
	rows = this.SheetContentObject.querySelectorAll("div.SheetContentDiv tr");
	if( hasLeftFixColumn ) leftFixRows = this.SheetContentObject.querySelectorAll("div.SheetContentLeftFixDiv tr");
	if( hasRightFixColumn ) rightFixRows = this.SheetContentObject.querySelectorAll("div.SheetContentRightFixDiv tr");
	if( hasRightFixColumn != null ) rightFixGap = this.colsPerRow - this.rightFixColumnCount;
	
	for(i = 0, rowCount = rows.length; i < rowCount; i = i + this.rowsPerDataRow){
		//데이터 행 인덱스
		dataIndex = (i - (i % this.rowsPerDataRow)) / this.rowsPerDataRow;
		//시트 행 데이터 저장
		rowData = this.data[dataIndex];
		recordIndex = (typeof rowData != "undefined") ? rowData.__STATE__._record_index : -1;
		
		for(j = 0, rowIndex = i, colIndex = 0; j < this.rowsPerDataRow && i < rowCount; j++){
			//실제 행 인덱스
			rowIndex = i + j;
			
			//시트 행별 열 객체 저장
			cells = rows[rowIndex].getElementsByTagName("td");
			if( leftFixRows != null && leftFixRows.length > 0 ) leftFixCells = leftFixRows[rowIndex].getElementsByTagName("td");
			if( rightFixRows != null && rightFixRows.length > 0 ) rightFixCells = rightFixRows[rowIndex].getElementsByTagName("td");
			
			//행번호를 기준으로 홀수번째 행과 짝수번째 행 클래스 적용
			if( j == 0 ){
				rowNum = cells[0].querySelector("div").innerHTML;
				
				rowLevel = (typeof rowData != "undefined") ? rowData.__STATE__._rowLevel : 0;
				rowClass = (displayOddEven ? (rowNum % 2 == 0 ? "even-num-row " : "odd-num-row ") : "none-background-row ");
				rowClass += "row-level-" + ((typeof rowLevel == "undefined") ? 0 : rowLevel) + "-style";
				
				this.setRowClass(rowIndex, rowClass, true);
				
				rowClass = null;
			}
			//사용자 추가 클래스 적용
			if( (typeof rowData != "undefined" && recordIndex >= 0) && this.rowStyleClass != null ){
				if( typeof this.rowStyleClass == "function" )
					rowClass = (" " + this.rowStyleClass(recordIndex + startRowColNum, rowData));
				else
					rowClass = (" " + this.rowStyleClass);
				
				this.setRowClass(rowIndex, rowClass, false);
				
				rowClass = null;
			}
			
			headRowItem = this.headerInfo[headerStartRowIndex + j];
			colCount = cells.length;
			
			//본문 셀 적용
			for(k = 0, colIndex = (j > 0 ? 0 : 1); columnCount > 0 && k < this.colsPerRow && colIndex < colCount; k++, headColItem = null, columnInfo = null){
				headColItem = headRowItem[k];
				if( headColItem.colspan < 0 ) continue;
				
				c = headColItem.cellIndex;
				if( c >= columnCount ){
					headerInfo = null; break;
				}
				
				columnInfo = this.columnInfo[c];
				
				cell = cells[colIndex];
				cellDiv = cell.querySelector("div");
				if( leftFixCells != null && this.leftFixColumnCount > 0 && k < this.leftFixColumnCount ){
					leftFixCell = leftFixCells[colIndex];
					leftFixCellDiv = leftFixCell.querySelector("div");
				}
				if( rightFixCells != null && this.rightFixColumnCount > 0 && k >= rightFixGap ){
					rightFixIndex = k - rightFixGap; //우고정 컬럼인 경우 우고정 컬럼의 실제 인덱스 계산
					rightFixCell = rightFixCells[rightFixIndex];
					rightFixCellDiv = rightFixCell.querySelector("div");
				}
				
				//좌/우고정 열 체크
				hasLeftFixColumn = (leftFixCell != null);
				hasRightFixColumn = (rightFixCell != null);
				
				//병합 설정
				if( typeof rowData != "undefined" && typeof rowData.__STATE__.mergeInfo != "undefined" ){
					var sheetRow = columnInfo.row - 1;
					var sheetCol = k;
					var mergeInfo = (rowData.__STATE__.mergeInfo[sheetRow])[sheetCol];
					var rowspan = mergeInfo.rowSpan;
					var display = (mergeInfo.disp ? "" : "none");
					var canMerge = (rowspan == this.rowsPerDataRow);
					var rowMergeCnt = rowspan;
					var r = 0;
					
					//병합할 행 수 구함
					if( display.length == 0 && canMerge ){
						for(r = i + 1; r < this.data.length; r++){
							if( (this.data[r].__STATE__.mergeInfo[sheetRow])[sheetCol].disp ) break;
							rowMergeCnt += this.rowsPerDataRow;
						}
					}
					
					//본문
					cell.style.display = display;
					cell.setAttribute("rowspan", rowMergeCnt);
					//좌측고정
					if( hasLeftFixColumn ){
						leftFixCell.style.display = display;
						leftFixCell.setAttribute("rowspan", rowMergeCnt);
					}
					//우측고정
					if( hasRightFixColumn ){
						rightFixCell.style.display = display;
						rightFixCell.setAttribute("rowspan", rowMergeCnt);
					}
					
					//메모리 해제
					display = null; mergeInfo = null;
				}
				
				//현재 수정중인 셀은 다시 그리지 않음
				if( cell === this.editingCellObject && this.isEditngSheet ) continue;
				if( hasLeftFixColumn && leftFixCell === this.editingCellObject && this.isEditngSheet ) continue;
				if( hasRightFixColumn && rightFixCell === this.editingCellObject && this.isEditngSheet ) continue;
				
				//셀 공통 스타일
				//수평정렬 적용
				this.setCellHAlign(c, cell);
				if( hasLeftFixColumn ) this.setCellHAlign(c, leftFixCell);				//좌측고정
				if( hasRightFixColumn ) this.setCellHAlign(c, rightFixCell);			//우측고정
				
				//수직정렬 적용
				this.setCellVAlign(c, cell);
				if( hasLeftFixColumn ) this.setCellVAlign(c, leftFixCell);				//좌측고정
				if( hasRightFixColumn ) this.setCellVAlign(c, rightFixCell);			//우측고정
				
				//배경색 적용
				this.setCellBackgroundColor(c, cell);
				if( hasLeftFixColumn ) this.setCellBackgroundColor(c, leftFixCell);		//좌측고정
				if( hasRightFixColumn ) this.setCellBackgroundColor(c, rightFixCell);	//우측고정
				
				//글자색 적용
				this.setCellFontColor(c, cell);
				if( hasLeftFixColumn ) this.setCellFontColor(c, leftFixCell);			//좌측고정
				if( hasRightFixColumn ) this.setCellFontColor(c, rightFixCell);			//우측고정
				
				//셀 클래스 적용
				cellClass = "";
				if( typeof rowData != "undefined" && recordIndex >= 0 ){
					if( columnInfo.columnStyleClass != null ){
						if( typeof columnInfo.columnStyleClass == "function" )
							cellClass = ("" + columnInfo.columnStyleClass(recordIndex + startRowColNum, c + startRowColNum, rowData));
						else
							cellClass = ("" + columnInfo.columnStyleClass);
					}
					else if( this.cellStyleClass != null ){
						if( typeof this.cellStyleClass == "function" )
							cellClass = ("" + this.cellStyleClass(recordIndex + startRowColNum, c + startRowColNum, rowData));
						else
							cellClass = ("" + this.cellStyleClass);
					}
				}
				this.setCellClass(cell, cellClass, true);
				if( hasLeftFixColumn ) this.setCellClass(leftFixCell, cellClass, true);		//좌측고정
				if( hasRightFixColumn ) this.setCellClass(rightFixCell, cellClass, true);	//우측고정
				
				//셀타입이 버튼인 경우
				if( columnInfo.cellType == "button" ){
					//버튼 캡션 구함
					if( this.showedTopRowIndex >= 0 && recordIndex >= 0 ){
						if( typeof columnInfo.buttonCaption == "function" )
							caption = columnInfo.buttonCaption(recordIndex, c);
						else
							caption = "" + columnInfo.buttonCaption;
					}
					else	caption = "";
					
					//버튼 세팅
					this.setCellTypeButton(c, cellDiv, caption);									//본문
					if( hasLeftFixColumn ) this.setCellTypeButton(c, leftFixCellDiv, caption);		//좌측고정
					if( hasRightFixColumn ) this.setCellTypeButton(c, rightFixCellDiv, caption);	//우측고정
					
					//메모리 해제
					caption = null;
				}
				//셀타입이 링크인 경우
				else if( columnInfo.cellType == "link" ){
					//링크 캡션 구함
					if( this.showedTopRowIndex >= 0 && recordIndex >= 0 ){
						if( typeof columnInfo.linkCaption == "function" )
							caption = columnInfo.linkCaption(recordIndex, c)
							else
								caption = "" + columnInfo.linkCaption;
					}
					else	caption = "";
					
					//링크 세팅
					this.setCellTypeLink(c, cellDiv, caption);										//본문
					if( hasLeftFixColumn ) this.setCellTypeLink(k, leftFixCellDiv, caption);		//좌측고정 
					if( hasRightFixColumn ) this.setCellTypeLink(k, rightFixCellDiv, caption);		//우측고정
					
					//메모리 해제
					caption = null;
				}
				//셀타입이 이미지인 경우
				else if( columnInfo.cellType == "image" ){
					//이미지 소스 설정
					src = (typeof rowData != "undefined") ? rowData[columnInfo.field] : this.columnInfo[c].defalutValue;
					
					//이미지 alt 설정
					if( this.showedTopRowIndex >= 0 && recordIndex >= 0 ){
						if( typeof columnInfo.alt == "function" )
							alt = columnInfo.alt(recordIndex, c);
						else
							alt = "" + columnInfo.alt;
					}
					else	alt = "";
					
					//이미지 세팅
					this.setCellTypeImage(c, cellDiv, src, alt);									//본문
					if( hasLeftFixColumn ) this.setCellTypeImage(c, leftFixCellDiv, src, alt);		//좌측고정
					if( hasRightFixColumn ) this.setCellTypeImage(c, rightFixCellDiv, src, alt);	//우측고정 
					
					//메모리 해제
					alt = null; src = null;
				}
				//그외 셀타입 : 텍스트, 정수, 실수, 퍼센트, 체크박스, 콤보박스, 일자(날짜)
				else{
					//체크박스인 경우 fontello 폰트 적용
					if( columnInfo.cellType == "checkbox" ){
						cell.style.fontFamily = "fontello";										//본문
						if( hasLeftFixColumn ) leftFixCell.style.fontFamily = "fontello";		//좌측고정
						if( hasRightFixColumn ) rightFixCellDiv.style.fontFamily = "fontello";	//우측고정
					}
					
					if( typeof rowData != "undefined" && (typeof rowData == "object" && (columnInfo.field in rowData)) && ("" + rowData[columnInfo.field]).length > 0 ){
						//셀타입이 정수 또는 실수인 경우
						if( (columnInfo.cellType == "integer" || columnInfo.cellType == "number") && columnInfo.negativeRed === true && (1 * rowData[columnInfo.field]) < 0 ){
							this.setCellFontColor(c, cell, "#ff0000");										//본문
							if( hasLeftFixColumn ) this.setCellFontColor(c, leftFixCell, "#ff0000");		//좌측고정
							if( hasRightFixColumn ) this.setCellFontColor(c, rightFixCellDiv, "#ff0000");	//우측고정
						}
						
						//표시형식 처리된 데이터
						if( columnInfo.cellType == "combobox" ){
//							caption = this.dataSet.getState(dataIndex, this.columnInfo[k].field + ".TEXT");
							caption = rowData.__STATE__[columnInfo.field + ".TEXT"];
						}
						
						caption = this.getDisplayValueByCellType(c, rowData[columnInfo.field], caption);
					}
					else{
						//표시형식 처리된 데이터
						caption = this.getDisplayValueByCellType(c, columnInfo.defalutValue);
					}
					
					//본문
					this.setCellTooltip(c, cell, caption);					//툴팁 적용
					cellDiv.innerHTML = caption;							//데이터 적용
					//좌측고정
					if( hasLeftFixColumn ){
						this.setCellTooltip(c, leftFixCell, caption);		//툴팁
						leftFixCellDiv.innerHTML = caption;					//데이터 적용
					}
					//시트 우측고정 본문
					if( hasRightFixColumn ){
						this.setCellTooltip(c, rightFixCellDiv, caption);	//툴팁
						rightFixCellDiv.innerHTML = caption;				//데이터 적용
					}
					
					//메모리 해제
					caption = null;
				}
				
				//셀 인덱스 증가
				colIndex++;
				
				//메모리 해제
				hasLeftFixColumn = false; hasRightFixColumn = false;
				alt = null; src = null; caption = null; cellClass = null;
				rightFixCellDiv = null; leftFixCellDiv = null; cellDiv = null;
				rightFixCell = null; leftFixCell = null; cell = null;
			}
			
			//메모리 해제
			headRowItem = null; rightFixCells = null; leftFixCells = null; cells = null;
			sheetRightFixRowCells = null; sheetLeftFixRowCells = null; sheetRowCells = null;
		}
		
		//메모리 해제
		rowData = null;
	}
	
	//메모리 해제
	rightFixRows = null; leftFixRows = null; rows = null;
	
	var mouseOverItem = null;
	var rowItem = null;
	
	//마우스 오버 객체가 있다면 마우스 오버 클래스 적용
	if( this.mouseOverObject != null ){
		//시트 선택 모드가 셀 선택 모드인 경우
		if( this.selectMode == SHEET_SELECT_CELL ){
			mouseOverItem = this.mouseOverObject;
			if( this.hasClass(mouseOverItem, "mouse-over-col") <= 0 )
				this.setCellClass(mouseOverItem, "mouse-over-col", false);
		}
		//시트 선택 모드가 행 선택 모드인 경우
		else if( this.selectMode == SHEET_SELECT_ROW ){
			mouseOverItem = this.mouseOverObject.parentNode;
			if( this.hasClass(mouseOverItem, "mouse-over-row") <= 0 )
				this.setRowClass(mouseOverItem, "mouse-over-row", false);
		}
		//메모리 해제
		mouseOverObejct = null;
	}
	
	//선택된 객체가 있다면 선택 클래스 적용
	if( this.selectedObject != null ){
		//파라메터가 행 인덱스로 동작하므로 selectedRowIndex 값으로 TR객체를 찾아 rowIndex 속성 값을 전달함
		rowItem = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentDiv > table#" + this.controlId + "_SheetContentTable tr[recordindex='" + this.selectedRowIndex + "']");
		if( rowItem != null ) this.setSelectionClass((1 * rowItem.getAttribute("rowIndex")), this.selectedColumnIndex);
		//메모리 해제
		rowItem = null;
	}
	
	//푸터 세팅
	this.setFooter();
	
	//리사이즈
	this.resize(true);
};



EasySheetRenderer.prototype._CreateSheetHeader = function(sheetDiv){
	var sheetHeader = null;
	var sheetHeaderDiv = null;
	var i = 0; var j = 0;
	
	//시트 헤더 div.SheetHeader 생성 및 추가
	sheetHeader = document.createElement("div");
	sheetHeader.setAttribute("class", "SheetHeader");
	sheetHeader.setAttribute("id", this.controlId + "_SheetHeader");
	sheetHeader.setAttribute("name", this.controlId + "_SheetHeader");
	sheetDiv.appendChild(sheetHeader);
	
	//시트 헤더 div.SheetHeader에 cellwidths 속성 추가
	var cellwidths = this.designTable.getAttribute("cellwidths");
	cellwidths = (cellwidths == null || (typeof cellwidths == "string" && cellwidths.length <= 0)) ? "" : cellwidths;
	sheetHeader.setAttribute("cellwidths", cellwidths);
	cellwidths = null;
	//시트 헤더 div.SheetHeader에 cellminwidths 속성 추가
	var cellminwidths = this.designTable.getAttribute("cellminwidths");
	cellminwidths = (cellminwidths == null || (typeof cellminwidths == "string" && cellminwidths.length <= 0)) ? "" : cellminwidths;
	sheetHeader.setAttribute("cellminwidths", cellminwidths);
	cellminwidths = null;
	
	//시트 헤더 div.SheetHeaderDiv 생성 및 추가
	sheetHeaderDiv = document.createElement("div");
	sheetHeaderDiv.setAttribute("class", "SheetHeaderDiv");
	sheetHeaderDiv.setAttribute("id", this.controlId + "_SheetHeaderDiv");
	sheetHeaderDiv.setAttribute("name", this.controlId + "_SheetHeaderDiv");
	sheetHeaderDiv.innerHTML = "<table id=\"" + this.controlId + "_SheetHeaderTable\" name=\"" + this.controlId + "_SheetHeaderTable\"><tbody></tbody></table>";
	sheetHeader.appendChild(sheetHeaderDiv);
	sheetHeaderDiv = null;
	
	var headerTableBody = null;
	var row = null; var cell = null;
	var width = null; var height = null;
	var headerRows = null; var headerRow = null;
	var headerCols = null; var headerCol = null;
	var headerRowCount = 0;
	var addHeaderCount = 0;
	var headerColCount = 0;
	
	//헤더 행 수 구함
	headerRows = this.designTable.querySelectorAll("thead > tr");
	headerRowCount = headerRows.length;
	addHeaderCount = headerRowCount - this.rowsPerDataRow;
	//헤더 행 높이 구함
	headerRow = headerRows[0];
	height = headerRow.style.height;
	headerRow = null;
	
	//해더 행을 추가하기 위한 테이블 객체 구함
	headerTableBody = sheetHeader.querySelector("div.SheetHeaderDiv > table > tbody");
	//시트 추가 헤더 행 및 셀 추가
	for(i = 0; i < addHeaderCount; i++, row = null, headerRow = null, headerCols = null){
		row = document.createElement("tr");
		
		if( height !== "" ) row.style.height = height;
		
		if( i == 0 ){
			cell = document.createElement("th");
			cell.setAttribute("class", "RowHeader");
			cell.rowSpan = headerRowCount;
			cell.style.width = this.sheetRowHeaderWidth + "px";
			cell.style.minWidth = this.sheetRowHeaderWidth + "px";
			cell.innerHTML = "<div style=\"width: " + this.sheetRowHeaderWidth + "px;\"></div>";
			row.appendChild(cell);
			cell = null;
		}
		
		headerRow = headerRows[i];
		headerCols = headerRow.querySelectorAll("td");
		headerColCount = headerCols.length;
		
		for(j = 0; j < headerColCount; j++, headerCol = null, cell = null){
			headerCol = headerCols[j];
			
			cell = document.createElement("td");
			cell.setAttribute("class", "AddColHead");
			cell.rowSpan = headerCol.rowSpan;
			cell.colSpan = headerCol.colSpan;
//			cell.innerHTML = "<div>" + headerCol.innerText + "</div>"
			cell.innerHTML = "<div>" + headerCol.innerHTML + "</div>"
						   + "<div class=\"resizer\"></div>";
			row.appendChild(cell);
		}
		
		headerTableBody.appendChild(row);
	}
	//시트 컬럼 헤더 행 및 셀 추가
	for(i = addHeaderCount; i < headerRowCount; i++, row = null, headerRow = null, headerCols = null){
		row = document.createElement("tr");
		
		if( height !== "" ) row.style.height = height;
		
		if( i == addHeaderCount ){
			cell = document.createElement("th");
			cell.setAttribute("class", "RowHeader");
			cell.rowSpan = this.rowsPerDataRow;
			cell.style.width = this.sheetRowHeaderWidth + "px";
			cell.style.minWidth = this.sheetRowHeaderWidth + "px";
			if( addHeaderCount > 0 ) cell.style.display = "none";
			cell.innerHTML = "<div style=\"width: " + this.sheetRowHeaderWidth + "px;\"></div>";
			row.appendChild(cell);
			cell = null;
		}
		
		headerRow = headerRows[i];
		headerCols = headerRow.querySelectorAll("td");
		headerColCount = headerCols.length;
		
		for(j = 0; j < headerColCount; j++, headerCol = null, width = null, cell = null){
			headerCol = headerCols[j];
			width = headerCol.style.width;
			
			cell = document.createElement("th");
			cell.rowSpan = headerCol.rowSpan;
			cell.colSpan = headerCol.colSpan;
			cell.style.width = width;
			cell.style.minWidth = width;
//			cell.innerHTML = "<div style=\"width: " + width + ";\">" + headerCol.innerText + "</div>"
			cell.innerHTML = "<div style=\"width: " + width + ";\">" + headerCol.innerHTML + "</div>"
						   + "<div class=\"resizer\"></div>";
			row.appendChild(cell);
		}
		
		headerTableBody.appendChild(row);
	}
	//메모리 해제
	headerTableBody = null;
	headerRows = null;
	
	//좌측고정 열 설정하지 않아도 행 타이틀 때문에 좌측고정 열을 생성 해야함
	//시트 헤더 div.SheetHeaderLeftFixDiv 생성 및 추가
	sheetHeaderDiv = document.createElement("div");
	sheetHeaderDiv.setAttribute("class", "SheetHeaderLeftFixDiv");
	sheetHeaderDiv.setAttribute("id", this.controlId + "_SheetHeaderLeftFixDiv");
	sheetHeaderDiv.setAttribute("name", this.controlId + "_SheetHeaderLeftFixDiv");
	sheetHeaderDiv.innerHTML = "<table id=\"" + this.controlId + "_SheetHeaderLeftFixTable\" name=\"" + this.controlId + "_SheetHeaderLeftFixTable\"><tbody></tbody></table>";
	sheetHeader.appendChild(sheetHeaderDiv);
	sheetHeaderDiv = null;
	
	//해더 행을 추가하기 위한 테이블 객체 구함
	headerTableBody = sheetHeader.querySelector("div.SheetHeaderLeftFixDiv > table > tbody");
	//시트 추가 헤더 행 및 셀 추가
	for(i = 0; i < addHeaderCount; i++, row = null){
		row = document.createElement("tr");
		
		if( height !== "" ) row.style.height = height;
		
		if( i == 0 ){
			cell = document.createElement("th");
			cell.setAttribute("class", "RowHeader");
			if( headerRowCount > 1 ) cell.rowSpan = headerRowCount;
			cell.style.width = this.sheetRowHeaderWidth + "px";
			cell.style.minWidth = this.sheetRowHeaderWidth + "px";
			cell.innerHTML = "<div style=\"width: " + this.sheetRowHeaderWidth + "px;\"></div>";
			row.appendChild(cell);
			cell = null;
		}
		
		headerTableBody.appendChild(row);
	}
	//시트 컬럼 헤더 행 및 셀 추가
	for(i = addHeaderCount; i < headerRowCount; i++, row = null){
		row = document.createElement("tr");
		
		if( height !== "" ) row.style.height = height;
		
		if( i == addHeaderCount ){
			cell = document.createElement("th");
			cell.setAttribute("class", "RowHeader");
			if( this.rowsPerDataRow > 1 ) cell.rowSpan = this.rowsPerDataRow;
			cell.style.width = this.sheetRowHeaderWidth + "px";
			cell.style.minWidth = this.sheetRowHeaderWidth + "px";
			if( addHeaderCount > 0 ) cell.style.display = "none";
			cell.innerHTML = "<div style=\"width: " + this.sheetRowHeaderWidth + "px;\"></div>";
			row.appendChild(cell);
			cell = null;
		}
		
		headerTableBody.appendChild(row);
	}
	//메모리 해제
	headerTableBody = null;
	
	//우측고정 열 설정한 경우
	if( this.rightFixColumnCount > 0 ){
		//시트 헤더 div.SheetHeaderRightFixDiv 생성 및 추가
		sheetHeaderDiv = document.createElement("div");
		sheetHeaderDiv.setAttribute("class", "SheetHeaderRightFixDiv");
		sheetHeaderDiv.setAttribute("id", this.controlId + "_SheetHeaderRightFixDiv");
		sheetHeaderDiv.setAttribute("name", this.controlId + "_SheetHeaderRightFixDiv");
		sheetHeaderDiv.innerHTML = "<table id=\"" + this.controlId + "_SheetHeaderRightFixTable\" name=\"" + this.controlId + "_SheetHeaderRightFixTable\"><tbody></tbody></table>";
		sheetHeader.appendChild(sheetHeaderDiv);
		sheetHeaderDiv = null;
		
		//해더 행을 추가하기 위한 테이블 객체 구함
		headerTableBody = sheetHeader.querySelector("div.SheetHeaderRightFixDiv > table > tbody");
		//시트 추가 헤더 행 및 셀 추가
		for(i = 0; i < addHeaderCount; i++, row = null){
			row = document.createElement("tr");
			
			if( height !== "" ) row.style.height = height;
			
			headerTableBody.appendChild(row);
		}
		//시트 컬럼 헤더 행 및 셀 추가
		for(i = addHeaderCount; i < headerRowCount; i++, row = null){
			row = document.createElement("tr");
			
			if( height !== "" ) row.style.height = height;
			
			headerTableBody.appendChild(row);
		}
		//메모리 해제
		headerTableBody = null;
	}
	
	//메모리 해제
	height = null; sheetHeader = null;
};

EasySheetRenderer.prototype._CreateSheetContent = function(sheetDiv){
	var sheetContent = null;
	var sheetContentDiv = null;
	var i = 0; var j = 0; var k = 0;
	
	//시트 본문 div.SheetHeader 생성 및 추가
	sheetContent = document.createElement("div");
	sheetContent.setAttribute("class", "SheetContent");
	sheetContent.setAttribute("id", this.controlId + "_SheetContent");
	sheetContent.setAttribute("name", this.controlId + "_SheetContent");
	sheetDiv.appendChild(sheetContent);
	
	//시트 본문 div.SheetContentDiv 생성 및 추가
	sheetContentDiv = document.createElement("div");
	sheetContentDiv.setAttribute("class", "SheetContentDiv");
	sheetContentDiv.setAttribute("id", this.controlId + "_SheetContentDiv");
	sheetContentDiv.setAttribute("name", this.controlId + "_SheetContentDiv");
	sheetContentDiv.innerHTML = "<table id=\"" + this.controlId + "_SheetContentTable\" name=\"" + this.controlId + "_SheetContentTable\"><tbody></tbody></table>";
	sheetContent.appendChild(sheetContentDiv);
	sheetContentDiv = null;
	
	var contentTableBody = null;
	var row = null; var cell = null;
	var width = null; var height = null;
	var contentRows = null; var contentRow = null;
	var contentCols = null; var contentCol = null;
	var contentRowCount = 0;
	var contentColCount = 0;
	
	//본문 행 수 구함
	contentRows = this.designTable.querySelectorAll("tbody > tr");
//	contentRowCount = contentRows.length;
	contentRowCount = this.rowsPerDataRow;
	//본문 행 높이 구함
	contentRow = contentRows[0];
	height = contentRow.style.height;
	contentRow = null;
	
	//본문 행을 추가하기 위한 테이블 객체 구함
	contentTableBody = sheetContent.querySelector("div.SheetContentDiv > table > tbody");
	//시트 추가 본문 행 및 셀 추가
	for(i = 0, k = 0; i < contentRowCount; i++, row = null, contentRow = null, contentCols = null){
		row = document.createElement("tr");
		row.setAttribute("class", "odd-num-row");
		row.setAttribute("rowindex", "0");
		
		if( height !== "" ) row.style.height = height;
		
		if( i == 0 ){
			cell = document.createElement("td");
			cell.setAttribute("class", "RowHeader");
			cell.rowSpan = contentRowCount;
			cell.style.width = this.sheetRowHeaderWidth + "px";
			cell.style.minWidth = this.sheetRowHeaderWidth + "px";
			cell.innerHTML = "<div style=\"width: " + this.sheetRowHeaderWidth + "px;\">1</div>";
			row.appendChild(cell);
			cell = null;
		}
		
		contentRow = contentRows[i];
		contentCols = contentRow.querySelectorAll("td");
		contentColCount = contentCols.length;
		
		for(j = 0; j < contentColCount; j++, k++, contentCol = null, width = null, cell = null){
			contentCol = contentCols[j];
			width = contentCol.style.width;
			
			cell = document.createElement("td");
			cell.setAttribute("cellindex", "" + k);
			cell.rowSpan = contentCol.rowSpan;
			cell.colSpan = contentCol.colSpan;
			cell.style.width = width;
			cell.style.minWidth = width;
			cell.innerHTML = "<div style=\"width: " + width + ";\"></div>";
			row.appendChild(cell);
		}
		
		contentTableBody.appendChild(row);
	}
	//메모리 해제
	contentTableBody = null;
	contentRows = null;
	
	//좌측고정 열 설정하지 않아도 행 타이틀 때문에 좌측고정 열을 생성 해야함
	//시트 본문 div.SheetHeaderLeftFixDiv 생성 및 추가
	sheetContentDiv = document.createElement("div");
	sheetContentDiv.setAttribute("class", "SheetContentLeftFixDiv");
	sheetContentDiv.setAttribute("id", this.controlId + "_SheetContentLeftFixDiv");
	sheetContentDiv.setAttribute("name", this.controlId + "_SheetContentLeftFixDiv");
	sheetContentDiv.innerHTML = "<table id=\"" + this.controlId + "_SheetContentLeftFixTable\" name=\"" + this.controlId + "_SheetContentLeftFixTable\"><tbody></tbody></table>";
	sheetContent.appendChild(sheetContentDiv);
	sheetContentDiv = null;
	
	//본문 행을 추가하기 위한 테이블 객체 구함
	contentTableBody = sheetContent.querySelector("div.SheetContentLeftFixDiv > table > tbody");
	//시트 컬럼 본문 행 및 셀 추가
	for(i = 0; i < contentRowCount; i++, row = null){
		row = document.createElement("tr");
		row.setAttribute("class", "odd-num-row");
		row.setAttribute("rowindex", "0");
		
		if( height !== "" ) row.style.height = height;
		
		if( i == 0 ){
			cell = document.createElement("td");
			cell.setAttribute("class", "RowHeader");
			cell.rowSpan = contentRowCount;
			cell.style.width = this.sheetRowHeaderWidth + "px";
			cell.style.minWidth = this.sheetRowHeaderWidth + "px";
			cell.innerHTML = "<div style=\"width: " + this.sheetRowHeaderWidth + "px;\">1</div>";
			row.appendChild(cell);
			cell = null;
		}
		
		contentTableBody.appendChild(row);
	}
	//메모리 해제
	contentTableBody = null;
	
	//우측고정 열 설정한 경우
	if( this.rightFixColumnCount > 0 ){
		//시트 본문 div.SheetHeaderLeftFixDiv 생성 및 추가
		sheetContentDiv = document.createElement("div");
		sheetContentDiv.setAttribute("class", "SheetContentRightFixDiv");
		sheetContentDiv.setAttribute("id", this.controlId + "_SheetContentRightFixDiv");
		sheetContentDiv.setAttribute("name", this.controlId + "_SheetContentRightFixDiv");
		sheetContentDiv.innerHTML = "<table id=\"" + this.controlId + "_SheetContentRightFixTable\" name=\"" + this.controlId + "_SheetContentRightFixTable\"><tbody></tbody></table>";
		sheetContent.appendChild(sheetContentDiv);
		sheetContentDiv = null;
		
		//본문 행을 추가하기 위한 테이블 객체 구함
		contentTableBody = sheetContent.querySelector("div.SheetContentRightFixDiv > table > tbody");
		//시트 컬럼 본문 행 및 셀 추가
		for(i = 0; i < contentRowCount; i++, row = null){
			row = document.createElement("tr");
			row.setAttribute("class", "odd-num-row");
			row.setAttribute("rowindex", "0");
			
			if( height !== "" ) row.style.height = height;
			
			contentTableBody.appendChild(row);
		}
		//메모리 해제
		contentTableBody = null;
	}
	
	//메모리 해제
	height = null; sheetContent = null;
};

EasySheetRenderer.prototype._CreateSheetFooter = function(sheetDiv){
	var sheetFooter = null;
	var sheetFooterDiv = null;
	var i = 0; var j = 0; var k = 0;
	
	//시트 푸터 div.sheetFooter 생성 및 추가
	sheetFooter = document.createElement("div");
	sheetFooter.setAttribute("class", "SheetFooter");
	sheetFooter.setAttribute("id", this.controlId + "_SheetFooter");
	sheetFooter.setAttribute("name", this.controlId + "_SheetFooter");
	sheetDiv.appendChild(sheetFooter);
	
	//시트 푸터 div.SheetFooterDiv 생성 및 추가
	sheetFooterDiv = document.createElement("div");
	sheetFooterDiv.setAttribute("class", "SheetFooterDiv");
	sheetFooterDiv.setAttribute("id", this.controlId + "_SheetFooterDiv");
	sheetFooterDiv.setAttribute("name", this.controlId + "_SheetFooterDiv");
	sheetFooterDiv.innerHTML = "<table id=\"" + this.controlId + "_SheetFooterTable\" name=\"" + this.controlId + "_SheetFooterTable\"><tbody></tbody></table>";
	sheetFooter.appendChild(sheetFooterDiv);
	sheetFooterDiv = null;
	
	var footerTableBody = null;
	var row = null; var cell = null;
	var width = null; var height = null;
	var footerRows = null; var footerRow = null;
	var footerCols = null; var footerCol = null;
	var footerRowCount = 0;
	var footerColCount = 0;
	
	//본문 행 수 구함
	footerRows = this.designTable.querySelectorAll("tfoot > tr");
	footerRowCount = this.rowsPerDataRow;
	//본문 행 높이 구함
	footerRow = footerRows[0];
	height = footerRow.style.height;
	footerRow = null;
	
	//본문 행을 추가하기 위한 테이블 객체 구함
	footerTableBody = sheetFooter.querySelector("div.SheetFooterDiv > table > tbody");
	//시트 추가 본문 행 및 셀 추가
	for(i = 0, k = 0; i < footerRowCount; i++, row = null, footerRow = null, footerCols = null){
		row = document.createElement("tr");
		row.setAttribute("class", "odd-num-row");
		row.setAttribute("rowindex", "0");
		
		if( height !== "" ) row.style.height = height;
		
		if( i == 0 ){
			cell = document.createElement("td");
			cell.setAttribute("class", "RowHeader");
			cell.rowSpan = footerRowCount;
			cell.style.width = this.sheetRowHeaderWidth + "px";
			cell.style.minWidth = this.sheetRowHeaderWidth + "px";
			cell.innerHTML = "<div style=\"width: " + this.sheetRowHeaderWidth + "px;\">1</div>";
			row.appendChild(cell);
			cell = null;
		}
		
		footerRow = footerRows[i];
		footerCols = footerRow.querySelectorAll("td");
		footerColCount = footerCols.length;
		
		for(j = 0; j < footerColCount; j++, k++, footerCol = null, width = null, cell = null){
			footerCol = footerCols[j];
			width = footerCol.style.width;
			
			cell = document.createElement("td");
			cell.setAttribute("cellindex", "" + k);
			cell.rowSpan = footerCol.rowSpan;
			cell.colSpan = footerCol.colSpan;
			cell.style.width = width;
			cell.style.minWidth = width;
			cell.innerHTML = "<div style=\"width: " + width + ";\"></div>";
			row.appendChild(cell);
		}
		
		footerTableBody.appendChild(row);
	}
	//메모리 해제
	footerTableBody = null;
	footerRows = null;
	
	//좌측고정 열 설정하지 않아도 행 타이틀 때문에 좌측고정 열을 생성 해야함
	//시트 본문 div.SheetHeaderLeftFixDiv 생성 및 추가
	sheetFooterDiv = document.createElement("div");
	sheetFooterDiv.setAttribute("class", "SheetFooterLeftFixDiv");
	sheetFooterDiv.setAttribute("id", this.controlId + "_SheetFooterLeftFixDiv");
	sheetFooterDiv.setAttribute("name", this.controlId + "_SheetFooterLeftFixDiv");
	sheetFooterDiv.innerHTML = "<table id=\"" + this.controlId + "_SheetFooterLeftFixTable\" name=\"" + this.controlId + "_SheetFooterLeftFixTable\"><tbody></tbody></table>";
	sheetFooter.appendChild(sheetFooterDiv);
	sheetFooterDiv = null;
	
	//본문 행을 추가하기 위한 테이블 객체 구함
	footerTableBody = sheetFooter.querySelector("div.SheetFooterLeftFixDiv > table > tbody");
	//시트 컬럼 본문 행 및 셀 추가
	for(i = 0; i < footerRowCount; i++, row = null){
		row = document.createElement("tr");
		row.setAttribute("class", "odd-num-row");
		row.setAttribute("rowindex", "0");
		
		if( height !== "" ) row.style.height = height;
		
		if( i == 0 ){
			cell = document.createElement("td");
			cell.setAttribute("class", "RowHeader");
			cell.rowSpan = footerRowCount;
			cell.style.width = this.sheetRowHeaderWidth + "px";
			cell.style.minWidth = this.sheetRowHeaderWidth + "px";
			cell.innerHTML = "<div style=\"width: " + this.sheetRowHeaderWidth + "px;\"></div>";
			row.appendChild(cell);
			cell = null;
		}
		
		footerTableBody.appendChild(row);
	}
	//메모리 해제
	footerTableBody = null;
	
	//우측고정 열 설정한 경우
	if( this.rightFixColumnCount > 0 ){
		//시트 본문 div.SheetHeaderLeftFixDiv 생성 및 추가
		sheetFooterDiv = document.createElement("div");
		sheetFooterDiv.setAttribute("class", "SheetFooterRightFixDiv");
		sheetFooterDiv.setAttribute("id", this.controlId + "_SheetFooterRightFixDiv");
		sheetFooterDiv.setAttribute("name", this.controlId + "_SheetFooterRightFixDiv");
		sheetFooterDiv.innerHTML = "<table id=\"" + this.controlId + "_SheetFooterRightFixTable\" name=\"" + this.controlId + "_SheetFooterRightFixTable\"><tbody></tbody></table>";
		sheetFooter.appendChild(sheetFooterDiv);
		sheetFooterDiv = null;
		
		//본문 행을 추가하기 위한 테이블 객체 구함
		footerTableBody = sheetFooter.querySelector("div.SheetFooterRightFixDiv > table > tbody");
		//시트 컬럼 본문 행 및 셀 추가
		for(i = 0; i < footerRowCount; i++, row = null){
			row = document.createElement("tr");
			row.setAttribute("class", "odd-num-row");
			row.setAttribute("rowindex", "0");
			
			if( height !== "" ) row.style.height = height;
			
			footerTableBody.appendChild(row);
		}
		//메모리 해제
		footerTableBody = null;
	}
	
	//메모리 해제
	height = null; sheetFooter = null;
};

EasySheetRenderer.prototype._CreateSheetScroll = function(sheetDiv){
	var scrollDiv = null;
	var scrollHtml = null;
	var controlId = this.controlId;
	
	//수직 스크롤 내부 html 생성
	scrollHtml =  '<div class="SheetVScrollHeader" id="' + controlId + '_SheetVScrollHeader" name="' + controlId + '_SheetVScrollHeader"></div>';
	scrollHtml += '<div class="SheetVScrollBody" id="' + controlId + '_SheetVScrollBody" name="' + controlId + '_SheetVScrollBody">';
	scrollHtml += '	<div class="SheetVScrollUpArrow" id="' + controlId + '_SheetVScrollUpArrow" name="' + controlId + '_SheetVScrollUpArrow">';
	scrollHtml += '		<span> &#xe86d </span>';
	scrollHtml += '	</div>';
	scrollHtml += '	<div class="SheetVScrollTrack" id="' + controlId + '_SheetVScrollTrack" name="' + controlId + '_SheetVScrollTrack">';
	scrollHtml += '		<div class="SheetVScrollFace" id="' + controlId + '_SheetVScrollFace" name="' + controlId + '_SheetVScrollFace"></div>';
	scrollHtml += '	</div>';
	scrollHtml += '	<div class="SheetVScrollDownArrow" id="' + controlId + '_SheetVScrollDownArrow" name="' + controlId + '_SheetVScrollDownArrow">';
	scrollHtml += '		<span> &#xe86c </span>';
	scrollHtml += '	</div>';
	scrollHtml += '</div>';
	//수직 스크롤 생성 및 추가
	scrollDiv = document.createElement("div");
	scrollDiv.setAttribute("class", "SheetVScroll");
	scrollDiv.setAttribute("id", controlId + "_SheetVScroll");
	scrollDiv.setAttribute("name", controlId + "_SheetVScroll");
	scrollDiv.innerHTML = scrollHtml;
	sheetDiv.appendChild(scrollDiv);
	//메모리 해제
	scrollDiv = null;
	scrollHtml = null;
	
	//수평 스크롤 내부 html 생성
	scrollHtml =  '<div class="SheetHScrollLeftArrow" id="' + controlId + '_SheetHScrollLeftArrow" name="' + controlId + '_SheetHScrollLeftArrow">';
	scrollHtml += '	<span> &#xe86e </span>';
	scrollHtml += '</div>';
	scrollHtml += '<div class="SheetHScrollTrack" id="' + controlId + '_SheetHScrollTrack" name="' + controlId + '_SheetHScrollTrack">';
	scrollHtml += '	<div class="SheetHScrollFace" id="' + controlId + '_SheetHScrollFace" name="' + controlId + '_SheetHScrollFace"></div>';
	scrollHtml += '</div>';
	scrollHtml += '<div class="SheetHScrollRightArrow" id="' + controlId + '_SheetHScrollRightArrow" name="' + controlId + '_SheetHScrollRightArrow">';
	scrollHtml += '	<span> &#xe86f </span>';
	scrollHtml += '</div>';
	//수직 스크롤 생성 및 추가
	scrollDiv = document.createElement("div");
	scrollDiv.setAttribute("class", "SheetHScroll");
	scrollDiv.setAttribute("id", controlId + "_SheetHScroll");
	scrollDiv.setAttribute("name", controlId + "_SheetHScroll");
	scrollDiv.innerHTML = scrollHtml;
	sheetDiv.appendChild(scrollDiv);
	//메모리 해제
	scrollDiv = null;
	scrollHtml = null;
	controlId = null;
};

EasySheetRenderer.prototype._CreateSheetEditControl = function(tagObject){
	var controlId = this.controlId;
	var div = null;
	
	//시트 편집 컨트롤과 위치 교환된 컨트롤 보관
	div = document.createElement("div");
	div.setAttribute("class", "SheetControlTempDiv");
	div.setAttribute("id", controlId + "_SheetControlTempDiv");
	div.setAttribute("name", controlId + "_SheetControlTempDiv");
	div.style.display = "none";
	tagObject.appendChild(div);
	div = null;
	
	//시트 편집 텍스트박스
	div = document.createElement("div");
	div.setAttribute("class", "SheetEidtTextDiv SelectedCell");
	div.setAttribute("id", controlId + "_SheetEidtTextDiv");
	div.setAttribute("name", controlId + "_SheetEidtTextDiv");
	div.innerHTML = '<input type="text" id="' + controlId + '_SheetEidtTextbox" name="' + controlId + '_SheetEidtTextbox" class="SheetEidtTextbox" value="">';
	tagObject.appendChild(div);
	div = null;
	
	//시트 편집 체크박스
	div = document.createElement("div");
	div.setAttribute("class", "SheetEidtCheckDiv SelectedCell");
	div.setAttribute("id", controlId + "_SheetEidtCheckDiv");
	div.setAttribute("name", controlId + "_SheetEidtCheckDiv");
	div.setAttribute("tabindex", "1");
	tagObject.appendChild(div);
	div = null;
	
	//시트 편집 콤보박스
	div = document.createElement("div");
	div.setAttribute("class", "SheetEidtComboDiv SelectedCell");
	div.setAttribute("id", controlId + "_SheetEidtComboDiv");
	div.setAttribute("name", controlId + "_SheetEidtComboDiv");
	div.style.display = "none";
	div.innerHTML = '<select id="' + controlId + '1_SheetEidtCombobox" name="' + controlId + '_SheetEidtCombobox" class="SheetEidtCombobox"></select>';
	tagObject.appendChild(div);
	div = null;
	
	//시트 편집 일자(날짜) 텍스트박스
	div = document.createElement("div");
	div.setAttribute("class", "SheetEidtDateDiv SelectedCell");
	div.setAttribute("id", controlId + "_SheetEidtDateDiv");
	div.setAttribute("name", controlId + "_SheetEidtDateDiv");
	div.style.display = "none";
	div.innerHTML = '<input type="text" id="' + controlId + '_SheetEidtSheetEidtDateInput" name="' + controlId + '_SheetEidtDateInput" class="SheetEidtDateInput" value="">'
				  + '<div id="' + controlId + '_SheetEidtDateCalender" name="' + controlId + '_SheetEidtDateCalender" class="SheetEidtDateCalender"> &#xf4c5 </div>';
	tagObject.appendChild(div);
	div = null;
	
	//시트 이미지 셀 확대 이미지
	div = document.createElement("div");
	div.setAttribute("class", "SheetZoomImgeBox");
	div.setAttribute("id", controlId + "_SheetZoomImgeBox");
	div.setAttribute("name", controlId + "_SheetZoomImgeBox");
	div.innerHTML = '<img src="">';
	tagObject.appendChild(div);
	div = null;
	
	//에러 알림 메시지박스
	div = document.createElement("div");
	div.setAttribute("class", "SheetMsgBox");
	div.setAttribute("id", controlId + "_SheetMsgBox");
	div.setAttribute("name", controlId + "_SheetMsgBox");
	tagObject.appendChild(div);
	div = null;
	
	//리사이저 수직 선
	div = document.createElement("div");
	div.setAttribute("class", "SheetResizerLine");
	div.setAttribute("id", controlId + "_SheetResizerLine");
	div.setAttribute("name", controlId + "_SheetResizerLine");
	tagObject.appendChild(div);
	div = null;
	
	//시트 동작가능 패널
	div = document.createElement("div");
	div.setAttribute("class", "SheetDisabledPanel");
	tagObject.appendChild(div);
	div = null;
};

EasySheetRenderer.prototype._ResetSheet = function(tagObject){
	//예외처리
	if( typeof tagObject == "undefined" || tagObject == null ) return false;
	
	//예외처리
	var table = document.querySelector("div#" + this.controlId + ".EasyDataSheet > table");
	if( table == null ) return false;
	
	//시트 디자인용 테이블 설정
//	this.designTable = tagObject.querySelector("table");
	this.designTable = table;
	//디자인용 테이블 제거
	tagObject.removeChild(this.designTable);
	
	//시트 푸터 보이기 여부
	var showFooter = tagObject.getAttribute("showFooter");
	//시트 Div 생성
	var sheetDiv = document.createElement("div");
	sheetDiv.setAttribute("class", "SheetDiv");
	sheetDiv.setAttribute("id", this.controlId + "_SheetDiv");
	sheetDiv.setAttribute("name", this.controlId + "_SheetDiv");
	
	//헤더 생성 및 추가
	this._CreateSheetHeader(sheetDiv);
	
	//본문 생성 및 추가
	this._CreateSheetContent(sheetDiv);
	
	//푸터 생성 및 추가
	if( showFooter === "true" )
		this._CreateSheetFooter(sheetDiv);
	
	//스크롤 생성 및 추가
	this._CreateSheetScroll(sheetDiv);
	
	//위 생성한 헤더, 본문, 스크롤을 시트에 추가
	tagObject.appendChild(sheetDiv);
	
	//편집컨트롤 생성 및 추가
	this._CreateSheetEditControl(tagObject);
	
	var cellCount = 0;
	var i = 0;
	
	//줄타이틀 안보이기 설정
	var hideRowHeader = tagObject.getAttribute("hiderowheader");
	if( hideRowHeader === "true" ){
		var rowHeaderCells = tagObject.querySelectorAll("th.RowHeader,td.RowHeader");
		//행 타이틀 숨김
		for(i = 0, cellCount = rowHeaderCells.length; i < cellCount; i++) rowHeaderCells[i].style.display = "none";
		//메모리 해제
		rowHeaderCells = null;
	}
	hideRowHeader = null;
	
	//줄타이틀 안보이기, 열타이틀 높이 설정
	var hideColHeader = tagObject.getAttribute("hidecolheader");
	var headers = this.designTable.querySelectorAll("thead > tr");
	var rowHeight = (1 * (headers[0]).style.height.replace("px", ""));
	var headerHeight = (hideColHeader === "true") ? (headers.length - this.rowsPerDataRow) * rowHeight : headers.length * rowHeight;
	var divObj = null;
	//헤더 height 설정
	divObj = tagObject.querySelector("div.SheetHeader");
	divObj.style.height = headerHeight + "px";
	divObj = null;
	//수직 스크롤 헤더 height 설정
	divObj = tagObject.querySelector("div.SheetVScroll > div.SheetVScrollHeader");
	divObj.style.height = headerHeight + "px";
	divObj = null;
	//수직 스크롤 바디 top 설정 
	divObj = tagObject.querySelector("div.SheetVScroll > div.SheetVScrollBody");
	divObj.style.top = headerHeight + "px";
	divObj = null;
	//시트 본문 marginTop, height 설정
	divObj = tagObject.querySelector("div.SheetContent");
	divObj.style.marginTop = headerHeight + "px";
	divObj.style.height = "calc(100% - " + headerHeight + "px)";
	divObj = null;
	//메모리 해제
	headers = null;
	hideColHeader = null;
	
	//
	if( showFooter === "true" ){
		var footers = this.designTable.querySelectorAll("tfoot > tr");
		var footerHeight = this.rowsPerDataRow * (1 * (footers[0]).style.height.replace("px", ""));
		//시트 푸터 height 설정
		divObj = tagObject.querySelector("div.SheetContent");
		divObj.style.height = "calc(100% - " + headerHeight + "px - " + footerHeight + "px)";
		divObj = null;
		//시트 푸터 height 설정
		divObj = tagObject.querySelector("div.SheetFooter");
		divObj.style.height = footerHeight + "px";
		divObj = null;
		//메모리 해제
		footers = null;
	}
	
	//메모리 해제
	sheetDiv = null;
	showFooter = null;
	table = null;
	
	return true;
};

EasySheetRenderer.prototype._InitializeHeaderInfo = function(sheetHeaderRows){
	var rowCount = sheetHeaderRows.length;
	var colCount = 0;
	
	//예외처리
	if( rowCount <= 0 ) return false;
	
	var headerRow = null;
	var headerCols = null; var headerCol = null;
	var attr = null; var title = null;
	var rowItem = null; var colItem = null;
	var rowspan = 0; var colspan = 0;
	var cellIndex = 0; var columnIndex = 0; var cellCount = 0;
	var headerStartIndex = 0;
	var i = 0; var j = 0;
	var r = 0; var c = 0;
	var m = 0; var n = 0;
	
	if( this.colsPerRow <= 1 ){
		headerRow = sheetHeaderRows[0];
		headerCols = headerRow.querySelectorAll("th,td");
		
		this.colsPerRow = 0;
		
		for(i = 0, colCount = headerCols.length; i < colCount; i++, headerCol = null){
			headerCol = headerCols[i];
			if( headerCol.className.indexOf("RowHeader") >= 0 ) continue;
			this.colsPerRow += (1 * headerCol.colSpan);
		}
		
		headerCols = null; headerRow = null;
	}
	
	//헤더정보 생성
	for(i = 0; i < rowCount; i++, rowItem = null){
		//행 배열 생성
		rowItem = this.headerInfo[i] = [];
		rowItem["cellCount"] = 0;
		//열 배열 생성
		for(j = 0; j < this.colsPerRow; j++)
			rowItem[j] = {rowIndex: i, cellIndex: j, colspan: 1, colspanMax: 1, rowspan: 1, rowspanMax: 1, cells: {}, childIndexs: null};
	}
	
	headerStartIndex = rowCount - this.rowsPerDataRow;
	
	//헤더정보 세팅
	for(i = 0; i < rowCount; i++){
		headerRow = sheetHeaderRows[i];
		headerCols = headerRow.querySelectorAll("th,td");
		
		//행의 열 개수 카운트
		for(j = 0, cellIndex = 0, colCount = headerCols.length; j < colCount; j++, title = null, headerCol = null){
			headerCol = headerCols[j];
			
			if( headerCol.className.indexOf("RowHeader") >= 0 ) continue;
			
			if( headerCol.querySelector("div") != null )
				 title = headerCol.querySelector("div").innerHTML.replace(/(^\s*)|(\s*$)/g, "");
			else title = headerCol.innerHTML.replace(/(^\s*)|(\s*$)/g, "");
			
			attr = headerCol.rowSpan;
			rowspan = ((attr == null) ? 1 : 1 * attr);
			attr = null;
			attr = headerCol.colSpan;
			colspan = ((attr == null) ? 1 : 1 * attr);
			attr = null;
			
			for(m = 0, r = i; m < rowspan && r < rowCount; m++, r++, rowItem = null){
				rowItem = this.headerInfo[r];
				
				for(n = 0, c = cellIndex; n < colspan && cellIndex < this.colsPerRow; n++, c++, colItem = null){
					colItem = rowItem[c];
					
					if( colItem.colspanMax < 0 ){
						n--; continue;
					}
					
					if( i >= headerStartIndex ){
						colItem.rowIndex = i - headerStartIndex;
						colItem.cellIndex = columnIndex;
					}
					
					if( r == i && n == 0 ){
						colItem["title"] = title;
						colItem.colspan = colItem.colspanMax = colspan;
						colItem.rowspan = colItem.rowspanMax = rowspan;
						colItem.cells["header"] = headerCol;
						cellIndex = c;
					}
					else{
						colItem.colspan = colItem.colspanMax = -1;
						colItem.rowspan = colItem.rowspanMax = rowspan;
						colItem.cells = null;
					}
				}
			}
			
			//
			if( i >= headerStartIndex ){
				columnIndex++;
				cellCount++;
			}
			//
			cellIndex = c;
		}
		
		//
		if( i >= headerStartIndex ) this.headerInfo[i].cellCount = cellCount;
		
		//메모리 해제
		headerCols = null, headerRow = null;
	}
	
	return true;
};

EasySheetRenderer.prototype._CreateLeftFixColumns = function(){
	var rows = null; var row = null;
	var cells = null; var cell = null;
	var leftFixRows = null; var leftFixRow = null;
	var headerInfos = null; var headerInfo = null;
	var rowCount = 0; var colCount = 0; var isCreated = false;
	var headerRowCount = 0; var headerStartIndex = 0;
	var i = 0; var j = 0; var c = 0;
	
	//좌측고정 헤더 생성
	rows = this.SheetHeaderObject.querySelectorAll("div.SheetHeaderDiv tr");
	leftFixRows = this.SheetHeaderObject.querySelectorAll("div.SheetHeaderLeftFixDiv tr");
	rowCount = leftFixRows.length;
	
	if( this.leftFixColumnCount <= 0 && rowCount > 0 ){
		leftFixRow = leftFixRows[0];
		cells = leftFixRow.querySelectorAll("th,td");
		colCount = cells.length;
		
		for(i = 0; i < colCount; i++, cell = null){
			cell = cells[i];
			if( cell.className.indexOf("RowHeader") >= 0 ) continue;
			this.leftFixColumnCount += (1 * cell.colSpan);
		}
		
		//이미 셀 태그가 생성되어 있는지 체크
		isCreated = (this.leftFixColumnCount > 0 && colCount > 0);
		
		//메모리 해제
		cells = null; leftFixRow = null;
	}
	
	if( this.leftFixColumnCount <= 0 ){
		//메모리 해제
		leftFixRows = null; rows = null;
		return;
	}
	
	//만약 이미 헤더 셀 태그가 생성되어 있다면 제거함
	if( isCreated ){
		for(i = 0; i < rowCount; i++, leftFixRow = null, cells = null){
			leftFixRow = leftFixRows[i];
			cells = leftFixRow.querySelectorAll("th,td");
			
			for(j = cells.length - 1; j >= 0; j--, cell = null){
				cell = cells[j];
				if( cell.className.indexOf("RowHeader") >= 0 ) continue;
				cell.parentNode.removeChild(cell);
			}
		}
	}
	
	for(i = 0, headerRowCount = rowCount; i < rowCount; i++){
		row = rows[i];
		leftFixRow = leftFixRows[i];
		cells = row.querySelectorAll("th,td");
		headerInfos = this.headerInfo[i];
		
		//
		if( cells.length > 0 ){
			c = (cells[0].className.indexOf("RowHeader") >= 0) ? 1 : 0;
			colCount = cells.length;
			
			for(j = 0; j < this.colsPerRow && j < this.leftFixColumnCount && c < colCount; j++, headerInfo = null){
				headerInfo = headerInfos[j];
				
				//colspan이 0보다 작은 경우 병합된 셀이므로 셀 추가하지 않음
				if( headerInfo.colspan < 0 ) continue;
				
				//좌측고정 헤더 셀 추가 및 셀 인덱스 증가
				cell = cells[c++].cloneNode(true);
				leftFixRow.appendChild(cell);
				headerInfo.cells["leftfix"] = cell;
				cell = null;
			}
		}
		
		//메모리 해제
		headerInfos = null; cells = null;
		leftFixRow = null; row = null;
	}
	
	//메모리 해제
	leftFixRows = null;
	rows = null;
	
	rows = this.SheetContentObject.querySelectorAll("div.SheetContentDiv tr");
	leftFixRows = this.SheetContentObject.querySelectorAll("div.SheetContentLeftFixDiv tr");
	rowCount = leftFixRows.length;
	headerStartIndex = headerRowCount - this.rowsPerDataRow;
	
	//만약 이미 본문 셀 태그가 생성되어 있다면 제거함
	if( isCreated ){
		for(i = 0; i < rowCount; i++, leftFixRow = null, cells = null){
			leftFixRow = leftFixRows[i];
			cells = leftFixRow.querySelectorAll("th,td");
			
			for(j = cells.length - 1; j >= 0; j--, cell = null){
				cell = cells[j];
				if( cell.className.indexOf("RowHeader") >= 0 ) continue;
				cell.parentNode.removeChild(cell);
			}
		}
	}
	
	//좌측고정 본문 생성
	for(i = 0; i < rowCount; i++){
		row = rows[i];
		leftFixRow = leftFixRows[i];
		cells = row.querySelectorAll("th,td");
		headerInfos = this.headerInfo[headerStartIndex + i];
		
		c = (cells[0].className.indexOf("RowHeader") >= 0) ? 1 : 0;
		colCount = cells.length;
		
		for(j = 0; j < this.colsPerRow && j < this.leftFixColumnCount && c < colCount; j++, headerInfo = null){
			headerInfo = headerInfos[j];
			
			//colspan이 0보다 작은 경우 병합된 셀이므로 셀 추가하지 않음
			if( headerInfo.colspan < 0 ) continue;
			
			//좌측고정 헤더 셀 추가 및 셀 인덱스 증가
			leftFixRow.appendChild(cells[c++].cloneNode(true));
		}
		
		//메모리 해제
		headerInfos = null; cells = null;
		leftFixRow = null; row = null;
	}
	
	//메모리 해제
	leftFixRows = null;
	rows = null;
	
	//좌측고정 푸터 생성
	if( this.isShowFooter ){
		rows = this.SheetFooterObject.querySelectorAll("div.SheetFooterDiv tr");
		leftFixRows = this.SheetFooterObject.querySelectorAll("div.SheetFooterLeftFixDiv tr");
		rowCount = leftFixRows.length;
		headerStartIndex = headerRowCount - this.rowsPerDataRow;
		
		for(i = 0; i < rowCount; i++){
			row = rows[i];
			leftFixRow = leftFixRows[i];
			cells = row.querySelectorAll("th,td");
			headerInfos = this.headerInfo[headerStartIndex + i];
			
			c = (cells[0].className.indexOf("RowHeader") >= 0) ? 1 : 0;
			colCount = cells.length;
			
			for(j = 0; j < this.colsPerRow && j < this.leftFixColumnCount && c < colCount; j++, headerInfo = null){
				headerInfo = headerInfos[j];
				
				//colspan이 0보다 작은 경우 병합된 셀이므로 셀 추가하지 않음
				if( headerInfo.colspan < 0 ) continue;
				
				//좌측고정 헤더 셀 추가 및 셀 인덱스 증가
				leftFixRow.appendChild(cells[c++].cloneNode(true));
			}
			
			//메모리 해제
			headerInfos = null; cells = null;
			leftFixRow = null; row = null;
		}
		
		//메모리 해제
		leftFixRows = null;
		rows = null;
	}
};

EasySheetRenderer.prototype._CreateRightFixColumns = function(){
	var rows = null; var row = null;
	var cells = null; var cell = null;
	var rightFixRows = null; var rightFixRow = null;
	var headerInfos = null; var headerInfo = null;
	var rowCount = 0; var colCount = 0; var isCreated = false;
	var headerRowCount = 0; var headerStartIndex = 0;
	var i = 0; var j = 0; var c = 0; var c1 = 0; var colIndex = 0;
	
	//우측고정 헤더 생성
	rows = this.SheetHeaderObject.querySelectorAll("div.SheetHeaderDiv tr");
	rightFixRows = this.SheetHeaderObject.querySelectorAll("div.SheetHeaderRightFixDiv tr");
	rowCount = rightFixRows.length;
	
	if( this.rightFixColumnCount <= 0 && rowCount > 0 ){
		rightFixRow = rightFixRows[0];
		cells = rightFixRow.querySelectorAll("th,td");
		
		for(i = 0, colCount = cells.length; i < colCount; i++)
			this.rightFixColumnCount += (1 * cells[i].colSpan);
		
		//이미 셀 태그가 생성되어 있는지 체크
		isCreated = (this.rightFixColumnCount > 0 && colCount > 0);
		
		//메모리 해제
		cells = null; rightFixRow = null;
	}
	
	if( this.rightFixColumnCount <= 0 ){
		//메모리 해제
		rightFixRows = null; rows = null;
		return;
	}
	
	//만약 이미 헤더 셀 태그가 생성되어 있다면 제거함
	if( isCreated ){
		for(i = 0; i < rowCount; i++, rightFixRow = null, cells = null){
			rightFixRow = rightFixRows[i];
			cells = rightFixRow.querySelectorAll("th,td");
			
			for(j = cells.length - 1; j >= 0; j--, cell = null){
				cell = cells[j];
				cell.parentNode.removeChild(cell);
			}
		}
	}
	
	for(i = 0, headerRowCount = rowCount = rightFixRows.length; i < rowCount; i++){
		row = rows[i];
		rightFixRow = rightFixRows[i];
		cells = row.querySelectorAll("th,td");
		headerInfos = this.headerInfo[i];
		
		colCount = cells.length;
		colIndex = (cells[0].getAttribute("class") == "RowHeader") ? 1 : 0;
		j = this.colsPerRow - this.rightFixColumnCount;
		
		for(c = c1 = 0; j < this.colsPerRow && c < this.rightFixColumnCount; j++, c++, headerInfo = null){
			headerInfo = headerInfos[j];
			
			//colspan이 0보다 작은 경우 병합된 셀이므로 셀 추가하지 않음
			if( headerInfo.colspan < 0 ) continue;
			//셀 인덱스 구함
			for( ; c1 < j; c1++){
				if( headerInfos[c1].colspan > 0 ) colIndex++;
			}
			//셀 인덱스가  셀 개수보다 큰 경우
			if( colIndex >= colCount ){
				headerInfo = null; break;
			}
			
			//좌측고정 헤더 셀 추가 및 셀 인덱스 증가
			cell = cells[colIndex].cloneNode(true);
			rightFixRow.appendChild(cell);
			headerInfo.cells["rightfix"] = cell;
			cell = null;
		}
		
		//메모리 해제
		headerInfos = null; cells = null;
		rightFixRow = null; row = null;
	}
	
	//메모리 해제
	rightFixRows = null;
	rows = null;
	
	rows = this.SheetContentObject.querySelectorAll("div.SheetContentDiv tr");
	rightFixRows = this.SheetContentObject.querySelectorAll("div.SheetContentRightFixDiv tr");
	rowCount = rightFixRows.length;
	headerStartIndex = headerRowCount - this.rowsPerDataRow;
	
	//우측고정 본문 생성
	//만약 이미 헤더 셀 태그가 생성되어 있다면 제거함
	if( isCreated ){
		for(i = 0; i < rowCount; i++, rightFixRow = null, cells = null){
			rightFixRow = rightFixRows[i];
			cells = rightFixRow.querySelectorAll("th,td");
			
			for(j = cells.length - 1; j >= 0; j--, cell = null){
				cell = cells[j];
				cell.parentNode.removeChild(cell);
			}
		}
	}
	
	for(i = 0; i < rowCount; i++){
		row = rows[i];
		rightFixRow = rightFixRows[i];
		cells = row.querySelectorAll("th,td");
		headerInfos = this.headerInfo[headerStartIndex + i];
		
		colCount = cells.length;
		colIndex = (cells[0].getAttribute("class") == "RowHeader") ? 1 : 0;
		j = this.colsPerRow - this.rightFixColumnCount;
		
		for(c = c1 = 0; j < this.colsPerRow && c < this.rightFixColumnCount; j++, c++, headerInfo = null){
			headerInfo = headerInfos[j];
			
			//colspan이 0보다 작은 경우 병합된 셀이므로 셀 추가하지 않음
			if( headerInfo.colspan < 0 ) continue;
			//셀 인덱스 구함
			for( ; c1 < j; c1++){
				if( headerInfos[c1].colspan > 0 ) colIndex++;
			}
			//셀 인덱스가  셀 개수보다 큰 경우
			if( colIndex >= colCount ){
				headerInfo = null; break;
			}
			
			//좌측고정 헤더 셀 추가 및 셀 인덱스 증가
			rightFixRow.appendChild(cells[colIndex].cloneNode(true));
		}
		
		//메모리 해제
		headerInfos = null; cells = null;
		rightFixRow = null; row = null;
	}
	
	//메모리 해제
	rightFixRows = null;
	rows = null;
	
	//우측고정 푸터 생성
	if( this.isShowFooter ){
		rows = this.SheetFooterObject.querySelectorAll("div.SheetFooterDiv tr");
		rightFixRows = this.SheetFooterObject.querySelectorAll("div.SheetFooterRightFixDiv tr");
		rowCount = rightFixRows.length;
		headerStartIndex = headerRowCount - this.rowsPerDataRow;
		
		for(i = 0; i < rowCount; i++){
			row = rows[i];
			rightFixRow = rightFixRows[i];
			cells = row.querySelectorAll("th,td");
			headerInfos = this.headerInfo[headerStartIndex + i];
			
			colCount = cells.length;
			colIndex = (cells[0].getAttribute("class") == "RowHeader") ? 1 : 0;
			j = this.colsPerRow - this.rightFixColumnCount;
			
			for(c = c1 = 0; j < this.colsPerRow && c < this.rightFixColumnCount; j++, c++, headerInfo = null){
				headerInfo = headerInfos[j];
				
				//colspan이 0보다 작은 경우 병합된 셀이므로 셀 추가하지 않음
				if( headerInfo.colspan < 0 ) continue;
				//셀 인덱스 구함
				for( ; c1 < j; c1++){
					if( headerInfos[c1].colspan > 0 ) colIndex++;
				}
				//셀 인덱스가  셀 개수보다 큰 경우
				if( colIndex >= colCount ){
					headerInfo = null; break;
				}
				
				//좌측고정 헤더 셀 추가 및 셀 인덱스 증가
				rightFixRow.appendChild(cells[colIndex].cloneNode(true));
			}
			
			//메모리 해제
			headerInfos = null; cells = null;
			rightFixRow = null; row = null;
		}
		
		//메모리 해제
		rightFixRows = null;
		rows = null;
	}
};

EasySheetRenderer.prototype._InitializeFooterInfo = function(footerRows){
	var rowCount = footerRows.length;
	
	if( rowCount <= 0 ) return false;
	
	var footerRow = null;
	var footerCols = null; var footerCol = null;
	var attr = null; var title = null;
	var rowItem = null; var colItem = null;
	var rowspan = 0; var colspan = 0;
	var cellIndex = 0; var columnIndex = 0; var cellCount = 0;
	var headerStartIndex = 0;
	var i = 0; var j = 0;
	var r = 0; var c = 0;
	var m = 0; var n = 0;
	
	//헤더정보 생성
	for(i = 0; i < rowCount; i++, rowItem = null){
		//행 배열 생성
		rowItem = this.footerInfo[i] = [];
		rowItem["cellCount"] = 0;
		//열 배열 생성
		for(j = 0; j < this.colsPerRow; j++)
			rowItem[j] = {rowIndex: i, cellIndex: j, colspan: 1, colspanMax: 1, rowspan: 1, rowspanMax: 1, childIndexs: null};
	}
	
	headerStartIndex = rowCount - this.rowsPerDataRow;
	
	//헤더정보 세팅
	for(i = 0; i < rowCount; i++){
		footerRow = footerRows[i];
		headerCols = footerRow.querySelectorAll("th,td");
		
		//행의 열 개수 카운트
		for(j = 0, cellIndex = 0, colCount = headerCols.length; j < colCount; j++, title = null, headerCol = null){
			headerCol = headerCols[j];
			
			if( headerCol.className.indexOf("RowHeader") >= 0 ) continue;
			
			if( headerCol.querySelector("div") != null )
					title = headerCol.querySelector("div").innerHTML.replace(/(^\s*)|(\s*$)/g, "");
			else	title = headerCol.innerHTML.replace(/(^\s*)|(\s*$)/g, "");
			
			attr = headerCol.rowSpan;
			rowspan = ((attr == null) ? 1 : 1 * attr);
			attr = null;
			attr = headerCol.colSpan;
			colspan = ((attr == null) ? 1 : 1 * attr);
			attr = null;
			
			for(m = 0, r = i; m < rowspan && r < rowCount; m++, r++, rowItem = null){
				rowItem = this.headerInfo[r];
				
				for(n = 0, c = cellIndex; n < colspan && cellIndex < this.colsPerRow; n++, c++, colItem = null){
					colItem = rowItem[c];
					
					if( colItem.colspanMax < 0 ){
						n--; continue;
					}
					
					if( i >= headerStartIndex ){
						colItem.rowIndex = i - headerStartIndex;
						colItem.cellIndex = columnIndex;
					}
					
					if( r == i && n == 0 ){
						colItem["title"] = title;
						colItem.colspan = colItem.colspanMax = colspan;
						colItem.rowspan = colItem.rowspanMax = rowspan;
						colItem.cells["header"] = headerCol;
					}
					else{
						colItem.colspan = colItem.colspanMax = -1;
						colItem.rowspan = colItem.rowspanMax = rowspan;
						colItem.cells = null;
					}
				}
			}
			
			//
			if( i >= headerStartIndex ){
				columnIndex++;
				cellCount++;
			}
			//
			cellIndex = c;
		}
		
		//
		if( i >= headerStartIndex ) this.headerInfo[i].cellCount = cellCount;
		
		//메모리 해제
		headerCols = null, headerRow = null;
	}
	
	return true;
};

EasySheetRenderer.prototype._InitHeaderInfo = function(){
	var headerInfoCount = this.headerInfo.length;
	var addHeadRowCount = headerInfoCount - this.rowsPerDataRow;
	
	if( addHeadRowCount <= 0 ) return false;
	
	var rowItem = null;
	var colItem = null;
	var i = 0;
	var j = 0;
	
	for(i = 0; i < headerInfoCount; i++, rowItem = null){
		rowItem = this.headerInfo[i];
		
		for(j = 0; j < this.colsPerRow; j++, colItem = null){
			colItem = rowItem[j];
			
			if( colItem.colspan < 0 )
				continue;
			
			colItem.colspan = colItem.colspanMax;
		}
	}
};

EasySheetRenderer.prototype._HideHeaderCellObject = function(columnIndex){
	//예외처리 : 컬럼 범위 벗어남
	if( columnIndex < 0 || columnIndex >= this.columnInfo.length )
		return false;
	
	var columnInfo = this.columnInfo[columnIndex];
	var columnRow = columnInfo.row - 1;
//	var columnCol = columnInfo.col - 1;
	var columnCol = columnIndex;
	columnInfo = null;
	
	var headerRowIndex = this.headerInfo.length - this.rowsPerDataRow + columnRow;
	var headerColIndex = 0;
	var physicalColIndex = columnCol - (columnRow > 0 ? this.headerInfo[headerRowIndex - 1].cellCount : 0);
	var headRowItem = this.headerInfo[headerRowIndex];
	var headColItem = null;
	var cellItem = null;
	var i = 0; var j = 0;
	
	for(i = 0, headerColIndex = 0; i <= physicalColIndex; i++, headerColIndex++, headColItem = null){
		headColItem = headRowItem[headerColIndex];
		if( headColItem.colspan < 0 ){ i--; continue; }
		if( i == physicalColIndex ) break;
	}
	
	//우측고정열 인덱스 차이
	var rightFixGap = this.colsPerRow - this.rightFixColumnCount;
	
	//헤더 정보
	headColItem = headRowItem[headerColIndex];
	
	//헤더 숨김
	cellItem = headColItem.cells.header;
	cellItem.style.display = "none";
	cellItem = null;
	
	//좌측고정 헤더 숨김
	if( this.leftFixColumnCount > 0 && headerColIndex < this.leftFixColumnCount ){
		cellItem = headColItem.cells.leftfix;
		cellItem.style.display = "none";
		cellItem = null;
	}
	
	//우측고정 헤더 숨김
	if( this.rightFixColumnCount > 0 && headerColIndex >= rightFixGap ){
		cellItem = headColItem.cells.rightfix;
		cellItem.style.display = "none";
		cellItem = null;
	}
	
	//메모리 해제
	headColItem = null; headRowItem = null;
	
	var headColItems = null;
	var rowSpan = 0;
	var colSpan = 0;
	
	for(headerRowIndex = this.headerInfo.length - this.rowsPerDataRow - 1; headerRowIndex >= 0;){
		headRowItem = this.headerInfo[headerRowIndex];
		headColItem = headRowItem[headerColIndex];
		
		rowSpan = headColItem.rowspan;
		colSpan = headColItem.colspan;
		
		//셀이 다른 셀과 병합되지 않은 상태로 숨김 처리(display:none; headerRowIndex--;) 
		if( colSpan == 1 ){
			cellItem = headColItem.cells.header;
			cellItem.style.display = "none";
			cellItem = null;
			
			cellItem = headColItem.cells.leftfix;
			if( cellItem != null && typeof cellItem != "undefined" ) cellItem.style.display = "none";
			cellItem = null;
			
			cellItem = headColItem.cells.rightfix;
			if( cellItem != null && typeof cellItem != "undefined" ) cellItem.style.display = "none";
			cellItem = null;
			
			headerRowIndex--;
		}
		//셀이 다른 셀과 병합된 상태로 병합 열 수를 1 감소
		else if( colSpan > 1 ){
			colSpan = headColItem.colspan = colSpan - 1;
			
			cellItem = headColItem.cells.header;
			cellItem.colSpan = colSpan;
			cellItem = null;
			
			cellItem = headColItem.cells.leftfix;
			if( cellItem != null && typeof cellItem != "undefined" ) cellItem.colSpan = colSpan;
			cellItem = null;
			
			cellItem = headColItem.cells.rightfix;
			if( cellItem != null && typeof cellItem != "undefined" ) cellItem.colSpan = colSpan;
			cellItem = null;
			
			if( typeof this._columnWidths != "undefined" && this._columnWidths != null ){
				var sumWidth = -1;
				var i = 0;
				var j = headerColIndex;
				for(i = 0; i < colSpan; i++, j++){
					sumWidth += this._columnWidths[j];
				}
				
				if( colSpan > 0) sumWidth -= colSpan;
				
				cellItem = headColItem.cells.header;
				cellItem.querySelector("div").style.width = (sumWidth+ "px");
				cellItem = null;
				
				cellItem = headColItem.cells.leftfix;
				if( cellItem != null && typeof cellItem != "undefined" ) cellItem.querySelector("div").style.width = (sumWidth+ "px");
				cellItem = null;
				
				cellItem = headColItem.cells.rightfix;
				if( cellItem != null && typeof cellItem != "undefined" ) cellItem.querySelector("div").style.width = (sumWidth+ "px");
				cellItem = null;
			}
			
			headerRowIndex--;
		}
		//병합되어 실제 태그가 없는 상태로 병합 셀의 위치로만 이동(headerRowIndex, headerColIndex 변경)
		else if( colSpan < 0 ){
			headerRowIndex = headerRowIndex - (rowSpan - 1);
			
			headColItems = this.headerInfo[headerRowIndex];
			
			for(i = headerColIndex; i >= 0; i--){
				if( headColItems[i].colspan > 0 ){
					headerColIndex = i;
					break;
				}
			}
			
			headColItems = null;
		}
		
		//메모리 해제
		headColItem = null;
		headRowItem = null;
	}
	
	return true;
};

EasySheetRenderer.prototype._ShowHeaderCellObject = function(columnIndex){
	//예외처리 : 컬럼 범위 벗어남
	if( columnIndex < 0 || columnIndex >= this.columnInfo.length )
		return false;
	
	var columnInfo = this.columnInfo[columnIndex];
	var columnRow = columnInfo.row - 1;
//	var columnCol = columnInfo.col - 1;
	var columnCol = columnIndex;
	var calcCellWidth = columnInfo.calcCellWidth + "px";
	var calcInnerDivWidth = columnInfo.calcInnerDivWidth + "px";
	var cellMinWidth = columnInfo.minWidth;
	columnInfo = null;
	
	var headerRowIndex = this.headerInfo.length - this.rowsPerDataRow + columnRow;
	var headerColIndex = 0;
	var physicalColIndex = columnCol - (columnRow > 0 ? this.headerInfo[headerRowIndex - 1].cellCount : 0);
	var headRowItem = this.headerInfo[headerRowIndex];
	var headColItem = null;
	var cellItem = null;
	var i = 0; var j = 0;
	
	for(i = 0, headerColIndex = 0; i <= physicalColIndex; i++, headerColIndex++, headColItem = null){
		headColItem = headRowItem[headerColIndex];
		if( headColItem.colspan < 0 ){ i--; continue; }
		if( i == physicalColIndex ) break;
	}
	
	//우측고정열 인덱스 차이
	var rightFixGap = this.colsPerRow - this.rightFixColumnCount;
	//정렬, 필터 표시 객체
	var sortDiv = null;
	var filterDiv = null;
	
	//헤더 정보
	headColItem = headRowItem[headerColIndex];
	
	//보이기 설정
	//헤더 보이기
	cellItem = headColItem.cells.header;
	cellItem.style.display = "";
	cellItem.style.width = calcCellWidth;
	cellItem.style.minWidth = cellMinWidth;
	cellItem.querySelector("div").style.width = calcInnerDivWidth;
	//정렬 아이콘 div 너비 재설정
	sortDiv = cellItem.querySelector("div.EasySheetSortDiv");
	if( sortDiv != null ) sortDiv.style.width = calcCellWidth;
	sortDiv = null;
	//필터 아이콘 div 너비 재설정
	filterDiv = cellItem.querySelector("div.EasySheetFilterDiv");
	if( filterDiv != null ) filterDiv.style.width = calcCellWidth;
	filterDiv = null;
	cellItem = null;
	
	//좌측고정 헤더 보이기
	if( this.leftFixColumnCount > 0 && headerColIndex < this.leftFixColumnCount ){
		cellItem = headColItem.cells.leftfix;
		cellItem.style.display = "";
		cellItem.style.width = calcCellWidth;
		cellItem.style.minWidth = cellMinWidth;
		cellItem.querySelector("div").style.width = calcInnerDivWidth;
		//정렬 아이콘 div 너비 재설정
		sortDiv = cellItem.querySelector("div.EasySheetSortDiv");
		if( sortDiv != null ) sortDiv.style.width = calcCellWidth;
		sortDiv = null;
		//필터 아이콘 div 너비 재설정
		filterDiv = cellItem.querySelector("div.EasySheetFilterDiv");
		if( filterDiv != null ) filterDiv.style.width = calcCellWidth;
		filterDiv = null;
		cellItem = null;
	}
	
	//우측고정 헤더 보이기
	if( this.rightFixColumnCount > 0 && headerColIndex >= rightFixGap ){
		cellItem = headColItem.cells.rightfix;
		cellItem.style.display = "";
		cellItem.style.width = calcCellWidth;
		cellItem.style.minWidth = cellMinWidth;
		cellItem.querySelector("div").style.width = calcInnerDivWidth;
		//정렬 아이콘 div 너비 재설정
		sortDiv = cellItem.querySelector("div.EasySheetSortDiv");
		if( sortDiv != null ) sortDiv.style.width = calcCellWidth;
		sortDiv = null;
		//필터 아이콘 div 너비 재설정
		filterDiv = cellItem.querySelector("div.EasySheetFilterDiv");
		if( filterDiv != null ) filterDiv.style.width = calcCellWidth;
		filterDiv = null;
		cellItem = null;
	}
	
	//메모리 해제
	headColItem = null; headRowItem = null;
	cellMinWidth = null; calcInnerDivWidth = null; calcCellWidth = null;
	
	var headColItems = null;
	var rowSpan = 0;
	var colSpan = 0;
	var colSpanMax = 0;
	var display = null;
	
	for(headerRowIndex = this.headerInfo.length - this.rowsPerDataRow - 1; headerRowIndex >= 0;){
		headRowItem = this.headerInfo[headerRowIndex];
		headColItem = headRowItem[headerColIndex];
		
		//병합정보
		rowSpan = headColItem.rowspan;
		colSpan = headColItem.colspan;
		colSpanMax = headColItem.colspanMax;
		display = (headColItem.cells != null) ? headColItem.cells.header.style.display : null;
		
		if( colSpan >= 1 ){
			if( colSpan == 1 && display == "none" ){
				cellItem = headColItem.cells.header;
				cellItem.style.display = "";
				cellItem = null;
				
				cellItem = headColItem.cells.leftfix;
				if( cellItem != null && typeof cellItem != "undefined" ) cellItem.style.display = "";
				cellItem = null;
				
				cellItem = headColItem.cells.rightfix;
				if( cellItem != null && typeof cellItem != "undefined" ) cellItem.style.display = "";
				cellItem = null;
			}
			else{
				if( typeof this._columnWidths != "undefined" && this._columnWidths != null ){
					var sumWidth = -1;
					var i = 0;
					var j = headerColIndex;
					for(i = 0; i < colSpan; i++, j++){
						sumWidth += this._columnWidths[j];
					}
					if( colSpan > 0) sumWidth -= colSpan;
					
					cellItem = headColItem.cells.header;
					cellItem.querySelector("div").style.width = (sumWidth+ "px");
					cellItem = null;
					
					cellItem = headColItem.cells.leftfix;
					if( cellItem != null && typeof cellItem != "undefined" ) cellItem.querySelector("div").style.width = (sumWidth+ "px");
					cellItem = null;
					
					cellItem = headColItem.cells.rightfix;
					if( cellItem != null && typeof cellItem != "undefined" ) cellItem.querySelector("div").style.width = (sumWidth+ "px");
					cellItem = null;
				}
			}
			
			headerRowIndex--;
		}
		else if( colSpan < 0 ){
			headerRowIndex = headerRowIndex - (rowSpan - 1);
			
			headColItems = this.headerInfo[headerRowIndex];
			
			for(i = headerColIndex; i >= 0; i--){
				if( headColItems[i].colspan > 0 ){
					headerColIndex = i;
					break;
				}
			}
			
			headColItems = null;
		}
		
		//메모리 해제
		display = null;
		headColItem = null;
		headRowItem = null;
	}
	
	return true;
};

EasySheetRenderer.prototype.resetRowNum = function(startRowNum){
	var rowHeaderCells = null;
	var rowHeaderCell = null;
	var rowHeaderLeftFixCells = null;
	var rowHeaderLeftFixCell = null;
	var rowIndex = 0;
	var i = 0;
	
	//시트 본문의 행 번호 셀을 배열로 구함
	rowHeaderCells = document.querySelectorAll("div#" + this.controlId + ".EasyDataSheet table#" + this.controlId + "_SheetContentTable td.RowHeader > div");
	rowHeaderLeftFixCells = document.querySelectorAll("div#" + this.controlId + ".EasyDataSheet table#" + this.controlId + "_SheetContentLeftFixTable td.RowHeader > div");
	
	for(i = 0; i < rowHeaderCells.length; i++, rowIndex = 0){
		rowHeaderCell = rowHeaderCells[i];
		rowHeaderLeftFixCell = rowHeaderLeftFixCells[i];
		
		//행의 인덱스를 구함, Selector를 구한 셀 객체는 td객체의 div객체이므로 부모의 부모 객체가 tr객체이고 tr객체의 rowIndex속성으로 행 번호를 계산함
		try{
//			rowIndex = 1 * rowHeaderCell.parentElement.parentElement.getAttribute("rowIndex");
			rowIndex = 1 * rowHeaderCell.parentElement.parentElement.getAttribute("recordindex");
		}
		//만약 rowIndex속성을 구하는 중 오류가 발생한다면 그 행은 무시하고 다음 행의 행번호를 구함
		catch(e){ continue; }
		
//		rowHeaderCell.innerHTML = (startRowNum + rowIndex);
		rowHeaderCell.innerHTML = rowIndex + 1;
		rowHeaderLeftFixCell.innerHTML = rowIndex + 1;
		
		rowHeaderCell = null;
		rowHeaderLeftFixCell = null;
	}
	
	//메모리 해제
	rowHeaderLeftFixCell = null; rowHeaderCell = null;
	rowHeaderLeftFixCells = null; rowHeaderCells = null;
};

EasySheetRenderer.prototype._RecalcColumnWidth = function(){
	var columnInfo = null;
	var colWidthInfo = null;
	var hasHiddenCell = false;
	var sheetWidth = 0;
	var sheetColCount = 0;
	var pxRegexp = /[0-9]+\.?[0-9]*px$/;
	var perRegexp = /[0-9]+\.?[0-9]*%$/;
	var colWidth = 0; var colMinWidth = -1; var calcWidth = 0;
	var sumCalcWidth = 0; var sumMinWidth = 0; var rowHeaderWidth = 0;
	var gapTableAndDiv = 0; var gapAddWidth = 0; var gapSumWidth = 0;
	var i = 0; var j = 0;
	
	sumCalcWidth = sumMinWidth = rowHeaderWidth = this.isShowRowHeader ? this.sheetRowHeaderWidth : 0;
	sheetWidth = this.sheetContentDivWidth - rowHeaderWidth;
	
	//열 너비 정보 재계산
	if( typeof this.columnWidths == "undefined" || this.columnWidths != null ){
		sheetColCount = this.columnWidths.length;
		
		if( sheetColCount > 0 ) this._columnWidths = [];
		
		var headerRowCount = this.headerInfo.length;
		var headerStartIndex = headerRowCount - this.rowsPerDataRow;
		
		for(i = 0; i < sheetColCount; i++, colWidthInfo = null){
			colWidthInfo = this.columnWidths[i];
			//예외처리
			if( colWidthInfo == null ) continue;
			//고정, 반응형에 따라 너비 계산
			if( !colWidthInfo.isFixed ){
				this._columnWidths[i] = Math.ceil(sheetWidth * (colWidthInfo.width / 100));
			}
			else{
				this._columnWidths[i] = colWidthInfo.width;
			}
			//최소 너비보다 작은 경우
			if( this._columnWidths[i] < colWidthInfo.minWidth ){
				this._columnWidths[i] = colWidthInfo.minWidth;
			}
			//만약 숨김 컬럼이라면 너비는 0임
			if( this.columnInfo.length > 0 ){
				for(j = headerStartIndex; j < headerRowCount; j++){
					if( this.columnInfo[(this.headerInfo[j])[i].cellIndex].hidden ){
						this._columnWidths[i] = 0;
						break;
					}
				}
			}
		}
		
		//메모리 해제
		perRegexp = null; pxRegexp = null;
	}
	
	//컬럼의 너비와 컬럼 내 Div 의 너비를 계산
	for(i = 0, colMinWidth = -1, sheetColCount = this.columnInfo.length; i < sheetColCount; i++, columnInfo = null){
		columnInfo = this.columnInfo[i];
		
		if( columnInfo.hidden ){
			sumCalcWidth += 0;
			sumMinWidth += 0;
			
			//계산한 컬럼 너비 설정
			columnInfo.isSameMinWidth = false;
			columnInfo.calcCellWidth = 0;
			columnInfo.calcInnerDivWidth = 0;
			
			//숨김 컬럼이 존재
			hasHiddenCell = true;
		}
		else{
			colWidth = (columnInfo.isFixedWidth) ? 1 * columnInfo.width.replace("px", "") : Math.ceil(sheetWidth * (columnInfo.percentWidth / 100));
			colMinWidth = 1 * ("" + columnInfo.minWidth).replace("px", "");
			
			//계산한 컬럼의 너비가 컬럼 최저 너비보다 작은 경우 최저 너비로 고정함
			calcWidth = (colWidth > colMinWidth) ? colWidth : colMinWidth;
			
			//행 정보가 1인(첫번째 행)의 컬럼 너비만 더함
			if( columnInfo.row == 1 ){
				sumCalcWidth += calcWidth;
				sumMinWidth += colMinWidth;
			}
			//계산한 컬럼 너비 설정
			columnInfo.isSameMinWidth = (calcWidth == colMinWidth);
			columnInfo.calcCellWidth = calcWidth;
			columnInfo.calcInnerDivWidth = (calcWidth - 1);

			//메모리 해제
			calcWidth = 0; colMinWidth = -1; colWidth = 0;
		}
	}
	
	//컬럼 너비의 합계가 컬럼 최소너비의 합계보다 큰 경우에만 너비조정을 함(최소너비가 크다면 컬럼너비가 더이상 줄어들 수 없으므로 조정하지 않음)
	if( sumCalcWidth > sumMinWidth ){
		gapTableAndDiv = (Math.ceil(this.sheetContentDivWidth) + 1) - sumCalcWidth;
	}
	
	//모든 컬럼이 반응형이고 너비의 합이 100% 이며, 헤더 Div와 열 너비의 차이가 있다면 컬럼 너비 조정하여 너비 100%에 맞춤
	if( !hasHiddenCell 
		&& (this._cntResponsibleColumnWidth == this.columnInfo.length) 
		&& (this._sumResponsibleColumnWidth == 100) && gapTableAndDiv != 0 
	){
		gapAddWidth = (gapTableAndDiv > 0) ? 1 : -1;
		sumCalcWidth = rowHeaderWidth;
		
		for(i = 0; i < sheetColCount; i++, columnInfo = null){
			columnInfo = this.columnInfo[i];
			
			if( columnInfo.isSameMinWidth || columnInfo.isFixedWidth ) continue;
			
			columnInfo.calcCellWidth = columnInfo.calcCellWidth + gapAddWidth;
			columnInfo.calcInnerDivWidth = columnInfo.calcCellWidth - 1; //(1 + 10); //1(border-right) + 5(padding-left) + 5(padding-right)
			gapSumWidth += gapAddWidth;
			
			//행 정보가 1인(첫번째 행)의 컬럼 너비만 더함
			if( columnInfo.row == 1 ) sumCalcWidth += columnInfo.calcCellWidth;
			
			//헤더 Div와 열 너비의 차이만큼 너비 조정이 완료되었다면 나머지 컬럼은 조정하지 않음
			if( gapSumWidth == gapTableAndDiv ){
				columnInfo = null;
				break;
			}
			//너비 조정이 완료되지 않았다면 다시 처음부터 컬럼 조정 시작
			if( i + 1 == sheetColCount ){
				i = 0;
				sumCalcWidth = rowHeaderWidth;
			}
		}
	}
	
	//메모리 해제
	gapTableAndDiv = null; hasHiddenCell = null;
	
	//푸터 너비 설정
	if( this.isShowFooter ){
		var footerInfo = null;
		var footerCount = 0;
		var colspan = 0;
		
		for(i = 0, footerCount = this.footerInfo.length, columnInfo = null; i < sheetColCount && i < footerCount; i++){
			footerInfo = this.footerInfo[i];
//			colspan = footerInfo.colspan;
//			
//			for(j = 0, calcWidth = 0; j < colspan; j++){
//				columnInfo = this.columnInfo[i + j];
//				calcWidth += columnInfo.calcCellWidth;
//				columnInfo = null;
//			}
			
			columnInfo = this.columnInfo[i];
			calcWidth = columnInfo.calcCellWidth;
			columnInfo = null;
			
			footerInfo.calcCellWidth = calcWidth;
			footerInfo.calcInnerDivWidth = (calcWidth - 1);
			footerInfo = null;
		}
	}
	
	return sumCalcWidth;
};

EasySheetRenderer.prototype._ResetShowScroll = function(){
	var cssStyleDeclaration = null;
	var sumColumnWidth = 0;
	
	//현재 수직스크롤 바가 보이지 않은 상태에서 수직스크롤이 추가될 경우 시트의 내부 너비가 변경되므로 너비를 변경한 후 너비를 재조정하고 스크롤을 재계산함
	if( this.displayScrollBar && this.dataRowCount > this.wholeShownRowCount ){
		this.SheetHeaderObject.style.width = "calc(100% - " + this.vScrollWidth + ")";
		this.SheetContentObject.style.width = "calc(100% - " + this.vScrollWidth + ")";
		if( this.isShowFooter ) this.SheetFooterObject.style.width = "calc(100% - " + this.vScrollWidth + ")";
		this.isShowVScroll = true;
	}
	//현재 수직스크롤 바가 보이는 상태에서 수직스크롤이 사라지게 될 경우 시트 내부 너비가 변경되므로 너비를 변경 후 너비를 재조정하고 스크롤을 재계산 함
	else{
		this.SheetHeaderObject.style.width = "100%";
		this.SheetContentObject.style.width = "100%";
		if( this.isShowFooter ) this.SheetFooterObject.style.width = "100%";
		this.isShowVScroll = false;
	}
	
	//시트 헤더 및 본문 Div 너비 재설정
	this.sheetHeaderDivWidth = 1 * (getComputedStyle(this.SheetHeaderObject).width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
	this.sheetContentDivWidth = 1 * (getComputedStyle(this.SheetContentObject).width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
	
	//시트 컬럼 너비 재계산
	sumColumnWidth = this._RecalcColumnWidth();
	
	//
	cssStyleDeclaration = getComputedStyle(this.SheetObject.querySelector("div.SheetDiv"));
	
	//
	if( this.displayScrollBar && sumColumnWidth > this.sheetHeaderDivWidth ){
		if( this.isShowFooter ){
			this.SheetContentObject.style.height = "calc(100% - " + this.sheetHeaderDivHeight + "px - " + this.hScrollHeight + " - " + this.footerHeight + "px)";
			this.SheetFooterObject.style.top = "calc(" + cssStyleDeclaration.height + " - " + this.footerHeight + "px - " + this.hScrollHeight + ")";
		}
		else
			this.SheetContentObject.style.height = "calc(100% - " + this.sheetHeaderDivHeight + "px - " + this.hScrollHeight + ")";
		
		this.isShowHScroll = true;
	}
	//
	else{
		if( this.isShowFooter ){
			this.SheetContentObject.style.height = "calc(100% - " + this.sheetHeaderDivHeight + "px - " + this.footerHeight + "px)";
			this.SheetFooterObject.style.top = "calc(" + cssStyleDeclaration.height + " - " + this.footerHeight + "px)";
		}
		else
			this.SheetContentObject.style.height = "calc(100% - " + this.sheetHeaderDivHeight + "px)";
		
		this.isShowHScroll = false;
	}
	
	//
	this.sheetContentDivHeight = 1 * (getComputedStyle(this.SheetContentObject).height).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
	
	//메모리 해제
	cssStyleDeclaration = null;
};

EasySheetRenderer.prototype.resetColumnWidth = function(){
	var i = 0; var j = 0; var k = 0; var m = 0;
	
	var sheetRowCount = 0;
	var sheetColCount = this.columnInfo.length;
	var sheetCellCount = 0;
	//좌/우측 고정열 너비
	var leftFixWidth = 0;
	var rightFixWidth = 0;
	var sumFixWidth = 0;
	//
	var headerInfos = null;
	var headerInfo = null;
	var columnInfo = null;
	var headerRowCount = this.headerInfo.length;
	var columnIndex = 0;
	var rowRIndex = 0; var colRIndex = 0;
	//우측고정열 인덱스 차이
	var rightFixGap = this.colsPerRow - this.rightFixColumnCount
	
	//
	this._InitHeaderInfo();
	
	//헤더 열 너비 설정
	for(i = headerRowCount - this.rowsPerDataRow; sheetColCount > 0 && i < headerRowCount; i++, headerInfos = null){
		headerInfos = this.headerInfo[i];
		
		for(j = 0; j < this.colsPerRow; j++, headerInfo = null){
			headerInfo = headerInfos[j];
			if( headerInfo.colspan < 0 ) continue;
			
			columnIndex = headerInfo.cellIndex;
			if( m >= sheetColCount ){
				headerInfos = null; headerInfo = null; 
				break;
			}
			
			columnInfo = this.columnInfo[columnIndex];
			
//			if(i == this._lastVisibleColumnIndex && !this.columnInfo[i].isFixedWidth && this.sheetHeaderLastRowCells[i + 1].style.borderRight.length <= 0 )
//				this.sheetHeaderLastRowCells[i + 1].style.borderRight = "0px none";
			
			if( columnInfo.hidden ){
				this._HideHeaderCellObject(columnIndex);
			}
			else{
				this._ShowHeaderCellObject(columnIndex);
				
				//좌, 우고정 헤더 너비 계산
				if( columnInfo.row == 1 && this.leftFixColumnCount > 0 && j < this.leftFixColumnCount )
					leftFixWidth += columnInfo.calcInnerDivWidth;
				else if( columnInfo.row == 1 && this.rightFixColumnCount > 0 && j >= rightFixGap )
					rightFixWidth += columnInfo.calcCellWidth;
			}
			
			columnInfo = null;
		}
	}
	
	//시트 본문, 좌/우측고정 본문의 행/열 객체배열(tr/td)
	var sheetContentRows = this.SheetContentObject.querySelectorAll("div.SheetContentDiv tr");
	var sheetContentRowCells = null;
	var sheetContentLeftFixRows = this.SheetContentObject.querySelectorAll("div.SheetContentLeftFixDiv tr");
	var sheetContentLeftFixRowCells = null;
	var sheetContentRightFixRows = this.SheetContentObject.querySelectorAll("div.SheetContentRightFixDiv tr");
	var sheetContentRightFixRowCells = null;
	var sheetCellObject = null;
	//좌/우측 고정여부
	var hasLeftFixColumn = null; var hasRightFixColumn = null;
	//시트 편집 셀 객체
	var editCellInnerDivOject = this.isEditngSheet ? this.SheetControlTempDivObject.children[0] : null;
	//시트 중복자료 병합 정보 객체
	var mergeInfo = null; var mergeDisp = false;
	//
	var cellWidth = null; var cellMinWidth = null; var calcInnerWidth = null;
	//
	var isHidden = false;
	
	//본문 행별로 열 너비 재설정
	for(i = 0, sheetRowCount = sheetContentRows.length / this.rowsPerDataRow; i < sheetRowCount && i < this.displayMaxRowCount; i++){
		for(j = 0, colRIndex = 0; j < this.rowsPerDataRow; j++){
			rowRIndex = (i * this.rowsPerDataRow) + j;
			
			sheetContentRowCells = sheetContentRows[rowRIndex].getElementsByTagName("td");
			if( sheetContentLeftFixRows != null && sheetContentLeftFixRows.length > 0 )
				sheetContentLeftFixRowCells = sheetContentLeftFixRows[rowRIndex].getElementsByTagName("td");
			if( sheetContentRightFixRows != null && sheetContentRightFixRows.length > 0 )
				sheetContentRightFixRowCells = sheetContentRightFixRows[rowRIndex].getElementsByTagName("td");
			
			//시트 중복자료 병합 정보
			if( i < this.data.length && typeof this.data[i].__STATE__.mergeInfo != "undefined" ){
				mergeInfo = this.data[i].__STATE__.mergeInfo[j];
				mergeInfo = (typeof mergeInfo != "undefined") ? mergeInfo : null;
			}
			
			sheetCellCount = sheetContentRowCells.length;
			headerInfos = this.headerInfo[this.headerInfo.length - this.rowsPerDataRow + j];
			
			//열 너비 재설정
			for(k = 0, colRIndex = (j > 0 ? 0 : 1); sheetColCount > 0 && k < this.colsPerRow && colRIndex < sheetCellCount; k++){
				headerInfo = headerInfos[k];
				if( headerInfo.colspan < 0 ) continue;
				
				m = headerInfo.cellIndex;
				if( m >= sheetColCount ){
					headerInfos = null; headerInfo = null;
					break;
				}
				
//				if(m == this._lastVisibleColumnIndex && !this.columnInfo[m].isFixedWidth && sheetContentRowCells[colRIndex].style.borderRight.length <= 0 ){
//					sheetContentRowCells[colRIndex].style.borderRight = "0px none";
//				}
				
				columnInfo = this.columnInfo[m];
				mergeDisp = (mergeInfo != null && !mergeInfo[k].disp);
				
				//열 고정여부 설정
				hasLeftFixColumn = (sheetContentLeftFixRowCells != null && this.leftFixColumnCount > 0 && k < this.leftFixColumnCount);
				hasRightFixColumn = (sheetContentRightFixRowCells != null && this.rightFixColumnCount > 0 && k >= rightFixGap);
				//열너비 설정
				cellWidth = columnInfo.calcCellWidth + "px"; 
				calcInnerWidth = columnInfo.calcInnerDivWidth + "px";
				cellMinWidth = columnInfo.minWidth;
				//컬럼 숨김 설정
				isHidden = columnInfo.hidden;
				
				//본문 너비 설정
				sheetCellObject = sheetContentRowCells[colRIndex];
				if( isHidden || mergeDisp ){
					sheetCellObject.style.display = "none";
				}
				else{
					sheetCellObject.style.display = "";
					sheetCellObject.style.width = cellWidth;
					sheetCellObject.style.minWidth = cellMinWidth;
					sheetCellObject.getElementsByTagName("div")[0].style.width = calcInnerWidth;
				}
				sheetCellObject = null;
				
				//좌측고정 본문 너비 설정
				if( hasLeftFixColumn ){
					sheetCellObject = sheetContentLeftFixRowCells[colRIndex];
					if( isHidden || mergeDisp ){
						sheetCellObject.style.display = "none";
					}
					else{
						sheetCellObject.style.display = "";
						sheetCellObject.style.width = cellWidth;
						sheetCellObject.style.minWidth = cellMinWidth;
						sheetCellObject.getElementsByTagName("div")[0].style.width = calcInnerWidth;
					}
					sheetCellObject = null;
				}
				
				//우측고정 헤더 너비 설정
				if( hasRightFixColumn ){
					sheetCellObject = sheetContentRightFixRowCells[k - rightFixGap];
					if( isHidden || mergeDisp ){
						sheetCellObject.style.display = "none";
					}
					else{
						sheetCellObject.style.display = "";
						sheetCellObject.style.width = cellWidth;
						sheetCellObject.style.minWidth = cellMinWidth;
						sheetCellObject.getElementsByTagName("div")[0].style.width = calcInnerWidth;
					}
					sheetCellObject = null;
				}
				
				//셀 인덱스 증가
				colRIndex++;
				
				//메모리 해제
				mergeDisp = false; isHidden = null;
				cellMinWidth = null; calcInnerWidth = null; cellWidth = null;
				hasLeftFixColumn = null; hasRightFixColumn = null;
			}
			
			//메모리 해제
			mergeInfo = null;
			sheetContentRightFixRowCells = null;
			sheetContentLeftFixRowCells = null;
			sheetContentRowCells = null;
		}
	}
	
	if( this.isShowFooter ){
		//시트 푸터, 좌/우측고정 푸터 행/열 객체배열(tr/td)
		var sheetFooterRows = this.SheetFooterObject.querySelectorAll("div.SheetFooterDiv tr");
		var sheetFooterRowCells = null;
		var sheetFooterLeftFixRows = this.SheetFooterObject.querySelectorAll("div.SheetFooterLeftFixDiv tr");
		var sheetFooterLeftFixRowCells = null;
		var sheetFooterRightFixRows = this.SheetFooterObject.querySelectorAll("div.SheetFooterRightFixDiv tr");
		var sheetFooterRightFixRowCells = null;
		var footerInfo = null;
		
		//푸터 열 너비 재설정
		for(i = 0, rowRIndex = 0, sheetRowCount = sheetFooterRows.length; i < this.footerRowCount && i < sheetRowCount; i++){
			for(j = 0, colRIndex = 0; j < this.rowsPerDataRow; j++){
				rowRIndex = (i * this.rowsPerDataRow) + j;
				
				sheetFooterRowCells = sheetFooterRows[rowRIndex].getElementsByTagName("td");
				if( sheetFooterLeftFixRows != null && sheetFooterLeftFixRows.length > 0 )
					sheetFooterLeftFixRowCells = sheetFooterLeftFixRows[rowRIndex].getElementsByTagName("td");
				if( sheetFooterRightFixRows != null && sheetFooterRightFixRows.length > 0 )
					sheetFooterRightFixRowCells = sheetFooterRightFixRows[rowRIndex].getElementsByTagName("td");
				
				sheetCellCount = sheetFooterRowCells.length;
				headerInfos = this.headerInfo[this.headerInfo.length - this.rowsPerDataRow + j];
				
				//열 너비 재설정
				for(k = 0, colRIndex = (j > 0 ? 0 : 1); sheetColCount > 0 && k < this.colsPerRow && colRIndex < sheetCellCount; k++){
					headerInfo = headerInfos[k];
					if( headerInfo.colspan < 0 ) continue;
					
					m = headerInfo.cellIndex;
					if( m >= sheetColCount ){
						headerInfos = null; headerInfo = null;
						break;
					}
					
					footerInfo = this.footerInfo[m];
					
					//열 고정여부 설정
					hasLeftFixColumn = (sheetFooterLeftFixRowCells != null && this.leftFixColumnCount > 0 && k < this.leftFixColumnCount);
					hasRightFixColumn = (sheetFooterRightFixRowCells != null && this.rightFixColumnCount > 0 && k >= rightFixGap);
					//열너비 설정
					cellWidth = footerInfo.calcCellWidth + "px";
					calcInnerWidth = footerInfo.calcInnerDivWidth + "px";
					//컬럼 숨김 설정
					isHidden = footerInfo.hidden;
					
					//본문 너비 설정
					if( isHidden )
						sheetFooterRowCells[colRIndex].style.display = "none";
					else{
						sheetFooterRowCells[colRIndex].style.display = "";
						sheetFooterRowCells[colRIndex].style.width = cellWidth;
						sheetFooterRowCells[colRIndex].getElementsByTagName("div")[0].style.width = calcInnerWidth;
					}
					//좌측고정 본문 너비 설정
					if( hasLeftFixColumn ){
						if( isHidden )
							sheetFooterLeftFixRowCells[colRIndex].style.display = "none";
						else{
							sheetFooterLeftFixRowCells[colRIndex].style.display = "";
							sheetFooterLeftFixRowCells[colRIndex].style.width = cellWidth;
							sheetFooterLeftFixRowCells[colRIndex].getElementsByTagName("div")[0].style.width = calcInnerWidth;
						}
					}
					//우측고정 헤더 너비 설정
					if( hasRightFixColumn ){
						if( isHidden )
							sheetFooterRightFixRowCells[k - rightFixGap].style.display = "none";
						else{
							sheetFooterRightFixRowCells[k - rightFixGap].style.display = "";
							sheetFooterRightFixRowCells[k - rightFixGap].style.width = cellWidth;
							sheetFooterRightFixRowCells[k - rightFixGap].getElementsByTagName("div")[0].style.width = calcInnerWidth;
						}
					}
					
					//셀 인덱스 증가
					colRIndex++;
					
					//메모리 해제
					isHidden = null;
					cellMinWidth = null; calcInnerWidth = null; cellWidth = null;
					hasLeftFixColumn = null; hasRightFixColumn = null;
				}
				
				//메모리 해제
				sheetFooterRightFixRowCells = null;
				sheetFooterLeftFixRowCells = null;
				sheetFooterRowCells = null;
			}
		}
		
		//푸터, 좌/우측고정 푸터 행 객체배열 메모리 해제
		sheetFooterRightFixRows = null;
		sheetFooterLeftFixRows = null;
		sheetFooterRows = null;
	}
	
	//좌측고정열 너비 설정
	if( sheetContentLeftFixRowCells != null && this.leftFixColumnCount > 0 ){
		this.sheetLeftFixWidth = leftFixWidth;
	}
	//우측고정열 위치 및 우측고정열 너비 설정
	if( this.SheetHeaderRightFixObject != null && this.rightFixColumnCount > 0 ){
		this.SheetHeaderRightFixObject.style.left = "calc(100% - " + rightFixWidth + "px)";
		this.SheetContentRightFixObject.style.left = "calc(100% - " + rightFixWidth + "px)";
		if( this.isShowFooter ) this.SheetFooterRightFixObject.style.left = "calc(100% - " + rightFixWidth + "px)";
		this.sheetRightFixWidth = rightFixWidth;
	}
	
	//시트 좌측고정 너비 + 우측고정 너비 만큼 시트 최소 너비 설정
	sumFixWidth = (this.sheetLeftFixWidth + this.sheetRightFixWidth + 1);
	this.SheetObject.style.minWidth = (this.sheetContentDivWidth > sumFixWidth ? sumFixWidth : this.sheetContentDivWidth) + "px";
	
	//본문, 좌/우측고정 본문 행 객체배열 메모리 해제
	editCellInnerDivOject = null;
	sheetContentRightFixRows = null;
	sheetContentLeftFixRows = null;
	sheetContentRows = null;
};

EasySheetRenderer.prototype.resetScroll = function(){
	var vScrollFaceObj = null;
	var hScrollFaceObj = null;
    var sheetHeaderTableObject = null;
    var sheetContentTableObject = null;
    var sheetFooterTableObject = null;
	
	//2. 스크롤 보이기 여부에 따라 스크롤 관련 Div 높이, 너비 등 재계산 및 화면 적용
	// 수직스크롤
	if( this.isShowVScroll ){
		//수직스크롤 보이기 처리
		this.SheetVScrollObject.style.display = "block";
		
		//수평스크롤 보이기 여부에 따른 처리
		if( this.isShowHScroll ){
			//수평스크롤도 보이므로 시트 헤더 높이와 수평스크롤 높이만큼 수직스크롤 높이 감소
			(document.getElementsByName(this.controlId + "_SheetVScrollBody")[0]).style.height = "calc(100% - " + this.headerHeight + "px - " + this.hScrollHeight + ")";
		}
		else{
			//수평스크롤이 숨겨지므로 수직스크롤의 높이는 시트 헤더 높이만큼 수직스크롤 높이 감소
			(document.getElementsByName(this.controlId + "_SheetVScrollBody")[0]).style.height = "calc(100% - " + this.headerHeight + "px)";
		}
		
		//수직스크롤의 높이에 따른 수직스크롤 Track 높이 재설정
		this.vScrollTrackHeight = 1 * (getComputedStyle(document.getElementsByName(this.controlId + "_SheetVScrollTrack")[0]).height).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
	}
	else{
		//수직스크롤 숨기기 처리
		this.SheetVScrollObject.style.display = "none";
	}
	
	// 수평스크롤
	if( this.isShowHScroll ){
		//수평스크롤 보이기 처리
		this.SheetHScrollObject.style.display = "block";
		
		//수직스크롤 보이기 여부에 따른 처리
		if( this.isShowVScroll ){
			//수직스크롤도 보이므로 수평스크롤 너비만큼 수평스크롤 너비 감소
			this.SheetHScrollObject.style.width = "calc(100% - " + this.vScrollWidth + ")";
		}
		else{
			//수직스크롤이 숨겨지므로 수평스크롤 너비 100% 설정
			this.SheetHScrollObject.style.width = "100%";
		}
		//수평스크롤 너비에 따른 수평스크롤 Track 너비 재설정
		this.hScrollTrackWidth = 1 * (getComputedStyle(document.getElementsByName(this.controlId + "_SheetHScrollTrack")[0]).width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
	}
	else{
		//수평스크롤 숨기기 처리
		this.SheetHScrollObject.style.display = "none";
	}
	
	//3. 시트내 보이는 스크롤의 Face, 위치 재계산 및 화면 적용
	// 수직스크롤 : 수직스크롤의 Face 및 위치, 기타 속성 재계산, 화면 적용
	if( this.isShowVScroll ){
		var vScrollTrackMaxHeight = 0;
		var dataMaxRow = 0;
		
		this.vScrollFaceHeight = Math.round((this.vScrollTrackHeight * (this.sheetContentDivHeight / this.rowHeight)) / this.dataRowCount);
		
		if( this.vScrollFaceHeight < 12){
			this.vScrollFaceHeight = 12;
		}
		
		vScrollTrackMaxHeight = this.vScrollTrackHeight - this.vScrollFaceHeight;
		dataMaxRow = this.dataRowCount - this.wholeShownRowCount;
		
		this.vScrollFaceTop = Math.round(((this.showedTopRowIndex <= 0 ? 0 : this.showedTopRowIndex) * vScrollTrackMaxHeight) / dataMaxRow);
		
		//수직스크롤 Face 가 Track 을 넘는 경우 수직이동 최대값 위치로 이동
		if( this.vScrollTrackHeight < this.vScrollFaceTop + this.vScrollFaceHeight ){
			this.vScrollFaceTop = Math.floor(this.vScrollTrackHeight - this.vScrollFaceHeight);
		}
		
		//수직스크롤 Face 스타일 적용
		vScrollFaceObj = document.getElementsByName(this.controlId + "_SheetVScrollFace")[0];
		vScrollFaceObj.style.top = this.vScrollFaceTop + "px";
		vScrollFaceObj.style.height = this.vScrollFaceHeight + "px";
	}
	
	// 수평스크롤 : 수평스크롤의 Face 및 위치, 기타 속성 재계산, 화면 적용
	hScrollFaceObj = document.getElementsByName(this.controlId + "_SheetHScrollFace")[0];
	sheetHeaderTableObject = document.getElementsByName(this.controlId + "_SheetHeaderTable")[0];
    sheetContentTableObject = document.getElementsByName(this.controlId + "_SheetContentTable")[0];
	
	if( this.isShowHScroll ){
		//수평스크롤 Face 너비 재계산
		this.hScrollFaceWidth = (this.hScrollTrackWidth * this.sheetContentDivWidth) / this.sheetContentTableWidth;
		//수평스크롤 Face 이동시 시트 본문 테이블 이동 비율 재계산
		this.tableMovePerHScrollFaceMove = this.sheetContentDivWidth / this.hScrollFaceWidth;
		//수평스크롤 Face 위치 재계산
		this.hScrollFaceLeft = this.sheetHeaderTableLeft / this.tableMovePerHScrollFaceMove;
		//수평스크롤 Face 가 Track 을 넘는 경우 수평이동 최대 값 위치로 이동하고 시트 헤더 및 본문 Div 이동 위치 수정
		if( this.hScrollTrackWidth < this.hScrollFaceLeft + this.hScrollFaceWidth ){
			//스크롤 최대이동 처리
			this.hScrollFaceLeft = this.hScrollTrackWidth - this.hScrollFaceWidth;
			//헤더 최대이동 처리
			this.sheetHeaderTableLeft = this.sheetHeaderTableWidth - this.sheetHeaderDivWidth - 1;
			sheetHeaderTableObject.style.marginLeft = (Math.ceil(-1 * this.sheetHeaderTableLeft)) + 1 + "px";
			//본문 최대이동 처리
			this.sheetContentTableLeft = this.sheetHeaderTableWidth - this.sheetContentDivWidth - 1;
			sheetContentTableObject.style.marginLeft = (Math.ceil(-1 * this.sheetContentTableLeft) + 1) + "px";
			//푸터 최대이동 처리
			if( this.isShowFooter ){
				sheetFooterTableObject = this.SheetFooterObject.querySelector("div.SheetFooterDiv > table");
				sheetFooterTableObject.style.marginLeft = (Math.ceil(-1 * this.sheetContentTableLeft) + 1) + "px";
				sheetFooterTableObject = null;
			}
		}
		
		//수평스크롤 Face 스타일 적용
		hScrollFaceObj.style.left = this.hScrollFaceLeft + "px";
		hScrollFaceObj.style.width = this.hScrollFaceWidth + "px";
	}
	else{
		//수평스크롤 위치 0 으로 이동
		this.hScrollFaceLeft = 0;
		hScrollFaceObj.style.left = this.hScrollFaceLeft + "px";
		//시트 헤더 위치 0 으로 이동
		this.sheetHeaderTableLeft = 0;
		sheetHeaderTableObject.style.marginLeft = "0px";
		//시트 본문 위치 0 으로 이동
		this.sheetContentTableLeft = 0;
		sheetContentTableObject.style.marginLeft = "0px";
		//시트 푸터 위치 0 으로 이동
		if( this.isShowFooter ){
			sheetFooterTableObject = this.SheetFooterObject.querySelector("div.SheetFooterDiv > table");
			sheetFooterTableObject.style.marginLeft = "0px";
			sheetFooterTableObject = null;
		}
		
		//스크롤이 없는 경우 우측고정열 위치 재조정
		if( this.displayScrollBar && this.SheetHeaderRightFixObject != null && typeof this.SheetHeaderRightFixObject != "undefined" )
			this.SheetHeaderRightFixObject.style.left = (this.sheetHeaderTableWidth - this.sheetRightFixWidth - 1) + "px";
		if( this.displayScrollBar && this.SheetContentRightFixObject != null && typeof this.SheetContentRightFixObject != "undefined" )
			this.SheetContentRightFixObject.style.left = (this.sheetContentTableWidth - this.sheetRightFixWidth - 1) + "px";
		if( this.displayScrollBar && this.SheetFooterRightFixObject != null && typeof this.SheetFooterRightFixObject != "undefined" )
			this.SheetFooterRightFixObject.style.left = (this.sheetContentTableWidth - this.sheetRightFixWidth - 1) + "px";
	}
	
	//메모리 해제
	sheetContentTableObject = null;
	sheetHeaderTableObject = null;
	hScrollFaceObj = null;
	vScrollFaceObj = null;
};

EasySheetRenderer.prototype.resize = function(){
	//예외처리
	if( isNaN(this.wholeShownRowCount) ) return;
	
	var oldWholeShownRowCount = 0;
	var i = 0;
	
	//시트 스크롤 보이기 여부 설정(시트 내 잘리지 않는 레코드 수 계산 후 같다면 스크롤 설정 완료된 것 임)
	while(oldWholeShownRowCount != this.wholeShownRowCount){
		oldWholeShownRowCount = this.wholeShownRowCount;
		
		//컬럼 너비 재계산
		this._ResetShowScroll();
		
		//시트 본문 높이에 따른 시트 내 잘리지 않는 레코드 행수 재계산
		this.wholeShownRowCount = Math.floor(Math.floor(this.sheetContentDivHeight / this.rowHeight) / this.rowsPerDataRow);
		
		if( isNaN(this.wholeShownRowCount) ) return;
		else if( oldWholeShownRowCount != this.wholeShownRowCount ) continue;
		else break;
		
		//무한루프로 빠지는 것을 막기 위한 장치
		if( i < 5 ){ i++; } else { break; }
	}
	
	//컬럼 너비 수정
	this.resetColumnWidth();
	
	//시트 헤더 및 본문 테이블 너비 재설정
	this.sheetHeaderTableWidth = 1 * (getComputedStyle(document.getElementsByName(this.controlId + "_SheetHeaderTable")[0])).width.replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
	this.sheetContentTableWidth = 1 * (getComputedStyle(document.getElementsByName(this.controlId + "_SheetContentTable")[0])).width.replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
	if( this.sheetContentTableWidth == 0 ) this.sheetContentTableWidth = this.sheetHeaderTableWidth;
	
	//스크롤 재계산
	this.resetScroll();
};



EasySheetRenderer.prototype.setTopFrozenCount = function(rowCount){
	//예외처리
	if( typeof rowCount != "number" || rowCount < 0 )
		return;
	
	this.topFixRowCount = rowCount;
	
	this.update();
};

EasySheetRenderer.prototype.setSelectedRowIndex = function(rowNum){
	var oldRowIndex = null;
	var sheet = null;
	var result = true;
	
	//예외처리
	if( typeof rowNum != "number" || !(rowNum >= 0 && rowNum < this.dataRowCount) )
		return false;
	
	//기존 행 인덱스 기억
	oldRowIndex = this.selectedRowIndex;
	
	//행 인덱스에 변화가 없다면 더이상 동작하지 않음
	if( oldRowIndex == rowNum )
		return true;
	
	//행 인덱스 설정
	this.selectedRowIndex = rowNum;
	
	sheet = controls[this.controlName];
	//렌더러에서 시트를 찾지 못한 경우
	if( (typeof sheet == "undefined" || sheet == null) && !(typeof EasySheet != "undefined" && sheet instanceof EasySheet) ){
		return false;
	}
//	//시트 이벤트 : RowChange 호출(시작)
//	//시트 사용자 이벤트가 있는 경우
//	if( sheet.hasRowChangeEvent ){
//		//이벤트 호출
//		result = sheet.fncRowChangeEvent(oldRowIndex, rowNum);
//		
//		//시트 이벤트 : RowChange 사용자 추가 로직 동작까지 정상적으로 완료되지 않았다면 행의 인덱스를 이전으로 복구
//		if( typeof result == "boolean" && result === false ){
//			this.selectedRowIndex = oldRowIndex;
//		}
//	}
//	//시트 이벤트 : RowChange 호출(종료)
//	
//	//시트 이벤트 후속 처리
//	sheet._catchEvent({event: "rowChange", row: oldRowIndex, newRow: rowNum});
	
	//시트 이벤트 처리 및 후속 동작
	result = sheet._catchEvent({event: "rowChange", row: oldRowIndex, newRow: rowNum});
	if( result ){
		//시트 이벤트 : RowChange 사용자 추가 로직 동작까지 정상적으로 완료되었다면 해당 행이 화면내 보이도록 이동 
		result = this.moveToRow(rowNum);
	}
	else{
		//시트 이벤트 : RowChange 사용자 추가 로직 동작이 정상적으로 완료되지 않았다면 행 인덱스 복구
		this.selectedRowIndex = oldRowIndex;
	}
	
	//메모리 해제
	sheet = null;
	oldRowIndex = null;
	
	return result;
};

EasySheetRenderer.prototype.getSelectedRowIndex = function(){
	return this.selectedRowIndex;
};

EasySheetRenderer.prototype.setSelectedColumnIndex = function(colNum){
	var oldCellIndex = null;
	var sheet = null;
	var result = true;
	
	//예외처리
	if( typeof colNum != "number" || !(colNum >= 0 && colNum < this.columnInfo.length) )
		return false;
	
	//기존의 열 인덱스 기억
	oldCellIndex = this.selectedColumnIndex;
	
	//열 인덱스에 변화가 없다면 더이상 동작하지 않음
	if( oldCellIndex == colNum )
		return true;
	
	//열 인덱스 설정
	this.selectedColumnIndex = colNum;
	
	sheet = controls[this.controlName];
	//렌더러에서 시트를 찾지 못한 경우
	if( (typeof sheet == "undefined" || sheet == null) && !(typeof EasySheet != "undefined" && sheet instanceof EasySheet) ){
		return false;
	}
//	//시트 이벤트 : ColChange 호출(시작)
//	//시트 사용자 이벤트가 있는 경우
//	if( sheet.hasColChangeEvent ){
//		//이벤트 호출
//		result = sheet.fncColChangeEvent(oldCellIndex, colNum);
//		
//		//시트 이벤트 : ColChange 사용자 추가 로직 동작까지 정상적으로 완료되었다면 해당 행이 화면내 보이도록 이동 
//		if( result ){
//			result = this.moveToColumn(colNum);
//		}
//		//시트 이벤트 : ColChange 사용자 추가 로직 동작까지 정상적으로 완료되지 않았다면 행의 인덱스를 이전으로 복구
//		else{
//			this.selectedColumnIndex = oldCellIndex;
//		}
//	}
//	//시트 이벤트 : ColChange 호출(종료)
	
//	//시트 이벤트 후속 처리
//	sheet._catchEvent({event: "colChange", col: oldCellIndex, newCol: colNum});
	
	//시트 이벤트 처리 및 후속 동작
	result = sheet._catchEvent({event: "colChange", col: oldCellIndex, newCol: colNum});
	if( result ){
		//시트 이벤트 : ColChange 사용자 추가 로직 동작까지 정상적으로 완료되었다면 해당 행이 화면내 보이도록 이동
		result = this.moveToColumn(colNum);
	}
	else{
		//시트 이벤트 : ColChange 사용자 추가 로직 동작까지 정상적으로 완료되지 않았다면 행의 인덱스를 이전으로 복구
		this.selectedColumnIndex = oldCellIndex;
	}
	
	//메모리 해제
	sheet = null;
	oldCellIndex = null;
	
	return result;
};

EasySheetRenderer.prototype.getSelectedColumnIndex = function(){
	return this.selectedColumnIndex;
};

EasySheetRenderer.prototype.getCellObject = function(recordIndex, cellIndex){
	var maxRowCount = this.dataRowCount;
	var maxColCount = this.columnInfo.length;
	var cellObject = null;
	
	//예외처리
	if( typeof recordIndex != "number" || (recordIndex < 0 || recordIndex >= maxRowCount) )
		return null;
	if( typeof cellIndex != "number" || (cellIndex < 0 || cellIndex >= maxColCount) )
		return null;
	
	//셀이 좌측고정열 테이블 내 존재
	if( cellIndex < this.leftFixColumnCount )
		cellObject = this.SheetContentLeftFixObject.querySelector("table tr[recordindex='" + recordIndex + "'] > td[cellindex='" + cellIndex + "']");
	//셀이 우측고정열 테이블 내 존재
	else if( maxColCount - this.rightFixColumnCount <= cellIndex )
		cellObject = this.SheetContentRightFixObject.querySelector("table tr[recordindex='" + recordIndex + "'] > td[cellindex='" + cellIndex + "']");
	//셀이 본문 테이블 내 존재
	else
		cellObject = this.SheetContentObject.querySelector("div.SheetContentDiv > table tr[recordindex='" + recordIndex + "'] > td[cellindex='" + cellIndex + "']");
	
	//셀 객체 리턴
	return cellObject;
};

EasySheetRenderer.prototype.setRowClass = function(/*rowObject, className, doReset | rowIndex, className, doReset*/){
	var args = Array.prototype.slice.call(arguments);
	var row = null;
	var rowIndex = 0;
	var className = null;
	var doReset = true;
	
	//파라메터
	if( args.length == 3 ){
		row = args[0];
		className = args[1];
		doReset = args[2];
	}
	else{
		//메모리 해제
		args = null;
		return false;
	}
	
	//클래스가 string 이 아닌 경우, 예외처리
	if( typeof className != "string" ){
		//메모리 해제
		doReset = null; className = null; row = null; args = null;
		return false;
	}
	
	//row 가 object 인 경우, row 객체에서 행 인덱스를 구함
	if( typeof row == "object" && row.tagName.toLowerCase() == "tr" ){
		rowIndex = 1 * row.getAttribute("rowIndex");
	}
	//row 가 number 인 경우, 행 번호에서 행 인덱스를 구함
	else if( typeof row == "number" && (row >= 0 && row < this.displayMaxRowCount) ){
		rowIndex = 1 * row;
	}
	//row 가 number 와 object 둘 다 아닌 경우, 예외처리
	else{
		//메모리 해제
		doReset = null; className = null; row = null; args = null;
		return false;
	}
	
	//본문, 좌측고정, 우측고정 테이블을 구함
	var table = document.getElementsByName(this.controlId + "_SheetContentTable")[0];
	var leftFixTable = document.getElementsByName(this.controlId + "_SheetContentLeftFixTable")[0];
	var rightFixTable = document.getElementsByName(this.controlId + "_SheetContentRightFixTable")[0];
	var rows = null; var leftFixRows = null; var rightFixRows = null;
	var rowObj = null; var leftFixRow = null; var rightFixRow = null;
	var classItems = null; var classStr = null;
	var rowCount = 0; var classCount = 0;
	var i = 0; var j = 0;

	//각 테이블이 존재할 경우, 각 테이블에서 행 인덱스에 해당하는 행 객체를 구함
	if( table != null && typeof table != "undefined" ){
		rows = table.querySelectorAll("tr[rowindex='" + rowIndex + "']");
	}
	if( leftFixTable != null && typeof leftFixTable != "undefined" ){
		leftFixRows = leftFixTable.querySelectorAll("tr[rowindex='" + rowIndex + "']");
	}
	if( rightFixTable != null && typeof rightFixTable != "undefined" ){
		rightFixRows = rightFixTable.querySelectorAll("tr[rowindex='" + rowIndex + "']");
	}
	
	//행 객체에 클래스 설정
	if( doReset === true ){
		//기존 class 속성을 초기화하고 클래스 적용
		if( rows != null && (rowCount = rows.length) > 0 ){
			for(i = 0; i < rowCount; i++, rowObj = null){
				rowObj = rows[i];
				rowObj.setAttribute("class", className);
			}
		}
		if( leftFixRows != null && (rowCount = leftFixRows.length) > 0 ){
			for(i = 0; i < rowCount; i++, leftFixRow = null){
				leftFixRow = leftFixRows[i];
				leftFixRow.setAttribute("class", className);
			}
		}
		if( rightFixRows != null && (rowCount = rightFixRows.length) > 0 ){
			for(i = 0; i < rowCount; i++, rightFixRow = null){
				rightFixRow = rightFixRows[j];
				rightFixRow.setAttribute("class", className);
			}
		}
	}
	else{
		//기존 class 속성에 클래스 추가
		classItems = className.replace(/\s+/g, " ").split(" ");
		
		//클래스 리스트에서 객체가 갖고 있지 않은 클래스만 적용
		for(i = 0, classCount = classItems.length; i < classCount; i++, classStr = null){
			classStr = classItems[i];
			
			if( rows != null && (rowCount = rows.length) > 0 ){
				for(j = 0; j < rowCount; j++, rowObj = null){
					rowObj = rows[j];
					if( this.hasClass(rowObj, classStr) <= 0 ) this.addClass(rowObj, classStr);
				}
			}
			if( leftFixRows != null && (rowCount = leftFixRows.length) > 0 ){
				for(j = 0; j < rowCount; j++, leftFixRow = null){
					leftFixRow = leftFixRows[j];
					if( this.hasClass(leftFixRow, classStr) <= 0 ) this.addClass(leftFixRow, classStr);
				}
			}
			if( rightFixRows != null && (rowCount = rightFixRows.length) > 0 ){
				for(j = 0; j < rowCount; j++, rightFixRow = null){
					rightFixRow = rightFixRows[j];
					if( this.hasClass(rightFixRow, classStr) <= 0 ) this.addClass(rightFixRow, classStr);
				}
			}
		}
		
		//메모리 해제
		classItems = null;
	}

	//메모리 해제
	rightFixRow = null; leftFixRow = null; rowObj = null;
	rightFixTable = null; leftFixTable = null; table = null;
	doReset = null; row = null; className = null; args = null;
	
	return true;
};

EasySheetRenderer.prototype.setCellClass = function(/*cellObject, className, doReset | rowIndex, colIndex, className, doReset*/){
	var args = Array.prototype.slice.call(arguments);
	var result = true;
	var row = null;
	var col = null;
	var doReset = null;
	var cell = null;
	var className = null;
	var classItems = null;
	var i = null;
	
	if( args.length == 3 ){
		//파라메터 2개 : 셀 객체, 클래스
		cell = args[0];
		className = args[1];
		doReset = args[2];
		//파라메터 데이터 체크
		if( !(typeof cell == "object" && cell.tagName.toLowerCase() == "td") ) result = false;
	}
	else if( args.length == 4 ){
		//파라메터 3개 : 행번호, 열번호, 클래스
		row = args[0];
		col = args[1];
		className = args[2];
		doReset = args[3];
		//파라메터 데이터 체크
		if( !(typeof row == "number" && (row >= 0 && row < this.displayMaxRowCount)) ) result = false;
		if( !(typeof col == "number" && (col >= 0 && col < this.columnInfo.length)) ) result = false;
	}
	else{
		result = false;
	}
	
	//파라메터 예외처리
	if( result === false ){
		//메모리 해제
		row = null; col = null; cell = null; className = null; result = null;
		return false;
	}
	
	//클래스가 string 이 아닌 경우, 예외처리
	if( typeof className != "string" ){
		//메모리 해제
		doReset = null; className = null; row = null; args = null;
		return false;
	}
	
	//행번호, 열번호로 파라메터가 전달된 경우, 셀 객체 구함
	if( row != null && col != null && cell == null ){
		cell = this.getCellObject(row, col);
	}
	
	//셀 객체에 클래스 적용
	if( doReset === true ){
		this.setClass(cell, className);
	}
	else{
		//기존 class 속성에 클래스 추가
		classItems = className.replace(/\s+/g, " ").split(" ");
		//클래스 리스트에서 객체가 갖고 있지 않은 클래스만 적용
		for(var i = 0; i < classItems.length; i++){
			if( this.hasClass(cell, classItems[i]) <= 0 )
				this.addClass(cell, classItems[i]);
		}
	}
	
	//메모리 해제
	cell = null; classItems = null; className = null; col = null; row = null; result = null;
	
	return true;
};

EasySheetRenderer.prototype.setSelectionClass = function(/*cellObject | rowIndex, colIndex*/){
	var args = Array.prototype.slice.call(arguments);
	var result = true;
	var cell = null;
	var row = null;
	var col = null;
	
	if( args.length == 1 ){
		//파라메터 1개 : 셀 객체
		cell = args[0];
	}
	else if( args.length == 2 ){
		//파라메터 2개 : 행번호, 열번호
		row = args[0];
		col = args[1];
		cell = this.getCellObject(row, col);
	}
	
	//파라메터 예외처리
	if( cell == null && !(cell != null && typeof cell == "object" && cell.tagName.toLowerCase() == "td") ){
		//메모리 해제
		row = null; col = null; cell = null; result = null; args = null;
		return false;
	}
	
	var rowObject = null;
	var cellObject = null;
	
	//
	if( this.selectedObject != null ){
		//
		cellObject = this.selectedObject;
		if( this.hasClass(cellObject, "selected-col") > 0 ){
			this.removeClass(cellObject, "selected-col");
		}
		//
		cellObject = null;
		
		//
		rowObject = this.selectedObject.parentNode;
		if( this.hasClass(rowObject, "selected-row") > 0 ){
			this.setRowClass(rowObject, this.getClass(rowObject).replace("selected-row", "").replace(/\s+/g, " "), true);
		}
		//
		rowObject = null;
		
		//
		this.selectedObject = null;
	}
	
	//시트 선택 모드가 SHEET_SELECT_NONE(선택 안함) 인 경우 더이상 처리하지 않음
	if( this.selectMode == SHEET_SELECT_CELL ){
		cellObject = cell;
		//
		if( this.hasClass(cellObject, "selected-col") <= 0 ){
			this.setCellClass(cellObject, "selected-col", false);
		}
		//
		cellObject = null;
	}
	else if( this.selectMode == SHEET_SELECT_ROW ){
		rowObject = cell.parentNode;
		//
		if( this.hasClass(rowObject, "selected-row") <= 0 ){
			this.setRowClass(rowObject, "selected-row", false);
		}
		//
		rowObject = null;
	}
	
	//
	this.selectedObject = cell;
	
	//메모리 해제
	row = null; col = null; cell = null; result = null; args = null;
	
	return true;
};

EasySheetRenderer.prototype.hasClass = function(object, className){
	var classCount = -1;
	
	//예외처리
	if( object == null || typeof object != "object" ){
		return classCount;
	}
	if( typeof className != "string" ){
		return classCount;
	}
	
	var classStr = null;
	var classList = null;
	var classIndex = 0;
	var i = 0;
	
	//클래스 속성 구함
	classStr = object.getAttribute("class");
	
	//찾을 클래스명 공백 제거(클래스는 1개만 찾을 수 있음)
	className = className.replace(/\s+/g, " ");
	
	if( typeof classStr == "string" ){
		classStr = classStr.replace(/\s+/g, " ");
		classList = classStr.split(" ");
		
		//클래스 존재유무 체크
		classIndex = classList.indexOf(className);
		//classIndex 가 0보다 크거나 같다면 해당 클래스가 존재, 0보다 작다면 해당 클래스는 존재하지 않음
		classCount = (classIndex >= 0) ? 1 : 0;
		
		//메모리 해제
		classList = null;
	}
	else{
		//객체에 클래스 속성이 없으므로 해당 클래스는 존재하지 않음
		classCount = 0;
	}
	
	//메모리 해제
	classStr = null;
	
	return classCount;
};

EasySheetRenderer.prototype.getClass = function(object){
	//예외처리
	if( object == null || typeof object != "object" ){
		return null;
	}
	
	var classStr = null;
	
	classStr = object.getAttribute("class");
	classStr = (classStr != null && typeof classStr == "string" && classStr.length > 0) ? classStr : "";
	
	return classStr;
};

EasySheetRenderer.prototype.setClass = function(object, className){
	//예외처리
	if( object == null || typeof object != "object" ){
		return false;
	}
	if( typeof className != "string" ){
		return false;
	}
	
	object.setAttribute("class", className.replace(/(^\s*)|(\s*$)/g, ""));
	
	return true;
};

EasySheetRenderer.prototype.addClass = function(object, className){
	//예외처리
	if( object == null || typeof object != "object" ){
		return false;
	}
	if( typeof className != "string" ){
		return false;
	}
	if( this.hasClass(object, className) > 0 ){
		return true;
	}
	
	var classStr = object.getAttribute("class");
	
	if( typeof classStr == "string" && classStr.length > 0 ){
		//클래스 추가
		classStr = className + " " + classStr;
		
		//클래스 문자열 2개 이상 공백 1개로 변경
		classStr = classStr.replace(/\s+/g, " ");
		//클래스 문자열의 양 끝 공백 제거
		classStr = classStr.replace(/(^\s*)|(\s*$)/g, "");
		
		//추가된 클래스 적용
		object.setAttribute("class", classStr);
	}
	else{
		//클래스 적용
		object.setAttribute("class", className);
	}
	
	classStr = null;
	
	return true;
};

EasySheetRenderer.prototype.removeClass = function(object, className){
	//예외처리
	if( object == null || typeof object != "object" ){
		return false;
	}
	if( typeof className != "string" ){
		return false;
	}
	
	var classStr = null;
	var classList = null;
	var removeList = null;
	var removeItem = null;
	var removeCount = 0;
	var classIndex = -1;
	var i = 0;
	
	classStr = object.getAttribute("class");
	classStr = classStr.replace(/\s+/g, " ");
	
	if( typeof classStr == "string" && classStr.length > 0 ){
		//삭제할 클래스
		className = className.replace(/\s+/g, " ");
		removeList = className.split(" ");
		removeCount = removeList.length;
		
		//현재 태그의 클래스
		classList = classStr.split(" ");
		classStr = null;
		
		//클래스 제거
		for(i = 0; i < removeCount; i++, classIndex = -1, removeItem = null){
			removeItem = removeList[i];
			//클래스 존재유무 체크
			classIndex = classList.indexOf(removeItem);
			//클래스가 있다면 클래스 제거
			if( classIndex >= 0 ) classList[classIndex] = "";
		}
		
		//제거한 후 클래스 명 결합 
		classStr = classList.join(" ");
		//클래스 문자열 2개 이상 공백 1개로 변경
		classStr = classStr.replace(/\s+/g, " ");
		//클래스 문자열의 양 끝 공백 제거
		classStr = classStr.replace(/(^\s*)|(\s*$)/g, "");
		
		//클래스 적용
		object.setAttribute("class", classStr);
		
		//메모리 해제
		classList = null;
		removeList = null;
	}
	
	//메모리 해제
	classStr = null;
	
	return true;
};





EasySheetRenderer.prototype.setCellHAlign = function(colIndex, cellObject, align){
	//예외처리
	if( typeof colIndex != "number" || !(colIndex >= 0 && colIndex < this.columnInfo.length) )
		return false;
	if( cellObject == null || typeof cellObject == "undefined" || cellObject.tagName.toLowerCase() != "td" ){
		return false;
	}
	
	if( typeof align == "undefined" ){
		align = this.columnInfo[colIndex].align;
	}
	
	cellObject.style.textAlign = align;
	
	return true;
};

EasySheetRenderer.prototype.setCellVAlign = function(colIndex, cellObject, valign){
	//예외처리
	if( typeof colIndex != "number" || !(colIndex >= 0 && colIndex < this.columnInfo.length) )
		return false;
	if( cellObject == null || typeof cellObject == "undefined" || cellObject.tagName.toLowerCase() != "td" ){
		return false;
	}
	
	if( typeof valign == "undefined" ){
		valign = this.columnInfo[colIndex].valign;
	}
	
	cellObject.style.verticalAlign = valign;
	
	return true;
};

EasySheetRenderer.prototype.setCellTooltip = function(colIndex, cellObject, value){
	//예외처리
	if( typeof colIndex != "number" || !(colIndex >= 0 && colIndex < this.columnInfo.length) )
		return false;
	if( cellObject == null || typeof cellObject == "undefined" || cellObject.tagName.toLowerCase() != "td" ){
		return false;
	}
	
	if( typeof value == "undefined" ){
		value = "";
	}
	
	if( this.columnInfo[colIndex].showColumnTooltip === true ){
		cellObject.setAttribute("title", value);
	}
	else{
		cellObject.setAttribute("title", "");
		cellObject.removeAttribute("title");
	}
	
	return true;
};

EasySheetRenderer.prototype.setCellBackgroundColor = function(colIndex, cellObject, backgroundColor){
	//예외처리
	if( typeof colIndex != "number" || !(colIndex >= 0 && colIndex < this.columnInfo.length) )
		return false;
	if( cellObject == null || typeof cellObject == "undefined" || cellObject.tagName.toLowerCase() != "td" ){
		return false;
	}
	
	if( typeof backgroundColor == "undefined" ){
		backgroundColor = this.columnInfo[colIndex].backgroundColor;
	}
	
	cellObject.style.backgroundColor = backgroundColor;
	
	return true;
};

EasySheetRenderer.prototype.setCellFontColor = function(colIndex, cellObject, fontColor){
	//예외처리
	if( typeof colIndex != "number" || !(colIndex >= 0 && colIndex < this.columnInfo.length) )
		return false;
	if( cellObject == null || typeof cellObject == "undefined" || cellObject.tagName.toLowerCase() != "td" ){
		return false;
	}
	
	if( typeof fontColor == "undefined" ){
		fontColor = this.columnInfo[colIndex].fontColor;
	}
	
	cellObject.style.color = fontColor;
	
	return true;
};


EasySheetRenderer.prototype.setCellTypeButton = function(colIndex, tagObject, caption){
	var buttonObjects = null;
	var buttonObject = null;
	var imageObj = null;
	
	//예외처리
	if( typeof colIndex != "number" || !(colIndex >= 0 && colIndex < this.columnInfo.length) )
		return false;
	if( tagObject == null || typeof tagObject == "undefined"){
		return false;
	}
	
	var buttonType = this.columnInfo[colIndex].buttonType;
	
	//redraw 함수에서 사용 : 셀의 div 객체가 파라메터로 전달된 경우 div 객체에 버튼 태그가 존재하는지 확인하여 없으면 생성
	if( tagObject.tagName.toLocaleLowerCase() == "div" ){
		buttonObjects = tagObject.getElementsByTagName("button");
		
		//버튼 태그가 없는 경우 버튼 생성
		if( buttonObjects.length <= 0 ){
			//태그 안의 모든 자식 노드를 제거한 뒤 이미지 추가
			while( tagObject.lastChild ) tagObject.removeChild(tagObject.lastChild);
			
			//버튼 생성
			buttonObject = document.createElement("button");
			buttonObject.setAttribute("class", "SheetCellButton");
			buttonObject.setAttribute("onmouseup", "return sheetButtonClick();");
			buttonObject.style.height = (this.rowHeight - 10) + "px";
			//버튼 추가
//			tagObject.style.textAlign = "center";
			tagObject.appendChild(buttonObject);
		}
		else{
			buttonObject = buttonObjects[0];
			buttonObject.style.background = "";
			buttonObject.style.height = (this.rowHeight - 10) + "px";
		}
	}
	//setData 함수에서 사용
	else if( tagObject.tagName.toLocaleLowerCase() == "button" ){
		buttonObject = tagObject;
	}
	//파라메터 태그 객체가 올바르지 않음
	else{
		//메모리 해제
		buttonObject = null;
		buttonObjects = null;
		
		return false;
	}
	
	//캡션 설정
	caption = (caption != null && typeof caption != "undefined") ? caption : "";
	
	var buttonIcon = this.columnInfo[colIndex].buttonIcon;
	buttonIcon = (buttonIcon != null && typeof buttonIcon != "undefined") ? buttonIcon : "";
	
	//버튼 타입 설정
	if( buttonType == "image" && this.showedTopRowIndex >= 0 ){
		//이미지 버튼 스타일 설정
		buttonObject.style.background = "url('" + caption + "') center center no-repeat";
		buttonObject.style.border = "0px none";
		buttonObject.innerText = "";
	}
	else{
		var iconObjectb = null;
		//텍스트 버튼 스타일 설정
		if( buttonIcon.length > 0 ){
			if( (iconObject = buttonObject.querySelector("i")) == null ){
				iconObject = document.createElement("i");
				buttonObject.appendChild(iconObject);
			}
			iconObject.setAttribute("class", buttonIcon);
			iconObject.innerText = caption;
		}
		else{
			if( (iconObject = buttonObject.querySelector("i")) != null ){
				buttonObject.removeChild(iconObject);
			}
			buttonObject.innerText = caption;
		}
		buttonObject.style.lineHeight = (this.rowHeight - 10 - 2) + "px";
		//메모리 해제
		iconObject = null;
	}

	//메모리 해제
	caption = null;
	buttonObject = null;
	buttonObjects = null;
	buttonIcon = null;
	buttonType = null;
	
	return true;
};

EasySheetRenderer.prototype.setCellTypeLink = function(colIndex, tagObject, caption){
	var anchorObjects = null;
	var anchorObject = null;
	
	//예외처리
	if( typeof colIndex != "number" || !(colIndex >= 0 && colIndex < this.columnInfo.length) )
		return false;
	if( tagObject == null || typeof tagObject == "undefined"){
		return false;
	}
	
	//redraw 함수에서 사용 : 셀의 div 객체가 파라메터로 전달된 경우 div 객체에 링크 태그가 존재하는지 확인하여 없으면 생성
	if( tagObject.tagName.toLocaleLowerCase() == "div" ){
		anchorObjects = tagObject.getElementsByTagName("a");
		
		//링크 태그가 없는 경우 버튼 생성
		if( anchorObjects.length <= 0 ){
			//태그 안의 모든 자식 노드를 제거한 뒤 이미지 추가
			while( tagObject.lastChild ) tagObject.removeChild(tagObject.lastChild);
			
			//링크 생성
			anchorObject = document.createElement("a");
			anchorObject.setAttribute("class", "SheetCellLink");
			anchorObject.setAttribute("target", "_blank");
//			anchorObject.setAttribute("href", "javascript: ;");
			anchorObject.setAttribute("onmouseup", "sheetLinkMouseUp();");
			anchorObject.setAttribute("onclick", "return sheetLinkClick(this);");
			//링크 추가
			tagObject.appendChild(anchorObject);
		}
		else{
			anchorObject = anchorObjects[0];
		}
	}
	//setData 함수에서 사용
	else if( tagObject.tagName.toLocaleLowerCase() == "a" ){
		anchorObject = tagObject;
	}
	//파라메터 태그 객체가 올바르지 않음
	else{
		//메모리 해제
		anchorObject = null;
		anchorObjects = null;
		
		return false;
	}

	//링크 타이틀 설정
	anchorObject.innerHTML = ("" + caption);

	//메모리 해제
	anchorObject = null;
	anchorObjects = null;
	
	return true;
};

EasySheetRenderer.prototype.setCellTypeImage = function(colIndex, tagObject, src, alt){
	var imageObjects = null;
	var imageObject = null;
	var align = null;
	
	//예외처리
	if( typeof colIndex != "number" || !(colIndex >= 0 && colIndex < this.columnInfo.length) )
		return false;
	if( tagObject == null || typeof tagObject == "undefined"){
		return false;
	}
	
	//redraw 함수에서 사용 : 셀의 div 객체가 파라메터로 전달된 경우 div 객체에 이미지 태그가 존재하는지 확인하여 없으면 생성
	if( tagObject.tagName.toLocaleLowerCase() == "div" ){
		imageObjects = tagObject.getElementsByTagName("img");
		
		//이미지 태그가 없는 경우 이미지 생성
		if( imageObjects.length <= 0 ){
			//태그 안의 모든 자식 노드를 제거한 뒤 이미지 추가
			while( tagObject.lastChild ) tagObject.removeChild(tagObject.lastChild);
			
			//이미지 생성
			imageObject = document.createElement("img");
			imageObject.setAttribute("class", "SheetCellImage");
			imageObject.setAttribute("onmouseup", "return sheetImageMouseUp();");
			imageObject.setAttribute("onmouseover", "return sheetImageMouseOver(this);");
			imageObject.setAttribute("onmouseout", "return sheetImageMouseOut();");
			imageObject.style.height = (this.rowHeight - 2) + "px";
			//이미지 추가
			tagObject.appendChild(imageObject);
		}
		else{
			imageObject = imageObjects[0];
		}
	}
	//setData 함수에서 사용
	else if( tagObject.tagName.toLocaleLowerCase() == "img" ){
		imageObject = tagObject;
	}
	//파라메터 태그 객체가 올바르지 않음
	else{
		//메모리 해제
		imageObject = null;
		imageObjects = null;
		
		return false;
	}
	//src 설정
	if( src == null || typeof src == "undefined" || (typeof src == "string" && ("" + src).length <= 0) ){
		src = this.columnInfo[colIndex].defalutValue;
		//컬럼의 defalutValue 도 없는 경우
		if( typeof this.columnInfo[colIndex].defalutValue == "string" && this.columnInfo[colIndex].defalutValue.length <= 0 ){
			src = "winnersoft/images/picture/blank.gif";
		}
	}
	//alt 설정
	if( alt == null ){
		alt = this.columnInfo[colIndex].altCaption;
	}

	//이미지 속성 설정
	imageObject.setAttribute("src", src);
	imageObject.setAttribute("alt", alt);
	imageObject.style.display = (src.length > 0) ? "block" : "none";
	
	//이미지 좌우정렬
	align = this.columnInfo[colIndex].align;
	if( align == "center" ){
		imageObject.style.margin = "auto";
		imageObject.style.float = "";
	}
	else if( align == "right" ){
		imageObject.style.margin = "";
		imageObject.style.float = "right";
	}
	else{
		imageObject.style.margin = "";
		imageObject.style.float = "left";
	}

	//메모리 해제
	imageObject = null;
	imageObjects = null;
	
	return true;
};

EasySheetRenderer.prototype.setCellTypeText = function(divObjectInCell){
	//예외처리
	if( typeof divObjectInCell == "undefined" || divObjectInCell == null ){
		//파라메터가 전달되지 않은 경우
		return false;
	}
	if( divObjectInCell.tagName.toLowerCase() != "div" && divObjectInCell.parentNode.tagName.toLowerCase() != "td" ){
		//파라메터로 전달된 객체가 셀 안의 div 객체가 아닌 경우
		return false;
	}
	
	var cellWidth = null;
	var cellValue = null;
	
	var rowObject = null;
	var rowIndex = 0;
	
	var hasRowSpan = 0;
	var rowHeight = 0;
	
	var inputCtrl = null;
	var inputableMaxLength = null; 
	
//	rowIndex = this.selectedRowIndex - this.showedTopRowIndex;
//	if( rowIndex >= this.topFixRowCount ) rowIndex = rowIndex + this.topFixRowCount;
	rowObject = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentDiv > table#" + this.controlId + "_SheetContentTable tr[recordindex='" + this.selectedRowIndex + "']");
	if( rowObject != null ) rowIndex = (1 * rowObject.getAttribute("rowIndex"));
	
//	cellWidth = ((this.columnInfo[this.selectedColumnIndex].isSameMinWidth ? this.columnInfo[this.selectedColumnIndex].calcCellWidth : this.columnInfo[this.selectedColumnIndex].calcInnerDivWidth) - 1) + "px";
	cellWidth = (this.columnInfo[this.selectedColumnIndex].isSameMinWidth ? this.columnInfo[this.selectedColumnIndex].calcCellWidth - 1 : this.columnInfo[this.selectedColumnIndex].calcInnerDivWidth) + "px";
//	cellValue = (this.data[this.selectedRowIndex - this.showedTopRowIndex])[this.columnInfo[this.selectedColumnIndex].field];
	cellValue = (this.data[rowIndex])[this.columnInfo[this.selectedColumnIndex].field];
	inputableMaxLength = this.columnInfo[this.selectedColumnIndex].maxLength;
	
	//셀 내 div 를 임시 보관 div 로 이동
	this.SheetControlTempDivObject.appendChild(divObjectInCell);
	//편집 텍스트박스 이동
	this.editingCellObject.appendChild(this.SheetEidtTextDivObject);
	//셀 높이 체크
	hasRowSpan = ((1 * this.editingCellObject.getAttribute("rowspan")) > 0);
	rowHeight = hasRowSpan ? 1 * ("" + getComputedStyle(this.editingCellObject).height).replace("px", "") : this.rowHeight;
	//편집 텍스트박스 스타일 설정
	this.SheetEidtTextDivObject.style.display = "block";
	this.SheetEidtTextDivObject.style.width = cellWidth;
//	this.SheetEidtTextDivObject.style.height = (this.rowHeight - 1) + "px";
	this.SheetEidtTextDivObject.style.height = (rowHeight - 1) + "px";
	//편집 텍스트박스에 셀 내 데이터 출력
	inputCtrl = this.SheetEidtTextDivObject.getElementsByTagName("input")[0];
	if( inputableMaxLength < 0 ) inputCtrl.setAttribute("maxlength", "");
	else						 inputCtrl.setAttribute("maxlength", inputableMaxLength);
	inputCtrl.value = (typeof cellValue != "undefined" && ("" + cellValue).length > 0) ? cellValue : this.columnInfo[this.selectedColumnIndex].defalutValue;
	inputCtrl.select();
	//편집 텍스트박스로 포커스 이동
	inputCtrl.focus();
	
	//메모리 해제
	inputCtrl = null;
	inputableMaxLength = null;
	rowObject = null;
	cellWidth = null;
	cellValue = null;
	
	return true;
};

EasySheetRenderer.prototype.setCellTypeCheckbox = function(divObjectInCell){
	//예외처리
	if( typeof divObjectInCell == "undefined" || divObjectInCell == null ){
		//파라메터가 전달되지 않은 경우
		return false;
	}
	if( divObjectInCell.tagName.toLowerCase() != "div" && divObjectInCell.parentNode.tagName.toLowerCase() != "td" ){
		//파라메터로 전달된 객체가 셀 안의 div 객체가 아닌 경우
		return false;
	}
	
	var cellValue = null;
	var cellWidth = null;
	
	var rowObject = null;
	var rowIndex = 0;
	
	cellWidth = ((this.columnInfo[this.selectedColumnIndex].isSameMinWidth ? this.columnInfo[this.selectedColumnIndex].calcCellWidth : this.columnInfo[this.selectedColumnIndex].calcInnerDivWidth) - 1) + "px";
	
//	rowIndex = this.selectedRowIndex - this.showedTopRowIndex;
//	if( rowIndex >= this.topFixRowCount ) rowIndex = rowIndex + this.topFixRowCount;
	rowObject = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentDiv > table#" + this.controlId + "_SheetContentTable tr[recordindex='" + this.selectedRowIndex + "']");
	if( rowObject != null ) rowIndex = (1 * rowObject.getAttribute("rowIndex"));
	
	//셀 내 div 를 임시 보관 div 로 이동
	this.SheetControlTempDivObject.appendChild(divObjectInCell);
	//편집 체크박스 이동
	this.editingCellObject.appendChild(this.SheetEidtCheckDivObject);
	//셀 높이 체크
	hasRowSpan = ((1 * this.editingCellObject.getAttribute("rowspan")) > 0);
	rowHeight = hasRowSpan ? 1 * ("" + getComputedStyle(this.editingCellObject).height).replace("px", "") : this.rowHeight;
	//편집 체크박스 스타일 설정
	this.SheetEidtCheckDivObject.style.textAlign = this.columnInfo[this.selectedColumnIndex].align;
	this.SheetEidtCheckDivObject.style.width = cellWidth;
//	this.SheetEidtCheckDivObject.style.height = (this.rowHeight - 2 - (IS_IE_BROWSER ? 2 : 1)) + "px";
	this.SheetEidtCheckDivObject.style.height = (rowHeight - 1) + "px";
	this.SheetEidtCheckDivObject.style.lineHeight = ((rowHeight - 1) - 4) + "px";
//	this.SheetEidtCheckDivObject.style.display = "table-cell";
//	this.SheetEidtCheckDivObject.style.verticalAlign = this.columnInfo[this.selectedColumnIndex].valign;
	this.SheetEidtCheckDivObject.style.display = "block";
	//편집 체크박스 셀 내 데이터 출력
	cellValue = ((this.data[rowIndex])[this.columnInfo[this.selectedColumnIndex].field]);
	this.SheetEidtCheckDivObject.setAttribute("originval", (typeof cellValue !== "undefined" ? cellValue : ""));
	this.SheetEidtCheckDivObject.innerHTML = this.getDisplayValueByCellType(this.selectedColumnIndex, cellValue);
	
//	var checkObject = this.SheetEidtCheckDivObject.querySelector("span");
//	if( checkObject == null ){
//		checkObject = document.createElement("span");
//		this.SheetEidtCheckDivObject.appendChild(checkObject);
//	}
//	checkObject.setAttribute("class", this.getDisplayValueByCellType(this.selectedColumnIndex, cellValue));
//	checkObject = null;
	
	//편집 체크박스로로 포커스 이동
	this.SheetEidtCheckDivObject.focus();
	
	//메모리 해제
	rowObject = null;
	cellValue = null;
	cellWidth = null;
	
	return true;
};

EasySheetRenderer.prototype.setCellTypeDateTime = function(divObjectInCell){
	//예외처리
	if( typeof divObjectInCell == "undefined" || divObjectInCell == null ){
		//파라메터가 전달되지 않은 경우
		return false;
	}
	if( divObjectInCell.tagName.toLowerCase() != "div" && divObjectInCell.parentNode.tagName.toLowerCase() != "td" ){
		//파라메터로 전달된 객체가 셀 안의 div 객체가 아닌 경우
		return false;
	}
	
	var cellValue = null;
	var cellWidth = null;
	var calrenderBtn = null;
	
	var rowObject = null;
	var rowIndex = 0;
	
	var hasRowSpan = 0;
	var rowHeight = 0;
	
	cellWidth = (this.columnInfo[this.selectedColumnIndex].isSameMinWidth ? this.columnInfo[this.selectedColumnIndex].calcCellWidth - 1 : this.columnInfo[this.selectedColumnIndex].calcInnerDivWidth) + "px";
	
//	rowIndex = this.selectedRowIndex - this.showedTopRowIndex;
//	if( rowIndex >= this.topFixRowCount ) rowIndex + this.topFixRowCount;
	rowObject = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentDiv > table#" + this.controlId + "_SheetContentTable tr[recordindex='" + this.selectedRowIndex + "']");
	if( rowObject != null ) rowIndex = (1 * rowObject.getAttribute("rowIndex"));
	
	//셀 내 div 를 임시 보관 div 로 이동
	this.SheetControlTempDivObject.appendChild(divObjectInCell);
	//편집 일자(날짜) 텍스트박스 이동
	this.editingCellObject.appendChild(this.SheetEidtDateDivOBject);
	//셀 높이 체크
	hasRowSpan = ((1 * this.editingCellObject.getAttribute("rowspan")) > 0);
	rowHeight = hasRowSpan ? 1 * ("" + getComputedStyle(this.editingCellObject).height).replace("px", "") : this.rowHeight;
	//편집 일자(날짜) 텍스트박스 스타일 설정
	this.SheetEidtDateDivOBject.style.display = "block";
	this.SheetEidtDateDivOBject.style.width = cellWidth;
//	this.SheetEidtDateDivOBject.style.height = this.rowHeight + "px";
	this.SheetEidtDateDivOBject.style.height = (rowHeight - 1) + "px";
	calrenderBtn = this.SheetEidtDateDivOBject.getElementsByTagName("div")[0];
	calrenderBtn.style.lineHeight = getComputedStyle(calrenderBtn).height;
	//편집 일자(날짜) 텍스트박스에 셀 내 데이터 출력
//	cellValue = (this.data[this.selectedRowIndex - this.showedTopRowIndex])[this.columnInfo[this.selectedColumnIndex].field];
	cellValue = (this.data[rowIndex])[this.columnInfo[this.selectedColumnIndex].field];
	this.SheetEidtDateDivOBject.getElementsByTagName("input")[0].value = (typeof cellValue != "undefined") ? cellValue : this.columnInfo[this.selectedColumnIndex].defalutValue;
	this.SheetEidtDateDivOBject.getElementsByTagName("input")[0].select();
	//편집 일자(날짜) 텍스트박스로 포커스 이동
	this.SheetEidtTextDivObject.getElementsByTagName("input")[0].focus();
	
	//메모리 해제
	rowObject = null;
	calrenderBtn = null;
	cellValue = null;
	cellWidth = null;
	
	return true;
};

EasySheetRenderer.prototype.setCellTypeCombobox = function(divObjectInCell){
	//예외처리
	if( typeof divObjectInCell == "undefined" || divObjectInCell == null ){
		//파라메터가 전달되지 않은 경우
		return false;
	}
	if( divObjectInCell.tagName.toLowerCase() != "div" && divObjectInCell.parentNode.tagName.toLowerCase() != "td" ){
		//파라메터로 전달된 객체가 셀 안의 div 객체가 아닌 경우
		return false;
	}
	
	var cellValue = null;
	var cellWidth = null;
	
	var rowObject = null;
	var rowIndex = 0;
	
	var comboboxObject = null;
	var dataList = null;
	var comboData = null;
	var optionListStr = "";
	var selectedIndex = -1;
	
//	rowIndex = this.selectedRowIndex - this.showedTopRowIndex;
//	if( rowIndex >= this.topFixRowCount ) rowIndex + this.topFixRowCount;
	rowObject = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentDiv > table#" + this.controlId + "_SheetContentTable tr[recordindex='" + this.selectedRowIndex + "']");
	if( rowObject != null ) rowIndex = (1 * rowObject.getAttribute("rowIndex"));
	
//	cellValue = (this.data[this.selectedRowIndex - this.showedTopRowIndex])[this.columnInfo[this.selectedColumnIndex].field];
	cellValue = (this.data[rowIndex])[this.columnInfo[this.selectedColumnIndex].field];
	cellWidth = ((this.columnInfo[this.selectedColumnIndex].isSameMinWidth ? this.columnInfo[this.selectedColumnIndex].calcCellWidth : this.columnInfo[this.selectedColumnIndex].calcInnerDivWidth) - 1) + "px";
	
	//셀 내 div 를 임시 보관 div 로 이동
	this.SheetControlTempDivObject.appendChild(divObjectInCell);
	//편집 콤보박스 이동
	this.editingCellObject.appendChild(this.SheetEidtComboDivObject);
	
	//편집 콤보박스 목록 채우기
	dataList = this.columnInfo[this.selectedColumnIndex].dataList;
	if( typeof dataList == "object" && dataList instanceof Array ){
		comboData = dataList;
	}
	else if( typeof dataList == "function" ){
		comboData = dataList();
	}
	else if( typeof dataList == "string" ){
//		comboData = controls[dataList].getListArray();
		if( typeof controls[dataList].getListArray != "undefined" ){
			comboData = controls[dataList].getListArray();
		}
		else if( typeof controls[dataList].getItemList != "undefined" ){
			comboData = controls[dataList].getItemList();
		}
	}
	
	//편집 콤보박스에 목록 채우고 셀 내 데이터 출력
	comboboxObject = this.SheetEidtComboDivObject.getElementsByTagName("select")[0];
	if( typeof comboboxObject != "undefined" ){
		//콤보 목록 생성
		comboboxObject.style.display = "none";
		comboboxObject.options.length = 0;
		for(i = 0; comboData != null && i < comboData.length; i++){
			comboboxObject.options.add(new Option(comboData[i].text, comboData[i].value));
			if( cellValue == comboData[i].value ) comboboxObject.options[i].selected = true;
		}
		//편집 콤보박스 스타일 설정
		this.SheetEidtComboDivObject.style.display = "block";
		this.SheetEidtComboDivObject.style.width = cellWidth;
		this.SheetEidtComboDivObject.style.height = (this.rowHeight - 1) + "px";
		//편집 콤보박스로 포커스 이동
		comboboxObject.style.display = "block";
		comboboxObject.focus();
	}
	
	//메모리 해제
	selectedIndex = null; optionListStr = null;
	comboData = null; dataList = null;
	comboboxObject = null; rowObject = null;
	cellValue = null; cellWidth = null;
	
	return true;
};


EasySheetRenderer.prototype.setSheetEditControl = function(rowNum, colNum){
	var result = null;
	
	//시트가 편집 중인 상태인 경우
	if( this.isEditngSheet ){
		//수정 데이터 적용 및 이벤트 처리
		if( !this.setApplyChangedValueToCell(true) ) return false;
		//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
		this.isIgnoreEditingControlBlurEvent = true;
		//기존의 열려있는 편집 컨트롤을 닫음
		result = true;
		result = this.removeSheetEditControl();
		//편집 컨트롤 닫기를 실패한 경우
		if( !result ){
			result = null; return false;
		}
	}
	
	//파라메터로 행 과 열 인덱스를 받지 않은 경우 현재 선택된 행 과 열 인덱스로 설정
	if( typeof rowNum == "undefined" )
		rowNum = this.selectedRowIndex;	//행 인덱스와 현재 출력되는 최상단 행의 인덱스를 더해야 데이터의 행 인덱스가 됨
	if( typeof colNum == "undefined" )
		colNum = this.selectedColumnIndex;
	
	//행 인덱스 설정 및 인덱스 변경시 이벤트 발생
	if( !this.setSelectedRowIndex(rowNum) ){
		result = null; return false;
	}
	//열 인덱스 설정 및 인덱스 변경시 이벤트 발생
	if( !this.setSelectedColumnIndex(colNum) ){
		result = null; return false;
	}
	
//	//시트가 리스트 시트인 경우 편집 상태로 바뀌지 않도록 처리
//	if( this.isListSheet ){
//		result = null; return true;
//	}
	
	//그뤂핑 레코드인 경우 편집 상태로 변경되지 않지만 리턴은 성공처리함
	if( this.dataSet.getState(rowNum, "rowType") == "Logical" ){
		result = null; return true;
	}
	
	//시트 편집 컨트롤 세팅
	var divObject = null;
	var columnInfo = null;
	var isReadOnly = null;
	var isHidden = null;
	var isLocked = null;
	var isEnable = null;
	var isLogicalRecord = null;
	var cellType = null;
	var cellWidth = null;
	var cellValue = null;
	var enable = null;
	var rowIndex = 0;
	var i = 0;
	
	//셀 잠금, 타입 설정
	columnInfo = this.columnInfo[colNum];
	isReadOnly = columnInfo.readOnly;
	isHidden = columnInfo.hidden;
	enable = columnInfo.enable;
	isEnable = (typeof enable == "function" ? enable(rowNum, colNum, this.dataSet.data[rowNum]) : enable);
	cellType = "" + columnInfo.cellType;
	cellWidth = (columnInfo.isSameMinWidth ? columnInfo.calcCellWidth : columnInfo.calcInnerDivWidth) + "px";
	
	var columnRow = columnInfo.row - 1;
	var columnCol = -1;
	var headerInfos = this.headerInfo[this.headerInfo.length - this.rowsPerDataRow + columnRow];
	var headerInfo = null;
	
	//
	for(i = 0; i < this.colsPerRow; i++, headerInfo = null){
		if( (headerInfo = headerInfos[i]).cellIndex == colNum ){
			columnCol = i;
			headerInfo = null;
			break;
		}
	}
	
	//셀 잠금 설정이 true 인 경우 편집 컨트롤을 세팅하지 않음
	if( !isReadOnly && !isHidden && isEnable ){	
		//편집할 셀(td) 객체가 없는 경우 현재 선택된 행, 열 인덱스 위치의 셀 객체를 설정
		if( this.editingCellObject == null || !this.isEditngSheet ){
			//편집 셀 객체 설정
			if( this.leftFixColumnCount > columnCol ){
				//시트 좌측고정 테이블
//				sheetContentTable = document.getElementsByName(this.controlId + "_SheetContentLeftFixTable")[0];
//				rowObject = sheetContentTable.getElementsByTagName("tr")[rowIndex];
//				this.editingCellObject = rowObject.getElementsByTagName("td")[this.selectedColumnIndex + 1];
//				rowObject = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentDiv > table#" + this.controlId + "_SheetContentLeftFixTable tr[recordindex='" + this.selectedRowIndex + "']");
				
//				rowObject = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentLeftFixDiv > table tr[recordindex = '" + this.selectedRowIndex + "']");
//				if( rowObject == null ) return null;
//				this.editingCellObject = rowObject.querySelector("td[cellindex='" + this.selectedColumnIndex + "']");
				
				//고정열 수정 가능
				if( this.editableFixedColumn ){
					this.editingCellObject = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentLeftFixDiv > table tr[recordindex = '" + rowNum + "'] td[cellindex='" + colNum + "']");
				}
				//고정열 수정 불가능
				else{
					this.editingCellObject = null;
				}
			}
			else if( this.colsPerRow - this.rightFixColumnCount <= columnCol ){
//				sheetContentTable = document.getElementsByName(this.controlId + "_SheetContentRightFixTable")[0];
//				rowObject = sheetContentTable.getElementsByTagName("tr")[rowIndex];
//				this.editingCellObject = rowObject.getElementsByTagName("td")[this.selectedColumnIndex - (this.columnInfo.length - this.rightFixColumnCount)];
				
//				rowObject = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentRightFixDiv > table#" + this.controlId + "_SheetContentRightFixTable tr[recordindex='" + this.selectedRowIndex + "']");
//				if( rowObject == null ) return null;
//				this.editingCellObject = rowObject.getElementsByTagName("td")[this.selectedColumnIndex - (this.columnInfo.length - this.rightFixColumnCount)];
				
				//고정열 수정 가능
				if( this.editableFixedColumn ){
					this.editingCellObject = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentRightFixDiv > table tr[recordindex = '" + rowNum + "'] td[cellindex='" + colNum + "']");
				}
				//고정열 수정 불가능
				else{
					this.editingCellObject = null;
				}
			}
			else{
//				//시트 본문 테이블
//				sheetContentTable = document.getElementsByName(this.controlId + "_SheetContentTable")[0];
//				rowObject = sheetContentTable.getElementsByTagName("tr")[rowIndex];
//				this.editingCellObject = rowObject.getElementsByTagName("td")[this.selectedColumnIndex + 1];
				
//				rowObject = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentDiv > table#" + this.controlId + "_SheetContentTable tr[recordindex='" + this.selectedRowIndex + "']");
//				if( rowObject == null ) return null;
//				this.editingCellObject = rowObject.querySelector("td[cellindex='" + this.selectedColumnIndex + "']");
				
				this.editingCellObject = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentDiv > table tr[recordindex='" + rowNum + "'] td[cellindex='" + colNum + "']");
			}
		}
		else{
			//선택된 객체가 셀 객체 하위 div 객체인 경우 부모인 셀(td) 객체로 설정
			if( this.editingCellObject.tagName.toLocaleLowerCase() == "div" ){
				this.editingCellObject = this.editingCellObject.parentNode;
			}
		}
		
		if( !this.isListSheet && this.editingCellObject != null ){
			result = true;
			
			//셀 하위 div 객체 설정
			divObject = this.editingCellObject.getElementsByTagName("div")[0];
			
			//각 셀 타입에 맞는 편집 컨트롤 셀로 이동
			if( cellType == "combobox" ){
				result = this.setCellTypeCombobox(divObject);
			}
			else if( cellType == "checkbox" ){
				result = this.setCellTypeCheckbox(divObject);
			}
			else if( cellType == "text" || cellType == "integer" || cellType == "number" || cellType == "percent" ){
				result = this.setCellTypeText(divObject);
			}
			else if( cellType == "date" ){
				result = this.setCellTypeDateTime(divObject);
			}
			
			//시트 편집상태 설정
			this.isEditngSheet = result;
		}
		else{
			this.isEditngSheet = false;
		}
	}
	
	//
//	this.setSelectionClass(this.getCellObject(this.selectedRowIndex, this.selectedColumnIndex));
	this.setSelectionClass(this.editingCellObject);
	
	//메모리 해제
	result = null; headerInfo = null; headerInfos = null;
	cellValue = null; cellWidth = null;
	cellType = null; enable = null;
	isEnable = null; isHidden = null; isReadOnly = null;
	columnInfo = null; divObject = null;
	
	return this.isEditngSheet;
};

EasySheetRenderer.prototype.clearSelection = function(){
	if( this.selectedObject == null ) return;
	
	var selectedClass = null;
	var selectedElement = null;
	var parentElement = null;
	
	//선택 셀 해제
	selectedElement = this.selectedObject;
	selectedClass = selectedElement.getAttribute("class");
//	this.selectedObject.setAttribute("class", selectedClass.replace("selected-col", "").trim());
	this.removeClass(selectedElement, "selected-col");
	selectedClass = null;
	
	//선택 로우 해제
	parentElement = this.selectedObject.parentElement;
	if( typeof parentElement != "undefined" && parentElement != null ){
		selectedClass = parentElement.getAttribute("class");
//		this.selectedObject.parentElement.setAttribute("class", selectedClass.replace("selected-row", "").trim());
		this.removeClass(parentElement, "selected-row");
		selectedClass = null;
	}
	
	//메모리 해제
	parentElement = null;
	selectedElement = null;
	
	//선택 셀 객체 해제
	this.selectedObject = null;
	
	//선택 로우, 셀 인덱스 초기화
	this.selectedColumnIndex = -1;
	this.selectedRowIndex = -1;
};

EasySheetRenderer.prototype.completeSheetEditing = function(isApplyChangedValue){
	//편집 중인 상태가 아닌 경우
	if( this.editingCellObject == null || typeof this.editingCellObject == "undefined" )
		return true;
	
	//파라메터 예외처리
	if( typeof isApplyChangedValue != "boolean" )
		return false;
	
	var result = true;
	
	//시트가 편집 중인 상태인 경우
	if( this.isEditngSheet ){
		//편집 중인 데이터를 수정, 적용할 경우
//		if( isApplyChangedValue ){
//			//수정 데이터 적용 및 이벤트 처리
//			if( !this.setApplyChangedValueToCell(true) ) return false;
//		}
		if( !this.setApplyChangedValueToCell(isApplyChangedValue) ) return false;
		
		//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
		this.isIgnoreEditingControlBlurEvent = true;
		//기존의 열려있는 편집 컨트롤을 닫음
		result = this.removeSheetEditControl();
		//시트 메세지박스 숨김
		this.setSheetMsgBox(false);
	}
	
	return result;
}

EasySheetRenderer.prototype.setApplyChangedValueToCell = function(isApplyChangedValue){
	//예외처리
	if( this.editingCellObject == null || typeof this.editingCellObject == "undefined" ){
		return false;
	}
	
	//파라메터 적용
	if( typeof isApplyChangedValue == "boolean" ){
		this.isApplyEditingControlChangedValue = isApplyChangedValue;
	}
	
	var rowObject = null;
	var rowIndex = -1;
	
	var colIndex = -1;
	var cellType = null;
	var fieldType = null;
	var newValue = null;
	var newText = null;
	var oldValue = null;
	var oldText = null;
	var dispValue = null;
	var isValid = true;
	var validationCheckData = null;
	var validationCheckMessage = null;
	var sheet = null;
	var result = null;
	
	var combobox = null;
	var options = null;
	
	//시트 찾기
	sheet = controls[this.controlName];
	//렌더러에서 시트를 찾지 못한 경우
	if( (typeof sheet == "undefined" || sheet == null) && !(typeof EasySheet != "undefined" && sheet instanceof EasySheet) ){
		sheet = null; return false;
	}
	
//	rowIndex = this.selectedRowIndex - this.showedTopRowIndex;
//	rowIndex = ((this.selectedRowIndex - this.showedTopRowIndex) >= this.topFixRowCount) ? (this.selectedRowIndex - this.showedTopRowIndex) + this.topFixRowCount : (this.selectedRowIndex - this.showedTopRowIndex);
	rowObject = rowObject = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentDiv > table#" + this.controlId + "_SheetContentTable tr[recordindex='" + this.selectedRowIndex + "']");
	if( rowObject != null) rowIndex = (1 * rowObject.getAttribute("rowIndex"));
	rowObject = null;
	
	//셀 속성 설정
	colIndex = this.selectedColumnIndex;
	cellType = this.columnInfo[colIndex].cellType;
	fieldType = this.columnInfo[colIndex].fieldType;
	oldValue = (this.data[rowIndex])[this.columnInfo[colIndex].field];

	//셀 타입별 수정 데이터 추출
	if( cellType == "checkbox" ){
		newValue = this.SheetEidtCheckDivObject.getAttribute("originval");
	}
	else if( cellType == "combobox" ){
		//
		oldText = this.dataSet.getState(rowIndex, this.columnInfo[colIndex].field + ".TEXT");
		//
		combobox = this.SheetEidtComboDivObject.getElementsByTagName("select")[0];
		if( typeof combobox.options[combobox.selectedIndex] != "undefined" ){
			newValue = combobox.options[combobox.selectedIndex].value;
			newText = combobox.options[combobox.selectedIndex].text;
		}
		combobox = null;
	}
	else if( cellType == "text" || cellType == "integer" || cellType == "number" || cellType == "percent" ){
		newValue = this.SheetEidtTextDivObject.getElementsByTagName("input")[0].value;
	}
	else if( cellType == "date" ){
		newValue = this.SheetEidtDateDivOBject.getElementsByTagName("input")[0].value;
	}
	else{
		//메모리 해제
		newValue = null; oldValue = null; fieldType = null; cellType = null; sheet = null;
		//알 수 없는 셀타입으로 에러처리
		return false;
	}
	
	//에러메세지 표시를 위한 데이터 기록
	validationCheckData = newValue;
	
	//필드 타입별 데이터 변환
	if( newValue == null ){
		newValue = oldValue;
	}
	else if( fieldType == "string" ){
		newValue = "" + newValue;
	}
	else if( fieldType == "number" ){
		newValue = 1 * newValue;
	}
	else if( fieldType == "boolean" ){
		newValue = ("" + newValue == "true") ? true : false;
	}

	if( oldValue == newValue ){
		this.isApplyEditingControlChangedValue = false;
	}
	
	//데이터 정합성 체크
	//정수 체크
	if( cellType == "integer" ){
		isValid = EasySheetUtil.checkValidationInteger(newValue);
		validationCheckMessage = getText("message_easysheetrender_001", "{0}은(는) 정수가 아닙니다.", [validationCheckData]);
	}
	//실수 체크
	if( cellType == "number" || cellType == "percent" ){
		isValid = EasySheetUtil.checkValidationDouble(newValue);
		if (cellType == "number") validationCheckMessage = getText("message_easysheetrender_002", "{0}은(는) 실수가 아닙니다.", [validationCheckData]);
		else validationCheckMessage = getText("message_easysheetrender_003", "{0}은(는) 올바른 퍼센트 형식의 데이터가 아닙니다.", [validationCheckData]);
	}
	//날짜 체크
	if( cellType == "date" ){
		var dtFormat = null;
		var dtName = null;
		switch( this.columnInfo[colIndex].dateType ){
			case 0: dtFormat = "yyyymmdd"; dtName = "년월일"; break; //년월일: 0
			case 1: dtFormat = "yyyymm"; dtName = "년월"; break; //년월: 1
			case 2: dtFormat = "yyyy"; dtName = "년도"; break; //년도: 2
			case 3: dtFormat = "yyyymmddHHMMss"; dtName = "년월일시분초"; break; //년월일시분초: 3
			case 4: dtFormat = "yyyymmddHHMM"; dtName = "년월일시분"; break; //년월일시분: 4
			case 5: dtFormat = "yyyymmddHH"; dtName = "년월일시"; break; //년월일시: 5
			case 6: dtFormat = "HHMMss"; dtName = "시분초"; break; //시분초: 6
			case 7: dtFormat = "HHMM"; dtName = "시분"; break; //시분: 7
			case 8: dtFormat = "HH"; dtName = "시간"; break; //시간: 8
		}
		isValid = EasySheetUtil.checkValidationDate(dtFormat, newValue);
		validationCheckMessage = getText("message_easysheetrender_004",  "{0}은(는) 올바른 '{1}' 형식의 데이터가 아닙니다.", [validationCheckData, dtName]);
		//메모리 해제
		dtFormat = null; dtName = null;
	}
	//boolean 체크
	if( fieldType == "boolean" ){
		isValid = EasySheetUtil.checkValidationBoolean(newValue);
		validationCheckMessage = getText("message_easysheetrender_005", "{0}은(는) true 또는 false 가 아닙니다.", [validationCheckData]);
	}
	//최대, 최소값 체크
	if( cellType == "integer" || cellType == "number" ){
		if( typeof this.columnInfo[colIndex].maxValue == "number" && this.columnInfo[colIndex].maxValue < newValue ){
			isValid = false;
			validationCheckMessage = getText("message_easysheetrender_006", "{0}은(는) 최대값 {1}보다 큽니다.", [validationCheckData, this.columnInfo[colIndex].maxValue]);
		}
		else if( typeof this.columnInfo[colIndex].maxValue == "number" && this.columnInfo[colIndex].minValue > newValue ){
			isValid = false;
			validationCheckMessage = getText("message_easysheetrender_007", "{0}은(는) 최소값 {1}보다 작습니다.", [validationCheckData, this.columnInfo[colIndex].minValue]);
		}
	}
	
	//셀 타입별 체크 항목들 중 통과하지 못한 경우
	if( !isValid ){
		this.setSheetMsgBox(true, validationCheckMessage, rowIndex, colIndex);
		
		//메모리 해제
		validationCheckData = null; validationCheckMessage = null;
		newValue = null; oldValue = null; fieldType = null; cellType = null; sheet = null;
		
		return false;
	}
	else{
		this.setSheetMsgBox(false);
	}
	
	//산식 및 사용자 이벤트 체크
	if( !sheet._catchValidate(this.selectedRowIndex, this.selectedColumnIndex, newValue) ){
		//시트 메세지 박스가 아닌 다른 방법으로 데이터 정합성 체크 에러 메세지를 출력했다면 이전 값으로 복구해야함.
		if( this.SheetMsgBox.style.display == "none" ){
			if( cellType == "checkbox" ){
				this.SheetEidtCheckDivObject.setAttribute("originval", oldValue);
			}
			else if( cellType == "combobox" ){
				combobox = this.SheetEidtComboDivObject.getElementsByTagName("select")[0];
				if( typeof combobox != "undefined" ) combobox.value = oldValue;
				combobox = null;
			}
		}
		//메모리 해제
		validationCheckData = null; validationCheckMessage = null;
		newValue = null; oldValue = null; fieldType = null; cellType = null; sheet = null;
		
		return false;
	}
	
	//수정 데이터 적용 여부에 따라 true 인 경우 변경된 데이터를 적용
	if( this.isApplyEditingControlChangedValue ){
//		//시트 이벤트 : Chnage 호출(시작)
//		if( sheet.hasChangeEvent ){
//			//이벤트 호출
//			result = sheet.fncChangeEvent(rowIndex, colIndex, newValue, oldValue);
//			
//			if( typeof result == "boolean" && result != true ){
//				//수정한 데이터 적용 여부 초기화
//				this.isApplyEditingControlChangedValue = true;
//				//메모리 해제
//				result = null;
//				isValid = null; validationCheckData = null; validationCheckMessage = null;
//				newValue = null; oldValue = null; fieldType = null; cellType = null;
//				colIndex = null; rowIndex = null; sheet = null;
//				//사용자 이벤트 로직 처리 결과에 따라 데이터 적용하지 않음
//				return false;
//			}
//		}
//		//시트 이벤트 : Chnage 호출(종료)
		
		//
		if( cellType == "integer" || cellType == "number" ){
			//소수점 자리수
			var decimalPlace = this.columnInfo[colIndex].decimalPlace;
			var value = 1 * newValue;
			if( typeof value == "number" && (decimalPlace != null && typeof decimalPlace == "number" && decimalPlace >= 0) ){
				newValue = Math.floor(value * Math.pow(10, decimalPlace)) / Math.pow(10, decimalPlace);
			}
			decimalPlace = null;
		}
		
		//내부 데이터 변경 : 시트의 이벤트 후속처리 함수에서 처리
		/* (this.data[rowIndex])[this.columnInfo[colIndex].field] = newValue; */
		if( !sheet._catchEvent({event: "change", row: this.selectedRowIndex, col: this.selectedColumnIndex, oldValue: oldValue, newValue: newValue, oldText: oldText, newText: newText}) ){
			//셀 타입별 데이터 복구
			if( cellType == "checkbox" ){
				this.SheetEidtCheckDivObject.setAttribute("originval", oldValue);
				this.SheetEidtCheckDivObject.innerHTML = this.getDisplayValueByCellType(colIndex, oldValue);
			}
			else if( cellType == "combobox" ){
				//편집 콤보박스를 oldValue 로 복구
				combobox = this.SheetEidtComboDivObject.getElementsByTagName("select")[0];
				options = combobox.options;
				for(var i = 0; i < options.length; i++){
					if( options[i].value == oldValue ){
						combobox.selectedIndex = i;
						break;
					}
				}
				//메모리 해제
				options = null; combobox = null;
			}
			else if( cellType == "text" || cellType == "integer" || cellType == "number" || cellType == "percent" ){
				//편집 텍스트박스를 oldValue 로 복구
				this.SheetEidtTextDivObject.getElementsByTagName("input")[0].value = oldValue;
			}
			else if( cellType == "date" ){
				//편집 날짜 텍스트박스를 oldValue 로 복구
				this.SheetEidtDateDivOBject.getElementsByTagName("input")[0].value = oldValue;
			}
			
			//수정한 데이터 적용 여부 초기화
			this.isApplyEditingControlChangedValue = true;
			
			//메모리 해제
			validationCheckData = null; validationCheckMessage = null;
			newValue = null; oldValue = null; fieldType = null; cellType = null; sheet = null;
			
			//사용자 이벤트 로직 처리 결과에 따라 데이터 적용하지 않음
			return false;
		}
		
		//표시형식 적용된 데이터 반영
		if( cellType == "combobox" ){
			dispValue = newText;
		}
		else{
			dispValue = this.getDisplayValueByCellType(colIndex, newValue);
		}
		
		if( this.SheetControlTempDivObject.children.length > 0 ){
			this.SheetControlTempDivObject.children[0].innerHTML = dispValue;
		}
		else{
//			this.editingCellObject.getElementsByTagName("div")[0].innerHTML = dispValue;
		}
		
		//수정데이터 툴팁 적용
		this.setCellTooltip(colIndex, this.editingCellObject, dispValue);
		
//		this.redraw();
		this.update();
	}
	else{
		//시트 이벤트 : CancelChange 호출(시작)
		result = true;
		if( typeof result == "boolean" && result != true ){
			//수정한 데이터 적용 여부 초기화
			this.isApplyEditingControlChangedValue = true;
			//메모리 해제
			result = null; validationCheckData = null; validationCheckMessage = null;
			newValue = null; oldValue = null; newText = null; oldText = null;
			fieldType = null; cellType = null; sheet = null;
			//사용자 이벤트 로직 처리 결과에 따라 데이터 적용하지 않음
			return false;
		}
		//시트 이벤트 : CancelChange 호출(종료)
	}
	
	//수정한 데이터 적용 여부 초기화
	this.isApplyEditingControlChangedValue = true;
	
	//메모리 해제
	result = null; validationCheckData = null; validationCheckMessage = null;
	dispValue = null; newValue = null; oldValue = null; newText = null; oldText = null;
	fieldType = null; cellType = null; sheet = null;
	
	return true;
};

EasySheetRenderer.prototype.removeSheetEditControl = function(){
	//현재 편집중이 아닌 경우 함수 동작 처리 안함
	if( !this.isEditngSheet ) return true;
	
	var recordIndex = -1;
	var rowIndex = -1;
	var cellIndex = -1;
	var cellType = null;
	var enable = null;
	var isReadOnly = null;
	var isHidden = null;
	var isEnable = null;
	
	recordIndex = 1 * this.editingCellObject.parentNode.getAttribute("recordindex");
	rowIndex = 1 * this.editingCellObject.parentNode.getAttribute("rowindex");
	cellIndex = 1 * this.editingCellObject.getAttribute("cellindex");
	cellType = "" + this.columnInfo[cellIndex].cellType;
	isReadOnly = this.columnInfo[cellIndex].readOnly;
	isHidden = this.columnInfo[cellIndex].hidden;
	enable = this.columnInfo[cellIndex].enable;
	isEnable = (typeof enable == "function" ? enable(recordIndex, cellIndex, this.dataSet.data[recordIndex]) : enable);
	
	//현재 셀이 편집가능한 상태에서만 편집 컨트롤을 제거할 수 있음 
	if( !isReadOnly && !isHidden && isEnable ){
		//편집 시트를 셀에서 제거
		if( cellType == "combobox" ){
			//콤보박스
			try{ this.SheetEidtComboDivObject.getElementsByTagName("select")[0].options.length = 0; }
			catch(e){ this.SheetEidtComboDivObject.getElementsByTagName("select")[0].innerHTML = ""; }
			this.SheetEidtComboDivObject.style.display = "none";
			this.SheetObject.appendChild(this.SheetEidtComboDivObject);
			//셀 내의 기존 div 복구
			if( this.SheetControlTempDivObject.children.length > 0 ){
				this.editingCellObject.appendChild(this.SheetControlTempDivObject.children[0]);
			}
		}
		else if( cellType == "checkbox" ){
			//체크박스
			this.SheetEidtCheckDivObject.removeAttribute("originval");
			this.SheetEidtCheckDivObject.style.display = "none";
			this.SheetObject.appendChild(this.SheetEidtCheckDivObject);
			//셀 내의 기존 div 복구
			if( this.SheetControlTempDivObject.children.length > 0 ){
				this.editingCellObject.appendChild(this.SheetControlTempDivObject.children[0]);
			}
		}
		else if( cellType == "text" || cellType == "integer" || cellType == "number" || cellType == "percent" ){
			//텍스트박스
			this.SheetEidtTextDivObject.getElementsByTagName("input")[0].value = "";
			this.SheetEidtTextDivObject.style.display = "none";
			this.SheetObject.appendChild(this.SheetEidtTextDivObject);
			//blur 이벤트 처리 상태 초기화
			this.isIgnoreEditingControlBlurEvent = false;
			//셀 내의 기존 div 복구
			if( this.SheetControlTempDivObject.children.length > 0 ){
				this.editingCellObject.appendChild(this.SheetControlTempDivObject.children[0]);
			}
			
			//셀 타입이 integer, number, percent 이고 컬럼의 negativeRed 속성이 true 인 경우 데이터가 음수이면 글자색을 #ff0000 으로 설정 
			if( (cellType == "integer" || cellType == "number" || cellType == "percent") && this.columnInfo[cellIndex].negativeRed === true ){
				if( this.data[rowIndex][this.columnInfo[cellIndex].field] < 0 )
					this.setCellFontColor(cellIndex, this.editingCellObject, "#ff0000");
				else
					this.setCellFontColor(cellIndex, this.editingCellObject);
			}
		}
		else if( cellType == "date" ){
			//텍스트박스
			this.SheetEidtDateDivOBject.getElementsByTagName("input")[0].value = "";
			this.SheetEidtDateDivOBject.style.display = "none";
			this.SheetObject.appendChild(this.SheetEidtDateDivOBject);
			//blur 이벤트 처리 상태 초기화
			this.isIgnoreEditingControlBlurEvent = false;
			//셀 내의 기존 div 복구
			if( this.SheetControlTempDivObject.children.length > 0 ){
				this.editingCellObject.appendChild(this.SheetControlTempDivObject.children[0]);
			}
			
			//시트 달력이 열려있는 상태인 경우 시트 달력을 닫음
			if( this.SheetEditCalenderObject != null && this.SheetEditCalenderObject.style.display == "block" ){
				this.SheetEditCalenderObject.style.display = "none";
			}
		}
	}
	
	//편집중인 셀 객체 해제
	this.editingCellObject = null;
	
	//시트 편집상태 설정
	this.isEditngSheet = false;
	
	//메모리 해제
	isEnable = null; isReadOnly = null; isHidden = null;
	enable = null; cellType = null;
	
	return true;
};

EasySheetRenderer.prototype.setSheetMsgBox = function(isShow, message, rowIndex, colIndex){
	//isShow 파라메터 입력값이 없는 경우 false로 처리하여 시트 메세지 박스를 숨김
	if( typeof isShow == "undefined" ) isShow = false;
	
	if( isShow ){
		if( typeof rowIndex == "undefined" ){
//			rowIndex = this.selectedRowIndex - this.showedTopRowIndex;
			var rowObject = document.querySelector("div.EasyDataSheet#" + this.controlId + " div.SheetContentDiv > table#" + this.controlId + "_SheetContentTable tr[recordindex='" + this.selectedRowIndex + "']");
			if( rowObject == null ){
				rowObject = null; return false;
			}
			rowIndex = (1 * rowObject.getAttribute("rowIndex"));
			rowObject = null;
		}
		if( typeof colIndex == "undefined" ){
			colIndex = this.selectedColumnIndex;
		}
		
		var headerRowCount = this.headerInfo.length;
		var headerColCount = this.colsPerRow;
		var headerStartIndex = headerRowCount - this.rowsPerDataRow;
		var headerRow = null; var headerCol = null;
		var colItem = null; var isCalcCompleted = false; var left = 0;
		var i = 0; var j = 0;
		var r = 0; var c = 0;
		
		//메세지 박스를 띄울 셀의 행, 열 인덱스로 박스의 좌측 위치 계산
		for(i = headerStartIndex, r = 0; i < headerRowCount; i++, r++, headerRow = null){
			headerRow = this.headerInfo[i];
			//행 정보가 없는 경우 예외처리
			if( headerRow == null || typeof headerRow == "undefined" ) continue;
			
			//
			for(j = 0; j < headerColCount; j++, headerCol = null){
				headerCol = headerRow[j];
				//열 정보가 없는 경우 예외처리
				if( headerCol == null || typeof headerCol == "undefined" ) continue;
				
				//열 인덱스와 일치하는 경우 위치 계산
				if( headerCol.cellIndex == colIndex ){
					//시트 메세지 박스 위치 계산
					for(k = 0, left = this.sheetRowHeaderWidth; k < j && k < headerColCount; k++, colItem = null){
						colItem = headerRow[k];
						left += this.columnInfo[colItem.cellIndex].calcCellWidth;
					}
					//위치 계산 완료
					isCalcCompleted = true;
					break;
				}
			}
			
			//계산 완료하였으므로 루프 나감
			if( isCalcCompleted ){
				//메모리 해제
				headerCol = null;
				headerRow = null;
				break;
			}
		}
		
		//시트 메세지 삽입
		if( message != null && typeof message != "undefined" )
			this.SheetMsgBox.innerHTML = message;
		else
			this.SheetMsgBox.innerHTML = "";
		
		//시트 메세지 박스 표시
//		this.SheetMsgBox.style.top = this.headerHeight + (this.rowHeight * (rowIndex + 1)) + 1 + "px";
		this.SheetMsgBox.style.top = (this.headerHeight + (this.rowHeight * ((rowIndex * this.rowsPerDataRow + r) + 1)) + 1) + "px";
		this.SheetMsgBox.style.left = left + "px";
		this.SheetMsgBox.style.display = "block";
		
		//메모리 해제
		c = null; left = null;
	}
	else{
		this.SheetMsgBox.style.display = "none";
	}
	
	return true;
};

EasySheetRenderer.prototype.setSheetCalender = function(dateType, dateValue){
	if( !this.createSheetCalender() ){
		return false;
	}
	
	var today = null;
	var date_year = null; var date_month = null; var date_day = null;
	var date_hour = null; var date_minutes = null; var date_seconds = null;
	var format = null; var formatCheck = null; var indexFormat = -1;
	var firstDayIndex = -1; var lastDayOfMonth = -1;
	var isSelected = false; var isDisplay = false;
	var dispYear = null; var dispMonth = null; var dispDay = null;
	var dispClass = null;
	
	var SheetCalenders = null;
	var dateCalender = null;
	var monthCalender = null;
	var yearCalender = null;
	var timeCalender = null;
	
	var calenderRows = null; var calenderRow = null;
	var calenderCells = null; var calenderCell = null;
	
	var i = 0; var j = 0;
	
	//날짜 형식 기본값 설정
	if( typeof dateType == "undefined" ){
		format = "yyyymmdd";
		formatCheck = /[1-9][0-9]{3}(0[1-9]|1[0-2])(0[0-9]|[1-2][0-9]|3[0-1])/;
	}
	else{
		dateType = 1 * dateType;
		switch( dateType ){
			//년월일: 0
			case 0:		format = "yyyymmdd";
						formatCheck = /[1-9][0-9]{3}(0[1-9]|1[0-2])(0[0-9]|[1-2][0-9]|3[0-1])/;
						break;
			//년월: 1
			case 1:		format = "yyyymm";
						formatCheck = /[1-9][0-9]{3}(0[1-9]|1[0-2])/;
						break;
			//년도: 2
			case 2:		format = "yyyy";
						formatCheck = /[1-9][0-9]{3}/;
						break;
			//년월일시분초: 3
			case 3:		format = "yyyymmddHHMMss";
						formatCheck = /[1-9][0-9]{3}(0[1-9]|1[0-2])(0[0-9]|[1-2][0-9]|3[0-1])([0-1][0-9]|2[0-3])[0-5][0-9][0-5][0-9]/;
						break;
			//년월일시분: 4
			case 4:		format = "yyyymmddHHMM";
						formatCheck = /[1-9][0-9]{3}(0[1-9]|1[0-2])(0[0-9]|[1-2][0-9]|3[0-1])([0-1][0-9]|2[0-3])[0-5][0-9]/;
						break;
			//년월일시: 5
			case 5:		format = "yyyymmddHH";
						formatCheck = /[1-9][0-9]{3}(0[1-9]|1[0-2])(0[0-9]|[1-2][0-9]|3[0-1])([0-1][0-9]|2[0-3])/;
						break;
			//시분초: 6
			case 6:		format = "HHMMss";
						formatCheck = /([0-1][0-9]|2[0-3])[0-5][0-9][0-5][0-9]/;
						break;
			//시분: 7
			case 7:		format = "HHMM";
						formatCheck = /([0-1][0-9]|2[0-3])[0-5][0-9]/;
						break;
			//시간: 8
			case 8:		format = "HH";
						formatCheck = /([0-1][0-9]|2[0-3])/;
						break;
			//기본값
			default :	format = "yyyymmdd";
						formatCheck = /[1-9][0-9]{3}(0[1-9]|1[0-2])(0[0-9]|[1-2][0-9]|3[0-1])/;
		}
	}
	
	//날짜 데아터 기본값(오늘 날짜 현재 시간) 설정
	today = new Date();
	date_year = today.getFullYear();
	date_month = (1 * today.getMonth()) + 1;
	date_day = today.getDate();
	date_hour = today.getHours();
	date_minutes = today.getMinutes();
	date_seconds = today.getSeconds();
	//메모리 초기화
	today = null;
	
	//입력된 일자가 있다면 입력된 날짜 형식에 따라 날짜를 설정
	if( typeof dateValue != "undefined" && ("" + dateValue).length > 0 ){
		//입력값 체크
		if( !formatCheck.test(("" + dateValue)) ){
			dateValue = null; dateValue = "";
			//Year
			if( dateType == 0 || dateType == 1 || dateType == 2 || dateType == 3 || dateType == 4 || dateType == 5 )
				dateValue += date_year;
			//Month
			if( dateType == 0 || dateType == 1 || dateType == 3 || dateType == 4 || dateType == 5 )
				dateValue += ((date_month < 10 ? "0" : "") + date_month);
			//Day
			if( dateType == 0 || dateType == 3 || dateType == 4 || dateType == 5 )
				dateValue += ((date_day < 10 ? "0" : "") + date_day);
			//Hour
			if( dateType == 3 || dateType == 4 || dateType == 5 || dateType == 6 || dateType == 7 || dateType == 8 )
				dateValue += ((date_hour < 10 ? "0" : "") + date_hour);
			//Minute
			if( dateType == 3 || dateType == 4 || dateType == 6 || dateType == 7 )
				dateValue += ((date_minutes < 10 ? "0" : "") + date_minutes);
			//Second
			if( dateType == 3 || dateType == 6 )
				dateValue += ((date_seconds < 10 ? "0" : "") + date_seconds);
		}
		//일자값 설정
		indexFormat = format.indexOf("yyyy"); //년
		if( indexFormat >= 0 && indexFormat < dateValue.length ){
			date_year = dateValue.substring(indexFormat, indexFormat + 4);
			date_year = 1 * date_year;
		}
		indexFormat = format.indexOf("mm"); //월
		if(indexFormat >= 0 && indexFormat < dateValue.length ){
			date_month = dateValue.substring(indexFormat, indexFormat + 2);
			date_month = 1 * date_month;
		}
		indexFormat = format.indexOf("dd"); //일
		if(indexFormat >= 0 && indexFormat < dateValue.length ){
			date_day = dateValue.substring(indexFormat, indexFormat + 2);
			date_day = 1 * date_day;
		}
		indexFormat = format.indexOf("HH"); //시
		if(indexFormat >= 0 && indexFormat < dateValue.length ){
			date_hour = dateValue.substring(indexFormat, indexFormat + 2);
		}
		indexFormat = format.indexOf("MM"); //분
		if(indexFormat >= 0 && indexFormat < dateValue.length ){
			date_minutes = dateValue.substring(indexFormat, indexFormat + 2);
		}
		indexFormat = format.indexOf("ss"); //초
		if(indexFormat >= 0 && indexFormat < dateValue.length ){
			date_seconds = dateValue.substring(indexFormat, indexFormat + 2);
		}
	}
	
	//달력 보이기 설정
	this.SheetEditCalenderObject.style.display = "block";
	
	//달력 적용 시트 설정
	this.SheetEditCalenderObject.setAttribute("targetSheet", this.controlId);
	//달력 타입 설정
	this.SheetEditCalenderObject.setAttribute("calenderType", dateType);
	
	//각 타입별 달력 객체 구함
	SheetCalenders = this.SheetEditCalenderObject.getElementsByTagName("div");
	for(i = 0; i < SheetCalenders.length; i++){
		if(SheetCalenders[i].getAttribute("class") == "DateCalender" ) dateCalender = SheetCalenders[i].getElementsByTagName("table")[0];
		if(SheetCalenders[i].getAttribute("class") == "MonthCalender" ) monthCalender = SheetCalenders[i].getElementsByTagName("table")[0];
		if(SheetCalenders[i].getAttribute("class") == "YearCalender" ) yearCalender = SheetCalenders[i].getElementsByTagName("table")[0];
		if(SheetCalenders[i].getAttribute("class") == "TimeCalender" ) timeCalender = SheetCalenders[i].getElementsByTagName("table")[0];
	}
	SheetCalenders = null;
	
	/* 일자-달력 세팅 */
	//해당 년월의 첫번째 일의 요일 구함
	today = new Date(date_year, date_month - 1, "1");
	firstDayIndex = today.getDay();
	firstDayIndex = (firstDayIndex == 0) ? 8 : firstDayIndex; //일요일부터 시작인 경우 한 행 아래부터 채움
	dispDay = 1;
	today = null;
	
	//해당 년월의 마지막 일 구함
	today = new Date(date_year, date_month, "0");
	lastDayOfMonth = today.getDate();
	today = null;
	
	//일자-달력 년월 채우기
	calenderRows = dateCalender.getElementsByTagName("tr");
	calenderRow = calenderRows[0];
	dispMonth = "00" + date_month;
	calenderRow.getElementsByTagName("th")[1].innerHTML = date_year + " . " + dispMonth.substring(dispMonth.length - 2, dispMonth.length);
	dispMonth = null;
	calenderRow = null;
	
	//일자-달력 일자 채우기
	for(i = 2; i < 8; i++){
		//행 및 셀 객체 설정
		calenderCells = calenderRows[i].getElementsByTagName("td");
		
		for(j = 0; j < 7; j++){
			calenderCell = calenderCells[j];
			
			//셀 일자 출력
			if( firstDayIndex <= j && dispDay <= lastDayOfMonth ){
				//선택된 셀 판별
				isSelected = (date_day == dispDay);
				//선택된 행과 열 인덱스 설정
				if( isSelected ){
					dateCalender.setAttribute("selectedRow", i);
					dateCalender.setAttribute("selectedCol", j);
				}
				//일자 적용
				calenderCell.innerHTML = dispDay;
				//일자 증가
				dispDay++;
				//클래스 적용
				dispClass = ((j == 0) ? "sunday " : ((j == 6) ? "saturday " : "")) + "clickable" + (isSelected ? " today" : "");
				calenderCell.setAttribute("class", dispClass);
				//메모리 초기화
				isSelected = null;
				dispClass = null;
			}
			else{
				//일자 적용
				calenderCell.innerHTML = "&nbsp;";
				//클래스 적용
				calenderCell.removeAttribute("class");
			}
			
			//메모리 초기화
			calenderCell = null;
		}
		
		//메모리 초기화
		firstDayIndex = 0;
		calenderCells = null;
	}
	
	//일자 달력 보이기 설정
	isDisplay = (dateType == 1 || dateType == 2 || dateType == 6 || dateType == 7 || dateType == 8) ? false : true;
	dateCalender.parentNode.style.display = isDisplay ? "block" : "none";
	
	//메모리 초기화
	isDisplay = null;
	isSelected = null;
	dispDay = null;
	calenderRows = null;
	dateCalender = null;
	/* 일자-달력 세팅 */
	
	/* 년월-달력 세팅 */
	//년월-달력 년도 채우기
	calenderRows = monthCalender.getElementsByTagName("tr");
	calenderRow = calenderRows[0];
	calenderRow.getElementsByTagName("th")[1].innerHTML = date_year;
	calenderRow = null;
	
	//년월-달력 월 선택
	dispDay = (date_month % 4) - 1;
	dispDay = (dispDay < 0) ? 3 : dispDay;
	dispMonth = Math.floor(date_month / 4);
	dispMonth = (dispDay == 3) ? dispMonth : dispMonth + 1;
	
	//선택된 행과 열 인덱스 설정
	monthCalender.setAttribute("selectedRow", dispMonth);
	monthCalender.setAttribute("selectedCol", dispDay);
	
	for(i = 1; i < 4; i++){
		calenderCells = calenderRows[i].getElementsByTagName("td");
		
		for(j = 0; j < 4; j++){
			//선택된 셀 판별
			isSelected = (i == dispMonth && j == dispDay);
			//클래스 적용
			dispClass = "clickable" + (isSelected ? " tomonth" : "");
			calenderCells[j].setAttribute("class", dispClass);
			//메모리 초기화
			dispClass = null;
		}
		
		//메모리 초기화
		calenderCells = null;
	}
	
	//일자 달력 보이기 설정
	monthCalender.parentNode.style.display = (dateType == 1) ? "block" : "none";
	
	//메모리 초기화
	dispMonth = null;
	dispDay = null;
	calenderRows = null;
	monthCalender = null;
	/* 년월-달력 세팅 */
	
	/* 년도-달력 세팅 */
	dispYear = date_year - 12;
	
	//년도-달력 년도 범위 채우기
	calenderRows = yearCalender.getElementsByTagName("tr");
	calenderRow = calenderRows[0];
	calenderRow.getElementsByTagName("th")[1].innerHTML = dispYear + " ~ " + (date_year + 12);
	calenderRow = null;
	
	for(i = 1; i < 6; i++){
		calenderCells = calenderRows[i].getElementsByTagName("td");
		
		for(j = 0; j < 5; j++, dispYear++){
			//선택된 셀 판별
			isSelected = (date_year == dispYear);
			//선택된 행과 열 인덱스 설정
			if( isSelected ){
				yearCalender.setAttribute("selectedRow", i);
				yearCalender.setAttribute("selectedCol", j);
			}
			//클래스 적용
			dispClass = "clickable" + (isSelected ? " toyear" : "");
			//년도 적용
			calenderCells[j].innerHTML = dispYear;
			//클래스 적용
			calenderCells[j].setAttribute("class", dispClass);
			//메모리 초기화
			dispClass = null;
		}
		
		//메모리 초기화
		calenderCells = null;
	}
	
	//년도 달력 보이기 설정
	yearCalender.parentNode.style.display = (dateType == 2) ? "block" : "none";
	
	//메모리 초기화
	isSelected = null;
	dispYear = null;
	calenderRows = null;
	yearCalender = null;
	/* 년도-달력 세팅 */
	
	/* 시간-달력 세팅 */
	//일자 적용
	calenderRow = timeCalender.getElementsByTagName("tr")[0];
	calenderCells = calenderRow.getElementsByTagName("th");
	dispMonth = "00" + date_month;
	dispDay = "00" + date_day;
	calenderCells[0].innerHTML = date_year + " . " + dispMonth.substring(dispMonth.length - 2, dispMonth.length) + " . " + dispDay.substring(dispDay.length - 2, dispDay.length);
	//메모리 초기화
	dispDay = null; dispMonth = null;
	calenderCells = null;
	calenderRow = null;
	
	//시 / 분 / 초 적용
	calenderRow = timeCalender.getElementsByTagName("tr")[2];
	calenderCells = calenderRow.getElementsByTagName("td");
	//시간 적용
	calenderCells[0].innerHTML = date_hour;
	//분 적용
	calenderCells[2].innerHTML = date_minutes;
	//초 적용
	calenderCells[4].innerHTML = date_seconds;
	//메모리 초기화
	calenderCells = null;
	calenderRow = null;
	
	//시간 달력 보이기 설정
	timeCalender.parentNode.style.display = (dateType == 6 || dateType == 7 || dateType == 8) ? "block" : "none";

	//메모리 초기화
	timeCalender = null;
	/* 시간-달력 세팅 */
	
	//시트 달력 포커스
	this.SheetEditCalenderObject.focus();
	
	//메모리 해제/초기화
	date_hour = null; date_minutes = null; date_seconds = null;
	date_year = null; date_month = null; date_day = null;
	format = null; indexFormat = null; firstDayIndex = null; lastDayOfMonth = null;
	
	return true;
};

EasySheetRenderer.prototype.createSheetCalender = function(){
	var sheetCalender = null;
	var calender = null;
	var table = null;
	var tableContent = null;
	var value = null;
	var i = 0; var j = 0;
	
	//시트 달력 객체 가져옴
//	sheetCalender = document.getElementsByName("easySheetCalender")[0];
	sheetCalender = this.SheetObject.querySelector("div.easySheetCalender");
	
	//시트 달력이 없는 경우 달력 생성
	if( sheetCalender == null || typeof sheetCalender == "undefined" ){
		//시트 달력 생성
		sheetCalender = document.createElement("div");
		sheetCalender.setAttribute("id", "easySheetCalender");
		sheetCalender.setAttribute("name", "easySheetCalender");
		sheetCalender.setAttribute("class", "EasySheetCalender");
		
		//일자 달력 생성 / 시트 달력에 추가
		calender = document.createElement("div");
		calender.setAttribute("class", "DateCalender");
		sheetCalender.appendChild(calender);
		//테이블 생성
		table = document.createElement("table");
		calender.appendChild(table);
		//테이블 내 소스 생성
		tableContent = "";
		tableContent += "<tr>";
		tableContent += 	"<th colspan=\"1\" class=\"prev_month clickable\"> &#xecd8; </th>"
					 +		"<th colspan=\"5\" class=\"year_month clickable\">  </th>"
					 +		"<th colspan=\"1\" class=\"next_month clickable\"> &#xecda; </th>";
		tableContent += "</tr>";
		tableContent += "<tr>";
		tableContent += 	"<th class=\"sunday\">" + getText("message_easysheetrender_907", "일") + "</th>"
					 +		"<th>" + getText("message_easysheetrender_908", "월") + "</th>"
					 +		"<th>" + getText("message_easysheetrender_909", "화") + "</th>"
					 +		"<th>" + getText("message_easysheetrender_910", "수") + "</th>"
					 +		"<th>" + getText("message_easysheetrender_911", "목") + "</th>"
					 +		"<th>" + getText("message_easysheetrender_912", "금") + "</th>"
					 +		"<th class=\"saturday\">" + getText("message_easysheetrender_913", "토") + "</th>";
		tableContent += "</tr>";
		for(i = 0; i < 6; i++){
			tableContent += "<tr> ";
			tableContent += 	"<td class=\"sunday\"></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td class=\"saturday\"></td> ";
			tableContent += "</tr> ";
		}
		tableContent += "<tr> ";
		tableContent += 	"<th colspan=\"5\" class=\"time_btn clickable\"> &#xe993; </th> ";
		tableContent += 	"<th colspan=\"2\" class=\"today_btn clickable\"> Today </th> ";
		tableContent += "</tr> ";
		//테이블 내 소스 추가
		table.innerHTML = tableContent;
		//이벤트 처리
		setEventHandler(table, "click", sheetDateCalenderClick);
		//메모리 해제
		tableContent = null; table = null; calender = null;
		
		//년월 달력 생성 / 시트 달력에 추가
		calender = document.createElement("div");
		calender.setAttribute("class", "MonthCalender");
		sheetCalender.appendChild(calender);
		//테이블 생성
		table = document.createElement("table");
		calender.appendChild(table);
		//테이블 내 소스 생성
		tableContent = "";
		tableContent += "<tr> ";
		tableContent += 	"<th colspan=\"1\" class=\"prev_btn clickable\"> &#xecd8; </th> ";
		tableContent += 	"<th colspan=\"2\" class=\"year_month clickable\"> </th> ";
		tableContent += 	"<th colspan=\"1\" class=\"next_btn clickable\"> &#xecda; </th> ";
		tableContent += "</tr> ";
		for(i = 0; i < 3; i++){
			tableContent += "<tr> ";
			
			for(j = 1; j < 5; j++, value = null){
				value = "" + (j + (4 * i));
				tableContent += "<td class=\"clickable\" month=\"" + value + "\"> " + getText("message_easysheetrender_month" + value, value) + " </td> ";
			}
			
			tableContent += "</tr> ";
		}
		//테이블 내 소스 추가
		table.innerHTML = tableContent;
		//이벤트 처리
		setEventHandler(table, "click", sheetMonthCalenderClick);
		//메모리 해제
		tableContent = null; table = null; calender = null;
		
		//년도 달력 생성 / 시트 달력에 추가
		calender = document.createElement("div");
		calender.setAttribute("class", "YearCalender");
		sheetCalender.appendChild(calender);
		//테이블 생성
		table = document.createElement("table");
		calender.appendChild(table);
		//테이블 내 소스 생성
		tableContent = "";
		tableContent += "<tr> ";
		tableContent += 	"<th colspan=\"1\" class=\"prev_btn clickable\"> &#xecd8; </th> ";
		tableContent += 	"<th colspan=\"3\" class=\"year_month\"> </th> ";
		tableContent += 	"<th colspan=\"1\" class=\"next_btn clickable\"> &#xecda; </th> ";
		tableContent += "</tr> ";
		for(i = 0; i < 5; i++){
			tableContent += "<tr> ";
			tableContent += 	"<td class=\"clickable\"></td> <td class=\"clickable\"></td> <td class=\"clickable\"></td> <td class=\"clickable\"></td> <td class=\"clickable\"></td> ";
			tableContent += "</tr> ";
		}
		//테이블 내 소스 추가
		table.innerHTML = tableContent;
		//이벤트 처리
		setEventHandler(table, "click", sheetYearCalenderClick);
		//메모리 해제
		tableContent = null; table = null; calender = null;
		
		//시간 달력 생성 / 시트 달력에 추가
		calender = document.createElement("div");
		calender.setAttribute("class", "TimeCalender");
		sheetCalender.appendChild(calender);
		//테이블 생성
		table = document.createElement("table");
		calender.appendChild(table);
		//테이블 내 소스 생성
		tableContent = "";
		tableContent += "<tr> ";
		tableContent += 	"<th colspan=\"5\" class=\"date_btn clickable\"> &#xe85b; </th> ";
		tableContent += "</tr> ";
		tableContent += "<tr> ";
		tableContent += 	"<td class=\"hour_up clickable\"> &#xe86d; </td> <td> &nbsp; </td> ";
		tableContent += 	"<td class=\"minutes_up clickable\"> &#xe86d; </td> <td> &nbsp; </td> ";
		tableContent += 	"<td class=\"seconds_up clickable\"> &#xe86d; </td> ";
		tableContent += "</tr> ";
		tableContent += "<tr> ";
		tableContent += 	"<td></td> <td> : </td> <td></td> <td> : </td> <td></td> ";
		tableContent += "</tr> ";
		tableContent += "<tr> ";
		tableContent += 	"<td class=\"hour_down clickable\"> &#xe86c; </td> <td> &nbsp; </td> ";
		tableContent += 	"<td class=\"minutes_down clickable\"> &#xe86c; </td> <td> &nbsp; </td> ";
		tableContent += 	"<td class=\"seconds_down clickable\"> &#xe86c; </td> ";
		tableContent += "</tr> ";
		tableContent += "<tr> ";
		tableContent += 	"<th colspan=\"5\" class=\"apply_btn clickable\"> Apply </th> ";
		tableContent += "</tr> ";
		//테이블 내 소스 추가
		table.innerHTML = tableContent;
		//이벤트 처리
		setEventHandler(table, "click", sheetTimeCalenderClick);
		//메모리 해제
		tableContent = null; table = null; calender = null;
		
		//시트 달력 body 에 추가
		//document.body.appendChild(sheetCalender);
		this.SheetObject.appendChild(sheetCalender);
	}
	
	//시트에 연결된 달력이 없는 경우
	if( this.SheetEditCalenderObject == null ){
		this.SheetEditCalenderObject = sheetCalender;
	}
	
	//시트 달력의 현재 연결중인 시트를 설정
	this.SheetEditCalenderObject.setAttribute("targetSheet", this.controlId);
	
	//메모리 해제
	tableContent = null; table = null;
	calender = null; sheetCalender = null;
	
	return true;
};





EasySheetRenderer.prototype.moveToRow = function(rowNum){
	//예외처리
	//-행 인덱스가 입력되지 않거나 행 범위 내에 없다면 에러
	if( typeof rowNum == "undefined" || (typeof rowNum != "number" && !(rowNum >= 0 && rowNum < this.dataRowCount)) )
		return false;
	
	//행 이동 여부 체크
	var rGapSize = 0;
	if( !(rowNum >= this.showedTopRowIndex && rowNum < this.showedTopRowIndex + this.wholeShownRowCount) ){
		rGapSize = rowNum - this.showedTopRowIndex - this.wholeShownRowCount + 1;
	}
	
	//스크롤 이동 크기 계산
	if( rGapSize < 0 ){
		rGapSize = (this.showedTopRowIndex - rowNum) * -1;
	}
	
	//현재 화면내 보이는 행 인덱스인 경우 스크롤 이동하지 않고 빠져나감
	if( rGapSize == 0 ){
		return true;
	}
	
	//시트 탐색
	var sheet = controls[this.controlName];
	//렌더러에서 시트를 찾지 못한 경우
	if( (typeof sheet == "undefined" || sheet == null) && !(typeof EasySheet != "undefined" && sheet instanceof EasySheet) ){
		//메모리 해제
		sheet = null;
		return false;
	}
	
	//수직스크롤 이동 정보 설정
	var scrollInfo = self["_SheetScrollMovingInfo"] = {
			"sheet" : sheet
			, "vScrollDirection" : rGapSize /* 수직스크롤 방향(및 크기) 설정 */
	};
	
	//스크롤 이동
	moveSheetVScroll();
	
	//수평스크롤 이동 정보 초기화
	if( scrollInfo != null && typeof scrollInfo != "undefined" ){
		scrollInfo.vScrollDirection = 0;
		scrollInfo.sheet = null;
		scrollInfo = null;
	}
	self["_SheetScrollMovingInfo"] = null;
	
	//메모리 해제
	sheet = null;
	
	return true;
};

EasySheetRenderer.prototype.moveToColumn = function(colNum){
	//예외처리
	//-열 범위 내에 없다면 에러
	if( typeof colNum == "undefined" || typeof colNum != "number" || !(colNum >= 0 && colNum < this.columnInfo.length) )
		return false;
	
	var columnIndex = 0; var columnWidth = 0;
	var columnWidthSum = 0; var columnWidthSumBeforeColNum = 0;
	var cGapSize = 0; var hScrollMoveStep = 0;
	
	var sheet = null; var headerCell = null;
	var colInfo = null; var colStyle = null;
	var headerInfos = null; var headerInfo = null;
	var columnRow = 0; var columnCol = 0;
	var columnRowspan = 0; var columnColspan = 0;
	var headerStartIndex = 0; var headerRowIndex = 0; var headerColumnIndex = 0;
	var i = 0;
	
	colInfo = this.columnInfo[colNum];
	columnRow = colInfo.row - 1;
	columnCol = colInfo.col - 1;
	
	headerStartIndex = this.headerInfo.length - this.rowsPerDataRow;
	headerInfos = this.headerInfo[headerStartIndex + columnRow];
	
	if( this.isShowRowHeader ){
		columnWidthSumBeforeColNum += this.sheetRowHeaderWidth;
		columnWidthSum += this.sheetRowHeaderWidth;
	}
	
	for(i = 0; i < this.colsPerRow; i++, headerInfo = null){
		headerInfo = headerInfos[i];
		headerRowIndex = headerInfo.rowIndex;
		headerColumnIndex = headerInfo.cellIndex;
		columnRowspan = headerInfo.rowspan;
		columnColspan = headerInfo.colspan;
		
		if( ((headerRowIndex < columnRow && columnRowspan < 0) || (headerRowIndex == columnRow && columnColspan > 0))
			&& headerColumnIndex <= columnCol
		){
			headerCell = this.headerInfo[headerStartIndex + headerRowIndex][i].cells.header;
			colStyle = getComputedStyle(headerCell);
			
			if( colStyle.display != "none" ){
				columnWidth = ((1 * colStyle.width.replace("px", "")) /*+ 1*/);
				columnWidthSumBeforeColNum += (headerColumnIndex < columnCol ? columnWidth : 0);
				columnWidthSum += columnWidth;
			}
			
			//메모리 해제
			colStyle = null; headerCell = null;
		}
		
		if( headerRowIndex == columnRow && headerColumnIndex == columnCol ) break;
	}
	
	//열 이동 여부 체크 : 컬럼 너비 합이 시트 본문 Div 너비와 시트 본문 테이블 이동한 너비의 합으로 컬럼의 위치를 찾음
	cGapSize = columnWidthSum - Math.ceil(this.sheetContentDivWidth) + Math.ceil(this.sheetContentTableLeft * -1) + (this.rightFixColumnCount > 0 ? this.sheetRightFixWidth : 0);
	
	//컬럼 너비의 합이 크다면 숨겨진 우측 컬럼으로 이동함
	if( cGapSize > 0 ){
		//컬럼 너비와 시트 본문 Div 너비, 시트 본문 테이블 이동한 너비의 합의 차이로 수평스크롤 이동 값을 계산
		hScrollMoveStep = Math.ceil(cGapSize / this.tableMovePerHScrollFaceMove);
	}
	//컬럼 너비의 합이 크다면 숨겨진 좌측 컬럼으로 이동함
	else if( cGapSize < 0 ){
		//숨겨진 좌측 컬럼의 경우 시트 본문 테이블 이동한 너비에서 지정한 컬럼 전까지의 컬럼 너비의 합의 차이로 수평스크롤 이동값을 계산
		cGapSize = Math.ceil(this.sheetContentTableLeft) - columnWidthSumBeforeColNum + (this.isShowRowHeader ? this.sheetRowHeaderWidth : 0) + (this.leftFixColumnCount > 0 ? this.sheetLeftFixWidth : 0);
		//위에서 구한 차이가 0보다 큰 경우에만 이동함, 0보다 작거나 같으면 화면내에 보이는 컬럼
		if( cGapSize > 0 ){
			//좌측으로 이동해야 하므로 -1 을 곱하여 음수로 만듬
			hScrollMoveStep = Math.ceil(cGapSize / this.tableMovePerHScrollFaceMove) * -1;
		}
	}
	
	//현재 화면내 보이는 열 인덱스인 경우 스크롤 이동하지 않고 빠져나감
	if( hScrollMoveStep == 0 ){
		//메모리 해제 및 초기화
		hScrollMoveStep = null; cGapSize = null;
		columnWidthSumBeforeColNum = null;
		columnWidthSum = null; columnWidth = null;
		
		return true;
	}
	
	//시트 탐색
	sheet = controls[this.controlName];
	//렌더러에서 시트를 찾지 못한 경우
	if( (typeof sheet == "undefined" || sheet == null) && !(typeof EasySheet != "undefined" && sheet instanceof EasySheet) ){
		sheet = null; hScrollMoveStep = null; cGapSize = null;
		columnWidthSumBeforeColNum = null;
		columnWidthSum = null; columnWidth = null;
		return false;
	}
	
	//수평스크롤 이동 정보 설정
	var scrollInfo = self["_SheetScrollMovingInfo"] = {
			"sheet" : sheet
			, "hScrollDirection" : hScrollMoveStep /* 수평스크롤 방향(및 크기) 설정 */
	};
	
	//스크롤 이동
	moveSheetHScroll();
	
	//수평스크롤 이동 정보 초기화
	if( scrollInfo != null && typeof scrollInfo != "undefined" ){
		scrollInfo.hScrollDirection = 0;
		scrollInfo.sheet = null;
		scrollInfo = null;
	}
	self["_SheetScrollMovingInfo"] = null;
	
	//메모리 해제 및 초기화
	sheet = null; headerInfo = null; headerInfos = null;
	headerCell = null; colStyle = null; colInfo = null;
	
	return true;
};

EasySheetRenderer.prototype.moveTo = function(rowNum, colNum){
	//예외처리
	if( typeof rowNum != "number" || !(rowNum >= 0 && rowNum < this.dataRowCount) )
		return false;
	if( typeof colNum != "number" || !(colNum >= 0 && colNum < this.columnInfo.length) )
		return false;
	
	//셀의 행 인덱스 설정 및 이벤트 호출
	if( !this.setSelectedRowIndex(rowNum) )
		return false;
	//셀의 열 인덱스 설정 및 이벤트 호출
	if( !this.setSelectedColumnIndex(colNum) )
		return false;
	
	//행 이동
	this.moveToRow(rowNum);
	//열 이동
	this.moveToColumn(colNum);
	
	//변경된 행 인덱스에 편집컨트롤 세팅
	return this.setSheetEditControl();
	
//	return true;
};

EasySheetRenderer.prototype.moveToNextCell = function( /*rowNum, colNum*/ ){
	var args = Array.prototype.slice.call(arguments);
	var rowNum = this.selectedRowIndex;
	var colNum = this.selectedColumnIndex;
	
	var isReadOnly = false;
	var isHidden = false;
	var isMoved = false;
	var i = 0;
	var j = 0;
	
	//파라메터 체크
	if(args.length == 1){
		//파라메터를 1개만 받았고 파라메터 타입이 number 인 경우 colNum 은 현재 인덱스로 처리하고, 받은 파라메터는 이동할 셀의 행 인덱스로 처리
		if(typeof args[0] == "number"){
			rowNum = args[0] * 1;
		}
		else{
			args = null;	//메모리 해제 및 초기화
			return false;
		}
	}
	else if(args.length == 2){
		//파라메터가 2개만 받은 경우 첫번째는 rowNum, 두번째는 colNum 으로 처리
		if(typeof args[0] != "number" || typeof args[1] != "number"){
			args = null;	//메모리 해제 및 초기화
			return false;
		}
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if( args.length > 2 ){
		args = null;	//메모리 해제 및 초기화
		return false;	//파라메터 처리가능한 인수를 초과
	}
	
	//다음 셀 열 인덱스 계산
	colNum = colNum + 1;
	//열 인덱스가 열 범위를 넘을 경우 다음 행으로 이동
	if( colNum > this.columnInfo.length - 1 ){
		colNum = 0;
		rowNum = rowNum + 1;
	}
	
	args = null;
	
	//예외처리
	if( typeof rowNum != "number" || !(rowNum >= 0 && rowNum < this.dataRowCount) )
		return false;
	if( typeof colNum != "number" || !(colNum >= 0 && colNum < this.columnInfo.length) )
		return false;
	
	//이동 가능한 다음 셀 탐색하여 이동
	for(i = rowNum; i < this.dataRowCount && !isMoved; i++){
		for(j = colNum; j < this.columnInfo.length && !isMoved; j++){
			isReadOnly = this.columnInfo[j].readOnly;
			isHidden = this.columnInfo[j].hidden;
			//열 이동 가능 체크 : 잠김 또는 숨김 열은 이동 불가
			if( !isReadOnly && !isHidden ){
				//편집컨트롤이 활성화된 경우 편집컨트롤을 닫은 후 셀을 이동
				if( this.isEditngSheet ){
					//수정 데이터 적용 및 이벤트 처리
					if( !this.setApplyChangedValueToCell(true) ){
						recordState = null;	//메모리 해제 및 초기화
						return false;
					}
					//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
					this.isIgnoreEditingControlBlurEvent = true;
					//편집 컨트롤 닫음
					this.removeSheetEditControl();
				}
				
				//셀 이동
				isMoved = this.moveTo(i, j);
			}
		}
		
		//한 행을 다 탐색하였으므로 다시 첫번째 열부터 다시 탐색하기 위해 colNum 을 0으로 초기화
		colNum = 0;
	}
	
//	//이동 가능한 다음 셀을 찾지 못한 경우
//	if( !isMoved ){
//		//메모리 해제 및 초기화
//		i = null; j = null; isMoved = null;
//		rowNum = null; colNum = null;
//		return false;
//	}
//	
//	//변경된 행 인덱스에 편집컨트롤 세팅
//	this.setSheetEditControl();
	
	return isMoved;
};

EasySheetRenderer.prototype.moveToFormerCell = function( /*rowNum, colNum*/ ){
	var args = Array.prototype.slice.call(arguments);
	var rowNum = this.selectedRowIndex;
	var colNum = this.selectedColumnIndex;
	
	var isReadOnly = false;
	var isHidden = false;
	var isMoved = false;
	var i = 0;
	var j = 0;
	
	//파라메터 체크
	if(args.length == 1){
		//파라메터를 1개만 받았고 파라메터 타입이 number 인 경우 colNum 은 현재 인덱스로 처리하고, 받은 파라메터는 이동할 셀의 행 인덱스로 처리
		if(typeof args[0] == "number"){
			rowNum = args[0] * 1;
		}
		else{
			args = null;	//메모리 해제 및 초기화
			return false;
		}
	}
	else if(args.length == 2){
		//파라메터가 2개만 받은 경우 첫번째는 rowNum, 두번째는 colNum 으로 처리
		if(typeof args[0] != "number" || typeof args[1] != "number"){
			args = null;	//메모리 해제 및 초기화
			return false;
		}
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if( args.length > 2 ){
		args = null;	//메모리 해제 및 초기화
		return false;	//파라메터 처리가능한 인수를 초과
	}
	
	args = null;
	
	//이전 셀 열 인덱스 계산
	colNum = colNum - 1;
	//열 인덱스가 열 범위를 넘을 경우 이전 행으로 이동
	if( colNum < 0 ){
		colNum = this.columnInfo.length - 1;
		rowNum = rowNum - 1;
	}
	
	//예외처리
	if( typeof rowNum != "number" || !(rowNum >= 0 && rowNum < this.dataRowCount) )
		return false;
	if( typeof colNum != "number" || !(colNum >= 0 && colNum < this.columnInfo.length) )
		return false;
	
	//이동 가능한 다음 셀 탐색하여 이동
	for(i = rowNum; i >= 0 && !isMoved; i--){
		for(j = colNum; j >= 0 && !isMoved; j--){
			isReadOnly = this.columnInfo[j].readOnly;
			isHidden = this.columnInfo[j].hidden;
			
			//열 이동 가능 체크 : 잠김 또는 숨김 열은 이동 불가
			if( !isReadOnly && !isHidden ){
				//편집컨트롤이 활성화된 경우 편집컨트롤을 닫은 후 셀을 이동한다.
				if( this.isEditngSheet ){
					//수정 데이터 적용 및 이벤트 처리
					if( !this.setApplyChangedValueToCell(true) ){
						recordState = null;	//메모리 해제 및 초기화
						return false;
					}
					//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
					this.isIgnoreEditingControlBlurEvent = true;
					//편집 컨트롤 닫음
					this.removeSheetEditControl();
				}
				
				//셀 이동
				isMoved = this.moveTo(i, j);
			}
		}
		
		//한 행을 다 탐색하였으므로 다시 첫번째 열부터 다시 탐색하기 위해 colNum 을 0으로 초기화
		colNum = this.columnInfo.length - 1;
	}
	
//	//이동 가능한 다음 셀을 찾지 못한 경우
//	if( !isMoved ){
//		//메모리 해제 및 초기화
//		i = null; j = null; isMoved = null;
//		rowNum = null; colNum = null;
//		return false;
//	}
//	
//	//변경된 행 인덱스에 편집컨트롤 세팅
//	this.setSheetEditControl();
	
	return isMoved;
};

EasySheetRenderer.prototype.moveToRightCell = function( /*rowNum, colNum*/ ){
	var args = Array.prototype.slice.call(arguments);
	var rowNum = this.selectedRowIndex;
	var colNum = this.selectedColumnIndex;
	
	var isReadOnly = false;
	var isHidden = false;
	var isMoved = false;
	var i = 0;
	
	//파라메터 체크
	if(args.length == 1){
		//파라메터를 1개만 받았고 파라메터 타입이 number 인 경우 colNum 은 현재 인덱스로 처리하고, 받은 파라메터는 이동할 셀의 행 인덱스로 처리
		if(typeof args[0] == "number"){
			rowNum = args[0] * 1;
		}
		else{
			args = null;	//메모리 해제 및 초기화
			return false;
		}
	}
	else if(args.length == 2){
		//파라메터가 2개만 받은 경우 첫번째는 rowNum, 두번째는 colNum 으로 처리
		if(typeof args[0] != "number" || typeof args[1] != "number"){
			args = null;	//메모리 해제 및 초기화
			return false;
		}
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if( args.length > 2 ){
		args = null;	//메모리 해제 및 초기화
		return false;	//파라메터 처리가능한 인수를 초과
	}
	
	args = null;
	
	//예외처리
	if( typeof rowNum != "number" || !(rowNum >= 0 && rowNum < this.dataRowCount) )
		return false;
	if( typeof colNum != "number" || !(colNum >= 0 && colNum < this.columnInfo.length) )
		return false;
	
	//이동 가능한 다음 셀 탐색하여 이동
	for(i = colNum + 1; i < this.columnInfo.length && !isMoved; i++){
		isReadOnly = this.columnInfo[i].readOnly;
		isHidden = this.columnInfo[i].hidden;
		
		//열 이동 가능 체크 : 잠김 또는 숨김 열은 이동 불가
		if( !isReadOnly && !isHidden ){
			//편집컨트롤이 활성화된 경우 편집컨트롤을 닫은 후 셀을 이동한다.
			if( this.isEditngSheet ){
				//수정 데이터 적용 및 이벤트 처리
				if( !this.setApplyChangedValueToCell(true) ){
					return false;
				}
				//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
				this.isIgnoreEditingControlBlurEvent = true;
				//편집 컨트롤 닫음
				this.removeSheetEditControl();
			}
			
			//셀 이동
			isMoved = this.moveTo(rowNum, i);
		}
	}
	
//	//이동 가능한 다음 셀을 찾지 못한 경우
//	if( !isMoved ){
//		//메모리 해제 및 초기화
//		i = null; isMoved = null;
//		rowNum = null; colNum = null;
//		return false;
//	}
//	
//	//변경된 행 인덱스에 편집컨트롤 세팅
//	this.setSheetEditControl();
	
	return isMoved;
};

EasySheetRenderer.prototype.moveToLeftCell = function( /*rowNum, colNum*/ ){
	var args = Array.prototype.slice.call(arguments);
	var rowNum = this.selectedRowIndex;
	var colNum = this.selectedColumnIndex;
	
	var isReadOnly = false;
	var isHidden = false;
	var isMoved = false;
	var i = 0;
	
	//파라메터 체크
	if(args.length == 1){
		//파라메터를 1개만 받았고 파라메터 타입이 number 인 경우 colNum 은 현재 인덱스로 처리하고, 받은 파라메터는 이동할 셀의 행 인덱스로 처리
		if(typeof args[0] == "number"){
			rowNum = args[0] * 1;
		}
		else{
			args = null;	//메모리 해제 및 초기화
			return false;
		}
	}
	else if(args.length == 2){
		//파라메터가 2개만 받은 경우 첫번째는 rowNum, 두번째는 colNum 으로 처리
		if(typeof args[0] != "number" || typeof args[1] != "number"){
			args = null;	//메모리 해제 및 초기화
			return false;
		}
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if( args.length > 2 ){
		args = null;	//메모리 해제 및 초기화
		return false;	//파라메터 처리가능한 인수를 초과
	}
	
	args = null;
	
	//예외처리
	if( typeof rowNum != "number" || !(rowNum >= 0 && rowNum < this.dataRowCount) )
		return false;
	if( typeof colNum != "number" || !(colNum >= 0 && colNum < this.columnInfo.length) )
		return false;
	
	//이동 가능한 다음 셀 탐색하여 이동 //이전 셀 열 인덱스 계산
	for(i = colNum - 1; i >= 0 && !isMoved; i--){
		isReadOnly = this.columnInfo[i].readOnly;
		isHidden = this.columnInfo[i].hidden;
		
		//열 이동 가능 체크 : 잠김 또는 숨김 열은 이동 불가
		if( !isReadOnly && !isHidden ){
			//편집컨트롤이 활성화된 경우 편집컨트롤을 닫은 후 셀을 이동한다.
			if( this.isEditngSheet ){
				//수정 데이터 적용 및 이벤트 처리
				if( !this.setApplyChangedValueToCell(true) ){
					return false;
				}
				//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
				this.isIgnoreEditingControlBlurEvent = true;
				//편집 컨트롤 닫음
				this.removeSheetEditControl();
			}
			
			//셀 이동
			isMoved = this.moveTo(rowNum, i);
		}
	}
	
//	//이동 가능한 다음 셀을 찾지 못한 경우
//	if( !isMoved ){
//		//메모리 해제 및 초기화
//		i = null; isMoved = null;
//		rowNum = null; colNum = null;
//		return false;
//	}
//	
//	//변경된 행 인덱스에 편집컨트롤 세팅
//	this.setSheetEditControl();
	
	return isMoved;
};

EasySheetRenderer.prototype.moveToLowerCell = function( /*rowNum, colNum*/ ){
	var args = Array.prototype.slice.call(arguments);
	var rowNum = this.selectedRowIndex;
	var colNum = this.selectedColumnIndex;
	
	var isReadOnly = false;
	var isHidden = false;
	var isMoved = false;
	var i = 0;
	
	//파라메터 체크
	if(args.length == 1){
		//파라메터를 1개만 받았고 파라메터 타입이 number 인 경우 colNum 은 현재 인덱스로 처리하고, 받은 파라메터는 이동할 셀의 행 인덱스로 처리
		if(typeof args[0] == "number"){
			rowNum = args[0] * 1;
		}
		else{
			args = null;	//메모리 해제 및 초기화
			return false;
		}
	}
	else if(args.length == 2){
		//파라메터가 2개만 받은 경우 첫번째는 rowNum, 두번째는 colNum 으로 처리
		if(typeof args[0] != "number" || typeof args[1] != "number"){
			args = null;	//메모리 해제 및 초기화
			return false;
		}
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if( args.length > 2 ){
		args = null;	//메모리 해제 및 초기화
		return false;	//파라메터 처리가능한 인수를 초과
	}
	
	args = null;
	
	//예외처리
	if( typeof rowNum != "number" || !(rowNum >= 0 && rowNum < this.dataRowCount) )
		return false;
	if( typeof colNum != "number" || !(colNum >= 0 && colNum < this.columnInfo.length) )
		return false;
	
	//이동 가능한 다음 셀 탐색하여 이동
	for(i = rowNum + 1; i < this.dataRowCount && !isMoved; i++){
		isReadOnly = this.columnInfo[colNum].readOnly;
		isHidden = this.columnInfo[colNum].hidden;
		
		//열 이동 가능 체크 : 잠김 또는 숨김 열은 이동 불가
		if( !isReadOnly && !isHidden ){
			//편집컨트롤이 활성화된 경우 편집컨트롤을 닫은 후 셀을 이동한다.
			if( this.isEditngSheet ){
				//수정 데이터 적용 및 이벤트 처리
				if( !this.setApplyChangedValueToCell(true) ){
					//메모리 해제 및 초기화
					recordState = null;
					return false;
				}
				//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
				this.isIgnoreEditingControlBlurEvent = true;
				//편집 컨트롤 닫음
				this.removeSheetEditControl();
			}
			
			//셀 이동
			isMoved = this.moveTo(i, colNum);
		}
	}
	
//	//이동 가능한 다음 셀을 찾지 못한 경우
//	if( !isMoved ){
//		//메모리 해제 및 초기화
//		i = null; isMoved = null;
//		rowNum = null; colNum = null;
//		return false;
//	}
//	
//	//변경된 행 인덱스에 편집컨트롤 세팅
//	this.setSheetEditControl();
	
	return isMoved;
};

EasySheetRenderer.prototype.moveToUpperCell = function( /*rowNum, colNum*/ ){
	var args = Array.prototype.slice.call(arguments);
	var rowNum = this.selectedRowIndex;
	var colNum = this.selectedColumnIndex;
	
	var isReadOnly = false;
	var isHidden = false;
	var isMoved = false;
	var i = 0;
	
	//파라메터 체크
	if(args.length == 1){
		//파라메터를 1개만 받았고 파라메터 타입이 number 인 경우 colNum 은 현재 인덱스로 처리하고, 받은 파라메터는 이동할 셀의 행 인덱스로 처리
		if(typeof args[0] == "number"){
			rowNum = args[0] * 1;
		}
		else{
			args = null;	//메모리 해제 및 초기화
			return false;
		}
	}
	else if(args.length == 2){
		//파라메터가 2개만 받은 경우 첫번째는 rowNum, 두번째는 colNum 으로 처리
		if(typeof args[0] != "number" || typeof args[1] != "number"){
			args = null;	//메모리 해제 및 초기화
			return false;
		}
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if( args.length > 2 ){
		args = null;	//메모리 해제 및 초기화
		return false;	//파라메터 처리가능한 인수를 초과
	}
	
	args = null;
	
	//예외처리
	if( typeof rowNum != "number" || !(rowNum >= 0 && rowNum < this.dataRowCount) )
		return false;
	if( typeof colNum != "number" || !(colNum >= 0 && colNum < this.columnInfo.length) )
		return false;
	
	//이동 가능한 다음 셀 탐색하여 이동
	for(i = rowNum - 1; i >= 0 && !isMoved; i--){
		isReadOnly = this.columnInfo[colNum].readOnly;
		isHidden = this.columnInfo[colNum].hidden;
		
		//열 이동 가능 체크 : 잠김 또는 숨김 열은 이동 불가
		if( !isReadOnly && !isHidden ){
			//편집컨트롤이 활성화된 경우 편집컨트롤을 닫은 후 셀을 이동한다.
			if( this.isEditngSheet ){
				//수정 데이터 적용 및 이벤트 처리
				if( !this.setApplyChangedValueToCell(true) ){
					return false;
				}
				//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
				this.isIgnoreEditingControlBlurEvent = true;
				//편집 컨트롤 닫음
				this.removeSheetEditControl();
			}
			
			//셀 이동
			isMoved = this.moveTo(i, colNum);
		}
	}
	
//	//이동 가능한 다음 셀을 찾지 못한 경우
//	if( !isMoved ){
//		//메모리 해제 및 초기화
//		i = null; isMoved = null;
//		rowNum = null; colNum = null;
//		return false;
//	}
//	
//	//변경된 행 인덱스에 편집컨트롤 세팅
//	this.setSheetEditControl();
	
	return isMoved;
};

EasySheetRenderer.prototype.moveToFirstCell = function( /*rowNum*/ ){
	var args = Array.prototype.slice.call(arguments);
	var rowNum = this.selectedRowIndex;
	var colNum = 0;
	
	var isReadOnly = false;
	var isHidden = false;
	var isMoved = false;
	var i = 0;
	
	//파라메터 체크
	if(args.length == 1){
		//파라메터를 1개만 받았고 파라메터 타입이 number 인 경우 colNum 은 현재 인덱스로 처리하고, 받은 파라메터는 이동할 셀의 행 인덱스로 처리
		if(typeof args[0] == "number"){
			rowNum = args[0] * 1;
		}
		else{
			args = null;	//메모리 해제 및 초기화
			return false;
		}
	}
	else if( args.length > 1 ){
		args = null;	//메모리 해제 및 초기화
		return false;	//파라메터 처리가능한 인수를 초과
	}
	
	args = null;
	
	//예외처리
	if( typeof rowNum != "number" || !(rowNum >= 0 && rowNum < this.dataRowCount) )
		return false;
	
	//이동 가능한 다음 셀 탐색하여 이동
	for(i = colNum; i < this.columnInfo.length && !isMoved; i++){
		isReadOnly = this.columnInfo[i].readOnly;
		isHidden = this.columnInfo[i].hidden;
		
		//열 이동 가능 체크 : 잠김 또는 숨김 열은 이동 불가
		if( !isReadOnly && !isHidden ){
			//편집컨트롤이 활성화된 경우 편집컨트롤을 닫은 후 셀을 이동한다.
			if( this.isEditngSheet ){
				//수정 데이터 적용 및 이벤트 처리
				if( !this.setApplyChangedValueToCell(true) ){
					return false;
				}
				//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
				this.isIgnoreEditingControlBlurEvent = true;
				//편집 컨트롤 닫음
				this.removeSheetEditControl();
			}
			//셀 이동
			isMoved = this.moveTo(rowNum, i);
		}
	}
	
	//이동 가능한 다음 셀을 찾지 못한 경우
	if( !isMoved )
		this.moveTo(rowNum, 0);	//이동 가능한 다음 셀을 찾지 못하면 첫번째 셀로 이동
	
	return true;
};

EasySheetRenderer.prototype.addColumn = function(columnIndex, columnObject){
	if( typeof columnIndex != "number" || !(columnIndex >= 0 && columnIndex <= this.columnInfo.length) )
		return false;
	if( typeof columnObject == "undefined" || columnObject == null )
		return false;
	
	var defaultColumnInfo = null; var columnInfo = null; var headerInfos = null;
	var addHeaderInfo = null; var addColumnInfo = null; var addColumnObject = null;
	var headerRowItem = null; var headerColItem = null;
	var rows = null; var row = null;
	var leftFixRows = null; var rightFixRows = null;
	var cells = null; var cell = null;
	var cntPercentColumn = 0; var sumPercentColumn = 0;
	var rowIndex = 0; var rowIndexOrigin = 0; 
	var rowCount = 0; var colCount = 0;
	var rowspan = 0; var rowspanMax = 0;
	var colspan = 0; var colspanMax = 0;
	var rightFixGap = 0;
	var i = 0; var j = 0;
	
	//컬럼 기본 설정
	defaultColumnInfo = {
		width : "81px"
		, minWidth: "81px"
		, hidden : false
		, enable : true
		, fieldType : "string"
		, align : "left"
		, valign : "middle"
		, backgroundColor : ""
		, fontColor : ""
		, maxLength : -1
		, defalutValue : ""
		, displayFormat : ""
		, prefix : ""
		, suffix : ""
		, title : ""
		, tooltip : ""
		, columnStyleClass : null
		, cellType : "text"
		, readOnly : false
	};
	
	//컬럼 정보 추가
	this.columnInfo.splice(columnIndex, 0, defaultColumnInfo);
	//컬럼 속성 설정
	this.setColumnInfo(columnIndex, columnObject);
	
	addColumnInfo = this.columnInfo[columnIndex];
	
	//컬럼 필드 기준으로 매칭되는 인덱스 매핑 정보 초기화
	this.columnIndexMapByField = null;
	this.columnIndexMapByField = {};
	//
	for(i = 0, colCount = this.columnInfo.length; i < colCount; i++, columnInfo = null){
		columnInfo = this.columnInfo[i];
		
		//반응형 컬럼인 경우 컬럼 너비의 비율 설정
		if( !columnInfo.isFixedWidth ){
			//반응형 컬럼의 개수 구함
			cntPercentColumn++;
			//반응형 컬럼의 너비 총합을 구함
			sumPercentColumn += columnInfo.percentWidth;
		}
		//
		columnInfo.index = i;
//		columnInfo.col = i + 1;
		
		//컬럼 필드 기준으로 매칭되는 인덱스 매핑 정보 설정
		this.columnIndexMapByField["" + columnInfo.field] = i;
	}
	//시트의 반응형 컬럼의 개수와 총합
	this._cntResponsibleColumnWidth = cntPercentColumn; //cntPercentColumn == this.columnInfo.length;
	this._sumResponsibleColumnWidth = sumPercentColumn; //sumPercentColumn == 100;
	
	rowIndex = this.headerInfo.length - this.rowsPerDataRow;
	rightFixGap = this.colsPerRow - this.rightFixColumnCount;
	
	//추가헤더 정보 추가
	for(i = 0, colspan = 1, headerRowItem = null; i < rowIndex; colspan = 1){
		headerRowItem = this.headerInfo[i];
		
		//컬럼 병합정보 계산
		if( columnIndex > 0 ){
			for(headerInfos = this.headerInfo[i], j = columnIndex - 1, colspan = 1; j >= 0; j--, headerColItem = null){
				headerColItem = headerInfos[j];
				if( headerColItem.colspanMax > 0 ) break;
				if( headerColItem.colspanMax < 0 ) colspan++;
			}
			headerInfos = null;
			
			rowspanMax = headerColItem.rowspanMax;
			colspanMax = headerColItem.colspanMax;
		}
		else{
			rowspanMax = 1;
			colspanMax = 1;
		}
		//추가되는 컬럼의 인덱스가 병합된 셀 내에 있는 경우
		if( colspanMax > colspan ){
			headerColItem.colspanMax = headerColItem.colspanMax + 1;
			headerColItem.colspan = headerColItem.colspan + 1;
		}
		
		for(headerRowItem = null, rowspan = i + rowspanMax; i < rowspan && i < rowIndex; i++, headerRowItem = null){
			headerRowItem = this.headerInfo[i];
			//헤더 정보 컬럼 인덱스 조정
			for(j = columnIndex, colCount = headerRowItem.length; j < colCount; j++)
				headerRowItem[j].cellIndex = j + 1;
			//헤더 정보 추가
			headerRowItem.splice(columnIndex, 0, {});
			//헤더 속성 설정
			addHeaderInfo = headerRowItem[columnIndex];
			addHeaderInfo.rowIndex = i;
			addHeaderInfo.cellIndex = columnIndex;
			addHeaderInfo.rowspan = addHeaderInfo.rowspanMax = (colspanMax > colspan) ? rowspanMax : 1;
			addHeaderInfo.colspan = addHeaderInfo.colspanMax = (colspanMax > colspan) ? -1 : 1;
			addHeaderInfo.cells = (colspanMax > colspan) ? null : {};
			addHeaderInfo.childIndexs = null;
			addHeaderInfo.title = "";
			addHeaderInfo = null;
		}
		
		//메모리 해제
		headerColItem = null;
		headerRowItem = null;
	}
	
	//헤더 정보 추가
	headerRowItem = this.headerInfo[rowIndex];
	for(i = columnIndex, colCount = headerRowItem.length; i < colCount; i++)
		headerRowItem[i].cellIndex = i + 1;
	headerRowItem.splice(columnIndex, 0, {});
	//헤더 속성 설정
	headerColItem = headerRowItem[columnIndex];
	headerColItem.rowIndex = rowIndex - (this.headerInfo.length - this.rowsPerDataRow);
	headerColItem.cellIndex = columnIndex;
	headerColItem.rowspan = headerColItem.rowspanMax = 1;
	headerColItem.colspan = headerColItem.colspanMax = 1;
	headerColItem.cells = {};
	headerColItem.childIndexs = null;
	headerColItem.title = addColumnInfo.title;
	//행 내 컬럼 셀 개수 증가
	headerRowItem.cellCount++;
	//행별 셀 개수 증가
	this.colsPerRow = headerRowItem.length;
	if( columnIndex < this.leftFixColumnCount ) this.leftFixColumnCount++;
	if( this.rightFixColumnCount > 0 && columnIndex >= rightFixGap ) this.rightFixColumnCount++;
	
	//컬럼 태그 추가
	var minWidth = addColumnInfo.minWidth;
	var cellIndex = 0;
	
	//헤더
	rows = this.SheetHeaderObject.querySelectorAll("div.SheetHeaderDiv > table tr");
	leftFixRows = this.SheetHeaderObject.querySelectorAll("div.SheetHeaderLeftFixDiv > table tr");
	rightFixRows = this.SheetHeaderObject.querySelectorAll("div.SheetHeaderRightFixDiv > table tr");
	//헤더 행이 있다면
	if( rows != null ){
		rowIndex = rows.length - this.rowsPerDataRow;
		
		row = rows[rowIndex];
		cells = row.querySelectorAll("th");
		//줄 타이틀 셀이 있다면 인덱스를 1 증가
		if( cells[0].className.indexOf("RowHeader") >= 0 ) cellIndex = columnIndex + 1;
		//추가할 컬럼 인덱스의 셀을 구함
		cell = cells[cellIndex];
		if( typeof cell == "undefined" ) cell = null;
		
		//헤더 컬럼 생성
		addColumnObject = document.createElement("th");
		addColumnObject.style.minWidth = minWidth;
		addColumnObject.appendChild(document.createElement("div"));
		//행 객체에 컬럼 추가
		row.insertBefore(addColumnObject, cell);
		//헤더 정보 셀 추가
		headerColItem.cells["header"] = addColumnObject;
		
		//메모리 해제
		addColumnObject = null;
		cell = null; cells = null; row = null;
		
		//좌측 고정
		if( columnIndex < this.leftFixColumnCount ){
			row = leftFixRows[rowIndex];
			cells = row.querySelectorAll("th");
			//추가할 컬럼 인덱스의 셀을 구함
			cell = cells[cellIndex];
			if( typeof cell == "undefined" ) cell = null;
			
			//헤더 컬럼 생성
			addColumnObject = document.createElement("th");
			addColumnObject.style.minWidth = minWidth;
			addColumnObject.appendChild(document.createElement("div"));
			//행 객체에 컬럼 추가
			row.insertBefore(addColumnObject, cell);
			//헤더 정보 셀 추가
			headerColItem.cells["leftfix"] = addColumnObject;
			
			//메모리 해제
			addColumnObject = null;
			cell = null; cells = null; row = null;
		}
		
		//우측 고정
		if( this.rightFixColumnCount > 0 && columnIndex >= rightFixGap ){
			row = rightFixRows[rowIndex];
			cells = row.querySelectorAll("th");
			//추가할 컬럼 인덱스의 셀을 구함
			cell = cells[columnIndex - rightFixGap];
			if( typeof cell == "undefined" ) cell = null;
			
			//헤더 컬럼 생성
			addColumnObject = document.createElement("th");
			addColumnObject.style.minWidth = minWidth;
			addColumnObject.appendChild(document.createElement("div"));
			//행 객체에 컬럼 추가
			row.insertBefore(addColumnObject, cell);
			//헤더 정보 셀 추가
			headerColItem.cells["rightfix"] = addColumnObject;
			
			//메모리 해제
			addColumnObject = null;
			cell = null; cells = null; row = null;
		}
		
		//추가 헤더
		for(i = 0, headerRowItem = null, headerColItem = null; i < rowIndex;){
			headerRowItem = this.headerInfo[i];
			addHeaderInfo = headerRowItem[columnIndex];
			colspan = addHeaderInfo.colspanMax;
			
			if( colspan > 0 ){
				for(j = columnIndex + 1, colCount = headerRowItem.length; j < colCount; j++, headerColItem = null){
					headerColItem = headerRowItem[j];
					if( headerColItem.colspan > 0 ) break;
				}
				
				row = rows[i];
				cell = (headerColItem != null && headerColItem.cells != null) ? headerColItem.cells.header : null;
				//헤더 컬럼 생성
				addColumnObject = document.createElement("td");
				addColumnObject.className = "AddColHead";
				//행 객체에 컬럼 추가
				row.insertBefore(addColumnObject, cell);
				//헤더 정보 셀 추가
				addHeaderInfo.cells["header"] = addColumnObject;
				//메모리 해제
				addColumnObject = null; cell = null; row = null;
				
				//좌측 고정
				if( columnIndex < this.leftFixColumnCount ){
					row = leftFixRows[i];
					cell = (headerColItem != null && headerColItem.cells != null) ? headerColItem.cells.leftfix : null;
					//헤더 컬럼 생성
					addColumnObject = document.createElement("td");
					addColumnObject.className = "AddColHead";
					//행 객체에 컬럼 추가
					row.insertBefore(addColumnObject, cell);
					//헤더 정보 셀 추가
					addHeaderInfo.cells["leftfix"] = addColumnObject;
					//메모리 해제
					addColumnObject = null; cell = null; row = null;
				}
				
				//우측 고정
				if( this.rightFixColumnCount > 0 && columnIndex >= rightFixGap ){
					row = rightFixRows[i];
					cell = (headerColItem != null && headerColItem.cells != null) ? headerColItem.cells.rightfix : null;
					//헤더 컬럼 생성
					addColumnObject = document.createElement("td");
					addColumnObject.className = "AddColHead";
					//행 객체에 컬럼 추가
					row.insertBefore(addColumnObject, cell);
					//헤더 정보 셀 추가
					addHeaderInfo.cells["rightfix"] = addColumnObject;
					//메모리 해제
					addColumnObject = null;
					cell = null; cells = null; row = null;
				}
				
				//행 인덱스 이동
				i++;
			}
			else{
				for(j = columnIndex - 1; j >= 0; j--, headerColItem = null){
					headerColItem = headerRowItem[j];
					if( headerColItem.colspan > 0 ) break;
				}
				
				//셀 병합 정보 수정
				headerColItem.cells.header.colSpan = headerColItem.colspan;
				//좌측 고정
				if( columnIndex < this.leftFixColumnCount ) headerColItem.cells.leftfix.colSpan = headerColItem.colspan;
				//우측 고정
				if( this.rightFixColumnCount > 0 && columnIndex >= rightFixGap ) headerColItem.cells.rightfix.colSpan = headerColItem.colspan;
				
				//행 인덱스 이동
				i = i + headerColItem.rowspan;
			}
			
			//메모리 해제
			addHeaderInfo = null;
			headerColItem = null;
			headerRowItem = null;
		}
	}
	//메모리 해제
	rightFixRows = null; leftFixRows = null; rows = null;
	
	//본문
	rows = this.SheetContentObject.querySelectorAll("div.SheetContentDiv tr");
	leftFixRows = this.SheetContentObject.querySelectorAll("div.SheetContentLeftFixDiv tr");
	rightFixRows = this.SheetContentObject.querySelectorAll("div.SheetContentRightFixDiv tr");
	//본문 행이 있다면
	if( rows != null ){
		for(i = 0, rowCount = rows.length; i < rowCount; i++){
			row = rows[i];
			cells = row.querySelectorAll("td");
			
			//줄 타이틀 셀이 있다면 인덱스를 1 증가
			if( cells[0].className.indexOf("RowHeader") >= 0 ) cellIndex = columnIndex + 1;
			//컬럼 인덱스 조정
			for(j = cellIndex, colCount = cells.length; j < colCount; j++){
				cells[j].setAttribute("cellindex", j);
			}
			//추가할 컬럼 인덱스의 셀을 구함
			cell = cells[cellIndex];
			if( typeof cell == "undefined" ) cell = null;
			
			//헤더 컬럼 생성
			addColumnObject = document.createElement("td");
			addColumnObject.style.minWidth = minWidth;
			addColumnObject.setAttribute("cellindex", columnIndex);
			addColumnObject.appendChild(document.createElement("div"));
			
			//행 객체에 열 추가
			row.insertBefore(addColumnObject, cell);
			
			//메모리 해제
			addColumnObject = null;
			cell = null; cells = null; row = null;
			
			//좌측 고정
			if( columnIndex < this.leftFixColumnCount ){
				row = leftFixRows[i];
				cells = row.querySelectorAll("td");
				
				//컬럼 인덱스 조정
				for(j = cellIndex, colCount = cells.length; j < colCount; j++)
					cells[j].setAttribute("cellindex", j);
				//추가할 컬럼 인덱스의 셀을 구함
				cell = cells[cellIndex];
				if( typeof cell == "undefined" ) cell = null;
				
				//헤더 컬럼 생성
				addColumnObject = document.createElement("td");
				addColumnObject.style.minWidth = minWidth;
				addColumnObject.setAttribute("cellindex", columnIndex);
				addColumnObject.appendChild(document.createElement("div"));
				
				//행 객체에 열 추가
				row.insertBefore(addColumnObject, cell);
				
				//메모리 해제
				addColumnObject = null;
				cell = null; cells = null; row = null;
			}
			
			//우측 고정
			if( this.rightFixColumnCount > 0 ){
				row = rightFixRows[i];
				cells = row.querySelectorAll("td");
				
				if( columnIndex < rightFixGap ){
					//컬럼 인덱스 조정
					for(j = 0, colCount = cells.length; j < colCount; j++)
						cells[j].setAttribute("cellindex", j + (this.colsPerRow - this.rightFixColumnCount));
				}
				else{ //else if( columnIndex >= rightFixGap ){
					//컬럼 인덱스 조정
					for(j = columnIndex - rightFixGap, colCount = cells.length; j < colCount; j++)
						cells[j].setAttribute("cellindex", j + (this.colsPerRow - this.rightFixColumnCount) + 1);
					//추가할 컬럼 인덱스의 셀을 구함
					cell = cells[columnIndex - rightFixGap];
					if( typeof cell == "undefined" ) cell = null;
					
					//헤더 컬럼 생성
					addColumnObject = document.createElement("td");
					addColumnObject.style.minWidth = minWidth;
					addColumnObject.setAttribute("cellindex", columnIndex);
					addColumnObject.appendChild(document.createElement("div"));
					
					//행 객체에 컬럼 추가
					row.insertBefore(addColumnObject, cell);
					
					//메모리 해제
					addColumnObject = null; cell = null;
				}
				
				//메모리 해제
				cells = null; row = null;
			}
		}
	}
	//메모리 해제
	rightFixRows = null; leftFixRows = null; rows = null;
	
	//너비 조정 & 스크롤 조정
	this.redraw();
	
	//메모리 해제
	minWidth = null;
	headerColItem = null; headerRowItem = null;
	addColumnInfo = null; defaultColumnInfo = null;
	
	return true;
};

EasySheetRenderer.prototype.delColumn = function(columnIndex){
	//파라메터 예외처리
	if( typeof columnIndex != "number" || !(columnIndex >= 0 && columnIndex < this.columnInfo.length) )
		return false;
	
	var columnInfo = this.columnInfo[columnIndex];
	var columnRow = columnInfo.row - 1;
//	var columnCol = columnInfo.col - 1;
	var columnCol = columnIndex;
	
	//컬럼의 병합 정보가 멀티 행의 행수와 같다면 예외처리
	if( columnInfo.rowspan < this.rowsPerDataRow ){
		columnInfo = null; return false;
	}
	
	var rows = null;
	var leftFixRows = null;
	var rightFixRows = null;
	var rowObject = null; var cellObjects = null; var cellObject = null;
	var headerStartIndex = this.headerInfo.length - this.rowsPerDataRow;
	var headerRowIndex = headerStartIndex + columnRow;
	var headerColIndex = 0;
	var headerCellCount = (headerRowIndex > 0) ? this.headerInfo[headerRowIndex - 1].cellCount : 0;
	var physicalColIndex = columnCol - (columnRow > 0 ? headerCellCount : 0);
	var headRowItem = this.headerInfo[headerRowIndex];
	var headColItems = null;
	var headColItem = null;
	var rightFixGap = this.colsPerRow - this.rightFixColumnCount;
	var rowSpan = 0; var colSpan = 0; var colSpanMax = 0;
	var i = 0; var j = 0; var c = 0; var size = 0;
	
	//1. 시트 헤더 컬럼 삭제
	//컬럼 선택
	for(i = 0, headerColIndex = 0; i <= physicalColIndex; i++, headerColIndex++, headColItem = null){
		headColItem = headRowItem[headerColIndex];
		if( headColItem.colspan < 0 ){ i--; continue; }
		if( i == physicalColIndex ) break;
	}
	
	//헤더 컬럼 삭제
	cellObject = headColItem.cells.header;
	cellObject.parentNode.removeChild(cellObject);
	cellObject = null;
	//좌측고정열 헤더 컬럼 삭제
	if( this.leftFixColumnCount > 0 && headerColIndex < this.leftFixColumnCount ){
		cellObject = headColItem.cells.leftfix;
		cellObject.parentNode.removeChild(cellObject);
		cellObject = null;
	}
	//우측고정열 헤더 컬럼 삭제
	if( this.rightFixColumnCount > 0 && headerColIndex >= rightFixGap ){
		cellObject = headColItem.cells.rightfix;
		cellObject.parentNode.removeChild(cellObject);
		cellObject = null;
	}
	
	//추가 헤더 셀 삭제
	for(i = this.headerInfo.length - this.rowsPerDataRow - 1, c = headerColIndex; i >= 0;){
		headRowItem = this.headerInfo[i];
		headColItem = headRowItem[c];
		
		rowSpan = headColItem.rowspan;
		colSpan = headColItem.colspan;
		colSpanMax = headColItem.colspanMax;
		
		//셀이 다른 셀과 병합되지 않은 상태로 삭제
		if( colSpanMax == 1 ){
			cellObject = headColItem.cells.header;
			cellObject.parentNode.removeChild(cellObject);
			cellObject = null;
			
			cellObject = headColItem.cells.leftfix;
			if( cellObject != null && typeof cellObject != "undefined" ) cellObject.parentNode.removeChild(cellObject);
			cellObject = null;
			
			cellObject = headColItem.cells.rightfix;
			if( cellObject != null && typeof cellObject != "undefined" ) cellObject.parentNode.removeChild(cellObject);
			cellObject = null;
			
			i--;
		}
		//셀이 다른 셀과 병합된 상태로 병합 열 수를 1 감소
		else if( colSpanMax > 1 ){
			headColItem.colspanMax = colSpanMax - 1;
			colSpan = headColItem.colspan = colSpan - 1;
			
			cellObject = headColItem.cells.header;
			cellObject.colSpan = colSpan;
			cellObject = null;
			
			cellObject = headColItem.cells.leftfix;
			if( cellObject != null && typeof cellObject != "undefined" ) cellObject.colSpan = colSpan;
			cellObject = null;
			
			cellObject = headColItem.cells.rightfix;
			if( cellObject != null && typeof cellObject != "undefined" ) cellObject.colSpan = colSpan;
			cellObject = null;
			
			i--;
		}
		//병합되어 실제 태그가 없는 상태로 병합 셀의 위치로만 이동(headerRowIndex, headerColIndex 변경)
		else if( colSpanMax < 0 ){
			i = i - (rowSpan - 1);
			
			headColItems = this.headerInfo[i];
			
			for(j = headerColIndex; j >= 0; j--){
				if( headColItems[j].colspan > 0 ){
					c = j;
					break;
				}
			}
			
			headColItems = null;
		}
		
		//메모리 해제
		headColItem = null;
		headRowItem = null;
	}
	
	//헤더정보 삭제
	for(i = 0, size = this.headerInfo.length; i < size; i++, headRowItem = null){
		headRowItem = this.headerInfo[i];
		
		//
		headColItem = headRowItem[headerColIndex];
		colSpanMax = headColItem.colspanMax;
		
		if( colSpanMax > 1 ){
			var nextHeadColItem = headRowItem[headerColIndex + 1];
			var key = null;
			var value = null;
			for(key in headColItem){
				value = headColItem[key];
				if( typeof value == "function" ){ value = null; key = null; continue; }
				nextHeadColItem[key] = value;
				//메모리 해제
				value = null; key = null;
			}
			//메모리 해제
			nextHeadColItem = null;
		}
		
		if( headColItem.cells != null ){
			//
			if( colSpanMax == 1 ){
				delete headColItem.cells.header;
				if( this.leftFixColumnCount > 0 && headerColIndex < this.leftFixColumnCount ) delete headColItem.cells.leftfix;
				if( this.rightFixColumnCount > 0 && headerColIndex >= rightFixGap ) delete headColItem.cells.rightfix;
			}
			//
			headColItem.cells = null;
		}
		
		headColItem = null;
		
		//
		if( i >= headerRowIndex ){
			//
			for(j = (i == headerRowIndex ? headerColIndex + 1 : 0); j < this.colsPerRow; j++, headColItem = null){
				headColItem = headRowItem[j];
				if( headColItem.rowIndex != i - headerStartIndex ) continue;
				headColItem.cellIndex--;
			}
			//
			headerCellCount = headRowItem.cellCount - 1;
		}
		
		//
//		this.headerInfo[i] = headRowItem.slice(0, headerColIndex).concat(headRowItem.slice(headerColIndex + 1, headRowItem.length));
		this.headerInfo[i].splice(headerColIndex, 1);
		//
		if( i >= headerStartIndex ) this.headerInfo[i].cellCount = headerCellCount;
	}
	//행별 셀 개수 감소
	this.colsPerRow--;
	
	//2. 시트 본문 컬럼 삭제
	rows = this.SheetContentObject.querySelectorAll("div.SheetContentDiv tr");
	leftFixRows = this.SheetContentObject.querySelectorAll("div.SheetContentLeftFixDiv tr");
	rightFixRows = this.SheetContentObject.querySelectorAll("div.SheetContentRightFixDiv tr");
	
	//행별 컬럼 삭제
	for(i = 0, size = rows.length; i < size; i++){
		if( i % this.rowsPerDataRow != columnRow )
			continue;
		
		//시트 본문 컬럼 삭제
		rowObject = rows[i];
		cellObjects = rowObject.querySelectorAll("td");
		cellObject = cellObjects[physicalColIndex + (columnRow > 0 ? 0 : 1)];
		cellObject.parentNode.removeChild(cellObject);
		cellObject = null; cellObjects = null; rowObject = null;
		//좌측고정열 헤더 컬럼 삭제
		if( this.leftFixColumnCount > 0 && headerColIndex < this.leftFixColumnCount ){
			rowObject = leftFixRows[i];
			cellObjects = rowObject.querySelectorAll("td");
			cellObject = cellObjects[physicalColIndex + (columnRow > 0 ? 0 : 1)];
			cellObject.parentNode.removeChild(cellObject);
			cellObject = null; cellObjects = null; rowObject = null;
		}
		//우측고정열 헤더 컬럼 삭제
		if( this.rightFixColumnCount > 0 && headerColIndex >= rightFixGap ){
			rowObject = rightFixRows[i];
			cellObjects = rowObject.querySelectorAll("td");
			cellObject = cellObjects[physicalColIndex - rightFixGap];
			cellObject.parentNode.removeChild(cellObject);
			cellObject = null; cellObjects = null; rowObject = null;
		}
	}
	
	//3. 고정열이 삭제된다면 고정열 수를 감소시킴
	if( this.leftFixColumnCount > 0 && headerColIndex < this.leftFixColumnCount )
		this.leftFixColumnCount--;
	if( this.rightFixColumnCount > 0 && headerColIndex >= rightFixGap )
		this.rightFixColumnCount--;
	
	//4. 
	var leftRowObject = null; var leftCellObjects = null;
	var rightRowObject = null; var rightCellObjects = null;
	
	for(i = 0, rightFixGap = this.colsPerRow - this.rightFixColumnCount, size = rows.length; i < size; i++){
		c = i % this.rowsPerDataRow;
		headRowItem = this.headerInfo[headerStartIndex + c];
		headerCellCount = (c > 0) ? headerCellCount : -1;
		
		rowObject = rows[i];
		cellObjects = rowObject.querySelectorAll("td");
		leftRowObject = leftFixRows[i]; 
		leftCellObjects = leftRowObject.querySelectorAll("td");
		rightRowObject = rightFixRows[i]; 
		rightCellObjects = rightRowObject.querySelectorAll("td");
		
		for(j = 0; j < this.colsPerRow; j++, headColItem = null){
			headColItem = headRowItem[j];
			if( headColItem.colspan < 0 ) continue;
			
			headerColIndex = headColItem.cellIndex;
			physicalColIndex = headColItem.cellIndex - headerCellCount;
			
			cellObject = cellObjects[physicalColIndex];
			cellObject.setAttribute("cellindex", "" + headerColIndex);
			cellObject = null;
			
			if( this.leftFixColumnCount > 0 && headerColIndex < this.leftFixColumnCount ){
				cellObject = leftCellObjects[physicalColIndex];
				cellObject.setAttribute("cellindex", "" + headerColIndex);
				cellObject = null;
			}
			
			if( this.rightFixColumnCount > 0 && headerColIndex >= rightFixGap ){
				cellObject = rightCellObjects[physicalColIndex - 1 - rightFixGap];
				cellObject.setAttribute("cellindex", "" + headerColIndex);
				cellObject = null;
			}
		}
		
		rightCellObjects = null; rightRowObject = null;
		leftCellObjects = null; leftRowObject = null;
		cellObjects = null; rowObject = null;
		headRowItem = null;
	}
	
	//5. 컬럼 정보 삭제
	//반응형 컬럼인 경우 반응형 컬럼 개수 -1 하고 반응형 컬럼의 너비 총합 빼야함
	if( !columnInfo.isFixedWidth ){
		//반응형 컬럼의 개수 -1 함
		this._cntResponsibleColumnWidth--;
		//반응형 컬럼의 너비에서 컬럼의 반응형 너비 뺌
		this._sumResponsibleColumnWidth -= columnInfo.percentWidth;
	}
	for(i = columnIndex + 1, columnInfo = null, size = this.columnInfo.length; i < size; i++, columnInfo = null){
		columnInfo = this.columnInfo[i];
//		columnInfo.col = columnInfo.col - 1;
		columnInfo.index = columnInfo.index - 1;
	}
	//컬럼 정보 제거
//	this.columnInfo = this.columnInfo.slice(0, columnIndex).concat(this.columnInfo.slice(columnIndex + 1, this.columnInfo.length));
	this.columnInfo.splice(columnIndex, 1);
	
	//시트 사이즈 재조정
	this.resize();
	
	//메모리 해제
	cellObject = null; rowObject = null;
	rightFixRows = null; leftFixRows = null; rows = null;
	headColItem = null; headRowItem = null;
	columnInfo = null;
	
	return true;
};

EasySheetRenderer.prototype.hideColumn = function(field){
	//파라메터 예외처리
	if( typeof field == "undefined" ) return false;
	
	var columnIndex = null;
	var hidden = null;
	
	columnIndex = this.columnIndexMapByField[field];
	
	if( typeof columnIndex != "number" || !(columnIndex >= 0 && columnIndex < this.columnInfo.length) )
		return false;
	
	hidden = this.columnInfo[columnIndex].hidden;
	
	//이미 숨겨진 열은 더이상 처리하지 않음
	if( hidden === true ){
		//메모리 해제
		columnIndex = null;
		hidden = null;
		
		return true;
	}
	
	//컬럼 숨김 속성 설정
	this.columnInfo[columnIndex].hidden = true;
	
	//시트 리사이징
	this.resize();
	
	//메모리 해제
	columnIndex = null;
	hidden = null;
	
	return true;
};

EasySheetRenderer.prototype.showHiddenColumn = function(field){
	//파라메터 예외처리
	if( typeof field == "undefined" ) return false;
	
	var columnIndex = null;
	var hidden = null;
	
	columnIndex = this.columnIndexMapByField[field];
	
	if( typeof columnIndex != "number" || !(columnIndex >= 0 && columnIndex < this.columnInfo.length) )
		return false;
	
	hidden = this.columnInfo[columnIndex].hidden;
	
	//이미 숨겨진 열은 더이상 처리하지 않음
	if( hidden === false ){
		//메모리 해제
		columnIndex = null;
		hidden = null;
		
		return true;
	}
	
	//컬럼 숨김 속성 설정
	this.columnInfo[columnIndex].hidden = false;
	
	//시트 리사이징
	this.resize();
	
	//메모리 해제
	columnIndex = null;
	hidden = null;
	
	return true;
};





EasySheetRenderer.prototype.update = function( updateInfo, designOption ){
	//예외처리
//	if( typeof updateInfo == "undefined" || updateInfo == null ){
//		return false;
//	}
	
	var data = null;
	var dataList = null;
	var dataRecord = null;
	var endIndex = 0;
	var visibleCnt = 0;
	var i = 0;
	
	//디자인 정보 설정
	if( updateInfo != null && typeof updateInfo != "undefined" ){
		var columns = updateInfo.columns;
		var footers = updateInfo.footers;
		
		if( columns != null && typeof columns != "undefined" ){
			var column = null;
			var colInfo = null;
			var columnCount = this.columnInfo.length;
			//컬럼정보 갱신
			for(i = 0; i < columnCount; i++, column = null, colInfo = null){
				column = columns[i];
				colInfo = this.columnInfo[i];
				//컬럼 위치 및 병합 정보 설정
				colInfo.row = column.sheetRow;
				colInfo.col = column.sheetCol;
				colInfo.rowspan = column.sheetRowSpan;
				colInfo.colspan = column.sheetColSpan;
			}
			//메모리 해제
			colInfo = null; column = null; columns = null;
		}
		
		if( footers != null && typeof footers != "undefined" ){
			var footerCount = this.footerInfo.length;
			//푸터정보 갱신
			for(i = 0; i < footerCount; i++){
				this.setFooterInfo(i, footers[i]);
			}
			//메모리 해제
			footers = null;
		}
		
		//데이터 레코드당 시트에 표시되는 행 수
		this.rowsPerDataRow = updateInfo.displayInfo.rowsPerDataRow;
	}
	
	if( designOption == SHEET_RESET_DESIGN ){
		//1. data와 showedTopRowIndex는 변경하지 않고 redraw 함수를 호출하여 시트의 디자인만 다시 렌더링함
		this.redraw();
	}
	else if( designOption == SHEET_RESET_DATA || typeof designOption == "undefined" ){
		//1. SHEET_RESET_DATA인 경우, data를 갱신하고 showedTopRowIndex를 초기화(0)하여 setData 함수를 호출하여 시트의 출력되는 데이터를 변경함
		//2. 파라메터로 전달받은 값이 없다면 현재  showedTopRowIndex는 유지한 상태로 setData 함수를 호출하여 시트의 출력되는 데이터를 변경함
		this.showedTopRowIndex = (designOption == SHEET_RESET_DATA) ? 0 : this.showedTopRowIndex;
		
		data = this.dataSet.data;
		dataList = [];
		endIndex = this.showedTopRowIndex + this.displayMaxRowCount - 1;
		
		//시작줄이 고정 줄수 보다 큰경우 
		if( this.showedTopRowIndex >= this.topFixRowCount ){
			endIndex = endIndex - this.topFixRowCount;
		}
		else if( this.showedTopRowIndex < this.topFixRowCount ){
			this.showedTopRowIndex = this.topFixRowCount;	// 고정줄 다음줄을 StartRow로 한다.
			endIndex = this.displayMaxRowCount - 1;
		}
		
		//출력 데이터 수를 설정
		this.dataRowCount = data.length;
		
		//화면에 출력될 데이터 갯수 체크
		if( !this.rowNumOrder ){
			for(i = 0, r = 1, this.visibleRowCount = 0; i < this.dataRowCount; i++){
				if( typeof data[i].__STATE__ != "undefined" && (data[i].__STATE__.hidden === true || data[i].__STATE__.filterd === true || data[i].__STATE__.rowType == "Logical") ) continue;
				data[i].__STATE__["_record_num"] = r++;
				this.visibleRowCount++;
			}
		}
		
		//만약 시작행의 행번호가 0보다 작으면 0으로 설정
		if( this.showedTopRowIndex < 0 ) this.showedTopRowIndex = 0;
		//
		if( endIndex >= data.length ) endIndex = data.length - 1;
		
		//메인 데이터
		for(i = this.showedTopRowIndex; i <= endIndex && i < data.length; i++){
			//숨김 또는 필터링된 행은 추가하지 않음
			if( typeof data[i].__STATE__ != "undefined" && (data[i].__STATE__.hidden === true || data[i].__STATE__.filterd === true) ){
				++endIndex;
				continue;
			}
			
			if( typeof data[i].__STATE__ == "undefined" ) data[i].__STATE__ = {};
			
			//시트에 출력할 레코드 배열에 추가
			dataRecord = JSON.parse(JSON.stringify(data[i]));
			dataRecord.__STATE__["_record_index"] = i;
			dataList.push( dataRecord );
			//메모리 해제
			dataRecord = null;
		}
		
		//필터 또는 행이 숨겨진 상태에서 마지막 행이 시트에 온전히 표현될 행 수보다 크다면 시작행을 앞으로 당기고 레코드를 배열 맨 앞에 추가
		if( dataList.length + this.topFixRowCount < this.wholeShownRowCount ){
			endIndex = this.wholeShownRowCount - this.topFixRowCount;
			
			for(i = this.showedTopRowIndex - 1; i >= 0 && dataList.length < endIndex; i--){
				//숨김 또는 필터링된 행은 추가하지 않음
				if( typeof data[i].__STATE__ != "undefined" && (data[i].__STATE__.hidden === true || data[i].__STATE__.filterd === true) )
					continue;
				
				if( typeof data[i].__STATE__ == "undefined" ) data[i].__STATE__ = {};
				
				//시트에 출력할 레코드 배열 맨 앞에 추가
				dataRecord = JSON.parse(JSON.stringify(data[i]));
				dataRecord.__STATE__["_record_index"] = i;
				dataList.unshift(dataRecord);
				//인덱스 당김
				this.showedTopRowIndex = i;
				//메모리 해제
				dataRecord = null;
			}
		}
		
		//상단 고정 행이 설정되어 있다면 상단 고정 데이터 추가
		if( this.topFixRowCount > 0 ){
			for(i = 0; i < this.topFixRowCount; i++){
				if( typeof data[i].__STATE__ == "undefined" ) data[i].__STATE__ = {};
				
				//시트에 출력할 레코드 배열에 추가
				dataRecord = JSON.parse(JSON.stringify(data[i]));
				dataRecord.__STATE__["_record_index"] = i;
//				dataList.push( dataRecord );
				dataList.splice(i, 0, dataRecord);
				//메모리 해제
				dataRecord = null;
			}
		}
		
		//
		this.refreshCellMerge(dataList);
		
		//시트 데이터 변경
		this.setData(dataList);
		
		//메모리 해제
		dataRecord = null; dataList = null; data = null;
	}
};

EasySheetRenderer.prototype.needMerge = function(){
	var result = SHEET_MERGE_NEED_NOT;
	var columnLength = this.columnInfo.length;
	var colNum0 = 0;
	
	for(colNum0 = 0; colNum0 < columnLength && result == SHEET_MERGE_NEED_NOT; colNum0++){
		if( this.columnInfo[colNum0].cellMerge > 0 )
			result = SHEET_MERGE_NEED;
	}
	
	return result;
};

EasySheetRenderer.prototype.getMergeInfo = function(){
	var mergeInfos = [];
	var i = 0;
	var j = 0;
	var k = 0;
	
	var colInfo = null;
	var maxRowCount = this.rowsPerDataRow;
	var maxColCount = this.colsPerRow;
	var maxColNum = 0;
	var colCount = 0;
	
	for(i = 0; i < maxColCount; i++, colInfo = null){
		colInfo = this.columnInfo[i];
		
		maxColNum = colInfo.col + colInfo.colspan - 1;	//???확인필요
		colCount = colCount >= maxColNum ? colCount : maxColNum;
	}
	
	for(i = 0; i < maxRowCount; i++){
		mergeInfos.push( new Array(colCount) );
	}
	
	var colRow = 0;
	var cellNum = -1;
	var rowspan = 0;
	var colspan = 0;
	var rowNumToFill = 0;
	var rowNumToEnd = 0;
	var cellNumToFill = 0;
	var cellNumToEnd = 0;
	var mergeInfo = null;
	var merge = null;
	
	for(j = 0, colCount = this.columnInfo.length; j < colCount; j++, colInfo = null, merge = null, mergeInfo = null){
		colInfo = this.columnInfo[j];
		colRow = colInfo.row - 1;
		mergeInfo = mergeInfos[colRow];
		
		//처리된 셀, 머지된 셀을 제하고, 채워야할 셀번호 찾기
		cellNum = -1;
		
		for(k = 0; k < maxColCount; k++){
			if( typeof mergeInfo[k] == "undefined" ){
				cellNum = k;
				break;
			}
		}
		
		//오류처리
		if( cellNum < 0 ){
			mergeInfos.clear(); mergeInfos = null; mergeInfo = null; colInfo = null;
			return null;
		}
		
		//자기셀은 채우고 
		rowspan = colInfo.rowspan;
		colspan = colInfo.colspan;
		
		merge = mergeInfo[cellNum] = {
				disp: true
				, rowSpan: rowspan
				, colSpan: colspan
				, colId: colInfo.field
				, icon: ""
		};
		
		if( typeof colInfo.index != "undefined" ){
			merge.colNum0 = colInfo.index;	// 0부터 시작
		}
		
		rowNumToEnd = colRow + rowspan;
		cellNumToEnd = cellNum + colspan;
		
		for(cellNumToFill = cellNum; cellNumToFill < cellNumToEnd; cellNumToFill++){
			for(rowNumToFill = colRow; rowNumToFill < rowNumToEnd; rowNumToFill++){
				//자기셀은 건너 뛴다 
				if( cellNumToFill == cellNum && rowNumToFill == colRow ) continue;
				// 머지된 셀은 디폴트 처리한다 
				mergeInfos[rowNumToFill][cellNumToFill] = { disp: false };
			}
		}
	}
	
	/*for(i = 0, j = 0; i < maxRowCount; i++){
		for(; j < maxColCount; j++, colInfo = null, merge = null, mergeInfo = null){
			colInfo = this.columnInfo[j];
			colRow = colInfo.row - 1;
			mergeInfo = mergeInfos[colRow];
			
			//처리된 셀, 머지된 셀을 제하고, 채워야할 셀번호 찾기
			cellNum = -1;
			
			for(k = 0; k < colCount; k++){
				if( typeof mergeInfo[k] == "undefined" ){
					cellNum = k;
					break;
				}
			}
			
			//오류처리
			if( cellNum < 0 ){
				mergeInfos.clear(); mergeInfos = null; mergeInfo = null; colInfo = null;
				return null;
			}
			
			//자기셀은 채우고 
			rowspan = colInfo.rowspan;
			colspan = colInfo.colspan;
			
			merge = mergeInfo[cellNum] = {
				disp: true
				, rowSpan: rowspan
				, colSpan: colspan
				, colId: colInfo.field
				, icon: ""
			};
			
			if( typeof colInfo.index != "undefined" ){
				merge.colNum0 = colInfo.index;	// 0부터 시작
			}
			
			rowNumToEnd = colRow + rowspan;
			cellNumToEnd = cellNum + colspan;
			
			for(cellNumToFill = cellNum; cellNumToFill < cellNumToEnd; cellNumToFill++){
				for(rowNumToFill = colRow; rowNumToFill < rowNumToEnd; rowNumToFill++){
					//자기셀은 건너 뛴다 
					if( cellNumToFill == cellNum && rowNumToFill == colRow ) continue;
					// 머지된 셀은 디폴트 처리한다 
					mergeInfos[rowNumToFill][cellNumToFill] = { disp: false };
				}
			}
		}
	}*/
	
	return mergeInfos;
};

EasySheetRenderer.prototype.refreshCellMerge = function(dataList){
	//셀 병합을 안 할 경우 예외처리
	if( this.needColumnMerge == SHEET_MERGE_NEED_NOT || this.needMerge() == SHEET_MERGE_NEED_NOT ){
		return;
	}
	
	var mergeInfos = this.getMergeInfo();
	var mergeInfo = null;
	var recordPrev = null;
	var recordCur = null;
	var rowsToRepeat = mergeInfos.length;
	var colCount = mergeInfos[0].length;
	var restrictable = true;
	var unitMergeInfo = null;
	var unitRowNum = 0;
	var unitColNum = 0;
	var colLength = this.columnInfo.length;
	var colInfo = null;
	var isEqual = false;
	var maxRow = 0;
	var i = 0;
	var j = 0;
	
	for(maxRow = dataList.length, i = 0; i < maxRow; i++){
		//자기줄과 윗줄의 데이터를 꺼낸다
		recordPrev = dataList[i - 1];
		recordCur = dataList[i];
		
		//시트단위 머지정보를 읽어 데이터 단위 머지 정보로 복제 생성 
		mergeInfo = recordCur.__STATE__.mergeInfo;
		
		if( typeof mergeInfo == "undefined" )
			mergeInfo = recordCur.__STATE__.mergeInfo = JSON.parse(JSON.stringify(mergeInfos));
		
//		//줄단위 트리정보 사전 파악 
//		var treeInfos = this.getRowAttribute(rowNum, "treeInfo");	//this.startRowColNum이 반영된 줄번호를 인자로 받는다.
		
		//mergeInfo 내의 줄, 열별로 루핑하며
		restrictable = true;
		
		for(unitRowNum = 0; unitRowNum < rowsToRepeat; unitRowNum++){
			for(unitColNum = 0; unitColNum < colCount; unitColNum++){
				unitMergeInfo = mergeInfo[unitRowNum][unitColNum];
				
				//병합 설정된 셀은 스킵한다.
        		if( unitMergeInfo.disp == false ) continue;
        		
        		for(j = 0; j < colLength; j++){
        			if( unitMergeInfo.colId == this.columnInfo[j].field ){
        				colInfo = this.columnInfo[j];
        				break;
        			}
        		}
        		
        		if( colInfo.cellMerge == SHEET_CELL_MERGE_ALWAYS ){
            		//위아래 데이터가 같은지 여부
            		isEqual = (i == 0) ? false : recordPrev[colInfo.field] === recordCur[colInfo.field];
            		//같으면 데이터를 숨긴다
            		if( isEqual ) unitMergeInfo.disp = false;
            		//앞의 머지셀 값이 변하면 RESTRICT셀은 머지할 수 없게 된다
            		restrictable = restrictable || isEqual;
        		}
        		else if( colInfo.cellMerge == SHEET_CELL_MERGE_RESTRICT && restrictable ){
        			//위아래 데이터가 같은지 여부
            		isEqual = isEqual && ((i == 0) ? false : recordPrev[colInfo.field] === recordCur[colInfo.field]);
            		//같으면 데이터를 숨긴다
            		if( isEqual ) unitMergeInfo.disp = false;
        		}
        		
        		//메모리 해제
        		colInfo = null; unitMergeInfo = null;
			}
		}
		
		//메모리 해제
		mergeInfo = null; recordCur = null; recordPrev = null;
	}
	
	//메모리 해제
	mergeInfos = null;
	
	return;
};

/*
EasySheetRenderer.prototype.updateScreen = function(sheet, dataInfo, doRedraw){
	//예외처리
	//1. 시트가 파라메터로 전달되지 않음
	if( (typeof sheet == "undefined" || sheet == null) && !(typeof EasySheet != "undefined" && sheet instanceof EasySheet) ){
		return false;
	}
	//2. 데이터 정보가 전달되지 않음
	if( typeof dataInfo == "undefined" && dataInfo != null ){
		return false;
	}
	
	//doRedraw 가 true인 경우 시트를 데이터 변경없이 다시 그리고, false인 경우 데이터를 갱신함
	doRedraw = (typeof doRedraw == "boolean" && doRedraw === true) ? true : false;
	
	var dataList = null;
	var rowList = null;
	var rowCount = 0;
	var result = true;
	
	var i = 0;
	
	try{
		//시트 데이터 갱신
		dataList = [];
		rowList = dataInfo.rowNums;
		rowCount = rowList.length;

		//데이터 추가
		for(i = 0; i < rowCount; i++){
			//행 번호 리스트에서 null 은 빈 행임
			if( rowList[i] == null || typeof rowList[i] != "number" )
				continue;
			
			//데이터 행 추가
			dataList[i] = sheet.dataSet.data[rowList[i]];
			dataList[i].__STATE__["display_row_num"] = rowList[i];
		}
		
		this.showedTopRowIndex = dataInfo.displayInfo.startRow;
		this.topFixRowCount = dataInfo.displayInfo.topFrozens;
		
		//데이터 갱신
//		result = this.setData(dataList, sheet.dataSet.getCount(false), false);
		result = this.setData(dataList, sheet.getVisibleRowCount(), false);
		
		//시트 디자인 렌더링
		if( doRedraw ){
			result = this.redraw();
		}
	}
	catch(e){
		result = false;
	}
	
	//메모리 해제
	rowList = null;
	dataList = null;
	
	return result;
};
*/

EasySheetRenderer.prototype.setPosition = function(left, top, width, height){
	//시트 left 적용 : null 인 경우 변경하지 않음
	if( left != null ){
		left = "" + left;
		this.SheetObject.style.left = left + ((left.indexOf("px") < 0 && left.indexOf("%") < 0) ? "px" : "");
	}
	
	//시트 top 적용 : null 인 경우 변경하지 않음
	if( top != null ){
		top = "" + top;
		this.SheetObject.style.top = top + ((top.indexOf("px") < 0 && top.indexOf("%") < 0) ? "px" : "");
	}
	
	//시트 width 적용 : null 인 경우 변경하지 않음
	if( width != null ){
		width = "" + width;
		this.SheetObject.style.width = width + ((width.indexOf("px") < 0 && width.indexOf("%") < 0) ? "px" : "");
	}
	
	//시트 height 적용 : null 인 경우 변경하지 않음
	if( height != null ){
		height = "" + height;
		this.SheetObject.style.height = height + ((height.indexOf("px") < 0 && height.indexOf("%") < 0) ? "px" : "");
	}
	
	var cssStyleDeclaration = null;
	
	//시트 헤더 정보 초기화 설정
	cssStyleDeclaration = getComputedStyle(this.SheetHeaderObject);
	this.sheetHeaderDivWidth = 1 * (cssStyleDeclaration.width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
	this.sheetHeaderDivHeight = 1 * (cssStyleDeclaration.height).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
	if( !this.isShowHeader ) this.sheetHeaderDivHeight = 0;
	this.sheetHeaderTableWidth = 1 * (getComputedStyle(document.getElementsByName(this.controlId + "_SheetHeaderTable")[0]).width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
	cssStyleDeclaration = null;
	
	//시트 좌측고정 헤더 너비
	if( typeof this.SheetHeaderLeftFixObject != "undefined" && this.SheetHeaderLeftFixObject != null ){
		cssStyleDeclaration = getComputedStyle(this.SheetHeaderLeftFixObject);
		this.sheetLeftFixWidth = (1 * (cssStyleDeclaration.width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0)) + 1;
		cssStyleDeclaration = null;
	}
	
	//시트 우측고정 헤더 너비
	if( typeof this.SheetHeaderRightFixObject != "undefined" && this.SheetHeaderRightFixObject != null ){
		cssStyleDeclaration = getComputedStyle(this.SheetHeaderRightFixObject);		
		this.sheetRightFixWidth = (1 * (cssStyleDeclaration.width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0)) + 1;
		cssStyleDeclaration = null;
	}
	//시트 좌측고정 너비 + 우측고정 너비 만큼 시트 최소 너비 설정
	this.SheetObject.style.minWidth = (this.sheetLeftFixWidth + this.sheetRightFixWidth + 1) + "px";
    
    //시트 본문 정보 초기화 설정
    cssStyleDeclaration = getComputedStyle(this.SheetContentObject);
    this.sheetContentDivWidth = 1 * (cssStyleDeclaration.width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
    this.sheetContentDivHeight = 1 * (cssStyleDeclaration.height).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
    this.sheetContentTableWidth = 1 * (getComputedStyle(document.getElementsByName(this.controlId + "_SheetContentTable")[0]).width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
    cssStyleDeclaration = null;
	
	//헤더 높이 설정
	this.headerHeight = 1 * (getComputedStyle(this.SheetHeaderObject).height).replace("px", ""); // + (IS_IE_BROWSER ? 1 : 0);
	if( !this.isShowHeader ) this.headerHeight = 0;
	//행 높이 설정
    this.rowHeight = 1 * (getComputedStyle(this.SheetContentObject.getElementsByTagName("tr")[0]).height).replace("px", ""); // + (IS_IE_BROWSER ? 1 : 0);
    //시트 본문 내 출력 가능한 최대 행수 설정
    this.displayMaxRowCount = Math.ceil(Math.ceil(this.sheetContentDivHeight / this.rowHeight) / this.rowsPerDataRow);
    this.wholeShownRowCount = Math.floor(Math.floor(this.sheetContentDivHeight / this.rowHeight) / this.rowsPerDataRow);
	
	//행 개수만큼 행 생성/복사
	if( this.displayMaxRowCount > 1 ){
		var sheetContentTable = null;
		var sheetContentTableTbody = null;
		var trObjects = null;
		//시트 좌측고정
		var sheetContentLeftFixTable = null;
		var sheetContentLeftFixTableTbody = null;
		var leftFixTrObjects = null;
		//시트 우측고정
		var sheetContentRightFixTable = null;
		var sheetContentRightFixTableTbody = null;
		var rightFixTrObjects = null;
		//행 객체
		var rowObject = null;
		var hasLeftFix = null;
		var hasRightFix = null;
		var trObjectCount = 0;
		
		hasLeftFix = (typeof this.SheetHeaderLeftFixObject != "undefined" && this.SheetHeaderLeftFixObject != null);
		hasRightFix = (typeof this.SheetHeaderRightFixObject != "undefined" && this.SheetHeaderRightFixObject != null);
		
		//시트 본문 설정
		sheetContentTable = document.getElementsByName(this.controlId + "_SheetContentTable")[0];
		sheetContentTableTbody = sheetContentTable.getElementsByTagName("tbody")[0];
		trObjects = sheetContentTable.getElementsByTagName("tr");
		trObjectCount = trObjects.length;
		//시트 좌측고정
		if( hasLeftFix ){
			sheetContentLeftFixTable = document.getElementsByName(this.controlId + "_SheetContentLeftFixTable")[0];
			sheetContentLeftFixTableTbody = sheetContentLeftFixTable.getElementsByTagName("tbody")[0];
			leftFixTrObjects = sheetContentLeftFixTable.getElementsByTagName("tr");
		}
		//시트 우측고정
		if( hasRightFix ){
			sheetContentRightFixTable = document.getElementsByName(this.controlId + "_SheetContentRightFixTable")[0];
			sheetContentRightFixTableTbody = sheetContentRightFixTable.getElementsByTagName("tbody")[0];
			rightFixTrObjects = sheetContentRightFixTable.getElementsByTagName("tr");
		}
		//행 타이틀 너비 설정
		if( this.isShowRowHeader && trObjectCount > 0 )
			this.sheetRowHeaderWidth = (1 * getComputedStyle(trObjects[0].querySelector("td.RowHeader")).width.replace("px", "")) + 1;
		else if( !this.isShowRowHeader && trObjectCount > 0 )
			this.sheetRowHeaderWidth = 0;
		
		for(i = trObjectCount / this.rowsPerDataRow; i < this.displayMaxRowCount; i++){
			for(j = 0; j < trObjectCount; j++){
				//행 복사(자식 포함)
				rowObject = trObjects[j].cloneNode(true);
				//행 인덱스 설정
				rowObject.setAttribute("rowIndex", i);
				
				//본문 테이블의 tbody 태그가 있다면 tbody 에 행을 추가하고, 없다면 table 에 추가
				if( typeof sheetContentTableTbody != "undefined" && sheetContentTableTbody != null )
					sheetContentTableTbody.appendChild(rowObject);
				else
					sheetContentTable.appendChild(rowObject);
				//메모리 해제
				rowObject = null;
				
				//좌측 고정열 
				if( hasLeftFix ){
					//행 복사(자식 포함)
					rowObject = leftFixTrObjects[j].cloneNode(true);
					//행 인덱스 설정
					rowObject.setAttribute("rowIndex", i);
					//본문 테이블의 tbody 태그가 있다면 tbody 에 행을 추가하고, 없다면 table 에 추가
					if( typeof sheetContentLeftFixTableTbody != "undefined" && sheetContentLeftFixTableTbody != null )
						sheetContentLeftFixTableTbody.appendChild(rowObject);
					else
						sheetContentLeftFixTable.appendChild(rowObject);
					//메모리 해제
					rowObject = null;
				}
				
				//우측 고정열
				if( hasRightFix ){
					//행 복사(자식 포함)
					rowObject = rightFixTrObjects[j].cloneNode(true);
					//행 인덱스 설정
					rowObject.setAttribute("rowIndex", i);
					//본문 테이블의 tbody 태그가 있다면 tbody 에 행을 추가하고, 없다면 table 에 추가
					if( typeof sheetContentRightFixTableTbody != "undefined" && sheetContentRightFixTableTbody != null )
						sheetContentRightFixTableTbody.appendChild(rowObject);
					else
						sheetContentRightFixTable.appendChild(rowObject);
					//메모리 해제
					rowObject = null;
				}
			}
		}
		
		//메모리 해제
		hasRightFix = null; hasLeftFix = null; rowObject = null;
		rightFixTrObjects = null; sheetContentRightFixTableTbody = null; sheetContentRightFixTable = null;
		leftFixTrObjects = null; sheetContentLeftFixTableTbody = null; sheetContentLeftFixTable = null;
		trObjects = null; sheetContentTableTbody = null; sheetContentTable = null;
	}
    
    //시트 수직스크롤 초기화 설정
    this.vScrollWidth = (1 * (getComputedStyle(this.SheetVScrollObject).width).replace("px", "")) + (IS_IE_BROWSER ? 1 : 0) + "px";
    this.vScrollTrackHeight = 1 * (getComputedStyle(document.getElementsByName(this.controlId + "_SheetVScrollTrack")[0]).height).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
    this.SheetVScrollObject.style.display = "none";
    
    //시트 수평스크롤 초기화 설정(수직스크롤은 로드시 행이 1행만 있으므로 따로 설정하지 않음)
    this.hScrollHeight =(1 * (getComputedStyle(this.SheetHScrollObject, null).height).replace("px", "")) + (IS_IE_BROWSER ? 1 : 0) + "px";
    //-수평스크롤 보이기 여부
    this.isShowHScroll = (this.sheetContentDivWidth < this.sheetContentTableWidth);
    //-시트 수평스크롤 Track, Face 너비 설정
    if( this.isShowHScroll ){
        this.hScrollTrackWidth = 1 * (getComputedStyle(document.getElementsByName(this.controlId + "_SheetHScrollTrack")[0]).width).replace("px", "") + (IS_IE_BROWSER ? 1 : 0);
        this.hScrollFaceWidth = (this.hScrollTrackWidth * this.sheetContentDivWidth) / this.sheetContentTableWidth + (IS_IE_BROWSER ? 1 : 0);
        (document.getElementsByName(this.controlId + "_SheetHScrollFace")[0]).style.width = this.hScrollFaceWidth + "px";
        this.tableMovePerHScrollFaceMove = this.sheetContentDivWidth / this.hScrollFaceWidth;
    }
    else{
        this.SheetHScrollObject.style.display = "none";
    }
    
    this.update();
	
	return true;
};



EasySheetRenderer.prototype.setEnabled = function(enabled){
	//예외처리 - 파라메터는 true 또는 false 만 받음
	if( typeof enabled != "boolean" ) return false;
	
	this.completeSheetEditing(false);
	
	//동작가능 상태 적용 - true : 동작 가능(block) / false : 동작 불가능(none);
	this.SheetObject.querySelector("div.SheetDisabledPanel").style.display = (enabled ? "none" : "block");
	
	return true;
};

EasySheetRenderer.prototype.setVisible = function(visible){
	//예외처리 - 파라메터는 true 또는 false 만 받음
	if( typeof visible != "boolean" ) return false;
	
	//보이기 상태 적용 - true : 보임(block) / false : 숨김(none);
	this.SheetObject.style.display = (visible ? "block" : "none");
	
	return true;
};

EasySheetRenderer.prototype.setNeedColumnMerge = function(needMerge){
	//예외처리 - 파라메터는 상수로만 받음
	if( typeof needMerge != "number" ) return false;
	
	//병합 여부 설정(SHEET_MERGE_UNFIXED: 병합 설정 미정, 컬럼 병합 설정에 따름, SHEET_MERGE_NEED_NOT: 병합 안함, SHEET_MERGE_NEED: 병합 함)
	this.needColumnMerge = needMerge;
	
	return true;
};

EasySheetRenderer.prototype.setPermitEditable = function(editable){
	//예외처리 - 파라메터는 true 또는 false 만 받음
	if( typeof editable != "boolean" ) return false;
	
	//편집 가능 여부  적용 - true : 편집 가능 / false : 편집 불가능;
	this.isListSheet = !editable;
	
	return true;
};

EasySheetRenderer.prototype.setPermitCellResize = function(permitable){
	//예외처리 : 파라메터는 true 또는 false 만 받음
	if( typeof permitable != "boolean" ){
		return false;
	}
	
	var resizerObjs = this.SheetHeaderObject.querySelectorAll("div.resizer");
	var resizerObj = null;
	var resizerCnt = resizerObjs.length;
	var i = 0;
	
	//열 너비 조정 가능여부 적용 - true : 조정 가능 / false : 조정 불가능
	var display = permitable ? "block" : "none";
	
	//시트의 모든 리사이저 설정
	for(i = 0; i < resizerCnt; i++){
		resizerObj = resizerObjs[i];
		resizerObj.style.display = display;
		resizerObj = null;
	}
	
	//메모리 해제
	display = null;
	resizerObjs = null;
	
	return true;
};

EasySheetRenderer.prototype.setPermitEditFixedColumn = function(permitable){
	//예외처리 : 파라메터는 true 또는 false 만 받음
	if( typeof permitable != "boolean" ){
		return false;
	}
	
	this.editableFixedColumn = permitable;
	
	return true;
};

EasySheetRenderer.prototype.setWheelMovementRows = function(rowCount){
	//예외처리 : 파라메터는 숫자만 받음
	if( typeof rowCount != "number" ){
		return false;
	}
	
	this.vScrollWheelMoveRows = rowCount;
	
	return true;
};

EasySheetRenderer.prototype.setUseContextMenu = function(usable){
	//예외처리 : 파라메터는 true 또는 false 만 받음
	if( typeof usable != "boolean" ){
		return false;
	}
	
	this.useContextMenu = usable;
	
	return true;
};

EasySheetRenderer.prototype.setSortOnHeader = function(sortable){
	//예외처리 : 파라메터는 true 또는 false 만 받음
	if( typeof sortable != "boolean" ){
		return false;
	}
	
	this.sortOnHeader = sortable;
	
	return true;
};

EasySheetRenderer.prototype.setRowColHeaderTitle = function(title){
	//예외처리 : 파라메터는 문자열만 받음
	if( typeof title != "string" ){
		return false;
	}
	
	var rowHeaderObjs = this.SheetHeaderObject.querySelectorAll("th.RowHeader");
	var rowHeaderObj = null;
	var rowHeaderDivObj = null;
	var rowHeaderCount = rowHeaderObjs.length;
	var i = 0;
	
	//시트 헤더 내 행열 타이틀 셀을 찾아 타이틀을 적용
	for(i = 0; i < rowHeaderCount; i++){
		rowHeaderObj = rowHeaderObjs[i];
		rowHeaderDivObj = rowHeaderObj.querySelector("div");
		
		//만약 헤더 태그 내 div 태그가 없다면, th 태그에 행열 타이틀 적용
		if( rowHeaderDivObj == null ){
			rowHeaderObj.innerText = title;
		}
		//만약 헤더 태그 내 div 태그가 있다면, th 태그 내 div 태그에 행열 타이틀 적용
		else{
			rowHeaderDivObj.innerText = title;
		}
		
		//메모리 해제
		rowHeaderDivObj = null;
		rowHeaderObj = null;
	}
	
	//메모리 해제
	rowHeaderObjs = null;
	
	return true;
};

EasySheetRenderer.prototype.setRowNumOrder = function(order){
	//예외처리 : 파라메터는 true 또는 false 만 받음
	if( typeof order != "boolean" ){
		return false;
	}
	
	this.rowNumOrder = order;
	
	return true;
};

EasySheetRenderer.prototype.setDisplayScrollBar = function(isDisplay){
	//예외처리 : 파라메터는 true 또는 false 만 받음
	if( typeof isDisplay != "boolean" ){
		return false;
	}
	
	this.displayScrollBar = isDisplay;
	
	this.resize();
	
	return true;
};

EasySheetRenderer.prototype.setTabKeyAction = function(tabKeyAction){
	//예외처리 : 파라메터는 SHEET_TAB_TONEXTCELL(1) 또는 SHEET_TAB_TONEXTCTRL(2)만 받음
	if( typeof tabKeyAction != "number" && (tabKeyAction == 0 || tabKeyAction == 1) ){
		return false;
	}
	
	this.tabKeyAction = tabKeyAction;
	
	return true;
};

EasySheetRenderer.prototype.setDisplayOddEven = function(isDisplay){
	//예외처리 : 파라메터는 true 또는 false 만 받음
	if( typeof isDisplay != "boolean" ){
		return false;
	}
	
	this.displayOddEven = isDisplay;
	
	this.redraw();
	
	return true;
};



EasySheetRenderer.prototype.setCellStyle = function(colIndex, styleInfo){
	//파라메터 예외처리
	if( typeof colIndex != "number" || !(colIndex >= 0 && colIndex < this.columnInfo.length) )
		return false;
	if( typeof styleInfo == "undefined" )
		return false;
	
	var sheetRows = null; var sheetLeftFixRows = null; var sheetRightFixRows = null;
	var sheetCell = null; var sheetLeftFixCell = null; var sheetRightFixCell = null;
	var hasLeftFixColumn = false; var hasRightFixColumn = false;
	var columnInfo = null; var columnRow = 0; var columnCol = 0;
	
	//
	columnInfo = this.columnInfo[colIndex];
	columnRow = columnInfo.row - 1;
//	columnCol = columnInfo.col - 1;
	columnCol = columnInfo.index;
	//좌측고정, 우측고정열 확인
	hasLeftFixColumn = (this.leftFixColumnCount > 0);
	hasRightFixColumn = (this.rightFixColumnCount > 0);
	//시트 행 객체 배열
	sheetRows = this.SheetContentObject.querySelectorAll("div.SheetContentDiv tr");
	if( hasLeftFixColumn ) sheetLeftFixRows = this.SheetContentObject.querySelectorAll("div.SheetContentLeftFixDiv tr");
	if( hasRightFixColumn ) sheetRightFixRows = this.SheetContentObject.querySelectorAll("div.SheetContentRightFixDiv tr");
	
	var styleKey = null;
	var styleValue = null;
	var sheetRowLength = 0;
	var rowIndex = 0;
	var colIndex = 0;
	var i = 0; var j = 0;
	
	//스타일 적용
	for(i = 0, sheetRowLength = sheetRows.length; i < sheetRowLength; i = i + this.rowsPerDataRow){
		for(j = 0; j < this.rowsPerDataRow; j++){
			if( j != columnRow ) continue;
			
//			rowIndex = (i * this.rowsPerDataRow) + j;
			rowIndex = i + j;
			
			sheetCell = sheetRows[rowIndex].querySelector("td[cellindex='" + columnCol + "']");
			if( hasLeftFixColumn ) sheetLeftFixCell = sheetLeftFixRows[rowIndex].querySelector("td[cellindex='" + columnCol + "']");
			if( hasRightFixColumn ) sheetRightFixCell = sheetRightFixRows[rowIndex].querySelector("td[cellindex='" + columnCol + "']");
			
			for(styleKey in styleInfo){
				styleValue = styleInfo[styleKey];
				
				//스타일 속성 적용
				sheetCell.style[styleKey] = styleValue;
				if( sheetLeftFixCell != null ) sheetLeftFixCell.style[styleKey] = styleValue;
				if( sheetRightFixCell != null ) sheetRightFixCell.style[styleKey] = styleValue;
				
				//메모리 해제
				styleValue = null; styleKey = null;
			}
			
			//메모리 해제
			sheetRightFixCell = null; sheetLeftFixCell = null; sheetCell = null;
		}
	}
	
	//메모리 해제
	styleValue = null; styleKey = null;
	columnInfo = null; hasRightFixColumn = null; hasLeftFixColumn = null;
	sheetRightFixCell = null; sheetLeftFixCell = null; sheetCell = null;
	sheetRightFixRows = null; sheetLeftFixRows = null; sheetRows = null;
	
	return true;
};

EasySheetRenderer.prototype.setTitle = function(rowIndex, colIndex, title){
	//예외처리 : 파라메터
	if( typeof rowIndex == "undefined" ) return false;
	if( typeof colIndex == "undefined" ) return false;
	if( typeof title == "undefined" ) return false;
	
	var headRowItem = null;
	var headColItem = null;
	var cellItem = null;
	var headerInfoSize = this.headerInfo.length;
	var i = 0; var j = 0;
	
	//예외처리 : 행 인덱스 오류
	if( typeof rowIndex != "number" || !(rowIndex >= 0 && rowIndex < headerInfoSize) )
		return false;
	//예외처리 : 열 인덱스 오류
	if( typeof colIndex != "number" || !(colIndex >= 0 && colIndex < this.colsPerRow) )
		return null;
	
	headRowItem = this.headerInfo[rowIndex];
	headColItem = headRowItem[colIndex];
	
	if( (headColItem != null && typeof headColItem != "undefined")
		&& headColItem.colspanMax <= 0
	){
		rowIndex = rowIndex - headColItem.rowspan + 1;
		rowIndex = (rowIndex < 0) ? 0 : rowIndex;
		
		headRowItem = null;
		headColItem = null;
		headRowItem = this.headerInfo[rowIndex];
		
		for(i = colIndex; i >= 0; i--){
			headColItem = headRowItem[i];
			if( headColItem.colspan > 0 ) break;
			headColItem = null;
		}
	}
	
	//예외처리 : 열 인덱스 오류
	if( headColItem == null || typeof headColItem == "undefined" ){
		headColItem = null; headRowItem = null; //메모리 해제
		return false;
	}
	
	var headerStartRowIndex = this.headerInfo.length - this.rowsPerDataRow;
	var isHeaderRow = (rowIndex >= headerStartRowIndex);
	var rightFixGap = this.colsPerRow - this.rightFixColumnCount;
	
	headColItem.title = title;
	if( isHeaderRow ) this.columnInfo[headColItem.cellIndex].title = title;
	
	//헤더 타이틀 수정
	cellItem = headColItem.cells.header;
	if( isHeaderRow ) cellItem.getElementsByTagName("div")[0].innerHTML = title;
	else			  cellItem.innerHTML = title;
	cellItem = null;
	
	//좌측고정 헤더 타이틀 수정
	if( this.leftFixColumnCount > 0 && i < this.leftFixColumnCount ){
		cellItem = headColItem.cells.leftfix;
		if( isHeaderRow ) cellItem.getElementsByTagName("div")[0].innerHTML = title;
		else			  cellItem.innerHTML = title;
		cellItem = null;
	}
	
	//우측고정 헤더 타이틀 수정
	if( this.rightFixColumnCount > 0 && i >= rightFixGap ){
		cellItem = headColItem.cells.rightfix;
		if( isHeaderRow ) cellItem.getElementsByTagName("div")[0].innerHTML = title;
		else			  cellItem.innerHTML = title;
		cellItem = null;
	}
	
	//메모리 해제
	headColItem = null; headRowItem = null;
	
	return true;
};

EasySheetRenderer.prototype.getTitle = function(rowIndex, colIndex){
	//파라메터 예외처리
	//예외처리 : 파라메터
	if( typeof rowIndex == "undefined" ) return null;
	if( typeof colIndex == "undefined" ) return null;
	
	var headRowItem = null;
	var headColItem = null;
	var title = "";
	var headerInfoSize = this.headerInfo.length;
	var i = 0;
	
	//예외처리 : 행 인덱스 오류
	if( typeof rowIndex != "number" || !(rowIndex >= 0 && rowIndex < headerInfoSize) )
		return null;
	//예외처리 : 열 인덱스 오류
	if( typeof colIndex != "number" || !(colIndex >= 0 && colIndex < this.colsPerRow) )
		return null;
	
	headRowItem = this.headerInfo[rowIndex];
	headColItem = headRowItem[colIndex];
	
	if( (headColItem != null && typeof headColItem != "undefined")
		&& headColItem.colspanMax <= 0
	){
		rowIndex = rowIndex - headColItem.rowspan + 1;
		rowIndex = (rowIndex < 0) ? 0 : rowIndex;
		
		headRowItem = null;
		headColItem = null;
		headRowItem = this.headerInfo[rowIndex];
		
		for(i = colIndex; i >= 0; i--){
			headColItem = headRowItem[i];
			if( headColItem.colspan > 0 ) break;
			headColItem = null;
		}
	}
	
	//예외처리 : 열 인덱스 오류
	if( headColItem == null || typeof headColItem == "undefined" ){
		headColItem = null; headRowItem = null; //메모리 해제
		return null;
	}
	
	title = headColItem.title;
	
	//메모리 해제
	headColItem = null; headRowItem = null;
	
	return title;
};

EasySheetRenderer.prototype.getDataForExcel = function(){
	//엑셀정보 초기화
	var generationInfo = new xlGenerationInfo();
	generationInfo.sheetType = 0;							// EasySheet
	generationInfo.rowsColors = "";
	generationInfo.rowsNum = this.isShowRowHeader ? 1 : 0;	// Row Header's Depth
	generationInfo.colsNum = this.rowsPerDataRow;			// Column Header's Depth
	generationInfo.colsWidth = null;
	generationInfo.align = null;							//SHEET_ALIGN_LEFT:0, SHEET_ALIGN_RIGHT:1, SHEET_ALIGN_CENTER:2
	generationInfo.format = null;
	generationInfo.data = null;
	generationInfo.decimal = null;
	generationInfo.rowsLevels = null;
	
	var dataList = [];
	var decimalList = [];
	var rowLevelList = [];
	var aligns = [];
	var formats = [];
	
	var rowInfo = null; var rowspan = 0; var rowCount = 0;
	var colInfo = null; var colspan = 0; var colCount = 0;
	var i = 0; var j = 0; var k = 0;
	var r = 0; var c = 0;
	
	//컬럼 너비
	if( this._columnWidths != null ){
		var columnWidths = this._columnWidths;
		var columnWidthCount = columnWidths.length;
		var widths = [];
		
		//셀너비 px에서 pt로 변환
		for(i = 0; i < columnWidthCount; i++){
			widths[i] = Math.ceil(parseFloat(1 * columnWidths[i]) / 7);
		}
		//셀 너비 추가
		generationInfo.colsWidth = (this.isShowRowHeader ? "7\t" : "") + (widths.join("\t"));
		
		//메모리 해제
		widths.clear(); widths = null;
		columnWidths = null;
	}
	
	//헤더 생성
	if( this.isShowHeader ){
		var headerInfos = this.headerInfo;
		var headers = null; var header = null; var title = null;
		var decimals = null; var decimal = null; var pointIndex = -1; var pointCount = 0;
		
		//시트 행열타이틀
		var rowColTitle = this.SheetHeaderObject.querySelector("th.RowHeader > div").innerText;
		if( rowColTitle === "" ) rowColTitle = " ";
		
		//헤더 보이기 설정에 따라 헤더 타이틀 배열 행,열 수 계산 
		rowCount = headerInfos.length - (this.isShowColHeader ? 0 : this.rowsPerDataRow);
		colCount = this.colsPerRow;
		
		//헤더 배열 생성
		for(i = 0, header = [], decimal = []; i < colCount; i++){
			header[i] = null;
			decimal[i] = 0;
		}
		for(i = 0, headers = [], decimals = []; i < rowCount; i++){
			headers[i] = JSON.parse(JSON.stringify(header));
			decimals[i] = JSON.parse(JSON.stringify(decimal));
		}
		
		//헤더 배열 채우기
		for(i = 0, header = null, decimal = null; i < rowCount; i++, rowInfo = null){
			rowInfo = headerInfos[i];
			
			for(j = 0; j < colCount; j++, colInfo = null){
				colInfo = rowInfo[j];
				
				//colspan이 0 보다작거나 같은 경우, 병합된 셀이므로 넘어감
				if( colInfo.colspan <= 0 ) continue;
				
				//colspan이 0보다 크다면, 현재 셀과 병합된 셀의 타이틀을 채움
				//타이틀
				title = colInfo.title;
				title = ((title == null || typeof title == "undefined" || title === "") ? " " : title);
				title = title.replace(/<br>/gi, "\r\n");
				//병합 정보
				rowspan = i + colInfo.rowspanMax;
				colspan = j + colInfo.colspanMax;
				//소수점 자리수 계산
				if( title.isNum() ){
					pointIndex = title.lastIndexOf(".");
					pointCount = (pointIndex < 0 ? 0 : title.length - (pointIndex + 1));
				}
				else pointCount = 0;
				
				//타이틀 채우기
				for(r = i; r < rowspan && r < rowCount; r++, header = null, decimal = null){
					header = headers[r];
					decimal = decimals[r];
					
					for(c = j; c < colspan && c < colCount; c++){
						header[c] = title;
						decimal[c] = pointCount;
					}
				}
				
				//메모리 해제
				title = null;
			}
		}
		
		//단일 행 시트인 경우 버튼 컬럼이나 숨김 컬럼인 경우, 헤더 컬럼 제외
		if( this.rowsPerDataRow == 1 ){
			for(i = this.columnInfo.length - 1; i >= 0; i--, colInfo = null){
				colInfo = this.columnInfo[i];
				//버튼 컬럼이나 숨김 컬럼인 경우, 배열에서 제거함
				if( colInfo.cellType == "button" || colInfo.hidden ){
					for(j = 0; j < rowCount; j++){
						//헤더 타이틀에서 컬럼 제거
						header = headers[j];
						header.splice(i, 1);
						header = null;
						//헤더 소수점 정보에서 컬럼 제거
						decimal = decimals[j];
						decimal.splice(i, 1);
						decimal = null;
					}
				}
			}
		}
		
		//헤더  추가
		for(i = 0, header = null, decimal = null; i < rowCount; i++){
			//헤더 타이틀 추가
			header = headers[i];
			dataList[i] = (this.isShowRowHeader ? rowColTitle + "\t" : "") + header.join("\t");
			header = null;
			//헤더 소수점 정보 추가
			decimal = decimals[i];
			decimalList[i] = (this.isShowRowHeader ? "0\t" : "") + decimal.join("\t");
			decimal = null;
			//헤더 row-level 추가(헤더는 row-level을 -1로 추가하여 데이터 레코드의 row-level과 구분) 
			rowLevelList[i] = -1;
		}
		
		//헤더 타이틀 행수에 따라  컬럼 헤더 뎁스 수정
		generationInfo.colsNum = rowCount;
		
		//메모리 해제
		decimals.clear(); decimals = null;
		headers.clear(); headers = null;
		headerInfos = null;
	}
	else{
		//헤더 타이틀 행수에 따라  컬럼 헤더 뎁스 수정
		generationInfo.colsNum = 0;
	}
	
	//정렬정보 및 표시형식 생성
	for(i = 0, j = 0, colCount = this.columnInfo.length; i < colCount; i++, colInfo = null){
		colInfo = this.columnInfo[i];
		//단일 행 시트인 경우 버튼 컬럼이나 숨김 컬럼인 경우, 제외
		if( this.rowsPerDataRow == 1 && (colInfo.cellType == "button" || colInfo.hidden) ) continue;
		//정렬 및 표시형식 설정
		aligns[j] = ((colInfo.align == "center") ? SHEET_ALIGN_CENTER : (colInfo.align == "right") ? SHEET_ALIGN_RIGHT : SHEET_ALIGN_LEFT);
		formats[j] = ((colInfo.displayFormat !== "") ? colInfo.displayFormat : " ");
		j++;
	}
	generationInfo.align = (this.isShowRowHeader ? SHEET_ALIGN_CENTER + "\t" : "") + aligns.join("\t");
	generationInfo.format = (this.isShowRowHeader ? "\t" : "") + formats.join("\t");
	
	//데이터 생성
	if( this.dataSet.getCount() > 0 ){
		var headerInfos = this.headerInfo;
		var startIndex = headerInfos.length - this.rowsPerDataRow;
		var rowIndex = 0; var colIndex = 0;
		
		var columnInfo = null;
		var columnInfoCount = this.columnInfo.length;
		var field = null; var cellType = null;
		
		var datas = null; var data = null;
		var records = null; var record = null; var value = null; var text = null;
		var decimals = null; var decimal = null; var pointIndex = -1; var pointCount = 0;
		var rowLevels = null; var rowLevel = 0;
		
		//숨김 열 제외
		for(i = 0, j = 0, rowCount = this.dataSet.data.length, datas = []; i < rowCount; i++, data = null){
			data = this.dataSet.data[i];
			
			if( typeof data.__STATE__ != "undefined"
				&& typeof data.__STATE__.hidden == "boolean"
				&& data.__STATE__.hidden == true
			){
				continue;
			}
			
			datas[j++] = data;
		}
		
		rowCount = datas.length * this.rowsPerDataRow;
		colCount = this.colsPerRow;
		
		//데이터 배열 생성
		for(i = 0, record = [], decimal = []; i < colCount; i++){
			record[i] = null;
			decimal[i] = 0;
		}
		for(i = 0, records = [], decimals = [], rowLevels = []; i < rowCount; i++){
			records[i] = JSON.parse(JSON.stringify(record));
			decimals[i] = JSON.parse(JSON.stringify(decimal));
			rowLevels[i] = 0;
		}
		
		//데이터 배열 채우기
		for(i = 0, record = null, decimal = null, rowCount = datas.length; i < rowCount; i++, data = null){
			data = datas[i];
			
			for(j = 0; j < this.rowsPerDataRow; j++, rowInfo = null){
				rowInfo = headerInfos[startIndex + j];
				rowIndex = (i * this.rowsPerDataRow) + j;
				
				for(k = colCount - 1; k >= 0; k--, colInfo = null, columnInfo = null){
					//
					colInfo = rowInfo[k];
					if( colInfo.colspan <= 0 ) continue;
					//
					colIndex = colInfo.cellIndex;
					if( colIndex >= columnInfoCount ) continue;
					
					//
					rowspan = rowIndex + colInfo.rowspan;
					colspan = k + colInfo.colspan;
					
					//컬럼 정보
					columnInfo = this.columnInfo[colIndex];
					//단일 행 시트이고 컬럼 타입이 버튼이거나 숨김 컬럼인 경우, 제외
					if( this.rowsPerDataRow == 1 && (columnInfo.cellType == "button" || columnInfo.hidden) ){
						//데이터 레코드에서 컬럼 제거
						record = records[rowIndex];
						record.splice(colIndex, 1);
						record = null;
						//헤더 소수점 정보에서 컬럼 제거
						decimal = decimals[rowIndex];
						decimal.splice(colIndex, 1);
						decimal = null;
						continue;
					}
					
					//데이터
					field = columnInfo.field;
					cellType = columnInfo.cellType;
					text = data.__STATE__[field + ".TEXT"];
					value = data[field];
					//
					if( typeof data.__STATE__ != "undefined" && typeof data.__STATE__._rowLevel != "undefined" )
						 rowLevel = data.__STATE__._rowLevel; 
					else rowLevel = 0;
					
					if( cellType == "button" ){
						value = "";
					}
					else{
						value = ((value == null || typeof value == "undefined") ? "" : value);
						value = ("" + this.getDisplayValueByCellType(colIndex, value, text));
						
						if( cellType == "checkbox" )
							value = (value == columnInfo.checkedIcon) ? "1" : "0";
						else
							if( typeof value == "undefined" || value == null || value == "undefined" || value == "null" ) value = "";
					}
					
					if( value === "" ) value = " ";
					
					//소수점 자리수 계산
					if( value.isNum() ){
						pointIndex = value.lastIndexOf(".");
						pointCount = (pointIndex < 0 ? 0 : value.length - (pointIndex + 1));
					}
					else pointCount = 0;
					
					//데이터 채우기
					for(r = rowIndex; r < rowspan; r++, record = null, decimal = null){
						record = records[r];
						decimal = decimals[r];
						rowLevels[r] = rowLevel;
						
						for(c = k; c < colspan; c++){
							record[c] = value;
							decimal[c] = pointCount;
						}
					}
					
					//메모리 해제
					value = null; text = null; cellType = null; field = null;
				}
			}
		}
		
		//데이터 추가
		for(i = 0, j = 0, rowIndex = dataList.length, rowCount = records.length; i < rowCount; i++, rowIndex++){
			//행번호 설정
			if( i % this.rowsPerDataRow == 0 ) j++;
			//헤더 타이틀 추가
			record = records[i];
			dataList[rowIndex] = (this.isShowRowHeader ? j + "\t" : "") + record.join("\t");
			record = null;
			//헤더 소수점 정보 추가
			decimal = decimals[i];
			decimalList[rowIndex] = (this.isShowRowHeader ? "0\t" : "") + decimal.join("\t");
			decimal = null;
			//
			rowLevelList[rowIndex] = rowLevels[i];
		}
		generationInfo.data = dataList.join("<<%ENTER%>>");
		generationInfo.decimal = decimalList.join("<<%ENTER%>>");
		generationInfo.rowsLevels = rowLevelList.join(",");
		
		//메모리 해제
		rowLevels.clear(); rowLevels = null;
		decimals.clear(); decimals = null;
		records.clear(); records = null;
		datas = null; headerInfos = null;
	}
	
	//메모리 해제
	formats.clear(); formats = null;
	aligns.clear(); aligns = null;
	rowLevelList.clear(); rowLevelList = null;
	decimalList.clear(); decimalList = null;
	dataList.clear(); dataList = null;
	
	return generationInfo;
};

EasySheetRenderer.prototype._getDataForExcel = function(){
	//엑셀정보 초기화
	var generationInfo = new xlGenerationInfo();
	generationInfo.sheetType = 0;							// EasySheet
	generationInfo.rowsColors = "";
	generationInfo.rowsNum = this.isShowRowHeader ? 1 : 0;	// Row Header's Depth
	generationInfo.colsNum = this.rowsPerDataRow;			// Column Header's Depth
	generationInfo.colsWidth = null;
	generationInfo.align = null;							//SHEET_ALIGN_LEFT:0, SHEET_ALIGN_RIGHT:1, SHEET_ALIGN_CENTER:2
	generationInfo.format = null;
	generationInfo.data = null;
	generationInfo.decimal = null;
	
	var headerInfos = this.headerInfo;
	var datas = this.dataSet.data;
	
	var rowInfo = null; var colInfo = null;
	var rowspan = 0; var colspan = 0;
	var rowsPerDataRow = this.rowsPerDataRow;
	var rowCount = 0; var rowIndex = 0; 
	var colCount = this.colsPerRow;
	var startIndex = headerInfos.length - rowsPerDataRow;
	var i = 0; var j = 0; var k = 0;
	var r = 0; var c = 0;
	
	var dataList = [];
	var decimalList = [];
	
	var aligns = [];
	var formats = [];
	
	var records = []; var record = null; var field = null; var value = null; var text = null;
	var decimals = []; var decimal = null; var pointIndex = -1; var pointCount = 0;
	
	//컬럼 너비
	if( this._columnWidths != null ){
		var columnWidths = this._columnWidths;
		var widths = [];
		
		//셀너비 px에서 pt로 변환
		for(i= columnWidths.length - 1; i >= 0 ; i--){
			widths[i] = Math.ceil(parseFloat(1 * columnWidths[i]) / 7);
		}
		//셀 너비 추가
		generationInfo.colsWidth = (this.isShowRowHeader ? "7\t" : "") + widths.reverse().join("\t");
		
		//메모리 해제
		widths.clear(); widths = null;
		columnWidths = null;
	}
	
	//헤더 생성
	if( this.isShowHeader ){
		var headers = []; var header = null; var title = null;
		var rowColTitle = null;
		
		//시트 행열타이틀
		rowColTitle = this.SheetHeaderObject.querySelector("th.RowHeader").innerText;
		if( rowColTitle === "" ) rowColTitle = " ";
		
		//헤더 보이기 설정에 따라 헤더 타이틀 배열 행 수 계산 
		rowCount = headerInfos.length - (this.isShowColHeader ? 0 : rowsPerDataRow);
		
		//헤더 행 수 만큼 행 배열 생성
		for(i = 0; i < rowCount; i++){
			headers[i] = [];
			decimals[i] = [];
		}
		
		//헤더 타이틀 배열 채우기
		for(i = 0; i < rowCount; i++, rowInfo = null){
			rowInfo = headerInfos[i];
			
			for(j = 0; j < colCount; j++, colInfo = null){
				colInfo = rowInfo[j];
				
				//colspan이 0 보다작거나 같은 경우, 병합된 셀이므로 넘어감
				if( colInfo.colspan <= 0 ) continue;
				
				//colspan이 0보다 크다면, 현재 셀과 병합된 셀의 타이틀을 채움
				//타이틀
				title = "" + colInfo.title;
				//병합 정보
				rowspan = i + colInfo.rowspan;
				colspan = j + colInfo.colspan;
				//소수점 자리수 계산
				if( title.isNum() ){
					pointIndex = title.lastIndexOf(".");
					pointCount = (pointIndex < 0 ? 0 : title.length - (pointIndex + 1));
				}
				else pointCount = 0;
				
				//타이틀 채우기
				for(r = i; r < rowspan && r < rowCount; r++, header = null, decimal = null){
					header = headers[r];
					decimal = decimals[r];
					
					for(c = j; c < colspan && c < colCount; c++){
						header[c] = title;
						decimal[c] = pointCount;
					}
				}
				
				//메모리 해제
				title = null;
			}
		}
		
		//헤더  추가
		for(i = 0; i < rowCount; i++, header = null, decimal = null){
			//헤더 타이틀 추가
			header = headers[i];
			dataList[i] = (this.isShowRowHeader ? rowColTitle + "\t" : "") + header.join("\t");
			//헤더 소수점 정보 추가
			decimal = decimals[i];
			decimalList[i] = (this.isShowRowHeader ? "0\t" : "") + decimal.join("\t");
		}
		
		//헤더 타이틀 행수에 따라  컬럼 헤더 뎁스 수정
		generationInfo.colsNum = rowCount;
		
		//메모리 해제
		decimals.clear(); decimals = null;
		headers.clear(); headers = null;
	}
	else{
		//헤더 타이틀 행수에 따라  컬럼 헤더 뎁스 수정
		generationInfo.colsNum = 0;
	}
	
	//
	var data = null;
	var columnInfo = null;
	var colInfoCount = this.columnInfo.length;
	var colInfoIndex = 0;
	
	//컬럼 정렬, 표시문자열
	for(i = 0; i < colInfoCount; i++, columnInfo = null){
		columnInfo = this.columnInfo[i];
		aligns[i] = ((columnInfo.align == "center") ? SHEET_ALIGN_CENTER : (columnInfo.align == "right") ? SHEET_ALIGN_RIGHT : SHEET_ALIGN_LEFT);
		formats[i] = (columnInfo.displayFormat !== "") ? columnInfo.displayFormat : " ";
	}
	generationInfo.align = (this.isShowRowHeader ? SHEET_ALIGN_CENTER + "\t" : "") + aligns.join("\t");
	generationInfo.format = (this.isShowRowHeader ? "\t" : "") + formats.join("\t");
	
	//
	for(i = 0, decimals = [], rowCount = datas.length * rowsPerDataRow; i < rowCount; i++){
		records[i] = [];
		decimals[i] = [];
	}
	
	//
	for(i = 0, rowCount = datas.length; i < rowCount; i++, data = null){
		data = datas[i];
		
		for(j = 0; j < rowsPerDataRow; j++, rowInfo = null){
			rowInfo = headerInfos[startIndex + j];
			rowIndex = (i * rowsPerDataRow) + j;
			
			for(k = 0; k < colCount; k++, colInfo = null){
				//
				colInfo = rowInfo[k];
				if( colInfo.colspan <= 0 ) continue;
				//
				colInfoIndex = colInfo.cellIndex;
				if( colInfoIndex >= colInfoCount ) continue;
				
				//
				rowspan = rowIndex + colInfo.rowspan;
				colspan = k + colInfo.colspan;
				//
				columnInfo = this.columnInfo[colInfoIndex];
				field = columnInfo.field;
				text = data.__STATE__[field + ".TEXT"];
				value = "" + this.getDisplayValueByCellType(colInfoIndex, data[field], text);
				
				if( value === "" ) value = " ";
				//소수점 자리수 계산
				if( value.isNum() ){
					pointIndex = value.lastIndexOf(".");
					pointCount = (pointIndex < 0 ? 0 : value.length - (pointIndex + 1));
				}
				else pointCount = 0;
				
				//
				for(r = rowIndex; r < rowspan; r++, record = null, decimal = null){
					record = records[r];
					decimal = decimals[r];
					
					for(c = k; c < colspan; c++){
						record[c] = value;
						decimal[c] = pointCount;
					}
				}
				
				//메모리 해제
				value = null; text = null; field = null; columnInfo = null;
			}
		}
	}
	
	//
	for(i = 0, rowIndex = dataList.length, rowCount = records.length; i < rowCount; i++, rowIndex++, record = null, decimal = null){ 
		//헤더 타이틀 추가
		record = records[i];
		dataList[rowIndex] = (this.isShowRowHeader ? (i + 1) + "\t" : "") + record.join("\t");
		//헤더 소수점 정보 추가
		decimal = decimals[i];
		decimalList[rowIndex] = (this.isShowRowHeader ? "0\t" : "") + decimal.join("\t");
	}
	
	//엑셀데이터 추가
	generationInfo.data = dataList.join("<<%ENTER%>>");
	//엑셀 데이터 소수점 정보 추가
	generationInfo.decimal = decimalList.join("<<%ENTER%>>");
	
	//메모리 해제
	formats.clear(); formats.clear();
	aligns.clear(); aligns.clear();
	decimals.clear(); decimals = null;
	records.clear(); records = null;
	decimalList.clear(); decimalList = null;
	dataList.clear(); dataList = null;
	datas = null; headerInfos = null;
	
	return generationInfo;
};

EasySheetRenderer.prototype.hideCellEdit = function(applyChangeValue){
	//현재 편집 상태인지 체크
	if( this.editingCellObject == null ) return false;
	
	var colIndex = null;
	
	//파라메터 체크 : applyChangeValue 가 true 인 경우에만 현재 편집중인 값 적용
	applyChangeValue = (typeof applyChangeValue == "boolean" && applyChangeValue === true) ? true : false;
	//열 인덱스
	colIndex = 1 * this.editingCellObject.getAttribute("cellIndex");
	
	//컬럼 타입이 text 아닌 경우 편집을 멈추지 않음
	if( this.columnInfo[colIndex].cellType != "text"
	    && this.columnInfo[colIndex].cellType != "integer"
	    && this.columnInfo[colIndex].cellType != "number"
	    && this.columnInfo[colIndex].cellType != "percent"
	    && this.columnInfo[colIndex].cellType != "date"
	  ){
		//메모리 해제
		colIndex = null;
		
		return false;
	}
	
	//편집 컨트롤 Blur 이벤트 발생시키지 않음
	this.isIgnoreEditingControlBlurEvent = true;
	//수정 데이터 적용
	this.setApplyChangedValueToCell(applyChangeValue);
	//편집 컨트롤 닫음
	this.removeSheetEditControl();
	//시트 메세지박스 숨김
	this.setSheetMsgBox(false);
	
	//메모리 해제
	colIndex = null;
	
	return true;
};

EasySheetRenderer.prototype.hideCellCombo = function(applyChangeValue){
	//현재 편집 상태인지 체크
	if( this.editingCellObject == null ) return false;
	
	var colIndex = null;
	
	//파라메터 체크 : applyChangeValue 가 true 인 경우에만 현재 편집중인 값 적용
	applyChangeValue = (typeof applyChangeValue == "boolean" && applyChangeValue === true) ? true : false;
	//열 인덱스
	colIndex = 1 * this.editingCellObject.getAttribute("cellIndex");
	
	//컬럼 타입이 text 아닌 경우 편집을 멈추지 않음
	if( this.columnInfo[colIndex].cellType != "combobox" ){
		//메모리 해제
		colIndex = null;
		
		return false;
	}
	
	//편집 컨트롤 Blur 이벤트 발생시키지 않음
	this.isIgnoreEditingControlBlurEvent = true;
	//수정 데이터 적용
	this.setApplyChangedValueToCell(applyChangeValue);
	//편집 컨트롤 닫음
	this.removeSheetEditControl();
	//시트 메세지박스 숨김
	this.setSheetMsgBox(false);
	
	//메모리 해제
	colIndex = null;
	
	return true;
};

EasySheetRenderer.prototype.isVisibleColumn = function(colIndex){
	//파라메터 예외처리
	if( typeof colIndex == "undefined" || typeof colIndex != "number" || !(colIndex >= 0 && colIndex < this.columnInfo.length) )
		return false;
	
	var headerInfos = null; var headerInfo = null; var headerCell = null;
	var headerRowIndex = 0; var headerCellIndex = 0;
	var columnInfo = null; var columnRow = 0; var columnCol = 0;
	var rowSpan = 0; var colSpan = 0;
	var columnWidth = 0;
	var columnWidthSum = 0;
	var columnWidthSumBeforecolIndex = 0;
	var cLeftGap = 0; var cRightGap = 0;
	var result = true;
	var i = 0; var m = 0;
	
	columnInfo = this.columnInfo[colIndex];
	columnRow = columnInfo.row - 1;
//	columnCol = columnInfo.col - 1;
	columnCol = columnInfo.index;
	
	headerRowIndex = this.headerInfo.length - this.rowsPerDataRow + columnRow;
	headerInfos = this.headerInfo[headerRowIndex];
	
	for(i = 0; i < this.colsPerRow; i++, headerInfo = null){
		headerInfo = headerInfos[i];
		headerCellIndex = headerInfo.cellIndex;
		rowSpan = headerInfo.rowspan;
		colSpan = headerInfo.colspan;
		
		if( headerCellIndex <= columnCol){
			if( colSpan < 0 && rowSpan > 1 ){
				var orginInfos = this.headerInfo[headerRowIndex - (rowSpan - 1)];
				var orginInfo = null;
				//
				for(m = i; m >= 0; m--, orginInfo = null){
					orginInfo = orginInfos[m];
					//
					if( orginInfo.colspan < 0 ) continue;
					//
					else{
						headerCell = orginInfo.cells.header;
						break;
					}
				}
				//
				orginInfo = null;
				orginInfos = null;
			}
			else if( colSpan < 0 && rowSpan == 1 ){
				headerCell = null;
			}
			else{
				headerCell = headerInfo.cells.header;
			}
			
			if( headerCell != null ){
				columnWidth = ((1 * getComputedStyle(headerCell).width.replace("px", "")) + 1);
				columnWidthSumBeforecolIndex += (i <= colIndex - 1 ? columnWidth : 0);
				columnWidthSum += columnWidth;
			}
			
			headerCell = null;
			headerInfo = null;
		}
		
		//
		if( headerCellIndex == columnCol ) break;
	}
	
	cLeftGap = (Math.ceil(this.sheetLeftFixWidth) + Math.ceil(this.sheetContentTableLeft)) - columnWidthSumBeforecolIndex;
	cRightGap = columnWidthSum - (Math.ceil(this.sheetContentDivWidth) + Math.ceil(this.sheetContentTableLeft));
	
	if( this.rightFixColumnCount > 0 && colIndex - (this.colsPerRow - this.rightFixColumnCount) < this.rightFixColumnCount ){
		//우측 고정열이 있고 컬럼이 우측고정열 범위 내 있다면 숨겨진 컬럼이 아님
		result = true;
	}
	else if( this.leftFixColumnCount > 0 && colIndex < this.leftFixColumnCount ){
		//좌측 고정열이 있고 컬럼이 좌측고정열 범위 내 있다면 숨겨진 컬럼이 아님
		result = true;
	}
	else if( cLeftGap > 0 ){
		if( Math.ceil((columnWidthSum - columnWidthSumBeforecolIndex) / 2) < cLeftGap )
			result = false;
	}
	else if( cRightGap > 0 ){
		if( Math.floor((columnWidthSum - columnWidthSumBeforecolIndex) / 2) < cRightGap )
			result = false;
	}
	
	//메모리 해제
	columnWidthSumBeforecolIndex = null;
	columnWidthSum = null; columnWidth = null;
	headerInfos = null; columnInfo = null;
	
	return result;
};

EasySheetRenderer.prototype.isVisibleRow = function(rowIndex){
	//예외처리
	if( typeof rowIndex == "undefined" || (typeof rowIndex != "number" && !(rowIndex >= 0 && rowIndex < this.dataRowCount)) )
		return false;
	
	//화면내 행 보이기 여부 체크 : 범위 밖인 경우 false 리턴
	if( !(rowIndex >= this.showedTopRowIndex && rowIndex < this.showedTopRowIndex + this.displayMaxRowCount) ){
		return false;
	}
	
	//범위 내 행이 보인다면 true 리턴
	return true;
};

EasySheetRenderer.prototype.refreshOddEven = function(){
	var rows = null;		 var row = null;			//시트 본문
	var leftFixRows = null;	 var leftFixRow = null;		//시트 좌측고정
	var rightFixRows = null; var rightFixRow = null;	//시트 우측고정
	var displayOddEven = this.displayOddEven;
	var rowClass = null;
	var rowCount = 0;
	var i = 0;
	
	rows = this.SheetContentObject.querySelectorAll("div.SheetContentDiv > table tr");
	if( typeof this.SheetHeaderLeftFixObject != "undefined" && this.SheetHeaderLeftFixObject != null ){
		leftFixRows = this.SheetContentObject.querySelectorAll("div.SheetContentLeftFixDiv > table tr");
	}
	if( typeof this.SheetHeaderRightFixObject != "undefined" && this.SheetHeaderRightFixObject != null ){
		rightFixRows = this.SheetContentObject.querySelectorAll("div.SheetContentRightFixDiv > table tr");
	}
	
	//행 보이기 & 행번호를 기준으로 홀수번째 행과 짝수번째 행 CSS 적용
	for(i = 0, rowCount = rows.length; i < rowCount && i < this.displayedRowCount; i++, rowClass = null){
		rowClass = (displayOddEven ? ((i + 1) % 2 == 0 ? "even-num-row" : "odd-num-row") : "none-background-row");
		
		//시트 본문
		row = rows[i];
		row.style.display = "table-row";
		this.removeClass(row, "even-num-row odd-num-row none-background-row");
		this.addClass(row, rowClass);
		row = null;
		
		//좌측고정열
		if( leftFixRows != null ){
			leftFixRow = leftFixRows[i];
			leftFixRow.style.display = "table-row";
			this.removeClass(leftFixRow, "even-num-row odd-num-row none-background-row");
			this.addClass(leftFixRow, rowClass);
			leftFixRow = null;
		}
		
		//우측고정열
		if( rightFixRows != null ){
			rightFixRow = rightFixRows[i]; 
			rightFixRow.style.display = "table-row";
			this.removeClass(rightFixRow, "even-num-row odd-num-row none-background-row");
			this.addClass(rightFixRow, rowClass);
			rightFixRow = null;
		}
	}
	
	//메모리 해제
	rightFixRows = null; leftFixRows = null; rows = null;
	
	return true;
};

EasySheetRenderer.prototype.getOddEvenStyle = function(rowIndex){
	var row = null;
	var result = null;
	
	//행 객체
	row = this.SheetContentObject.querySelector("div.SheetContentDiv > table tr[recordindex='" + rowIndex + "']")
	
	if( row != null ){
		//행 클래스에서 Odd, Even 또는 None-background Class 탐색
		if( this.hasClass(row, "even-num-row") > 0 ){
			result = "even-num-row";
		}
		else if( this.hasClass(row, "odd-num-row") > 0 ){
			result = "odd-num-row";
		}
		else if( this.hasClass(row, "none-background-row") > 0 ){
			result = "none-background-row";
		}
	}
	
	//메모리 해제
	row = null;
	
	return result;
};

EasySheetRenderer.prototype.displaySortDirection = function(headerCellObject, sortDirection){
	//예외처리
	if( typeof headerCellObject == "undefined" || headerCellObject == null ){
		//파라메터가 전달되지 않은 경우
		return false;
	}
	if( headerCellObject.tagName.toLowerCase() != "th" ){
		//파라메터로 전달된 객체가 셀 안의 div 객체가 아닌 경우
		return false;
	}
	if( headerCellObject.querySelector("div.EasySheetFilterDiv") != null ){
		return false;
	}
	
	var sortDisplayObject = null;
	var sortContentObject = null;
	var headCellStyle = getComputedStyle(headerCellObject);
	
	//정렬 표시 Div객체 생성
	sortDisplayObject = document.createElement("div");
	sortDisplayObject.setAttribute("class", "EasySheetSortDiv");
	sortDisplayObject.style.width = headCellStyle.width;
	sortDisplayObject.style.height = headCellStyle.height;
	//정렬 방향 화살표 생성 및 추가
	sortContentObject = document.createElement("span");
	sortContentObject.setAttribute("class", (sortDirection === SHEET_SORT_ORDER_DESCENDING) ? "icon-sort-down" : "icon-sort-up");
//	sortContentObject.innerText = (sortDirection === SHEET_SORT_ORDER_DESCENDING) ? "&#xf0dd;" : "&#xf0de;";
	sortDisplayObject.appendChild(sortContentObject);
	
	//헤더 객체에 정렬 표시 Div객체 추가
	headerCellObject.appendChild(sortDisplayObject);
	
	//메모리 해제
	headCellStyle = null;
	sortContentObject = null;
	sortDisplayObject = null;
	
	return true;
};

EasySheetRenderer.prototype.removeSortDirection = function(sortDisplayObject){
	try{
		sortDisplayObject.parentElement.removeChild(sortDisplayObject);
	}
	catch(e){ return false; }
	
	return true;
};

EasySheetRenderer.prototype.removeAllSortDirection = function(){
	var wResult = true;
	var sortDisplayObjects = null;
	var sortDisplayObject = null;
	var i = 0;
	
	try{
		sortDisplayObjects = this.SheetHeaderObject.querySelectorAll("div.EasySheetSortDiv");
		
		//정렬 방향 아이콘 객체가 존재할 경우
		if( sortDisplayObjects != null && sortDisplayObjects.length > 0 ){
			for(i = 0; i < sortDisplayObjects.length; i++){
				sortDisplayObject = sortDisplayObjects[i];
				//헤더에서 정렬 방향 아이콘 객체 제거
				this.removeSortDirection(sortDisplayObject);
				//메모리 해제
				sortDisplayObject = null;
			}
		}
	}
	catch(err){
		wResult = false;
	}
	
	//메모리 해제
	sortDisplayObject = null;
	sortDisplayObjects = null;
	
	return wResult;
};

EasySheetRenderer.prototype.displayFilterIcon = function(headerCellObject, targetColumnId){
	//예외처리
	if( typeof headerCellObject == "undefined" || headerCellObject == null ){
		//파라메터가 전달되지 않은 경우
		return false;
	}
	if( headerCellObject.tagName.toLowerCase() != "th" ){
		//파라메터로 전달된 객체가 셀 안의 div 객체가 아닌 경우
		return false;
	}
	if( headerCellObject.querySelector("div.EasySheetFilterDiv") != null ){
		return true;
	}
	
	this.removeSortDirection(headerCellObject.querySelector("div.EasySheetSortDiv"));
	
	var filterDisplayObject = null;
	var filterContentObject = null;
	var headCellStyle = getComputedStyle(headerCellObject);
	
	//정렬 표시 Div객체 생성
	filterDisplayObject = document.createElement("div");
	filterDisplayObject.setAttribute("class", "EasySheetFilterDiv");
	filterDisplayObject.setAttribute("targetColId", targetColumnId);
//	filterDisplayObject.style.width = "81px";
	filterDisplayObject.style.width = headCellStyle.width;
	filterDisplayObject.style.height = headCellStyle.height;
	//정렬 방향 화살표 생성 및 추가
	filterContentObject = document.createElement("span");
	filterContentObject.setAttribute("class", "icon-filter");
	filterDisplayObject.appendChild(filterContentObject);
	
	//헤더 객체에 정렬 표시 Div객체 추가
	headerCellObject.appendChild(filterDisplayObject);
	
	//메모리 해제
	headCellStyle = null;
	filterContentObject = null;
	filterDisplayObject = null;
	
	return true;
};

EasySheetRenderer.prototype.removeFilterIcon = function(targetColumn){
	var targetSheet = null; 
	var filterDisplayObj = null;
	var headerCellObj = null;
	var i = 0;
	
	try{
		targetSheet = controls[this.controlName];
		
		//
		filterDisplayObj = targetSheet.tagObject.querySelector("div.EasySheetFilterDiv[targetColId='" + targetColumn + "']");
		if( filterDisplayObj == null || typeof filterDisplayObj == "undefined" ){
			//메모리 해제
			filterDisplayObj = null; targetSheet = null;
			return false;
		}
		
		//
//		filterDisplayObj.parentElement.removeChild(filterDisplayObj);
		headerCellObj = filterDisplayObj.parentNode;
		headerCellObj.removeChild(filterDisplayObj);
		
		//타겟 컬럼의 소트 정보가 있다면 소트 아이콘 표시
		for(i = 0; i < targetSheet.columns.length; i++){
			if( targetSheet.columns[i].colId == targetColumn ){
				if( targetSheet.columns[i].sortDirection !== "" )
					targetSheet.sheetRenderer.displaySortDirection(headerCellObj, targetSheet.columns[i].sortDirection);
				break;
			}
		}
		
		//메모리 해제
		headerCellObj = null; filterDisplayObj = null; targetSheet = null;
	}
	catch(e){
		//메모리 해제
		headerCellObj = null; filterDisplayObj = null; targetSheet = null;
		return false;
	}
	
	return true;
};

EasySheetRenderer.prototype.showContextMenu = function(positionX, positionY, headerCellObj){
	//예외처리 : 팝업메뉴 사용 안 할 경우
	if( !this.useContextMenu ) return;
	
	var parentObj = null;
	var contextMenuObj = null;
	var contextMenuHtml = null;
	var contextMenuItem = null;
	
	//컨텍스트 메뉴 객체를 찾음
	contextMenuObj = document.querySelector("div.EasySheetMenu");
	
	//컨텍스트 메뉴 객체가 없다면
	if( contextMenuObj == null ){
		//컨텍스트 메뉴 리스트 생성
		contextMenuHtml = "\r\n\t<div class=\"EasySheetMenuItem SheetSortAsc\"> <span>" + getText("message_easysheetrender_901", "오름차순 정렬") + ", A → Z</span> </div>"
						+ "\r\n\t<div class=\"EasySheetMenuItem SheetSortDesc\"> <span>" + getText("message_easysheetrender_902", "내림차순 정렬") + ", Z → A</span> </div>"
						+ "\r\n\t<div class=\"EasySheetMenuSeparator\"></div>"
						+ "\r\n\t<div class=\"EasySheetMenuItem SheetSearch\"> <span>" + getText("message_easysheetrender_903", "찾기(검색)") + "</span> </div>"
						+ "\r\n\t<div class=\"EasySheetMenuSeparator\"></div>"
						+ "\r\n\t<div class=\"EasySheetMenuItem SheetFilter\"> <span>" + getText("message_easysheetrender_904", "필터") + "</span> </div>";
		//컨텍스트 메뉴 생성
		contextMenuObj = document.createElement("div");
		contextMenuObj.setAttribute("class", "EasySheetMenu");
		contextMenuObj.innerHTML = contextMenuHtml;
		
		//화면에 추가
		parentObj = document.querySelector("div.contents");
		parentObj = (parentObj == null) ? document.body : parentObj;
		parentObj.appendChild(contextMenuObj);
		
		//화면 클릭 이벤트 추가 - 컨텍스트 메뉴 닫기
		setEventHandler(parentObj, "click", function(e){
			var contextMenuObj = null;
			//컨텍스트 메뉴 객체를 찾음
			contextMenuObj = document.querySelector("div.EasySheetMenu");
			//컨텍스트 메뉴가 추가되어 있다면 숨김
			if( contextMenuObj != null && contextMenuObj.style.display != "none" ){
				contextMenuObj.style.display = "none";
			}
			//메모리 해제
			contextMenuObj = null;
		});
		
		//메뉴 클릭 이벤트 추가 - 오름차순 정렬
		contextMenuItem = contextMenuObj.querySelector("div.EasySheetMenuItem.SheetSortAsc");
		setEventHandler(contextMenuItem, "click", function(e){
			var contextMenuObj = this.parentElement;
			var sheetName = contextMenuObj.getAttribute("targetsheet");
			var sheetColIndex = 1 * contextMenuObj.getAttribute("targetcolIndex");
			
			//컬럼 인덱스가 0보다 큰 경우에만 정렬할 수 있음
			if( sheetColIndex >= 0 ){
				var sheet = controls[sheetName];
				var renderer = sheet.sheetRenderer;
				
				if( !renderer.sortOnHeader ){
					renderer = null; sheet = null; sheetName = null; contextMenuObj = null; //메모리 해제
					return;
				}
				
				var columns = sheet.columns;
				var colId = renderer.columnInfo[sheetColIndex].field;
				var headerRowInfo = null; var headerColInfo = null;
				var headerCells = null; var headerCell = null;
				var rowCount = 0; var colCount = 0;
				var i = 0; var j = 0;
				
				//아이콘을 제거하면서 각 컬럼의 정렬 정보를 초기화
				if( renderer.removeAllSortDirection() ){
					for(i = 0, colCount = columns.length; i < colCount; i++) columns[i].sortDirection = "";
				}
				
				//시트의 데이터 오름차순 정렬이 정상적으로 완료되었다면 헤더 컬럼에 오름차순 정렬 아이콘 추가
				if( sheet.sortTable(colId, true) ){
					rowCount = renderer.headerInfo.length;
					colCount = renderer.colsPerRow;
					
					for(i = rowCount - renderer.rowsPerDataRow; i < rowCount; i++, headerRowInfo = null){
						headerRowInfo = renderer.headerInfo[i];
						for(j = 0; j < colCount; j++, headerColInfo = null){
							headerColInfo = headerRowInfo[j];
							if( headerColInfo.colspan < 0 ) continue;
							if( headerColInfo.cellIndex == sheetColIndex ){
								headerCells = headerColInfo.cells;
								headerCellObj = ("leftfix" in headerCells ? headerCells.leftfix : ("rightfix" in headerCells ? headerCells.rightfix : headerCells.header));
								headerCells = null; headerColInfo = null; headerRowInfo = null;
								break;
							}
						}
						if( headerCellObj != null ) break;
					}
					
					if( headerCellObj != null ){
						renderer.displaySortDirection(headerCellObj, true);
						headerCellObj = null;
					}
				}
				
				//메모리 해제
				colId = null; columns = null; renderer = null; sheet = null;
			}
			
			//메모리 해제
			sheetName = null; contextMenuObj = null;
		});
		contextMenuItem = null;
		
		//메뉴 클릭 이벤트 추가 - 내림차순 정렬
		contextMenuItem = contextMenuObj.querySelector("div.EasySheetMenuItem.SheetSortDesc");
		setEventHandler(contextMenuItem, "click", function(e){
			var contextMenuObj = this.parentElement;
			var sheetName = contextMenuObj.getAttribute("targetsheet");
			var sheetColIndex = 1 * contextMenuObj.getAttribute("targetcolIndex");
			
			//컬럼 인덱스가 0보다 큰 경우에만 정렬할 수 있음
			if( sheetColIndex >= 0 ){
				var sheet = controls[sheetName];
				var renderer = sheet.sheetRenderer;
				
				if( !renderer.sortOnHeader ){
					renderer = null; sheet = null; sheetName = null; contextMenuObj = null; //메모리 해제
					return;
				}
				
				var columns = sheet.columns;
				var colId = renderer.columnInfo[sheetColIndex].field;
				var headerRowInfo = null; var headerColInfo = null;
				var headerCells = null; var headerCell = null;
				var rowCount = 0; var colCount = 0;
				var i = 0; var j = 0;
				
				//아이콘을 제거하면서 각 컬럼의 정렬 정보를 초기화
				if( renderer.removeAllSortDirection() ){
					for(i = 0, colCount = columns.length; i < colCount; i++) columns[i].sortDirection = "";
				}
				
				//시트의 데이터 내림차순 정렬이 정상적으로 완료되었다면 헤더 컬럼에 내림차순 정렬 아이콘 추가
				if( sheet.sortTable(colId, false) ){
					rowCount = renderer.headerInfo.length;
					colCount = renderer.colsPerRow;
					
					for(i = rowCount - renderer.rowsPerDataRow; i < rowCount; i++, headerRowInfo = null){
						headerRowInfo = renderer.headerInfo[i];
						for(j = 0; j < colCount; j++, headerColInfo = null){
							headerColInfo = headerRowInfo[j];
							if( headerColInfo.colspan < 0 ) continue;
							if( headerColInfo.cellIndex == sheetColIndex ){
								headerCells = headerColInfo.cells;
								headerCellObj = ("leftfix" in headerCells ? headerCells.leftfix : ("rightfix" in headerCells ? headerCells.rightfix : headerCells.header));
								headerCells = null; headerColInfo = null; headerRowInfo = null;
								break;
							}
						}
						if( headerCellObj != null ) break;
					}
					
					if( headerCellObj != null ){
						renderer.displaySortDirection(headerCellObj, false);
						headerCellObj = null;
					}
				}
				
				//메모리 해제
				colId = null; columns = null; renderer = null; sheet = null;
			}
			
			//메모리 해제
			sheetName = null; contextMenuObj = null;
		});
		contextMenuItem = null;
		
		//메뉴 클릭 이벤트 추가 - 검색
		contextMenuItem = contextMenuObj.querySelector("div.EasySheetMenuItem.SheetSearch");
		setEventHandler(contextMenuItem, "click", function(e){
			var contextMenuObj = this.parentElement;
			var sheetName = contextMenuObj.getAttribute("targetsheet");
			var sheetColIndex = 1 * contextMenuObj.getAttribute("targetcolIndex");
			var renderer = controls[sheetName].sheetRenderer;
			var colId = (sheetColIndex < 0) ? "" : renderer.columnInfo[sheetColIndex].field;
			
			//검색 박스 보이기
			renderer.showSearchBox(colId);
			
			//메모리 해제
			colId = null; renderer = null; sheetName = null; contextMenuObj = null;
		});
		contextMenuItem = null;
		
		//메뉴 클릭 이벤트 추가 - 필터
		contextMenuItem = contextMenuObj.querySelector("div.EasySheetMenuItem.SheetFilter");
		setEventHandler(contextMenuItem, "click", function(e){
			var contextMenuObj = this.parentElement;
			var sheetName = contextMenuObj.getAttribute("targetsheet");
			var sheetColIndex = 1 * contextMenuObj.getAttribute("targetcolIndex");
			var renderer = controls[sheetName].sheetRenderer;
			var colId = (sheetColIndex < 0) ? "" : renderer.columnInfo[sheetColIndex].field;
			
			//필터 박스 보이기
			renderer.showFilterBox(colId);
			
			//메모리 해제
			colId = null; renderer = null; sheetName = null; contextMenuObj = null;
		});
		contextMenuItem = null;
		
		//메모리 해제
		parentObj = null;
		contextMenuHtml = null;
	}
	
	//컨텍스트 메뉴를 호출한 시트 정보 설정
	contextMenuObj.setAttribute("targetsheet", this.controlName);
	
	var headerStartIndex = this.headerInfo.length - this.rowsPerDataRow;
	var headerRow = null; var headerCells = null;
	var headerCol = null;
	var rowCount = 0; var colCount = 0;
	var rowIndex = -1; var colIndex = -1;
	var i = 0; var j = 0;
	
	//헤더 셀 위치 탐색
	for(i = 0, rowCount = this.headerInfo.length; i < rowCount; i++, headerRow = null){
		headerRow = this.headerInfo[i];
		
		for(j = 0, colCount = headerRow.length; j < colCount; j++, headerCells = null){
			headerCells = headerRow[j].cells;
			
			if( headerCells == null ) continue;
			
			if( headerCells.leftfix === headerCellObj
				|| headerCells.rightfix === headerCellObj
				|| headerCells.header === headerCellObj
			){
				rowIndex = i;
				colIndex = j;
				headerCol = headerRow[j];
				headerCells = null;
				headerRow = null;
				break;
			}
		}
		
		if( headerCol != null ) break;
	}
	
	if( headerCol == null ){
		contextMenuObj.style.display = "none";
		//메모리 해제
		headerCol = null;
		contextMenuObj = null;
	}
	
	var menuList = ["SheetSortAsc", "SheetSortDesc", "SheetFilter"]; //오름차순, 내림차순, 필터
	var menuCount = menuList.length;
	var classList = null;
	var classIndex = -1;
	
	//오름차순, 내림차순, 필터 메뉴 활성화/비활성화 설정
	if( headerStartIndex > rowIndex ){
		//메뉴 비활성화
		for(i = 0; i < menuCount; i++){
			contextMenuItem = contextMenuObj.querySelector("div.EasySheetMenuItem." + menuList[i]);
			
			//Disabled 클래스 추가
			classList = contextMenuItem.className.split(" ");
			if( classList.indexOf("Disabled") < 0 ){
				classList.push("Disabled");
				contextMenuItem.className = classList.join(" ");
			}
			
			//메모리 해제
			classList = null;
			contextMenuItem = null;
		}
		
		//타겟 컬럼 인덱스 설정
		contextMenuObj.setAttribute("targetcolIndex", -1);
	}
	else{
		var menuName = null;
		
		//메뉴 활성화
		for(i = 0; i < menuCount; i++){
			menuName = menuList[i];
			contextMenuItem = contextMenuObj.querySelector("div.EasySheetMenuItem." + menuName);
			
			classList = contextMenuItem.className.split(" ");
			classIndex = classList.indexOf("Disabled");
			
			//소트 메뉴의 경우 선택정렬 속성이  false라면, 소트 메뉴 비활성화 
			if( !this.sortOnHeader && (menuName == "SheetSortAsc" || menuName == "SheetSortDesc") ){
				if( classIndex < 0 ){
					classList.push("Disabled");
					contextMenuItem.className = classList.join(" ");
				}
			}
			//Disabled 클래스 제거
			else{
				if( classIndex >= 0 ){
					classList[classIndex] = "";
					contextMenuItem.className = classList.join(" ").replace(/(^\s*)|(\s*$)/g, "");
				}
			}
			
			//메모리 해제
			classList = null;
			contextMenuItem = null;
			menuName = null;
		}
		
		//타겟 컬럼 인덱스 설정
		contextMenuObj.setAttribute("targetcolIndex", headerCol.cellIndex);
	}
	
	//컨텍스트 메뉴를 마우스 클릭 위치에 표시
	contextMenuObj.style.display = "block";
	contextMenuObj.style.left = positionX + "px";
	contextMenuObj.style.top = positionY + "px";
	
	//메모리 해제
	menuList = null;
	headerCol = null;
	contextMenuObj = null;
};

EasySheetRenderer.prototype.showSearchBox = function(searchColId){
	var parentObj = null;
	var searchBoxObj = null;
	var searchBoxHtml = null;
	var selectBoxHtml = null;
	var sheetCssStyle = null;
	
	//검색 박스 객체를 찾음
	searchBoxObj = document.querySelector("div.EasySheetSearch");
	
	//검색 박스 객체가 없다면
	if( searchBoxObj == null ){
		//검색 박스 생성
		searchBoxHtml = "\r\n\t<div class=\"searchColum\"><div><select></select></div></div>"
					  + "\r\n\t<input type=\"text\" class=\"searchText\"/>"
					  + "\r\n\t<div class=\"searchButtons\">"
					  + "\r\n\t\t<div class=\"button search\"><div>&#xe96b;</div></div>"
					  + "\r\n\t\t<div class=\"button close\"><div>&#xebb1;</div></div>"
					  + "\r\n\t</div>";
		searchBoxObj = document.createElement("div");
		searchBoxObj.setAttribute("class", "EasySheetSearch");
		searchBoxObj.innerHTML = searchBoxHtml;
		
		//화면에 추가
		parentObj = this.SheetObject;
		parentObj = (parentObj == null) ? document.body : parentObj;
		parentObj.appendChild(searchBoxObj);
		
		//닫기 버튼 클릭 이벤트 추가
		setEventHandler(document.querySelector("div.EasySheetSearch > div.searchButtons > div.button.close"), "click", function(e){
			var searchBoxObj = document.querySelector("div.EasySheetSearch");
			
			//컨텍스트 메뉴가 추가되어 있다면 숨김
			if( searchBoxObj != null && searchBoxObj.style.display != "none" ){
				searchBoxObj.style.display = "none";
				searchBoxObj.setAttribute("targetSheet", "");
				searchBoxObj.setAttribute("lastFoundRow", "-1");
			}
			
			//메모리 해제
			searchBoxObj = null;
		});
		
		//찾기/검색 버튼 클릭 이벤트 추가
		setEventHandler(document.querySelector("div.EasySheetSearch > div.searchButtons > div.button.search"), "click", function(e){
			var searchBoxObj = document.querySelector("div.EasySheetSearch");
			var targetSheet = searchBoxObj.getAttribute("targetSheet");
			var lastFoundRow = 1 * searchBoxObj.getAttribute("lastFoundRow");
			var searchColId = document.querySelector("div.EasySheetSearch > div.searchColum select").value;
			var findText = document.querySelector("div.EasySheetSearch > input.searchText[type='text']").value;
			var sheet = null;
			
			//타겟 시트가 있다면 시트에서 검색
			if( typeof targetSheet == "string" && targetSheet.length > 0 ){
				sheet = controls[targetSheet];
				
				//마지막 검색한 행이 0보다 작은 경우 현재 행부터 검색함
				lastFoundRow = (lastFoundRow < 0) ? sheet.currentRow : lastFoundRow + 1;
				//검색
				searchRow = sheet.searchText(findText, searchColId, lastFoundRow);
				
				//찾지 못한 경우 첫 행부터 다시 검색
				if( searchRow < 0 ){
					searchRow = sheet.searchText(findText, searchColId, sheet.startRowColNum);
				}
				
				//검색 결과가 있다면 해당 행으로 이동
				if( searchRow >= 0 ){
					sheet.moveTo(searchRow, sheet.getColNum(searchColId));
					searchBoxObj.setAttribute("lastFoundRow", "" + searchRow);
				}
			}
			
			//메모리 해제
			sheet = null; findText = null; searchColId = null; lastFoundRow = null; targetSheet = null; searchBoxObj = null;
		});
		
		setEventHandler(document.querySelector("div.EasySheetSearch > input.searchText[type='text']"), "keydown", function(e){
			if( !e ) e = window.event;
			
			var keyCode = (e.which) ? e.which : e.keyCode;
			
			//F5새로고침 방지 추가
			if( keyCode == 116 ){
				if( typeof e.preventDefault == "function" ){
					e.preventDefault();
				}
				else{
					e.returnValue = false; // for IE
				}
				return false;
			}
			
			if( keyCode == 13 ){
				document.querySelector("div.EasySheetSearch > div.searchButtons > div.button.search").click();
			}
			
			stopPropagation(e);
			
			return true;
		});
		
		//메모리 해제
		parentObj = null;
		searchBoxHtml = null;
	}
	
	//컨텍스트 메뉴를 호출한 시트 정보 설정
	searchBoxObj.setAttribute("targetSheet", this.controlName);
	searchBoxObj.setAttribute("lastFoundRow", "-1");
	
	//컨텍스트 메뉴를 마우스 클릭 위치에 표시
	searchBoxObj.style.display = "block";
	searchBoxObj.querySelector("div.searchColum").style.width = "120px";
	searchBoxObj.querySelector("input.searchText").style.width = "calc(100% - 190px)";
	
	//시트 헤더 컬럼 리스트 생성
	for(var i = 0, selectBoxHtml = ""; i < this.columnInfo.length; i++){
		selectBoxHtml += "\r\n\t\t<option value=\"" + this.columnInfo[i].field + "\">" + this.columnInfo[i].title + "</option>";
	}
	searchBoxObj.querySelector("div.searchColum select").innerHTML = selectBoxHtml;
	searchBoxObj.querySelector("div.searchColum select").value = searchColId;
	
	//메모리 해제
	selectBoxHtml = null;
	searchBoxObj = null;
};

EasySheetRenderer.prototype.showFilterBox = function(filterColId){
	if( filterColId === "" ) return false;
	
	var parentObj = null;
	var filterBoxObj = null;
	var filterBoxHtml = null;
	
	//필터 박스 객체를 찾음
	filterBoxObj = document.querySelector("div.EasySheetFilter");
	
	//필터 박스 객체가 없다면
	if( filterBoxObj == null ){
		//필터 박스 생성
		filterBoxHtml = "\r\n\t<div class=\"EasySheetMenuItem Title\"><span></span></div>"
					  + "\r\n\t<div class=\"EasySheetMenuSeparator\"></div>"
					  + "\r\n\t<div class=\"EasySheetMenuItem Initialize\"><span>" + getText("message_easysheetrender_905", "필터 초기화") + "</span></div>"
					  + "\r\n\t<div class=\"EasySheetMenuSeparator\"></div>"
					  + "\r\n\t<div class=\"EasySheetMenuItem Select\">"
					  + "\r\n\t\t<div class=\"FilterItemList\">"
					  + "\r\n\t\t</div>"
					  + "\r\n\t</div>"
					  + "\r\n\t<div class=\"EasySheetMenuSeparator\"></div>"
					  + "\r\n\t<div class=\"EasySheetMenuItem Buttons\">"
					  + "\r\n\t\t<div class=\"Button Cancel\"><span>&#xe978;</span></div>"
					  + "\r\n\t\t<div class=\"Button Apply\"><span>&#xe976;</span></div>"
					  + "\r\n\t</div>";
		filterBoxObj = document.createElement("div");
		filterBoxObj.setAttribute("class", "EasySheetFilter");
		filterBoxObj.innerHTML = filterBoxHtml;
		
		//화면에 추가
		parentObj = document.querySelector("div.contents");
		parentObj = (parentObj == null) ? document.body : parentObj;
		parentObj.appendChild(filterBoxObj);
		
		//필터 초기화 클릭시 이벤트 추가
		setEventHandler(document.querySelector("div.EasySheetFilter > div.EasySheetMenuItem.Initialize"), "click", function(e){
			var filterBoxObj = document.querySelector("div.EasySheetFilter");
			var sheet = controls[filterBoxObj.getAttribute("targetSheet")];
			var colId = filterBoxObj.getAttribute("targetColumn");
			
			//시트 필터 적용
			sheet.unfilter({"colId": colId});
			//필터 박스 닫음
			filterBoxObj.querySelector("div.EasySheetMenuItem.Buttons > div.Button.Cancel").click();
			
			//메모리 해제
			colId = null; sheet = null; filterBoxObj = null;
		});
		
		//필터 항목 클릭시 이벤트 추가
		setEventHandler(filterBoxObj.querySelector("div.EasySheetMenuItem.Select > div.FilterItemList"), "mouseup", function(e){
			if( !e ) e = window.event;
			
			var em = getSrcElement(e);
			while( em.className.indexOf("FilterItem") < 0 ) em = em.parentNode;
			
			var selected = em.getAttribute("selected");
			var checkAllObj = document.querySelector("div.EasySheetFilter div.FilterItem.All");
			var filterItemObjs = null;
			
			//'(전체선택)'항목 클릭한 경우, 선택되지 않은 모든 항목을 선택 처리함
			if( checkAllObj === em ){
				var filterItemObj = null;
				var selectVal = (selected == "false") ? "true" : "false";
				var checkIcon = (selectVal == "true") ? "&#xe8f8;" : "&#xe8f9;";
				
				//선택되지 않은 항목을 가져옴
				filterItemObjs = document.querySelectorAll("div.EasySheetFilter div.FilterItem[selected='" + selected + "']");
				//선택되지 않은 항목을 선택 처리함
				for(i = 0; i < filterItemObjs.length; i++, filterItemObj = null){
					filterItemObj = filterItemObjs[i];
					filterItemObj.setAttribute("selected", selectVal);
					filterItemObj.querySelector("div.ItemCheck").innerHTML = checkIcon;
				}
				//메모리 해제
				filterItemObjs = null;
			}
			//선택된 항목을 클릭한 경우, 클릭한 항목을 선택안함 처리하고 '(전체선택)'항목을 선택안함 처리함
			else if( selected === "true" ){
				//클릭한 항목 선택안함
				em.setAttribute("selected", "false");
				em.querySelector("div.ItemCheck").innerHTML = "&#xe8f9;";
				
				//'(전체선택)'항목 선택 안함
				checkAllObj.setAttribute("selected", "false");
				checkAllObj.querySelector("div.ItemCheck").innerHTML = "&#xe8f9;";
			}
			//선택되지 않은 항목을 클릭한 경우, 클릭한 항목을 선택 처리하고 클릭한 항목을 포함한 모든 항목이 선택되었다면 '(전체선택)'항목을 선택처리 함
			else{
				//클릭한 항목 선택
				em.setAttribute("selected", "true");
				em.querySelector("div.ItemCheck").innerHTML = "&#xe8f8;";
				
				//선택되지 않은 항목을 가져옴
				filterItemObjs = document.querySelectorAll("div.EasySheetFilter div.FilterItem[selected='false']");
				//선택되지 않은 항목이 1개이고, 그 항목이 '(전체선택)'항목인 경우 선택처리 함
				if( filterItemObjs != null && filterItemObjs.length == 1 ){
					if(filterItemObjs[0] == checkAllObj ){
						checkAllObj.setAttribute("selected", "true");
						checkAllObj.querySelector("div.ItemCheck").innerHTML = "&#xe8f8;";
					}
				}
				//메모리 해제
				filterItemObjs = null;
			}
			
			//메모리 해제
			checkAllObj = null; selected = null; em = null;
		});
		
		//적용 버튼 클릭 이벤트 추가
		setEventHandler(filterBoxObj.querySelector("div.EasySheetMenuItem.Buttons > div.Button.Apply"), "click", function(e){
			var filterBoxObj = document.querySelector("div.EasySheetFilter");
			var sheet = controls[filterBoxObj.getAttribute("targetSheet")];
			var renderer = sheet.sheetRenderer;
			var colId = filterBoxObj.getAttribute("targetColumn");
			var i = 0; var j = 0;
			
			//필터링할 컬럼 속성
			var columnIndex = renderer.columnIndexMapByField[colId];
			var columnInfo = renderer.columnInfo[columnIndex];
			var isString = (columnInfo.fieldType == "string");
			//메모리 해제
			columnInfo = null;
			
			//컬럼 셀 위치 탐색
			var headerRowItem = null; var headerColItem = null;
			var headerCells = null; var headerCellObj = null;
			var headerRowCount = renderer.headerInfo.length;
			var headerColCount = renderer.colsPerRow;
			var headerStartIndex = headerRowCount - renderer.rowsPerDataRow;
			var headerCellIndex = 0;
			//컬럼의 셀 객체를 찾아  필터 아이콘을 표시함
			for(i = headerStartIndex; i < headerRowCount; i++, headerRowItem = null){
				headerRowItem = renderer.headerInfo[i];
				
				//셀 탐색
				for(j = 0; j < headerColCount; j++, headerColItem = null, headerCells = null){
					headerColItem = headerRowItem[j];
					headerCells = headerColItem.cells;
					//colspan이 -1인 경우, 병합된 셀이므로 넘어감
					if( headerColItem.colspan < 0 ) continue;
					//컬럼 인덱스와 셀 인덱스가  같은 경우
					if( headerColItem.cellIndex == columnIndex ){
						headerCellObj = ("leftfix" in headerCells ? headerCells.leftfix : ("rightfix" in headerCells ? headerCells.rightfix : headerCells.header));
						break;
					}
				}
				
				//컬럼의 셀 객체를 찾을 경우
				if( headerCellObj != null ){
					//메모리 해제
					headerCells = null; headerColItem = null; headerRowItem = null;
					break;
				}
			}
			
			//필터 산식 생성
			var selectedItems = filterBoxObj.querySelectorAll("div.FilterItem[selected='true']");
			var selectedItem = null;
			var selectedCount = selectedItems.length;
			var filterFormula = [];
			//선택된 필터 항목 중 첫번째 항목이 '(전체선택)'인 경우 시작 인덱스틑 0이 아닌 1로 설정
			selectedItem = selectedItems[0];
			i = (selectedItem.className.indexOf("All") < 0 ? 0 : 1);
			//필터 산식 추가
			for(j = 0, electedItem = null; i < selectedCount; i++, j++, selectedItem = null){
				selectedItem = selectedItems[i];
				filterFormula[j] = colId + "=="
								 + (isString ? "'" : "")
								 + selectedItem.querySelector("div.ItemName").innerText.replace(/\'/g, "\\\'")
								 + (isString ? "'" : "");
			}
			
			//
			if( filterFormula.length > 0 ){
				//시트 필터 적용
				sheet.filter({"colId": colId, "formula": filterFormula.join(" || ")});
				//필터 아이콘 추가
				if( headerCellObj != null ) renderer.displayFilterIcon(headerCellObj, colId);
			}
			
			//필터 박스 닫음
			filterBoxObj.querySelector("div.EasySheetMenuItem.Buttons > div.Button.Cancel").click();
			
			//메모리 해제
			filterFormula.clear(); filterFormula = null; headerCellObj = null; selectedItems = null;
			colId = null; renderer = null; sheet = null; filterBoxObj = null;
		});
		
		//닫기 버튼 클릭 이벤트 추가
		setEventHandler(filterBoxObj.querySelector("div.EasySheetMenuItem.Buttons > div.Button.Cancel"), "click", function(e){
			var filterBoxObj = document.querySelector("div.EasySheetFilter");
			
			//필터 박스가 추가되어 있다면 숨김
			if( filterBoxObj != null && filterBoxObj.style.display != "none" ){
				filterBoxObj.style.display = "none";
			}
			
			//메모리 해제
			filterBoxObj = null;
		});
		
		//메모리 해제
		parentObj = null;
		filterBoxHtml = null;
	}
	
	//필터 박스 호출한 시트 컨트롤 설정
	filterBoxObj.setAttribute("targetSheet", this.controlName);
	filterBoxObj.setAttribute("targetColumn", filterColId);
	
	//컬럼 타이틀 속성 
	var colIndex = this.columnIndexMapByField[filterColId];
	var colTitle = this.columnInfo[colIndex].title;
	//필터 타이틀 설정
	filterBoxObj.querySelector("div.EasySheetMenuItem.Title > span").innerText = colTitle;
	//메모리 해제
	colTitle = null;
	
	//필터 항목 추가
	var datas = (typeof this.dataSet.originData != "undefined") ? this.dataSet.originData : this.dataSet.data;
	var dataCount = 0;
	var i = 0; var j = 0;
	
	if( datas != null && (dataCount = datas.length) > 0 ){
		var filterItemList = document.querySelector("div.EasySheetMenuItem.Select > div.FilterItemList");
		var uniqItems = [];
		var filterItems = [];
		var record = null; var value = null; var filtered = false;
		var isAllChecked = false; var checkedCnt = 0;
		
		//중복데이터를 제외한 필터 항목 생성
		for(i = 0; i < dataCount; i++, record = null, value = null){
			record = datas[i];
			value = record[filterColId];
			filtered = record.__STATE__.filterd;
			
			//데이터가 undefined 인 경우, 필터 항목에서 제외함
			if( typeof value == "undefined" ) continue;
			//중복데이터인 경우, 넘어감
			if( uniqItems.indexOf(value) >= 0 ) continue;
			
			//중복데이터가 아닌 경우, 중복데이터 체크 배열에 항목 추가 
			uniqItems.push(value);
			//중복데이터가 아닌 경우, 필터 목록 배열에 필터 항목 태그 추가
			filterItems.push(
				  "<div class=\"FilterItem\" selected=\"" + (filtered ? "false" : "true") + "\">"
				+ " <div class=\"ItemCheck\">" + (filtered ? "&#xe8f9;" : "&#xe8f8;") + "</div>"
				+ " <div class=\"ItemName\">" + value + "</div>"
				+ "</div>"
			);
			//모든 항목이 체크되었는지 확인하기 위해 체크된 경우, 증가
			if( !filtered ) checkedCnt++;
		}
		//모든 항목 체크 여부
		isAllChecked = (filterItems.length == checkedCnt);
		
		//필터 항목 설정
		filterItemList.innerHTML = "<div class=\"FilterItem All\" selected=\"" + (isAllChecked ? "true" : "false") + "\"> "
								 + "<div class=\"ItemCheck\">" + (isAllChecked ? "&#xe8f8;" : "&#xe8f9;") + "</div>"
								 + "<div class=\"ItemName\">" + getText("message_easysheetrender_906", "(전체선택)") + "</div> </div>"
								 + ((filterItems.length > 0) ? filterItems.join(" ") : "");
		//메모리 해제
		filterItems.clear(); filterItems = null;
		uniqItems.clear(); uniqItems = null;
		filterItemList = null;
	}
	//메모리 해제
	datas = null;
	
	//시트 디자인 속성
	var cssStyleObj = getComputedStyle(this.SheetObject);
	var sheetTop = 1 * cssStyleObj.top.replace("px", "");
	var sheetLeft = 1 * cssStyleObj.left.replace("px", "");
	var sheetHeight = 1 * cssStyleObj.height.replace("px", "");
	cssStyleObj = null;
	
	//필터 위치 계산
	var headerRowItem = null; var headerColItem = null;
	var headerRowCount = this.headerInfo.length;
	var headerColCount = this.colsPerRow;
	var headerStartIndex = headerRowCount - this.rowsPerDataRow;
	var rowIndex = headerRowCount - 1;
	var cellIndex = -1;
	var rightFixIndex = 0;
	var filterLeft = 0;
	
	for(i = headerStartIndex; i < headerRowCount; i++, headerRowItem = null){
		headerRowItem = this.headerInfo[i];
		
		//셀 탐색
		for(j = 0; j < headerColCount; j++, headerColItem = null){
			headerColItem = headerRowItem[j];
			//colspan이 -1인 경우, 병합된 셀이므로 넘어감
			if( headerColItem.colspan < 0 ) continue;
			//컬럼 인덱스와 셀 인덱스가  같은 경우
			if( headerColItem.cellIndex == colIndex ){
				rowIndex = i + headerColItem.rowspan;
				cellIndex = j;
				break;
			}
		}
		
		//컬럼의 셀 인덱스가 0보다 크다면 컬럼의 셀 위치를 잦음
		if( cellIndex >= 0 ){
			//_columnWidths 속성이 있다면 필터 좌측 위치 계산
			if( this._columnWidths != null && typeof this._columnWidths != "undefined" ){
				rightFixIndex = this.colsPerRow - this.rightFixColumnCount;
				//컬럼 너비 합
				for(i = (rightFixIndex <= cellIndex ? rightFixIndex : 0); i < cellIndex; i++){
					filterLeft += this._columnWidths[i];
				}
				//우측고정열인 경우, 우측고정열 좌측 위치만큼 더하고 행 타이틀 너비만큼 빼야함
				if( rightFixIndex <= cellIndex  ){
					cssStyleObj = getComputedStyle(this.SheetHeaderRightFixObject);
					filterLeft += ((1 * cssStyleObj.left.replace("px", "")) - this.sheetRowHeaderWidth + 1);
					cssStyleObj = null;
				}
				//좌측고정열이 아닌 경우 스크롤이 이동되었다면, 이동 거리만큼 빼야함
				else{
					if( this.leftFixColumnCount <= cellIndex ) filterLeft -= this.sheetHeaderTableLeft
				}
			}
			//메모리 해제
			headerColItem = null;headerRowItem = null;
			break;
		}
	}
	
	//시트 헤더 디자인 속성
	cssStyleObj = getComputedStyle(this.SheetHeaderObject.querySelector("div.SheetHeaderDiv tr"));
	var sheetHeaderHeight = rowIndex * cssStyleObj.height.replace("px", "");
	cssStyleObj = null;
	
	//필터 스타일 설정
	filterBoxObj.style.display = "block";
	filterBoxObj.style.position = "relative";
	filterBoxObj.style.top = (sheetTop + sheetHeaderHeight + 1) + "px";
	filterBoxObj.style.left = (sheetLeft + this.sheetRowHeaderWidth + filterLeft) + "px";
	filterBoxObj.style.width = "200px";
	filterBoxObj.style.maxHeight = (sheetHeight - sheetHeaderHeight) + "px";
	filterBoxObj.scrollTop = 0;
	
	//메모리 해제
	filterBoxObj = null;
};

EasySheetRenderer.prototype.filter = function(filterState, startRowColNum){
	//
	if( typeof startRowColNum != "number" )
		startRowColNum = 0;
	
	var records = [];
	var record = null;
	var key = null;
	var filtered = false;
	var maxRow = 0;
	var rowNum = 0;
	var rowNum0 = 0;
	var recordIndex = 0;
	var maxCol = this.columnInfo.length;
	var i = 0;
	
	//필터 설정되어 있는 컬럼을 제외한 나머지 컬럼 필터 아이콘 제거
	for(i = 0; i < maxCol; i++){
		if( !(this.columnInfo[i].field in filterState) )
			this.removeFilterIcon(this.columnInfo[i].field);
	}
	
	if( typeof this.dataSet.originData == "undefined" ){
		//원본 데이터는 originData에 보관
		this.dataSet.originData = [].concat(this.dataSet.data);
	}
	else{
		//필터 상태 초기화
		for(rowNum0 = 0, maxRow = this.dataSet.originData.length; rowNum0 < maxRow; rowNum0++)
			this.dataSet.originData[rowNum0].__STATE__.filterd = false;
		//데이터 초기화
		this.dataSet.data.clear();
		this.dataSet.data = [].concat(this.dataSet.originData);
	}
	
	for(rowNum0 = 0, recordIndex = 0, maxRow = this.dataSet.getCount(); rowNum0 < maxRow; rowNum0++, filtered = false){
		record = this.dataSet.data[rowNum0];
		rowNum = rowNum0 + startRowColNum;
		
		for(key in filterState){
			filtered = filtered || !filterState[key].func(controls[this.controlName], rowNum);
			
			if( filtered ) break;
			
			key = null;
		}
		
		//필터 상태 설정
		record.__STATE__["filterd"] = filtered;
		//필터에 걸러지지 않은 데이터 추가
		if( !filtered ) records[recordIndex++] = record;
		
		//메모리 해제
		key = null; record = null;
	}
	
	//data 배열을 비우고 필터에 걸러지지 않은 레코드만 있는 배열 설정
	this.dataSet.data.clear();
	this.dataSet.data = records;
	
	//필터시 시트에서 선택된 셀 정보 초기화
	this.selectedRowIndex = -1;
	this.selectedColumnIndex = -1;
	this.selectedObject = null;
	
	//화면 갱신
	this.update();
	
	//메모리 해제
	key = null; record = null; records = null;
};

EasySheetRenderer.prototype.unfilter = function(){
	var recordList = null;
	var recordObj = null;
	var recordIdx = 0;
	var maxRow = 0;
	var maxCol = 0;
	var i = 0;
	
	//필터 아이콘 제거
	for(maxCol = this.columnInfo.length, i = 0; i < maxCol; i++)
		this.removeFilterIcon(this.columnInfo[i].field);
	
	//필터 초기화 전 선택된 셀 객체를 기준으로 레코드 객체를 찾음
	if( this.selectedObject != null ){
		try{
			recordIdx = (1 * this.selectedObject.parentElement.getAttribute("recordIndex"));
			recordObj = (recordIdx >= 0 && recordIdx < this.dataSet.data.length) ? this.dataSet.data[recordIdx] : null;
		}
		catch(e){ recordObj = null; }
	}
	
	if( typeof this.dataSet.originData != "undefined" ){
		//모든 레코드를 필터 해제함
		for(maxRow = this.dataSet.originData.length, i = 0; i < maxRow; i++)
			this.dataSet.originData[i].__STATE__.filterd = false;
		
		//data 배열을 비우고 originData 데이터로 복구
		this.dataSet.data.clear();
		this.dataSet.data = [].concat(this.dataSet.originData);
		//필터 해제하였으므로 originData를 비우고 데이터셋에서 제거함
		this.dataSet.originData.clear();
		delete this.dataSet.originData;
	}
	
	//필터 초기화 전 선택된 셀 객체를 기준으로 찾은 레코드 객체의 인덱스를 찾아 렌터러의 속성들을 갱신함
	if( recordObj != null ){
		for(recordList = this.dataSet.data, maxRow = recordList.length, i = 0; i < maxRow; i++){
			if( recordList[i] === recordObj ){
				//선택된 행 인덱스 갱신
				this.selectedRowIndex = i;
				//선택된 셀 객체 갱신
				this.selectedObject = this.getCellObject(this.selectedRowIndex, this.selectedColumnIndex);
				break;
			}
		}
		
		//메모리 해제
		recordObj = null; recordList = null;
	}
	
	//화면 갱신
	this.update();
};









/*
 *  수평스크롤 이동 및 이벤트 관련 처리 (시작)
 */
//-수평스크롤 이동 처리
function moveSheetHScroll(){
	var scrollInfo = self["_SheetScrollMovingInfo"];
	if( scrollInfo == null && typeof scrollInfo == "undefined" ){
		scrollInfo = null; return;
	}
	
	var sheet = scrollInfo.sheet.sheetRenderer;
	var hScrollDirection = scrollInfo.hScrollDirection;
	
	//시트 객체 설정
	var sheetHScrollFaceObject = sheet.SheetHScrollObject.querySelector("div.SheetHScrollTrack > div.SheetHScrollFace");
	var sheetHeaderTableObject = sheet.SheetHeaderObject.querySelector("div.SheetHeaderDiv > table");
	var sheetContentTableObject = sheet.SheetContentObject.querySelector("div.SheetContentDiv > table");
	var sheetFooterTableObject = null;
	if( sheet.isShowFooter ){
		sheetFooterTableObject = sheet.SheetFooterObject.querySelector("div.SheetFooterDiv > table");
	}
	
	//수평스크롤 이동
	sheet.hScrollFaceLeft = sheet.hScrollFaceLeft + hScrollDirection;
	//-우방향 최대이동 처리
	if( hScrollDirection > 0 && sheet.hScrollTrackWidth < sheet.hScrollFaceWidth + sheet.hScrollFaceLeft ){
		sheet.hScrollFaceLeft = sheet.hScrollTrackWidth - sheet.hScrollFaceWidth;
	}
	//-좌방향 최대이동 처리
	else if( hScrollDirection < 0 && sheet.hScrollFaceLeft < 0 ){
		sheet.hScrollFaceLeft = 0;
	}
	sheetHScrollFaceObject.style.left = sheet.hScrollFaceLeft + "px";
	
	//헤더 테이블 이동
	sheet.sheetHeaderTableLeft = sheet.sheetHeaderTableLeft + (sheet.tableMovePerHScrollFaceMove * hScrollDirection);
	//-우방향 최대이동 처리
	if( hScrollDirection > 0 && sheet.sheetHeaderTableWidth < sheet.sheetHeaderDivWidth + sheet.sheetHeaderTableLeft ){
		sheet.sheetHeaderTableLeft = sheet.sheetHeaderTableWidth - sheet.sheetHeaderDivWidth - 1;
	}
	//-좌방향 최대이동 처리
	else if( hScrollDirection < 0 && sheet.sheetHeaderTableLeft < 0 ){
		sheet.sheetHeaderTableLeft = 0;
	}
	sheetHeaderTableObject.style.marginLeft = (-1 * sheet.sheetHeaderTableLeft) + "px";
	
	//데이터 테이블 이동
	sheet.sheetContentTableLeft = sheet.sheetContentTableLeft + (sheet.tableMovePerHScrollFaceMove * hScrollDirection);
	//-우방향 최대이동 처리
	if( hScrollDirection > 0 && sheet.sheetHeaderTableWidth < sheet.sheetContentDivWidth + sheet.sheetContentTableLeft ){
		sheet.sheetContentTableLeft = sheet.sheetHeaderTableWidth - sheet.sheetContentDivWidth - 1;
	}
	//-좌방향 최대이동 처리
	else if( hScrollDirection < 0 && sheet.sheetContentTableLeft < 0 ){
		sheet.sheetContentTableLeft = 0;
	}
	sheetContentTableObject.style.marginLeft = (-1 * sheet.sheetContentTableLeft) + "px";
	
    //푸터 테이블 이동
	if( sheet.isShowFooter ){
		sheetFooterTableObject.style.marginLeft = (-1 * sheet.sheetContentTableLeft) + "px";
	}
	
	//메모리 초기화
	sheetContentTableObject = null;
	sheetHeaderTableObject = null;
	sheetHScrollFaceObject = null;
	sheet = null; scrollInfo = null;
}

//-수평스크롤 좌방향 버튼 클릭(마우스다운) 이벤트 함수
function sheetHScrollLeftArrowDown(e){
	if( !e ) e = window.event;
	
	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
	
	var sheet = null;
	var sheetRenderer = null;
	
	if( em.getAttribute("class") == "EasyDataSheet" ){
		//시트 컨트롤을 찾음
		sheet = controls["" + em.getAttribute("ctlname")];
		if( sheet == null || typeof sheet == "undefined" ){
			sheet = null; em = null;
			return false;
		}
		//시트 렌더러를 찾음
		sheetRenderer = sheet.sheetRenderer;
		if( sheetRenderer == null || typeof sheetRenderer == "undefined" ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
		//시트의 수평 스크롤이 없는 경우
		if( !sheetRenderer.isShowHScroll ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
    }
	else{
		sheetRenderer = null; sheet = null; em = null;
		return false;
	}
	
	//수평스크롤 이동 정보 설정
	self["_SheetScrollMovingInfo"] = {"sheet" : sheet, "hScrollDirection" : -3}; //수평스크롤 방향(및 크기) 설정 : -3(좌로 3씩 이동)
	
	//수평스크롤 이동 타이머 초기화(종료)
	clearInterval(_SheetHScrollArrowDownTimer);
	_SheetHScrollArrowDownTimer = null;
	//수평스크롤 이동 타이머 시작 : 스크롤 이동
	_SheetHScrollArrowDownTimer = setInterval(moveSheetHScroll, 50);
	
	//메모리 해제
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
	
	return true;
}
//-수평스크롤 우방향 버튼 클릭(마우스다운) 이벤트 함수
function sheetHScrollRightArrowDown(e){
	if( !e ) e = window.event;
	
	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
	
	var sheet = null;
	var sheetRenderer = null;
	
	if( em.getAttribute("class") == "EasyDataSheet" ){
		//시트 컨트롤을 찾음
		sheet = controls["" + em.getAttribute("ctlname")];
		if( sheet == null || typeof sheet == "undefined" ){
			sheet = null; em = null;
			return false;
		}
		//시트 렌더러를 찾음
		sheetRenderer = sheet.sheetRenderer;
		if( sheetRenderer == null || typeof sheetRenderer == "undefined" ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
		//시트의 수평 스크롤이 없는 경우
		if( !sheetRenderer.isShowHScroll ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
	}
	else{
		sheetRenderer = null; sheet = null; em = null;
		return false;
	}
	
	//수평스크롤 이동 정보 설정
	self["_SheetScrollMovingInfo"] = {"sheet" : sheet, "hScrollDirection" : 3}; //수평스크롤 방향(및 크기) 설정 : +3(우로 3씩 이동)
	
	//수평스크롤 이동 타이머 초기화(종료)
	clearInterval(_SheetHScrollArrowDownTimer);
	_SheetHScrollArrowDownTimer = null;
	//수평스크롤 이동 타이머 시작 : 스크롤 이동
	_SheetHScrollArrowDownTimer = setInterval(moveSheetHScroll, 50);
	
	//메모리 해제
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
	
	return true;
};
//-수평스크롤 좌,우방향 마우스업 이벤트 함수
function sheetHScrollArrowUp(e){
	if( !e ) e = window.event;
	
	//수평스크롤 이동 종료
	if( _SheetHScrollArrowDownTimer != null ){
		//수평스크롤 이동 타이머 종료
		clearInterval(_SheetHScrollArrowDownTimer);
		//수평스크롤 이동 타이머 초기화
		_SheetHScrollArrowDownTimer = null;
		//수평스크롤 이동 정보 초기화
		var scrollInfo = self["_SheetScrollMovingInfo"];
		if( scrollInfo != null && typeof scrollInfo != "undefined" ){
			scrollInfo.hScrollDirection = 0;
			scrollInfo.sheet = null;
			scrollInfo = null;
		}
		self["_SheetScrollMovingInfo"] = null;
	}
	
	stopEvent(e);
	
	return true;
}
//-수평스크롤 Track 클릭 이벤트 함수
function sheetHScrollTrackClick(e){
	if( !e ) e = window.event;
	
	//수평스크롤 Track 을 클릭하지 않을 경우 처리하지 않음
	var em = getSrcElement(e);
	if( em.getAttribute("class") != "SheetHScrollTrack" ) { em = null; return false; }
	
	//시트 탐색
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
	
	var sheet = null;
	var sheetRenderer = null;
	
	if( em.getAttribute("class") == "EasyDataSheet" ){
		//시트 컨트롤을 찾음
		sheet = controls["" + em.getAttribute("ctlname")];
		if( sheet == null || typeof sheet == "undefined" ){
			sheet = null; em = null;
			return false;
		}
		//시트 렌더러를 찾음
		sheetRenderer = sheet.sheetRenderer;
		if( sheetRenderer == null || typeof sheetRenderer == "undefined" ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
		//시트의 수평 스크롤이 없는 경우
		if( !sheetRenderer.isShowHScroll ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
	}
	else{
		sheetRenderer = null; sheet = null; em = null;
		return false;
	}
	
	var hScrollFaceLeft = sheetRenderer.hScrollFaceLeft;
	var hScrollDirection = (hScrollFaceLeft < e.offsetX) ? sheetRenderer.hScrollFaceWidth : sheetRenderer.hScrollFaceWidth * -1;
	
	//수평스크롤 이동 정보 설정
	var scrollInfo = self["_SheetScrollMovingInfo"] = {
			"sheet" : sheet
			, "hScrollDirection" : hScrollDirection /* 수평스크롤 방향(및 크기) 설정 : 스크롤 Face 크기만큼 좌측 클릭시 -, 우측 클릭시 + 이동 */
	};
	
	//수평스크롤 이동
	moveSheetHScroll();
	
	//수평스크롤 이동 정보 초기화
	if( scrollInfo != null && typeof scrollInfo != "undefined" ){
		scrollInfo.hScrollDirection = 0;
		scrollInfo.sheet = null;
		scrollInfo = null;
	}
	self["_SheetScrollMovingInfo"] = null;
	
	//메모리 해제
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
	
	return true;
};
//-수평스크롤 Face 클릭(마우스다운) 이벤트 함수
function sheetHScrollFaceMouseDown(e){
	if( !e ) e = window.event;
	
	//시트 탐색
	var em = getSrcElement(e);
	
	var sheet = null;
	var sheetRenderer = null;
	
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
	
	if( em.getAttribute("class") == "EasyDataSheet" ){
		//시트 컨트롤을 찾음
		sheet = controls["" + em.getAttribute("ctlname")];
		if( sheet == null || typeof sheet == "undefined" ){
			sheet = null; em = null;
			return false;
		}
		//시트 렌더러를 찾음
		sheetRenderer = sheet.sheetRenderer;
		if( sheetRenderer == null || typeof sheetRenderer == "undefined" ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
		//시트의 수평 스크롤이 없는 경우
		if( !sheetRenderer.isShowHScroll ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
	}
	else{
		sheetRenderer = null; sheet = null; em = null;
		return false;
	}
	
	//수평스크롤 이동 정보 설정
	var scrollInfo = self["_SheetScrollMovingInfo"] = {
			"sheet" : sheet
			, "hScrollDirection" : 0
			, "curPosX" : e.clientX	/* 마우스 클릭 위치 기억 */
			, "isDragging" : true	/* 스크롤 드래그 상태 설정 */
	};
	
	//메모리 해제
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
	
	return true;
}
//-수평스크롤 Face 드래그(클릭/마우스다운 후) 이벤트 함수
function sheetHScrollFaceMouseMove(e){
	if( !e ) e = window.event;
	
	var scrollInfo = self["_SheetScrollMovingInfo"];
	if( scrollInfo != null && typeof scrollInfo != "undefined" ){
		//스크롤 Face 드래그 상태인 경우에만 처리
		if( scrollInfo.isDragging === true ){
			//"마우스 이동 위치 - 마우스 클릭 위치" 를 계산하여 수평스크롤 방향(및 크기) 설정 
			scrollInfo.hScrollDirection = e.clientX - scrollInfo.curPosX;
			//수평스크롤 이동
			moveSheetHScroll();
			//스크롤 이동 후 현재 마우스 위치 기억(다음 마우스 이동시 현재를 기준으로 다시 스크롤 이동 거리 계산)
			scrollInfo.curPosX = e.clientX;
		}
		
		stopEvent(e);
	}
	scrollInfo = null;
	
	return true;
};
//-수평스크롤 Face 마우스업(드래그 후) 이벤트 함수
function sheetHScrollFaceMouseUp(e){
	if( !e ) e = window.event;
	
	var scrollInfo = self["_SheetScrollMovingInfo"];
	if( scrollInfo != null && typeof scrollInfo != "undefined" ){
		//스크롤 Face 드래그 상태인 경우에만 처리
		if( scrollInfo.isDragging === true ){
			scrollInfo.isDragging = false;
			scrollInfo.curPosX = 0;
		}
		
		//수평스크롤 이동 정보 초기화
		scrollInfo.hScrollDirection = 0;
		scrollInfo.sheet = null;
		scrollInfo = null;
		
		stopEvent(e);
	}
	self["_SheetScrollMovingInfo"] = null;
	
	return false;
}
/*
 *  수평스크롤 이동 및 이벤트 관련 처리 (끝)
 */



/*
 *  수직스크롤 이동 및 이벤트 관련 처리 (시작)
 */
//-수직스크롤 이동 처리
function moveSheetVScroll(){
	var scrollInfo = self["_SheetScrollMovingInfo"];
	if( scrollInfo == null && typeof scrollInfo == "undefined" ){
		scrollInfo = null; return;
	}
	
	var sheet = scrollInfo.sheet;
	var renderer = sheet.sheetRenderer;
	var vScrollDirection = scrollInfo.vScrollDirection;
	var oldShowedTopRowIndex = renderer.showedTopRowIndex; //스크롤 이동 전 시트 최상단 인덱스를 기록
	
	//수직스크롤 이동 체크
	//-위방향
	if( vScrollDirection < 0 && renderer.showedTopRowIndex + vScrollDirection <= 0 ){
		renderer.showedTopRowIndex = 1;
		vScrollDirection = -1;
	}
	//-아래방향
	if( vScrollDirection > 0 && 
	    (renderer.dataRowCount < renderer.showedTopRowIndex + (renderer.wholeShownRowCount + 1) + vScrollDirection
		|| renderer.dataRowCount < renderer.showedTopRowIndex + renderer.wholeShownRowCount + vScrollDirection) 
	){
		renderer.showedTopRowIndex = renderer.dataRowCount - (renderer.wholeShownRowCount + 1) + renderer.topFixRowCount
		vScrollDirection = 1;
	}
	
	//이동 방향에 따른 출력될 데이터의 첫번째 행 인덱스를 계산
	renderer.showedTopRowIndex = renderer.showedTopRowIndex + vScrollDirection;
	if( renderer.showedTopRowIndex < 0 || isNaN(renderer.showedTopRowIndex) ){
		renderer.showedTopRowIndex = 0;
	}
	
	//시트 최상단 인덱스가 변동이 없는 경우 더이상 진행하지 않음
	if( oldShowedTopRowIndex == renderer.showedTopRowIndex ){
		//메모리 해제
		renderer = null; sheet = null; scrollInfo = null;
		return;
	}
	
	//시트가 현재 편집중인 경우 편집중인 컨트롤 편집 종료
	if( renderer.isEditngSheet ){
		//수정 데이터 적용 및 이벤트 처리
		if( !renderer.setApplyChangedValueToCell(true) ){
			//메모리 해제
			renderer = null; sheet = null; scrollInfo = null;
			return false;
		}
		//편집중인 컨트롤 편집 종료
		renderer.isIgnoreEditingControlBlurEvent = true;
		renderer.removeSheetEditControl();
		//시트 메세지박스 숨김
		renderer.setSheetMsgBox(false);
	}
	
	//시트 데이터 출력
	renderer.update();
	
	//스크롤 이벤트 호출
	sheet._catchEvent({event: "scroll", oldTopIndex: oldShowedTopRowIndex, newTopIndex: renderer.showedTopRowIndex, lastIndex: renderer.dataRowCount - 1, pageSize: renderer.wholeShownRowCount + 1});
	
	//메모리 해제
	renderer = null;
	sheet = null;
	scrollInfo = null;
};

//-수직스크롤 위방향 버튼 클릭(마우스다운) 이벤트 함수
function sheetVScrollUpArrowDown(e){
	if( !e ) e = window.event;
	
	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
	
	var sheet = null;
	var sheetRenderer = null;
	
	if( em.getAttribute("class") == "EasyDataSheet" ){
		//시트 컨트롤을 찾음
		sheet = controls["" + em.getAttribute("ctlname")];
		if( sheet == null || typeof sheet == "undefined" ){
			sheet = null; em = null;
			return false;
		}
		//시트 렌더러를 찾음
		sheetRenderer = sheet.sheetRenderer;
		if( sheetRenderer == null || typeof sheetRenderer == "undefined" ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
		//시트의 수평 스크롤이 없는 경우
		if( !sheetRenderer.isShowVScroll ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
	}
	else{
		sheetRenderer = null; sheet = null; em = null;
		return false;
	}
	
	//수직스크롤 이동 정보 설정
	self["_SheetScrollMovingInfo"] = {"sheet" : sheet, "vScrollDirection" : -1}; //수직스크롤 방향(및 크기) 설정 : -1(위로 1행 이동)
	
	//수직스크롤 이동 타이머 초기화(종료)
	clearInterval(_SheetVScrollArrowDownTimer);
	_SheetVScrollArrowDownTimer = null;
	//수직스크롤 이동 타이머 시작 : 스크롤 이동
	_SheetVScrollArrowDownTimer = setInterval(moveSheetVScroll, 50);
	
	//메모리 해제
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
	
	return true;
}
//-수직스크롤 아래방향 버튼 클릭(마우스다운) 이벤트 함수
function sheetVScrollDownArrowDown(e){
	if( !e ) e = window.event;
	
	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
	
	var sheet = null;
	var sheetRenderer = null;
	
	if( em.getAttribute("class") == "EasyDataSheet" ){
		//시트 컨트롤을 찾음
		sheet = controls["" + em.getAttribute("ctlname")];
		if( sheet == null || typeof sheet == "undefined" ){
			sheet = null; em = null;
			return false;
		}
		//시트 렌더러를 찾음
		sheetRenderer = sheet.sheetRenderer;
		if( sheetRenderer == null || typeof sheetRenderer == "undefined" ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
		//시트의 수평 스크롤이 없는 경우
		if( !sheetRenderer.isShowVScroll ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
	}
	else{
		sheetRenderer = null; sheet = null; em = null;
		return false;
	}
	
	//수직스크롤 이동 정보 설정
	self["_SheetScrollMovingInfo"] = {"sheet" : sheet, "vScrollDirection" : 1}; //수직스크롤 방향(및 크기) 설정 : +1(아래로 1행 이동)
	
	//수직스크롤 이동 타이머 초기화(종료)
	clearInterval(_SheetVScrollArrowDownTimer);
	_SheetVScrollArrowDownTimer = null;
	//수직스크롤 이동 타이머 시작 : 스크롤 이동
	_SheetVScrollArrowDownTimer = setInterval(moveSheetVScroll, 50);
	
	//메모리 해제
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
	
	return true;
};
//-수직스크롤 위,아래방향 마우스업 이벤트 함수
function sheetVScrollArrowUp(e){
	if( !e ) e = window.event;
	
	//수직스크롤 이동 종료
	if( _SheetVScrollArrowDownTimer != null ){
		//수직스크롤 이동 타이머 종료
		clearInterval(_SheetVScrollArrowDownTimer);
		//수직스크롤 이동 타이머 초기화
		_SheetVScrollArrowDownTimer = null;
		//수직스크롤 이동 정보 초기화
		var scrollInfo = self["_SheetScrollMovingInfo"];
		if( scrollInfo != null && typeof scrollInfo != "undefined" ){
			scrollInfo.vScrollDirection = 0;
			scrollInfo.sheet = null;
			scrollInfo = null;
		}
		self["_SheetScrollMovingInfo"] = null;
	}
	
	stopEvent(e);
	
	return true;
}
//-수직스크롤 Track 클릭 이벤트 함수
function sheetVScrollTrackClick(e){
	if( !e ) e = window.event;
	
	//수직스크롤 Track 을 클릭하지 않을 경우 처리하지 않음
	var em = getSrcElement(e);
	if( em.getAttribute("class") != "SheetVScrollTrack" ) { em = null; return false; }
	
	//시트 탐색
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
	
	var sheet = null;
	var sheetRenderer = null;
	
	if( em.getAttribute("class") == "EasyDataSheet" ){
		//시트 컨트롤을 찾음
		sheet = controls["" + em.getAttribute("ctlname")];
		if( sheet == null || typeof sheet == "undefined" ){
			sheet = null; em = null;
			return false;
		}
		//시트 렌더러를 찾음
		sheetRenderer = sheet.sheetRenderer;
		if( sheetRenderer == null || typeof sheetRenderer == "undefined" ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
		//시트의 수평 스크롤이 없는 경우
		if( !sheetRenderer.isShowVScroll ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
	}
	else{
		sheetRenderer = null; sheet = null; em = null;
		return false;
	}
	
	var vScrollTop = sheetRenderer.vScrollFaceTop;
	var pageSize = sheetRenderer.wholeShownRowCount + 1;
	
	//수직스크롤 이동 정보 설정
	var scrollInfo = self["_SheetScrollMovingInfo"] = {
			"sheet" : sheet
			, "vScrollDirection" : (vScrollTop < e.offsetY) ? pageSize : pageSize * -1 /* 수직스크롤 방향(및 크기) 설정 : 페이지 크기만큼 위 클릭시 -, 아래 클릭시 + 이동 */
	};
	
	//스크롤 이동
	moveSheetVScroll();
	
	//수평스크롤 이동 정보 초기화
	if( scrollInfo != null && typeof scrollInfo != "undefined" ){
		scrollInfo.vScrollDirection = 0;
		scrollInfo.sheet = null;
		scrollInfo = null;
	}
	self["_SheetScrollMovingInfo"] = null;
	
	//메모리 해제
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
	
	return true;
};
//-수직스크롤 Face 클릭(마우스다운) 이벤트 함수
function sheetVScrollFaceMouseDown(e){
	if( !e ) e = window.event;
	
	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
	
	var sheet = null;
	var sheetRenderer = null;
	
	if( em.getAttribute("class") == "EasyDataSheet" ){
		//시트 컨트롤을 찾음
		sheet = controls["" + em.getAttribute("ctlname")];
		if( sheet == null || typeof sheet == "undefined" ){
			sheet = null; em = null;
			return false;
		}
		//시트 렌더러를 찾음
		sheetRenderer = sheet.sheetRenderer;
		if( sheetRenderer == null || typeof sheetRenderer == "undefined" ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
		//시트의 수평 스크롤이 없는 경우
		if( !sheetRenderer.isShowVScroll ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
	}
	else{
		sheetRenderer = null; sheet = null; em = null;
		return false;
	}
	
	//수직스크롤 이동 정보 설정
	var scrollInfo = self["_SheetScrollMovingInfo"] = {
			"sheet" : sheet
			, "vScrollDirection" : 0
			, "curPosY" : e.clientY	/* 마우스 클릭 위치 기억 */
			, "isDraging" : true	/* 스크롤 드래그 상태 설정 */
	};
	
	//메모리 해제
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
	
	return true;
}
//-수직스크롤 Face 드래그(클릭/마우스다운 후) 이벤트 함수
function sheetVScrollFaceMouseMove(e){
	if( !e ) e = window.event;
	
	var scrollInfo = self["_SheetScrollMovingInfo"];
	
	if( scrollInfo != null && typeof scrollInfo != "undefined" ){
		var sheet = scrollInfo.sheet;
		var renderer = sheet.sheetRenderer;
		var vScrollFace = null;
		var oldShowedTopRowIndex = renderer.showedTopRowIndex;
		var vScrollTrackMaxHeight = 0;
		var dataMaxRow = 0;
		var direction = 0;
		
		//스크롤 Face 드래그 상태인 경우에만 처리
		if( scrollInfo.isDraging === true ){
			//시트가 현재 편집중인 경우 편집중인 컨트롤 편집 종료
			if( renderer.isEditngSheet ){
				//수정 데이터 적용 및 이벤트 처리
				if( !renderer.setApplyChangedValueToCell(true) ){
					//메모리 해제
					scrollInfo = null; renderer = null; sheet = null;
					return false;
				}
				//편집중인 컨트롤 편집 종료
				renderer.isIgnoreEditingControlBlurEvent = true;
				renderer.removeSheetEditControl();
				//시트 메세지박스 숨김
				renderer.setSheetMsgBox(false);
			}
			
			//스크롤 이동 최대값 계산
			vScrollTrackMaxHeight = renderer.vScrollTrackHeight - renderer.vScrollFaceHeight;
			dataMaxRow = renderer.dataRowCount - renderer.wholeShownRowCount;
			
			//"마우스 이동 위치 - 마우스 클릭 위치" 를 계산하여 수직스크롤 방향(및 크기) 설정 
			direction = e.clientY - scrollInfo.curPosY;
			
			//스크롤 위치 설정
			renderer.vScrollFaceTop = renderer.vScrollFaceTop + direction;
			if( direction >= 0 ){
				renderer.showedTopRowIndex = Math.floor(dataMaxRow * (renderer.vScrollFaceTop / vScrollTrackMaxHeight));
			}
			else{
				renderer.showedTopRowIndex = Math.ceil(dataMaxRow * (renderer.vScrollFaceTop / vScrollTrackMaxHeight));
			}
			
			//화면에 출력될 데이터의 최상단 인덱스 최대/최소 예외처리
			if( renderer.showedTopRowIndex < 0 ){
				renderer.showedTopRowIndex = 0;
			}
			else if( renderer.showedTopRowIndex > renderer.dataRowCount - renderer.wholeShownRowCount ){
				renderer.showedTopRowIndex = renderer.dataRowCount - renderer.wholeShownRowCount;
			}
			//스크롤 위치 최대/최소값 예외처리
			if( renderer.vScrollFaceTop < 0 ){
				renderer.vScrollFaceTop = 0;
			}
			else if( renderer.vScrollFaceTop > vScrollTrackMaxHeight ){
				renderer.vScrollFaceTop = vScrollTrackMaxHeight;
			}
			
			//스크롤 위치가 변경된 경우에만 시트 갱신 및 이벤트 호출
			if( oldShowedTopRowIndex != renderer.showedTopRowIndex ){
				//시트 데이터 출력
				renderer.update();
				//스크롤 이벤트 호출
				sheet._catchEvent({event: "scroll", oldTopIndex: oldShowedTopRowIndex, newTopIndex: sheet.showedTopRowIndex, lastIndex: sheet.dataRowCount - 1, pageSize: sheet.wholeShownRowCount + 1});
			}
			else{
				vScrollFace = renderer.SheetVScrollObject.querySelector("div.SheetVScrollFace");
				vScrollFace.style.top = renderer.vScrollFaceTop + "px";
				vScrollFace = null;
			}
			
			//스크롤 이동 후 현재 마우스 위치 기억(다음 마우스 이동시 현재를 기준으로 다시 스크롤 이동 거리 계산)
			scrollInfo.curPosY = e.clientY;
		}
		
		stopEvent(e);
		
		//메모리 해제
		renderer = null;
		sheet = null;
	}
	
	//메모리 해제
	scrollInfo = null;
	
	return true;
};
//-수직스크롤 Face 마우스업(드래그 후) 이벤트 함수
function sheetVScrollFaceMouseUp(e){
	if( !e ) e = window.event;
	
	var scrollInfo = self["_SheetScrollMovingInfo"];
	
	if( scrollInfo != null && typeof scrollInfo != "undefined" ){
		//스크롤 Face 드래그 상태인 경우에만 처리
		if( scrollInfo.isDraging === true ){
			scrollInfo.isDraging = false;
			scrollInfo.curPosY = 0;
			scrollInfo.firstPosY = 0;
			scrollInfo.vScrollDirection = 0;
			scrollInfo.sheet = null;
			scrollInfo = null;
		}
		
		stopEvent(e);
	}
	
	self["_SheetScrollMovingInfo"] = null;
	
	return true;
}
//-수직스크롤 마우스 휠 이벤트 처리
function sheetVScrollMouseWheel(e){
	if( !e ) e = window.event;
	
	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
		
	var sheet = null;
	var sheetRenderer = null;
	
	if( em.getAttribute("class") == "EasyDataSheet" ){
		//시트 컨트롤을 찾음
		sheet = controls["" + em.getAttribute("ctlname")];
		if( sheet == null || typeof sheet == "undefined" ){
			sheet = null; em = null;
			return false;
		}
		//시트 렌더러를 찾음
		sheetRenderer = sheet.sheetRenderer;
		if( sheetRenderer == null || typeof sheetRenderer == "undefined" ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
		//시트의 수평 스크롤이 없는 경우
		if( !sheetRenderer.isShowVScroll ){
			sheetRenderer = null; sheet = null; em = null;
			return false;
		}
	}
	else{
		sheetRenderer = null; sheet = null; em = null;
		return false;
	}
	
	var scrollInfo = null;
	var vScrollDirection = 0;
	
	//휠 이동 방향 브라우저별 호환 체크
	if( typeof e.wheelDelta != "undefined" ){
		vScrollDirection = (e.wheelDelta > 0) ? (-1 * sheetRenderer.vScrollWheelMoveRows) : (1 * sheetRenderer.vScrollWheelMoveRows);
	}
	else if( typeof e.detail != "undefined" ){
		if( e.detail == 0 )
			vScrollDirection = e.deltaY > 0 ? (1 * sheetRenderer.vScrollWheelMoveRows) : (-1 * sheetRenderer.vScrollWheelMoveRows);
		else
			vScrollDirection = e.detail > 0 ? (1 * sheetRenderer.vScrollWheelMoveRows) : (-1 * sheetRenderer.vScrollWheelMoveRows);
	}
	
	//수직스크롤 이동 정보 설정
	scrollInfo = self["_SheetScrollMovingInfo"] = {
			"sheet" : sheet
			, "vScrollDirection" : vScrollDirection
	};
	
	//스크롤 이동
	moveSheetVScroll();
	
	//수평스크롤 이동 정보 초기화
	if( scrollInfo != null && typeof scrollInfo != "undefined" ){
		scrollInfo.vScrollDirection = 0;
		scrollInfo.sheet = null;
		scrollInfo = null;
	}
	self["_SheetScrollMovingInfo"] = null;
	
	//메모리 해제
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
	
	return true;
};
/*
 *  수직스크롤 이동 및 이벤트 관련 처리 (끝)
 */



/*
 *	컬럼 너비 리사이즈 이벤트 (시작)
 */
//-컬럼 리사이저 마우스 다운(컬럼 너비 조정 시작) 이벤트  처리
function sheetResizerMousedown(e){
	if( !e ) e = window.event;
	
	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
	
	var sheet = null;
	var sheetRenderer = null;
	
	if( em.getAttribute("class") == "EasyDataSheet" ){
		//시트 컨트롤을 찾음
		sheet = controls["" + em.getAttribute("ctlname")];
		if( sheet != null && typeof sheet == "undefined" ){
			sheet = null; em = null; return false;
		}
		//시트 렌더러를 찾음
		sheetRenderer = sheet.sheetRenderer;
		if( sheetRenderer != null && typeof sheetRenderer == "undefined" ){
			sheetRenderer = null; sheet = null; em = null; return false;
		}
	}
	
	//헤더 탐색(인덱스, 헤더 위치)
	var sheetResizerLine = sheetRenderer.SheetObject.querySelector("div.SheetResizerLine");
	var headerCell = this.parentElement;
	var headerRow = null;
	var headerCol = null;
	var isLeftFix = false;
	var rowCount = 0;
	var colCount = 0;
	var colIndex = -1;
	var i = 0; var j = 0;
	
	for(i = 0, rowCount = sheetRenderer.headerInfo.length; i < rowCount; i++, headerRow = null){
		headerRow = sheetRenderer.headerInfo[i];
		
		for(j = 0, colCount = headerRow.length; j < colCount; j++, headerCol = null){
			headerCol = headerRow[j].cells;
			
			if( headerCol == null ) continue;
			
			if( headerCol.leftfix === headerCell ){
				isLeftFix = true;
				colIndex = j;
				break;
			}
			else if( headerCol.header === headerCell || headerCol.rightfix === headerCell ){
				colIndex = j;
				break;
			}
	    }
		
		if( colIndex >= 0 ){
			colIndex = colIndex + headerCell.colSpan - 1;
			break;
		}
	}
	
	//메모리 해제
	headerCol = null; headerRow = null; headerCell = null;
	
	//리사이저 라인 위치 계산
	var colWidths = sheetRenderer._columnWidths;
	var columnWidthSum = sheetRenderer.sheetRowHeaderWidth;
	for(i = 0, colCount = colWidths.length; i <= colIndex && i < colCount; i++){
		columnWidthSum += colWidths[i];
	}
	
	sheetResizerLine.style.display = "block";
	sheetResizerLine.style.left = (columnWidthSum - (isLeftFix ? 0 : sheetRenderer.sheetContentTableLeft) - 3) + "px";
	
	//리사이저 정보 초기화
	var resizerInfo = self["_SheetResizingInfo"];
	if( resizerInfo != null && typeof resizerInfo != "undefined" ){
		resizerInfo.curPosX = 0;
		resizerInfo.firstPosX = 0;
		resizerInfo.columnIndex = -1;
		resizerInfo.resizerLine = null;
		resizerInfo.sheet = null;
	}
	resizerInfo = null;
	self["_SheetResizingInfo"] = null;
	
	//리사이저 정보 설정
	self["_SheetResizingInfo"] = {
    		"sheet" : sheet
    		, "columnIndex" : colIndex
    		, "firstPosX" : e.clientX
    		, "curPosX" : e.clientX
    		, "resizerLine" : sheetResizerLine
    };
	
	//메모리 해제
	colWidths = null;
	sheetResizerLine = null;
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
	
	return true;
};
//-컬럼 리사이저 마우스 업(컬럼 너비 조정 완료) 이벤트 처리
function sheetResizerMouseup(e){
	if( !e ) e = window.event;
	
	var resizerInfo = self["_SheetResizingInfo"];
	
	if( resizerInfo != null && typeof resizerInfo != "undefined" ){
		//리사이저 숨김
		resizerInfo.resizerLine.style.display = "none";
		
		//리사이저 라인 위치 정보
		var firstPosX = resizerInfo.firstPosX;						//리사이저 이동 시작 마우스다운 위치
		var currentPosX = e.clientX;								//리사이저 이동 완료 마우스업 위치
		var gapWidth = currentPosX - firstPosX;						//리사이저 이동 거리 계산
		//시트 정보
		var sheet = resizerInfo.sheet;
		var renderer = sheet.sheetRenderer;
		var columnIndex = resizerInfo.columnIndex;
		//시트 너비
		var sheetWidth = renderer.sheetContentDivWidth - renderer.sheetRowHeaderWidth;
		
		//시트 렌더러 컬럼 너비 정보
		var colWidthInfos = renderer.columnWidths;
		var colWidthInfo = colWidthInfos[columnIndex];
		var colWidth = renderer._columnWidths[columnIndex];
		var colMinWidth = colWidthInfo.minWidth;
		var resizedColWidth = 0;
		var resizedColMinWidth = 0;
		
		//시트 렌더러 컬럼 너비 조정
		resizedColWidth = colWidth + gapWidth;
		resizedColMinWidth = colMinWidth + gapWidth;
		if( resizedColWidth < 12 ){
			resizedColWidth = 12;											//최저 너비 설정
			gapWidth = resizedColWidth - colWidth;							//실제 차이 계산
		}
		if( colWidthInfo.isFixed )
				colWidthInfo.width = resizedColWidth;						//렌더러 고정 컬럼 너비 정보
		else	colWidthInfo.width = (resizedColWidth / sheetWidth) * 100;	//렌더러 반응형 컬럼 너비 정보
		//
		colWidthInfo.minWidth = (resizedColMinWidth < 12) ? 12 : resizedColMinWidth;
		
		//메모리 해제
		colWidthInfos = null;
		
		//컬럼 너비 정보
		var columns = sheet.columns;
		var column = null;
		var columnInfos = renderer.columnInfo;
		var columnInfo = null;
		var isFixedWidth = false;
		var calcWidth = 0; var calcMinWidth = 0;
		var resizedWidth = 0; var resizedMinWidth = 0;
		
		var headerInfos = renderer.headerInfo;
		var headerRowInfo = null;
		var headerColInfo = null;
		var startRowIndex = headerInfos.length - renderer.rowsPerDataRow;
		var colsPerRow = renderer.colsPerRow;
		var colInfoIndex = 0;
		var rowspan = 0; var colspan = 0;
		var i = 0; var j = 0;
		
		//시트 컬럼 너비 조정
		for(i = headerInfos.length - 1; i >= startRowIndex; i--, headerRowInfo = null){
			headerRowInfo = headerInfos[i];
			headerColInfo = headerRowInfo[columnIndex];
			rowspan = headerColInfo.rowspan;
			colspan = headerColInfo.colspan;
			
			if( colspan < 0 ){
				if( rowspan > 1 ){
					i -= (rowspan - 1);
					headerRowInfo = null;
					headerRowInfo = headerInfos[i];
				}
				
				for(headerColInfo = null, j = columnIndex; j >= 0; j--, headerColInfo = null){
					headerColInfo = headerRowInfo[j];
					
					if( headerColInfo.colspan < 0 ){
						continue;
					}
					else{
						colInfoIndex = headerColInfo.cellIndex;
						headerColInfo = null;
						break;
					}
				}
			}
			else{
				colInfoIndex = headerColInfo.cellIndex;
				headerColInfo = null;
			}
			
			column = sheet.columns[colInfoIndex + sheet.startRowColNum];
			columnInfo = renderer.columnInfo[colInfoIndex];
			isFixedWidth = columnInfo.isFixedWidth;
			calcWidth = columnInfo.calcCellWidth;
			calcMinWidth = 1 * column.minWidth.replace("px", "");
			
			resizedWidth = calcWidth + gapWidth;
			if( resizedWidth < 12 ) resizedWidth = 12;
			
			//렌더러 컬럼 정보 설정
			if( isFixedWidth ){
				//시트  고정 너비 컬럼
				column.width = resizedWidth + "px";
				column.minWidth = column.width;
			}
			else{
				//시트 반응형 컬럼 너비
				column.width = (resizedWidth / sheetWidth * 100) + "%";
				resizedMinWidth = isNaN(calcMinWidth) ? 12 : calcMinWidth + gapWidth;
				column.minWidth = (resizedMinWidth < 12 ? 12 : resizedMinWidth) + "px";
			}
			
			//메모리 해제
			columnInfo = null;
			column = null;
		}
		
		//메모리 해제
		columnInfos = null;
		columns = null;
		
		//너비 조정
		sheet.refreshColumns(false, true);
		
		//메모리 해제
		renderer = null;
		sheet = null;
		
		//컬럼 리사이저 정보 초기화
		resizerInfo.curPosX = 0;
		resizerInfo.firstPosX = 0;
		resizerInfo.columnIndex = -1;
		resizerInfo.resizerLine = null;
		resizerInfo.sheet = null;
		resizerInfo = null;
	}
	
	//컬럼 리사이저 정보 메모리 해제
	self["_SheetResizingInfo"] = null;
};
//-컬럼 리사이저 이동 이벤트 처리
function sheetResizerMousemove(e){
	if( !e ) e = window.event;
	
	var resizerInfo = self["_SheetResizingInfo"];
	
	if( resizerInfo != null && typeof resizerInfo != "undefined" ){
		//리사이저 라인 위치 정보
		var beforePosX = resizerInfo.curPosX;
		var currentPosX = e.clientX;
		var gapWidth = currentPosX - beforePosX;
		//리사이저 라인 객체 정보
		var sheetResizerLine = resizerInfo.resizerLine;
		var resizerLeft = 1 * (getComputedStyle(resizerInfo.resizerLine).left.replace("px", ""));
		
		//리사이저 라인 이동
		sheetResizerLine.style.left = ((resizerLeft + gapWidth) + "px");
		//리사이저 라인 이동 위치 기록
		resizerInfo.curPosX = e.clientX;
		
		//메모리 초기화
		sheetResizerLine = null;
		resizerInfo = null;
	}
};
/*
 * 	컬럼 너비 리사이즈 이벤트 (끝)
 */


/*
 *	시트 헤더 관련 처리 (시작)
 */
function sheetHeaderTableMouseUp(e){
	if( !e ) e = window.event;
	
	var em = null;
	var tagName = null;
	var className = null;
	var sheetHeaderCell = null;
	var sheet = null;
	var sheetRenderer = null;
	
	em = getSrcElement(e);
	tagName = em.tagName.toLocaleLowerCase();
	className = em.getAttribute("class");
	
	//시트 탐색
	while( className != "EasyDataSheet" && tagName != "body" ){
		//선택한 헤더 셀
		if( sheetHeaderCell == null && (tagName == "th" || tagName == "td") ){
			sheetHeaderCell = em;
		}
		
		//메모리 해제
		tagName = null; className = null;
		
		//클릭한 시트를 찾기위해 부모를 계속 탐색
		em = em.parentNode;
		tagName = em.tagName.toLocaleLowerCase();
		className = em.getAttribute("class");
	}
	
	//선택한 헤더셀을 찾지 못한 경우 예외처리
	if( sheetHeaderCell == null || typeof sheetHeaderCell == "undefined" ){
		sheetHeaderCell = null; className = null; tagName = null; em = null;
		stopEvent(e); return false;
	}
	
	//시트 컨트롤 및 렌더러 찾기
	if( className == "EasyDataSheet" ){
		sheet = controls["" + em.getAttribute("ctlname")];
		//시트 컨트롤을 못  찾은 경우
		if( sheet == null || typeof sheet == "undefined" ){
			sheet = null; sheetHeaderCell = null;
			className = null; tagName = null; em = null;
			stopEvent(e); return false;
		}
		
		sheetRenderer = sheet.sheetRenderer;
		//시트 렌터러를 못  찾은 경우
		if( sheetRenderer == null || typeof sheetRenderer == "undefined" ){
			sheetRenderer = null; sheet = null; sheetHeaderCell = null;
			className = null; tagName = null; em = null;
			stopEvent(e); return false;
		}
	}
	else{
		className = null; tagName = null; sheetHeaderCell = null; em = null;
		stopEvent(e); return false;
	}
	
	//마우스 클릭한 버튼 코드
	if( e.which ){
		mouseButtonCode = ((e.which == 3) ? 2 : ((e.which == 1) ? 1 : -1));
	}
	else if( e.button ){
		mouseButtonCode = ((e.button == 2) ? 2 : ((e.button == 0) ? 1 : -1));
	}
	
	//마우스 클릭한 버튼을 찾지 못한 경우 예외처리
	if( mouseButtonCode > 0 ){
		//마우스 버튼에 따른 동작
		switch(mouseButtonCode){
		case 1:	//마우스 왼쪽 버튼 클릭
			if( sheetRenderer.sortOnHeader ){
				var headerInfo = sheetRenderer.headerInfo;
				var headerRow = null;
				var headerCol = null;
				var headerCells = null;
				var rowCount = 0;
				var colCount = 0;
				var i = 0; var j = 0;
				
				rowCount = headerInfo.length;
				colCount = sheetRenderer.colsPerRow;
				//헤더 위치 탐색
				for(i = rowCount - sheetRenderer.rowsPerDataRow; i < rowCount; i++, headerRow = null){
					headerRow = headerInfo[i];
					
					for(j = 0; j < colCount; j++, headerCells = null){
						headerCells = headerRow[j].cells;
						
						if( headerCells == null ) continue;
						
						if( headerCells.leftfix === sheetHeaderCell
								|| headerCells.rightfix === sheetHeaderCell
								|| headerCells.header === sheetHeaderCell
						){
							headerCol = headerRow[j];
							headerCells = null;
							headerRow = null;
							break;
						}
					}
					
					if( headerCol != null ) break;
				}
				//정렬
				if( headerCol != null && headerCol.cellIndex >= 0 ){
					var columns = sheet.columns;
					var column = columns[headerCol.cellIndex + sheet.startRowColNum];
					var oldSortDirection = column.sortDirection;
					var sortDirection = null;
					
					//현재 설정되어 있는 정렬 아이콘을 제거 후 정렬
					if( sheetRenderer.removeAllSortDirection() ){
						//아이콘을 제거하면서 각 컬럼의 정렬 정보를 초기화
						for(i = 0, colCount = columns.length; i < colCount; i++){
							columns[i].sortDirection = "";
						}
						//선택한 셀의 현재 정렬상태 설정
						column.sortDirection = oldSortDirection;
						//정렬
						if( oldSortDirection === SHEET_SORT_ORDER_DESCENDING ){
							//현재 컬럼의 정렬상태가 내림차순인 경우 컬럼 정렬 초기화
							sheet.sortClear();
						}
						else{
							//현재 컬럼의 정렬상태가 오름차순인 경우 내림차순으로 정렬되지 않은 상태인 경우 오름차순으로 정렬
							sortDirection = (oldSortDirection === SHEET_SORT_ORDER_ASCENDING) ? SHEET_SORT_ORDER_DESCENDING : SHEET_SORT_ORDER_ASCENDING;
							//시트의 데이터 정렬이 정상적으로 완료되었다면 헤더 컬럼에 정렬 아이콘 추가
							if( sheet.sortTable(column.colId, sortDirection) ){
								sheetRenderer.displaySortDirection(sheetHeaderCell, sortDirection);
							}
						}
					}
					
					//메모리 해제
					sortDirection = null; oldSortDirection = null; column = null; columns = null;
				}
				
				//메모리 해제
				headerCol = null; headerInfo = null;
			}
			break;
			
		case 2:	//마우스 오른쪽 버튼 클릭
			//컨텍스트 메뉴 보이기
			sheetRenderer.showContextMenu(e.clientX, e.clientY, sheetHeaderCell);
			break;
		}
	}
	
	//메모리 해제
	sheetRenderer = null; sheet = null; sheetHeaderCell = null;
	className = null; tagName = null; em = null;
	
	stopEvent(e);
	
	return true;
};
/*
 *	시트 헤더 관련 처리(끝)
 */



/*
 *	시트 편집 관련 처리 (시작)
 */
//-시트 클릭 이벤트 함수(편집 컨트롤 세팅)
function sheetContentTableClick(e){
	if( !e ) e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	var targetObject = null;
	var className = null;
	var oldShowedTopRowIndex = -1;
	var oldRowIndex = 0;
	var oldColIndex = 0;
	var rowIndex = 0;
	var colIndex = 0;
	var result = null;

	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;

	if( em.getAttribute("class") == "EasyDataSheet" ){
		sheet = controls["" + em.getAttribute("ctlname")];
		//시트 컨트롤을 못 찾은 경우
		if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { em = null; return false; }
		if( typeof sheet.sheetRenderer.SheetControlTempDivObject == "undefined" ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	if( sheetRenderer.isEditngSheet ){
		//수정 데이터 적용 및 이벤트 처리
		if( !sheetRenderer.setApplyChangedValueToCell(true) ){
			sheetRenderer = null; sheet = null; em = null;
			stopEvent(e);
			return false;
		}
		//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
		sheetRenderer.isIgnoreEditingControlBlurEvent = true;
		//기존의 열려있는 편집 컨트롤을 닫음
		if( !sheetRenderer.removeSheetEditControl() ){
			sheetRenderer = null; sheet = null; em = null;
			stopEvent(e);
			return false; //편집 컨트롤 닫기를 실패한 경우
		}
	}
	
	//선택된 객체가 셀 객체 하위 div 객체인 경우 부모노드인 셀(td) 객체 설정
	targetObject = e.target;
	
	if( targetObject.tagName.toLocaleLowerCase() == "div" ){
		sheetRenderer.editingCellObject = targetObject.parentNode;
	}
	else{
		while( (typeof targetObject.tagName == "string" && targetObject.tagName.toLocaleLowerCase() != "td")
				|| targetObject.tagName == "body" || targetObject.tagName == "BODY"
		){
			targetObject = targetObject.parentNode;
		}
		
		sheetRenderer.editingCellObject = targetObject;
	}
	
	//셀의 행 인덱스 설정 전 기존 최상단 행 인덱스를 기록
	oldShowedTopRowIndex = sheetRenderer.showedTopRowIndex;
	//이전 행과 열 인덱스 기억
	oldRowIndex = sheetRenderer.selectedRowIndex;
	oldColIndex = sheetRenderer.selectedColumnIndex;
	
	//행 / 열 인덱스 구함
//	rowIndex = (1 * sheetRenderer.editingCellObject.parentNode.getAttribute("rowindex"));
	rowIndex = (1 * sheetRenderer.editingCellObject.parentNode.getAttribute("recordindex"));
	colIndex = (1 * sheetRenderer.editingCellObject.getAttribute("cellindex"));
	//클래스 구함
	className = sheetRenderer.editingCellObject.getAttribute("class");
	
//	if( rowIndex >= sheetRenderer.topFixRowCount ){
//		rowIndex = rowIndex + sheetRenderer.showedTopRowIndex - sheetRenderer.topFixRowCount;
//	}
	
	//셀의 행 인덱스 설정 및 이벤트 호출
//	if( !sheetRenderer.setSelectedRowIndex((1 * sheetRenderer.editingCellObject.parentNode.getAttribute("rowindex")) + sheetRenderer.showedTopRowIndex) ){
	if( !sheetRenderer.setSelectedRowIndex(rowIndex) ){
		className = null; targetObject = null; sheetRenderer = null; sheet = null; em = null;
		return false;
	}
	
	//클릭한 셀이 행 타이틀인 경우 컬럼 인덱스 이동 및 편집 컨트롤 세팅 등 후속 작업을 실행하지 않음
	if( className != null && className.indexOf("RowHeader") >= 0 ){
		//편집 중인 셀 초기화
		sheetRenderer.editingCellObject = null;
		//메모리 해제
		className = null; targetObject = null; sheetRenderer = null; sheet = null; em = null;
		return true;
	}
	
	//셀의 열 인덱스 설정 및 이벤트 호출
//	if( !sheetRenderer.setSelectedColumnIndex(1 * sheetRenderer.editingCellObject.getAttribute("cellindex")) ){
	if( !sheetRenderer.setSelectedColumnIndex(colIndex) ){
		className = null; targetObject = null; sheetRenderer = null; sheet = null; em = null;
		return false;
	}
	
	//
//	sheetRenderer.selectedObject = sheetRenderer.editingCellObject;
	
//	//시트 이벤트 : click 호출(시작)
//	if( sheet.hasClickEvent ){
//		//이벤트 호출
//		result = sheet.fncClickEvent(sheetRenderer.selectedRowIndex, sheetRenderer.selectedColumnIndex);
//		
//		//이벤트 결과 처리
//		if( typeof result == "boolean" && result != true ){
//			//메모리 해제
//			result = null; oldColIndex = null; oldRowIndex = null; oldShowedTopRowIndex = null; targetObject = null; sheetRenderer = null; sheet = null; em = null;
//			//사용자 이벤트 로직 처리 결과에 따라 후동작 처리하지 않음
//			return false;
//		}
//	}
//	//시트 이벤트 : click 호출(종료)
	
//	//시트 이벤트 후속 처리
//	sheet._catchEvent({event: "click", row: oldRowIndex, col: oldColIndex, newRow: sheetRenderer.selectedRowIndex, newCol: sheetRenderer.selectedColumnIndex});
	
	//시트 이벤트 처리 및 후속 동작
	if( !sheet._catchEvent({event: "click", row: oldRowIndex, col: oldColIndex, newRow: sheetRenderer.selectedRowIndex, newCol: sheetRenderer.selectedColumnIndex}) ){
		//메모리 해제
		result = null; className = null; targetObject = null; sheetRenderer = null; sheet = null; em = null;
		//사용자 이벤트 로직 처리 결과에 따라 후동작 처리하지 않음
		stopEvent(e);
		return false;
	}
	
	//스크롤이 이동되었기 때문에 시트의 화면내 출력되는 최상단 행 인덱스가 변경었고 클릭 이벤트 등에서 선택한 객체가 변경되야 하므로 셀 객체를 null 로 설정하여 setSheetEditControl 함수 동작시 셀을 찾도록 함
	if( oldShowedTopRowIndex != sheetRenderer.showedTopRowIndex ){
		sheetRenderer.editingCellObject = null;
	}
	
	//셀 편집 컨트롤 세팅
	sheetRenderer.setSheetEditControl();
	
	//체크박스 셀을 클릭한 경우 값이 변경되야함
	if( sheetRenderer.columnInfo[sheetRenderer.selectedColumnIndex].cellType == "checkbox" ){
		sheetRenderer.SheetEidtCheckDivObject.click();
	}
	
	//
	sheetRenderer.setSelectionClass(sheetRenderer.editingCellObject);
	
	//메모리 해제
	result = null; className = null; targetObject = null; sheetRenderer = null; sheet = null; em = null;
	
	stopEvent(e);
    
    return true;
}
//-시트 더블클릭 이벤트 함수
function sheetContentTableDoubleClick(e){
	if( !e ) e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	var targetObject = null;
	var rowIndex = null;
	var colIndex = null;
	var result = null;
	
	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;

	if( em.getAttribute("class") == "EasyDataSheet" ){
		sheet = controls["" + em.getAttribute("ctlname")];
		//시트 컨트롤을 못 찾은 경우
		if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { em = null; return false; }
		if( typeof sheet.sheetRenderer.SheetControlTempDivObject == "undefined" ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	//선택된 객체가 셀 객체 하위 div 객체인 경우 부모노드인 셀(td) 객체 설정
	targetObject = e.target;
	
	if( targetObject.tagName.toLocaleLowerCase() != "td" ){
		while( targetObject.tagName.toLocaleLowerCase() != "td" && targetObject.tagName.toLocaleLowerCase() != "body" )
			targetObject = targetObject.parentNode;
		
		if( targetObject.tagName.toLocaleLowerCase() == "body" ){
			//메모리 해제
			targetObject = null; sheetRenderer = null; sheet = null; em = null;
			//셀을 찾지 못하여 후동작 처리하지 않음
			return false;
		}
	}
	
	//이전 행과 열 인덱스 기억
//	rowIndex = (1 * targetObject.parentNode.getAttribute("rowindex")) + sheetRenderer.showedTopRowIndex;
	rowIndex = (1 * targetObject.parentNode.getAttribute("recordindex"));
	colIndex = (1 * targetObject.getAttribute("cellindex"));
	
	sheetRenderer.selectedObject = targetObject;
	
//	//시트 이벤트 : double click 호출(시작)
//	if( sheet.hasDblClickEvent ){
//		//이벤트 호출
//		result = sheet.fncDblClickEvent(rowIndex, colIndex);
//		
//		//이벤트 결과 처리
//		if( typeof result == "boolean" && result != true ){
//			//메모리 해제
//			result = null; colIndex = null; rowIndex = null; targetObject = null;
//			sheetRenderer = null; sheet = null; em = null;
//			//사용자 이벤트 로직 처리 결과에 따라 후동작 처리하지 않음
//			return false;
//		}
//	}
//	//시트 이벤트 : double click 호출(종료)
	
//	//시트 이벤트 후속 처리
//	sheet._catchEvent({event: "dblclick", row: rowIndex, col: colIndex});
	
	//시트 이벤트 처리 및 후속 동작
	sheet._catchEvent({event: "dblclick", row: rowIndex, col: colIndex});
	
	//이벤트 처리 후 
//	if( targetObject !== sheetRenderer.editingCellObject && sheetRenderer.isEditngSheet ){
//		//수정 데이터 적용 및 이벤트 처리
//		if( !sheetRenderer.setApplyChangedValueToCell(true) ){
//			sheetRenderer = null; sheet = null; em = null;
//			stopEvent(e);
//			return false;
//		}
//		//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
//		sheetRenderer.isIgnoreEditingControlBlurEvent = true;
//		//기존의 열려있는 편집 컨트롤을 닫음
//		if( !sheetRenderer.removeSheetEditControl() ){
//			sheetRenderer = null; sheet = null; em = null;
//			stopEvent(e);
//			return false; //편집 컨트롤 닫기를 실패한 경우
//		}
//	}
	
	//메모리 해제
	result = null; colIndex = null; rowIndex = null; targetObject = null;
	sheetRenderer = null; sheet = null; em = null;
	
	stopEvent(e);
	
	return true;
}
//-시트 MouseOver 이벤트 함수(마우스 오버 행 표시)
function sheetContentTableMouseOver(e){
	if( !e ) e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	
	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;

	if( em.getAttribute("class") == "EasyDataSheet" ){
		sheet = controls["" + em.getAttribute("ctlname")];
		//시트 컨트롤을 못 찾은 경우
		if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { em = null; return false; }
		if( typeof sheet.sheetRenderer.SheetControlTempDivObject == "undefined" ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	var target = null;
	var overCellObejct = null;
	var overRowObject = null;
	
	//시트 선택 모드가 SHEET_SELECT_NONE(선택 안함) 인 경우 더이상 처리하지 않음
	if( sheetRenderer.selectMode == SHEET_SELECT_NONE ){
		stopEvent(e);
		return true;
	}
	
	//행(td) 객체 탐색
	target = getSrcElement(e);
	while(target.tagName.toLowerCase() != "td" && target.tagName.toLowerCase() != "body") target = target.parentNode;
	
	//target 이 행 객체인 경우 행에 마우스가 오버 클래스 추가
	if( target.tagName.toLowerCase() == "td" ){
		//마우스가 오버된 이전 객체가 있는 경우
		if( sheetRenderer.mouseOverObject != null ){
			//셀 객체 마우스 오버 클래스 제거
			overCellObejct = sheetRenderer.mouseOverObject;
			if( sheetRenderer.hasClass(overCellObejct, "mouse-over-col") > 0 ){
				sheetRenderer.removeClass(overCellObejct, "mouse-over-col");
			}
			
			//행 객체 마우스 오버 클래스 제거
			overRowObject = sheetRenderer.mouseOverObject.parentNode;
			if( sheetRenderer.hasClass(overRowObject, "mouse-over-row") > 0 ){
				sheetRenderer.setRowClass(overRowObject, sheetRenderer.getClass(overRowObject).replace("mouse-over-row", "").replace(/\s+/g, " "), true);
			}
			
			//메모리 해제
			overRowObject = null; overCellObejct = null;
			
			//마우스 오버 이전 객체 해제
			sheetRenderer.mouseOverObject = null;
		}
		
		//시트 선택 모드가 셀 선택 모드인 경우
		if( sheetRenderer.selectMode == SHEET_SELECT_CELL ){
			//셀 객체 마우스 오버 클래스 적용
			overCellObejct = target;
			if( sheetRenderer.hasClass(overCellObejct, "mouse-over-col") <= 0 ){
				sheetRenderer.setCellClass(overCellObejct, "mouse-over-col", false);
			}
			//메모리 해제
			overCellObejct = null;
		}
		//시트 선택 모드가 행 선택 모드인 경우
		else if( sheetRenderer.selectMode == SHEET_SELECT_ROW ){
			//행 객체 마우스 오버 클래스 적용
			overRowObject = target.parentNode;
			if( sheetRenderer.hasClass(overRowObject, "mouse-over-row") <= 0 ){
				sheetRenderer.setRowClass(overRowObject, "mouse-over-row", false);
			}
			//메모리 해제
			overRowObject = null;
		}
		
		//마우스 오버 객체 설정
		sheetRenderer.mouseOverObject = target;
	}
	
	//메모리 해제
	overRowObject = null; overCellObejct = null; target = null;
	sheetRenderer = null; sheet = null; em = null;
	
	stopEvent(e);
	
	return true;
};
//-시트 MouseOut 이벤트 함수(마우스 오버 행 표시)
function sheetContentTableMouseOut(e){
	if( !e ) e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	
	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;

	if( em.getAttribute("class") == "EasyDataSheet" ){
		sheet = controls["" + em.getAttribute("ctlname")];
		//시트 컨트롤을 못 찾은 경우
		if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { em = null; return false; }
		if( typeof sheet.sheetRenderer.SheetControlTempDivObject == "undefined" ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	var classStr = null;
	var classItems = null;
	var moveOverClassIndex = -1;
	var overCellObejct = null;
	var overRowObject = null;
	
	//마우스가 오버된 이전 객체가 있는 경우
	if( sheetRenderer.mouseOverObject != null ){
		//셀 객체 마우스 오버 클래스 제거
		overCellObejct = sheetRenderer.mouseOverObject;
		if( sheetRenderer.hasClass(overCellObejct, "mouse-over-col") > 0 ){
			sheetRenderer.removeClass(overCellObejct, "mouse-over-col");
		}

		//행 객체 마우스 오버 클래스 제거
		overRowObject = sheetRenderer.mouseOverObject.parentNode;
		if( sheetRenderer.hasClass(overRowObject, "mouse-over-row") > 0 ){
			sheetRenderer.setRowClass(overRowObject, sheetRenderer.getClass(overRowObject).replace("mouse-over-row", "").replace(/\s+/g, " "), true);
		}
		
		//메모리 해제
		overRowObject = null; overCellObejct = null;

		//마우스 오버 이전 객체 해제
		sheetRenderer.mouseOverObject = null;
	}
	
	//메모리 해제
	overRowObject = null; overCellObejct = null;
	sheetRenderer = null; sheet = null; em = null;
	
	stopEvent(e);
	
	return true;
}

//-시트 편집 컨트롤:텍스트박스 Blur 이벤트 처리
function sheetEidtTextboxBlur(e){
	if( !e ) e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	
	//시트 탐색
	var em = getSrcElement(e);
    while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
    
    if( em.getAttribute("class") == "EasyDataSheet" ){
        sheet = controls["" + em.getAttribute("ctlname")];
        //시트 컨트롤을 못 찾은 경우
		if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { em = null; return false; }
		if( typeof sheet.sheetRenderer.SheetControlTempDivObject == "undefined" ) { sheet = null; em = null; return false; }
		//Blur 이벤트를 처리하지 않는 상태인 경우 처리하지 않음
		if( sheet.sheetRenderer.isIgnoreEditingControlBlurEvent ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	//수정 데이터 적용 및 이벤트 처리
	if( !sheetRenderer.setApplyChangedValueToCell(true) ) { sheetRenderer = null; sheet = null; em = null; return false; }
	//시트 편집 컨트롤:텍스트박스 해제
	sheetRenderer.removeSheetEditControl();
	
//	sheetRenderer.selectedRowIndex = -1;
//	sheetRenderer.selectedColumnIndex = -1;
	
	//메모리 해제
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
    
    return true;
};
//-시트 편집 컨트롤:텍스트박스 MouseUp 이벤트 처리
function sheetEidtTextboxMouseUp(e){
	if( !e ) e = window.event;
	
	//시트 본문 테이블의 MouseUp 이벤트를 막기위한 용도
	
	stopEvent(e);
    
    return true;
}
//-시트 편집 컨트롤:텍스트박스 Keydown 이벤트 처리
function sheetEidtTextboxKeydown(e){
	if( !e ) e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	var keyCode = (e.which) ? e.which : e.keyCode;
	
	//F5새로고침 방지 추가
	if( keyCode == 116 ){
		if( typeof e.preventDefault == "function" ){
			e.preventDefault();
		}
		else{
			e.returnValue = false; // for IE
		}
		return false;
	}
	
	//시트 탐색
	var em = getSrcElement(e);
    while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
    
    if( em.getAttribute("class") == "EasyDataSheet" ){
        sheet = controls["" + em.getAttribute("ctlname")];
        //시트 컨트롤을 못 찾은 경우
        if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	var isCtrlKeyDown = e.ctrlKey || e.metaKey;		//컨트롤 or 커맨드(Mac지원)
    var isAltKeqyDown = e.altKey;					//알트
	var isShiftKeyDown = e.shiftKey					//쉬프트
	
	switch( keyCode ){
		//위 방향키(Arrow Up)
		case 38:
			//한 행 위 셀로 이동
			sheetRenderer.moveToUpperCell();
			break;
			
		//아래 방향키(Arrow Down)
		case 40:
			//한 행 아래 셀로 이동
			sheetRenderer.moveToLowerCell();
			break;
			
		//엔터(Enter)
		case 13:
			//엔터와 탭 키의 이동 동작 설정에 따라 편집 컨트롤을 이동
			if( sheetRenderer.switchMoveEnterAndTab ){
				if( isShiftKeyDown ) sheetRenderer.moveToFormerCell();	//이전 셀로 이동
				else				 sheetRenderer.moveToNextCell();	//다음 셀로 이동
			}
			else{
				if( isShiftKeyDown ) sheetRenderer.moveToUpperCell();	//위 셀로 이동
				else				 sheetRenderer.moveToLowerCell();	//아래 셀로 이동
			}
			break;
		
		//탭(Tab)
		case 9:
			if( sheetRenderer.tabKeyAction == 1 /*SHEET_TAB_TONEXTCELL*/ ){
				//엔터와 탭 키의 이동 동작 설정에 따라 편집 컨트롤을 이동
				if( sheetRenderer.switchMoveEnterAndTab ){
					if( isShiftKeyDown ) sheetRenderer.moveToUpperCell();	//위 셀로 이동
					else				 sheetRenderer.moveToLowerCell();	//아래 셀로 이동
				}
				else{
					if( isShiftKeyDown ) sheetRenderer.moveToFormerCell();	//이전 셀로 이동
					else				 sheetRenderer.moveToNextCell();	//다음 셀로 이동
				}
			}
			else{
				//수정 데이터 적용 후, 편집 컨트롤 닫음
				sheetRenderer.completeSheetEditing(true);
				//컨트롤 이동
				if( isShiftKeyDown )	setTimeout("setFocusToFormerControl(\"" + sheetRenderer.controlName + "\")", 0);	//이전으로 이동
				else 					setTimeout("setFocusToNextControl(\"" + sheetRenderer.controlName + "\")", 0);		//다음으로 이동
			}
			stopEvent(e);
			break;
			
		//취소(Esc)
		case 27:
			/*
			//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
			sheetRenderer.isIgnoreEditingControlBlurEvent = true;
			//수정 데이터 적용 안함
			sheetRenderer.setApplyChangedValueToCell(false);
			//편집 컨트롤 닫음
			sheetRenderer.removeSheetEditControl();
			//시트 메세지박스 숨김
			sheetRenderer.setSheetMsgBox(false);
			*/
			//수정 데이터 적용  취소 후, 편집 컨트롤 닫음
			sheetRenderer.completeSheetEditing(false);
			break;
	}
	
	//메모리 해제
	isCtrlKeyDown = null; isAltKeqyDown = null; isShiftKeyDown = null;
	sheetRenderer = null; sheet = null; keyCode = null; em = null;
	
	stopPropagation(e);
    
    return true;
};

//-시트 편집 컨트롤:체크박스 Blur 이벤트 처리
function sheetEidtCheckboxBlur(e){
	if( !e ) e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	
	//시트 탐색
	var em = getSrcElement(e);
    while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
    
    if( em.getAttribute("class") == "EasyDataSheet" ){
        sheet = controls["" + em.getAttribute("ctlname")];
        //시트 컨트롤을 못 찾은 경우
        if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { em = null; return false; }
		if( typeof sheet.sheetRenderer.SheetControlTempDivObject == "undefined" ) { sheet = null; em = null; return false; }
		//Blur 이벤트를 처리하지 않는 상태인 경우 처리하지 않음
		if( sheet.sheetRenderer.isIgnoreEditingControlBlurEvent ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	//수정 데이터 적용 및 이벤트 처리
	if( !sheetRenderer.setApplyChangedValueToCell(true) ){
		sheetRenderer = null; sheet = null; em = null;
		return false;
	}
	
	//시트 편집 컨트롤:텍스트박스 해제
	sheetRenderer.removeSheetEditControl();
	
//	sheetRenderer.selectedRowIndex = -1;
//	sheetRenderer.selectedColumnIndex = -1;
	
	//메모리 해제
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
    
    return true;
}
//-시트 편집 컨트롤:체크박스 MouseUp 이벤트 처리
function sheetEidtCheckboxMouseUp(e){
	if( !e ) e = window.event;
	
	//시트 본문 테이블의 MouseUp 이벤트를 막기위한 용도
	
	stopEvent(e);
    
    return true;
};
//-시트 편집 컨트롤:체크박스 Click 이벤트 처리
function sheetEidtCheckboxClick(e){
	if( !e ) e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	
	//시트 탐색
	var em = getSrcElement(e);
    while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
    
    if( em.getAttribute("class") == "EasyDataSheet" ){
        sheet = controls["" + em.getAttribute("ctlname")];
        //시트 컨트롤을 못 찾은 경우
        if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
    
	//리스트 시트인 경우 편집 불가능하므로 수정 데이터를 적용하지 않음
	if( sheetRenderer.isListSheet ){
		sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
	    return true;
	}
	
	var enable = sheetRenderer.columnInfo[sheetRenderer.selectedColumnIndex].enable;
	var isEnable = (typeof enable == "function" ? enable(sheetRenderer.selectedRowIndex, sheetRenderer.selectedColumnIndex) : enable);
	
	//데이터 시트의 컬럼을 잠금 설정한 경우 편집이 불가능하므로 수정 데이터를 적용하지 않음
	if( !isEnable ){
		sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
	    return true;
	}
	
	//수정 데이터 적용
	var fieldType = sheetRenderer.columnInfo[sheetRenderer.selectedColumnIndex].fieldType;
	var value = sheetRenderer.SheetEidtCheckDivObject.getAttribute("originval");
	
	//필드 타입별 데이터 변환
	if( fieldType == "string" ){
		value = "" + value;
	}
	else if( fieldType == "number" ){
		value = 1 * value;
	}
	else if( fieldType == "boolean" ){
		value = ("" + value == "true") ? true : false;
	}
	
	//변경된 값 설정
	if( value == sheetRenderer.columnInfo[sheetRenderer.selectedColumnIndex].checkedValue ){
		value = sheetRenderer.columnInfo[sheetRenderer.selectedColumnIndex].uncheckedValue;
	}
	else{
		value = sheetRenderer.columnInfo[sheetRenderer.selectedColumnIndex].checkedValue;
	}
	
	//데이터 수정이 완료되었다면 화면에 수정된 데이터에 해당하는 체크 아이콘 출력
	sheetRenderer.SheetEidtCheckDivObject.setAttribute("originval", value);
	sheetRenderer.SheetEidtCheckDivObject.innerHTML = sheetRenderer.getDisplayValueByCellType(sheetRenderer.selectedColumnIndex, value);
	
	//수정 데이터 적용
	sheetRenderer.setApplyChangedValueToCell(true);
	
	//메모리 해제
	sheet = null;
	em = null;

	stopEvent(e);
    
    return true;
};
//-시트 편집 컨트롤:체크박스 Keydown 이벤트 처리
function sheetEidtCheckboxKeydown(e){
	if( !e ) e = window.event;
	
	var keyCode = (e.which) ? e.which : e.keyCode;
	
	var sheet = null;
	var sheetRenderer = null;
	
	//F5새로고침 방지 추가
	if( keyCode == 116 ){
		if( typeof e.preventDefault == "function" ){
			e.preventDefault();
		}
		else{
			e.returnValue = false; // for IE
		}
		return false;
	}
	
	//시트 탐색
	var em = getSrcElement(e);
    while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
    
    if( em.getAttribute("class") == "EasyDataSheet" ){
        sheet = controls["" + em.getAttribute("ctlname")];
        //시트 컨트롤을 못 찾은 경우
        if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; keyCode = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	var isCtrlKeyDown = e.ctrlKey || e.metaKey;		//컨트롤 or 커맨드(Mac지원)
    var isAltKeqyDown = e.altKey;					//알트
	var isShiftKeyDown = e.shiftKey					//쉬프트
	
	switch( keyCode ){
		//위 방향키(Arrow Up)
		case 38:
			//한 행 위 셀로 이동
			sheetRenderer.moveToUpperCell();
			break;
			
		//아래 방향키(Arrow Down)
		case 40:
			//한 행 아래 셀로 이동
			sheetRenderer.moveToLowerCell();
			break;
			
		//엔터(Enter)
		case 13:
			//엔터와 탭 키의 이동 동작 설정에 따라 편집 컨트롤을 이동
			if( sheetRenderer.switchMoveEnterAndTab ){
				//다음 셀로 이동
				sheetRenderer.moveToNextCell();
			}
			else{
				//아래 셀로 이동
				sheetRenderer.moveToLowerCell();
			}
			break;
		
		//탭(Tab)
		case 9:
			//엔터와 탭 키의 이동 동작 설정에 따라 편집 컨트롤을 이동
			if( sheetRenderer.switchMoveEnterAndTab ){
				//아래 셀로 이동
				sheetRenderer.moveToLowerCell();
			}
			else{
				//열 인덱스 계산
				sheetRenderer.moveToNextCell();
			}
			stopEvent(e);
			break;
			
		//취소(Esc)
		case 27:
			//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
			sheetRenderer.isIgnoreEditingControlBlurEvent = true;
			//수정 데이터 적용 안함
			sheetRenderer.setApplyChangedValueToCell(false);
			//편집 컨트롤 닫음
			sheetRenderer.removeSheetEditControl();
//			//편집 컨트롤 닫은 후 행과 열 인덱스 초기화
//			sheetRenderer.selectedRowIndex = -1;
//			sheetRenderer.selectedColumnIndex = -1;
			//시트 메세지박스 숨김
			sheetRenderer.setSheetMsgBox(false);
			break;
			
		//스페이스(Space)
		case 32:
			sheetRenderer.SheetEidtCheckDivObject.click();
			break;
	}
	
	//메모리 해제
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
    
    return true;
}

//-시트 편집 컨트롤:콤보박스 Blur 이벤트 처리
function sheetEidtComboboxBlur(e){
	if( !e ) e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	
	//시트 탐색
	var em = getSrcElement(e);
    while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
    
    if( em.getAttribute("class") == "EasyDataSheet" ){
        sheet = controls["" + em.getAttribute("ctlname")];
        //시트 컨트롤을 못 찾은 경우
        if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; em = null; return false; }
		if( typeof sheet.sheetRenderer.SheetControlTempDivObject == "undefined" ) { sheet = null; em = null; return false; }
		//Blur 이벤트를 처리하지 않는 상태인 경우 처리하지 않음
		if( sheet.sheetRenderer.isIgnoreEditingControlBlurEvent ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	//수정 데이터 적용 및 이벤트 처리
	if( !sheetRenderer.setApplyChangedValueToCell(true) ){
		//메모리 해제
		sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
		return false;
	}
	//시트 편집 컨트롤:텍스트박스 해제
	sheetRenderer.removeSheetEditControl();
	
//	sheetRenderer.selectedRowIndex = -1;
//	sheetRenderer.selectedColumnIndex = -1;
	
	//메모리 해제
	sheetRenderer = null; sheet = null; em = null;
	
	stopEvent(e);
    
    return true;
};
//-시트 편집 컨트롤:콤보박스 Change 이벤트 처리
function sheetEditComboboxChange(e){
	if( !e ) e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	var target = null;
	var trObject = null;
	var tdObject = null;
	var selectedOptionObject = null;
	var rowIndex = null;
	var colIndex = null;
	var oldValue = null;
	var newValue = null;
	var fieldType = null;
	var result = null;
	
	//시트 탐색
	var em = getSrcElement(e);
    while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
    
    if( em.getAttribute("class") == "EasyDataSheet" ){
        sheet = controls["" + em.getAttribute("ctlname")];
        //시트 컨트롤을 못 찾은 경우
        if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	//변경된 콤모박스의 위치를 찾음
	target = e.target || e.srcElement;
	if( target.tagName.toLocaleLowerCase() == "select" ){
		tdObject = target.parentNode.parentNode;
		trObject = tdObject.parentNode;
		selectedOptionObject = target.options[target.selectedIndex];
	}
	else{
		//메모리 해제
		target = null; sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
		return false;
	}
	
	//이벤트 파라메터 정보
	rowIndex = 1 * trObject.getAttribute("rowindex");
	colIndex = 1 * tdObject.getAttribute("cellindex");
	oldValue = sheetRenderer.data[rowIndex][sheetRenderer.columnInfo[colIndex].field];
//	rowIndex = rowIndex + sheetRenderer.showedTopRowIndex; //oldValue 를 찾기 위해 인덱스로만 설정하고 oldValue 를 기록한 다음엔 상단 행의 인덱스와 더해 행 인덱스를 설정
	
	//현재 선택된 값 설정
	if( typeof selectedOptionObject != "undefined" ){
		fieldType = sheetRenderer.columnInfo[colIndex].fieldType;
		newValue = selectedOptionObject.value;

		//현재 선택된 값 형변환
		if( fieldType == "number" ){
			newValue = 1 * newValue;
		}
		else if( fieldType == "boolean" ){
			newValue = ("" + newValue == "true") ? true : false;
		}
		else{
			newValue = "" + newValue;
		}
	}
	
	//수정 데이터 적용 및 이벤트 처리
	if( !sheetRenderer.setApplyChangedValueToCell(true) ){
		//oldValue 를 찾기 위해 인덱스로만 설정하고 oldValue 를 기록한 다음엔 레코드 인덱스를 설정
		rowIndex = 1 * trObject.getAttribute("recordindex");
		//콤보 포커스
		self["sheetRenderer"] = sheetRenderer;
		setTimeout(function(rowIndex, colIndex){
			self["sheetRenderer"].setSheetEditControl(rowIndex, colIndex);
			self["sheetRenderer"] = null;
			delete self["sheetRenderer"];
		}, 1);
		//메모리 해제
		fieldType = null; newValue = null; oldValue = null;
		selectedOptionObject = null; trObject = null; tdObject = null;
		target = null; sheetRenderer = null; sheet = null; em = null;
		//사용자 이벤트 로직 처리 결과에 따라 후동작 처리하지 않음
		stopEvent(e);
		return false;
	}
	
	//메모리 해제
	result = null; fieldType = null; newValue = null; oldValue = null;
	selectedOptionObject = null; trObject = null; tdObject = null;
	target = null; sheetRenderer = null; sheet = null; em = null;
	
	stopEvent(e);
    
    return true;
}
//-시트 편집 컨트롤:콤보박스 MouseUp 이벤트 처리
function sheetEidtComboboxMouseUp(e){
	if( !e ) e = window.event;
	
	//시트 본문 테이블의 MouseUp 이벤트를 막기위한 용도
	
	stopEvent(e);
    
    return true;
};
//-시트 편집 컨트롤:콤보박스 Keydown 이벤트 처리
function sheetEidtComboboxKeydown(e){
	if( !e ) e = window.event;
	
	var sheet = null;
	var keyCode = (e.which) ? e.which : e.keyCode;
	
	//F5새로고침 방지 추가
	if( keyCode == 116 ){
		if( typeof e.preventDefault == "function" ){
			e.preventDefault();
		}
		else{
			e.returnValue = false; // for IE
		}
		return false;
	}
	
	//시트 탐색
	var em = getSrcElement(e);
    while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
    
    if( em.getAttribute("class") == "EasyDataSheet" ){
        sheet = controls["" + em.getAttribute("ctlname")];
        //시트 컨트롤을 못 찾은 경우
        if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; keyCode = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	var isCtrlKeyDown = e.ctrlKey || e.metaKey;		//컨트롤 or 커맨드(Mac지원)
    var isAltKeqyDown = e.altKey;					//알트
	var isShiftKeyDown = e.shiftKey					//쉬프트
	
	//현재 컬럼 위치 기억
//	rowIndex = oldRowIndex = sheet.selectedRowIndex;
//	colIndex = oldColIndex = sheet.selectedColumnIndex;
	
	switch( keyCode ){
		//위 방향키(Arrow Up)
		case 38:
			//한 행 위 셀로 이동
			if( !isAltKeqyDown ) sheetRenderer.moveToUpperCell();
			break;	
		
		//아래 방향키(Arrow Down)
		case 40:
			//한 행 아래 셀로 이동
			if( !isAltKeqyDown ) sheetRenderer.moveToLowerCell();
			break;
			
		//엔터(Enter)
		case 13:
			//엔터와 탭 키의 이동 동작 설정에 따라 편집 컨트롤을 이동
			if( sheetRenderer.switchMoveEnterAndTab ){
				//다음 셀로 이동
				sheetRenderer.moveToNextCell();
			}
			else{
				//아래 셀로 이동
				sheetRenderer.moveToLowerCell();
			}
			sheetRenderer.SheetEidtComboDivObject.getElementsByTagName("select")[0].size = 0;
			break;
		
		//탭(Tab)
		case 9:
			//엔터와 탭 키의 이동 동작 설정에 따라 편집 컨트롤을 이동
			if( sheetRenderer.switchMoveEnterAndTab ){
				//아래 셀로 이동
				sheetRenderer.moveToLowerCell();
			}
			else{
				//열 인덱스 계산
				sheetRenderer.moveToNextCell();
			}
			stopEvent(e);
			break;
			
		//취소(Esc)
		case 27:
			//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
			sheetRenderer.isIgnoreEditingControlBlurEvent = true;
			//수정 데이터 적용 안함
			sheetRenderer.setApplyChangedValueToCell(false);
			//편집 컨트롤 닫음
			sheetRenderer.removeSheetEditControl();
//			//편집 컨트롤 닫은 후 행과 열 인덱스 초기화
//			sheetRenderer.selectedRowIndex = -1;
//			sheetRenderer.selectedColumnIndex = -1;
			//시트 메세지박스 숨김
			sheetRenderer.setSheetMsgBox(false);
			break;
	}
	
	if( isAltKeqyDown && (keyCode == 38 || keyCode == 40) ){
		stopPropagation(e);
	}
	else{
		stopEvent(e);
	}
	
	//메모리 해제
	isCtrlKeyDown = null; isAltKeqyDown = null; isShiftKeyDown = null;
	sheetRenderer = null; sheet = null; keyCode = null; em = null;
	
    return true;
};

//-시트 편집 컨트롤:일자(날짜) 텍스트박스 MouseUp 이벤트 처리
function sheetEidtDateMouseUp(e){
	if( !e ) e = window.event;
	
	//시트 본문 테이블의 MouseUp 이벤트를 막기위한 용도
	
	stopEvent(e);
    
    return true;
}
//-시트 편집 컨트롤:일자(날짜) 텍스트박스 Blur 이벤트 처리
function sheetEidtDateInputBlur(e){
	if( !e ) e = window.event;
	
	//시트 날짜타입 셀 편집시 달력버튼 위에 마우스가 올라갔을 경우(또는 클릭한 경우) Blur 이벤트를 발생시키지 않음
	if( _SheetCalenderBtnOver )
		return false;
	
	var sheet = null;
	var sheetRenderer = null;
	
	//시트 탐색
	var em = getSrcElement(e);
    while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
    
    if( em.getAttribute("class") == "EasyDataSheet" ){
        sheet = controls["" + em.getAttribute("ctlname")];
        //시트 컨트롤을 못 찾은 경우
        if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; em = null; return false; }
		if( typeof sheet.sheetRenderer.SheetControlTempDivObject == "undefined" ) { sheet = null; em = null; return false; }
		//Blur 이벤트를 처리하지 않는 상태인 경우 처리하지 않음
		if( sheet.sheetRenderer.isIgnoreEditingControlBlurEvent ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	//수정 데이터 적용 및 이벤트 처리
	if( !sheetRenderer.setApplyChangedValueToCell(true) ) { sheetRenderer = null; sheet = null; em = null; return false; }
	//시트 편집 컨트롤:텍스트박스 해제
	sheetRenderer.removeSheetEditControl();
	
//	sheetRenderer.selectedRowIndex = -1;
//	sheetRenderer.selectedColumnIndex = -1;
	
	//메모리 해제
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
    
    return true;
};
//-시트 편집 컨트롤:일자(날짜) 텍스트박스 Keydown 이벤트 처리
function sheetEidtDateInputKeydown(e){
	if( !e ) e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	var keyCode = (e.which) ? e.which : e.keyCode;
	
	//F5새로고침 방지 추가
	if( keyCode == 116 ){
		if( typeof e.preventDefault == "function" ){
			e.preventDefault();
		}
		else{
			e.returnValue = false; // for IE
		}
		return false;
	}
	
	//시트 탐색
	var em = getSrcElement(e);
    while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
    
    if( em.getAttribute("class") == "EasyDataSheet" ){
        sheet = controls["" + em.getAttribute("ctlname")];
        //시트 컨트롤을 못 찾은 경우
        if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheetRenderer = null; sheet = null; keyCode = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	var isCtrlKeyDown = e.ctrlKey || e.metaKey;		//컨트롤 or 커맨드(Mac지원)
    var isAltKeqyDown = e.altKey;					//알트
	var isShiftKeyDown = e.shiftKey					//쉬프트
	
	switch( keyCode ){
		//위 방향키(Arrow Up)
		case 38:
			//한 행 위 셀로 이동
			sheetRenderer.moveToUpperCell();
			break;
			
		//아래 방향키(Arrow Down)
		case 40:
			//한 행 아래 셀로 이동
			sheetRenderer.moveToLowerCell();
			break;
			
		//엔터(Enter)
		case 13:
			//엔터와 탭 키의 이동 동작 설정에 따라 편집 컨트롤을 이동
			if( sheetRenderer.switchMoveEnterAndTab ){
				//다음 셀로 이동
				sheetRenderer.moveToNextCell();
			}
			else{
				//아래 셀로 이동
				sheetRenderer.moveToLowerCell();
			}
			break;
		
		//탭(Tab)
		case 9:
			//엔터와 탭 키의 이동 동작 설정에 따라 편집 컨트롤을 이동
			if( sheetRenderer.switchMoveEnterAndTab ){
				//아래 셀로 이동
				sheetRenderer.moveToLowerCell();
			}
			else{
				//열 인덱스 계산
				sheetRenderer.moveToNextCell();
			}
			stopEvent(e);
			break;
			
		//취소(Esc)
		case 27:
			//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
			sheetRenderer.isIgnoreEditingControlBlurEvent = true;
			//수정 데이터 적용 안함
			sheetRenderer.setApplyChangedValueToCell(false);
			//편집 컨트롤 닫음
			sheetRenderer.removeSheetEditControl();
//			//편집 컨트롤 닫은 후 행과 열 인덱스 초기화
//			sheetRenderer.selectedRowIndex = -1;
//			sheetRenderer.selectedColumnIndex = -1;
			//시트 메세지박스 숨김
			sheetRenderer.setSheetMsgBox(false);
			break;
	}
	
	//메모리 해제
	isCtrlKeyDown = null; isAltKeqyDown = null; isShiftKeyDown = null; keyCode = null;
	sheetRenderer = null; sheet = null; em = null;
	
	stopPropagation(e);
    
    return true;
}
//-시트 편집 컨트롤:일자(날짜) 달력버튼 Click 이벤트 처리
function sheetEidtDateCalenderClick(e){
	if( !e ) e = window.event;
	
	//달력 버튼 위에 마우스가 있지 않다면 실행하지 않음
	if( !_SheetCalenderBtnOver ) false;
	
	var sheet = null; var sheetRenderer = null; var target = null;
	var trObject = null; var tdObject = null; var inputObject = null;
	var rowIndex = null; var colIndex = null;
	var sheetCssDeclare = null; var sheetTop = null; var sheetLeft = null;
	
	//시트 탐색
	var em = getSrcElement(e);
    while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
    
    if( em.getAttribute("class") == "EasyDataSheet" ){
        sheet = controls["" + em.getAttribute("ctlname")];
        //시트 컨트롤을 못 찾은 경우
        if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	//이벤트 발생 객체
	target = e.target || e.srcElement;
	//이벤트 발생 객체가 일자(날짜) 편집 컨트롤의 달력 버튼인 경우
	if( target.tagName.toLowerCase() == "div" && target.getAttribute("class") == "SheetEidtDateCalender" ){
		tdObject = target.parentNode.parentNode;
		trObject = tdObject.parentNode;
		//
		colIndex = 1 * tdObject.getAttribute("cellIndex");
		rowIndex = 1 * trObject.getAttribute("rowIndex");
		//메모리 해제
		trObject = null; tdObject = null; target = null;
	}
	else{
		//메모리 해제
		target = null; sheet = null; em = null;
		stopEvent(e);
		return false;
	}

//	//시트 메세지 박스 위치 계산
//	for(c = 0, left = 30; c < colIndex; c++) left += sheetRenderer.columnInfo[c].calcCellWidth;
	
	var headerRowCount = sheetRenderer.headerInfo.length;
	var headerColCount = sheetRenderer.colsPerRow;
	var headerStartIndex = headerRowCount - sheetRenderer.rowsPerDataRow;
	var headerRow = null; var headerCol = null;
	var colItem = null; var isCalcCompleted = false; var left = 0;
	var i = 0; var j = 0;
	var r = 0; var c = 0;
	
	//메세지 박스를 띄울 셀의 행, 열 인덱스로 박스의 좌측 위치 계산
	for(i = headerStartIndex, r = 0; i < headerRowCount; i++, r++, headerRow = null){
		headerRow = sheetRenderer.headerInfo[i];
		//행 정보가 없는 경우 예외처리
		if( headerRow == null || typeof headerRow == "undefined" ) continue;
		
		//
		for(j = 0; j < headerColCount; j++, headerCol = null){
			headerCol = headerRow[j];
			//열 정보가 없는 경우 예외처리
			if( headerCol == null || typeof headerCol == "undefined" ) continue;
			
			//열 인덱스와 일치하는 경우 위치 계산
			if( headerCol.cellIndex == colIndex ){
				//시트 메세지 박스 위치 계산
				for(k = 0, left = sheetRenderer.sheetRowHeaderWidth; k < j && k < headerColCount; k++, colItem = null){
					colItem = headerRow[k];
					left += sheetRenderer.columnInfo[colItem.cellIndex].calcCellWidth;
				}
				//위치 계산 완료
				isCalcCompleted = true;
				break;
			}
		}
		
		//계산 완료하였으므로 루프 나감
		if( isCalcCompleted ){
			//메모리 해제
			headerCol = null;
			headerRow = null;
			break;
		}
	}
	
	//시트 달력 호출
	inputObject = document.getElementsByName(sheetRenderer.controlId + "_SheetEidtDateInput")[0];
	sheetRenderer.setSheetCalender(sheetRenderer.columnInfo[colIndex].dateType, "" + inputObject.value);
	inputObject = null;
	
	//시트 달력이 위치한 셀 위치 기록
	sheetRenderer.SheetEditCalenderObject.setAttribute("targetRow", rowIndex);
	sheetRenderer.SheetEditCalenderObject.setAttribute("targetCol", colIndex);
	
	//시트의 Top, Left 위치 기억
	sheetCssDeclare = getComputedStyle(sheetRenderer.SheetObject);
	sheetTop = 1 * ("" + sheetCssDeclare.top).replace("px", "");
	sheetLeft = 1 * ("" + sheetCssDeclare.left).replace("px", "");
	sheetCssDeclare = null;
	
	//달력의 left 위치 계산
	var innerWidth = window.innerWidth;
	var calLeftPos = (left - (isNaN(sheetRenderer.sheetContentTableLeft) ? 0 : sheetRenderer.sheetContentTableLeft));
	var calRightPos = sheetLeft + calLeftPos + 270; /* calender : 270px */
	if( innerWidth <= calRightPos ){
		calLeftPos = calLeftPos - (calRightPos - innerWidth + 1);
	}
	
	//시트 스타일 설정 : 시트 달력의 위치는 시트 위치 + 셀 위치
//	sheetRenderer.SheetEditCalenderObject.style.top = (sheetRenderer.headerHeight + (sheetRenderer.rowHeight * (rowIndex + 1))) + "px";
	sheetRenderer.SheetEditCalenderObject.style.top = (sheetRenderer.headerHeight + (sheetRenderer.rowHeight * ((rowIndex * sheetRenderer.rowsPerDataRow + r) + 1)) + 1) + "px";
	sheetRenderer.SheetEditCalenderObject.style.left = (calLeftPos + "px");
	sheetRenderer.SheetEditCalenderObject.style.display = "block";
	
	//메모리 해제
	left = null; sheet = null; em = null;
	
	stopEvent(e);
    
    return true;
};
//-시트 편집 컨트롤:일자(날짜) 달력버튼 MoueOver 이벤트 처리
function sheetEidtDateCalenderMouseOver(e){
	if( !e ) e = window.event;
	
	//달력 버튼 위에 마우스를 올려놓았을 때 일자(날짜) 텍스트박스의 Blur 이벤트 처리동작을 막기 위한 설정
	_SheetCalenderBtnOver = true;
    
    return true;
}
//-시트 편집 컨트롤:일자(날짜) 달력버튼 MoueOut 이벤트 처리
function sheetEidtDateCalenderMouseOut(e){
	if( !e ) e = window.event;
	
	//마우스가 달력버튼 위에 있지 않을 때 일자(날짜) 텍스트박스의 Blur 이벤트 처리동작을 막지 않기 위한 설정
	_SheetCalenderBtnOver = false;
    
    return true;
};

//-시트 달력:날짜(일자) 달력 Click 이벤트 처리
function sheetDateCalenderClick(e){
	if( !e ) e = window.event;
	
	var em = null;
	var sheet = null;
	var sheetRenderer = null;
	
	var target = null;
	var targetTagName = null;
	var targetClass = null;
	
	var sheetCalenderType = null;
	var times = null;
	var format = null;
	
	var year = null;
	var month = null;
	var day = null;
	var hour = null;
	var minutes = null;
	var seconds = null;
	
	//시트 탐색
	em = getSrcElement(e);
	while( em.getAttribute("class") != "EasySheetCalender" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
	
	if( em.getAttribute("class") == "EasySheetCalender" ){
//		sheet = controls["" + em.getAttribute("targetSheet")];
		sheet = controls[("" + document.getElementsByName(em.getAttribute("targetSheet"))[0].getAttribute("ctlname"))];
        //시트 컨트롤을 못 찾은 경우
        if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; em = null; return false; }
		//시트 편집 달력이 없는 경우
		if( typeof sheet.sheetRenderer.SheetEditCalenderObject == "undefined" || sheet.sheetRenderer.SheetEditCalenderObject == null ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	//클릭한 셀 정보
	target = e.target || e.srcElement;
	targetTagName = "" + target.tagName.toLowerCase();
	targetClass = "" + target.getAttribute("class");
	
	//달력 타입과 연관 시트의 셀 정보
//	sheetCalenderType = 1 * sheetRenderer.SheetEditCalenderObject.getAttribute("calenderType");
	sheetCalenderType = sheetRenderer.columnInfo[1 * sheetRenderer.SheetEditCalenderObject.getAttribute("targetcol")].dateType;
	
	//현재 년도
	year = sheetRenderer.SheetEditCalenderObject.getElementsByClassName("toyear")[0].innerHTML;
	//현재 월
	month = "00" + sheetRenderer.SheetEditCalenderObject.getElementsByClassName("tomonth")[0].getAttribute("month");
	month = month.substring(month.length - 2, month.length);
	//현재 일
	day = "00" + sheetRenderer.SheetEditCalenderObject.getElementsByClassName("today")[0].innerHTML;
	day = day.substring(day.length - 2, day.length);
	//현재 시간
	times = sheetRenderer.SheetEditCalenderObject.getElementsByClassName("TimeCalender")[0].getElementsByTagName("tr")[2].getElementsByTagName("td");
	hour = "00" + (1 * times[0].innerHTML);
	hour = hour.substring(hour.length - 2, hour.length);
	//현재 분
	minutes = "00" + (1 * times[2].innerHTML);
	minutes = minutes.substring(minutes.length - 2, minutes.length);
	//현재 초
	seconds = "00" + (1 * times[4].innerHTML);
	seconds = seconds.substring(seconds.length - 2, seconds.length);
	
	//오늘 버튼 클릭
	if( targetTagName == "th" && targetClass.indexOf("today_btn clickable") >= 0 ){
		sheetRenderer.setSheetCalender(sheetCalenderType, "");
	}
	//이전달 버튼 클릭
	else if( targetTagName == "th" && targetClass.indexOf("prev_month clickable") >= 0 ){
		//현재 월 -1
		month = (1 * month) - 1;
		//현재 월 -1 이 0 인 경우 년도에서 -1 하고 현재 월은 12 로 설정
		if( month == 0){
			year = (1 * year) - 1; month = 12;
		}
		month = "00" + month;
		month = month.substring(month.length - 2, month.length);
		//달력 열기
		sheetRenderer.setSheetCalender(sheetCalenderType, "" + year + month + day + hour + minutes + seconds);
	}
	//다음달 버튼 클릭
	else if( targetTagName == "th" && targetClass.indexOf("next_month clickable") >= 0 ){
		//현재 월 +1
		month = (1 * month) + 1;
		//현재 월 +1 이 13 인 경우 년도에서 +1 하고 현재 월은 1 로 설정
		if( month == 13 ){
			year = (1 * year) + 1; month = 1;
		}
		month = "00" + month;
		month = month.substring(month.length - 2, month.length);
		//달력 열기
		sheetRenderer.setSheetCalender(sheetCalenderType, "" + year + month + day + hour + minutes + seconds);
	}
	//년월 클릭 - 년월 달력으로 변경
	else if( targetTagName == "th" && targetClass.indexOf("year_month clickable") >= 0 ){
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("DateCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("MonthCalender")[0].style.display = "block";
	}
	//시간 버튼 클릭 - 시간 달력으로 변경
	else if( targetTagName == "th" && targetClass.indexOf("time_btn clickable") >= 0 && sheetCalenderType >= 3 ){
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("DateCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("TimeCalender")[0].style.display = "block";
	}
	//달력-일 클릭
	else if( targetTagName == "td" && targetClass.indexOf("clickable") >= 0 ){
		//선택 일자
		day = "00" + target.innerHTML;
		day = day.substring(day.length - 2, day.length);
		//포맷 형식 구함
		switch( sheetCalenderType ){
			case 0: format = "yyyymmdd"; break; //년월일: 0
			case 1: format = "yyyymm"; break; //년월: 1
			case 2: format = "yyyy"; break; //년도: 2
			case 3: format = "yyyymmddHHMMss"; break; //년월일시분초: 3
			case 4: format = "yyyymmddHHMM"; break; //년월일시분: 4
			case 5: format = "yyyymmddHH"; break; //년월일시: 5
			case 6: format = "HHMMss"; break; //시분초: 6
			case 7: format = "HHMM"; break; //시분: 7
			case 8: format = "HH"; break; //시간: 8
			default : format = "yyyymmdd"; //기본값
		}
		//달력 닫기
		sheetRenderer.SheetEditCalenderObject.style.display = "none";
		//시트 날짜(일자) 편집 컨트롤에 선택 날짜 적용
		sheetRenderer.editingCellObject.getElementsByTagName("input")[0].value = EasySheetUtil.formatDate(format, "" + year + month + day + hour + minutes + seconds);
		//시트 날짜(일자) 편집 컨트롤에 선택 날짜 선택 및 포커스
		sheetRenderer.editingCellObject.getElementsByTagName("input")[0].select();
		sheetRenderer.editingCellObject.getElementsByTagName("input")[0].focus();
	}
	
	//메모리 해제
	format = null;
	hour = null; minutes = null; seconds = null; times = null;
	day = null; month = null; year = null;
	sheetCalenderType = null; targetClass = null; targetTagName = null;
	target = null; sheetRenderer = null; sheet = null; em = null;
	
	stopEvent(e);
    
    return true;
}
//-시트 달력:날짜(년월) 달력 Click 이벤트 처리
function sheetMonthCalenderClick(e){
	if( !e ) e = window.event;
	
	var em = null;
	var sheet = null;
	var sheetRenderer = null;
	
	var target = null;
	var targetTagName = null;
	var targetClass = null;
	
	var sheetCalenderType = null;
	var times = null;
	
	var year = null;
	var month = null;
	var day = null;
	var hour = null;
	var minutes = null;
	var seconds = null;
	
	//시트 탐색
	em = getSrcElement(e);
	while( em.getAttribute("class") != "EasySheetCalender" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
	
	if( em.getAttribute("class") == "EasySheetCalender" ){
        sheet = controls[("" + document.getElementsByName(em.getAttribute("targetSheet"))[0].getAttribute("ctlname"))];
        //시트 컨트롤을 못 찾은 경우
        if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; em = null; return false; }
		//시트 편집 달력이 없는 경우
		if( typeof sheet.sheetRenderer.SheetEditCalenderObject == "undefined" || sheet.sheetRenderer.SheetEditCalenderObject == null ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	//클릭한 셀 정보
	target = e.target || e.srcElement;
	targetTagName = "" + target.tagName.toLowerCase();
	targetClass = "" + target.getAttribute("class");
	
	//달력 타입과 연관 시트의 셀 정보
//	sheetCalenderType = 1 * sheetRenderer.SheetEditCalenderObject.getAttribute("calenderType");
	sheetCalenderType = sheetRenderer.columnInfo[1 * sheetRenderer.SheetEditCalenderObject.getAttribute("targetcol")].dateType;
	
	//현재 년도
	year = sheetRenderer.SheetEditCalenderObject.getElementsByClassName("toyear")[0].innerHTML;
	//현재 월
	month = "00" + sheetRenderer.SheetEditCalenderObject.getElementsByClassName("tomonth")[0].getAttribute("month");
	month = month.substring(month.length - 2, month.length);
	//현재 일
	day = "00" + sheetRenderer.SheetEditCalenderObject.getElementsByClassName("today")[0].innerHTML;
	day = day.substring(day.length - 2, day.length);
	//현재 시간
	times = sheetRenderer.SheetEditCalenderObject.getElementsByClassName("TimeCalender")[0].getElementsByTagName("tr")[2].getElementsByTagName("td");
	hour = "00" + (1 * times[0].innerHTML);
	hour = hour.substring(hour.length - 2, hour.length);
	//현재 분
	minutes = "00" + (1 * times[2].innerHTML);
	minutes = minutes.substring(minutes.length - 2, minutes.length);
	//현재 초
	seconds = "00" + (1 * times[4].innerHTML);
	seconds = seconds.substring(seconds.length - 2, seconds.length);
	
	//이전 년도 버튼 클릭
	if( targetTagName == "th" && targetClass.indexOf("prev_btn clickable") >= 0 ){
		//현재 년도 -1
		year = (1 * year) - 1;
		//달력 열기
		sheetRenderer.setSheetCalender(sheetCalenderType, "" + year + month + day + hour + minutes + seconds);
		//월 달력으로 보이도록 설정
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("DateCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("MonthCalender")[0].style.display = "block";
	}
	//다음 년도 버튼 클릭
	else if( targetTagName == "th" && targetClass.indexOf("next_btn clickable") >= 0 ){
		//현재 년도 +1
		year = (1 * year) + 1;
		//달력 열기
		sheetRenderer.setSheetCalender(sheetCalenderType, "" + year + month + day + hour + minutes + seconds);
		//월 달력으로 보이도록 설정
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("DateCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("MonthCalender")[0].style.display = "block";
	}
	//년도 클릭 - 년월 달력으로 변경
	else if( targetTagName == "th" && targetClass.indexOf("year_month clickable") >= 0 ){
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("MonthCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("YearCalender")[0].style.display = "block";
	}
	//달력-월 클릭
	else if( targetTagName == "td" && targetClass.indexOf("clickable") >= 0 ){
		//선택 월
		month = "00" + target.getAttribute("month");
		month = month.substring(month.length - 2, month.length);
		
		//달력 타입이 년월 달력일 경우 편집 컨트롤로 바로 적용, 년월 타입이 아닌 달력은 일자 달력 출력
		if( sheetCalenderType == 1 ){
			//달력 닫기
			sheetRenderer.SheetEditCalenderObject.style.display = "none";
			//시트 날짜(일자) 편집 컨트롤에 선택 날짜 적용
			sheetRenderer.editingCellObject.getElementsByTagName("input")[0].value = EasySheetUtil.formatDate("yyyymm", "" + year + month + day + hour + minutes + seconds);
			//시트 날짜(일자) 편집 컨트롤에 선택 날짜 선택 및 포커스
			sheetRenderer.editingCellObject.getElementsByTagName("input")[0].select();
			sheetRenderer.editingCellObject.getElementsByTagName("input")[0].focus();
		}
		else{
			//달력 열기
			sheetRenderer.setSheetCalender(sheetCalenderType, "" + year + month + day + hour + minutes + seconds);
		}
	}
	
	//메모리 해제
	hour = null; minutes = null; seconds = null; times = null;
	day = null; month = null; year = null;
	sheetCalenderType = null; targetClass = null; targetTagName = null;
	target = null; sheetRenderer = null; sheet = null; em = null;
	
	stopEvent(e);
    
    return true;
};
//-시트 달력:날짜(년도) 달력 Click 이벤트 처리
function sheetYearCalenderClick(e){
	if( !e ) e = window.event;
	
	var em = null;
	var sheet = null;
	var sheetRenderer = null;
	
	var target = null;
	var targetTagName = null;
	var targetClass = null;
	
	var sheetCalenderType = null;
	var times = null;
	var format = null;
	
	var year = null;
	var month = null;
	var day = null;
	var hour = null;
	var minutes = null;
	var seconds = null;
	
	//시트 탐색
	em = getSrcElement(e);
	while( em.getAttribute("class") != "EasySheetCalender" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
	
	if( em.getAttribute("class") == "EasySheetCalender" ){
        sheet = controls[("" + document.getElementsByName(em.getAttribute("targetSheet"))[0].getAttribute("ctlname"))];
        //시트 컨트롤을 못 찾은 경우
        if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; em = null; return false; }
		//시트 편집 달력이 없는 경우
		if( typeof sheet.sheetRenderer.SheetEditCalenderObject == "undefined" || sheet.sheetRenderer.SheetEditCalenderObject == null ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	//클릭한 셀 정보
	target = e.target || e.srcElement;
	targetTagName = "" + target.tagName.toLowerCase();
	targetClass = "" + target.getAttribute("class");
	
	//달력 타입과 연관 시트의 셀 정보
//	sheetCalenderType = 1 * sheetRenderer.SheetEditCalenderObject.getAttribute("calenderType");
	sheetCalenderType = sheetRenderer.columnInfo[1 * sheetRenderer.SheetEditCalenderObject.getAttribute("targetcol")].dateType;
	
	//현재 년도
	year = sheetRenderer.SheetEditCalenderObject.getElementsByClassName("toyear")[0].innerHTML;
	//현재 월
	month = "00" + sheetRenderer.SheetEditCalenderObject.getElementsByClassName("tomonth")[0].getAttribute("month");
	month = month.substring(month.length - 2, month.length);
	//현재 일
	day = "00" + sheetRenderer.SheetEditCalenderObject.getElementsByClassName("today")[0].innerHTML;
	day = day.substring(day.length - 2, day.length);
	//현재 시간
	times = sheetRenderer.SheetEditCalenderObject.getElementsByClassName("TimeCalender")[0].getElementsByTagName("tr")[2].getElementsByTagName("td");
	hour = "00" + (1 * times[0].innerHTML);
	hour = hour.substring(hour.length - 2, hour.length);
	//현재 분
	minutes = "00" + (1 * times[2].innerHTML);
	minutes = minutes.substring(minutes.length - 2, minutes.length);
	//현재 초
	seconds = "00" + (1 * times[4].innerHTML);
	seconds = seconds.substring(seconds.length - 2, seconds.length);
	
	//이전 범위 년도 버튼 클릭
	if( targetTagName == "th" && targetClass.indexOf("prev_btn clickable") >= 0 ){
		//현재 년도 -25
		year = (1 * year) - 25;
		//달력 열기
		sheetRenderer.setSheetCalender(sheetCalenderType, "" + year + month + day + hour + minutes + seconds);
		//년도 달력으로 보이도록 설정
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("DateCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("MonthCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("YearCalender")[0].style.display = "block";
	}
	//다음 범위 년도 버튼 클릭
	else if( targetTagName == "th" && targetClass.indexOf("next_btn clickable") >= 0 ){
		//현재 년도 +25
		year = (1 * year) + 25;
		//달력 열기
		sheetRenderer.setSheetCalender(sheetCalenderType, "" + year + month + day + hour + minutes + seconds);
		//년도 달력으로 보이도록 설정
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("DateCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("MonthCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("YearCalender")[0].style.display = "block";
	}
	//달력-년도 클릭
	else if( targetTagName == "td" && targetClass.indexOf("clickable") >= 0 ){
		//선택 년도
		year = target.innerHTML;
		
		//달력 타입이 년도 달력일 경우 편집 컨트롤로 바로 적용, 년도 타입이 아닌 달력은 년월 달력 출력
		if( sheetCalenderType == 2 ){
			//달력 닫기
			sheetRenderer.SheetEditCalenderObject.style.display = "none";
			//시트 날짜(일자) 편집 컨트롤에 선택 날짜 적용
			sheetRenderer.editingCellObject.getElementsByTagName("input")[0].value = EasySheetUtil.formatDate("yyyy", "" + year + month + day + hour + minutes + seconds);
			//시트 날짜(일자) 편집 컨트롤에 선택 날짜 선택 및 포커스
			sheetRenderer.editingCellObject.getElementsByTagName("input")[0].select();
			sheetRenderer.editingCellObject.getElementsByTagName("input")[0].focus();
		}
		else{
			//달력 열기
			sheetRenderer.setSheetCalender(sheetCalenderType, "" + year + month + day + hour + minutes + seconds);
			//년도 달력으로 보이도록 설정
			sheetRenderer.SheetEditCalenderObject.getElementsByClassName("DateCalender")[0].style.display = "none";
			sheetRenderer.SheetEditCalenderObject.getElementsByClassName("MonthCalender")[0].style.display = "block";
		}
	}
	
	//메모리 해제
	format = null;
	hour = null; minutes = null; seconds = null; times = null;
	day = null; month = null; year = null;
	sheetCalenderType = null; targetClass = null; targetTagName = null;
	target = null; sheetRenderer = null; sheet = null; em = null;
	
	stopEvent(e);
    
    return true;
}
//-시트 달력:날짜(시간) 달력 Click 이벤트 처리
function sheetTimeCalenderClick(e){
	if( !e ) e = window.event;
	
	var em = null;
	var sheet = null;
	var sheetRenderer = null;
	
	var target = null;
	var targetTagName = null;
	var targetClass = null;
	
	var sheetCalenderType = null;
	var times = null;
	var format = null;
	var ndate = null;
	
	var year = null;
	var month = null;
	var day = null;
	var hour = null;
	var minutes = null;
	var seconds = null;
	
	//시트 탐색
	em = getSrcElement(e);
	while( em.getAttribute("class") != "EasySheetCalender" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;
	
	if( em.getAttribute("class") == "EasySheetCalender" ){
        sheet = controls[("" + document.getElementsByName(em.getAttribute("targetSheet"))[0].getAttribute("ctlname"))];
        //시트 컨트롤을 못 찾은 경우
        if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" )  { sheet = null; em = null; return false; }
		//시트 편집 달력이 없는 경우
		if( typeof sheet.sheetRenderer.SheetEditCalenderObject == "undefined" || sheet.sheetRenderer.SheetEditCalenderObject == null ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	//클릭한 셀 정보
	target = e.target || e.srcElement;
	targetTagName = "" + target.tagName.toLowerCase();
	targetClass = "" + target.getAttribute("class");
	
	//달력 타입과 연관 시트의 셀 정보
//	sheetCalenderType = 1 * sheetRenderer.SheetEditCalenderObject.getAttribute("calenderType");
	sheetCalenderType = sheetRenderer.columnInfo[1 * sheetRenderer.SheetEditCalenderObject.getAttribute("targetcol")].dateType;
	
	//현재 년도
	year = sheetRenderer.SheetEditCalenderObject.getElementsByClassName("toyear")[0].innerHTML;
	//현재 월
	month = "00" + sheetRenderer.SheetEditCalenderObject.getElementsByClassName("tomonth")[0].getAttribute("month");
	month = month.substring(month.length - 2, month.length);
	//현재 일
	day = "00" + sheetRenderer.SheetEditCalenderObject.getElementsByClassName("today")[0].innerHTML;
	day = day.substring(day.length - 2, day.length);
	//현재 시간
	times = sheetRenderer.SheetEditCalenderObject.getElementsByClassName("TimeCalender")[0].getElementsByTagName("tr")[2].getElementsByTagName("td");
	hour = "00" + (1 * times[0].innerHTML);
	hour = hour.substring(hour.length - 2, hour.length);
	//현재 분
	minutes = "00" + (1 * times[2].innerHTML);
	minutes = minutes.substring(minutes.length - 2, minutes.length);
	//현재 초
	seconds = "00" + (1 * times[4].innerHTML);
	seconds = seconds.substring(seconds.length - 2, seconds.length);
	
	//일자 달력 버튼 클릭
	if( targetTagName == "th" && targetClass.indexOf("date_btn clickable") >= 0 && sheetCalenderType < 6 ){
		//일자 달력으로 보이도록 설정
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("MonthCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("YearCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("TimeCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("DateCalender")[0].style.display = "block";
	}
	//적용 버튼 클릭
	else if( targetTagName == "th" && targetClass.indexOf("apply_btn clickable") >= 0 ){
		//포맷 형식 구함
		switch( sheetCalenderType ){
			case 0: format = "yyyymmdd"; break; //년월일: 0
			case 1: format = "yyyymm"; break; //년월: 1
			case 2: format = "yyyy"; break; //년도: 2
			case 3: format = "yyyymmddHHMMss"; break; //년월일시분초: 3
			case 4: format = "yyyymmddHHMM"; break; //년월일시분: 4
			case 5: format = "yyyymmddHH"; break; //년월일시: 5
			case 6: format = "HHMMss"; break; //시분초: 6
			case 7: format = "HHMM"; break; //시분: 7
			case 8: format = "HH"; break; //시간: 8
			default : format = "yyyymmdd"; //기본값
		}
		//달력 닫기
		sheetRenderer.SheetEditCalenderObject.style.display = "none";
		//시트 날짜(일자) 편집 컨트롤에 선택 날짜 적용
		sheetRenderer.editingCellObject.getElementsByTagName("input")[0].value = EasySheetUtil.formatDate(format, "" + year + month + day + hour + minutes + seconds);
		//시트 날짜(일자) 편집 컨트롤에 선택 날짜 선택 및 포커스
		sheetRenderer.editingCellObject.getElementsByTagName("input")[0].select();
		sheetRenderer.editingCellObject.getElementsByTagName("input")[0].focus();
	}
	//시, 분, 초의 위 또는 아래방향 삼각형 버튼 클릭
	else if( targetTagName == "td" && targetClass.indexOf("clickable") >= 0 ){
		//현재 시간 +1
		if( targetClass.indexOf("hour_up") >= 0 )			hour = (1 * hour) + 1;
		//현재 시간 -1
		else if( targetClass.indexOf("hour_down") >= 0 )	hour = (1 * hour) - 1;
		//현재 분 +1
		else if( targetClass.indexOf("minutes_up") >= 0 )	minutes = (1 * minutes) + 1;
		//현재 분 -1
		else if( targetClass.indexOf("minutes_down") >= 0 )	minutes = (1 * minutes) - 1;
		//현재 초 +1
		else if( targetClass.indexOf("seconds_up") >= 0 )	seconds = (1 * seconds) + 1;
		//현재 초 -1
		else if( targetClass.indexOf("seconds_down") >= 0 )	seconds = (1 * seconds) - 1;
		
		ndate = new Date(year, (1 * month) - 1, 1 * day, hour, minutes, seconds);
		
		//년도
		year = ndate.getFullYear();
		//월
		month = "00" + (ndate.getMonth() + 1);
		month = month.substring(month.length - 2, month.length);
		//일
		day = "00" + ndate.getDate();
		day = day.substring(day.length - 2, day.length);
		//시간
		hour = "00" + ndate.getHours();
		hour = hour.substring(hour.length - 2, hour.length);
		//분
		minutes = "00" + ndate.getMinutes();
		minutes = minutes.substring(minutes.length - 2, minutes.length);
		//초
		seconds = "00" + ndate.getSeconds();
		seconds = seconds.substring(seconds.length - 2, seconds.length);
		
		//달력 열기
		sheetRenderer.setSheetCalender(3, "" + year + month + day + hour + minutes + seconds);
		
		//시간 달력으로 보이도록 설정
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("DateCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("MonthCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("YearCalender")[0].style.display = "none";
		sheetRenderer.SheetEditCalenderObject.getElementsByClassName("TimeCalender")[0].style.display = "block";
	}
	
	//메모리 해제
	format = null; ndate = null;
	hour = null; minutes = null; seconds = null; times = null;
	day = null; month = null; year = null;
	sheetCalenderType = null; targetClass = null; targetTagName = null;
	target = null; sheetRenderer = null; sheet = null; em = null;
	
	stopEvent(e);
    
    return true;
}

//-시트 버튼 셀타입 : 버튼 Click 이벤트
function sheetButtonClick(e){
	if( !e ) e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	var targetObject = null;
	var trObject = null;
	var tdObject = null;
	var rowIndex = null;
	var colIndex = null;
	var oldRowIndex = null;
	var oldColIndex = null;

	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;

	if( em.getAttribute("class") == "EasyDataSheet" ){
		sheet = controls["" + em.getAttribute("ctlname")];
		//시트 컨트롤을 못 찾은 경우
		if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	if( sheetRenderer.isEditngSheet ){
		//수정 데이터 적용 및 이벤트 처리
		if( !sheetRenderer.setApplyChangedValueToCell(true) ){
			sheetRenderer = null; sheet = null; em = null;
			stopEvent(e);
			return false;
		}
		//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
		sheetRenderer.isIgnoreEditingControlBlurEvent = true;
		//기존의 열려있는 편집 컨트롤을 닫음
		if( !sheetRenderer.removeSheetEditControl() ){
			sheetRenderer = null; sheet = null; em = null;
			stopEvent(e);
			return false; //편집 컨트롤 닫기를 실패한 경우
		}
	}
	
	//클릭한 버튼의 셀 위치를 찾음
	targetObject = e.target;
	//td 객체 탐색
	if( targetObject.tagName.toLocaleLowerCase() == "i" ){
		tdObject = targetObject.parentNode.parentNode.parentNode;
	}
	else if( targetObject.tagName.toLocaleLowerCase() == "button" ){
		tdObject = targetObject.parentNode.parentNode;
	}
	else if( targetObject.tagName.toLocaleLowerCase() == "input" ){
		tdObject = targetObject.parentNode.parentNode;
	}
	else if( targetObject.tagName.toLocaleLowerCase() == "div" ){
		tdObject = targetObject.parentNode;
	}
	else{
		//메모리 해제
		targetObject = null; sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
		return false;
	}
	//tr 객체 탐색
	trObject = tdObject.parentNode;
	
	//이전 행 / 열 인덱스 기억
	oldRowIndex = sheetRenderer.selectedRowIndex;
	oldColIndex = sheetRenderer.selectedColumnIndex;
	
	//행 / 열 인덱스 구함
//	rowIndex = (1 * trObject.getAttribute("rowindex")) + sheetRenderer.showedTopRowIndex;
	rowIndex = 1 * trObject.getAttribute("recordindex");
	colIndex = 1 * tdObject.getAttribute("cellindex");
	
	//셀의 행 인덱스 설정 및 이벤트 호출
	if( !sheetRenderer.setSelectedRowIndex(rowIndex) ){
		//메모리 해제
		trObject = null; tdObject = null; targetObject = null; sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
		return false;
	}
	//셀의 열 인덱스 설정 및 이벤트 호출
	if( !sheetRenderer.setSelectedColumnIndex(colIndex) ){
		//메모리 해제
		trObject = null; tdObject = null; targetObject = null; sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
		return false;
	}
	
	//
	sheetRenderer.setSelectionClass(tdObject);
	
//	//시트 이벤트 : CommandClick 호출(시작)
//	if( sheet.hasCommandClickEvent ){
//		result = sheet.fncCommandClickEvent(rowIndex, colIndex);
//		
//		if( typeof result == "boolean" && result != true ){
//			//메모리 해제
//			result = null;
//			oldRowIndex = null; oldColIndex = null; rowIndex = null; colIndex = null; trObject = null; tdObject = null;
//			targetObject = null; sheetRenderer = null; sheet = null; em = null;
//			//사용자 이벤트 로직 처리 결과에 따라 후동작 처리하지 않음
//			stopEvent(e);
//			return false;
//		}
//	}
//	//시트 이벤트 : CommandClick 호출(종료)
//	
//	//시트 이벤트 후속 처리
//	sheet._catchEvent({event: "cmdclick", row: oldRowIndex, col: oldColIndex, newRow: rowIndex, newCol: colIndex});
	
	//시트 이벤트 처리 및 후속 동작
	sheet._catchEvent({event: "cmdclick", row: oldRowIndex, col: oldColIndex, newRow: rowIndex, newCol: colIndex});
	
	//메모리 해제
	trObject = null; tdObject = null; targetObject = null; sheetRenderer = null; sheet = null; em = null;
	
	stopEvent(e);
    
    return true;
};

//-시트 링크 셀타입 : 링크 MouseUp 이벤트
function sheetLinkMouseUp(e){
	if( !e ) e = window.event;
	
	//시트 본문 테이블의 MouseUp 이벤트를 막기위한 용도
	
	stopEvent(e);
    
    return true;
}
//-시트 링크 셀타입 : 링크 Click 이벤트
function sheetLinkClick(target){
	e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	var trObject = null;
	var tdObject = null;
	var rowIndex = -1;
	var colIndex = -1;
	var oldRowIndex = null;
	var oldColIndex = null;
	
	var url = null;
	var newWindow = null;
	
	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;

	if( em.getAttribute("class") == "EasyDataSheet" ){
		sheet = controls["" + em.getAttribute("ctlname")];
		//시트 컨트롤을 못 찾은 경우
		if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	if( sheetRenderer.isEditngSheet ){
		//수정 데이터 적용 및 이벤트 처리
		if( !sheetRenderer.setApplyChangedValueToCell(true) ){
			sheetRenderer = null; sheet = null; em = null;
			stopEvent(e);
			return false;
		}
		//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
		sheetRenderer.isIgnoreEditingControlBlurEvent = true;
		//기존의 열려있는 편집 컨트롤을 닫음
		if( !sheetRenderer.removeSheetEditControl() ){
			sheetRenderer = null; sheet = null; em = null;
			stopEvent(e);
			return false; //편집 컨트롤 닫기를 실패한 경우
		}
	}
	
	//클릭한 버튼의 셀 위치를 찾음
	if( target.tagName.toLocaleLowerCase() == "a" ){
		tdObject = target.parentNode.parentNode;
		trObject = tdObject.parentNode;
	}
	else{
		//메모리 해제
		sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
		return false;
	}
	
	//이전 행 / 열 인덱스 기억
	oldRowIndex = sheetRenderer.selectedRowIndex;
	oldColIndex = sheetRenderer.selectedColumnIndex;
	
	//행 / 열 인덱스 구함
//	rowIndex = (1 * trObject.getAttribute("rowindex")) + sheetRenderer.showedTopRowIndex;
	rowIndex = 1 * trObject.getAttribute("recordindex");
	colIndex = 1 * tdObject.getAttribute("cellindex");
	
	//셀의 행 인덱스 설정 및 이벤트 호출
	if( !sheetRenderer.setSelectedRowIndex(rowIndex) ){
		//메모리 해제
		trObject = null; tdObject = null; sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
		return false;
	}
	//셀의 열 인덱스 설정 및 이벤트 호출
	if( !sheetRenderer.setSelectedColumnIndex(colIndex) ){
		//메모리 해제
		trObject = null; tdObject = null; sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
		return false;
	}
	
	sheetRenderer.setSelectionClass(tdObject);
	
	//시트 이벤트 : click 호출(시작)
	//Anchor 태그 동작 전 이벤트가 먼저 호출됨
//	if( sheet.hasClickEvent ){
//		//이벤트 호출
//		result = sheet.fncClickEvent(rowIndex, colIndex);
//		
//		//이벤트 결과 처리
//		if( typeof result == "boolean" && result != true ){
//			//메모리 해제
//			result = null;
//			oldRowIndex = null; oldColIndex = null; rowIndex = null; colIndex = null; trObject = null; tdObject = null;
//			sheetRenderer = null; sheet = null; em = null;
//			//사용자 이벤트 로직 처리 결과에 따라 후동작 처리하지 않음
//			stopEvent(e);
//			return false;
//		}
//	}
//	//시트 이벤트 : click 호출(종료)
	
//	//시트 이벤트 후속 처리
//	sheet._catchEvent({event: "click", row: oldRowIndex, col: oldColIndex, newRow: rowIndex, newCol: colIndex});
	
	//시트 이벤트 처리 및 후속 동작
	if( !sheet._catchEvent({event: "click", row: oldRowIndex, col: oldColIndex, newRow: rowIndex, newCol: colIndex}) ){
		//메모리 해제
		trObject = null; tdObject = null; sheetRenderer = null; sheet = null; em = null;
		//사용자 이벤트 로직 처리 결과에 따라 후동작 처리하지 않음
		stopEvent(e);
		return false;
	}
	
	//링크 동작 : 새창 띄우기
	url = sheetRenderer.data[rowIndex][sheetRenderer.columnInfo[colIndex].field];
	newWindow = window.open(url);
	newWindow.focus();
	
	//메모리 해제
	url = null; newWindow = null; trObject = null; tdObject = null;
	sheetRenderer = null; sheet = null; em = null;
	
	stopEvent(e);
	
    return true;
};

//-시트 이미지 셀타입 : 이미지 MouseUp 이벤트
function sheetImageMouseUp(e){
	if( !e ) e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	var target = null;
	var trObject = null;
	var tdObject = null;
	var rowIndex = null;
	var colIndex = null;
	var oldRowIndex = null;
	var oldColIndex = null;
	var result = null;
	
	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;

	if( em.getAttribute("class") == "EasyDataSheet" ){
		sheet = controls["" + em.getAttribute("ctlname")];
		//시트 컨트롤을 못 찾은 경우
		if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; em = null; return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	if( sheetRenderer.isEditngSheet ){
		//수정 데이터 적용 및 이벤트 처리
		if( !sheetRenderer.setApplyChangedValueToCell(true) ){
			sheetRenderer = null; sheet = null; em = null;
			stopEvent(e);
			return false;
		}
		//편집 컨트롤 이동시 Blur 이벤트 발생시키지 않음
		sheetRenderer.isIgnoreEditingControlBlurEvent = true;
		//기존의 열려있는 편집 컨트롤을 닫음
		if( !sheetRenderer.removeSheetEditControl() ){
			sheetRenderer = null; sheet = null; em = null;
			stopEvent(e);
			return false; //편집 컨트롤 닫기를 실패한 경우
		}
	}
	
	//클릭한 버튼의 셀 위치를 찾음
	target = e.target || e.srcElement;
	if( target.tagName.toLocaleLowerCase() == "img" ){
		tdObject = target.parentNode.parentNode;
		trObject = tdObject.parentNode;
	}
	else{
		//메모리 해제
		target = null; sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
		return false;
	}
	
	//이전 행 / 열 인덱스 기억
	oldRowIndex = sheetRenderer.selectedRowIndex;
	oldColIndex = sheetRenderer.selectedColumnIndex;
	
	//행 / 열 인덱스 구함
//	rowIndex = (1 * trObject.getAttribute("rowindex")) + sheetRenderer.showedTopRowIndex;
	rowIndex = 1 * trObject.getAttribute("recordindex");
	colIndex = 1 * tdObject.getAttribute("cellindex");
	
	//셀의 행 인덱스 설정 및 이벤트 호출
	if( !sheetRenderer.setSelectedRowIndex(rowIndex) ){
		//메모리 해제
		trObject = null; tdObject = null; target = null; sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
		return false;
	}
	//셀의 열 인덱스 설정 및 이벤트 호출
	if( !sheetRenderer.setSelectedColumnIndex(colIndex) ){
		//메모리 해제
		trObject = null; tdObject = null; target = null; sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
		return false;
	}
	
	//
	sheetRenderer.setSelectionClass(tdObject);
	
	//시트 이벤트 : click 호출(시작)
	if( sheet.hasImageClickEvent ){
		//이벤트 호출
		result = sheet.fncImageClickEvent(rowIndex, colIndex);
		
		//이벤트 결과 처리
		if( typeof result == "boolean" && result != true ){
			//메모리 해제
			result = null; trObject = null; tdObject = null;
			target = null; sheetRenderer = null; sheet = null; em = null;
			//사용자 이벤트 로직 처리 결과에 따라 후동작 처리하지 않음
			stopEvent(e);
			return false;
		}
	}
	//시트 이벤트 : click 호출(종료)
	
	//시트 이벤트 후속 처리
	sheet._catchEvent({event: "imageclick", row: oldRowIndex, col: oldColIndex, newRow: rowIndex, newCol: colIndex});
	
	//메모리 해제
	result = null; trObject = null; tdObject = null;
	target = null; sheetRenderer = null; sheet = null; em = null;
	
	stopEvent(e);
    
    return true;
}
//-시트 이미지 셀타입 : 이미지 MouseOver 이벤트
function sheetImageMouseOver(target){
	var e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	var trObject = null;
	var tdObject = null;
	var oldRowIndex = null;
	var oldColIndex = null;
	var newRowIndex = null;
	var newColIndex = null;
	var src = null;
	
	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;

	if( em.getAttribute("class") == "EasyDataSheet" ){
		sheet = controls["" + em.getAttribute("ctlname")];
		//시트 컨트롤을 못 찾은 경우
		if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; em = null; stopEvent(e); return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	//마우스가 위치한 이미지의 셀 위치를 찾음
	if( target.tagName.toLocaleLowerCase() == "img" ){
		tdObject = target.parentNode.parentNode;
		trObject = tdObject.parentNode;
	}
	else{
		sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
		return false;
	}
	
	//마우스가 위치한 이미지의 셀의 행 / 열 인덱스 구함
	newRowIndex = trObject.getAttribute("rowindex");
	newColIndex = tdObject.getAttribute("cellindex");
	
	//확대 이미지 설정을 하지 않은 경우
	if( sheetRenderer.columnInfo[newColIndex].zoomImage == false ){
		newColIndex = null; newRowIndex = null;
		trObject = null; tdObject = null;
		sheetRenderer = null; sheet = null; em = null;
		stopEvent(e);
		return false;
	}
	
	//현재 확대 이미지의 이미지 셀의 행 / 열 인덱스 구함
	oldRowIndex = sheetRenderer.SheetZoomImgeBox.getAttribute("rowindex");
	oldColIndex = sheetRenderer.SheetZoomImgeBox.getAttribute("cellindex");
	
	//행 / 열 인덱스가 변했다면 확대 이미지 교체
	if( newRowIndex != oldRowIndex || newColIndex != oldColIndex ){
		//셀의 이미지 소스를 확대 이미지 소스에 설정
		src = target.getAttribute("src");
		sheetRenderer.SheetZoomImgeBox.getElementsByTagName("img")[0].setAttribute("src", src);
		//변경된 행 / 열 인덱스 적용
		sheetRenderer.SheetZoomImgeBox.setAttribute("rowindex", newRowIndex);
		sheetRenderer.SheetZoomImgeBox.setAttribute("cellindex", newColIndex);
		//확대 이미지 위치 이동 및 보이기
		sheetRenderer.SheetZoomImgeBox.style.top = sheetRenderer.headerHeight + (sheetRenderer.rowHeight * ((1 * newRowIndex) + 1)) + "px";
		sheetRenderer.SheetZoomImgeBox.style.left = (e.clientX + 20) + "px";
		sheetRenderer.SheetZoomImgeBox.style.display = "block";
	}
	
	//메모리 해제
	src = null; trObject = null; tdObject = null;
	sheetRenderer = null; sheet = null; em = null;
	
	stopEvent(e);
	
    return true;
};
//-시트 이미지 셀타입 : 이미지 MouseOut 이벤트
function sheetImageMouseOut(e){
	var e = window.event;
	
	var sheet = null;
	var sheetRenderer = null;
	
	//시트 탐색
	var em = getSrcElement(e);
	while( em.getAttribute("class") != "EasyDataSheet" && em.tagName.toLocaleLowerCase() != "body" ) em = em.parentNode;

	if( em.getAttribute("class") == "EasyDataSheet" ){
		sheet = controls["" + em.getAttribute("ctlname")];
		//시트 컨트롤을 못 찾은 경우
		if( sheet == null || typeof sheet == "undefined" || typeof sheet.sheetRenderer == "undefined" ) { sheet = null; em = null; stopEvent(e); return false; }
		//시트 렌더러 설정
		sheetRenderer = sheet.sheetRenderer;
	}
	
	//확대 이미지가 보여지고 있다면 숨김
	if( sheetRenderer.SheetZoomImgeBox.style.display != "none" ){
		//확대 이미지 숨김
		sheetRenderer.SheetZoomImgeBox.style.display = "none";
		//이미지 셀 인덱스 초기화
		sheetRenderer.SheetZoomImgeBox.removeAttribute("rowindex");
		sheetRenderer.SheetZoomImgeBox.removeAttribute("cellindex");
	}
	
	//메모리 해제
	sheetRenderer = null;
	sheet = null;
	em = null;
	
	stopEvent(e);
	
    return true;
}

//-시트 동작가능 패널 : mousedown, mouseup, click, keydown, keyup 이벤트
function sheetSheetDisabledPanelEvent(e){
	//이벤트 버블링 막음
	stopEvent(e);
	return true;
};





/*
 *	EasySheet Validator, Format 등 처리할 수 있는 객체
 */
var EasySheetUtil = {
	/*
	 *	Validator
	 */
	checkValidationInteger : function(value){
		var isValid = false;
		var isIntegerRegx = /^[-|+]?\d+$/;
		
		if( typeof value == "number" ){
			isValid = isIntegerRegx.test("" + value);
		}
		
		isIntegerRegx = null;
		
		return isValid;
	},
	checkValidationDouble : function(value){
		var isValid = false;
		var isDoubleRegx = /^[-|+]?\d+\.?\d*$/;
		
		if( typeof value == "number" ){
			isValid = isDoubleRegx.test("" + value);
		}
		
		isDoubleRegx = null;
		
		return isValid;
	},
	checkValidationBoolean : function(value){
		var isValid = false;
		
		if( typeof value == "boolean" ){
			isValid = true;
		}

		return isValid;
	},
	checkValidationDate : function(dateFormat, value){
		//입력 값이 없다면 체크 안함
		if((value + "").length == 0) return true;
		//날짜형식과 입력 값의 길이가 다르다면 에러처리
		if((dateFormat + "").length != (value + "").length) return false;
		
		value = "" + value;
		
		var isValid = true;
		var idxFmt = -1;
		var year = "1979";	var month = "01";	var day = "01";
		var hour = "00";	var min = "00";		var sec = "00";
		var lastDay = 0;
		
		//년도 추출
		idxFmt = dateFormat.indexOf("yyyy");
		if(idxFmt >= 0){
			year = value.substring(idxFmt, idxFmt + 4);
		}
		//년월 추출
		idxFmt = dateFormat.indexOf("mm");
		if(idxFmt >= 0){
			month = value.substring(idxFmt, idxFmt + 2);
		}
		//일 추출
		idxFmt = dateFormat.indexOf("dd");
		if(idxFmt >= 0){
			day = value.substring(idxFmt, idxFmt + 2);
			if(month * 1 == 1 || month * 1 == 3 || month * 1 == 5 || month * 1 == 7 || month * 1 == 8 || month * 1 == 10 || month * 1 == 12)	lastDay = 31;
			else if(month * 1 == 4 || month * 1 == 6 || month * 1 == 9 || month * 1 == 11)														lastDay = 30;
			else if(month * 1 == 2){
				//윤달 체크
				if(year * 1 % 4 == 0 && year * 1 % 100 != 0 || year * 1 % 400 == 0)	lastDay = 29;
				else																lastDay = 28;
			}
			if( !(day * 1 > 0 && day * 1 <= lastDay) ) isValid = false;
		}
		//시 추출
		idxFmt = dateFormat.indexOf("HH");
		if(idxFmt >= 0){
			hour = value.substring(idxFmt, idxFmt + 2);
		}
		//분 추출
		idxFmt = dateFormat.indexOf("MM");
		if(idxFmt >= 0){
			min = value.substring(idxFmt, idxFmt + 2);
		}
		//초 추출
		idxFmt = dateFormat.indexOf("ss");
		if(idxFmt >= 0){
			sec = value.substring(idxFmt, idxFmt + 2);
		}
		
		//날짜(년월일시분초 포함) 체크
		if( isValid ){
//			isValid = (/^(19[7-9][0-9]|[2-9][0-9]{3})(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])([0-1][0-9]|2[0-3])([0-5][0-9])([0-5][0-9])$/).test(year + month + day + hour + min + sec);
			isValid = (/^(1[0-9]{3}|[2-9][0-9]{3})(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])([0-1][0-9]|2[0-3])([0-5][0-9])([0-5][0-9])$/).test(year + month + day + hour + min + sec);
		}
		
		//매모리 해제
		year = null; month = null; day = null; lastDay = null;
		hour = null; min = null; sec = null;
		
		return isValid;
	},
	
	/*
	 *	Formatter
	 */
	FORMAT_MONTH : [
		{i: "Jan", f: "January"}, {i: "Feb", f: "February"}, {i: "Mar", f: "March"}, {i: "Apr", f: "April"}, {i: "May", f: "May"}, {i: "Jun", f: "June"},
		{i: "Jul", f: "July"}, {i: "Aug", f: "August"}, {i: "Sept", f: "September"}, {i: "Oct", f: "October"}, {i: "Nov", f: "November"}, {i: "Dec", f: "December"}
	],
	FORMAT_WEEK : [
		{k: "일", e: "Sun"}, {k: "월", e: "Mon"}, {k: "화", e: "Tue"}, {k: "수", e: "Wed"}, {k: "목", e: "Thu"}, {k: "금", e: "Fri"}, {k: "토", e: "Sat"}
	],
	format : function(formatString, value){
		//숫자 표시형식만 처리 
		if( formatString.match(/^([0#]{1,3},)?([#0]{3},)*[#0]{3}(\.[#0]+)?$/g) != null ){
			return this.formatNumber(formatString, value);
		}
		//날짜 표시형식만 처리
		else if( (/(yyyy|yy){1}.*(mmmm|mmm|mm|m)?.*(dddd|ddd|dd|d)?.*(HH|H|hh|h)?.*(MM|M)?.*(ss|s)?.*(TT|tt|T|t)?.*/).test(formatString) ){
			return this.formatDate(formatString, value);
		}
		//시간 표시형식만 처리
		else if( (/(HH|H|hh|h){1}.*(MM|M)?.*(ss|s)?.*(TT|tt|T|t)?.*/).test(formatString) ){
			return this.formatTime(formatString, value);
		}
		//기타
		else{
			return (typeof format == "function" ? format(value, formatString) : mask(value, formatString));
		}
	},
	formatNumber: function(formatString, value){
		var paddingZero = "000000000000000000000000000000";
		var dotIndex = 0;
		var formatStrBeforeDot = null;
		var formatStrAfterDot = null;
		var rValueBeforeDot = null;
		var rValueAfterDot = null;

		var lengthGapFmtAndVal = 0;
		var zeroIndex = 0;
		var cutCount = 0;
		var i = 0;

		var plusOrMinusSign = "";
		var rValue = "";

		value = "" + value;
		if( (/^[-|+]{1}/).test(value) ){
			plusOrMinusSign = value.substring(0, 1);
			value = value.substring(1);
		}

		dotIndex = formatString.indexOf(".");
		formatStrBeforeDot = (dotIndex < 0) ? formatString : formatString.substring(0, dotIndex);
		formatStrAfterDot = (dotIndex < 0) ? null : formatString.substring(dotIndex + 1, formatString.length);

		dotIndex = value.indexOf(".");
		rValueBeforeDot = ((dotIndex < 0) ? value : value.substring(0, dotIndex));

		lengthGapFmtAndVal = formatStrBeforeDot.replace(/[^0#]/g, "").length - rValueBeforeDot.length;

		if( lengthGapFmtAndVal > 0 ){
			rValueBeforeDot = paddingZero.substring(0, lengthGapFmtAndVal) + rValueBeforeDot;
			
			zeroIndex = formatStrBeforeDot.indexOf("0");
			if( zeroIndex < 0 ){
				rValue = rValueBeforeDot * 1;
				rValue = (rValue == 0) ? "" : ("" + rValue).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
			}
			else{
				rValueBeforeDot = rValueBeforeDot.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
				
				for(i = zeroIndex - 1, cutCount = 0; i >= 0; i--){
					if( (formatStrBeforeDot.charAt(i) == '#' && rValueBeforeDot.charAt(i) == '0') || (formatStrBeforeDot.charAt(i) == ',' && rValueBeforeDot.charAt(i) == ',') ) cutCount++;
					else cutCount = 0;
				}
				
				rValue = rValueBeforeDot.substring(cutCount, rValueBeforeDot.length);
			}
		}
		else if( lengthGapFmtAndVal < 0 ){
			rValue = rValueBeforeDot.substring(0, (lengthGapFmtAndVal * -1));
			rValueBeforeDot = rValueBeforeDot.substring((lengthGapFmtAndVal * -1), rValueBeforeDot.length);
			rValueBeforeDot = rValueBeforeDot.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
			rValue = rValue + rValueBeforeDot;
		}
		else{
			rValueBeforeDot = rValueBeforeDot.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
			rValue = rValueBeforeDot;
		}

		if( formatStrAfterDot != null ){
			rValueAfterDot = (dotIndex < 0) ? "" : value.substring(dotIndex + 1, value.length);

			lengthGapFmtAndVal = formatStrAfterDot.replace(/[^0#]/g, "").length - rValueAfterDot.length;

			if( lengthGapFmtAndVal > 0 ){
				rValueAfterDot = rValueAfterDot + paddingZero.substring(0, lengthGapFmtAndVal);
			}
			else if( lengthGapFmtAndVal < 0 ){
				rValueAfterDot = rValueAfterDot.substring(0, rValueAfterDot.length + lengthGapFmtAndVal);
			}
			else{
				rValueAfterDot = rValueAfterDot;
			}

			zeroIndex = formatStrAfterDot.lastIndexOf("0");
			if( zeroIndex < 0 ){
				rValue = rValue + (rValueAfterDot.replace(/0+$/, "").length > 0 ? "." + rValueAfterDot.replace(/0+$/, "") : rValueAfterDot.replace(/0+$/, ""));
			}
			else{
				rValue = rValue + "." + rValueAfterDot.substring(0, zeroIndex + 1) + rValueAfterDot.substring(zeroIndex + 1, rValueAfterDot.length).replace(/0+$/, "");
			}
		}
		
		rValue = plusOrMinusSign + rValue;
		
		//메모리 해제
		rValueBeforeDot = null; rValueAfterDot = null;
		formatStrBeforeDot = null; formatStrAfterDot = null;
		plusOrMinusSign = null;
		paddingZero = null;

		return rValue;
	},
	formatDate : function(formatString, value){
		if( (value + "").length == 0 ){
			return "";
		}

		var year = "0000";	var month = "01";	var day = "01";
		var hour = "00";	var min = "00";		var sec = "00";
		var dt = null;		var rDate = null;
		
		if(formatString.indexOf("mmmm") >= 0)	formatString = formatString.replace(/mmmm/g, "{nn_f}");
		if(formatString.indexOf("mmm") >= 0)	formatString = formatString.replace(/mmm/g, "{nn_i}");
		if(formatString.indexOf("dddd") >= 0)	formatString = formatString.replace(/dddd/g, "{ww_e}");
		if(formatString.indexOf("ddd") >= 0)	formatString = formatString.replace(/ddd/g, "{ww_k}");
		
		rDate = formatString;
		year  = value.substring(0, 4) + "";
		month = value.substring(4, 6) + "";
		day   = value.substring(6, 8) + "";
		hour  = value.substring(8, 10) + "";
		min   = value.substring(10, 12) + "";
		sec   = value.substring(12, 14) + "";
		dt	  = new Date(year + "-" + month + "-" + ((1 * day) - 1));

		if(formatString.indexOf("yyyy") >= 0)	rDate = rDate.replace(/yyyy/g, year);
		if(formatString.indexOf("yy") >= 0)		rDate = rDate.replace(/yy/g, (year.substring(2, 4)));
//		if(formatString.indexOf("{nn_f}") >= 0)	rDate = rDate.replace(/\{nn_f\}/g, (this.FORMAT_MONTH[(month * 1) - 1].f));
//		if(formatString.indexOf("{nn_i}") >= 0)	rDate = rDate.replace(/\{nn_i\}/g, (this.FORMAT_MONTH[(month * 1) - 1].i));
		if(formatString.indexOf("mm") >= 0)		rDate = rDate.replace(/mm/g, month);
		if(formatString.indexOf("m") >= 0)		rDate = rDate.replace(/m/g, (month * 1));
//		if(formatString.indexOf("{ww_e}") >= 0)	rDate = rDate.replace(/\{ww_e\}/g, (this.FORMAT_WEEK[dt.getDay()].e));
//		if(formatString.indexOf("{ww_k}") >= 0)	rDate = rDate.replace(/\{ww_k\}/g, (this.FORMAT_WEEK[dt.getDay()].k));
		if(formatString.indexOf("dd") >= 0)		rDate = rDate.replace(/dd/g, day);
		if(formatString.indexOf("d") >= 0)		rDate = rDate.replace(/d/g, (day * 1));
		if(formatString.indexOf("HH") >= 0)		rDate = rDate.replace(/HH/g, hour);
		if(formatString.indexOf("H") >= 0)		rDate = rDate.replace(/H/g, (hour * 1));
		if(formatString.indexOf("hh") >= 0){
			var h = hour * 1 > 12 ? (hour * 1) - 12 : (hour * 1 == 0 ? 12 : (hour * 1));
			rDate = rDate.replace(/hh/g,  (h < 10 ? "0" + h : "" + h));
		}
		if(formatString.indexOf("h") >= 0)		rDate = rDate.replace(/h/g,  (hour * 1 > 12 ? (hour * 1) - 12 : (hour * 1 == 0 ? 12 : (hour * 1))));
		if(formatString.indexOf("MM") >= 0)		rDate = rDate.replace(/MM/g, min);
		if(formatString.indexOf("M") >= 0)		rDate = rDate.replace(/M/g, (min * 1));
		if(formatString.indexOf("ss") >= 0)		rDate = rDate.replace(/ss/g, sec);
		if(formatString.indexOf("s") >= 0)		rDate = rDate.replace(/s/g, (sec * 1));
		if(formatString.indexOf("TT") >= 0)		rDate = rDate.replace(/TT/g, (hour * 1 > 12 ? "PM" : "AM"));
		if(formatString.indexOf("tt") >= 0)		rDate = rDate.replace(/tt/g, (hour * 1 > 12 ? "pm" : "am"));
		if(formatString.indexOf("T") >= 0)		rDate = rDate.replace(/T/g, (hour * 1 > 12 ? "p" : "a"));
		if(formatString.indexOf("t") >= 0)		rDate = rDate.replace(/t/g, (hour * 1 > 12 ? "오후" : "오전"));
		if(formatString.indexOf("{nn_f}") >= 0)	rDate = rDate.replace(/\{nn_f\}/g, (this.FORMAT_MONTH[(month * 1) - 1].f));
		if(formatString.indexOf("{nn_i}") >= 0)	rDate = rDate.replace(/\{nn_i\}/g, (this.FORMAT_MONTH[(month * 1) - 1].i));
		if(formatString.indexOf("{ww_e}") >= 0)	rDate = rDate.replace(/\{ww_e\}/g, (this.FORMAT_WEEK[dt.getDay()].e));
		if(formatString.indexOf("{ww_k}") >= 0)	rDate = rDate.replace(/\{ww_k\}/g, (this.FORMAT_WEEK[dt.getDay()].k));
		
		//메모리 해제
		dt = null; sec = null; min = null; hour = null;
		day = null; month = null; year = null;
		
		return rDate;
	},
	formatTime : function(formatString, value){
		if( (value + "").length == 0 ){
			return "";
		}

		var hour = "00";	var min = "00";		var sec = "00";
		var rDate = formatString;

		hour  = value.substring(0, 2) + "";
		min   = value.substring(2, 4) + "";
		sec   = value.substring(4, 6) + "";

		if(formatString.indexOf("HH") >= 0)		rDate = rDate.replace(/HH/g, hour);
		if(formatString.indexOf("H") >= 0)		rDate = rDate.replace(/H/g, (hour * 1));
		if(formatString.indexOf("hh") >= 0){
			var h = hour * 1 > 12 ? (hour * 1) - 12 : (hour * 1 == 0 ? 12 : (hour * 1));
			rDate = rDate.replace(/hh/g,  (h < 10 ? "0" + h : "" + h));
		}
		if(formatString.indexOf("h") >= 0)		rDate = rDate.replace(/h/g,  (hour * 1 > 12 ? (hour * 1) - 12 : (hour * 1 == 0 ? 12 : (hour * 1))));
		if(formatString.indexOf("MM") >= 0)		rDate = rDate.replace(/MM/g, min);
		if(formatString.indexOf("M") >= 0)		rDate = rDate.replace(/M/g, (min * 1));
		if(formatString.indexOf("ss") >= 0)		rDate = rDate.replace(/ss/g, sec);
		if(formatString.indexOf("s") >= 0)		rDate = rDate.replace(/s/g, (sec * 1));
		if(formatString.indexOf("TT") >= 0)		rDate = rDate.replace(/TT/g, (hour * 1 > 12 ? "PM" : "AM"));
		if(formatString.indexOf("tt") >= 0)		rDate = rDate.replace(/tt/g, (hour * 1 > 12 ? "pm" : "am"));
		if(formatString.indexOf("T") >= 0)		rDate = rDate.replace(/T/g, (hour * 1 > 12 ? "p" : "a"));
		if(formatString.indexOf("t") >= 0)		rDate = rDate.replace(/t/g, (hour * 1 > 12 ? "오후" : "오전"));
		
		//메모리 해제
		sec = null; min = null; hour = null;
		day = null; month = null; year = null;
		
		return rDate;
	}
};





/*
 *	시트 피봇 다시 그리기 관련 함수
 */
EasySheet.prototype.createPivotSheet = function(needReset){
	//시트 렌더러 및 html 태그 클리어
	this._ClearSheetHtmlTag();
	
	var sheetObj = this.tagObject;
	var sheetPivot = this.pivot;
	var rowsPerDataRow = this.displayInfo.rowsPerDataRow;
	var leftFixedCount =  this.displayInfo.leftFrozens;
	var rightFixedCount = this.displayInfo.rightFrozens;
	var columnCount = this.columns.length;
	var pivotCaptionsCount = this._pivotCaptionSettings.length;
	var cellCount = sheetPivot._pivotCaptions[sheetPivot._pivotCaptions.length - 1].length;
	
	//피봇 캡션 컬럼의 수가 1개이며 비어있을 때, 시트의 추가헤더의 행 수는 1행으로 설정
	if( cellCount == 1 ){
		var _pivotCaption = (sheetPivot._pivotCaptions[sheetPivot._pivotCaptions.length - 1])[0];
		//시트 추가헤더의 행 수는 1행으로 설정
		if( _pivotCaption.trim().length == 0 ){
			pivotCaptionsCount = 1;
		}
		//메모리 해제
		_pivotCaption = null;
	}
	
	//태그 초기화
	this._InitSheetHtmlTag(rowsPerDataRow, pivotCaptionsCount);
	
	//셀 너비 설정
	var sheetHdObj = sheetObj.querySelector("div.SheetDiv > div.SheetHeader");
	var cellWidth = null; var cellMinWidth = null; var exoCol = null;
	
	//시트 헤더 객체에 셀 너비 설정
	for(i = 0, cellWidth = [], cellMinWidth = []; i < this.maxCols; i++){
		exoCol = this.columns[i];
		cellWidth.push(exoCol.width);
		cellMinWidth.push(exoCol.minWidth);
		exoCol = null;
	}
	sheetHdObj.setAttribute("cellwidths", cellWidth.join(";"));
	sheetHdObj.setAttribute("cellminwidths", cellMinWidth.join(";"));
	//메모리 해제
	cellMinWidthItems = null; cellMinWidths = null;
	cellWidthItems = null; cellWidths = null;
	
	//추가헤더 셀 및 헤더 컬럼 추가
	var rows = sheetObj.querySelectorAll("div.SheetDiv > div.SheetHeader > div.SheetHeaderDiv > table > tbody > tr");
	var row = null; var cell = null; var div = null;
	var hdCells = null; var hdCell = null;
	var column = null; var minWidth = null;
	var colspanMax = 0; var colspanSum = 0;
	var i = 0; var j = 0;
	
	//추가헤더
	for(i = 0; i < pivotCaptionsCount; i++){
		//셀 캡션 및 병합 정보
		hdCells = this._pivotCaptionSettings[i];
		cellCount = hdCells.length;
		//셀을 추가할 행
		row = rows[i];
		//추가헤더 셀 추가
		for(j = 0, colspanSum = 0; j < cellCount; j++){
			hdCell = hdCells[j];
			//colspan 총 합 계산
			colspanSum += hdCell.colspan;
			//셀 생성
			cell = this._CreateCell();
			if( hdCell.rowspan > 1 && pivotCaptionsCount > 1 ) cell.rowSpan = hdCell.rowspan; 
			if( hdCell.colspan > 1 && pivotCaptionsCount > 1 ) cell.colSpan = hdCell.colspan;
			cell.setAttribute("class", "AddColHead");
			div = cell.querySelector("div");
			div.innerHTML = "" + hdCell.caption;
			//셀 추가
			row.appendChild(cell);
			//메모리 해제
			div = null; cell = null; hdCell = null;
		}
		//메모리 해제
		row = null; hdCells = null;
		//최대 열 갯수 체크
		if( colspanSum > colspanMax ) colspanMax = colspanSum;
	}
	//헤더
	row = rows[rows.length - 1];
	//헤더 컬럼 셀 추가
	for(i = 0; i < columnCount; i++){
		column = this.columns[i];
		//
		column.width = cellWidth[i];
		column.minWidth = minWidth = cellMinWidth[i];
		//셀 생성
		cell = this._CreateCell("th");
		cell.style.width = minWidth;
		cell.style.minWidth = minWidth;
		div = cell.querySelector("div");
		div.style.width = minWidth;
		div.innerHTML = "" + column.caption;
		//셀 추가
		row.appendChild(cell);
		//메모리 해제
		div = null; cell = null;
		minWidth = null; column = null;
	}
	//메모리 해제
	row = null; rows = null;
	
	//바디 컬럼 추가
	row = sheetObj.querySelector("div.SheetDiv > div.SheetContent > div.SheetContentDiv > table > tbody > tr");
	//바디
	for(i = 0; i < columnCount; i++){
		column = this.columns[i];
		minWidth = cellMinWidth[i];
		//셀 생성
		cell = this._CreateCell("td", false);
		cell.setAttribute("cellindex", "" + i);
		cell.style.width = minWidth;
		cell.style.minWidth = minWidth;
		div = cell.querySelector("div");
		div.style.width = minWidth;
		//셀 추가
		row.appendChild(cell);
		//메모리 해제
		div = null; cell = null;
		minWidth = null; column = null;
	}
	
	//최대 열 갯수 설정
	sheetObj.setAttribute("colsperrow", "" + colspanMax);
	
	//좌고정, 우고정 컬럼 수 설정
	if( leftFixedCount > 0 ) sheetObj.setAttribute("leftfixedcount", "" + leftFixedCount);
	if( rightFixedCount > 0 ) sheetObj.setAttribute("rightfixedcount", "" + rightFixedCount);
	
	//메모리 해제
	cellWidth.clear(); cellWidth = null;
	cellMinWidth.clear(); cellMinWidth = null;
	row = null; sheetHdObj = null; sheetPivot = null; sheetObj = null;
	
	//시트 렌더러 설정 및 출력
	this._SetSheetRenderer(needReset);
	
	//시트 추가 설정 : 시트에 설정된 속성들을 렌더러로 설정
	var sheetRenderer = this.sheetRenderer;
	sheetRenderer.setEnabled(this.enabled);								//동작가능
	sheetRenderer.setVisible(this.visible);								//보이기
	sheetRenderer.setPermitEditable(this.permitEditable);				//편집가능
	sheetRenderer.setPermitCellResize(this.permitCellResize);			//사이즈조정
	sheetRenderer.setPermitEditFixedColumn(this.permitEditFixedColumn);	//고정셀수정가능
	sheetRenderer.setWheelMovementRows(this.wheelMovementRows);			//마우스휠반응도
	sheetRenderer.setUseContextMenu(this.useContextMenu);				//팝업메뉴
	sheetRenderer.setTabKeyAction(this.tabKeyAction);					//탭키동작
	sheetRenderer.setSortOnHeader(this.sortOnHeaderClick);				//선택정렬
	sheetRenderer.setRowColHeaderTitle(this.rowColHeaderTitle);			//행열타이틀
	sheetRenderer.setRowNumOrder(this.rowNumOrder);						//역순행번호
	sheetRenderer.setDisplayScrollBar(this.displayScrollBar);			//스크롤바 보이기
	sheetRenderer.setDisplayOddEven(this.displayOddEven);				//줄색깗구분
	sheetRenderer.isListSheet = ((this.tagObject.getAttribute("islistsheet") == "true") ? true : false);
	sheetRenderer.selectMode = (this.isListSheet ? SHEET_SELECT_ROW : SHEET_SELECT_CELL);
	sheetRenderer = null;
	
	return;
};

EasySheet.prototype._SetSheetRenderer = function(needReset){
	var json = null;
	var oldUpdateControl = this.instantUpdateControl;
	
	//시트 렌더러 초기화
	this.sheetRenderer = new EasySheetRenderer(this.controlId, this.controlName, this.tagObject);
	
	//시트 렌더러에 시트 데이터셋 연결 
	this.sheetRenderer.dataSet = this.dataSet;
	
	// 시트 디자인 속성
	this.displayRowCount = this.sheetRenderer.displayMaxRowCount;
	this.displayInfo.endRow = this.displayRowCount - 1;
	this.displayInfo.dataCount = this.displayRowCount;
	this.displayInfo.rowsPerDataRow = this.sheetRenderer.rowsPerDataRow;
	
	//시트 컬럼 정보 렌더러에 적용
	this.instantUpdateControl = false;
	this.refreshColumns();
	this.instantUpdateControl = oldUpdateControl;
	
	//화면상 시트갱신, 데이터만 갱신
	json = {
		displayInfo: this.displayInfo
		, columns: []
		, footers: this.pivot.footerInfos
	};
	
	this.columns.forEach(
		function(column, colIndex){
			json.columns.push({
				colId : column.colId,
				colIndex : colIndex,		// 0부터 시작
				cellType : column.cellType,
				sheetRow : column.sheetRow,
				sheetCol : column.sheetCol,
				sheetRowSpan : column.sheetRowSpan,
				sheetColSpan : column.sheetColSpan
			});
		}, this);
	
	this.sheetRenderer.update(json, needReset);
	
	//메모리 해제
	//푸터
	if( typeof json.footers != "undefined" && json.footers != null ){
		json.footers = null;
	}
	//컬럼
	if( typeof json.columns != "undefined" && json.columns != null ){
		json.columns.clear();
		json.columns = null;
	}
	//디스플레이 정보
	json.displayInfo = null;
	json = null;
};

EasySheet.prototype._InitSheetHtmlTag = function(headerRowCount, addHeaderRowCount){
	//헤더 행 수가 숫자가 아니면 1 행으로 설정
	if( typeof headerRowCount != "number" ){
		headerRowCount = 1;
	}
	//헤더 행 수가 숫자이지만 1보다 작은 경우 1행으로 설정(최소 행 수 : 1)
	headerRowCount = (headerRowCount < 1) ? 1 : headerRowCount;
	
	//추가 헤더 행 수가 숫자가 아니면 0 행으로 설정
	if( typeof addHeaderRowCount != "number" ){
		addHeaderRowCount = 0;
	}
	//추가 해더 행 수가 숫자이지만 0보다 작은 경우 0행으로 설정(최소 행 수 : 0)
	addHeaderRowCount = (addHeaderRowCount < 0) ? 0 : addHeaderRowCount;
	
	var totalCount = headerRowCount + addHeaderRowCount;
	
	var sheetObj = this.tagObject;
	var objs = null; var obj = null; var tbody = null;
	var rows = null; var row = null; var cell = null; var div = null;
	var className = null; var classList = null; var isRightFix = false;
	var count = 0; var i = 0; var j = 0;
	
	//헤더 행 추가
	objs = sheetObj.querySelectorAll("div.SheetDiv > div.SheetHeader > div");
	
	for(i = 0, count = objs.length; i < count; i++){
		obj = objs[i];
		
		//우측고정열인지 체크
		className = obj.className;
		classList = className.split(" ");
		isRightFix = (classList.indexOf("SheetHeaderRightFixDiv") >= 0);
		
		//행 추가
		tbody = obj.querySelector("table > tbody");
		
		for(j = 0; j < totalCount; j++, row = null){
			row = document.createElement("tr");
			tbody.appendChild(row);
		}
		
		//우측고정열이 아닌 경우 행열타이틀 추가
		if( !isRightFix ){
			rows = tbody.querySelectorAll("tr");
			
			//추가 헤더 첫번째 행에 추가
			row = rows[0];
			//셀 생성 및 설정
			cell = this._CreateCell("th", false);
			if(totalCount > 1) cell.setAttribute("rowspan", "" + totalCount);
			cell.setAttribute("class", "RowHeader");
			cell.style.width = "40px";
			cell.style.minWidth = "40px";
			div = cell.querySelector("div");
			div.style.width = "40px";
			//셀 추가
			row.appendChild(cell);
			//메모리 해제
			div = null; cell = null; row = null;
			
			//헤더 첫번째 행에 추가
			if( totalCount > headerRowCount ){
				row = rows[totalCount - headerRowCount];
				//셀 생성 및 설정
				cell = this._CreateCell("th", false);
				if( headerRowCount > 1 ) cell.setAttribute("rowspan", "" + headerRowCount);
				cell.setAttribute("class", "RowHeader");
				cell.style.display = "none";
				div = cell.querySelector("div");
				div.style.width = "40px";
				//셀 추가
				row.appendChild(cell);
				//메모리 해제
				div = null; cell = null; row = null;
			}
			
			//메모리 해제
			rows = null;
		}
		
		//메모리 해제
		tbody = null; classList = null; className = null; obj = null;
	}
	
	//메모리 해제
	objs = null;
	
	//바디 행 추가
	objs = sheetObj.querySelectorAll("div.SheetDiv > div.SheetContent > div");
	
	for(i = 0, count = objs.length; i < count; i++){
		obj = objs[i];
		
		//우측고정열인지 체크
		className = obj.className;
		classList = className.split(" ");
		isRightFix = (classList.indexOf("SheetHeaderRightFixDiv") >= 0);
		
		//행 추가
		tbody = obj.querySelector("table > tbody");
		
		for(j = 0; j < headerRowCount; j++, row = null){
			row = document.createElement("tr");
			row.setAttribute("class", "odd-num-row");
			row.setAttribute("rowindex", "0");
			tbody.appendChild(row);
		}
		
		//우측고정열이 아닌 경우 행열타이틀 추가
		if( !isRightFix ){
			rows = tbody.querySelectorAll("tr");
			
			//추가 헤더 첫번째 행에 추가
			row = rows[0];
			//셀 생성 및 설정
			cell = this._CreateCell("td", false);
			cell.setAttribute("class", "RowHeader");
			cell.style.width = "40px";
			cell.style.minWidth = "40px";
			div = cell.querySelector("div");
			div.style.width = "40px";
			div.innerHTML = "1";
			//셀 추가
			row.appendChild(cell);
			
			//메모리 해제
			div = null; cell = null; row = null; rows = null;
		}
		
		//메모리 해제
		tbody = null; classList = null; className = null; obj = null;
	}
	
	//메모리 해제
	objs = null;
	sheetObj = null;
};

EasySheet.prototype._CreateCell = function(tagName, hasResizer){
	//예외처리 : 태그명(기본값 : td)
	if( tagName !== "td" && tagName !== "th" ) tagName = "td";
	//예외처리 : 리사이저(기본값 : true)
	if( typeof hasResizer != "boolean" ) hasResizer = true;
	
	var cell = document.createElement(tagName);
	var div = null;
	
	//텍스트 div 추가
	div = document.createElement("div");
	cell.appendChild(div);
	div = null;
	
	//리사이저 div 추가
	if( hasResizer ){
		div = document.createElement("div");
		div.setAttribute("class", "resizer");
		cell.appendChild(div);
		div = null;
	}
	
	return cell;
};

EasySheet.prototype._ClearSheetHtmlTag = function(){
	//시트 렌더러 해제
	if( this.sheetRenderer != null ){
		this.sheetRenderer.destroy();
		this.sheetRenderer = null;
	}
	
	var sheetObj = this.tagObject;
	var objs = null; var obj = null;
	var rows = null; var row = null;
	var cells = null; var cell = null;
	var divs = null; var div = null;
	var count = 0;
	var i = 0; var j = 0; var k = 0; var l = 0;
	
	//헤더 클리어
	objs = sheetObj.querySelectorAll( "div.SheetDiv > div.SheetHeader > div > table"		/* 헤더 */
									+ ", div.SheetDiv > div.SheetContent > div > table" );	/* 본문 */
	
	//행,셀 등 자식객체 제거
	for(i = 0, count = objs.length; i < count; i++){
		obj = objs[i];
		rows = obj.querySelectorAll("tr");
		
		for(j = rows.length - 1; j >= 0; j--, row = null){
			row = rows[j];
			cells = row.children;
			
			//행 객체의 셀 객체 제거
			for(k = cells.length - 1; k >= 0; k--, cell = null){
				cell = cells[k];
				divs = cell.children;
				
				//셀 객체의 자식 객체 제거
				for(l = divs.length - 1; l >= 0; l--, div = null){
					headerCellDiv = divs[l];
					//자식 객체 제거
					cell.removeChild(headerCellDiv);
				}
				
				//메모리 해제
				divs = null;
				
				//셀 제거
				row.removeChild(cell);
			}
			
			//메모리 해제
			cells = null;
			
			//행 제거
			row.parentNode.removeChild(row);
		}
		
		//메모리 해제
		rows = null;
		obj = null;
	}
	
	//메모리 해제
	objs = null;
	sheetObj = null;
};/*******************************************************************************
* 데이터시트 콘트롤의 정의 부분이다 인수로는 콘트롤 명과 , 테그객체를 갖는다 용어의 정의: LogicalRow: ColSpan과
* 여러줄처리를 감안한 논리적 줄번호 (1 ~) SheetRow : HeadColumn을 포함하지 않는 순수 데이터셀의 줄번호(1 ~)
* HardRow : HeadColumn을 포함하는 테이블 테그내 줄번호(0 ~)
* 
* Sheet : 자식 테이블들을 포함하는 콘트롤 단위의 개념(DIV) Table : 시트내 각각의 자식 테이블 단위의 개념(TABLE)
******************************************************************************/
/*
* 시트동작에 필요한 상수
*/
// Sort 에 필요한 상수
// 시트타입 구분에 사용하는 변수
var SHEETTYPE_DataSheet = 1;
var SHEETTYPE_LISTSHEET = 2;

// 시트채우기 모드
var SHEETMODE_SETCELL = 1;
var SHEETMODE_SETDATA = 2;

function AUIDataSheet(controlId, controlName, tagObject) // constructor
{
	// 변수 선언부
    this.controlName = controlName || "";   
    this.controlId   = controlId || "";
    this.AUIcontrolId = "AUI_" + controlId;
    this.id   = this.controlId; //콘트롤 아이디와 같다.
    this.tagObject = tagObject || null;
    this.sheetType = SHEETTYPE_DataSheet;
    this.linkedObjects = []; //연결된 콘트롤
    
    //style 정보
    if (this.tagObject){
	    this.enabled = !(this.tagObject.disabled ? this.tagObject.disabled : (this.tagObject.getAttribute("disabled") ? this.tagObject.getAttribute("disabled") : true));
	    this.visible = (getStyle(this.tagObject).display ? getStyle(this.tagObject).display != "none" : (getStyle(this.tagObject).left ? getStyle(this.tagObject).left != "-10000px" : true));
	    this.zIndex = (getStyle(this.tagObject).zIndex ? getStyle(this.tagObject).zIndex : 0);
    }
    
    // DataSet 정보
    this.rows = [null];  // Logical 데이터가 1번 배열부터 들어간다는 의미
    this.dataValues = []; // 내부
    this.defaultData = []; // 디폴트 데이터(json)
    this.notSetValue = false; // true 일때 setValue 함수 동작하지 않음
    this.fillKeyField = false; // 시트에 연결된 객체가 화면채우기키 설정이 되어있다면 시트에서 setValue, cellChange, clear 를 하지 않는다.
    this.fillJobName = null; // lazy loding 사용시에 해당 fillJob 이름
    this.pageNum = 2; // lazy loding 사용시에 해당 recordset의 pageNum 저장한다.
    this.defaultLayoutValue = "({})"; // 줄추가할때마다 들어갈 디폴트 값
    this.defaultLayoutValue_JSON = {}; // 줄추가할때마다 들어갈 디폴트 값: JSON 
    
    this.applyRestPercentWidth = false;
    this.defaultColumnSize = []; //열 너비 정보 배열
    
    this.inClearMode = false;
    
    // 초기동작
    this.inputMode = SHEETMODE_SETCELL; // SHEETMODE_SETCELL : GUI 만 수정, SHEETMODE_SETDATA : GUI 는 수정 안되고 데이터 만 채운다.
    
    // 시트의 외양에 관한 변수들
    this.headRows = 1;       // Physical
    this.headCols = 1;       // Physical
    this.maxCols = 0;        // Logical 데이터의 최대칼럼수
    this.maxRows = 0;        // Logical 데이터의 최대줄수
    this.currentRow = 1;     // Logical
    this.currentCol = 0;     // Logical
    this._clicked_row_id = "";  //클릭된 행 ID
    
    this.rowsPerDataRow = 1; // 데이터 한줄당 물리적으로 몇줄이 소요되는지....
    this.colsPerDataRow = 1; // 데이터 한줄당 물리적으로 몇줄이 소요되는지....
    this.multilineHelper = null;
    this.columns = [null];

    /** AUIgrid 에서 필요한 속성값들 **/
    this.editable = true; // 수정가능여부
    this.editableOnFixedCell = true; // 고정 칼럼, 행 지정된 셀 수정 가능여부
    this.editBeginMode = "doubleClick"; // 마우스로 편집, 수정 모드로 들어가는 정책, 더블클릭과 클릭 중 택 doubleClick, click
    this.editingOnKeyDown = true; // 엑셀과 같이 바로 해당 셀에서 어떤 키(any keys)를 누르든 수정 가능 상태로 만들지 여부
    this.enableColumnResize = true; // 칼럼 리사이징 가능 여부
    this.enableMovingColumn = false; // 칼럼 순서 바꾸기 가능 여부
    this.enableSorting = true; // 정렬 가능 여부
    /**/this.autoEditCompleteMode = true;
    this.exportURL = getContextPath() + "/third-party/AUISoft/export.jsp"; // 엑셀(xlsx), CSV, TXT 등으로 내보내기(Export) 할 때 내보내기 된 내용물을 다운로드 형식으로 응답해 줄 서버단 URL 주소
    this.hScrollPosition = 0; // 수평 스크롤의 위치(픽셀)
    this.isColumnOriented = false; // 키보드의 Home, End 키가 기본적으로 행의 시작과 끝으로 이동합니다. 칼럼의 시작과 끝으로 이동시키고자 한다면 이 속성을 true 로 설정
    this.keepEditing = false; // true 로 설정한 경우, 다음 셀이 바로 수정 가능한 상태로 입력 창이 열리게 됩니다.
    this.minColumnWidth = 12; // 칼럼의 최소 사이즈를 지정
    this.multiSortingKey = "shiftKey"; // 다중 칼럼 정렬을 실행 할 때 클리과 더블어 함께 할 키(key)를 지정 ("shiftKey", "ctrlKey", "always")
    this.rowIdField = null; // 고유 값을 갖는 Key 필드(Primary Key) 이 필드를 지정하면 그리드가 빨리 생성됩니다. 10만 로우 이상에선 반드시 설정하십시오.
    this.rowPosition = 0; // 현재 화면에 보이는 그리드의 최상단 행의 인덱스
    this.treeOpenRecursivly = false; // 트리 열기 할 때 자손까지 열지 여부
    this.triggerSelectionChangeOnCell = true; // 행 이동시에도 selectionChange 이벤트 발생
    this.useGroupingPanel = false; // 그리드 상단에 그룹핑 가능한 패널 사용 여부
    this.filterMenuItemMaxCount = 20; // 필터링 아이콘 클릭시 나오는 필터링 메뉴에서 필터링 가능한 체크박스의 최대값
    this.filterItemMoreMessage = getText("message_AUIDataSheet_001", "필터링 메뉴보다 실제 값들이 더 많습니다."); // 칼럼의 필터링 아이콘 클릭 시 나오는 필터링 메뉴에서 실제 값들이 더 많다는 메세지를 출력할 수 있습니다.
    this.showAutoNoDataMessage = true; // 데이터가 존재 하지 않을 때 자동으로 메세지를 출력할지 여부
    this.noDataMessage = getText("message_AUIDataSheet_002", "데이터가 없습니다."); // 출력할 데이터 없을 경우 출력 될 메세지
    
    this.autoEditBeginMode = true; // 모바일 기기는 싱글 탭(1번 클릭) 으로 수정 진입 모드를 설정
    this.softRemovePolicy = "exceptNew"; // Insert 키나 addRow 메소드로 행을 추가한 줄은 바로 삭제
    this.autoScrollSize = false; // 스크롤을 모바일 사이즈로 바꿈
    this.copyDisplayValue = false; // 복사(Ctrl+C) 할 때 원래 데이터 값을 복사할 지 그리드에 의해 포매팅된 값을 복사할 지 여부
    this.displayTreeOpen = false; // 계층형 그리드(트리 그리드) 에서 최초로 보여지는 그리드의 브랜치 아이템이 모두 열린 상태로 출력될지 닫힌 상태로 출력될지를 결정
    this.enableCellMerge = false; // 칼럼 셀 병합(cell merge) 가능 여부
    this.enableClipboard = true; // 그리드 데이터 복사하기(Ctrl+C), 붙여넣기(Ctrl+V) 활성화 여부
    this.enableFilter = true; // 칼럼 필드 필터링 기능 활성화 여부를 지정
    this.filterCancelText = getText("message_AUIDataSheet_003", "취 소"); // 필터 메뉴에 표현 할 "취 소" 텍스트를 대체할 다른 텍스트를 지정
    this.filterCheckAllText = getText("message_AUIDataSheet_004", "(전체선택)"); // 필터 메뉴에 표현 할 "전체선택" 텍스트를 대체할 다른 텍스트를 지정
    this.filterClearText = getText("message_AUIDataSheet_005", "필터 초기화"); // 필터 메뉴에 표현 할 "필터 초기화" 텍스트를 대체할 다른 텍스트를 지정
    this.filterNumberOperatorList = [getText("message_AUIDataSheet_006", "같다(=)"), getText("message_AUIDataSheet_007", "크다(>)"), getText("message_AUIDataSheet_008", "크거나 같다(>=)"), getText("message_AUIDataSheet_009", "작다(<)"), getText("message_AUIDataSheet_010", "작거나 같다(<=)"), getText("message_AUIDataSheet_011", "같지 않다(!=)")]; // 필터 유형이 numeric 인 경우 필터링 체크박스에 표시할 비교 연산자명을 지정
    this.filterOkText = getText("message_AUIDataSheet_012", "확 인"); // 필터 메뉴에 표현 할 "확 인" 텍스트를 대체할 다른 텍스트를 지정
    this.filterSearchCheckAllText = getText("message_AUIDataSheet_013", "(검색 전체선택)"); // 필터 메뉴에 표현 할 "검색 전체선택" 텍스트를 대체할 다른 텍스트를 지정
    this.fixedColumnCount = 0; // 고정 칼럼의 개수를 지정
    this.fixedColumnHGap = 0; // 행 줄번호 또는 fixedColumnCount 설정 시 좌측으로 구분되는 그리드와 메인 그리드 사이의 여백
    this.fixedRowCount = 0; // 고정 행(row)의 개수를 지정
    
    // 그리드에 입력되는 데이터가 계층구조의 데이터는 아니지만, 트리 그리드로 출력하고자 할 때 행이 id, parent 필드를 갖어야 합니다.
    this.treeIdField = null; // 이 때 id에 해당되는 데이터의 필드명을 treeIdField 값으로 지정
    this.treeIdRefField = null; // 이 때 내 부모행에 해당되는 참고필드를 treeIdRefField 값으로 지정
    this.flat2tree = false; // 그리드에 입력되는 데이터가 계층구조의 데이터는 아니지만, id, parent 구조를 갖는 일반 데이터인 경우 트리 그리드로 출력할지 여부를 나타냅니다.
    						// flat2tree 속성은 반드시 treeIdField, treeIdRefField 가 선행적으로 설정되어야 합니다.
    
    this.footerHeight = 30; // 푸터의 높이를 지정
    this.footerVGap = 4; // 푸터와 메인 그리드 사이의 간격, 공백을 지정
    this.groupingFields = null; // 그룹핑을 할 칼럼의 데이터 필드를 지정합니다 ex) ["country", "product"]
    this.groupingMessage = getText("message_AUIDataSheet_014", "컬럼을 드래그하여 여기에 올려 놓으세요."); // 그리드 상단에 그룹핑 가능한 패널에 표시되는 메세지를 지정
    this.groupingPanelHeight = 40; // 그리드 상단에 그룹핑 가능한 패널의 높이를 지정
    this.showBranchOnGrouping = false; // 그룹핑 시 브랜치에 해당되는 행 출력 여부를 지정합니다. 이 속성은 그룹핑과 셀병합를 함께 적용할 때만 유효합니다. 이 속성을 false 로 지정하면 그룹핑 시 브랜치 행이 표시되지 않습니다.
    
    this.headerHeight = 30; // 헤더의 높이를 지정
    this.onlyEnterKeyEditEnd = false; // 이 속성을 true 설정하면 셀을 수정하고 완료를 하기 위해 엔터(Enter) 키를 입력할 때 수정 완료 행위만 하고 다음 행으로 선택자를 내리지 않습니다
    this.pageRowCount = 20; // 페이징을 사용하는 경우 한 페이지에 출력되는 행의 수를 지정합니다.;
    // 페이징을 사용하는 경우 페이징 오른쪽에 출력되는 현재페이지와 전체페이지 출력 텍스트를 사용자 정의할 수 있는 라벨펑션을 지정합니다.
    // 함수의 반환값이 곧 출력값이 됩니다.
    this.pagingInfoLabelFunction = function AUIPagingFunction(currentPage, totalPageCount, currentTopNumber, currentBottomNumber, dataLen){return currentPage + " / " + totalPageCount;};
    this.pagingMode = "default"; // "simple" 로 설정한 경우 이전, 다음 버턴과 현재페이지/전체페이지 만 출력됩니다.
    this.pagingPanelHeight = 34; // 페이징을 사용하는 경우 페이징이 출력되는 하단의 페이징 영역이 높이를 지정
    this.processValidData = false; // 그리드 데이터를 유효한 데이터로 재작성 할지 여부
    
    this.resetHScroll = true; // 데이터 변경 시 수평 스크롤의 위치를 초기화 할지 여부를 나타냅니다. 이 속성을 false 로 설정하면 데이터 변경 시 수평 스크롤의 위치가 변하지 않습니다.
    this.resetVScroll = true; // 데이터 변경 시 수직 스크롤의 위치를 초기화 할지 여부를 나타냅니다. 이 속성을 false 로 설정하면 데이터 변경 시 수직 스크롤의 위치가 변하지 않습니다.
    this.reverseRowNum = false; // 행번호 칼럼에서 행 번호를 반대로 출력할지 여부
    this.rowCheckColumnWidth = 25; // 행 체크박스 칼럼의 가로 사이즈(width)를 지정
    this.rowCheckToRadio = false;// 체크박스 대신 라디오버턴 그룹으로 변환시켜 출력할지 여부를 지정합니다.
    this.rowHeight = 26; //  행의 높이를 지정합니다. 행의 높이는 20보다 작아질 수 없습니다
    this.rowPosition = 0; // 현재 화면에 보이는 그리드의 최상단 행의 인덱스
    this.rowStyleFunction = function rowStyleFunction(rowIndex, item){}; // 행(row) 단위로 동적 스타일을 적용할 수 있는 스타일 함수를 지정(return 클래스명)
    														  // rowIndex : 행 인덱스, item : 해당 인덱스의 행 아이템
    this.scrollHeight = 14; // 스크롤의 높이(수직 스크롤인 경우 넓이)를 지정
    this.scrollHeight4Mobile = 4; // 터치가 지원되는 모바일 화면에서의 스크롤 높이(수직 스크롤인 경우 넓이)를 지정
    this.scrollThumbHeight = 12; // 스크롤 썸(thumb)의 높이(수직 스크롤인 경우 넓이)를 지정
    this.selectionMode = "multipleCells"; // 셀 선택모드를 지정 ( singleCell, singleRow, multipleCells, multipleRows, none )
    this.showEditedCellMarker = true; // 수정 가능한 상태(editable = true) 인 경우 셀을 수정하면 해당 셀에 수정된 표시(마크)를 출력할 지 여부
    this.showFooter = false; // 푸터 출력 여부를 지정
    this.showHeader = true; // 헤더 출력 여부
    
    this.showPageButtonCount = 10; // 페이징을 사용하는 경우 출력되는 페이지의 버턴 개수를 지정
    this.showRowCheckColumn = false; // 이 속성 값이 true 이면 최좌측에 체크박스 칼럼이 생성됩니다
    this.showRowNumColumn = true; // 행 줄번호(로우 넘버링) 칼럼의 출력 여부
    this.showSelectionBorder = false; // 셀 선택 시 선택된 셀에 테두리(border) 를 표시할지 여부
    this.showStateColumn = true; // 그리드 좌측에 행의 상태를 나타내는 칼럼 출력 여부를 결정
    this.stateColumnWidth = 16; // 행 상태 칼럼(showStateColumn = true)을 설정한 경우 해당 칼럼의 가로 사이즈를 지정
    this.showTooltip = false; // 그리드 툴팁 표시 여부를 지정
    this.softRemoveRowMode = true; // 행을 삭제하면 그리드에서 바로 제거하지 않고, 삭제된 표시를 하고 남겨 둘 지 여부를 나타냅니다.
    this.summaryText = getText("message_AUIDataSheet_015", "합계"); // groupingSummary 속성을 설정하였을 때 합계 필드에 출력되는 텍스트를 지정
    this.treeColumnIndex = 0; // 계층형 그리드(트리 그리드) 에서 트리 아이콘을 출력시킬 칼럼 인덱스를 지정
    this.treeIconFunction; // 트리 그리드에서 트리를 출력하는 칼럼에 표시되는 아이콘을 동적으로 변경 할 수 있는 함수
    this.treeLevelIndent = 18; // 계층형 그리드(트리 그리드) 에서 자식 행과 부모 행의 왼쪽 간격(indent)를 지정
    this.treeOpenRecursivly = false; // 계층형 그리드(트리 그리드) 에서 열기/닫기 실행 시 재귀적으로(recursivly) 열/닫을 실행할지 결정합니다.
    
    this.useContextMenu = true; // 컨텍스트 메뉴 사용 여부 ( enableFilter = true 설정도 함께 해주십시오 )
    this.useFooterExpData = false; // 푸터를 사용할 때(showFooter = true) 푸터 연산에 사용되는 데이터가 칼럼의 expFunction 에 의해 생성된 데이터를 사용할지 여부를 나타냅니다.
    this.usePaging = false; // 페이징을 사용 여부를 지정
    this.useSummaryExpData = false; // 그룹핑 합계필드(groupingSummary)를 사용할 때 합계 필드에 사용되는 데이터가 칼럼의 expFunction 에 의해 생성된 데이터를 사용할지 여부
    this.wheelSensitivity = 1; // 수직 스크롤의 반응도를 결정합니다.
    						   // 예를 들어 이 속성의 값을 2로 주면 마우스 휠로 반응하는 행의 개수가 2로 증가합니다.
    this.wordWrap = false; // 이 속성값이 true 인 경우 자동 word-wrap 이 발생합니다.
    this.zeroBazeAtRowNum = false; // 행 줄번호(로우 넘버링)의 시작을 0에서 시작할 지, 1에서 시작할지 여부를 지정합니다. true 인 경우 0에서부터 시작합니다.
    
    this.groupingSummary = null; //그룹핑 시 합계 행(groupingSummary)을 생성하고자 할 때 이 속성을 설정하십시오. 합계 필드는 칼럼의 dataType 이 "numeric" 인 경우에만 유효합니다.
    
    this.auiGridProps = null;
    this.footerObject = [];
    this.columnLayout = [];    
    /** AUIgrid 에서 필요한 속성값들 끝 **/
    
    this.hasDelRowEvent = false; this.fncDelRowEvent = null;
    this.hasDelRowDataEvent = false; this.fncDelRowDataEvent = null;
    this.hasAddRowEvent = false; this.fncAddRowEvent = null;
    this.hasAddRowDataEvent = false; this.fncAddRowDataEvent = null;
    this.hasRowChangeEvent = false; this.fncRowChangeEvent = null;
    this.hasColChangeEvent = false; this.fncColChangeEvent = null;
    this.hasChangeEvent = false; this.fncChangeEvent = null;
    this.hasChangeComboTextEvent = false; this.fncChangeComboTextEvent = null;
    this.hasClearEvent = false; this.fncClearEvent = null;
    this.hasClickEvent = false; this.fncClickEvent = null;
    this.hasHeadClickEvent = false; this.fncHeadClickEvent = null;
    this.hasValidateEvent = false; this.fncValidateEvent = null;
    this.hasCommandClickEvent = false; this.fncCommandClickEvent = null;
    this.hasScrollEvent = false; this.fncScrollEvent = null;
    this.hasDblClickEvent = false; this.fncDblClickEvent = null;
    this.hasSortedEvent = false; this.fncSortedEvent = null;
    this.hasSheetChangeEvent = true;
    this.hasEditBeginEvent = false;	this.fncEditBeginEvent = null;

	this.dataBinds = [];     	// 데이터 링크된 콘트롤들 
	this.bindDataset = "";
	this.pivotBound = false;
	
	this.passEvent = false;		//사용자 이벤트 동작 여부(true:동작안함 / false:동작함)
	
    // clear memory
    tagObject = null;
    
    this.GV_DATASHEET_DEFAULT_SELECTION_MODE = "singleRow";
    this.GV_DATASHEET_DEFAULT_SELECTION_FLAG = 0;
    this._sumOfColWidth_per = 0;
};

AUIDataSheet.prototype.create = function(){
	
	if(typeof _SheetLoadCompleted != "undefined" && _SheetLoadCompleted instanceof Array){
		_SheetLoadCompleted[this.id] = false;		
	}
	
	if(this.GV_DATASHEET_DEFAULT_SELECTION_MODE == "singleRow" && this.GV_DATASHEET_DEFAULT_SELECTION_FLAG == 0){
		this.selectionMode = this.GV_DATASHEET_DEFAULT_SELECTION_MODE;
		this.GV_DATASHEET_DEFAULT_SELECTION_FLAG = 1;
	}
	
	if(this._sumOfColWidth_per < 100){
		var sumWidth = 0;
		var colWidth = 0;
		var lastColWidth = 0;
		for(var i = 0; i < this.defaultColumnSize.length - 1; i++){
			colWidth = ("" + this.defaultColumnSize[i]);
			//명시적 칼럼 사이즈를 제외하고 남는 width를 대상으로 %에 따라 너비 조정
			if( colWidth.indexOf("%") < 0 ){
				this.applyRestPercentWidth = true;
				continue;
			}
			//너비의 % 값을 합산
			colWidth = 1 * (colWidth.replace("%", ""));
			sumWidth = sumWidth + colWidth;
		}
		
		lastColWidth = 1 * ("" + this.defaultColumnSize[this.defaultColumnSize.length - 1]).replace("%", "");
		this._sumOfColWidth_per = sumWidth + lastColWidth;
		
		if(this._sumOfColWidth_per >= 90 && this._sumOfColWidth_per < 100){
			this.defaultColumnSize[this.defaultColumnSize.length - 1] = "" + (100 - sumWidth) + "%";
			this._sumOfColWidth_per = 100;
		}		
	}
	
	this.auiGridProps = {
			editable : this.editable,
		    editableOnFixedCell : this.editableOnFixedCell,
		    editBeginMode : this.editBeginMode,
		    editingOnKeyDown : this.editingOnKeyDown,
		    enableColumnResize : this.enableColumnResize,
		    enableMovingColumn : this.enableMovingColumn,
		    enableSorting : this.enableSorting,
		    exportURL : this.exportURL,
		    hScrollPosition : this.hScrollPosition,
		    isColumnOriented : this.isColumnOriented,
		    keepEditing : this.keepEditing,
		    minColumnWidth : this.minColumnWidth,
		    multiSortingKey : this.multiSortingKey,
		    rowIdField : (this.rowIdField == null) ? "_$uid" : this.rowIdField,
		    rowPosition : this.rowPosition,
		    showHeader : this.showHeader,
		    treeOpenRecursivly : this.treeOpenRecursivly,
		    triggerSelectionChangeOnCell : this.triggerSelectionChangeOnCell,
		    useGroupingPanel : this.useGroupingPanel,
		    filterMenuItemMaxCount : this.filterMenuItemMaxCount,
		    filterItemMoreMessage : this.filterItemMoreMessage,
		    showAutoNoDataMessage : this.showAutoNoDataMessage,
		    noDataMessage : this.noDataMessage,
		    autoEditBeginMode : this.autoEditBeginMode,
		    softRemovePolicy : this.softRemovePolicy,
		    autoScrollSize : this.autoScrollSize,
		    copyDisplayValue : this.copyDisplayValue,
		    displayTreeOpen : this.displayTreeOpen,
		    enableCellMerge : this.enableCellMerge,
		    enableClipboard : this.enableClipboard,
		    enableFilter : this.enableFilter,
		    filterCancelText : this.filterCancelText,
		    filterCheckAllText : this.filterCheckAllText,
		    filterClearText : this.filterClearText,
		    filterNumberOperatorList : this.filterNumberOperatorList,
		    filterOkText : this.filterOkText,
		    filterSearchCheckAllText : this.filterSearchCheckAllText,
		    fixedColumnCount : this.fixedColumnCount,
		    fixedColumnHGap : this.fixedColumnHGap,
		    fixedRowCount : this.fixedRowCount,
		    treeIdField : this.treeIdField,
		    treeIdRefField : this.treeIdRefField,
		    flat2tree : this.flat2tree,
		    footerHeight : this.footerHeight,
		    footerVGap : this.footerVGap,
		    groupingFields : this.groupingFields,
		    groupingMessage : this.groupingMessage,
		    groupingPanelHeight : this.groupingPanelHeight,
		    showBranchOnGrouping : this.showBranchOnGrouping,
		    headerHeight : this.headerHeight,
		    onlyEnterKeyEditEnd : this.onlyEnterKeyEditEnd,
		    pageRowCount : this.pageRowCount,
		    pagingInfoLabelFunction : this.pagingInfoLabelFunction,
		    pagingMode : this.pagingMode,
		    pagingPanelHeight : this.pagingPanelHeight,
		    processValidData : this.processValidData,
		    resetHScroll : this.resetHScroll,
		    resetVScroll : this.resetVScroll,
		    reverseRowNum : this.reverseRowNum,
		    rowCheckColumnWidth : this.rowCheckColumnWidth,
		    rowCheckToRadio : this.rowCheckToRadio,
		    rowHeight : this.rowHeight,
		    rowPosition : this.rowPosition,
		    rowStyleFunction : this.rowStyleFunction,
		    scrollHeight : this.scrollHeight,
		    scrollHeight4Mobile : this.scrollHeight4Mobile,
		    scrollThumbHeight : this.scrollThumbHeight,
//		    showEditedCellMarker : this.showEditedCellMarker,
		    showEditedCellMarker : false,
		    showFooter : this.showFooter,
		    showHeader : this.showHeader,
		    showPageButtonCount : this.showPageButtonCount,
		    showRowCheckColumn : this.showRowCheckColumn,
		    showRowNumColumn : this.showRowNumColumn,
		    showSelectionBorder : this.showSelectionBorder,
//		    showStateColumn : this.showStateColumn,
//		    stateColumnWidth : this.stateColumnWidth,
		    showStateColumn : false,
		    showTooltip : this.showTooltip,
		    softRemoveRowMode : this.softRemoveRowMode,
		    summaryText : this.summaryText,
		    treeColumnIndex : this.treeColumnIndex,
		    treeIconFunction : this.treeIconFunction,
		    treeLevelIndent : this.treeLevelIndent,
		    treeOpenRecursivly : this.treeOpenRecursivly,
		    useContextMenu : this.useContextMenu,
		    useFooterExpData : this.useFooterExpData,
		    usePaging : this.usePaging,
		    useSummaryExpData : this.useSummaryExpData,
		    wheelSensitivity : this.wheelSensitivity,
		    wordWrap : this.wordWrap,
		    zeroBazeAtRowNum : this.zeroBazeAtRowNum,
		    selectionMode : this.selectionMode,		    
		    groupingSummary : this.groupingSummary,
		    autoEditCompleteMode : true,
		    applyRestPercentWidth : this.applyRestPercentWidth
	};
	
	if(typeof this.showStateColumn == "string"){
		this.auiGridProps["showStateColumn"] = (this.showStateColumn == "TRUE") ? true : false;
		this.auiGridProps["stateColumnWidth"] = (this.showStateColumn == "TRUE") ? this.stateColumnWidth : 0;
	}
	
	if( !AUIGrid.isCreated(this.AUIcontrolId) ){
		// 실제로 #grid_wrap 에 그리드 생성
		AUIGrid.create(this.AUIcontrolId, this.columnLayout, this.auiGridProps);
		// 푸터 객체 세팅
		AUIGrid.setFooter(this.AUIcontrolId, this.footerObject);
	}
	
	// 연결된 객체중 하나라도 dniMode가 false라면 'U' 업데이트 구분을 주기위해 objectmanager의 dataloaded 속성을 true로 바꿔준다.
//	var arrData = this.linkedObjects;
//	var dataLen = arrData.length;
//	for (var i = 0; i < dataLen; i++) {
//		if(arrData[i].dniMode == false){
//			objectManager.dataloaded = true;
////			break;
//		}
//		if(arrData[i].fillKeyFieldName.length > 0){
//			this.fillKeyField = true;
//		}
//	}
	
	// 이벤트 선언
	this.createEvent();
	
	// 빈데이터 세팅 (데이터 세팅을 한번도 하지않고 줄이 없는상태에서 줄추가를 하면 에러가 난다)
	// defaultData가 있다면 세팅해준다.
	//this.setData(this.defaultData);
	AUIGrid.setGridData(this.AUIcontrolId, this.defaultData);
	
	// defaultData가 없다면 첫줄을 생성한다
//	if(this.defaultData.length == 0) this.addRow(0);
	
	this.resize();
	
	return;
};

// 셋 데이터
AUIDataSheet.prototype.setData = function(data, updateDataset) {
	if(data.length > 0){
		AUIGrid.setGridData(this.AUIcontrolId, data);
		//무한루핑 방지
		if(updateDataset == undefined || updateDataset){
			//Dataset을 사용하지 않은 경우
			if(typeof(AUIDataSheet.prototype._UpdateDatasetList) != "undefined"){
				this._UpdateDatasetList();
			}
		}
	}	
	return;
};

// 데이터를 아래쪽에 추가로 붙인다
// appendData는 onready 이벤트를 타지 않는다. 강제로 onReady() 함수 호출
AUIDataSheet.prototype.setAppendData = function(data, updateDataset) {
	if(data.length > 0){
		AUIGrid.appendData(this.AUIcontrolId, data);
		//Dataset을 사용하지 않은 경우
		if(updateDataset == undefined || updateDataset){
			if(typeof(AUIDataSheet.prototype._UpdateDatasetList) != "undefined"){
				this._UpdateDatasetList();			
			}
		}
		this.onReady();
	}
	return;
};

AUIDataSheet.prototype.createEvent = function() {
	
	var myGridID =  this.AUIcontrolId;
	var aSheet = getControlById(this.controlId);
	
	AUIGrid.bind(myGridID, "ready", function(event) {return auiSheet_Ready(event, aSheet);});
	
	AUIGrid.bind(myGridID, "selectionChange", function( event ) {return auiSheet_selectionChange(event, aSheet);});
	
	AUIGrid.bind(myGridID, "cellDoubleClick", function( event ) {return auiSheet_cellDoubleClick(event, aSheet);});
	
	AUIGrid.bind(myGridID, "cellClick", function( event ) {return auiSheet_cellClick(event, aSheet);});
	
	AUIGrid.bind(myGridID, "headerClick", function( event ) {return auiSheet_headerClick(event, aSheet);});
	
	AUIGrid.bind(myGridID, "cellEditEnd", function( event ) {return auiSheet_setValue(event, aSheet);});
	
	AUIGrid.bind(myGridID, "addRow", function( event ) {return auiSheet_addRow(event, aSheet);});
	
	AUIGrid.bind(myGridID, "beforeRemoveRow", function( event ) {return auiSheet_removeRow(event, aSheet);});
	
	AUIGrid.bind(myGridID, "sorting", function( event ) {return auiSheet_sorting(event, aSheet);});
	
	AUIGrid.bind(myGridID, "vScrollChange", function( event ) {return auiSheet_vScroll(event, aSheet);});
	
	AUIGrid.bind(myGridID, "keyDown", function(event) {return auiSheet_keyDown(event, aSheet);});
	
	AUIGrid.bind(myGridID, "cellEditBegin", function(event) {return auiSheet_editBegin(event, aSheet);});
	
	AUIGrid.bind(myGridID, "cellEditEndBefore", function(event) {return auiSheet_setValueBefore(event, aSheet);});
	
	if (this.AUIcontrolId.length > 0) {
		this.hasDelRowEvent = (typeof self[this.controlId + "_ondelrow"] != "undefined");
        if (this.hasDelRowEvent){
        	this.fncDelRowEvent = new Function("return function (atRowNum) { return " + this.controlId + "_ondelrow(atRowNum); }")();
        }
        this.hasDelRowDataEvent = (typeof self[this.controlId + "_ondelrowdata"] != "undefined");
        if (this.hasDelRowDataEvent){
        	this.fncDelRowEvent = new Function("return function (atRowNum) { return " + this.controlId + "_ondelrowdata(atRowNum); }")();
        }
        this.hasAddRowEvent = (typeof self[this.controlId + "_onaddrow"] != "undefined");
        if (this.hasAddRowEvent){
        	this.fncAddRowEvent = new Function("return function (atRowNum) { return " + this.controlId + "_onaddrow(atRowNum); }")();
        }
        this.hasAddRowDataEvent = (typeof self[this.controlId + "_onaddrowdata"] != "undefined");
        if (this.hasAddRowDataEvent){
        	this.fncAddRowDataEvent = new Function("return function (atRowNum) { return " + this.controlId + "_onaddrowdata(atRowNum); }")();
        }
        this.hasRowChangeEvent = (typeof self[this.controlId + "_onrowchange"] != "undefined");
        if (this.hasRowChangeEvent){
        	this.fncRowChangeEvent = new Function("return function (rowNumFrom, rowNumTo, objectSeq) { return " + this.controlId + "_onrowchange(rowNumFrom, rowNumTo, objectSeq); }")();
        }
        this.hasColChangeEvent = (typeof self[this.controlId + "_oncolchange"] != "undefined");
        if (this.hasColChangeEvent){
        	this.fncColChangeEvent = new Function("return function (colNumFrom, colNumTo) { return " + this.controlId + "_oncolchange(colNumFrom, colNumTo); }")();
        }
        this.hasChangeEvent = (typeof self[this.controlId + "_onchange"] != "undefined");
        if (this.hasChangeEvent){
        	this.fncChangeEvent = new Function("return function (rowNum, colNum, value, oldValue, keyCode) { return " + this.controlId + "_onchange(rowNum, colNum, value, oldValue, keyCode); }")();
        }
        this.hasChangeComboTextEvent = (typeof self[this.controlId + "_onchangeCombotext"] != "undefined");
        if (this.hasChangeComboTextEvent){
        	this.fncChangeComboTextEvent = new Function("return function (rowNum, colNum, value, oldValue) { return " + this.controlId + "_onchangeCombotext(rowNum, colNum, value, oldValue); }")();
        }
        this.hasClearEvent = (typeof self[this.controlId + "_onclear"] != "undefined");
        if (this.hasClearEvent){
        	this.fncClearEvent = new Function("return function () { return " + this.controlId + "_onclear(); }")();
        }
        this.hasClickEvent = (typeof self[this.controlId + "_onclick"] != "undefined");
        if (this.hasClickEvent){
        	this.fncClickEvent = new Function("return function (rowNum, colNum, colId, colIndex) { return " + this.controlId + "_onclick(rowNum, colNum, colId, colIndex); }")();
        }
        this.hasHeadClickEvent = (typeof self[this.controlId + "_onheadclick"] != "undefined");
        if (this.hasHeadClickEvent){
        	this.fncHeadClickEvent = new Function("return function (rowNum, colNum, headerText) { return " + this.controlId + "_onheadclick(rowNum, colNum, headerText); }")();
        }
        this.hasValidateEvent = (typeof self[this.controlId + "_onvalidate"] != "undefined");
        if (this.hasValidateEvent){
        	this.fncValidateEvent = new Function("return function (colNum, value) { return " + this.controlId + "_onvalidate(colNum, value); }")();
        }
        this.hasCommandClickEvent = (typeof self[this.controlId + "_oncommandclick"] != "undefined");
        if (this.hasCommandClickEvent){
        	this.fncCommandClickEvent = new Function("return function (rowNum, colNum) { return " + this.controlId + "_oncommandclick(rowNum, colNum); }")();
        }
        this.hasImageClickEvent = (typeof self[this.controlId + "_onimageclick"] != "undefined");
        if (this.hasImageClickEvent){
        	this.fncImageClickEvent = new Function("return function (rowNum, colNum) { return " + this.controlId + "_onimageclick(rowNum, colNum); }")();
        }
        this.hasScrollEvent = (typeof self[this.controlId + "_onscroll"] != "undefined");
        if (this.hasScrollEvent){
        	this.fncScrollEvent = new Function("return function (scrollPanel, scrollTop, scrollLeft,  lastScrollTop, lastScrollLeft) { return " + this.controlId + "_onscroll(scrollPanel, scrollTop, scrollLeft, lastScrollTop, lastScrollLeft); }")();
        }
        this.hasDblClickEvent = (typeof self[this.controlId + "_ondblclick"] != "undefined");
        if (this.hasDblClickEvent){
        	this.fncDblClickEvent = new Function("return function (rowNum, colNum) { return " + this.controlId + "_ondblclick(rowNum, colNum); }")();
        }
        this.hasSortedEvent = (typeof self[this.controlId + "_onsorted"] != "undefined");
        if (this.hasSortedEvent){
        	this.fncSortedEvent = new Function("return function () { return " + this.controlId + "_onsorted(); }")();
        }
        this.hasEditBeginEvent = (typeof self[this.controlId + "_oncellEditBefore"] != "undefined");
        if (this.hasEditBeginEvent){
        	this.fncEditBeginEvent = new Function("return function (rowNum, colNum) { return " + this.controlId + "_oncellEditBefore(rowNum, colNum); }")();
        }
        //  KeyDown(rowNum, colNum, KeyCode, Shift)
        makeEventHandler(this, "KeyDown", "rowNum", "colNum", "keyCode", "shiftPressed", "controlPressed", "altPressed");    
        
        //  KeyPress(rowNum, colNum, KeyAscii)
        makeEventHandler(this, "KeyPress", "rowNum", "colNum", "KeyCode");  
        
        //  KeyUp(rowNum, colNum, KeyCode, Shift)
        makeEventHandler(this, "KeyUp", "rowNum", "colNum", "KeyCode", "shiftPressed", "controlPressed", "altPressed");  
/*
		try {
			if (eval(this.controlId + "_ondelrow")) this.hasDelRowEvent = true;
		} catch(e){}
		if (this.hasDelRowEvent){
			eval("this.fncDelRowEvent = function(atRowNum){ return " + this.controlId + "_ondelrow(atRowNum);}");
		}
		
    	try {
        	if (eval(this.controlId + "_ondelrowdata")) this.hasDelRowDataEvent = true;
        } catch(e){}
        if (this.hasDelRowDataEvent){
    	    eval("this.fncDelRowDataEvent = function(atRowNum){ return " + this.controlId + "_ondelrowdata(atRowNum);}");
        }

        try {
        	if (eval(this.controlId + "_onaddrow")) this.hasAddRowEvent = true;
        } catch(e){}
        if (this.hasAddRowEvent){
        	eval("this.fncAddRowEvent = function(atRowNum){ return " + this.controlId + "_onaddrow(atRowNum);}");
        }
        
    	try {
        	if (eval(this.controlId + "_onaddrowdata")) this.hasAddRowDataEvent = true;
        } catch(e){}
        if (this.hasAddRowDataEvent){
    	    eval("this.fncAddRowDataEvent = function(atRowNum){ return " + this.controlId + "_onaddrowdata(atRowNum);}");
        }

    	try {
        	if (eval(this.controlId + "_onrowchange")) this.hasRowChangeEvent = true;
        } catch(e){}
        if (this.hasRowChangeEvent){
    	    eval("this.fncRowChangeEvent = function(rowNumFrom, rowNumTo, objectSeq){ return " + this.controlId + "_onrowchange(rowNumFrom, rowNumTo, objectSeq);}");
        }

    	try {
        	if (eval(this.controlId + "_oncolchange")) this.hasColChangeEvent = true;
        } catch(e){}
        if (this.hasColChangeEvent){
    	    eval("this.fncColChangeEvent = function(colNumFrom, colNumTo){ return " + this.controlId + "_oncolchange(colNumFrom, colNumTo);}");
        }
        
        
    	try {
        	if (eval(this.controlId + "_onchange")) this.hasChangeEvent = true;
        } catch(e){}
        if (this.hasChangeEvent){
    	    eval("this.fncChangeEvent = function(rowNum, colNum, value, oldValue, keyCode){ return " + this.controlId + "_onchange(rowNum, colNum, value, oldValue, keyCode);}");
        }

    	try {
        	if (eval(this.controlId + "_onchangeCombotext")) this.hasChangeComboTextEvent = true;
        } catch(e){}
        if (this.hasChangeComboTextEvent){
    	    eval("this.fncChangeComboTextEvent = function(rowNum, colNum, value, oldValue){ return " + this.controlId + "_onchangeCombotext(rowNum, colNum, value, oldValue);}");
        }

    	try {
        	if (eval(this.controlId + "_onclear")) this.hasClearEvent = true;
        } catch(e){}
        if (this.hasClearEvent){
    	    eval("this.fncClearEvent = function(){ return " + this.controlId + "_onclear();}");
        }
        
    	try {
        	if (eval(this.controlId + "_onclick")) this.hasClickEvent = true;
        } catch(e){}
        if (this.hasClickEvent){
    	    eval("this.fncClickEvent = function(rowNum, colNum, colId, colIndex){ return " + this.controlId + "_onclick(rowNum, colNum, colId, colIndex);}");
        }
        
    	try {
        	if (eval(this.controlId + "_onheadclick")) this.hasHeadClickEvent = true;
        } catch(e){}
        if (this.hasHeadClickEvent){
    	    eval("this.fncHeadClickEvent = function(rowNum, colNum, headerText){ return " + this.controlId + "_onheadclick(rowNum, colNum, headerText);}");
        }

    	try {
        	if (eval(this.controlId + "_onvalidate")) this.hasValidateEvent = true;
        } catch(e){}
        if (this.hasValidateEvent){
    	    eval("this.fncValidateEvent = function(colNum, value){ return " + this.controlId + "_onvalidate(colNum, value);}");
        }

    	try {
        	if (eval(this.controlId + "_oncommandclick")) this.hasCommandClickEvent = true;
        } catch(e){}
        if (this.hasCommandClickEvent){
    	    eval("this.fncCommandClickEvent = function(rowNum, colNum){ return " + this.controlId + "_oncommandclick(rowNum, colNum);}");
        }
    	try {
        	if (eval(this.controlId + "_onimageclick")) this.hasImageClickEvent = true;
        } catch(e){}
        if (this.hasImageClickEvent){
    	    eval("this.fncImageClickEvent = function(rowNum, colNum){ return " + this.controlId + "_onimageclick(rowNum, colNum);}");
        }
    	try {
        	if (eval(this.controlId + "_onscroll")) this.hasScrollEvent = true;
        } catch(e){}
        if (this.hasScrollEvent){
    	    eval("this.fncScrollEvent = function(scrollPanel, scrollTop, scrollLeft,  lastScrollTop, lastScrollLeft){ return " + this.controlId + "_onscroll(scrollPanel, scrollTop, scrollLeft, lastScrollTop, lastScrollLeft);}");
        }
    	try {
        	if (eval(this.controlId + "_ondblclick")) this.hasDblClickEvent = true;
        } catch(e){}
        if (this.hasDblClickEvent){
    	    eval("this.fncDblClickEvent = function(rowNum, colNum){ return " + this.controlId + "_ondblclick(rowNum, colNum);}");
        }

    	try {
        	if (eval(this.controlId + "_onsorted")) this.hasSortedEvent = true;
        } catch(e){}
        if (this.hasSortedEvent){
    	    eval("this.fncSortedEvent = function(){ return " + this.controlId + "_onsorted();}");
        }
        
        try {
        	if (eval(this.controlId + "_oncellEditBefore")) this.hasEditBeginEvent = true;
        } catch(e){}
        if (this.hasEditBeginEvent){
    	    eval("this.fncEditBeginEvent = function(rowNum, colNum){ return " + this.controlId + "_oncellEditBefore(rowNum, colNum);}");
        }
        
        //  KeyDown(rowNum, colNum, KeyCode, Shift)
        makeEventHandler(this, "KeyDown", "rowNum", "colNum", "keyCode", "shiftPressed", "controlPressed", "altPressed");    
        
        //  KeyPress(rowNum, colNum, KeyAscii)
        makeEventHandler(this, "KeyPress", "rowNum", "colNum", "KeyCode");  
        
        //  KeyUp(rowNum, colNum, KeyCode, Shift)
         makeEventHandler(this, "KeyUp", "rowNum", "colNum", "KeyCode", "shiftPressed", "controlPressed", "altPressed");  
*/
    }
};

// 리사이즈 함수
AUIDataSheet.prototype.resize = function(){
	AUIGrid.resize(this.AUIcontrolId);
	if(this.defaultColumnSize.length > 0){
		AUIGrid.setColumnSizeList(this.AUIcontrolId, this.defaultColumnSize);
	}
	return;
};

AUIDataSheet.prototype.excelDownLoad = function(styleFix, downFileName, exportProps) {
	var nowDate = new Date();
	var now = "_";
	now += nowDate.getFullYear() + "";
	now += ((nowDate.getMonth() + 1) < 10 ? "0" : "") + (nowDate.getMonth() + 1);
	now += (nowDate.getDate() < 10 ? "0" : "") + nowDate.getDate();
	now += (nowDate.getHours() < 10 ? "0" : "") + nowDate.getHours();
	now += (nowDate.getMinutes() < 10 ? "0" : "") + nowDate.getMinutes();
	now += (nowDate.getSeconds() < 10 ? "0" : "") + nowDate.getSeconds();
	now += (nowDate.getMilliseconds() < 10 ? "00" : (nowDate.getMilliseconds() < 100 ? "0" : "")) + nowDate.getMilliseconds();
	
	if(typeof exportProps == "undefined")	exportProps = {};
	
	exportProps["fileName"] = downFileName + now;
	exportProps["exceptColumnFields"] = AUIGrid.getHiddenColumnDataFields(this.AUIcontrolId);
	
	AUIGrid.exportToXlsx(this.AUIcontrolId, styleFix, exportProps);
	
	return true;
};

AUIDataSheet.prototype.textDownLoad = function(downFileName) {
	AUIGrid.exportToTxt(this.AUIcontrolId, {filename: downFileName});
	
	return true;
};

/** AUI 이벤트 함수 시작 **/
function auiSheet_Ready(e, aSheet){
	aSheet.onReady();
	
	if(typeof _SheetLoadCompleted != "undefined" && _SheetLoadCompleted instanceof Array){
		var key = "";
		for(key in _SheetLoadCompleted){
			if(typeof _SheetLoadCompleted[key] != "boolean") continue;
			_SheetLoadCompleted[key] = true;
		}
	}
	
	return true;
};

function auiSheet_addRow(e, aSheet){
	var atRowNum = e.rowIndex + 1;
	
	var arrData = aSheet.linkedObjects;
	var dataLen = arrData.length;
	aSheet.notSetValue = true;
	
	for(var i = 0; i < dataLen;i++){
		arrData[i].notSetValue = true;
	}
	
	// 시트 줄수값 갱신
	aSheet.maxRows++;
	
	// DataRow 갱신 ----------------------------------------------------
	var rowsLen = aSheet.rows.length - 1;
    for (var wRowNum = rowsLen; wRowNum >= atRowNum; wRowNum--){
    	if(aSheet.rows[wRowNum] == undefined) continue;
    	aSheet.rows[wRowNum + 1] = aSheet.rows[wRowNum];
    }
    
    // EXORow 추가
    aSheet.rows[atRowNum] = new EXORow();
     //새로추가된줄 표시
    aSheet.rows[atRowNum].newData = true;
    // 객체 생성전 생성관련 속성 세팅 ( newData )
	for(var i = 0; i < dataLen;i++){
		arrData[i].newData = true;
	}
	// 객체 데이터 생성
	if(aSheet.hasAddRowDataEvent) aSheet.fncAddRowDataEvent(atRowNum);
	
	for(var i = 0; i < dataLen;i++){
		arrData[i].newData = false;
	}
	
	aSheet.notSetValue = false;
	
	for(var i = 0; i < dataLen;i++){
		arrData[i].notSetValue = false;
		
		arrData[i].seq = aSheet.rows[atRowNum].objectSeq;
		if (arrData[i].hasAddRecordEvent) arrData[i].fncAddRecordEvent(); // 지금은 change 이벤트가 일어나지 않기 때문에 강제로 addRecordEvent를 호출해준다.
	}
	
	aSheet.setCurrentRow(atRowNum);
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 이벤트단계 : 사용자 이벤트
	    if (aSheet.inputMode == SHEETMODE_SETCELL){
	        if (aSheet.hasAddRowEvent) {
	        	aSheet.fncAddRowEvent(atRowNum);
	        }
	    }
	}
    
    return true;
};

function auiSheet_removeRow(e, aSheet){
	aSheet.notSetValue = true;
	var arrData = aSheet.linkedObjects;
	
	var items = e.items;
	var itemsLen = items.length;
	var atRowNum = 0;
	var removedRowCount = 0;	//물리적으로 삭제된 행 갯수
	var rowId = "";
	
	for(var j=0; j<itemsLen; j++){
		/*
		// rowIdField가 지정되어 있을때 
		if(aSheet.rowIdField != null){
			atRowNum = AUIGrid.rowIdToIndex(aSheet.AUIcontrolId, e.items[j][aSheet.rowIdField]) + 1;
		}
		// 지정되어있지 않다면 내부 rowId(_$uid)가 생성되어있다
		else{
			atRowNum = AUIGrid.rowIdToIndex(aSheet.AUIcontrolId, e.items[j]._$uid) + 1;
		}
		*/
		
		// rowIdField가 지정되어 있을때
		if(aSheet.rowIdField != null){
			rowId = e.items[j][aSheet.rowIdField];
		}
		// 지정되어있지 않다면 내부 rowId(_$uid)가 생성되어있다
		else{
			rowId = e.items[j]._$uid;
		}
		//삭제된 행의 행 번호를 가져온다
		atRowNum = AUIGrid.rowIdToIndex(aSheet.AUIcontrolId, rowId) + 1;
		
		if(arrData.length > 0){
			aSheet.currentRow = atRowNum;
			// 데이터 row가 있을때
			if(aSheet.rows[atRowNum] != null || aSheet.rows[atRowNum] != undefined) {
				for (var i = 0; i < arrData.length;i++) {
					arrData[i].seq = aSheet.rows[atRowNum].objectSeq;
				}
			}
			// 데이터 row가 없을때는 만든다
			else {
				aSheet.rows[atRowNum] = new EXORow();
				if(aSheet.hasAddRowDataEvent) aSheet.fncAddRowDataEvent(atRowNum);
				for (var i = 0; i < arrData.length;i++) {
					arrData[i].seq = aSheet.rows[atRowNum].objectSeq;
				}
			}
			
			aSheet.fncChangeEvent(atRowNum, 1, "", "");
		}
		
		// 1)SOFT행삭제를 하지 않거나 2)SOFT행삭제를 하면서 추가된 행인 경우 삭제된 행 갯수를 증가시킨다
		if( !aSheet.softRemoveRowMode || (aSheet.softRemoveRowMode && AUIGrid.isAddedById(aSheet.AUIcontrolId, rowId)) ){
			removedRowCount++;
			//console.log(removedRowCount);
		}
		
		//삭제된 행이 클릭한 행이면 _clicked_row_id 초기화
		if(aSheet._clicked_row_id + "" == rowId + ""){
			aSheet._clicked_row_id = "";
		}
		
		//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
		if( !this.passEvent ){
			// 이벤트 : 객체.줄삭제
			if (aSheet.hasDelRowDataEvent) aSheet.fncDelRowDataEvent(atRowNum);
		}
	}
	
	/*// 줄 바로 삭제하는 경우
	if(!aSheet.softRemoveRowMode) {
		aSheet.maxRows -= j;
		aSheet.currentRow = aSheet.maxRows;
	}*/
	
	if( aSheet.maxRows - removedRowCount <= 0 ){
		AUIGrid.forceEditingComplete(aSheet.AUIcontrolId, null);
	}
	
	var isMoveUpper = aSheet.moveToUpperCell(true);
	
	// 삭제된 행 갯수가 0보다 큰 경우(물리적인 행 삭제가 된 경우)
	if(removedRowCount > 0) {
		aSheet.maxRows -= removedRowCount;
		if( !isMoveUpper ){
			aSheet.currentRow = (aSheet.currentRow < aSheet.maxRows) ? aSheet.currentRow : aSheet.maxRows;
		}
	}
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 삭제 후 사용자 이벤트
		if (aSheet.hasDelRowEvent) aSheet.fncDelRowEvent(atRowNum);
	}
	
    aSheet.notSetValue = false;
    
//    if (aSheet.sheetType == SHEETTYPE_LISTSHEET){
//         if (aSheet.hasRowChangeEvent && !aSheet.inClearMode) aSheet.fncRowChangeEvent(atRowNum, atRowNum);
//    } else {
//         if (aSheet.hasRowChangeEvent && !aSheet.inClearMode) aSheet.fncRowChangeEvent(atRowNum, atRowNum, aSheet.rows[atRowNum].objectSeq);
//    } 
    
    return true;
};

function auiSheet_selectionChange(e, aSheet){
	aSheet.cellChange(e.selectedItems[0].rowIndex + 1, e.selectedItems[0].columnIndex + 1);
	return true;
};

function auiSheet_cellClick(e, aSheet){
	aSheet._clicked_row_id = (aSheet.rowIdField == null) ? e.item._$uid : e.item[aSheet.rowIdField];
	aSheet.click(e.rowIndex + 1, e.columnIndex + 1);
	return true;
};

function auiSheet_cellDoubleClick(e, aSheet){
	aSheet._clicked_row_id = (aSheet.rowIdField == null) ? e.item._$uid : e.item[aSheet.rowIdField];
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		if(aSheet.hasDblClickEvent) aSheet.fncDblClickEvent(e.rowIndex + 1, e.columnIndex + 1);
	}
	return true;
};

function auiSheet_headerClick(e, aSheet){
	// 체크박스 칼럼 클릭 한 경우
	if(e.item.renderer && e.item.renderer.type == "CheckBoxEditRenderer") {
		var checkBoxId = aSheet.AUIcontrolId + "_f" + (e.columnIndex + 1) + "_allCheckbox";
		if(e.orgEvent.target.id == checkBoxId) { // 정확히 체크박스 클릭 한 경우만 적용 시킴.
			var isChecked = document.getElementById(checkBoxId).checked;
			var checkColumnValue = isChecked? "1": "0"; // true는 1로 false는 0로 변경
			// 모든 체크박스 컬럼값 모두 변경
			aSheet.setValueAllColumn((e.columnIndex + 1), checkColumnValue);
			// 헤더 체크 박스 일치시킴.
			document.getElementById(checkBoxId).checked = isChecked;
		}
		return false;
	} else {
		if( !this.passEvent ){
			if(aSheet.hasHeadClickEvent) aSheet.fncHeadClickEvent(e.item.depth, e.columnIndex + 1, e.headerText);
		}
	}
	
	return true;
}

function auiSheet_setValue(e, aSheet){
	//엔터로 값이 변경되었다면 event.keyCode를 시트 change 사용자 함수에 전달
	var keyCode = undefined;
	if(typeof window.event != "undefined" && window.event instanceof KeyboardEvent){
		keyCode = window.event.keyCode;
	}
	// 객체에 값 세팅
	aSheet.setValueAUI(e.rowIndex + 1, e.columnIndex + 1, e.value, e.oldValue, keyCode);
	
	// 피벗 갱신
	if (aSheet.pivotBound){
		if (typeof aSheet.updatePivotCell != "undefined"){
			aSheet.updatePivotCell(e.rowIndex + 1, e.columnIndex + 1, e.value, e.oldValue);
		}
		return true;
	}
	
	
	// 컬럼에 있는 전체체크 체크박스의 아이디
	var checkBoxId = aSheet.AUIcontrolId + "_f" + (e.columnIndex + 1) + "_allCheckbox";
	// 체크박스 칼럼 수정 완료 한 경우
	if(document.getElementById(checkBoxId)) {
		
		// 데이터에서 해당 체크 필드의 값이 1 인 행 아이템 모두 반환
		var activeItems = AUIGrid.getItemsByValue(aSheet.AUIcontrolId, "f"+(e.columnIndex + 1), "1");
		// 헤더 체크 박스 전체 체크 일치시킴.
		if(activeItems.length != aSheet.maxRows) {
			document.getElementById(checkBoxId).checked = false;
		} else if(activeItems.length == aSheet.maxRows) {
			document.getElementById(checkBoxId).checked = true;
		}
	}
	
	return true;
};

function auiSheet_sorting(e, aSheet){
	if(aSheet.hasSortedEvent) aSheet.fncSortedEvent();
	return true;
};

function auiSheet_vScroll(e, aSheet){
	if(e.position == e.maxPosition){
		jobControler.open(aSheet.fillJobName, "", aSheet.pageNum);
		aSheet.pageNum++;
	}
	return true;
};

function auiSheet_keyDown(e, aSheet){
	//F5 키 이벤트 동작 제어
	if(e.keyCode == 116 || e.which == 116) {
		e.orgEvent.preventDefault();
		return false;
	}
	
	//이벤트 정보
	var evt = (e.orgEvent) ? e : window.event;
	e = (evt.orgEvent) ? evt.orgEvent : window.event;
	//현재 키 다운 이벤트가 발생한 시트
	var em = null;
	var sheet = aSheet ? aSheet : null;
	if(sheet == null){
    	em = getSrcElement(e);
    	sheet = searchSheet(em);    	
    }
	
	//입력된 키 정보
	var keyCode = (e.which) ? e.which : e.keyCode;	// 키 코드
	var ctrlDown = getCtrlPressed(e);				// 컨트롤 // 커맨드(Mac지원)
	var altDown = getAltPressed(e);					// 알트
	var shiftDown = getShiftKeyPressed(e);			// 쉬프트
	//현재 행, 열 번호
	var rowNum = -1;
	var colNum = -1;

	//사용자 코딩 추가영역 호출
	var wResult = true;
	if(sheet.hasKeyDownEvent){
		wResult = sheet.fncKeyDownEvent(sheet.currentRow, sheet.currentCol, keyCode, shiftDown, ctrlDown, altDown);
	}	
	
    //컨트롤, 알트, 쉬프트 키가 안 눌리고 방향키만 눌린 경우
    if( !ctrlDown && !altDown && !shiftDown && (keyCode >= 37 && keyCode <= 40) ){
    	rowNum = sheet.currentRow;
    	colNum = sheet.currentCol;
    	
//    	console.log("Current Row : " + rowNum);
//    	console.log("Current Col : " + colNum);
    	
    	//방향키 동작
    	if(keyCode == 37){			//왼쪽
    		colNum = (colNum - 1 > 1) ? colNum - 1 : 1;
    		sheet.setCurrentCol(colNum);
    	}
    	else if(keyCode == 39){		//오른쪽
    		colNum = (colNum + 1 <= sheet.maxCols) ? colNum + 1 : sheet.maxCols;
    		sheet.setCurrentCol(colNum);
    	}
    	else if(keyCode == 38){		//위
    		rowNum = (rowNum - 1 > 1) ? rowNum - 1 : 1;
    		sheet.setCurrentRow(rowNum);
    	}
    	else if(keyCode == 40){		//아래
    		rowNum = (rowNum + 1 <= sheet.maxRows) ? rowNum + 1 : sheet.maxRows;
    		sheet.setCurrentRow(rowNum);
    	}
    }
    
    return true;
};

/*function auiSheet_editBegin(e, aSheet){
	var wReturn = true;
	
	var rowNum = e.rowIndex + 1;
	var colNum = e.columnIndex + 1;

	//컬럼에 잠금 조건이 있는지 체크
	var columnObject = (AUIGrid.getColumnInfoList(aSheet.AUIcontrolId))[e.columnIndex];
	var lockFunction = (columnObject != undefined) ? columnObject.lockFunction : null;
	var isFunction = (typeof(lockFunction) == "function") ? true : false;
	
	//잠금 조건이 있는 경우, 잠금 조건에 의한 잠금여부 리턴
	if(lockFunction && isFunction){
		wReturn = lockFunction(rowNum, colNum);
	}

	//잠금 여부는 boolean 형으로 리턴되야 하므로 삼항연산으로 true 또는 false로 변환
	wReturn = wReturn ? true : false;
	
	// dataset logical 데이터는 편집 불가
	if (typeof DataSet != "undefined" && typeof DataSet.prototype.rowTypeOf_$uid != "undefined"){
		var dateset = dataSets[aSheet.bindDataset];
		if (dateset._GroupKey.trim().length > 0 && 
			"Logical" == dateset.rowTypeOf_$uid(e.item._$uid)){
			wReturn = false;
		};
	}
	
	//리턴 : true(편집가능) / false(편집불가능)
	return wReturn;
}*/

//2016-06-26 사장님 스크립트 변경(기존 소스는 상단에 주석처리)
function auiSheet_editBegin(e, aSheet){
	var wReturn = true;
	
	var rowNum = e.rowIndex + 1;
	var colNum = e.columnIndex + 1;

	//컬럼에 잠금 조건이 있는지 체크
	var columnObject = (AUIGrid.getColumnInfoList(aSheet.AUIcontrolId))[e.columnIndex];
	var lockFunction = (columnObject != undefined) ? columnObject.lockFunction : null;
	var isFunction = (typeof(lockFunction) == "function") ? true : false;
	
	//잠금 조건이 있는 경우, 잠금 조건에 의한 잠금여부 리턴
	if(lockFunction && isFunction){
		wReturn = lockFunction(rowNum, colNum);
	}

	//잠금 여부는 boolean 형으로 리턴되야 하므로 삼항연산으로 true 또는 false로 변환
	wReturn = wReturn ? true : false;
	
	// dataset logical 데이터는 편집 불가
	// bindDataset이 처리되지 앟은 구버전을 위한 코딩 추가 
	if (typeof DataSet != "undefined" && typeof DataSet.prototype.rowTypeOf_$uid != "undefined"){
		if (aSheet.bindDataset == "") {
                var ds = aSheet.getBindDataset();
                aSheet.bindDataset = (ds == null ? "" : ds.id);
		}
		var dateset = dataSets[aSheet.bindDataset];
		if (typeof dateset != "undefined"){
			if (dateset._GroupKey.trim().length > 0 && 
				"Logical" == dateset.rowTypeOf_$uid(e.item._$uid)){
				wReturn = false;
			};
		}
	}
	
	//리턴 : true(편집가능) / false(편집불가능)
	return wReturn;
};

function auiSheet_setValueBefore(e, aSheet){
	var result = true;
	var value = e.value;
	var oldValue = e.oldValue;
	var row = e.rowIndex + 1;
	var oldRow = aSheet.currentRow;
	var col = e.columnIndex + 1;
	var oldCol = aSheet.currentCol;
	
	var columnInfo = (typeof AUIGrid.getColumnInfoList == "function" ? AUIGrid.getColumnInfoList(aSheet.AUIcontrolId) : AUIGrid.getColumnLayout(aSheet.AUIcontrolId));
	
	//입력된 값의 컬럼의 타입이 날짜인 경우 / 구분자를 제거
	if(columnInfo[e.columnIndex].dataType == "date"){
		e.value = value.replace(/[/-]/g, "");
		
		value = value.replace(/[/-]/g, "");		
		oldValue = oldValue.replace(/[/-]/g, "");		
	}
	
	// dataset 현재줄 추가 기능 
	if (columnInfo[e.columnIndex].dataType != "checkbox" && typeof(AUIDataSheet.prototype._UpdateCheckDataset) != "undefined"){
		aSheet.setCurrentRow(row);
		aSheet.setCurrentCol(col);
		result = aSheet._UpdateCheckDataset(e.item._$uid, col, oldValue, value );
	}
	if (!result){
		aSheet.setCurrentRow(oldRow);
		aSheet.setCurrentCol(oldCol);
		e.value = e.oldValue;
	}
	
	return e.value;
};
/** 이벤트 함수 끝 **/


AUIDataSheet.prototype.exoRowClear = function(){
	this.rows = [null];
	this.rows[1] = new EXORow();
	this.rows[1].newData = true;
};

AUIDataSheet.prototype.setEnabled = function(enabled){
	// functionname : [Control.setEnabled]

	this.enabled = enabled;
	// 하위 테그들의 글자색 조정
    this.tagObject.disabled = !enabled;
};


AUIDataSheet.prototype.setVisible = function(visible){
	// functionname : [Control.setVisible]

	if (this.visible == visible) return;
	this.visible = visible;

	var obj =  this.tagObject;
	var comp = obj.currentStyle ? obj.currentStyle : getComputedStyle(obj, null);
	
    if (("" + comp.position).toLowerCase() == "absolute" || ("" + comp.position).toLowerCase() == "relative"){
    	if (visible){
    		if (obj.style.left == "-10000px"){
    			obj.style.left = obj.getAttribute("xposition");
    		}
    	} else {
    		obj.setAttribute("xposition", obj.style.left);
    		obj.style.left = "-10000px";
    	}
    	this.tagObject.style.display = (visible ? "block" : "none");
    } else {
    	this.tagObject.style.display = (visible ? "inline" : "none");
    }
    
    if(typeof resizeControls == "function") resizeControls();
    
    this.resize();
    
    return;
};


AUIDataSheet.prototype.setCurrentRow = function(rowNum){
    // functionname : [AUIDataSheet.setCurrentRow]
	if (this.currentRow == rowNum) return;
	if(rowNum > this.maxRows){
		alert(getText("message_AUIDataSheet_016", "현재의 줄 수 {0} 보다 클 수는 없습니다.", [this.maxRows]));
		return;
	}

	var oldRowNum = this.currentRow;
	this.currentRow = rowNum;
	
	// dataset 현재줄 갱신 기능 
	if (typeof(AUIDataSheet.prototype._UpdateDatasetRowPos) != "undefined"){
//    	var availableRowNum = this.convertToDsRowNum(rowNum);
//    	if (availableRowNum > 0){
//    		this._UpdateDatasetRowPos(availableRowNum);
//    	}
		var row = AUIGrid.getItemByRowIndex(this.AUIcontrolId, rowNum -1);
		if(row != null){
			var uid = row._$uid;
			this._UpdateDatasetRowPos(uid);
		}
	}
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		if (this.sheetType == SHEETTYPE_LISTSHEET){
	        if (this.hasRowChangeEvent) this.fncRowChangeEvent(oldRowNum, rowNum);
		}
		else if(this.rows[rowNum]){
	        if (this.hasRowChangeEvent) this.fncRowChangeEvent(oldRowNum, rowNum, this.fillKeyField? 1: this.rows[rowNum].objectSeq);
		}
		/*
		 * 	임시조치(2016-03-01)
		 * 	setData 시 객체의 rows 에 EXORow를 생성/추가하지 않는다.
		 */
		else{
			if (this.hasRowChangeEvent) this.fncRowChangeEvent(oldRowNum, rowNum);
		}
	}
	
	return;
};

AUIDataSheet.prototype.setCurrentCol = function(colNum){
    // functionname : [AUIDataSheet.setCurrentCol]
	
	if (this.currentCol == colNum) return;
	if(colNum > this.maxCols){
		alert(getText("message_AUIDataSheet_017", "현재의 열 수 {0} 보다 클 수는 없습니다.", [this.maxCols]));
		return;
	}

	var oldColNum = this.currentCol;
	this.currentCol = colNum;
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
	    if (this.hasColChangeEvent){
	    	this.fncColChangeEvent(oldColNum, colNum);
	    }	
	}
	
	return;
};

AUIDataSheet.prototype.refresh = function(){
    // functionname : [AUIDataSheet.refresh]
    // 셀값들을 다시 채운다.
	
	AUIGrid.refresh(this.AUIcontrolId);
	
    return;
};

// 선택한 줄 뒤로 줄이 추가된다
// pAtRowNum가 생략된다면 현재 마지막에 추가된다
// objectSeq는 데이터 순번으로 선택항목이다
AUIDataSheet.prototype.addRow = function(atRowNum, Decoration, updateDataset){
    // functionname : [AUIDataSheet.addRow]

    Decoration = (typeof Decoration == "undefined" ? "last" : (Decoration == null ? "last" : Decoration));

    if(atRowNum == undefined || atRowNum == null) atRowNum = this.maxRows; 
    
    // "선택한 줄 뒤"로 줄이 추가된다
    var nNewRow = atRowNum + 1;
    
    // 산식때문에 문자열로 받아서 eval하여 넣어준다.
	//AUIGrid.addRow(this.AUIcontrolId, eval(this.defaultLayoutValue), nNewRow - 1, Decoration);
	//AUIGrid.addRow(this.AUIcontrolId, eval(this.defaultLayoutValue), nNewRow - 1);
    AUIGrid.addRow(this.AUIcontrolId, this.defaultLayoutValue_JSON, nNewRow - 1);


	// dataset 현재줄 추가 기능 
	if(updateDataset == undefined || updateDataset){
		if (typeof(AUIDataSheet.prototype._UpdateDatasetAddRow) != "undefined"){
			var availableRowNum = this.getAvailableRowNum(nNewRow);
			if (availableRowNum > 0){
				this._UpdateDatasetAddRow(availableRowNum);
			}
		}
	}
	
    return nNewRow;
};

// 지정줄 삭제 (atRowNum 위치의 줄을 삭제한다)
AUIDataSheet.prototype.delRow = function(atRowNum, Decoration, updateDataset){
	if (this.maxRows == 0) return;

    Decoration = (typeof Decoration == "undefined" ? "last" : (Decoration == null ? "last" : Decoration));

	// rowIndex가 없을시 현재 선택된 줄
	atRowNum = (atRowNum == undefined? this.currentRow: atRowNum);
	var uid = AUIGrid.getItemByRowIndex(this.AUIcontrolId, atRowNum - 1)._$uid;

	var delRows = AUIGrid.getSelectedItems(this.AUIcontrolId);
	var delRowLen  = delRows.length;
	
	if(delRowLen < 2 || Decoration){
		AUIGrid.removeRow(this.AUIcontrolId, atRowNum - 1);
	}
	else {
		var items = [];
		// rowIdField가 지정되어 있을때 
		if(this.rowIdField != null){
			for(var i = 0; i<delRowLen; i++){
				items.push(delRows[i].item[this.rowIdField]);
			}
		}
		// 지정되어있지 않다면 내부 rowId(_$uid)가 생성되어있다
		else{
			for(var i = 0; i<delRowLen; i++){
				items.push(delRows[i].item._$uid);
			}
		}
		
		AUIGrid.removeRowByRowId(this.AUIcontrolId, items);
	}
	
	//auiSheet_removeRow 호출됨
    // dataset 현재줄 삭제 기능 
	if(updateDataset == undefined || updateDataset){
		if (typeof(AUIDataSheet.prototype._UpdateDatasetDelRow) != "undefined"){
			this._UpdateDatasetDelRow(uid);
		}
	}
	
    return;
};

//지정줄 삭제 ((uid, 의 줄을 삭제한다) 한 데이터내의 두번째이상의 줄의 아이디를 주면 동작 안함
AUIDataSheet.prototype.delRowByUid = function(uid, Decoration, updateDataset){
	if (this.maxRows == 0) return;
    Decoration = (typeof Decoration == "undefined" ? "last" : (Decoration == null ? "last" : Decoration));

	// rowIndex가 없을시 현재 선택된 줄
	var AUIRowNum = this.getIndexOf_$uid(uid);
	var atRowNum = AUIRowNum + 1;
	
	var delRows = AUIGrid.getSelectedItems(this.AUIcontrolId);
	var delRowLen  = delRows.length;
	
	if(delRowLen < 2 || Decoration){
		AUIGrid.removeRow(this.AUIcontrolId, atRowNum - 1);
	}
	else {
		var items = [];
		// rowIdField가 지정되어 있을때 
		if(this.rowIdField != null){
			for(var i = 0; i<delRowLen; i++){
				items.push(delRows[i].item[this.rowIdField]);
			}
		}
		// 지정되어있지 않다면 내부 rowId(_$uid)가 생성되어있다
		else{
			for(var i = 0; i<delRowLen; i++){
				items.push(delRows[i].item._$uid);
			}
		}
		
		AUIGrid.removeRowByRowId(this.AUIcontrolId, items);
	}
	
	//auiSheet_removeRow 호출됨
    // dataset 현재줄 삭제 기능 
	if(updateDataset == undefined || updateDataset){
		if (typeof(AUIDataSheet.prototype._UpdateDatasetDelRow) != "undefined"){
			this._UpdateDatasetDelRow(uid);
		}
	}
	
    return;
};

AUIDataSheet.prototype.setMaxRows = function(rows){
    // functionname : [AUIDataSheet.setMaxRows]
    if (this.maxRows > rows){
        for (var wRowNum = this.maxRows; wRowNum > rows; wRowNum--){
            this.delRow(wRowNum);
        }
        
    } else if (this.maxRows < rows){
        for (var wRowNum = this.maxRows; wRowNum < rows; wRowNum++){
            this.addRow(this.maxRows, true);
        }
    }
    
    return;
};

// 원하는 숫자만큼의 줄을 추가 후, 데이터를 추가할 수 있는 첫줄번호를 리턴
AUIDataSheet.prototype.addRows = function(rows){
    // functionname : [AUIDataSheet.addRows]

    var wRow = this.maxRows;
//    while (wRow > 0 && this.isEmptyRow(wRow)) wRow--;
    this.setMaxRows(wRow + rows);
    
    return wRow + rows;
};


AUIDataSheet.prototype.getValue = function(){
    // functionname : [AUIDataSheet.getValue]

    // 콤보 스타일에서 인수는 Logical 줄,열번호이다
    var wRowNum = this.currentRow;
    var wColNum = this.currentCol;
    var args = Array.prototype.slice.call(arguments);
    if (args.length == 1){
        wColNum = args[0];
    } else {
        wRowNum = args[0];
        wColNum = args[1];
    }
    
 	var value = "";
 	
    try{
    	var dataField = AUIGrid.getDataFieldByColumnIndex(this.AUIcontrolId, wColNum - 1);
    	value = AUIGrid.getItemByRowIndex(this.AUIcontrolId,wRowNum-1)[dataField];
    } catch(e){
    	value =  "";
    }
    
    return value;
};

//인수가 하나만 넘어왔을 경우 컬럼번호로 인식하고 해당 컬럼의 모든 데이터를 배열로 리턴한다.
AUIDataSheet.prototype.getColumnValue = function(){
    // functionname : [AUIDataSheet.getValue]
	// 인수가 하나만 넘어왔을 경우 컬럼번호로 인식하고 해당 컬럼의 모든 데이터를 배열로 리턴한다.
	var returnArray = false;
	// 리턴값
	var returnValue = [];
	
    // 콤보 스타일에서 인수는 Logical 줄,열번호이다
    var wRowNum = this.currentRow;
    var wColNum = this.currentCol;
    var args = Array.prototype.slice.call(arguments);
    if (args.length == 1){
        wColNum = args[0];
        returnArray = true
    } else {
        wRowNum = args[0];
        wColNum = args[1];
    }
    
    try{
    	// 해당 컬럼의 데이터필드 값
    	var dataField = AUIGrid.getDataFieldByColumnIndex(this.AUIcontrolId, wColNum - 1);
    	var bindDataset = (this.bindDataset.length > 0) ? dataSets[this.bindDataset] : undefined;
    	
    	if(returnArray){
    		//시트와 데이터셋 모두 그룹핑 정보가 없는 경우
    		if( this.groupingFields.length == 0 && (typeof bindDataset == "undefined" || (typeof bindDataset != "undefined" && (bindDataset._GroupKey + "").length == 0)) ){
    			returnValue = AUIGrid.getColumnValues(this.AUIcontrolId, dataField);
    		}
    		//시트의 그룹핑 정보가 있는 경우
    		else if(this.groupingFields.length > 0){
    			var gridData = AUIGrid.getGridData(this.AUIcontrolId);
    			for(var i = 0; i < gridData.length; i++){
    				if(typeof gridData[i]._$groupParentValue != "undefined" && gridData[i]._$groupParentValue.length > 0){
    					returnValue.push( (gridData[i])[dataField] );
    				}
    			}
    		}
    		//데이터셋의 그룹핑 정보가 있는 경우
    		else if((bindDataset._GroupKey + "").length > 0){
    			//연결 컬럼 찾기
    			var bindKey = "";
    			var colId = "";
    			for(bindKey in bindDataset.dataBinds){
    				if(wColNum == bindDataset.dataBinds[bindKey].colIndex){
    					colId = bindDataset.dataBinds[bindKey].colId;
    					break;
    				}
    			}
    			//데이터 생성
    			var records = bindDataset.records;
    			for(var i = 0; i < records.length; i++){
    				if(records[i].RowType != "Logical"){
    					returnValue.push( (records[i]).values[colId] );
    				}
    			}
    		}
    	}
    	else{
    		returnValue = AUIGrid.getItemByRowIndex(this.AUIcontrolId,wRowNum-1)[dataField];
    	}
    } catch(e){
    	returnValue = "";
    }
    
    return returnValue;
};

// 사용자에 의해 줄추가된 데이터만 가져온다. * 배열로 행,로우 전체를 가져옴
AUIDataSheet.prototype.getAddedRowItems = function(){
	return AUIGrid.getAddedRowItems(this.AUIcontrolId);
};

//수정된 데이터를 가져온다. * 배열로 행,로우 전체를 가져옴
AUIDataSheet.prototype.getEditedRowItems = function(){
	return AUIGrid.getEditedRowItems(this.AUIcontrolId);
};

// 삭제된 데이터를 가져온다 ( 줄추가되었다 삭제된 행은 제외) * 배열로 행,로우 전체를 가져옴)
AUIDataSheet.prototype.getRemoveItems = function(){
	return AUIGrid.getRemovedItems(this.AUIcontrolId);
};

// 해당 줄의 I,U,D,N 플래그를 가져온다
AUIDataSheet.prototype.getIUDNFlag = function(rowNum){
	// 인자값이 없을때는 현재 줄번호
	if(!rowNum) rowNum = this.currentRow;
    
    var data = AUIGrid.getItemByRowIndex(this.AUIcontrolId, rowNum-1);
    // 없는 데이터라면 null 리턴
    if(data == undefined || data == null) return null;
    
	var rowId = data._$uid;
	
	// 플래그 찾기
	// 추가된 데이터
	var array_IUDN = this.getAddedRowItems();
	for(var i=0; i<array_IUDN.length; i++){
		if(array_IUDN[i]._$uid == rowId){
			return "I";
		}
	}
	// 수정된 데이터
	array_IUDN = this.getEditedRowItems();
	for(var i=0; i<array_IUDN.length; i++){
		if(array_IUDN[i]._$uid == rowId){
			return "U";
		}
	}
	// 삭제된 데이터
	array_IUDN = this.getRemoveItems();
	for(var i=0; i<array_IUDN.length; i++){
		if(array_IUDN[i]._$uid == rowId){
			return "D";
		}
	}
	
	return "N"    
};

// 해당 colNum의 [추가된데이터["I"], 수정된데이터["U"], 삭제된데이터["D"], 나머지 데이터["N"]] 배열을 리턴 (I,U,D,N)
AUIDataSheet.prototype.getIUDNStatusColumnValue = function(colNum){
	var returnValue = [];
	var value = [];
	var array_I = [];
	var array_U = [];
	var array_D = [];
	var array_N = [];
	var rowIdField = AUIGrid.getProperty(this.AUIcontrolId, "rowIdField");
	
	// colNum이 없을 경우 현재 선택된 colNum을 넣어준다.
	if(!colNum) colNum = this.currentCol;
	
	// 추가된 데이터
	array_I = this.getAddedRowItems();
	for(var i=0; i<array_I.length; i++){
		value.push(array_I[i]["f" + colNum] == undefined? "": array_I[i]["f" + colNum]);
	}
	returnValue["I"] = value;
	value = [];
	
	// 수정된 데이터
	array_U = this.getEditedRowItems();
	for(var i=0; i<array_U.length; i++){
		value.push(array_U[i]["f" + colNum] == undefined? "": array_U[i]["f" + colNum]);
	}
	returnValue["U"] = value;
	value = [];
	
	// 삭제된 데이터
	array_D = this.getRemoveItems();
	for(var i=0; i<array_D.length; i++){
		value.push(array_D[i]["f" + colNum] == undefined? "": array_D[i]["f" + colNum]);
	}
	returnValue["D"] = value;
	value = [];
	
	// 나머지 일반(조회된) 데이터
	array_N = AUIGrid.getGridData(this.AUIcontrolId);
	N :
	for(var i=0; i<array_N.length; i++){
		for(var j=0; j<array_I.length; j++){
			if(array_I[j][rowIdField] == array_N[i][rowIdField]) continue N;
		}
		for(var j=0; j<array_U.length; j++){
			if(array_U[j][rowIdField] == array_N[i][rowIdField]) continue N;
		}
		for(var j=0; j<array_D.length; j++){
			if(array_D[j][rowIdField] == array_N[i][rowIdField]) continue N;
		}
		value.push(array_N[i]["f" + colNum] == undefined? "": array_N[i]["f" + colNum]);
	}
	returnValue["N"] = value;
	
	
	value = null; array_I = null; array_U = null; array_D = null; array_N = null; rowIdField = null;
	
	return returnValue;
};

// dni 모드인 객체의 데이터 미리 생성
AUIDataSheet.prototype.onReady = function(){
	this.rows = [null]; // 시트 데이터 rows 초기화
	
	this.maxRows = AUIGrid.getGridData(this.AUIcontrolId).length;
	
	if(this.fillKeyField) {
		this.rows[1] = new EXORow();
		return;
	}
	
	var arrData = this.linkedObjects;
	var dataLen = arrData.length;
	var dni = false;
	this.notSetValue = true;
	
	
	for(var i = 0; i < dataLen;i++){
		if(arrData[i].dniMode){
			dni = true;
		}else {
			arrData[i].notSetValue = true;
		}
	}
	
	
	if(!dni){
		this.rows[1] = new EXORow();
		for(var i = 0; i < dataLen;i++){
            arrData[i].setUpdateGu(1, "N");    // 2017.08.18 지운학
		}
	}
	else if(dni){
		for(var i = 0; i < dataLen;i++){
			// 객체의 체인지이벤트를 막고 데이터를 추가한다.
			var dataEvent = arrData[i].hasChangeEvent;
			arrData[i].hasChangeEvent = false;
			// 객체 및 시트 rows 데이터 생성
			for(var wRowNum = 1; wRowNum<=this.maxRows; wRowNum++){
				this.currentRow = wRowNum;
				// 이미 해당 인덱스의 객체가 추가 되어있는경우
				if(this.rows[wRowNum] != null || this.rows[wRowNum] != undefined) {
					arrData[i].seq = this.rows[wRowNum].objectSeq;
					//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
					if( !this.passEvent ){
						if(this.hasChangeEvent) this.fncChangeEvent(wRowNum);
					}
				} 
				// 해당 인덱스의 객체가 없을때 생성
				else {
					this.rows[wRowNum] = new EXORow();
					//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
					if( !this.passEvent ){
						if(this.hasAddRowDataEvent) this.fncAddRowDataEvent(wRowNum);
					}
					arrData[i].seq = this.rows[wRowNum].objectSeq;
					//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
					if( !this.passEvent ){
						if(this.hasChangeEvent) this.fncChangeEvent(wRowNum);
					}
				}
			}
			
			arrData[i].hasChangeEvent = dataEvent;
		}
	}
	
	for(var i = 0; i < dataLen;i++){
		arrData[i].notSetValue = false;
	}
	
	this.notSetValue = false;
	
	return;
};

//기존 소스와의 호환성
AUIDataSheet.prototype.setValueAll = function(){
	return;
};

//한컬럼 전체에 동일한 값 세팅
AUIDataSheet.prototype.setValueAllColumn = function(colNum, value) {
	
	// updateAllToValue함수는 업데이트 표시가 남지 않아 막음
	AUIGrid.updateAllToValue(this.AUIcontrolId, "f" + colNum, value);
	
	// 그리드의 전체 데이터를 대상으로 컬럼의 값을 바꿈
//	for(var i=1; i<=this.maxRows; i++){
//		this.setValue(i, colNum, value);
//	}
	
	//Dataset을 사용하지 않은 경우
	if(typeof(AUIDataSheet.prototype._UpdateDatasetList) != "undefined"){
		this._UpdateDatasetList();
	}
	
	return;
};

// 이미 해당 인덱스의 객체가 있을때 수정된 필드만 고친다
AUIDataSheet.prototype.setValue = function(){
	if(this.notSetValue/* || this.fillKeyField*/) return;
	
	var target = "B";			// B : 본문 / F : 푸터
	var wRowNum = this.currentRow;
    var wColNum = this.currentCol;
    var wValue;
    var updateDataset = true;
    
    var args = Array.prototype.slice.call(arguments);
    if (args.length == 1){
        wValue = args[0];
    } else if (args.length == 2){
        wColNum = args[0];
        wValue = args[1];
    } else if(args.length == 3){
    	if(typeof args[0] == "string" && (args[0] == "B" || args[0] == "F")){
    		target = args[0];
            wColNum = args[1];
            wValue = args[2];
    	}
    	else{
    		wRowNum = args[0];
    		wColNum = args[1];
    		wValue = args[2];
    	}
    } else if(args.length == 4){
    	if(typeof args[0] == "string" && (args[0] == "B" || args[0] == "F")){
    		target = args[0];
    		wRowNum = args[1];
            wColNum = args[2];
            wValue = args[3];
    	}
    	else{
    		wRowNum = args[0];
    		wColNum = args[1];
    		wValue = args[2];
    		updateDataset = args[3];
    	}
    } else {
    	target = args[0];
    	wRowNum = args[1];
		wColNum = args[2];
		wValue = args[3];
		updateDataset = args[4];
    }
    
    if(target == "F"){
    	this.setFooter(wColNum, wValue);
    	return;
    }
    	 
	var dataField = "f" + wColNum;
	var item = {};    
	item[dataField] = wValue;
	
	// 기존과 값이 동일하다면 리턴
	if(this.getValue(wRowNum, wColNum) == wValue) return;
	
	try {
		AUIGrid.updateRow(this.AUIcontrolId, item, wRowNum - 1);
	} catch(e){
		try {
			AUIGrid.updateRow(this.AUIcontrolId, item, wRowNum - 1);
		} catch(e){
			console.log(e);
		}
	}	
	
	var arrData = this.linkedObjects;
	var dataLen = arrData.length;
	
	if(dataLen > 0){
		// 이미 해당 인덱스의 객체가 추가 되어있는경우 ( setValue를 탈땐 데이터row가 추가되어 있음)
		if(this.rows[wRowNum] != null || this.rows[wRowNum] != undefined) {
			for (var i = 0; i < dataLen; i++) {
				arrData[i].newData = this.rows[wRowNum].newData;
				arrData[i].seq = this.rows[wRowNum].objectSeq;
			}
		}
	}
	
	// dataset 갱신 기능 
	if(updateDataset == undefined || updateDataset){
	    if (typeof(AUIDataSheet.prototype._UpdateDataset) != "undefined"){
//	    	var availableRowNum = this.convertToDsRowNum(wRowNum);
//	    	if (availableRowNum > 0){
//	    		this._UpdateDataset(availableRowNum, wColNum);
//	    	}
	    	var row = AUIGrid.getItemByRowIndex(this.AUIcontrolId, wRowNum -1);
			if(row != null){
				var uid = row._$uid;
	        	this._UpdateDataset(uid, wColNum);	
			}
	    }
	}
	
	var keyCode = undefined;
	if(typeof window.event != "undefined" && window.event instanceof KeyboardEvent){
		keyCode = window.event.keyCode;
	}
	
    //passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		if (this.hasChangeEvent) this.fncChangeEvent(wRowNum, wColNum, wValue, keyCode);
	}
	
	return;
};

AUIDataSheet.prototype.setFooter = function(colNum, value){
	if(isNaN(colNum) || colNum > this.maxCols || colNum <= 0){
		//현재 시트의 열 범위 내 아님
		return false;
	}
	
	var footerObject = null;
	
	if( this.pivotBound ){
//		var colInfo = (AUIGrid.getColumnInfoList(this.AUIcontrolId))[colNum - 1];
//		var footerObject = null;
//		if( !(this.footerObjectPivot instanceof Array) ){
//			this.footerObjectPivot = [];
//		}
//		
//		for(var i = 0; i < this.footerObjectPivot.length; i++){
//			if(this.footerObjectPivot[i].dataField == colInfo.dataField){
//				footerObject = this.footerObjectPivot[i];
//				break;
//			}
//		}
		
		this.footerObjectPivot = AUIGrid.getFooterLayout(this.AUIcontrolId);
		footerObject = this.footerObjectPivot[colNum - 1];
		
		if(footerObject == null){
			footerObject = {};
			this.footerObjectPivot.push(footerObject);
		}
		
		footerObject["positionField"] = (typeof footerObject.positionField != "undefined") ? footerObject.positionField : footerObject.dataField;
		footerObject["style"] = footerObject.style;
		footerObject["labelText"] = value;
		
		AUIGrid.setFooter(this.AUIcontrolId, this.footerObjectPivot);
	}
	else{
		footerObject = this.footerObject[colNum - 1];
		footerObject["labelFunction"] = null;
		footerObject["labelText"] = value;
		
		AUIGrid.setFooter(this.AUIcontrolId, this.footerObject);		
	}
	
	AUIGrid.refresh(this.AUIcontrolId);
	
	return true;
};

// 수정된 인덱스의 전체 값을 객체로 한줄 추가
AUIDataSheet.prototype.setValueAUI = function(){
	
	var wRowNum = this.currentRow;
    var wColNum = this.currentCol;
    var wValue = "";
    var wOldValue = "";
    var keyCode = "";
    
    var args = Array.prototype.slice.call(arguments);
    if (args.length == 1){
        wValue = args[0];
    } else if (args.length == 2){
        wColNum = args[0];
        wValue = args[1];
    } else if (args.length == 3){
        wRowNum = args[0];
        wColNum = args[1];
        wValue = args[2];
    } else if (args.length == 4){
        wRowNum = args[0];
        wColNum = args[1];
        wValue = args[2];
        wOldValue = args[3];
    } else if (args.length == 5){
        wRowNum = args[0];
        wColNum = args[1];
        wValue = args[2];
        wOldValue = args[3];
        keyCode = args[4];
    }
    
	this.setCurrentRow(wRowNum);
	this.setCurrentCol(wColNum);
	
	var arrData = this.linkedObjects;
	var dataLen = arrData.length;
	
	if(dataLen > 0){
		// 이미 해당 인덱스의 객체가 추가 되어있는경우
		if(this.rows[wRowNum] != null || this.rows[wRowNum] != undefined) { 
			for (var i = 0; i < dataLen; i++) {
				arrData[i].newData = this.rows[wRowNum].newData;
				arrData[i].seq = this.rows[wRowNum].objectSeq;
				arrData[i].dataUp = true; // 데이터row가 이미 바뀌어 있더라도 updateGu를 업데이트하기 위해
			}
		} 
		// 해당 인덱스의 객체가 없을때 생성 ( 시트에 링크된 객체가 모두 dni모드가 아니고 줄추가한 데이터도 아닐때 타게된다 )
		else {
			this.rows[wRowNum] = new EXORow();
			if(this.hasAddRowDataEvent) this.fncAddRowDataEvent(wRowNum);
			for (var i = 0; i < dataLen; i++) {
				arrData[i].seq = this.rows[wRowNum].objectSeq;
			}
		}
	}
	
    // dataset 갱신 기능 
    if (typeof(AUIDataSheet.prototype._UpdateDataset) != "undefined"){
//    	var availableRowNum = this.convertToDsRowNum(wRowNum);
//    	if (availableRowNum > 0){
//    		this._UpdateDataset(availableRowNum, wColNum);
//    	}
        var row = AUIGrid.getItemByRowIndex(this.AUIcontrolId, wRowNum -1);
		if(row != null){
			var uid = row._$uid;
        	this._UpdateDataset(uid, wColNum);	
		}
    }

    // 이벤트
    //passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		if(this.hasChangeEvent) this.fncChangeEvent(wRowNum, wColNum, wValue, wOldValue, keyCode);
	}
	
	for (var i = 0; i < dataLen; i++) {
		arrData[i].newData = false;
		arrData[i].dataUp = false;
	}
	
	return;
};


//현재 선택된 시트의 줄을 한칸 올린다
AUIDataSheet.prototype.upRow = function(){
    // functionname : [AUIDataSheet.upRow]

	// 현재 선택된 데이터(다중선택도 고려)
	var selectDatas = AUIGrid.getSelectedItems(this.AUIcontrolId);
	
	if (this.maxRows <= 1 || selectDatas[0].rowIndex == 0) return;
	
    // DataRow의 이동 (가장 위쪽 데이터 부터 이동)
    var wDataRow = null;
    var wDataRow2 = null;
	for(var i=0; i<selectDatas.length; i++){
		var currentrow = selectDatas[i].rowIndex + 1
		wDataRow = this.rows[currentrow];
		wDataRow2 = this.rows[currentrow - 1];
		//DataRow가 비어있는 경우 DataRow 행 이동을 동작하지 않음, setData 시 DataRow 채우는 동작 미구현되어있음
		if(wDataRow && wDataRow2){
			this.rows[currentrow] = wDataRow2;
			this.rows[currentrow] = wDataRow;
			wDataRow2.hardRowNum  = wDataRow.hardRowNum;
			wDataRow2.hardRowNum2 = wDataRow.hardRowNum2;
			wDataRow.hardRowNum = wDataRow2.hardRowNum - this.rowsPerDataRow;
			wDataRow.hardRowNum2 = wDataRow2.hardRowNum - this.rowsPerDataRow;
		}
	}
    
    wDataRow = null;
    wDataRow2 = null;
    
    AUIGrid.moveRows2Up(this.AUIcontrolId);
    
    // dataset 현재줄 위로 이동 기능 
    if (typeof(AUIDataSheet.prototype._UpdateDatasetUpRow) != "undefined"){
    	var availableRowNum = this.getAvailableRowNum(this.currentRow);
    	if (availableRowNum > 0){
        	this._UpdateDatasetUpRow(availableRowNum);
    	}
    }
    
    this.setCurrentRow(this.currentRow - 1);
    
    return;
};

// 현재 선택된 시트의 줄을 한칸 내린다
AUIDataSheet.prototype.downRow = function(){
    // functionname : [AUIDataSheet.downRow]

	// 현재 선택된 데이터(다중선택도 고려)
	var selectDatas = AUIGrid.getSelectedItems(this.AUIcontrolId);
	
	if (this.maxRows <= 1 || selectDatas[selectDatas.length - 1].rowIndex + 1 == this.maxRows) return;

    // DataRow의 이동 (가장 아래쪽 데이터 부터 이동)
    var wDataRow = null;
    var wDataRow2 = null;
	for(var i=selectDatas.length - 1; i>=0; i--){
		var currentrow = selectDatas[i].rowIndex + 1
	    wDataRow = this.rows[currentrow];
	    wDataRow2 = this.rows[currentrow + 1];
	    //DataRow가 비어있는 경우 DataRow 행 이동을 동작하지 않음, setData 시 DataRow 채우는 동작 미구현되어있음
		if(wDataRow && wDataRow2){
		    this.rows[currentrow] = wDataRow2;
		    this.rows[currentrow + 1] = wDataRow;
		    wDataRow2.hardRowNum  = wDataRow.hardRowNum;
		    wDataRow2.hardRowNum2 = wDataRow.hardRowNum2;
		    wDataRow.hardRowNum = wDataRow2.hardRowNum + this.rowsPerDataRow;
		    wDataRow.hardRowNum2 = wDataRow2.hardRowNum + this.rowsPerDataRow;
		}
	}
    
    wDataRow = null;
    wDataRow2 = null;
    
    AUIGrid.moveRows2Down(this.AUIcontrolId);
    
    // dataset 현재줄 아래로 이동 기능 
    if (typeof(AUIDataSheet.prototype._UpdateDatasetDownRow) != "undefined"){
    	var availableRowNum = this.getAvailableRowNum(this.currentRow);
    	if (availableRowNum > 0){
        	this._UpdateDatasetDownRow(availableRowNum);
    	}
    }
    
    this.setCurrentRow(this.currentRow + 1);
    
    return;
};

// 시트 전페이지를 초기화 한다
AUIDataSheet.prototype.clear = function(){
	if(this.fillKeyField) return;
	// 데이터 클리어
	this.currentRow = 1;
//	this.exoRowClear();
	// AUIGrid 지우고 다시 생성
	AUIGrid.destroy(this.AUIcontrolId);
	this.create(this.AUIcontrolId);
	
	this.maxRows = 0;
	this._clicked_row_id = "";
	
	// dataset clear 기능 
    if (typeof(AUIDataSheet.prototype._UpdateDatasetClear) != "undefined"){
    	this._UpdateDatasetClear();
    }
	
    //passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// clear 이벤트를 호출하고 거기서는 연결된 객체의 시퀀스를 1로한다
		if (this.hasClearEvent) this.fncClearEvent();
	}
    
    return;
};

// 가져오기 실행전 클리어
AUIDataSheet.prototype.AUIClear = function(){
	// 데이터 클리어
	this.currentRow = 1;
	this.exoRowClear();
	// AUIGrid 지우고 다시 생성
	AUIGrid.destroy(this.AUIcontrolId);
	this.create(this.AUIcontrolId);
	
	this.maxRows = 0;
	this._clicked_row_id = "";
	
	// dataset 현재줄 아래로 이동 기능 
    if (typeof(AUIDataSheet.prototype._UpdateDatasetClear) != "undefined"){
    	this._UpdateDatasetClear();
    }
	
	return;
};


AUIDataSheet.prototype.clearRow = function(pRowNum){
    // functionname : [AUIDataSheet.clearRow]
	AUIGrid.refreshRows(this.AUIcontrolId, [{}], "my-flash-style", 200); 
	
    return;
};

AUIDataSheet.prototype.clearCurrentSeq = function(){
    // functionname : [AUIDataSheet.clearCurrentSeq]
    this.clearRow(this.currentRow);
    return;
};

AUIDataSheet.prototype.cellChange = function(wRowNum, wColNum){
	// 선택한 줄 데이터 로우 생성
	var arrData = this.linkedObjects;
	var dataLen = arrData.length;
	
	if(dataLen > 0) {
		// 화면 체우기 키가 연결된 객체가 있을때는 체인지 이벤트만 호출
		if(this.fillKeyField){
			this.setCurrentRow(wRowNum);
			//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
			if( !this.passEvent ){
				if(this.hasChangeEvent) this.fncChangeEvent(wRowNum);
			}
			return;
		}
		
		var dataloaded = objectManager.dataloaded;
		objectManager.dataloaded = false; // 클릭할때 업데이트 구분이 U로 들어가지 않게 하기위해
		this.notSetValue = true; // 클릭할때는 setValue 함수를 타지 않게 한다.
		
		// 해당 인덱스의 객체가 없을때 생성
		if(this.rows[wRowNum] == null || this.rows[wRowNum] == undefined) {
			// 객체의 체인지이벤트를 막고 데이터를 추가한다.
			for(var i = 0; i < dataLen;i++){
				arrData[i].hasAddRecordEvent = false;
			}
			
			this.rows[wRowNum] = new EXORow();
			//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
			if( !this.passEvent ){
				if(this.hasAddRowDataEvent) this.fncAddRowDataEvent(wRowNum);
			}
			
			for(var i = 0; i < dataLen;i++){
				this.setCurrentRow(wRowNum); // onSeqChange가 일어나야 디폴트값이 들어간다.
				arrData[i].seq = this.rows[wRowNum].objectSeq; // 조회후 바로 첫줄을 클릭할때 currentRow가 1이라 데이터seq가 안바뀜
				arrData[i].hasAddRecordEvent = true;
				//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
				if( !this.passEvent ){
					if (arrData[i].hasAddRecordEvent) arrData[i].fncAddRecordEvent(); // 지금은 change 이벤트가 일어나지 않기 때문에 강제로 addRecordEvent를 호출해준다.
				}
			}
		}
		
		this.setCurrentRow(wRowNum);
		
		if(arrData[0].getUpdateGu(this.rows[wRowNum].objectSeq) != "X"){        // 2017.08.18 지운학 
			//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
			if( !this.passEvent ){
				if(this.sheetType == SHEETTYPE_LISTSHEET){ // 리스트 시트는 change 이벤트가 없다.
					if(this.hasClickEvent) this.fncClickEvent(wRowNum, wColNum);
				}else{
					if(this.hasChangeEvent) this.fncChangeEvent(wRowNum, wColNum);
				}
			}
		}
		
		objectManager.dataloaded = dataloaded;
		this.notSetValue = false;
	}
	
	return;
};

AUIDataSheet.prototype.click = function(wRowNum, wColNum){
    // functionname : [AUIDataSheet.click]
	this.setCurrentRow(wRowNum);
	this.setCurrentCol(wColNum);
	
	var type = "";
	try{ type = AUIGrid.getColumnInfoList(this.AUIcontrolId)[wColNum - 1].dataType; } catch(e) { /**/ }
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
	    // 사용자 코딩 추가영역을 호출한다
		if (this.hasImageClickEvent && type == "image"){
			var wResult = this.fncImageClickEvent(wRowNum, wColNum);
			if (typeof(wResult)=="boolean" && !wResult) {
				return false;
			}
			return;
		}
		if (this.hasClickEvent) {
			var wResult = this.fncClickEvent(wRowNum, wColNum);
			if (typeof(wResult)=="boolean" && !wResult) {
				return false;
			}            
		}
	}
	
    return;
};

AUIDataSheet.prototype.updateSeqFieldOfLinkedObject = function(){
    // functionname : [AUIDataSheet.updateSeqFieldOfLinkedObject]

	var newSeq = 1;
	for (var wRowNum = 1; wRowNum < this.rows.length; wRowNum++){
		var wRow = this.rows[wRowNum];
		var wObjectSeq = wRow.objectSeq;
		
    	for (var wObjectNum = 0; wObjectNum < this.linkedObjects.length; wObjectNum++){
    		var wObject = this.linkedObjects[wObjectNum];
    		wObject.updateSeqField(wObjectSeq, newSeq);
    	}
    	
    	newSeq++;
	}
	
	return;
};

// 시트 객체 시퀀스 재정렬
AUIDataSheet.prototype.updateObjectSeq = function(){
	
	var sheetRows = this.rows;
	var rowLength = sheetRows.length;
	
	for (var wRowNum = 1; wRowNum < rowLength; wRowNum++){
		sheetRows.objectSeq = wRowNum;
	}
};

AUIDataSheet.prototype.getRowNumOfObjectSeq = function(seq){
    // functionname : [AUIDataSheet.getRowNumOfObjectSeq]

	var wReturn = 1;
	for (var wRowNum = 1; wRowNum < this.rows.length; wRowNum++){
		var wRow = this.rows[wRowNum];
		if(wRow == undefined) continue;
		if (seq == wRow.objectSeq) {
			wReturn = wRowNum; break; 
		}
	}
	
	return wReturn;
};

//엑셀 또는 배열데이터 업로드
function setExcelData(jsonArrayObject, message, commandName, frameName, sheetName){
	// 오류 메시지 먼저 파악 
	if (jsonArrayObject == null){
       alert(message);
		this.errInfo = message;
		return;
	}
	sheetNameToPaste = sheetName;
	controls[sheetNameToPaste].setArrayData(jsonArrayObject, "excel");

	var wControl = controls[commandName];
	
	uploadControls[frameName].clearInfo();
	uploadControls[frameName] = null;
	wControl.uploadFrame = null;
	
	wControl.uploadFrame = uploadControls[frameName] = new IFrame_UploadXL_Command(frameName, commandName, sheetName);
	
	alert(getText("message_AUIDataSheet_018", "총 {0}건의 데이터를 붙여 넣었습니다.", [jsonArrayObject.data.length]));

	return;
};

AUIDataSheet.prototype.getDataForExcel = function(){
    // functionname : [AUIDataSheet.getDataForExcel]

    var arrFromStrings = [",", ":", ";", "&", "%", "?"];
    var arrToStrings   = ["<COMMA>", "<COLON>", "<SEMICOLON>", "<AMP>", "<PERCENT>", "<QUESTION>"];
	
    var generationInfo = new xlGenerationInfo();
	generationInfo.colsNum = this.headCols; // Column Header's Depth
	generationInfo.rowsNum = this.headRows; // Row Header's Depth
	
	generationInfo.rowsColors = "";
	
	/*
	 * var found = false;
     * var selectorText = ".colhead";
     *
	 * for (var cssSheetIndex = 0; cssSheetIndex <
	 * document.styleSheets.length; cssSheetIndex++){ var
	 * cssSheet=document.styleSheets[cssSheetIndex]; var cssRules =
	 * (cssSheet.cssRules? cssSheet.cssRules: cssSheet.rules); for (var
	 * cssRulesIndex = 0; cssRulesIndex < cssRules.length; cssRulesIndex++){
	 * var cssRule = cssRules[cssRulesIndex];
	 * 
	 * if(cssRule.selectorText.toLowerCase() == selectorText){ var
	 * colorString = "" + cssRule.style.backgroundColor; if
	 * (colorString.substring(0,1)=="#"){ colorString =
	 * colorString.substring(1); } else if
	 * (colorString.substring(0,4)=="rgb("){ colorString =
	 * colorString.substring(4, colorString.length - 1); var arrStrColors =
	 * colorString.split(","); var redString =
	 * parseInt(arrStrColors[0].trim(), 10).toString(16); var greenString =
	 * parseInt(arrStrColors[1].trim(), 10).toString(16); var blueString =
	 * parseInt(arrStrColors[2].trim(), 10).toString(16);
	 * 
	 * redString = (redString.length == 1 ? "0" : "") + redString;
	 * greenString = (greenString.length == 1 ? "0" : "") + greenString;
	 * blueString = (blueString.length == 1 ? "0" : "") + blueString;
	 * 
	 * colorString = "" + redString + greenString + blueString; }
	 * 
	 * generationInfo.rowsColors = colorString; found = true; break; }
	 *  } if (found) break; }
	 */

	var wStrColsWidths = this.tagObject.getAttribute("cellsize") || "";
	var wColsWidths = wStrColsWidths.split(";"); wStrColsWidths = "";
	for (var i = 0; i < wColsWidths.length; i++){
		if (wColsWidths[i].trim().length == 0) continue;
		var colWidth = Math.ceil(parseFloat(1 * wColsWidths[i]) / 7,5);
		wStrColsWidths += (i == 0 ? "" : "\t") + colWidth;
	}
	
	generationInfo.colsWidth = wStrColsWidths;
	
	generationInfo.data = "";
	

	// 칼럼해더정보 넘기기
	for (var rowNum = 0; rowNum < this.headRows; rowNum++){
		var wRow = this.dataTable.tBodies[0].rows[rowNum];
		for (var colNum = 1; colNum < wRow.cells.length; colNum++){
			generationInfo.data += (colNum == 0 ? "" : "\t") + escapeCharacter(wRow.cells[colNum].innerHTML,arrFromStrings, arrToStrings);
		}
		//generationInfo.data += ":\r\n";
		generationInfo.data += "<<%ENTER%>>";
	}
	
	// 데이터정보 넘기기
	for (var rowNum = 1; rowNum <= this.maxRows; rowNum++){
		var wHardRow  = this.rowNumOf(rowNum, 1, CONV_LOGICAL_HARD);
		var wRow = this.dataTable.tBodies[0].rows[wHardRow];
		for (var colNum = 0; colNum < this.headCols; colNum++){
			generationInfo.data += (colNum == 0 ? "" : "\t") + escapeCharacter(wRow.cells[colNum].innerHTML,arrFromStrings, arrToStrings);
		}
		
		for (var colNum = 1; colNum <= this.maxCols; colNum++){
			generationInfo.data += "\t" + escapeCharacter(this.rows[rowNum].cells[colNum].value,arrFromStrings, arrToStrings);
		}
		if (generationInfo.data.endsWith("\t")) generationInfo.data += " ";
		//generationInfo.data += (rowNum < this.maxRows ? ":\r\n" : "");
		generationInfo.data += (rowNum < this.maxRows ? "<<%ENTER%>>" : "");
	}
	return generationInfo;
};


AUIDataSheet.prototype.hideColumn = function(colNum){
	
//	var dataField = "f" + colNum;
	//2016-05-02(차중훈) 수정
	var dataField = "";
	//열번호 <-> dataField 변환
	dataField = AUIGrid.getDataFieldByColumnIndex(this.AUIcontrolId, colNum - 1);
	//dataField를 정상적으로 변환한 경우 열 숨기기 동작
	if(typeof dataField != "undefiend" && typeof dataField == "string" && dataField != null && dataField != ""){
		AUIGrid.hideColumnByDataField(this.AUIcontrolId, dataField);
	}
	else{
		return false;
	}
	
	// 염 숨김 : true / 에러 : false
	return true;
	//2016-05-02(차중훈) 수정
};

AUIDataSheet.prototype.showHiddenColumn = function(colNum){
	
//	var dataField = "f" + colNum;
	//2016-05-02(차중훈) 수정
	var dataField = "";
	//열번호 <-> dataField 변환
	dataField = AUIGrid.getDataFieldByColumnIndex(this.AUIcontrolId, colNum - 1);
	//dataField를 정상적으로 변환한 경우 열 보이기 동작
	if(typeof dataField != "undefiend" && typeof dataField == "string" && dataField != null && dataField != ""){
		AUIGrid.showColumnByDataField(this.AUIcontrolId, dataField);
	}
	else{
		return false;
	}
	
	// 염 보이기 : true / 에러 : false
	return true;
	//2016-05-02(차중훈) 수정
};

AUIDataSheet.prototype.setArrayData = function(jsonArrayObject, type){
	
	var jsonData = "[";
	
	var startRow = jsonArrayObject.row;
	var startCol = jsonArrayObject.col;
	var columnOrder = jsonArrayObject.columnOrder;
	var data = jsonArrayObject.data;
	
	var dataLen = data.length;
	
	for(var i=startRow - 1; i<dataLen; i++){
		jsonData += "{";
		for(var col=1; col<=this.maxCols; col++){
			var column = columnOrder[col];
			var excelData = "";
			if(!(column == undefined || column == null || column < 0)){
				excelData = data[i][column - 1];
			}
			
			jsonData += "f" + col + ':"' + excelData + '"' + (col<this.maxCols? ",": "");
		}
		jsonData += "}" + (i+1<dataLen? ",": "");
	}
	
	jsonData += "]";
	
	this.clear();
	
	//AUIGrid.setGridData(this.AUIcontrolId, eval(jsonData));
	this.setData( eval(jsonData) );
	
	//2016-07-12(추가) : 엑셀 업로드시 데이터셋의 레코드(버퍼 포함)의 RowType은 Insert가 되야한다.
	var dataset = this.getBindDataset();
	var filterExpr = "";
	if(this.getBindDataset() != null){
		filterExpr = dataset.FilterExpr;
		dataset.unFilter();
		
		for(var i = 0; i < dataset.getRowCount(); i++){
			dataset.buffer[i].RowType	= "Insert"; 
			dataset.records[i].RowType	= "Insert";
		}
		
		dataset.filter(filterExpr);
	}
	
	return;
};

/*
*   2016-02-16 추가(차중훈)
*/
AUIDataSheet.prototype.getRowNumByValue = function(colNum, value){
	var resultRowNum = -1;

	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		//현재 시트의 열 범위 내 아님, 숫자 아님
		return resultRowNum;
	}
	//배열인지 체크
	var isArray = (value instanceof Array);
	//행번호를 가져옴
	var dataField = AUIGrid.getDataFieldByColumnIndex(this.AUIcontrolId, colNum - 1);
	var rowNum = AUIGrid.getRowIndexesByValue(this.AUIcontrolId, dataField, value);
	//결과 정리
	if(rowNum.length <= 0){
		return resultRowNum;
	}
	if( !isArray ){
		//배열 아닌 경우 : 행 번호 리턴(Number)
		resultRowNum = (rowNum[0] * 1) + 1;
	}
	else{
		//배열인 경우 : {"값":"행번호", ...} 형식으로 리턴(JSON)
		var resJson = "{";
		for(var i = 0; i < rowNum.length; i++){
			resJson += ('"' + value[i] + '":"' + ((rowNum[i] * 1) + 1) + '"') + ((i + 1 < rowNum.length) ? "," : "");
		}
		resJson += "}";
		resultRowNum = eval( "(" + resJson + ")" );
	}
	//결과 리턴
	return resultRowNum;
};

AUIDataSheet.prototype.moveTo = function(rowNum, colNum, isShtControlSet){
	var rownum = 0;
	var colnum = 0;
	var oldRownum = -1;
	var oldColnum = -1;
	
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		//현재 시트의 행 범위 내 아님, 숫자 아님
		return false;
	}
	
	rownum = rowNum;
	colnum = (typeof colNum == "undefined" ? 1 : (isNaN(colNum) ? 1 : colNum));
	oldRownum = this.currentRow;
	oldColnum = this.currentCol;
	
	if(colNum > this.maxCols || colNum <= 0){
		//현재 시트의 열 범위 내 아님
		return false;
	}
	
	//현재 셀이므로 셀 이동은 안하고 스크롤 위치만 이동
	if(rowNum == oldRownum && colNum == oldColnum){
		if( !isShtControlSet ){
			return true;			
		}
	}
	//입력한 행 선택 후 스크롤 위치 이동
	else{
		if(typeof colNum != "undefined"){
		  AUIGrid.setSelectionByIndex(this.AUIcontrolId, rownum - 1, colnum - 1);
		}
		else{
			AUIGrid.setSelectionByIndex(this.AUIcontrolId, rownum - 1);
			colNum = colnum - 1;
		}
		
		//셀 이동 후 현재 행, 열 번호 변경
		if(rowNum != oldRownum){
			//행 번호 변동이 있으면 행 번호 변경
			this.setCurrentRow(rowNum);
		}
		if(colNum != oldColnum){
			//열 번호 변동이 있으면 열 번호 변경
			this.setCurrentCol(colNum);
		}
	}
	
	//입력한 행에 때라 수직 스크롤 이동
	AUIGrid.setRowPosition(this.AUIcontrolId, rownum - 1);
	//입력한 열에 따라 수평스크롤 이동
	AUIGrid.setHScrollPosition(this.AUIcontrolId, colnum - 1);
	
	//입력 활성화 체크
	if(isShtControlSet){
		this.shtControlSet(rowNum, colNum);
	}
	
	return true;
};

AUIDataSheet.prototype.moveToRow = function(rowNum){
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		//현재 시트의 행 범위 내 아님, 숫자 아님
		return false;
	}
	
	return this.moveTo(rowNum);
};

AUIDataSheet.prototype.selectRowByRowNum = function(rowNum){	
	return this.moveToRow(rowNum);
};

AUIDataSheet.prototype.countA = function(colNum, btrim){
	var resultCount = -1;
	var istrim = btrim ? true : false;
	
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		//현재 시트의 열 범위 내 아님, 숫자 아님
		return resultCount;
	}
	//해당 열번호의 열 목록을 배열로 가져옴
	var dataField = "f" + colNum;
	var colList = this.getColumnValue(colNum);
	//빈값이 아닌 배열의 갯수를 구함
	resultCount = 0;
	var data = null;
	for(var i = 0; i < colList.length; i++){
		data = colList[i];
		if( ((istrim) ? (data + "").trim() : data + "").length > 0 ) resultCount++;
	}
	
	return resultCount;
};

AUIDataSheet.prototype.countBlank = function(colNum, btrim){
	var resultCount = -1;
	var istrim = btrim ? true : false;
	
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		//현재 시트의 열 범위 내 아님, 숫자 아님
		return resultRowNum;
	}
	//해당 열번호의 열 목록을 배열로 가져옴
	var dataField = "f" + colNum;
	var colList = this.getColumnValue(colNum);
	//빈값인 배열의 갯수를 구함
	resultCount = 0;
	var data = null;
	for(var i = 0; i < colList.length; i++){
		data = colList[i];
		if( ((istrim) ? (data + "").trim() : data + "").length == 0 ) resultCount++;
	}
	
	return resultCount;
};

AUIDataSheet.prototype.countIF = function(colNum, condition, btrim){
	var resultCount = -1;
	var istrim = btrim ? true : false;
	
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		//현재 시트의 열 범위 내 아님, 숫자 아님
		return resultRowNum;
	}
	//해당 열번호의 열 목록을 배열로 가져옴
	var dataField = "f" + colNum;
	var colList = this.getColumnValue(colNum);
	//빈값인 배열의 갯수를 구함
	resultCount = 0;
	var data = null;
	for(var i = 0; i < colList.length; i++){
		data = colList[i];
		if( eval(((istrim) ? (data + "").trim() : data + "") + condition) ) resultCount++;
	}
	
	return resultCount;
};

AUIDataSheet.prototype.showNoDataMessage = function(isShowNoDataMsg, noDataMessage){
	if(isShowNoDataMsg != true && isShowNoDataMsg != false){
		return false;
	}
	
	try{
		//NO-DATA 이미지 보이기 여부
		AUIGrid.setProperty(this.AUIcontrolId, "showAutoNoDataMessage", isShowNoDataMsg);
		//NO-DATA 이미지 보이고 NO-DATA 메세지 사용자가 입력한 경우
		if(isShowNoDataMsg && noDataMessage && (noDataMessage + "").trim().length > 0){
			AUIGrid.setProperty(this.AUIcontrolId, "noDataMessage", noDataMessage);
		}

		AUIGrid.refresh(this.AUIcontrolId);
	}
	catch(err){
		return false;
	}
	
	return true;
};
/*
*   2016-02-16 추가(차중훈)
*/

AUIDataSheet.prototype.clearFilterByColNum = function(colNum){
	var dataField = "f" + colNum;
	
	try{
		AUIGrid.clearFilter(this.AUIcontrolId, dataField);
	}
	catch(e){
		return false;
	}
	
	return true;
};

AUIDataSheet.prototype.clearFilterAllColNum = function(){
	try{
		AUIGrid.clearFilterAll(this.AUIcontrolId);
	}
	catch(e){
		return false;
	}
	
	return true;
};

AUIDataSheet.prototype.setFilterToColumnByColNum = function(colNum, expression, customFucntion){
	//예외처리
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		//현재 시트의 열 범위 내 아님, 숫자 아님
		return false;
	}
	if(!customFucntion && (expression + "").trim().length <= 0){
		//사용자 정의 함수도 없고 비교 연산식도 없는 경우
		return false;
	}
	try{
		//데이터필드 생성
		var dataField = "f" + colNum;
		//default function :e-x-p-ression식으로 비교연산
		var defaultFunc = function(value, expression){
			return eval( ("\"" + (value + "").replace(/[\"\']/g, "\"") + "\"") + expression );
		};
		//필터적용함수 체크 : customFucntion을 입력하면 customFucntion를 적용
		var applyFilterFunc = (customFucntion) ? customFucntion : defaultFunc;
		//시트 필터 적용
		AUIGrid.setFilter(
				this.AUIcontrolId, 
				dataField, 
				function (dataField, value, item){
					return applyFilterFunc(value, expression);
				}
		);		
	}
	catch(err){
		return false;
	}
	
	return true;
};
/*
*   2016-02-18 추가(차중훈)
*/

/*
 * 	2016-02-23 추가(차중훈)
 */
AUIDataSheet.prototype.isEmptyRow = function(rowNum){
	//비어있지 않음 : true / 비어있음 : false / 행이 존재하지 않음 : undefined
	var wReturn = true;
	
	//파라메터로 받은 행의 데이터를 가져옴
	var rowItem = AUIGrid.getItemByRowIndex(this.AUIcontrolId, rowNum - 1);
	if(rowItem == null){
		//행이 없으므로 undefined 리턴
		return false;
	}
	
	//연결된 객체가 있는 경우
	//시트와 연결된 객체의 상태플래그를 기준으로 빈 행인지 비교
	if(this.linkedObjects.length > 0){
		//객체 연결된 상태의 경우 기존 DataSheet 분석 후 개발
		return wReturn;
	}
	
	//연결된 객체가 없는 경우
	//그리드 각 컬럼의 데이터 타입을 비교하여 빈값인지 비교
	var columnLayoutList = (typeof AUIGrid.getColumnInfoList == "function" ? 
			                    AUIGrid.getColumnInfoList(this.AUIcontrolId) :
			                    AUIGrid.getColumnLayout(this.AUIcontrolId));
	var columnLayout = null;
	var cellType = null;
	var cellData = null;
	for(var i = 0; i < columnLayoutList.length; i++){
		//컬럼의 정보와 셀의 데이터를 저장
		columnLayout = columnLayoutList[i];
		cellType = columnLayout.dataType;
		cellData = rowItem[columnLayout.dataField];
		//각 셀의 값이 컬럼의 데이터타입에 맞는 빈 값인지 비교
		wReturn = wReturn && (
			/*문자열*/	(cellType == "string" && (cellData + "").length == 0) ||
			/*날짜*/		(cellType == "date" && (cellData + "").length == 0) ||
			/*실수,정수*/	(cellType == "numeric" && (cellData + "" == "0" || cellData + "" == "0.0" || cellData + "" == "")) ||
			/*체크박스*/	(cellType == "checkbox" && (cellData + "").length == 0) ||
			/*콤보박스*/	(cellType == "combobox" && (cellData + "").length == 0) ||
			/*시간*/		(cellType == "time" && (cellData + "").length == 0) );
	}
	
	return wReturn;
};

// 2016-03-19 : 함수 수정 / 콘트롤간 이동 함수에서 클릭된 행이 있는지 체크
AUIDataSheet.prototype._getClickedRowItem = function(){
	return AUIGrid.getItemByRowId(this.AUIcontrolId, this._clicked_row_id);
};

// 2016-03-29 : 함수 복구 / 콘트롤간 이동에서 기존에 사용한 함수
AUIDataSheet.prototype.getSelectedCellPostion = function(){
	return this._getClickedRowItem();
};


// 2016-03-19 : 함수 사용 안함 -> 2016-04-18 : 함수 복구 및 수정 / Mi->EM 변환시 사용한 함수
AUIDataSheet.prototype.getSelectedRowNum = function(){
	return this.currentRow;
};
AUIDataSheet.prototype.getSelectedColNum = function(){
	return this.currentCol;
};


/*
 * 	2016-02-23 추가(차중훈)
 */

//삭제된 줄을 뺀 줄번호 [ 1부터 시작한다. ]
AUIDataSheet.prototype.getAvailableRowNum = function(rowNum){
    if (rowNum == undefined){
    	alert(getText("message_AUIDataSheet_019", "getAvailableRowNum(줄번호)의 형태로 사용하세요."));
    	return -1;
    }
    
    var cnt = 0;
    var array_IUDN = this.getRemoveItems();
    if (array_IUDN.length == 0) {
    	return rowNum;
    }

    for (var nRowNum = 1; nRowNum < rowNum; nRowNum++){
        var data = AUIGrid.getItemByRowIndex(this.AUIcontrolId, nRowNum -1);
        if(data == undefined || data == null) continue;
        var rowId = data._$uid;
        
    	for(var i=0; i < array_IUDN.length; i++){
    		if(array_IUDN[i]._$uid == rowId) cnt++;
    	}
    }
    
    return rowNum - cnt;

};

// AUISheet에 보이는 줄번호 [ 1부터 시작한다. ]
AUIDataSheet.prototype.getLookingRowNum = function(varRow){
    if (varRow == undefined){
    	alert(getText("message_AUIDataSheet_020", "getAvailableRowNum(줄번호) 또는 getAvailableRowNum(\"줄ID\")의 형태로 사용하세요."));
    	return -1;
    }
    
    var gridData = AUIGrid.getGridData(this.AUIcontrolId);
    
    var rowNum = -1;
    // 문자로 받은 경우 처리
	if (typeof(varRow) == "string" ){
		var uid = varRow;
		for (var nRow=1; nRow <= this.maxRows; nRow++){
			if (uid == gridData[nRow - 1]._$uid) {
				rowNum = nRow; 
				break;
			}
		}
	    return rowNum;
	}
    
	// 숫자로 받은 경우 처리
	rowNum = varRow;
    if (!this.softRemoveRowMode){
    	return rowNum;
    }
    
    var rsltRowNum = 0;
    var cmprRowNum = 0;
    
    var array_IUDN = this.getRemoveItems();
    if (array_IUDN.length == 0) {
    	return rowNum;
    }
    
    for (var nRowNum = 1; nRowNum <= this.maxRows ; nRowNum++){
    	rsltRowNum++;
        var data = gridData[nRow - 1];
        if(data == undefined || data == null) continue;
        var rowId = data._$uid;
        
        var found = false;
    	for(var i=0; i < array_IUDN.length; i++){
    		if(array_IUDN[i]._$uid == rowId) {
    			found = true; break;
    		}
    	}
    	if (!found) cmprRowNum++;
    	if (rowNum == cmprRowNum) break;
    }
    
    return rsltRowNum;
};

AUIDataSheet.prototype.isAvailableRowNum = function(rowNum){
    if (rowNum == undefined){
    	alert(getText("message_AUIDataSheet_021", "'isAvailableRowNum(줄번호)'의 형태로 사용하세요."));
    	return false;
    }
    if (!getControlById(this.controlId).softRemoveRowMode){
    	return true;
    }
     
    var deleted = false;
    var data = AUIGrid.getItemByRowIndex(this.AUIcontrolId, rowNum-1);
    if(data == undefined || data == null) return false;
    var rowId = data._$uid;
    
	var array_IUDN = this.getRemoveItems();
    if (array_IUDN.length == 0) {
    	return true;
    }
	
	for(var i=0; i<array_IUDN.length; i++){
		if(array_IUDN[i]._$uid == rowId) {
			deleted = true; 
			break;
		}
	}
    
    return !deleted;
};

// AUISheet의 줄번호를 리턴(0부터시작 함을 주의 해서 사용)
AUIDataSheet.prototype.getIndexOf_$uid = function(uid){
	var nRowToGet = -1;
	for (var nRow=0; nRow <this.maxRows; nRow++){
		if (uid == AUIGrid.getItemByRowIndex(this.AUIcontrolId, nRow)._$uid) {
			nRowToGet = nRow;
			break;
		}
	}
	return nRowToGet;
};

/*
 * 	2016-03-18 추가(차중훈)
 */
AUIDataSheet.prototype.isAddedRow = function(rowNum){
	var wReturn = false;
	
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		//현재 시트의 행 범위 내 아님, 숫자 아님
		return false;
	}
	
	//행 번호로 행 정보를 가져와 행의 rowId를 찾음
	var _row_uid = (AUIGrid.getItemByRowIndex(this.AUIcontrolId, rowNum - 1))._$uid;
	//행의 rowId로 해당 행이 추가된 행인지 판별
	wReturn = AUIGrid.isAddedById(this.AUIcontrolId, _row_uid);
	
	//리턴 : true(추가된 행) / false(추가되지 않은 행)
	return wReturn;
};

AUIDataSheet.prototype.isEditedRow = function(rowNum){
	var wReturn = false;
	
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		//현재 시트의 행 범위 내 아님, 숫자 아님
		return false;
	}
	
	//행 번호로 행 정보를 가져와 행의 rowId를 찾음
	var _row_uid = (AUIGrid.getItemByRowIndex(this.AUIcontrolId, rowNum - 1))._$uid;
	//행의 rowId로 해당 행이 수정된 행인지 판별
	wReturn = AUIGrid.isEditedById(this.AUIcontrolId, _row_uid);
	
	//리턴 : true(수정된 행) / false(수정되지 않은 행)
	return wReturn;
};

AUIDataSheet.prototype.isDeletedRow = function(rowNum){
	var wReturn = false;
	
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		//현재 시트의 행 범위 내 아님, 숫자 아님
		return false;
	}
    if (!getControlById(this.controlId).softRemoveRowMode){
    	return false;
    }
	
	//행 번호로 행 정보를 가져와 행의 rowId를 찾음
	var _row_uid = (AUIGrid.getItemByRowIndex(this.AUIcontrolId, rowNum - 1))._$uid;
	//행의 rowId로 해당 행이 삭제된 행인지 판별
	wReturn = AUIGrid.isRemovedById(this.AUIcontrolId, _row_uid);
	
	//리턴 : true(삭제된 행) / false(삭제되지 않은 행)
	return wReturn;
};
/*
 * 	2016-03-18 추가(차중훈)
 */

/*
 * 	2016-03-19 추가(차중훈)
 */
AUIDataSheet.prototype.setColumnProperty = function(colNum, propertyObj){
	var wReturn = true;
	
	//현재 시트의 열 범위 내 아님, 숫자 아님
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		return ;
	}
	//
	if( !propertyObj ){
		return ;
	}
	
	try{
//		//열 번호를 컬럼 인덱스로 변환
//		var colIndex = AUIGrid.getColumnIndexByDataField(this.AUIcontrolId, "f" + colNum);
//		if(colIndex < 0) colIndex = colNum - 1;
		var colIndex = colNum - 1;
		AUIGrid.setColumnProp(this.AUIcontrolId, colIndex, propertyObj);
		//시트 컬럼 정보 변경 완료 : true
		wReturn = true;
	}
	catch(e){
		//시트 컬럼 정보 변경 실패 : false
		wReturn = false;
	}
	
	return wReturn;
};
/*
 * 	2016-03-19 추가(차중훈)
 */

/*
 * 	2016-03-30 추가(차중훈)
 */

AUIDataSheet.prototype.shtControlSet = function(rowNum, colNum){
	var wReturn = false;
	var oldRownum = -1;
	var oldColnum = -1;
	
	//현재 시트의 행 범위 내 아님, 숫자 아님
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		return wReturn;
	}
	
	//현재 시트의 열 범위 내 아님, 숫자 아님
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		return wReturn;
	}
	
	//숨김 열 체크
	if( this.isHiddenColumn(colNum) ){
		return wReturn;
	}
	
	oldRownum = this.currentRow;
	oldColnum = this.currentCol;
	
	//컬럼에 잠금 조건이 있는지 체크
	var columnObject = (AUIGrid.getColumnInfoList(this.AUIcontrolId))[colNum - 1];
	var lockFunction = (columnObject != undefined) ? columnObject.lockFunction : null;
	var isFunction = (typeof(lockFunction) == "function") ? true : false;
	
	//잠금 조건을 입력한 경우, 잠금 조건에 의한 잠금여부 리턴
	var wLockReturn = true;
	if(lockFunction && isFunction){
		//셀 이동 후 현재 행, 열 번호 변경
		if(rowNum != oldRownum){
			//행 번호 변동이 있으면 행 번호 변경
			this.setCurrentRow(rowNum);
		}
		if(colNum != oldColnum){
			//열 번호 변동이 있으면 열 번호 변경
			this.setCurrentCol(colNum);
		}
		wReturn = lockFunction(rowNum, colNum);
	}
	
	//잠금 여부는 boolean 형으로 리턴되야 하므로 삼항연산으로 true 또는 false로 변환
	wLockReturn = wLockReturn ? true : false;
	
	if(wLockReturn){
		setTimeout(new Function("", "AUIGrid.setSelectionByIndex(\"" + this.AUIcontrolId + "\", " + (rowNum - 1) + ", " + (colNum - 1) + ");"), 100);
//		setTimeout(new Function("", "AUIGrid.openInputer('" + this.AUIcontrolId + "');"), 100);
		
		var columnInfo = AUIGrid.getColumnInfoList(this.AUIcontrolId)[colNum - 1];
		if(columnInfo.dataType != "combobox"){
			setTimeout(new Function("", "AUIGrid.openInputer('" + this.AUIcontrolId + "');"), 100);
		}
		
//		AUIGrid.setSelectionByIndex(this.AUIcontrolId, rowNum - 1, colNum - 1 );
//		AUIGrid.openInputer(this.AUIcontrolId);	
		wReturn = true;
	}
	
	return wReturn;
};

AUIDataSheet.prototype.restoreSoftRemoveRow = function(rowNum){
	var wReturn = false;
	var rowIndex = "selectedIndex";
	
	//소프트 행 삭제 모드 true 아님
	if( !this.softRemoveRowMode ){
		return wReturn;
	}
	
	//현재 시트의 행 범위 내 아님, 숫자 아님
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		//행번호를 입력하지 않은 경우 현재 선택된 행을 선택
		if(rowNum != undefined){
			return wReturn;
		}
	}

	//행번호를 입력하지 않은 경우 선택된 행을 복구
	if( rowNum == undefined ){
		AUIGrid.restoreSoftRows(this.AUIcontrolId, "selectedIndex");
		wReturn = true;
	}
	//행번호를 입력한 경우 입혁한 행이 삭제된 행인 경우 복구
	else if( this.isDeletedRow(rowNum) ){
		rowNum = rowNum - 1;
		AUIGrid.restoreSoftRows(this.AUIcontrolId, rowNum);
		wReturn = true;
	}
	
	return wReturn;
};

AUIDataSheet.prototype.moveToNextCell = function(/*rowNum, colNum, isShtControlSet*/){
	//초기화 : 현재 행, 열번호로 지정
	var rowNum = this.currentRow;
	var colNum = this.currentCol;
	var isShtControlSet = false;
	
	var args = Array.prototype.slice.call(arguments);
	if(args.length == 1){
		if(typeof args[0] == "boolean") isShtControlSet = args[0];
		if(typeof args[0] == "number") rowNum = args[0] * 1;
		if(typeof args[0] == "string") return false;
	}
	else if(args.length == 2){
		if(typeof args[0] != "number" || typeof args[1] != "number") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if(args.length == 3){
		if(typeof args[0] != "number" || typeof args[1] != "number" || typeof args[2] != "boolean") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
		isShtControlSet = args[2];
	}
	
	//시트에 행이 없다면 동작하지 않음
	if(this.maxRows == 0){
		return false;
	}
	
	//현재 열의 다음 셀을 가리킴(검사 시작 위치 지정)
	colNum = colNum + 1;
	
	//가리킨 셀이 이동 가능한 셀인지 검사
	var isFound = false;
	for(var r = rowNum; r <=  this.maxRows; r++){
		//가리킨 셀이 숨김 열이면 한칸 다음 셀을 검사
		for(var c = colNum; c <= this.maxCols; c++){
			if( (!isShtControlSet && !this.isHiddenColumn(c)) || (isShtControlSet && !this.isHiddenColumn(c) && !this.isLockedColumn(r, c)) ){	
				colNum = c;
				rowNum = r;
				isFound = true;
				break;
			}
		}
		//이동 가능한 셀을 찾지 못한 경우 이전 행 마지막 셀을 가리키고 다시 검사
		if( !isFound ){
			colNum = 1;
		}
		//이동 가능한 셀을 찾은 경우 검사 마침
		else{
			break;
		}
	}
	
	//모든 다음 행에서 이동할 셀을 찾지 못함
	if( !isFound ){
		return false;
	}
	
	return this.moveTo(rowNum, colNum, isShtControlSet);
};

AUIDataSheet.prototype.moveToRightCell = function(/*rowNum, colNum, isShtControlSet*/){
	//초기화 : 현재 행, 열번호로 지정
	var rowNum = this.currentRow;
	var colNum = this.currentCol;
	var isShtControlSet = false;
	
	var args = Array.prototype.slice.call(arguments);
	if(args.length == 1){
		if(typeof args[0] == "boolean") isShtControlSet = args[0];
		if(typeof args[0] == "number") rowNum = args[0] * 1;
		if(typeof args[0] == "string") return false;
	}
	else if(args.length == 2){
		if(typeof args[0] != "number" || typeof args[1] != "number") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if(args.length == 3){
		if(typeof args[0] != "number" || typeof args[1] != "number" || typeof args[2] != "boolean") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
		isShtControlSet = args[2];
	}
	
	//시트에 행이 없다면 동작하지 않음
	if(this.maxRows == 0){
		return false;
	}
	
	//현재 열의 다음 열 중 이동 가능한 셀을 검사
	var isFound = false;
	if(this.maxCols >= colNum + 1){
		//가리킨 셀이 숨김 열이면 한칸 이전 셀을 검사
		for(var c = colNum + 1; c <= this.maxCols; c++){
			if( (!isShtControlSet && !this.isHiddenColumn(c)) || (isShtControlSet && !this.isHiddenColumn(c) && !this.isLockedColumn(rowNum, c)) ){
				colNum = c;
				isFound = true;
				break;
			}
		}	
	}
	
	//마지막 셀인 경우 또는 이동할 셀을 찾지 못한 경우 이동 안 함
	if( !isFound ){
		return false;
	}
	
	return this.moveTo(rowNum, colNum, isShtControlSet);
};

AUIDataSheet.prototype.moveToFormerCell = function(/*rowNum, colNum, isShtControlSet*/){
	//초기화 : 현재 행, 열번호로 지정
	var rowNum = this.currentRow;
	var colNum = this.currentCol;
	var isShtControlSet = false;
	
	var args = Array.prototype.slice.call(arguments);
	if(args.length == 1){
		if(typeof args[0] == "boolean") isShtControlSet = args[0];
		if(typeof args[0] == "number") rowNum = args[0] * 1;
		if(typeof args[0] == "string") return false;
	}
	else if(args.length == 2){
		if(typeof args[0] != "number" || typeof args[1] != "number") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if(args.length == 3){
		if(typeof args[0] != "number" || typeof args[1] != "number" || typeof args[2] != "boolean") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
		isShtControlSet = args[2];
	}

	//시트에 행이 없다면 동작하지 않음
	if(this.maxRows == 0){
		return false;
	}
	
	//현재 열의 이전 셀을 가리킴(검사 시작 위치 지정)
	colNum = colNum - 1;
	
	//가리킨 셀이 이동 가능한 셀인지 검사
	var isFound = false;
	for(var r = rowNum; r > 0; r--){
		//가리킨 셀이 숨김 열이면 한칸 이전 셀을 검사
		for(var c = colNum; c > 0; c--){
			if( (!isShtControlSet && !this.isHiddenColumn(c)) || (isShtControlSet && !this.isHiddenColumn(c) && !this.isLockedColumn(r, c)) ){
				colNum = c;
				rowNum = r;
				isFound = true;
				break;
			}
		}
		//이동 가능한 셀을 찾지 못한 경우 이전 행 마지막 셀을 가리키고 다시 검사
		if( !isFound ){
			colNum = this.maxCols;
		}
		//이동 가능한 셀을 찾은 경우 검사 마침
		else{
			break;
		}
	}
	
	//모든 이전 행에서 이동할 셀을 찾지 못함
	if( !isFound ){
		return false;
	}
	
	return this.moveTo(rowNum, colNum, isShtControlSet);
};

AUIDataSheet.prototype.moveToLeftCell = function(/*rowNum, colNum, isShtControlSet*/){
	//초기화 : 현재 행, 열번호로 지정
	var rowNum = this.currentRow;
	var colNum = this.currentCol;
	var isShtControlSet = false;
	
	var args = Array.prototype.slice.call(arguments);
	if(args.length == 1){
		if(typeof args[0] == "boolean") isShtControlSet = args[0];
		if(typeof args[0] == "number") rowNum = args[0] * 1;
		if(typeof args[0] == "string") return false;
	}
	else if(args.length == 2){
		if(typeof args[0] != "number" || typeof args[1] != "number") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if(args.length == 3){
		if(typeof args[0] != "number" || typeof args[1] != "number" || typeof args[2] != "boolean") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
		isShtControlSet = args[2];
	}
	
	//시트에 행이 없다면 동작하지 않음
	if(this.maxRows == 0){ 
		return false;
	}
	
	//현재 열의 이전 열 중 이동 가능한 셀을 검사
	var isFound = false;
	if(0 < colNum - 1){
		//가리킨 셀이 숨김 열이면 한칸 이전 셀을 검사
		for(var c = colNum - 1; c > 0; c--){
			if( (!isShtControlSet && !this.isHiddenColumn(c)) || (isShtControlSet && !this.isHiddenColumn(c) && !this.isLockedColumn(rowNum, c)) ){
				colNum = c;
				isFound = true;
				break;
			}
		}	
	}
	
	//첫번째 셀인 경우 또는 이동할 셀을 찾지 못한 경우 이동 안 함
	if( !isFound ){
		return false;
	}
	
	return this.moveTo(rowNum, colNum, isShtControlSet);
};

AUIDataSheet.prototype.moveToLowerCell = function(/*rowNum, colNum, isShtControlSet*/){
	//초기화 : 현재 행, 열번호로 지정
	var rowNum = this.currentRow;
	var colNum = this.currentCol;
	var isShtControlSet = false;
	
	var args = Array.prototype.slice.call(arguments);
	if(args.length == 1){
		if(typeof args[0] == "boolean") isShtControlSet = args[0];
		if(typeof args[0] == "number") rowNum = args[0] * 1;
		if(typeof args[0] == "string") return false;
	}
	else if(args.length == 2){
		if(typeof args[0] != "number" || typeof args[1] != "number") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if(args.length == 3){
		if(typeof args[0] != "number" || typeof args[1] != "number" || typeof args[2] != "boolean") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
		isShtControlSet = args[2];
	}
	
	//시트에 행이 없다면 동작하지 않음
	if(this.maxRows == 0){
		return false;
	}
	
	//이동하려는 컬럼이 숨김 열인 경우 이동 안 함
	if( this.isHiddenColumn(colNum) ){	
		return false;
	}
	
	//마지막 행인 경우 해당 열의 마지막 행으로 이동
	rowNum = (this.maxRows < rowNum) ? this.maxRows : rowNum + 1;
	
	//가리킨 셀이 잠김 셀이면 한칸 아래 셀을 검사
	var isFound = false;
	for(var r = rowNum; r <= this.maxRows; r++){
		if( (!isShtControlSet) || (isShtControlSet && !this.isLockedColumn(r, colNum)) ){
			rowNum = r;
			isFound = true;
			break;
		}
	}
	
	//이동할 셀을 찾지 못한 경우 이동 안 함
	if( !isFound ){
		return false;
	}
	
	return this.moveTo(rowNum, colNum, isShtControlSet);
};

AUIDataSheet.prototype.moveToUpperCell = function(/*rowNum, colNum, isShtControlSet*/){
	//초기화 : 현재 행, 열번호로 지정
	var rowNum = this.currentRow;
	var colNum = this.currentCol;
	var isShtControlSet = false;
	
	var args = Array.prototype.slice.call(arguments);
	if(args.length == 1){
		if(typeof args[0] == "boolean") isShtControlSet = args[0];
		if(typeof args[0] == "number") rowNum = args[0] * 1;
		if(typeof args[0] == "string") return false;
	}
	else if(args.length == 2){
		if(typeof args[0] != "number" || typeof args[1] != "number") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if(args.length == 3){
		if(typeof args[0] != "number" || typeof args[1] != "number" || typeof args[2] != "boolean") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
		isShtControlSet = args[2];
	}
	
	//시트에 행이 없다면 동작하지 않음
	if(this.maxRows == 0){
		return false;
	}
	
	//이동하려는 컬럼이 숨김 열인 경우 이동 안 함
	if( this.isHiddenColumn(colNum) ){	
		return false;
	}
	
	//첫번째 행인 경우 해당 열의 첫번째 행으로 지정
	rowNum = (1 > rowNum - 1) ? 1 : rowNum - 1;
	
	//가리킨 셀이 잠김 셀이면 한칸 아래 셀을 검사
	var isFound = false;
	for(var r = rowNum; r > 0; r--){
		if( (!isShtControlSet) || (isShtControlSet && !this.isLockedColumn(r, colNum)) ){
			rowNum = r;
			isFound = true;
			break;
		}
	}
	
	//이동할 셀을 찾지 못한 경우 이동 안 함
	if( !isFound ){
		return false;
	}
	
	return this.moveTo(rowNum, colNum, isShtControlSet);
};

AUIDataSheet.prototype.moveToFirstCell = function(/*rowNum, isShtControlSet*/){
	//초기화 : 현재 행, 열번호로 지정
	var rowNum = this.currentRow;
	var colNum = 1;
	var isShtControlSet = false;

	var args = Array.prototype.slice.call(arguments);
	if(args.length == 1){
		if(typeof args[0] == "boolean") isShtControlSet = args[0];
		if(typeof args[0] == "number") rowNum = args[0] * 1;
		if(typeof args[0] == "string") return false;
	}
	else if(args.length == 2){
		if(typeof args[0] != "number" || typeof args[1] != "boolean") return false;
		rowNum = args[0] * 1;
		isShtControlSet = args[1];
	}
	
	//시트에 행이 없다면 동작하지 않음
	if(this.maxRows == 0){
		return false;
	}
	
	//행 번호가 1보다 작은 경우 첫번째 행으로 지정
	rowNum = (rowNum > 1) ? rowNum : 1;
	
	//행의 이동 가능한 첫번째 셀 검사
	var isFound = false;
	for(var c = 1; c <= this.maxCols; c++){
		if( (!isShtControlSet && !this.isHiddenColumn(c)) || (isShtControlSet && !this.isHiddenColumn(c) && !this.isLockedColumn(rowNum, c)) ){
			colNum = c;
			isFound = true;
			break;
		}
	}
	
	//이동할 셀을 찾지 못한 경우 이동 안 함
	if( !isFound ){
		return false;
	}
	
	return this.moveTo(rowNum, colNum, isShtControlSet);
};

AUIDataSheet.prototype.isHiddenColumn = function(colNum){
	var wReturn = false;
	
	//현재 시트의 열 범위 내 아님, 숫자 아님
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		return wReturn;
	}
	
	//컬럼 정보를 가져옴
	var colInfoList = AUIGrid.getColumnInfoList(this.AUIcontrolId);
	//컬럼의 visible 속성이 false인 경우에만 숨김 열
	if(colInfoList[colNum - 1].visible == false){
		wReturn = true;
	}
	
	//리턴 : true(숨김 열) / false(숨기지 않은 열)
	return wReturn;
};

AUIDataSheet.prototype.isLockedColumn = function(rowNum, colNum){
	var wReturn = true;
	
	//현재 시트의 행 범위 내 아님, 숫자 아님
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		return false;
	}
	
	//현재 시트의 열 범위 내 아님, 숫자 아님
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		return false;
	}
	
	//컬럼에 잠금 조건이 있는지 체크
	var columnObject = (AUIGrid.getColumnInfoList(this.AUIcontrolId))[colNum - 1];
	var lockFunction = (columnObject != undefined) ? columnObject.lockFunction : null;
	var isFunction = (typeof(lockFunction) == "function") ? true : false;
	
	//잠금 조건이 있는 경우, 잠금 조건에 의한 잠금여부 리턴
	if(lockFunction && isFunction){
		wReturn = lockFunction(rowNum, colNum);
	}

	//잠금 여부는 boolean 형으로 리턴되야 하므로 삼항연산으로 true 또는 false로 변환
	wReturn = !(wReturn ? true : false);
	
	return wReturn;
};
/*
 * 	2016-03-30 추가(차중훈)
 */

/*
 * 	2016-04-07 추가(차중훈)
 */

AUIDataSheet.prototype.focus = function(){
	AUIGrid.setFocus(this.AUIcontrolId);
};

//컬럼 위치 검색 결과
var FOUND_COLUMN = true;
var NOT_FOUND_COLUMN = false;
//컬럼 타입 오류 정보
var INCORRECT_PROPERTY_VALUE = " is not incorrect";
var UNDEFINED_PROPERTY_NAME = " is not defined";
var UNDEFINED_DATATYPE = "is not defined data type";
var NO_EXIST_COLNUM = "is not exist column number";

AUIDataSheet.prototype._findColNumByDataField = function(dataField, columnList){
	var resultJson = {found : NOT_FOUND_COLUMN, columnPosition : ""};

	if(typeof dataField == "undefined" || typeof dataField != "string") return resultJson;
	if(!(columnList instanceof Array)) return resultJson;
	if(columnList.length <= 0) return resultJson;
	
	var returnJson = null;
	var children = null;
	var i = 0;
	
	for(i = 0; i < columnList.length; i++){
		if(columnList[i].dataField + "" == dataField + ""){
			resultJson.found = FOUND_COLUMN;
			resultJson.columnPosition = "." + (i + 1);
			return  resultJson;
		}
		
		children = columnList[i].children;
		
		if(children != null && typeof children != "undefined" && children instanceof Array && children.length > 0){
			returnJson = this._findColNumByDataField(dataField, columnList[i].children);
			if(returnJson.found){
				resultJson.found = returnJson.found;
				resultJson.columnPosition = "." + (i + 1) + returnJson.columnPosition;
				return resultJson;
			}
		}
	}
	
	return resultJson;
};


AUIDataSheet.prototype.setColumnProp = function(colNum, propName, propValue, isClear){
	//현재 시트의 열 범위 내 아님, 숫자 아님
	if( typeof colNum == "number" && (isNaN(colNum) || colNum > this.maxCols || colNum < 1) ){
		return false;
	}
	//"1.2.3" 형식 아님
	else if( typeof colNum == "string" && !(/^\d+(\.\d+)+$/g).test(colNum + "") && !(/^\d+$/g).test(colNum + "") ){
		return false;
	}
	
	var pValue = null;
	var datatypes = "date,string,numeric,button,combobox,image,checkbox,bar,string";
	var columnLayout = null;
	var findColumn = null;
	
	//파라메터 체크
	try{
		//속성 체크
		switch(propName){
		case "editable" :
		case "sortable" :
		case "visible" :
			if( typeof(propValue) != "boolean" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		case "headerStyle" :
		case "headerText" :
		case "style" :
		case "perfix" :
		case "postfix" :
		case "formatString" :
		case "mergePolicy" :
			if( typeof(propValue) != "string" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		case "width" :
		case "minWidth" :
			var pVal = (propValue + "").replace(/%/, "");
			if( !(/^\d+\.?\d*$/.test(pVal + "")) ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		case "maxLength" :
		case "decPointCnt" :
		case "limit" :
		case "limitdec" :
		case "mergeRef" :
			if( !(/^\d+$/.test(propValue + "")) ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		case "lockFunction" :
			if( typeof(propValue) != "function" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		case "expFunction" :
			if( typeof(propValue) != "function" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = function(rowIndex, columnIndex, item, dataField){
				var rowNum = rowIndex + 1;
				var colNum = columnIndex + 1;
				return propValue(rowNum, colNum, item);
			};
			break;
		case "styleFunction" : 
		case "labelFunction" :
			if( typeof(propValue) != "function" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = function(rowIndex, columnIndex, value, headerText, item, dataField){
				var rowNum = rowIndex + 1;
				var colNum = columnIndex + 1;
				return propValue(rowNum, colNum, value, item);
			};
			break;
//		case "dataType" :
//			if(datatypes.indexOf(propValue) < 0) throw propValue + UNDEFINED_DATATYPE;
//			break;
		default :
			throw UNDEFINED_PROPERTY_NAME;
		}
		
		//시트를 클리어 설정 여부
		isClear = (typeof isClear != "undefined" && isClear == true) ? true : false;
		
		//컬럼 체크
//		columnLayout = AUIGrid.getColumnLayout(this.AUIcontrolId);
		columnLayout = ( this.pivotBound ) ? this.columnLayout : AUIGrid.getColumnLayout(this.AUIcontrolId);
		findColumn = null;
		
		if( !(/^\d+(\.\d+)+$/g).test(colNum + "") && (propName != "headerText" && propName != "headerStyle")){
			var dataField = AUIGrid.getDataFieldByColumnIndex(this.AUIcontrolId, (colNum * 1) - 1);
			findColumn = this._findColNumByDataField(dataField, columnLayout);
			if(findColumn.found == NOT_FOUND_COLUMN) throw colNum + NO_EXIST_COLNUM;
		}
	}
	catch(e){
		return false;
	}
	
	//시트 컬럼 설정
	try{
		var columnIndexes = (findColumn != null ) ? ((findColumn.columnPosition + "").substring(1)).split(".") : (colNum + "").split(".");
		var column = "";
		var columnObject = null;
		
		column = "columnLayout[" + (columnIndexes[0] - 1) + "]";
		for(var i = 1; i < columnIndexes.length; i++){
			column = column + ".children[" + (columnIndexes[i] - 1) + "]";
		}
		
		//시트 컬럼 가져옴.
		columnObject = eval(column);
		if(columnObject == null) return false;
		//컬럼 속성 설정
		columnObject = _setPorpertyToColumn(columnObject, propName, pValue, this),
		//AUIDataSheet.columnLayout 업데이트
		eval(column + " = columnObject");
		this.columnLayout = columnLayout;

		//headerText 를 변경한 경우 시트를 다시 만들어야함.
		if(	propName != "headerText" && propName != "headerStyle" 
			&& propName != "maxLength" && propName != "limit" ){
			//컬럼 적용
			this.setColumnProperty(colNum, columnObject);
			//시트 refresh
			if(propName != "lockFunction"){
				AUIGrid.update(this.AUIcontrolId);
				AUIGrid.refresh(this.AUIcontrolId);
			}
			//시트 클리어
			if( isClear ) this.clear();
		}
		else{
			var sheetData = null;
			var bindDataset = null;
			var bindColumnCnt = getAssociativeArrayLength(this.dataBinds);
			//시트를 클리어하지 않는다면 시트의 데이터를 백업
			if( !isClear && bindColumnCnt <= 0 ) sheetData = AUIGrid.getGridData(this.AUIcontrolId);
			
			// AUIGrid 지우고 다시 생성
			AUIGrid.destroy(this.AUIcontrolId);
			this.create(this.AUIcontrolId);
			
			//생성한 시트에 데이터 입력
			if( !isClear ){
				if(bindColumnCnt < 0){
					this.setData(sheetData);
				}
				else{
					bindDataset = this.getBindDataset();
					if(bindDataset != null) bindDataset.setInstantUpdateControl(true);
				}											  
			}
		}
	}
	catch(e){
		return false;
	}
	
	return true;
};

function _setPorpertyToColumn(columnObject, pName, pValue, sheet){
	switch(pName){
	case "maxLength" :
	case "limit" :
		if(typeof columnObject.editRenderer == "undefined") { 
			columnObject["editRenderer"] = {};
			columnObject.editRenderer["type"] = "InputEditRenderer";
		}
		var validationNumber = "";
		if(columnObject.dataType == "numeric" && typeof columnObject.editRenderer.validator != "undefined"){
			if(columnObject.editRenderer.validator.toString().indexOf("isIntegerRegx") >= 0){		//isIntegerRegx 가 있다면 정수
				validationNumber += "var isIntegerRegx = /^[-|+]?\\d+$/; "
								 +	"var isValid = isIntegerRegx.test(newValue);"
								 +	"if(isValid == false){ return { \"validate\" : isValid, \"message\"  : getText(\"message_AUIDataSheet_022\", \"{0}은(는) 정수가 아닙니다.\", [newValue]) }; }";

			}
			else if(columnObject.editRenderer.validator.toString().indexOf("isDoubleRegx") >= 0){	//isDoubleRegx 가 있다면 실수
				validationNumber += "var isDoubleRegx = /^[-|+]?\\d+\.?\\d*$/; "
					 			 +	"var isValid = isDoubleRegx.test(newValue);"
					 			 +	"if(isValid == false){ return { \"validate\" : isValid, \"message\"  : getText(\"message_AUIDataSheet_023\", \"{0}은(는) 실수가 아닙니다.\", [newValue]) }; }";
				
			}
		}
		var validationDecPointCnt = "";
		if(typeof columnObject.editRenderer != "undefined" && typeof columnObject.editRenderer.decPointCnt != "undefined"){
			validationDecPointCnt += "if( typeof this.decPointCnt != \"undefined\" && !(/^[+|-]?\\d+[.]?\\d{0," + pValue + "}$/.test((\"\" + newValue))) ){"
								  +  "	return {\"validate\" : false, \"message\" : getText(\"message_AUIDataSheet_024\", \"소수점은 최대 {0}자리까지 입력할 수 있습니다.\", [this.decPointCnt])};"
								  +  "}"
		}
		columnObject.editRenderer.maxLength = pValue * 1;
		columnObject.editRenderer.validator = new Function(
				"oldValue", "newValue", "item", "dataField", "fromClipboard",
				"var isValid = true; var message = \"\";"
				+ (((validationNumber + "").length > 0) ? validationNumber : "")
				+ (((validationDecPointCnt + "").length > 0) ? validationDecPointCnt : "")
				+ "if( typeof this.maxLength != \"undefined\" && (newValue + \"\").length > (this.maxLength * 1) ){"
				+ "	return {\"validate\" : false, \"message\" : getText(\"message_AUIDataSheet_025\", \"최대 {0}자리까지 입력할 수 있습니다.\", [this.maxLength])};"
				+ "}"
				+ "return {\"validate\" : isValid, \"message\" : message}"
		);
		break;
	case "decPointCnt" :
	case "limitdec" :
		if(typeof columnObject.editRenderer == "undefined") { 
			columnObject["editRenderer"] = {};
			columnObject.editRenderer["type"] = "InputEditRenderer";
		}
		var validationNumber = "";
		if(columnObject.dataType == "numeric" && typeof columnObject.editRenderer.validator != "undefined"){
			if(columnObject.editRenderer.validator.toString().indexOf("isIntegerRegx") >= 0){		//isIntegerRegx 가 있다면 정수
				validationNumber += "var isIntegerRegx = /^[-|+]?\\d+$/; "
								 +	"var isValid = isIntegerRegx.test(newValue);"
								 +	"if(isValid == false){ return { \"validate\" : isValid, \"message\"  : getText(\"message_AUIDataSheet_022\", \"{0}은(는) 정수가 아닙니다.\", [newValue]) }; }";

			}
			else if(columnObject.editRenderer.validator.toString().indexOf("isDoubleRegx") >= 0){	//isDoubleRegx 가 있다면 실수
				validationNumber += "var isDoubleRegx = /^[-|+]?\\d+\.?\\d*$/; "
					 			 +	"var isValid = isDoubleRegx.test(newValue);"
					 			 +	"if(isValid == false){ return { \"validate\" : isValid, \"message\"  : getText(\"message_AUIDataSheet_023\", \"{0}은(는) 실수가 아닙니다.\", [newValue]) }; }";
			}
		}
		var validationMaxLength = "";
		if(typeof columnObject.editRenderer != "undefined" && typeof columnObject.editRenderer.maxLength != "undefined"){
			validationMaxLength += 	"if( typeof this.maxLength != \"undefined\" && (\"\" + newValue).length > (this.maxLength * 1) ){"
								+ 	"	return {\"validate\" : false, \"message\" : getText(\"message_AUIDataSheet_025\", \"최대 {0}자리까지 입력할 수 있습니다.\", [this.maxLength])};"
								+ 	"}"
		}
		columnObject.editRenderer.decPointCnt = pValue * 1;
		columnObject.editRenderer.validator = new Function(
				"oldValue", "newValue", "item", "dataField", "fromClipboard",
				"var isValid = true; var message = \"\";"
				+ (((validationNumber + "").length > 0) ? validationNumber : "")
				+ (((validationMaxLength + "").length > 0) ? validationMaxLength : "")
				+ "if( typeof this.decPointCnt != \"undefined\" && !(/^[+|-]?\\d+[.]?\\d{0," + pValue + "}$/.test((\"\" + newValue))) ){"
				+ "	return {\"validate\" : false, \"message\" : getText(\"message_AUIDataSheet_024\", \"소수점은 최대 {0}자리까지 입력할 수 있습니다.\", [this.decPointCnt])};"
				+ "}"
				+ "return {\"validate\" : isValid, \"message\" : message}"
		);
		break;
	case "mergeRef" :
		var colNum = (pValue * 1) - 1;
		var dataField = AUIGrid.getDataFieldByColumnIndex(sheet.AUIcontrolId, colNum);
		columnObject[pName] = dataField;
		break;
	default :
		columnObject[pName] = pValue;
	}
	
	return columnObject;
};

AUIDataSheet.prototype.SetColProp = function(colNum, propName, propValue, isClear){
	return this.setColumnProp(colNum, propName, propValue, isClear);
};

AUIDataSheet.prototype.getColumnProp = function(colNum, propName){
	//현재 시트의 열 범위 내 아님, 숫자 아님
	if( typeof colNum == "number" && (isNaN(colNum) || colNum > this.maxCols || colNum < 1) ){
		return false;
	}
	//"1.2.3" 형식 아님
	else if( typeof colNum == "string" && !(/^\d+(\.\d+)+$/g).test(colNum + "") && !(/^\d+$/g).test(colNum + "") ){
		return false;
	}
	
	var rPropValue = null;
	var columnLayout = null;
	var findColumn = null;
	
	//파라메터 체크
	try{
		//속성 체크
		switch(propName){
		case "editable" :
		case "sortable" :
		case "visible" :
		case "headerText" :
		case "style" :
		case "perfix" :
		case "postfix" :
		case "formatString" :
		case "width" :
		case "minWidth" :
//		case "lockFunction" :
//		case "expFunction" :
//		case "styleFunction" : 
//		case "labelFunction" :
		case "dataType" :
			break;
		default :
			throw UNDEFINED_PROPERTY_NAME;
		}
		
		//컬럼 체크
		columnLayout = AUIGrid.getColumnLayout(this.AUIcontrolId);
		findColumn = null;
		
		if( !(/^\d+(\.\d+)+$/g).test(colNum + "") && propName != "headerText"){
			var dataField = AUIGrid.getDataFieldByColumnIndex(this.AUIcontrolId, (colNum * 1) - 1);
			findColumn = this._findColNumByDataField(dataField, columnLayout);
			if(findColumn.found == NOT_FOUND_COLUMN) throw colNum + NO_EXIST_COLNUM;
		}
	}
	catch(e){
		return ;
	}
	
	//시트 컬럼 설정
	try{
		var columnIndexes = (findColumn != null ) ? ((findColumn.columnPosition + "").substring(1)).split(".") : (colNum + "").split(".");
		var column = "";
		var columnObject = null;
		
		column = "columnLayout[" + (columnIndexes[0] - 1) + "]";
		for(var i = 1; i < columnIndexes.length; i++){
			column = column + ".children[" + (columnIndexes[i] - 1) + "]";
		}
		
		//시트 컬럼 가져옴.
		columnObject = eval(column);
		if(columnObject == null) return ;
		//속성 값 가져옴
		rPropValue = columnObject[propName]
	}
	catch(e){
		return ;
	}
	
	return rPropValue;
};

/*
 * 	2016-04-07 추가(차중훈)
 */

/*
 * 	2016-04-19 추가(차중훈)
 */

AUIDataSheet.prototype.setZIndex = function(zIndex){
	// functionname : [Control.setZIndex]
	var wReturn = false;
	var oldZIndex = this.zIndex;
	
	try{
		this.zIndex = zIndex;
		this.tagObject.style.zIndex = zIndex;
		wReturn = true;
	}
	catch(err){
		this.zIndex = oldZIndex;
	}
	
	return wReturn;
};

AUIDataSheet.prototype.setZOrder = function(zOrder){
	// functionname : [Control.setZOrder]
	return this.setZIndex(zOrder);
};

/*
 * 	2016-04-19 추가(차중훈)
 */

/*
 * 	2016-04-26 추가(차중훈)
 */

AUIDataSheet.prototype.setProperty = function(propName, propValue, isClear){
	var pValue = null;
	
	//파라메터 체크
	try{
		//속성 체크
		switch(propName){
		case "editable" :
		case "editableOnFixedCell" :
		case "enableColumnResize" :
		case "enableMovingColumn" :
		case "enableCellMerge" :
		case "enableSorting" :
		case "showHeader" :
		case "useGroupingPanel" :
		case "showAutoNoDataMessage" :
			if( typeof(propValue) != "boolean" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		case "noDataMessage" :
			if( typeof(propValue) != "string" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		case "rowPosition" :
			if( !(/^\d+\.?\d*$/.test(propValue + "")) ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		case "rowStyleFunction" :
			if( typeof(propValue) != "function" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			var pValue = function(rowIndex, item){
				var rowNum = rowIndex + 1;
				return propValue(rowNum,item);
			};
			break;
		default :
			throw UNDEFINED_PROPERTY_NAME;
		}
		
		//시트를 클리어 설정 여부
		isClear = (typeof isClear != "undefined" && isClear == true) ? true : false;
	}
	catch(e){
		return false;
	}
	
	//시트 설정
	try{
		//시트 객체 설정 적용
		switch(propName){
		case "editable" :
			this.editable = propValue;
			break;
		case "editableOnFixedCell" :
			this.editableOnFixedCell = propValue;
			break;
		case "enableColumnResize" :
			this.enableColumnResize = propValue;
			break;
		case "enableMovingColumn" :
			this.enableMovingColumn = propValue;
			break;
		case "enableCellMerge" :
			AUIGrid.setCellMerge(this.AUIcontrolId, propValue);
			break;
		case "enableSorting" :
			this.enableSorting = propValue;
			break;
		case "showHeader" :
			this.showHeader = propValue;
			break;
		case "useGroupingPanel" :
			this.useGroupingPanel = propValue;
			break;;
		case "showAutoNoDataMessage" :
			this.showAutoNoDataMessage = propValue;
			break;
		case "noDataMessage" :
			this.noDataMessage = propValue;
			break;
		case "rowPosition" :
			//this.rowPosition = propValue;
			//break;
			//동작 변경됨 : setProperty 함수로 행 지정하는 동작이 AUIGrid 가 업데이트 되면서 사라짐
			var rowNum = ((pValue * 1) - 1 > 0) ? (pValue * 1) - 1 : 0;
			var colNum = (this.currentCol - 1 > 0) ? this.currentCol - 1 : 0;
			AUIGrid.setSelectionByIndex(this.AUIcontrolId, rowNum, colNum);		//지정한 행을 시트에서 선택
			AUIGrid.setRowPosition(this.AUIcontrolId, rowNum);					//지정한 행을 시트의 최상단으로 이동
			if( isClear ) this.clear();											//시트 클리어
			return false;
		}
		//시트 설정 적용
		var prop = {};
		prop[propName] = pValue;
		AUIGrid.setProperty(this.AUIcontrolId, prop);
		AUIGrid.refresh(this.AUIcontrolId);
		//시트 클리어
		if( isClear ) this.clear();
	}
	catch(e){
		return false;
	}
	
	return true;
};

/*
 * 	2016-04-26 추가(차중훈)
 */
AUIDataSheet.prototype.setFixedColumnCount = function (cnt) {
//	if(cnt > 8) {
//		alert("현재 고정 칼럼의 최대 개수는 8로 설정되어있습니다.\r\n8이하로 다시 시도해 주십시오.");
//		return;
//	}
	
	// 고정 칼럼을 변경합니다.
	AUIGrid.setFixedColumnCount(this.AUIcontrolId, cnt);
};

function EXORow(){
	this.objectSeq = 1;
    this.hardRowCount = 1; 
    this.hardRowNum = 0;
    this.hardRowNum2 = 0;
    this.cells = [null];  // 데이터가 1번 배열부터 들어간다는 의미
    this.oldNum = 0;      // Sort시 사용된다
    this.hidden = false;  // 줄숨기기시 사용된다
    this.newData = false; // 줄추가된 데이터
    
};

// 2016-05-22 : 컬럼 Default Layout
var defaultLayout = {};
/* 버튼 */
defaultLayout["button"] = {
	headerText : "",
	dataField : "",
	width : "100px",
	style : "AUIGrid_Align_left",
	editable : false,
	dataType : "button",
	renderer : {
		type : "ButtonRenderer",
		labelText : ""
	}
};
/* 체크박스 */
defaultLayout["checkbox"] = {
	headerText : "",
	dataField : "",
	width : "100px",
	style : "AUIGrid_Align_left",
	dataType : "checkbox",
	renderer : {  	
		type : "CheckBoxEditRenderer",
		editable : true,
		checkValue : "1",
		unCheckValue : "0"
	}
};
/* 콤보박스 */
defaultLayout["combobox"] = {
	headerText : "",
	dataField : "",
	width : "100px",
	style : "AUIGrid_Align_left",
	dataType : "combobox",
	labelFunction : function(rowIndex, columnIndex, value, headerText, item) {
		var retStr = value;
		return retStr;
	},
	editRenderer : {	
		type : "DropDownListRenderer",
		keyField : "value",
		valueField : "text",
		list : [{"value" : "", text : ""}]
	}
};
/* 날짜 */
defaultLayout["date"] = {
	headerText : "",
	dataField : "",
	width : "100px",
	style : "AUIGrid_Align_left",
	dataType : "date",
	editRenderer : {
		type : "CalendarRenderer",
		onlyMonthMode : false,
		showExtraDays : true,
		showTodayBtn : true,
		showUncheckDateBtn : true,
		uncheckDateValue : "",
		titles : [
		          getText("message_AUIDataSheet_026", "일"), 
		          getText("message_AUIDataSheet_027", "월"), 
		          getText("message_AUIDataSheet_028", "화"), 
		          getText("message_AUIDataSheet_029", "수"), 
		          getText("message_AUIDataSheet_030", "목"), 
		          getText("message_AUIDataSheet_031", "금"), 
		          getText("message_AUIDataSheet_032", "토")]
	}
};
/* 텍스트 */
defaultLayout["text"] = {
	headerText : "",
	dataField : "",
	width : "100px",
	style : "AUIGrid_Align_left",
	dataType : "string"
};
/* 실수 */
defaultLayout["number"] = {
	headerText : "",
	dataField : "",
	width : "100px",
	style : "AUIGrid_Align_left",
	formatString : "#,##0.00",
	dataType : "numeric",
	editRenderer : {
		type : "InputEditRenderer",
		validator : function(oldValue, newValue, item, dataField, fromClipboard){
			var isDoubleRegx = /^[-|+]?\d+\.?\d*$/;
			var isValid = isDoubleRegx.test(newValue);
			return { "validate" : isValid, "message"  : getText("message_AUIDataSheet_023", "{0}은(는) 실수가 아닙니다.", [newValue]) };
		}
	}
};
/* 정수 */
defaultLayout["integer"] = {
	headerText : "",
	dataField : "",
	width : "100px",
	style : "AUIGrid_Align_left",
	dataType : "numeric",
	editRenderer : {
		type : "InputEditRenderer",
		validator : function(oldValue, newValue, item, dataField, fromClipboard){
			var isIntegerRegx = /^[-|+]?\d+$/;
			var isValid = isIntegerRegx.test(newValue);
			return { "validate" : isValid, "message"  : getText("message_AUIDataSheet_022", "{0}은(는) 정수가 아닙니다.", [newValue]) };
		}
	}
};
/* 사진 */
defaultLayout["image"] = {
	headerText : "",
	dataField : "",
	width : "100px",
	style : "AUIGrid_Align_left",
	dataType : "image",
	renderer : {
		type : "ImageRenderer",
		imgHeight : 30 - 8,
	}
};
/* 아이콘 */
defaultLayout["icon"] = {
headerText : "",
	dataField : "",
	width : "100px",
	style : "AUIGrid_Align_left",
	dataType : "string",
	renderer : {
		type : "IconRenderer",
		iconWidth : 16,
		iconHeight : 16,
		iconPosition : "aisleRight",
	}
};
/* 게이지 바 */
defaultLayout["bar"] = {
	headerText : "",
	dataField : "",
	width : "100px",
	style : "AUIGrid_Align_left",
	dataType : "bar",
	renderer : {
		type : "BarRenderer",
		min : 0,
		max : 100,
		offset : 1
	}
};

//2016-05-22 : 각 타입별 Default Column Layout 생성
AUIDataSheet.prototype.createDefaultLayout = function(columnType, headerText){
	var layout = null;
	
	//Default Layout Copy
	switch(columnType){
	case "button" :		layout = JSON.parse(JSON.stringify( defaultLayout["button"] ));		break;
	case "checkbox" :	layout = JSON.parse(JSON.stringify( defaultLayout["checkbox"] ));	break;
	case "combobox" :	layout = JSON.parse(JSON.stringify( defaultLayout["combobox"] ));	break;
	case "date" :		layout = JSON.parse(JSON.stringify( defaultLayout["date"] ));		break;
	case "text" :		layout = JSON.parse(JSON.stringify( defaultLayout["text"] ));		break;
	case "number" :		layout = JSON.parse(JSON.stringify( defaultLayout["number"] ));		break;
	case "integer" :	layout = JSON.parse(JSON.stringify( defaultLayout["integer"] ));	break;
	case "image" :		layout = JSON.parse(JSON.stringify( defaultLayout["image"] ));		break;
	case "icon" :		layout = JSON.parse(JSON.stringify( defaultLayout["icon"] ));		break;
	case "bar" :		layout = JSON.parse(JSON.stringify( defaultLayout["bar"] ));		break;
	default :			layout = null;
	}
	
	//컬럼 타입에 해당하는 레이아웃이 없는 경우 null 리턴
	if(layout == null){
		return null;
	}
	
	//컬럼 헤더 타이틀 적용
	layout["headerText"] = headerText;
	
	return layout;
};

//2016-05-22 : Column Layout 클리어
AUIDataSheet.prototype.clearColumnLayout = function(){
	this.columnLayout.clear();
    delete this.columnLayout;
    
    this.columnLayout = [];
    this.maxCols = this.columnLayout.length;
    this.defaultLayoutValue_JSON = {};
    for(var i = 0; i < this.maxCols; i++){
    	this.defaultLayoutValue_JSON[columnList[i].dataField] = "";
    }
    this.defaultLayoutValue = eval( "(" + JSON.stringify(this.defaultLayoutValue_JSON) + ")" );
    
    return true;
};

//2016-05-22 : Column Layout 추가
AUIDataSheet.prototype.addColumn = function(){
	var columnLayout = null;
	var index = -1;
	/*
	 *	파라메터 정리
	 *	1. 파라메터 1개인 경우 : 컬럼 레이아웃
	 *	2. 파라메터 2개인 경우 : 컬럼 순서 / 컬럼 레이아웃
	 *	(※ 컬럼 순서는 1부터 시작)
	 */
	var args = Array.prototype.slice.call(arguments);
    if (args.length == 1){
    	columnLayout = args[0];
    }
    else {
    	index = args[0];	columnLayout = args[1];
    }
    //
    if(typeof columnLayout == "undefined" || columnLayout == null){
    	return false;
    }
    /*
     * 	1. index를 파라메터로 받은 경우(index != -1) : 해당 인덱스 위치에 추가/dataFeild 정리
     *  2. index를 파라메터로 받지 않은 경우(index == -1) : 맨 뒤에 추가
     */
    index = (index < 1) ? ((index == 0) ? 1 : this.columnLayout.length) : (this.columnLayout.length > index) ? index - 1 : this.columnLayout.length;
    var i = 0; k = 0;
    var columnList = [];
    for(i = 0; i < index; i++){
    	columnList.push(this.columnLayout[i]);
    }
    columnLayout["dataField"] = "f" + (index + 1);
    columnList.push(columnLayout);
    for(i = index, k = index + 1; i < this.columnLayout.length; i++, k++){
    	columnList.push(this.columnLayout[i]);
    	columnList[k].dataField = "f" + (k + 1);
    }
    //시트 기존 columnLayout 클리어
    this.columnLayout.clear();
    delete this.columnLayout;
    //추가된 레이아웃 정보에 따른 시트 정보 업데이트
    this.columnLayout = columnList;
    this.maxCols = columnList.length;
    this.defaultLayoutValue_JSON = {};
    for(var i = 0; i < this.maxCols; i++){
    	this.defaultLayoutValue_JSON[columnList[i].dataField] = "";
    }
    this.defaultLayoutValue = eval( "(" + JSON.stringify(this.defaultLayoutValue_JSON) + ")" );
    
    return true;
};



//2016-06-20 : 시트에 바인드된 데이터셋 가져오는 함수 추가
AUIDataSheet.prototype.getBindDataset = function(){
	var key = "";
	var bindinfo = null;
	
	for(key in this.dataBinds){
		bindinfo = this.dataBinds[key];
		//함수인 경우 예외처리
		if(typeof bindinfo == "function") continue;
		//데이터셋을 찾은 경우 데이터셋 리턴
		if(dataSets[bindinfo.datasetId] instanceof DataSet) return dataSets[bindinfo.datasetId];
	}
	
	//데이터셋을 찾지 못한 경우 null 리턴
	return null;
};



//2016-07-05 : 시트 선택모드 변경하는 함수 추가
AUIDataSheet.prototype.setSelectionMode = function(selectionMode){
	//예외처리
	//파라메터 데이터타입이 올바르지 않음
	if(typeof selectionMode != "string"){
		return false;
	}
	//파라메터 설정값이 올바르지 않음
	else if( selectionMode != "none" 
		&& selectionMode != "singleCell"	&& selectionMode != "singleRow"
		&& selectionMode != "multipleCells"	&& selectionMode != "multipleRows" )
	{
		return fasle;
	}

	//시트 선택모드 속성 변경
	this.selectionMode = selectionMode;
	//시트 선택모드 변경
	AUIGrid.setSelectionMode(this.AUIcontrolId, selectionMode);
	
	return true;
};



AUIDataSheet.prototype.clearData = function(){
	
	AUIGrid.setGridData(this.AUIcontrolId, []);
	
	return true;
}



AUIDataSheet.prototype.forceEditingComplete = function(doCancel){
	//예외처리
	//파라메터 데이터타입이 올바르지 않음
	if(typeof doCancel != "boolean"){
		return false;
	}
	
	try{
		AUIGrid.forceEditingComplete(this.AUIcontrolId, null, doCancel);
	}
	catch(e){
		return false;
	}
	
	return true;
};



function checkVaildDate(pCheck, pDate){
	//데이터 길이 체크
	if((pDate + "").length == 0)					
		return true;
	if((pCheck + "").length != (pDate + "").length)
		return false;
	
	var isValid = true;
	var year = "0000";	var month = "01";	var day = "01";
	var hour = "00";	var min = "00";		var sec = "00";
	var lastDay = 0;
	var date = "";
	
	pDate = pDate + "";
	
	//년도 체크
	if(pCheck.indexOf("yyyy") >= 0){
		year = pDate.substring(0, 4);
	}
	//년월 체크
	if(pCheck.indexOf("mm") >= 0){
		month = pDate.substring(4, 6);
	}
	//일 체크
	if(pCheck.indexOf("dd") >= 0){
		day = (pDate.substring(6, 8));
		if(month * 1 == 1 || month * 1 == 3 || month * 1 == 5 || month * 1 == 7 || month * 1 == 8 || month * 1 == 10 || month * 1 == 12)	lastDay = 31;
		else if(month * 1 == 4 || month * 1 == 6 || month * 1 == 9 || month * 1 == 11)														lastDay = 30;
		else if(month * 1 == 2){
			//윤달 체크
			if(year * 1 % 4 == 0 && year * 1 % 100 != 0 || year * 1 % 400 == 0)	lastDay = 29;
			else																lastDay = 28;
		}
		if( !(day * 1 > 0 || day * 1 <= lastDay) ) isValid = false;
	}
	if(pCheck.indexOf("HH") >= 0){
		hour = (pDate.substring(8, 10));
	}
	if(pCheck.indexOf("MM") >= 0){
		min = (pDate.substring(10, 12));
	}
	if(pCheck.indexOf("ss") >= 0){
		sec = (pDate.substring(12, 14));
	}
	
	//일 체크 후 isValid가 false인 경우
	if( !isValid )	return isValid;
	//날짜 체크(년도+월+일+시+분+초 하여 체크함)
	date = year + month + day + hour + min + sec;
	if( !(/^(19[7-9][0-9]|[0-9]{4})(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])([0-1][0-9]|2[0-3])([0-5][0-9])([0-5][0-9])$/).test(date) ) isValid = false;
	
	return isValid;
};



function checkVaildDateA(pCheck, pDate){
	var dateType = "";

	//데이터 형식 체크
	switch(pCheck){
		case "yyyy" :			dateType = "년도"; break;
		case "yyyymm" :			dateType = "년월"; break;
		case "yyyymmdd" :		dateType = "년월일"; break;
		case "yyyymmddHH" :		dateType = "년월일시분초"; break;
		case "yyyymmddHHMM" :	dateType = "년월일시분"; break;
		case "yyyymmddHHMMss" :	dateType = "년월일시"; break;
		case "HH" :				dateType = "시간"; break;
		case "HHMM" :			dateType = "시분"; break;
		case "HHMMss" :			dateType = "시분초"; break;
		default : 				dateType = "";
	}
	
	//데이터 길이 체크
	if((pDate + "").length == 0)					
		return {"validate" : true, "message" : ""};
	if((pCheck + "").length != (pDate + "").length){
		//return 
		return {"validate" : false, "message" :  getText("message_AUIDataSheet_033", "'{0}' 형식은 {1}자리를 입력해야 합니다.", [dateType, pCheck.length])};
	}
	
	var isValid = true;
	var message = "";
	var idxFmt = -1;
	var year = "1979";	var month = "01";	var day = "01";
	var hour = "00";	var min = "00";		var sec = "00";
	var lastDay = 0;
	var date = "";
	
	pDate = pDate + "";
	
	//년도 체크
	idxFmt = pCheck.indexOf("yyyy");
	if(idxFmt >= 0){
		year = pDate.substring(idxFmt, idxFmt + 4);
	}
	//년월 체크
	idxFmt = pCheck.indexOf("mm");
	if(idxFmt >= 0){
		month = pDate.substring(idxFmt, idxFmt + 2);
	}
	//일 체크
	idxFmt = pCheck.indexOf("dd");
	if(idxFmt >= 0){
		day = pDate.substring(idxFmt, idxFmt + 2);
		if(month * 1 == 1 || month * 1 == 3 || month * 1 == 5 || month * 1 == 7 || month * 1 == 8 || month * 1 == 10 || month * 1 == 12)	lastDay = 31;
		else if(month * 1 == 4 || month * 1 == 6 || month * 1 == 9 || month * 1 == 11)														lastDay = 30;
		else if(month * 1 == 2){
			//윤달 체크
			if(year * 1 % 4 == 0 && year * 1 % 100 != 0 || year * 1 % 400 == 0)	lastDay = 29;
			else																lastDay = 28;
		}
		if( !(day * 1 > 0 && day * 1 <= lastDay) ) isValid = false;
	}
	//시 체크
	idxFmt = pCheck.indexOf("HH");
	if(idxFmt >= 0){
		hour = pDate.substring(idxFmt, idxFmt + 2);
	}
	//분 체크
	idxFmt = pCheck.indexOf("HH");
	if(idxFmt >= 0){
		min = pDate.substring(idxFmt, idxFmt + 2);
	}
	//초 체크
	idxFmt = pCheck.indexOf("ss");
	if(idxFmt >= 0){
		sec = pDate.substring(idxFmt, idxFmt + 2);
	}
	
	//일 체크 후 isValid가 false인 경우
	if( !isValid )	return {"validate" : isValid, "message" : pDate + " 은(는) 올바른 '" + dateType + "' 형식의 데이터가 아닙니다."};
	//날짜 체크(년도+월+일+시+분+초 하여 체크함)
	date = year + month + day + hour + min + sec;
	if( !(/^(19[7-9][0-9]|[0-9]{4})(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])([0-1][0-9]|2[0-3])([0-5][0-9])([0-5][0-9])$/).test(date) ){
		isValid = false;
		message = getText("message_AUIDataSheet_034", "{0} 은(는) 올바른 '{1}' 형식의 데이터가 아닙니다.", [pDate, dateType]);
	}
	
	return {"validate" : isValid, "message" : message};
}

var AUI_MONTH = [
	{i: "Jan", f: "January"}, {i: "Feb", f: "February"}, {i: "Mar", f: "March"}, {i: "Apr", f: "April"}, {i: "May", f: "May"}, {i: "Jun", f: "June"},
	{i: "Jul", f: "July"}, {i: "Aug", f: "August"}, {i: "Sept", f: "September"}, {i: "Oct", f: "October"}, {i: "Nov", f: "November"}, {i: "Dec", f: "December"}
];

var AUI_WEEK = [
	{k: "월", e: "Mon"}, {k: "화", e: "Tue"}, {k: "수", e: "Wed"}, {k: "목", e: "Thu"}, {k: "금", e: "Fri"}, {k: "토", e: "Sat"}, {k: "일", e: "Sun"}
];

function maskDateFormat(pFormat, pValue){
	if( (pValue + "").length == 0 ){
		return "";
	}
	
	var year = "0000";	var month = "01";	var day = "01";
	var hour = "00";	var min = "00";		var sec = "00";
	var rDate = pFormat;
	
	year  = pValue.substring(0, 4) + "";
	month = pValue.substring(4, 6) + "";
	day   = pValue.substring(6, 8) + "";
	hour  = pValue.substring(8, 10) + "";
	min   = pValue.substring(10, 12) + "";
	sec   = pValue.substring(12, 14) + "";
	
	if(pFormat.indexOf("yyyy") >= 0)	rDate = rDate.replace(/yyyy/g, year);
	if(pFormat.indexOf("yy") >= 0)		rDate = rDate.replace(/yy/g, (year.substring(2, 4)));
	if(pFormat.indexOf("mmmm") >= 0)	rDate = rDate.replace(/mmmm/g, (AUI_MONTH[(month * 1) - 1].f));
	if(pFormat.indexOf("mmm") >= 0)		rDate = rDate.replace(/mmm/g, (AUI_MONTH[(month * 1) - 1].i));
	if(pFormat.indexOf("mm") >= 0)		rDate = rDate.replace(/mm/g, month);
	if(pFormat.indexOf("m") >= 0)		rDate = rDate.replace(/m/g, (month * 1));
	if(pFormat.indexOf("dddd") >= 0)	rDate = rDate.replace(/dddd/g, (AUI_WEEK[(day * 1) - 1].f));
	if(pFormat.indexOf("ddd") >= 0)		rDate = rDate.replace(/ddd/g, (AUI_WEEK[(day * 1) - 1].i));
	if(pFormat.indexOf("dd") >= 0)		rDate = rDate.replace(/dd/g, day);
	if(pFormat.indexOf("d") >= 0)		rDate = rDate.replace(/d/g, (day * 1));
	if(pFormat.indexOf("HH") >= 0)		rDate = rDate.replace(/HH/g, hour);
	if(pFormat.indexOf("H") >= 0)		rDate = rDate.replace(/H/g, (hour * 1));
	if(pFormat.indexOf("hh") >= 0){
		var h = hour * 1 > 12 ? (hour * 1) - 12 : (hour * 1 == 0 ? 12 : (hour * 1));
		rDate = rDate.replace(/hh/g,  (h < 10 ? "0" + h : "" + h));
	}
	if(pFormat.indexOf("h") >= 0)		rDate = rDate.replace(/h/g,  (hour * 1 > 12 ? (hour * 1) - 12 : (hour * 1 == 0 ? 12 : (hour * 1))));
	if(pFormat.indexOf("MM") >= 0)		rDate = rDate.replace(/MM/g, min);
	if(pFormat.indexOf("M") >= 0)		rDate = rDate.replace(/M/g, (min * 1));
	if(pFormat.indexOf("ss") >= 0)		rDate = rDate.replace(/ss/g, sec);
	if(pFormat.indexOf("s") >= 0)		rDate = rDate.replace(/s/g, (sec * 1));
	if(pFormat.indexOf("TT") >= 0)		rDate = rDate.replace(/TT/g, (hour * 1 > 12 ? "PM" : "AM"));
	if(pFormat.indexOf("tt") >= 0)		rDate = rDate.replace(/tt/g, (hour * 1 > 12 ? "pm" : "am"));
	if(pFormat.indexOf("T") >= 0)		rDate = rDate.replace(/T/g, (hour * 1 > 12 ? "p" : "a"));
	if(pFormat.indexOf("t") >= 0)		rDate = rDate.replace(/t/g, (hour * 1 > 12 ? "오후" : "오전"));
	
	return rDate;
};

function maskTimeFormat(pFormat, pValue){
	if( (pValue + "").length == 0 ){
		return "";
	}
	
	return maskDateFormat(pFormat, "00000000" + pValue);
};/*******************************************************************************
* 데이터시트 콘트롤의 정의 부분이다 인수로는 콘트롤 명과 , 테그객체를 갖는다 용어의 정의: LogicalRow: ColSpan과
* 여러줄처리를 감안한 논리적 줄번호 (1 ~) SheetRow : HeadColumn을 포함하지 않는 순수 데이터셀의 줄번호(1 ~)
* HardRow : HeadColumn을 포함하는 테이블 테그내 줄번호(0 ~)
* 
* Sheet : 자식 테이블들을 포함하는 콘트롤 단위의 개념(DIV) Table : 시트내 각각의 자식 테이블 단위의 개념(TABLE)
******************************************************************************/
/*
* 시트동작에 필요한 상수
*/
// Sort 에 필요한 상수
// 시트타입 구분에 사용하는 변수
var SHEETTYPE_DataSheet = 1;
var SHEETTYPE_LISTSHEET = 2;

// 시트채우기 모드
var SHEETMODE_SETCELL = 1;
var SHEETMODE_SETDATA = 2;

function AUIDataSheetM(controlId, controlName, tagObject) // constructor
{
	// 변수 선언부
    this.controlName = controlName || "";   
    this.controlId   = controlId || "";
    this.AUIcontrolId = "AUI_" + controlId;
    this.id   = this.controlId; //콘트롤 아이디와 같다.
    this.tagObject = tagObject || null;
    this.sheetType = SHEETTYPE_DataSheet;
    this.linkedObjects = []; //연결된 콘트롤
    
    //style 정보
    if (this.tagObject){
	    this.enabled = !(this.tagObject.disabled ? this.tagObject.disabled : (this.tagObject.getAttribute("disabled") ? this.tagObject.getAttribute("disabled") : true));
	    this.visible = (getStyle(this.tagObject).display ? getStyle(this.tagObject).display != "none" : (getStyle(this.tagObject).left ? getStyle(this.tagObject).left != "-10000px" : true));
	    this.zIndex = (getStyle(this.tagObject).zIndex ? getStyle(this.tagObject).zIndex : 0);
    }
    
    // DataSet 정보
    this.rows = [null];  // Logical 데이터가 1번 배열부터 들어간다는 의미
    this.dataValues = []; // 내부
    this.defaultData = []; // 디폴트 데이터(json)
    this.notSetValue = false; // true 일때 setValue 함수 동작하지 않음
    this.fillKeyField = false; // 시트에 연결된 객체가 화면채우기키 설정이 되어있다면 시트에서 setValue, cellChange, clear 를 하지 않는다.
    this.fillJobName = null; // lazy loding 사용시에 해당 fillJob 이름
    this.pageNum = 2; // lazy loding 사용시에 해당 recordset의 pageNum 저장한다.
    this.defaultLayoutValue = "({})"; // 줄추가할때마다 들어갈 디폴트 값
    this.defaultColumnSize = [];
    
    this.inClearMode = false;
    
    // 초기동작
    this.inputMode = SHEETMODE_SETCELL; // SHEETMODE_SETCELL : GUI 만 수정, SHEETMODE_SETDATA : GUI 는 수정 안되고 데이터 만 채운다.
    
    // 시트의 외양에 관한 변수들
    this.headRows = 1;       // Physical
    this.headCols = 1;       // Physical
    this.maxCols = 0;        // Logical 데이터의 최대칼럼수
    this.maxRows = 0;        // Logical 데이터의 최대줄수
    this.currentRow = 1;     // Logical Row [1~]
    this.currentCol = 0;     // Logical Row [1~]
    
    this._clicked_row_id = "";  //클릭된 행 ID
    
    this.rowsPerDataRow = 1; // 데이터 한줄당 물리적으로 몇줄이 소요되는지....
    this.colsPerDataRow = 1; // 데이터 한줄당 물리적으로 몇줄이 소요되는지....
    this.multilineHelper = null;
    this.columns = [null];
    
    /** AUIgrid 에서 필요한 속성값들 **/
    this.editable = true; // 수정가능여부
    this.editableOnFixedCell = true; // 고정 칼럼, 행 지정된 셀 수정 가능여부
    this.editBeginMode = "doubleClick"; // 마우스로 편집, 수정 모드로 들어가는 정책, 더블클릭과 클릭 중 택 doubleClick, click
    this.editingOnKeyDown = true; // 엑셀과 같이 바로 해당 셀에서 어떤 키(any keys)를 누르든 수정 가능 상태로 만들지 여부
    this.enableColumnResize = true; // 칼럼 리사이징 가능 여부
    this.enableMovingColumn = false; // 칼럼 순서 바꾸기 가능 여부
    this.enableSorting = true; // 정렬 가능 여부
    this.exportURL = getContextPath() + "/third-party/AUISoft/export.jsp"; // 엑셀(xlsx), CSV, TXT 등으로 내보내기(Export) 할 때 내보내기 된 내용물을 다운로드 형식으로 응답해 줄 서버단 URL 주소
    this.hScrollPosition = 0; // 수평 스크롤의 위치(픽셀)
    this.isColumnOriented = false; // 키보드의 Home, End 키가 기본적으로 행의 시작과 끝으로 이동합니다. 칼럼의 시작과 끝으로 이동시키고자 한다면 이 속성을 true 로 설정
    this.keepEditing = false; // true 로 설정한 경우, 다음 셀이 바로 수정 가능한 상태로 입력 창이 열리게 됩니다.
    this.minColumnWidth = 12; // 칼럼의 최소 사이즈를 지정
    this.multiSortingKey = "shiftKey"; // 다중 칼럼 정렬을 실행 할 때 클리과 더블어 함께 할 키(key)를 지정 ("shiftKey", "ctrlKey", "always")
    this.rowIdField = null; // 고유 값을 갖는 Key 필드(Primary Key) 이 필드를 지정하면 그리드가 빨리 생성됩니다. 10만 로우 이상에선 반드시 설정하십시오.
    this.rowPosition = 0; // 현재 화면에 보이는 그리드의 최상단 행의 인덱스
    this.treeOpenRecursivly = false; // 트리 열기 할 때 자손까지 열지 여부
    this.triggerSelectionChangeOnCell = true; // 행 이동시에도 selectionChange 이벤트 발생
    this.useGroupingPanel = false; // 그리드 상단에 그룹핑 가능한 패널 사용 여부
    this.filterMenuItemMaxCount = 20; // 필터링 아이콘 클릭시 나오는 필터링 메뉴에서 필터링 가능한 체크박스의 최대값
    this.filterItemMoreMessage = getText("message_AUIDataSheetM_001", "필터링 메뉴보다 실제 값들이 더 많습니다."); // 칼럼의 필터링 아이콘 클릭 시 나오는 필터링 메뉴에서 실제 값들이 더 많다는 메세지를 출력할 수 있습니다.
    this.showAutoNoDataMessage = true; // 데이터가 존재 하지 않을 때 자동으로 메세지를 출력할지 여부
    this.noDataMessage = getText("message_AUIDataSheetM_002", "데이터가 없습니다."); // 출력할 데이터 없을 경우 출력 될 메세지
    
    this.autoEditBeginMode = true; // 모바일 기기는 싱글 탭(1번 클릭) 으로 수정 진입 모드를 설정
    this.softRemovePolicy = "exceptNew"; // Insert 키나 addRow 메소드로 행을 추가한 줄은 바로 삭제
    this.autoScrollSize = false; // 스크롤을 모바일 사이즈로 바꿈
    this.copyDisplayValue = false; // 복사(Ctrl+C) 할 때 원래 데이터 값을 복사할 지 그리드에 의해 포매팅된 값을 복사할 지 여부
    this.displayTreeOpen = false; // 계층형 그리드(트리 그리드) 에서 최초로 보여지는 그리드의 브랜치 아이템이 모두 열린 상태로 출력될지 닫힌 상태로 출력될지를 결정
    this.enableCellMerge = false; // 칼럼 셀 병합(cell merge) 가능 여부
    this.enableClipboard = true; // 그리드 데이터 복사하기(Ctrl+C), 붙여넣기(Ctrl+V) 활성화 여부
    this.enableFilter = true; // 칼럼 필드 필터링 기능 활성화 여부를 지정
    this.filterCancelText = getText("message_AUIDataSheetM_003", "취 소"); // 필터 메뉴에 표현 할 "취 소" 텍스트를 대체할 다른 텍스트를 지정
    this.filterCheckAllText = getText("message_AUIDataSheetM_004", "(전체선택)"); // 필터 메뉴에 표현 할 "전체선택" 텍스트를 대체할 다른 텍스트를 지정
    this.filterClearText = getText("message_AUIDataSheetM_005", "필터 초기화"); // 필터 메뉴에 표현 할 "필터 초기화" 텍스트를 대체할 다른 텍스트를 지정
    this.filterNumberOperatorList = [getText("message_AUIDataSheetM_006", "같다(=)"), getText("message_AUIDataSheetM_007", "크다(>)"), getText("message_AUIDataSheetM_008", "크거나 같다(>=)"), getText("message_AUIDataSheetM_009", "작다(<)"), getText("message_AUIDataSheetM_010", "작거나 같다(<=)"), getText("message_AUIDataSheetM_011", "같지 않다(!=)")]; // 필터 유형이 numeric 인 경우 필터링 체크박스에 표시할 비교 연산자명을 지정
    this.filterOkText = getText("message_AUIDataSheetM_012", "확 인"); // 필터 메뉴에 표현 할 "확 인" 텍스트를 대체할 다른 텍스트를 지정
    this.filterSearchCheckAllText = getText("message_AUIDataSheetM_013", "(검색 전체선택)"); // 필터 메뉴에 표현 할 "검색 전체선택" 텍스트를 대체할 다른 텍스트를 지정
    this.fixedColumnCount = 0; // 고정 칼럼의 개수를 지정
    this.fixedColumnHGap = 0; // 행 줄번호 또는 fixedColumnCount 설정 시 좌측으로 구분되는 그리드와 메인 그리드 사이의 여백
    this.fixedRowCount = 0; // 고정 행(row)의 개수를 지정
    
    // 그리드에 입력되는 데이터가 계층구조의 데이터는 아니지만, 트리 그리드로 출력하고자 할 때 행이 id, parent 필드를 갖어야 합니다.
    this.treeIdField = null; // 이 때 id에 해당되는 데이터의 필드명을 treeIdField 값으로 지정
    this.treeIdRefField = null; // 이 때 내 부모행에 해당되는 참고필드를 treeIdRefField 값으로 지정
    this.flat2tree = false; // 그리드에 입력되는 데이터가 계층구조의 데이터는 아니지만, id, parent 구조를 갖는 일반 데이터인 경우 트리 그리드로 출력할지 여부를 나타냅니다.
    						// flat2tree 속성은 반드시 treeIdField, treeIdRefField 가 선행적으로 설정되어야 합니다.
    
    this.footerHeight = 30; // 푸터의 높이를 지정
    this.footerVGap = 4; // 푸터와 메인 그리드 사이의 간격, 공백을 지정
    this.groupingFields = null; // 그룹핑을 할 칼럼의 데이터 필드를 지정합니다 ex) ["country", "product"]
    this.groupingMessage = getText("message_AUIDataSheetM_014", "컬럼을 드래그하여 여기에 올려 놓으세요."); // 그리드 상단에 그룹핑 가능한 패널에 표시되는 메세지를 지정
    this.groupingPanelHeight = 40; // 그리드 상단에 그룹핑 가능한 패널의 높이를 지정
    this.showBranchOnGrouping = false; // 그룹핑 시 브랜치에 해당되는 행 출력 여부를 지정합니다. 이 속성은 그룹핑과 셀병합를 함께 적용할 때만 유효합니다. 이 속성을 false 로 지정하면 그룹핑 시 브랜치 행이 표시되지 않습니다.
    
    this.headerHeight = 30; // 헤더의 높이를 지정
    this.onlyEnterKeyEditEnd = false; // 이 속성을 true 설정하면 셀을 수정하고 완료를 하기 위해 엔터(Enter) 키를 입력할 때 수정 완료 행위만 하고 다음 행으로 선택자를 내리지 않습니다
    this.pageRowCount = 20; // 페이징을 사용하는 경우 한 페이지에 출력되는 행의 수를 지정합니다.;
    // 페이징을 사용하는 경우 페이징 오른쪽에 출력되는 현재페이지와 전체페이지 출력 텍스트를 사용자 정의할 수 있는 라벨펑션을 지정합니다.
    // 함수의 반환값이 곧 출력값이 됩니다.
    this.pagingInfoLabelFunction = function AUIPagingFunction(currentPage, totalPageCount, currentTopNumber, currentBottomNumber, dataLen){return currentPage + " / " + totalPageCount;};
    this.pagingMode = "default"; // "simple" 로 설정한 경우 이전, 다음 버턴과 현재페이지/전체페이지 만 출력됩니다.
    this.pagingPanelHeight = 34; // 페이징을 사용하는 경우 페이징이 출력되는 하단의 페이징 영역이 높이를 지정
    this.processValidData = false; // 그리드 데이터를 유효한 데이터로 재작성 할지 여부
    
    this.resetHScroll = true; // 데이터 변경 시 수평 스크롤의 위치를 초기화 할지 여부를 나타냅니다. 이 속성을 false 로 설정하면 데이터 변경 시 수평 스크롤의 위치가 변하지 않습니다.
    this.resetVScroll = true; // 데이터 변경 시 수직 스크롤의 위치를 초기화 할지 여부를 나타냅니다. 이 속성을 false 로 설정하면 데이터 변경 시 수직 스크롤의 위치가 변하지 않습니다.
    this.reverseRowNum = false; // 행번호 칼럼에서 행 번호를 반대로 출력할지 여부
    this.rowCheckColumnWidth = 25; // 행 체크박스 칼럼의 가로 사이즈(width)를 지정
    this.rowCheckToRadio = false;// 체크박스 대신 라디오버턴 그룹으로 변환시켜 출력할지 여부를 지정합니다.
    this.rowHeight = 26; //  행의 높이를 지정합니다. 행의 높이는 20보다 작아질 수 없습니다
    this.rowPosition = 0; // 현재 화면에 보이는 그리드의 최상단 행의 인덱스
    this.rowStyleFunction = function rowStyleFunction(rowIndex, item){}; // 행(row) 단위로 동적 스타일을 적용할 수 있는 스타일 함수를 지정(return 클래스명)
    														  // rowIndex : 행 인덱스, item : 해당 인덱스의 행 아이템
    this.scrollHeight = 14; // 스크롤의 높이(수직 스크롤인 경우 넓이)를 지정
    this.scrollHeight4Mobile = 4; // 터치가 지원되는 모바일 화면에서의 스크롤 높이(수직 스크롤인 경우 넓이)를 지정
    this.scrollThumbHeight = 12; // 스크롤 썸(thumb)의 높이(수직 스크롤인 경우 넓이)를 지정
    this.selectionMode = "multipleCells"; // 셀 선택모드를 지정 ( singleCell, singleRow, multipleCells, multipleRows, none )
    this.showEditedCellMarker = true; // 수정 가능한 상태(editable = true) 인 경우 셀을 수정하면 해당 셀에 수정된 표시(마크)를 출력할 지 여부
    this.showFooter = false; // 푸터 출력 여부를 지정
    this.showHeader = true; // 헤더 출력 여부
    
    this.showPageButtonCount = 10; // 페이징을 사용하는 경우 출력되는 페이지의 버턴 개수를 지정
    this.showRowCheckColumn = false; // 이 속성 값이 true 이면 최좌측에 체크박스 칼럼이 생성됩니다
    this.showRowNumColumn = true; // 행 줄번호(로우 넘버링) 칼럼의 출력 여부
    this.showSelectionBorder = false; // 셀 선택 시 선택된 셀에 테두리(border) 를 표시할지 여부
    this.showStateColumn = true; // 그리드 좌측에 행의 상태를 나타내는 칼럼 출력 여부를 결정
    this.stateColumnWidth = 16; // 행 상태 칼럼(showStateColumn = true)을 설정한 경우 해당 칼럼의 가로 사이즈를 지정
    this.showTooltip = false; // 그리드 툴팁 표시 여부를 지정
    this.softRemoveRowMode = true; // 행을 삭제하면 그리드에서 바로 제거하지 않고, 삭제된 표시를 하고 남겨 둘 지 여부를 나타냅니다.
    this.summaryText = getText("message_AUIDataSheetM_015", "합계"); // groupingSummary 속성을 설정하였을 때 합계 필드에 출력되는 텍스트를 지정
    this.treeColumnIndex = 0; // 계층형 그리드(트리 그리드) 에서 트리 아이콘을 출력시킬 칼럼 인덱스를 지정
    this.treeIconFunction; // 트리 그리드에서 트리를 출력하는 칼럼에 표시되는 아이콘을 동적으로 변경 할 수 있는 함수
    this.treeLevelIndent = 18; // 계층형 그리드(트리 그리드) 에서 자식 행과 부모 행의 왼쪽 간격(indent)를 지정
    this.treeOpenRecursivly = false; // 계층형 그리드(트리 그리드) 에서 열기/닫기 실행 시 재귀적으로(recursivly) 열/닫을 실행할지 결정합니다.
    
    this.useContextMenu = true; // 컨텍스트 메뉴 사용 여부 ( enableFilter = true 설정도 함께 해주십시오 )
    this.useFooterExpData = false; // 푸터를 사용할 때(showFooter = true) 푸터 연산에 사용되는 데이터가 칼럼의 expFunction 에 의해 생성된 데이터를 사용할지 여부를 나타냅니다.
    this.usePaging = false; // 페이징을 사용 여부를 지정
    this.useSummaryExpData = false; // 그룹핑 합계필드(groupingSummary)를 사용할 때 합계 필드에 사용되는 데이터가 칼럼의 expFunction 에 의해 생성된 데이터를 사용할지 여부
    this.wheelSensitivity = 1; // 수직 스크롤의 반응도를 결정합니다.
    						   // 예를 들어 이 속성의 값을 2로 주면 마우스 휠로 반응하는 행의 개수가 2로 증가합니다.
    this.wordWrap = false; // 이 속성값이 true 인 경우 자동 word-wrap 이 발생합니다.
    this.zeroBazeAtRowNum = false; // 행 줄번호(로우 넘버링)의 시작을 0에서 시작할 지, 1에서 시작할지 여부를 지정합니다. true 인 경우 0에서부터 시작합니다.
    
    this.groupingSummary = null; //그룹핑 시 합계 행(groupingSummary)을 생성하고자 할 때 이 속성을 설정하십시오. 합계 필드는 칼럼의 dataType 이 "numeric" 인 경우에만 유효합니다.
    
    this.auiGridProps = null;
    this.footerObject = [];
    this.columnLayout = [];    
    /** AUIgrid 에서 필요한 속성값들 끝 **/
    
    this.hasDelRowEvent = false; this.fncDelRowEvent = null;
    this.hasDelRowDataEvent = false; this.fncDelRowDataEvent = null;
    this.hasAddRowEvent = false; this.fncAddRowEvent = null;
    this.hasAddRowDataEvent = false; this.fncAddRowDataEvent = null;
    this.hasRowChangeEvent = false; this.fncRowChangeEvent = null;
    this.hasColChangeEvent = false; this.fncColChangeEvent = null;
    this.hasChangeEvent = false; this.fncChangeEvent = null;
    this.hasChangeComboTextEvent = false; this.fncChangeComboTextEvent = null;
    this.hasClearEvent = false; this.fncClearEvent = null;
    this.hasClickEvent = false; this.fncClickEvent = null;
    this.hasHeadClickEvent = false; this.fncHeadClickEvent = null;
    this.hasValidateEvent = false; this.fncValidateEvent = null;
    this.hasCommandClickEvent = false; this.fncCommandClickEvent = null;
    this.hasScrollEvent = false; this.fncScrollEvent = null;
    this.hasDblClickEvent = false; this.fncDblClickEvent = null;
    this.hasSortedEvent = false; this.fncSortedEvent = null;
    this.hasSheetChangeEvent = true;
    this.hasEditBeginEvent = false;	this.fncEditBeginEvent = null;

	this.dataBinds = [];     	// 데이터 링크된 콘트롤들 
	this.bindDataset = "";
	this.pivotBound = false;
	
	this.passEvent = false;		//사용자 이벤트 동작 여부(true:동작안함 / false:동작함)
	
    // clear memory
    tagObject = null;
    
    this.GV_DATASHEETM_DEFAULT_SELECTION_MODE = "singleRow";
    this.GV_DATASHEETM_DEFAULT_SELECTION_FLAG = 0;
};

AUIDataSheetM.prototype.create = function(){
	
	if(this.GV_DATASHEETM_DEFAULT_SELECTION_MODE == "singleRow" && this.GV_DATASHEETM_DEFAULT_SELECTION_FLAG == 0){
		this.selectionMode = this.GV_DATASHEETM_DEFAULT_SELECTION_MODE;
		this.GV_DATASHEETM_DEFAULT_SELECTION_FLAG = 1;
	}
	
	this.auiGridProps = {
			editable : this.editable,
		    editableOnFixedCell : this.editableOnFixedCell,
		    editBeginMode : this.editBeginMode,
		    editingOnKeyDown : this.editingOnKeyDown,
		    enableColumnResize : this.enableColumnResize,
		    enableMovingColumn : this.enableMovingColumn,
		    enableSorting : this.enableSorting,
		    exportURL : this.exportURL,
		    hScrollPosition : this.hScrollPosition,
		    isColumnOriented : this.isColumnOriented,
		    keepEditing : this.keepEditing,
		    minColumnWidth : this.minColumnWidth,
		    multiSortingKey : this.multiSortingKey,
		    rowIdField : this.rowIdField,
		    rowPosition : this.rowPosition,
		    showHeader : this.showHeader,
		    treeOpenRecursivly : this.treeOpenRecursivly,
		    triggerSelectionChangeOnCell : this.triggerSelectionChangeOnCell,
		    useGroupingPanel : this.useGroupingPanel,
		    filterMenuItemMaxCount : this.filterMenuItemMaxCount,
		    filterItemMoreMessage : this.filterItemMoreMessage,
		    showAutoNoDataMessage : this.showAutoNoDataMessage,
		    noDataMessage : this.noDataMessage,
		    autoEditBeginMode : this.autoEditBeginMode,
		    softRemovePolicy : this.softRemovePolicy,
		    autoScrollSize : this.autoScrollSize,
		    copyDisplayValue : this.copyDisplayValue,
		    displayTreeOpen : this.displayTreeOpen,
		    enableCellMerge : this.enableCellMerge,
		    enableClipboard : this.enableClipboard,
		    enableFilter : this.enableFilter,
		    filterCancelText : this.filterCancelText,
		    filterCheckAllText : this.filterCheckAllText,
		    filterClearText : this.filterClearText,
		    filterNumberOperatorList : this.filterNumberOperatorList,
		    filterOkText : this.filterOkText,
		    filterSearchCheckAllText : this.filterSearchCheckAllText,
		    fixedColumnCount : this.fixedColumnCount,
		    fixedColumnHGap : this.fixedColumnHGap,
		    fixedRowCount : this.fixedRowCount,
		    treeIdField : this.treeIdField,
		    treeIdRefField : this.treeIdRefField,
		    flat2tree : this.flat2tree,
		    footerHeight : this.footerHeight,
		    footerVGap : this.footerVGap,
		    groupingFields : this.groupingFields,
		    groupingMessage : this.groupingMessage,
		    groupingPanelHeight : this.groupingPanelHeight,
		    showBranchOnGrouping : this.showBranchOnGrouping,
		    headerHeight : this.headerHeight,
		    onlyEnterKeyEditEnd : this.onlyEnterKeyEditEnd,
		    pageRowCount : this.pageRowCount,
		    pagingInfoLabelFunction : this.pagingInfoLabelFunction,
		    pagingMode : this.pagingMode,
		    pagingPanelHeight : this.pagingPanelHeight,
		    processValidData : this.processValidData,
		    resetHScroll : this.resetHScroll,
		    resetVScroll : this.resetVScroll,
		    reverseRowNum : this.reverseRowNum,
		    rowCheckColumnWidth : this.rowCheckColumnWidth,
		    rowCheckToRadio : this.rowCheckToRadio,
		    rowHeight : this.rowHeight,
		    rowPosition : this.rowPosition,
		    rowStyleFunction : this.rowStyleFunction,
		    scrollHeight : this.scrollHeight,
		    scrollHeight4Mobile : this.scrollHeight4Mobile,
		    scrollThumbHeight : this.scrollThumbHeight,
//		    showEditedCellMarker : this.showEditedCellMarker,
		    showEditedCellMarker : false,
		    showFooter : this.showFooter,
		    showHeader : this.showHeader,
		    showPageButtonCount : this.showPageButtonCount,
		    showRowCheckColumn : this.showRowCheckColumn,
		    showRowNumColumn : this.showRowNumColumn,
		    showSelectionBorder : this.showSelectionBorder,
//		    showStateColumn : this.showStateColumn,
//		    stateColumnWidth : this.stateColumnWidth,
		    showStateColumn : false,
		    showTooltip : this.showTooltip,
		    softRemoveRowMode : this.softRemoveRowMode,
		    summaryText : this.summaryText,
		    treeColumnIndex : this.treeColumnIndex,
		    treeIconFunction : this.treeIconFunction,
		    treeLevelIndent : this.treeLevelIndent,
		    treeOpenRecursivly : this.treeOpenRecursivly,
		    useContextMenu : this.useContextMenu,
		    useFooterExpData : this.useFooterExpData,
		    usePaging : this.usePaging,
		    useSummaryExpData : this.useSummaryExpData,
		    wheelSensitivity : this.wheelSensitivity,
		    wordWrap : this.wordWrap,
		    zeroBazeAtRowNum : this.zeroBazeAtRowNum,
		    selectionMode : this.selectionMode,		    
		    groupingSummary : this.groupingSummary
	};

	// 실제로 #grid_wrap 에 그리드 생성
	AUIGrid.create(this.AUIcontrolId, this.columnLayout, this.auiGridProps);
	
	// 푸터 객체 세팅
	AUIGrid.setFooter(this.AUIcontrolId, this.footerObject);
	
	// 연결된 객체중 하나라도 dniMode가 false라면 'U' 업데이트 구분을 주기위해 objectmanager의 dataloaded 속성을 true로 바꿔준다.
	var arrData = this.linkedObjects;
	var dataLen = arrData.length;
	for (var i = 0; i < dataLen; i++) {
		if(arrData[i].dniMode == false){
			objectManager.dataloaded = true;
//			break;
		}
		if(arrData[i].fillKeyFieldName.length > 0){
			this.fillKeyField = true;
		}
	}
	
	// 이벤트 선언
	this.createEvent();
	
	// 빈데이터 세팅 (데이터 세팅을 한번도 하지않고 줄이 없는상태에서 줄추가를 하면 에러가 난다)
	// defaultData가 있다면 세팅해준다.
	//this.setData(this.defaultData);
	AUIGrid.setGridData(this.AUIcontrolId, this.defaultData);
	
	// defaultData가 없다면 첫줄을 생성한다
//	if(this.defaultData.length == 0) this.addRow(0);
	
	return;
};

// 셋 데이터  AUI 시트를 기준으로한 데이터 이다.즉 두줄데이터는 두줄이다.
AUIDataSheetM.prototype.setData = function(data, updateDataset) {
	if(data.length > 0){
		AUIGrid.setGridData(this.AUIcontrolId, data);
		if (this.multilineHelper != null){
			this.maxRows = AUIGrid.getGridData(this.AUIcontrolId).length / this.rowsPerDataRow;
	        this.multilineHelper.resetRowNum();
		} else {
			this.maxRows = AUIGrid.getGridData(this.AUIcontrolId).length;
		}

		//무한루핑 방지
		if(updateDataset == undefined || updateDataset){
			//Dataset을 사용하지 않은 경우
			if(typeof(AUIDataSheetM.prototype._UpdateDatasetList) != "undefined"){
				if (this.multilineHelper != null){
					this._UpdateDatasetList(this.multilineHelper.getDatasetData());			
				} else {
					this._UpdateDatasetList();			
				}
			}
		}
	}	
	return;
};

// 데이터를 아래쪽에 추가로 붙인다
// appendData는 onready 이벤트를 타지 않는다. 강제로 onReady() 함수 호출
AUIDataSheetM.prototype.setAppendData = function(data, updateDataset) {
	if(data.length > 0){
		AUIGrid.appendData(this.AUIcontrolId, data);
		
		if (this.multilineHelper != null){
			this.maxRows = AUIGrid.getGridData(this.AUIcontrolId).length / this.rowsPerDataRow;
	        this.multilineHelper.resetRowNum();
		} else {
			this.maxRows = AUIGrid.getGridData(this.AUIcontrolId).length;
		}

		//Dataset을 사용하지 않은 경우
		if(updateDataset == undefined || updateDataset){
			if(typeof(AUIDataSheetM.prototype._UpdateDatasetList) != "undefined"){
				if (this.multilineHelper != null){
					this._UpdateDatasetList(this.multilineHelper.getDatasetData());			
				} else {
					this._UpdateDatasetList();			
				}
			}
		}
		this.onReady();
	}
	
	return;
};

AUIDataSheetM.prototype.createEvent = function() {
	
	var myGridID =  this.AUIcontrolId;
	var aSheet = getControlById(this.controlId);
	
	AUIGrid.bind(myGridID, "ready", function(event) {auiSheetM_Ready(event, aSheet);});
	
	AUIGrid.bind(myGridID, "selectionChange", function( event ) {auiSheetM_selectionChange(event, aSheet);});
	
	AUIGrid.bind(myGridID, "cellDoubleClick", function( event ) {auiSheetM_cellDoubleClick(event, aSheet);});
	
	AUIGrid.bind(myGridID, "cellClick", function( event ) {auiSheetM_cellClick(event, aSheet);});
	
	AUIGrid.bind(myGridID, "headerClick", function( event ) {auiSheetM_headerClick(event, aSheet);});
	
	AUIGrid.bind(myGridID, "cellEditEnd", function( event ) {auiSheetM_setValue(event, aSheet);});
	
	AUIGrid.bind(myGridID, "addRow", function( event ) {auiSheetM_addRow(event, aSheet);});
	
	AUIGrid.bind(myGridID, "beforeRemoveRow", function( event ) {auiSheetM_removeRow(event, aSheet);});
	
	AUIGrid.bind(myGridID, "sorting", function( event ) {auiSheetM_sorting(event, aSheet);});
	
	AUIGrid.bind(myGridID, "vScrollChange", function( event ) {auiSheetM_vScroll(event, aSheet);});
	
	AUIGrid.bind(myGridID, "keyDown", function(event) {auiSheetM_keyDown(event, aSheet);});
	
	AUIGrid.bind(myGridID, "cellEditBegin", function(event) {return auiSheetM_editBegin(event, aSheet);});
	
	AUIGrid.bind(myGridID, "cellEditEndBefore", function(event) {return auiSheetM_setValueBefore(event, aSheet);});
	
	if (this.AUIcontrolId.length > 0) {
		try {
			if (eval(this.controlId + "_ondelrow")) this.hasDelRowEvent = true;
		} catch(e){}
		if (this.hasDelRowEvent){
			eval("this.fncDelRowEvent = function(atRowNum){ return " + this.controlId + "_ondelrow(atRowNum);}");
		}
		
    	try {
        	if (eval(this.controlId + "_ondelrowdata")) this.hasDelRowDataEvent = true;
        } catch(e){}
        if (this.hasDelRowDataEvent){
    	    eval("this.fncDelRowDataEvent = function(atRowNum){ return " + this.controlId + "_ondelrowdata(atRowNum);}");
        }

        try {
        	if (eval(this.controlId + "_onaddrow")) this.hasAddRowEvent = true;
        } catch(e){}
        if (this.hasAddRowEvent){
        	eval("this.fncAddRowEvent = function(atRowNum){ return " + this.controlId + "_onaddrow(atRowNum);}");
        }
        
    	try {
        	if (eval(this.controlId + "_onaddrowdata")) this.hasAddRowDataEvent = true;
        } catch(e){}
        if (this.hasAddRowDataEvent){
    	    eval("this.fncAddRowDataEvent = function(atRowNum){ return " + this.controlId + "_onaddrowdata(atRowNum);}");
        }

    	try {
        	if (eval(this.controlId + "_onrowchange")) this.hasRowChangeEvent = true;
        } catch(e){}
        if (this.hasRowChangeEvent){
    	    eval("this.fncRowChangeEvent = function(rowNumFrom, rowNumTo, objectSeq){ return " + this.controlId + "_onrowchange(rowNumFrom, rowNumTo, objectSeq);}");
        }

    	try {
        	if (eval(this.controlId + "_oncolchange")) this.hasColChangeEvent = true;
        } catch(e){}
        if (this.hasColChangeEvent){
    	    eval("this.fncColChangeEvent = function(colNumFrom, colNumTo){ return " + this.controlId + "_oncolchange(colNumFrom, colNumTo);}");
        }
        
        
    	try {
        	if (eval(this.controlId + "_onchange")) this.hasChangeEvent = true;
        } catch(e){}
        if (this.hasChangeEvent){
    	    eval("this.fncChangeEvent = function(rowNum, colNum, value, oldValue, keyCode){ return " + this.controlId + "_onchange(rowNum, colNum, value, oldValue, keyCode);}");
        }

    	try {
        	if (eval(this.controlId + "_onchangeCombotext")) this.hasChangeComboTextEvent = true;
        } catch(e){}
        if (this.hasChangeComboTextEvent){
    	    eval("this.fncChangeComboTextEvent = function(rowNum, colNum, value, oldValue){ return " + this.controlId + "_onchangeCombotext(rowNum, colNum, value, oldValue);}");
        }

    	try {
        	if (eval(this.controlId + "_onclear")) this.hasClearEvent = true;
        } catch(e){}
        if (this.hasClearEvent){
    	    eval("this.fncClearEvent = function(){ return " + this.controlId + "_onclear();}");
        }
        
    	try {
        	if (eval(this.controlId + "_onclick")) this.hasClickEvent = true;
        } catch(e){}
        if (this.hasClickEvent){
    	    eval("this.fncClickEvent = function(rowNum, colNum){ return " + this.controlId + "_onclick(rowNum, colNum);}");
        }
        
    	try {
        	if (eval(this.controlId + "_onheadclick")) this.hasHeadClickEvent = true;
        } catch(e){}
        if (this.hasHeadClickEvent){
    	    eval("this.fncHeadClickEvent = function(rowNum, colNum, headerText){ return " + this.controlId + "_onheadclick(rowNum, colNum, headerText);}");
        }

    	try {
        	if (eval(this.controlId + "_onvalidate")) this.hasValidateEvent = true;
        } catch(e){}
        if (this.hasValidateEvent){
    	    eval("this.fncValidateEvent = function(colNum, value){ return " + this.controlId + "_onvalidate(colNum, value);}");
        }

    	try {
        	if (eval(this.controlId + "_oncommandclick")) this.hasCommandClickEvent = true;
        } catch(e){}
        if (this.hasCommandClickEvent){
    	    eval("this.fncCommandClickEvent = function(rowNum, colNum){ return " + this.controlId + "_oncommandclick(rowNum, colNum);}");
        }
    	try {
        	if (eval(this.controlId + "_onimageclick")) this.hasImageClickEvent = true;
        } catch(e){}
        if (this.hasImageClickEvent){
    	    eval("this.fncImageClickEvent = function(rowNum, colNum){ return " + this.controlId + "_onimageclick(rowNum, colNum);}");
        }
    	try {
        	if (eval(this.controlId + "_onscroll")) this.hasScrollEvent = true;
        } catch(e){}
        if (this.hasScrollEvent){
    	    eval("this.fncScrollEvent = function(scrollPanel, scrollTop, scrollLeft,  lastScrollTop, lastScrollLeft){ return " + this.controlId + "_onscroll(scrollPanel, scrollTop, scrollLeft, lastScrollTop, lastScrollLeft);}");
        }
    	try {
        	if (eval(this.controlId + "_ondblclick")) this.hasDblClickEvent = true;
        } catch(e){}
        if (this.hasDblClickEvent){
    	    eval("this.fncDblClickEvent = function(rowNum, colNum){ return " + this.controlId + "_ondblclick(rowNum, colNum);}");
        }

    	try {
        	if (eval(this.controlId + "_onsorted")) this.hasSortedEvent = true;
        } catch(e){}
        if (this.hasSortedEvent){
    	    eval("this.fncSortedEvent = function(){ return " + this.controlId + "_onsorted();}");
        }
        
        try {
        	if (eval(this.controlId + "_oncellEditBefore")) this.hasEditBeginEvent = true;
        } catch(e){}
        if (this.hasEditBeginEvent){
    	    eval("this.fncEditBeginEvent = function(rowNum, colNum){ return " + this.controlId + "_oncellEditBefore(rowNum, colNum);}");
        }
        
        //  KeyDown(rowNum, colNum, KeyCode, Shift)
        makeEventHandler(this, "KeyDown", "rowNum", "colNum", "keyCode", "shiftPressed", "controlPressed", "altPressed");    
        
        //  KeyPress(rowNum, colNum, KeyAscii)
        makeEventHandler(this, "KeyPress", "rowNum", "colNum", "KeyCode");  
        
        //  KeyUp(rowNum, colNum, KeyCode, Shift)
         makeEventHandler(this, "KeyUp", "rowNum", "colNum", "KeyCode", "shiftPressed", "controlPressed", "altPressed");  
        
    }
};

// 리사이즈 함수
AUIDataSheetM.prototype.resize = function(){
	AUIGrid.resize(this.AUIcontrolId);
	if(this.defaultColumnSize.length > 0){
		AUIGrid.setColumnSizeList(this.AUIcontrolId, this.defaultColumnSize);
	}
	return;
};

AUIDataSheetM.prototype.excelDownLoad = function(styleFix, downFileName) {
	var nowDate = new Date();
	var now = "_";
	now += nowDate.getFullYear() + "";
	now += ((nowDate.getMonth() + 1) < 10 ? "0" : "") + (nowDate.getMonth() + 1);
	now += (nowDate.getDate() < 10 ? "0" : "") + nowDate.getDate();
	now += (nowDate.getHours() < 10 ? "0" : "") + nowDate.getHours();
	now += (nowDate.getMinutes() < 10 ? "0" : "") + nowDate.getMinutes();
	now += (nowDate.getSeconds() < 10 ? "0" : "") + nowDate.getSeconds();
	now += (nowDate.getMilliseconds() < 10 ? "00" : (nowDate.getMilliseconds() < 100 ? "0" : "")) + nowDate.getMilliseconds();
	
	if(typeof exportProps == "undefined")	exportProps = {};
	
	exportProps["fileName"] = downFileName + now;
	
//	AUIGrid.exportAsXlsx(this.AUIcontrolId, styleFix, {fileName: downFileName + now});
	AUIGrid.exportToXlsx(this.AUIcontrolId, styleFix, exportProps);
	
	return true;
};

/** AUI 이벤트 함수 시작 **/
function auiSheetM_Ready(e, aSheet){
	aSheet.onReady();
	return true;
};

function auiSheetM_addRow(e, aSheet){
	if (aSheet.multilineHelper != null){
		// 관련이벤트는 해당 메서드에서 호출함
		return true;
	};
	
	var atRowNum = e.rowIndex + 1;
	
	var arrData = aSheet.linkedObjects;
	var dataLen = arrData.length;
	aSheet.notSetValue = true;
	
	for(var i = 0; i < dataLen;i++){
		arrData[i].notSetValue = true;
	}
	
	// 시트 줄수값 갱신
	aSheet.maxRows++;
	
	// DataRow 갱신 ----------------------------------------------------
	var rowsLen = aSheet.rows.length - 1;
    for (var wRowNum = rowsLen; wRowNum >= atRowNum; wRowNum--){
    	if(aSheet.rows[wRowNum] == undefined) continue;
    	aSheet.rows[wRowNum + 1] = aSheet.rows[wRowNum];
    }
    
    // EXORow 추가
    aSheet.rows[atRowNum] = new EXORow();
     //새로추가된줄 표시
    aSheet.rows[atRowNum].newData = true;
    // 객체 생성전 생성관련 속성 세팅 ( newData )
	for(var i = 0; i < dataLen;i++){
		arrData[i].newData = true;
	}
	// 객체 데이터 생성
	if(aSheet.hasAddRowDataEvent) aSheet.fncAddRowDataEvent(atRowNum);
	
	for(var i = 0; i < dataLen;i++){
		arrData[i].newData = false;
	}
	
	aSheet.notSetValue = false;
	
	for(var i = 0; i < dataLen;i++){
		arrData[i].notSetValue = false;
		
		arrData[i].seq = aSheet.rows[atRowNum].objectSeq;
		if (arrData[i].hasAddRecordEvent) arrData[i].fncAddRecordEvent(); // 지금은 change 이벤트가 일어나지 않기 때문에 강제로 addRecordEvent를 호출해준다.
	}
	
	aSheet.setCurrentRow(atRowNum);
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 이벤트단계 : 사용자 이벤트
	    if (aSheet.inputMode == SHEETMODE_SETCELL){
	        if (aSheet.hasAddRowEvent) {
	        	aSheet.fncAddRowEvent(atRowNum);
	        }
	    }
	}
    
    return true;
};

function auiSheetM_removeRow(e, aSheet){
	if (aSheet.multilineHelper != null){
		// 관련이벤트는 해당 메서드에서 호출함
		return true;
	};

	aSheet.notSetValue = true;
	var arrData = aSheet.linkedObjects;
	
	var items = e.items;
	var itemsLen = items.length;
	var atRowNum = 0;
	var removedRowCount = 0;	//물리적으로 삭제된 행 갯수
	var rowId = "";
	
	for(var j=0; j<itemsLen; j++){
		/*
		// rowIdField가 지정되어 있을때 
		if(aSheet.rowIdField != null){
			atRowNum = AUIGrid.rowIdToIndex(aSheet.AUIcontrolId, e.items[j][aSheet.rowIdField]) + 1;
		}
		// 지정되어있지 않다면 내부 rowId(_$uid)가 생성되어있다
		else{
			atRowNum = AUIGrid.rowIdToIndex(aSheet.AUIcontrolId, e.items[j]._$uid) + 1;
		}
		*/
		
		// rowIdField가 지정되어 있을때
		if(aSheet.rowIdField != null){
			rowId = e.items[j][aSheet.rowIdField];
		}
		// 지정되어있지 않다면 내부 rowId(_$uid)가 생성되어있다
		else{
			rowId = e.items[j]._$uid;
		}
		//삭제된 행의 행 번호를 가져온다
		atRowNum = AUIGrid.rowIdToIndex(aSheet.AUIcontrolId, rowId) + 1;
		
		if(arrData.length > 0){
			aSheet.currentRow = atRowNum;
			// 데이터 row가 있을때
			if(aSheet.rows[atRowNum] != null || aSheet.rows[atRowNum] != undefined) {
				for (var i = 0; i < arrData.length;i++) {
					arrData[i].seq = aSheet.rows[atRowNum].objectSeq;
				}
			}
			// 데이터 row가 없을때는 만든다
			else {
				aSheet.rows[atRowNum] = new EXORow();
				if(aSheet.hasAddRowDataEvent) aSheet.fncAddRowDataEvent(atRowNum);
				for (var i = 0; i < arrData.length;i++) {
					arrData[i].seq = aSheet.rows[atRowNum].objectSeq;
				}
			}
			
			aSheet.fncChangeEvent(atRowNum, 1, "", "");
		}
		
		// 1)SOFT행삭제를 하지 않거나 2)SOFT행삭제를 하면서 추가된 행인 경우 삭제된 행 갯수를 증가시킨다
		if( !aSheet.softRemoveRowMode || (aSheet.softRemoveRowMode && AUIGrid.isAddedById(aSheet.AUIcontrolId, rowId)) ){
			removedRowCount++;
			//console.log(removedRowCount);
		}
		
		//삭제된 행이 클릭한 행이면 _clicked_row_id 초기화
		if(aSheet._clicked_row_id + "" == rowId + ""){
			aSheet._clicked_row_id = "";
		}
		
		//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
		if( !this.passEvent ){
			// 이벤트 : 객체.줄삭제
			if (aSheet.hasDelRowDataEvent) aSheet.fncDelRowDataEvent(atRowNum);
		}
	}
	
	/*// 줄 바로 삭제하는 경우
	if(!aSheet.softRemoveRowMode) {
		aSheet.maxRows -= j;
		aSheet.currentRow = aSheet.maxRows;
	}*/
	
	// 삭제된 행 갯수가 0보다 큰 경우(물리적인 행 삭제가 된 경우)
	if(removedRowCount > 0) {
		aSheet.maxRows -= removedRowCount;
		aSheet.currentRow = aSheet.maxRows;
	}
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 삭제 후 사용자 이벤트
		if (aSheet.hasDelRowEvent) aSheet.fncDelRowEvent(atRowNum);
	}
	
    aSheet.notSetValue = false;
    
//    if (aSheet.sheetType == SHEETTYPE_LISTSHEET){
//         if (aSheet.hasRowChangeEvent && !aSheet.inClearMode) aSheet.fncRowChangeEvent(atRowNum, atRowNum);
//    } else {
//         if (aSheet.hasRowChangeEvent && !aSheet.inClearMode) aSheet.fncRowChangeEvent(atRowNum, atRowNum, aSheet.rows[atRowNum].objectSeq);
//    } 
    
    return true;
};

function auiSheetM_selectionChange(e, aSheet){
	var AUIRowIndex = e.selectedItems[0].rowIndex;
	var AUIColIndex =  e.selectedItems[0].columnIndex;
	
	
	var rowNum =  (aSheet.multilineHelper != null ? aSheet.multilineHelper.getLogicalRowNum(AUIRowIndex + 1) : AUIRowIndex + 1);
	var colNum =  (aSheet.multilineHelper != null ? aSheet.multilineHelper.getLogicalColNum(AUIRowIndex + 1, AUIColIndex + 1) : AUIColIndex + 1);
	
	aSheet.cellChange(rowNum, colNum);
	return true;
};

function auiSheetM_cellClick(e, aSheet){
	aSheet._clicked_row_id = (aSheet.rowIdField == null) ? e.item._$uid : e.item[aSheet.rowIdField];

	var rowNum =  (aSheet.multilineHelper != null ? aSheet.multilineHelper.getLogicalRowNum(e.rowIndex + 1) : e.rowIndex + 1);
	var colNum =  (aSheet.multilineHelper != null ? aSheet.multilineHelper.getLogicalColNum(e.rowIndex + 1, e.columnIndex + 1) : e.columnIndex + 1);
	
	aSheet.click(rowNum, colNum);
	return true;
};

function auiSheetM_cellDoubleClick(e, aSheet){
	aSheet._clicked_row_id = (aSheet.rowIdField == null) ? e.item._$uid : e.item[aSheet.rowIdField];
	var rowNum =  (aSheet.multilineHelper != null ? aSheet.multilineHelper.getLogicalRowNum(e.rowIndex + 1) : e.rowIndex + 1);
	var colNum =  (aSheet.multilineHelper != null ? aSheet.multilineHelper.getLogicalColNum(e.rowIndex + 1, e.columnIndex + 1) : e.columnIndex + 1);
	
	if(aSheet.hasDblClickEvent) aSheet.fncDblClickEvent(rowNum, colNum);
	
	return true;
};

function auiSheetM_headerClick(e, aSheet){
	// 체크박스 칼럼 클릭 한 경우
	if(e.item.renderer && e.item.renderer.type == "CheckBoxEditRenderer") {
		var checkBoxId = aSheet.AUIcontrolId + "_f" + (e.columnIndex + 1) + "_allCheckbox";
		if(e.orgEvent.target.id == checkBoxId) { // 정확히 체크박스 클릭 한 경우만 적용 시킴.
			var isChecked = document.getElementById(checkBoxId).checked;
			var checkColumnValue = isChecked? "1": "0"; // true는 1로 false는 0로 변경
			// 모든 체크박스 컬럼값 모두 변경
			var colNum =  (this.multilineHelper != null ? aSheet.multilineHelper.getLogicalColNum(e.rowIndex + 1, e.columnIndex + 1) : e.columnIndex + 1);
			aSheet.setValueAllColumn(colNum, checkColumnValue);
			// 헤더 체크 박스 일치시킴.
			document.getElementById(checkBoxId).checked = isChecked;
		}
		return false;
	} else {
		if( !this.passEvent ){
			if(aSheet.hasHeadClickEvent) aSheet.fncHeadClickEvent(e.item.depth, e.columnIndex + 1, e.headerText);
		}

	}
	
	return true;
};

function auiSheetM_setValue(e, aSheet){
	//엔터로 값이 변경되었다면 event.keyCode를 시트 change 사용자 함수에 전달
	var keyCode = undefined;
	if(typeof window.event != "undefined" && window.event instanceof KeyboardEvent){
		keyCode = window.event.keyCode;
	}
	// 객체에 값 세팅
	var shtRowNum = e.rowIndex + 1;	
	var shtColNum = e.columnIndex + 1;
	
	var rowNum =  (aSheet.multilineHelper != null ? aSheet.multilineHelper.getLogicalRowNum(shtRowNum) : shtRowNum);
	var colNum =  (aSheet.multilineHelper != null ? aSheet.multilineHelper.getLogicalColNum(shtRowNum, shtColNum) : shtColNum);

	aSheet.setValueAUI(rowNum, colNum, e.value, e.oldValue, keyCode);
	
	var columnInfo = AUIGrid.getColumnLayout(aSheet.AUIcontrolId)
	var mergePolicy = columnInfo[e.columnIndex].mergePolicy;
	if(typeof mergePolicy != "undefined" && mergePolicy == "restrict"){
		var info = {};info["f" + shtColNum] = e.value;
		AUIGrid.updateRow(aSheet.AUIcontrolId, info, e.rowIndex +1);
	}	
	
	// 피벗 갱신
	if (aSheet.pivotBound){
		if (typeof aSheet.updatePivotCell != "undefined"){
			aSheet.updatePivotCell(rowNum, colNum, e.value, e.oldValue);
		}
		return true;
	}
	
	
	// 컬럼에 있는 전체체크 체크박스의 아이디
	var checkBoxId = aSheet.AUIcontrolId + "_f" + shtColNum + "_allCheckbox";
	// 체크박스 칼럼 수정 완료 한 경우
	if(document.getElementById(checkBoxId)) {
		
		// 데이터에서 해당 체크 필드의 값이 1 인 행 아이템 모두 반환
		var activeItems = AUIGrid.getItemsByValue(aSheet.AUIcontrolId, "f"+ shtColNum, "1");
		// 헤더 체크 박스 전체 체크 일치시킴.
		if(activeItems.length != aSheet.maxRows) {
			document.getElementById(checkBoxId).checked = false;
		} else if(activeItems.length == aSheet.maxRows) {
			document.getElementById(checkBoxId).checked = true;
		}
	}
	
	return true;
};

function auiSheetM_sorting(e, aSheet){
	if(aSheet.hasSortedEvent) aSheet.fncSortedEvent();
	return true;
};

function auiSheetM_vScroll(e, aSheet){
	if(e.position == e.maxPosition){
		jobControler.open(aSheet.fillJobName, "", aSheet.pageNum);
		aSheet.pageNum++;
	}
	return true;
};

function auiSheetM_keyDown(e, aSheet){
	//F5 키 이벤트 동작 제어
	if(e.keyCode == 116 || e.which == 116) {
		e.orgEvent.preventDefault();
		return false;
	}
	
	//이벤트 정보
	var evt = (e.orgEvent) ? e : window.event;
	e = (evt.orgEvent) ? evt.orgEvent : window.event;
	//현재 키 다운 이벤트가 발생한 시트
	var em = null;
	var sheet = aSheet ? aSheet : null;
	if(sheet == null){
    	em = getSrcElement(e);
    	sheet = searchSheet(em);    	
    }
	
	//입력된 키 정보
	var keyCode = (e.which) ? e.which : e.keyCode;	// 키 코드
	var ctrlDown = getCtrlPressed(e);				// 컨트롤 // 커맨드(Mac지원)
	var altDown = getAltPressed(e);					// 알트
	var shiftDown = getShiftKeyPressed(e);			// 쉬프트
	//현재 행, 열 번호
	var rowNum = -1;
	var colNum = -1;

	//사용자 코딩 추가영역 호출
	var wResult = true;
	if(sheet.hasKeyDownEvent){
		wResult = sheet.fncKeyDownEvent(sheet.currentRow, sheet.currentCol, keyCode, shiftDown, ctrlDown, altDown);
	}	
	
    //컨트롤, 알트, 쉬프트 키가 안 눌리고 방향키만 눌린 경우
    if( !ctrlDown && !altDown && !shiftDown && (keyCode >= 37 && keyCode <= 40) ){
    	rowNum = sheet.currentRow;
    	colNum = sheet.currentCol;
    	
//    	console.log("Current Row : " + rowNum);
//    	console.log("Current Col : " + colNum);
    	
    	//방향키 동작
    	if(keyCode == 37){			//왼쪽
    		colNum = (colNum - 1 > 1) ? colNum - 1 : 1;
    		sheet.setCurrentCol(colNum);
    	}
    	else if(keyCode == 39){		//오른쪽
    		colNum = (colNum + 1 <= sheet.maxCols) ? colNum + 1 : sheet.maxCols;
    		sheet.setCurrentCol(colNum);
    	}
    	else if(keyCode == 38){		//위
    		rowNum = (rowNum - 1 > 1) ? rowNum - 1 : 1;
    		sheet.setCurrentRow(rowNum);
    	}
    	else if(keyCode == 40){		//아래
    		rowNum = (rowNum + 1 <= sheet.maxRows) ? rowNum + 1 : sheet.maxRows;
    		sheet.setCurrentRow(rowNum);
    	}
    }
    
    return true;
};

function auiSheetM_editBegin(e, aSheet){
	var wReturn = true;
	
	var rowNum = e.rowIndex + 1;
	var colNum = e.columnIndex + 1;

	//컬럼에 잠금 조건이 있는지 체크
	var columnObject = (AUIGrid.getColumnInfoList(aSheet.AUIcontrolId))[e.columnIndex];
	var lockFunction = (columnObject != undefined) ? columnObject.lockFunction : null;
	var isFunction = (typeof(lockFunction) == "function") ? true : false;
	
	//잠금 조건이 있는 경우, 잠금 조건에 의한 잠금여부 리턴
	if(lockFunction && isFunction){
		wReturn = lockFunction(rowNum, colNum);  // Logical Col 이 아닌 Sheet Col을 받음 
	}

	//잠금 여부는 boolean 형으로 리턴되야 하므로 삼항연산으로 true 또는 false로 변환
	wReturn = wReturn ? true : false;
	
	//리턴 : true(편집가능) / false(편집불가능)
	return wReturn;
};
// 오늘 수정
function auiSheetM_setValueBefore(e, aSheet){
	var value = e.value;
	var oldValue = e.oldValue;

	var columnInfo = (typeof AUIGrid.getColumnInfoList == "function" ? 
					            AUIGrid.getColumnInfoList(aSheet.AUIcontrolId) :
					            AUIGrid.getColumnLayout(aSheet.AUIcontrolId));
	
	//입력된 값의 컬럼의 타입이 날짜인 경우 / 구분자를 제거
	if(columnInfo[e.columnIndex].dataType == "date"){
		e.value = e.value.replace(/[/-]/g, "");		
		
		value = value.replace(/[/-]/g, "");		
		oldValue = oldValue.replace(/[/-]/g, "");		
	}
	
	// dataset 현재줄 추가 기능 
	if (typeof(AUIDataSheet.prototype._UpdateCheckDataset) != "undefined"){
		var uid = e.item._$uid;
		// 2016-06-11 multiLine 시트 더블클릭시 에러가 발생하는 현상 수정
		//var wLogicalColNum = getLogicalColNum(e.rowIndex + 1, e.columnIndex + 1);
		var wLogicalColNum = aSheet.multilineHelper.getLogicalColNum(e.rowIndex + 1, e.columnIndex + 1);
		var result = aSheet._UpdateCheckDataset(uid, wLogicalColNum, oldValue, value );
		
		if (!result) return e.oldValue;
	}
		
	return e.value;
};
/** 이벤트 함수 끝 **/


AUIDataSheetM.prototype.exoRowClear = function(){
	this.rows = [null];
	this.rows[1] = new EXORow();
	this.rows[1].newData = true;
};

AUIDataSheetM.prototype.setEnabled = function(enabled){
	// functionname : [Control.setEnabled]

	this.enabled = enabled;
	// 하위 테그들의 글자색 조정
    this.tagObject.disabled = !enabled;
};


AUIDataSheetM.prototype.setVisible = function(visible){
	// functionname : [Control.setVisible]

	if (this.visible == visible) return;
	this.visible = visible;

	var obj =  this.tagObject;
	var comp = obj.currentStyle ? obj.currentStyle : getComputedStyle(obj, null);
	
    if (("" + comp.position).toLowerCase() == "absolute" || ("" + comp.position).toLowerCase() == "relative"){
    	if (visible){
    		if (obj.style.left == "-10000px"){
    			obj.style.left = obj.getAttribute("xposition");
    		}
    	} else {
    		obj.setAttribute("xposition", obj.style.left);
    		obj.style.left = "-10000px";
    	}
    	this.tagObject.style.display = (visible ? "block" : "none");
    } else {
    	this.tagObject.style.display = (visible ? "inline" : "none");
    }
    
    this.resize();
    
    return;
};

// logical 줄번호를 받는다
AUIDataSheetM.prototype.setCurrentRow = function(rowNum){
    // functionname : [AUIDataSheetM.setCurrentRow]
	if (this.currentRow == rowNum) return;
	if(rowNum > this.maxRows){
		alert(getText("message_AUIDataSheetM_016", "현재의 줄 수 {0} 보다 클 수는 없습니다.", [this.maxRows]));
		return;
	}

	var oldRowNum = this.currentRow;
	this.currentRow = rowNum;
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		if (this.sheetType == SHEETTYPE_LISTSHEET){
	        if (this.hasRowChangeEvent) this.fncRowChangeEvent(oldRowNum, rowNum);
		}
		else if(this.rows[rowNum]){
	        if (this.hasRowChangeEvent) this.fncRowChangeEvent(oldRowNum, rowNum, this.fillKeyField? 1: this.rows[rowNum].objectSeq);
		}
		/*
		 * 	임시조치(2016-03-01)
		 * 	setData 시 객체의 rows 에 EXORow를 생성/추가하지 않는다.
		 */
		else{
			if (this.hasRowChangeEvent) this.fncRowChangeEvent(oldRowNum, rowNum);
		}
	}
	
	// dataset 현재줄 갱신 기능 
    if (typeof(ControlBase.prototype._UpdateDatasetRowPos) != "undefined"){
	    var wShtRowNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetRowNum(rowNum) : rowNum);
    	var row = AUIGrid.getItemByRowIndex(this.AUIcontrolId, wShtRowNum -1);
		if(row != null){
			var uid = row._$uid;
			this._UpdateDatasetRowPos(uid);
		}
    }
	
	return;
};

AUIDataSheetM.prototype.setCurrentCol = function(colNum){
    // functionname : [AUIDataSheetM.setCurrentCol]
	
	if (this.currentCol == colNum) return;
	if(colNum > this.maxCols){
		alert(getText("message_AUIDataSheetM_017", "현재의 열 수 {0} 보다 클 수는 없습니다.", [this.maxCols]));
		return;
	}

	var oldColNum = this.currentCol;
	this.currentCol = colNum;
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
	    if (this.hasColChangeEvent){
	    	this.fncColChangeEvent(oldColNum, colNum);
	    }	
	}
	
	return;
};

AUIDataSheetM.prototype.refresh = function(){
    // functionname : [AUIDataSheetM.refresh]
    // 셀값들을 다시 채운다.
	
	AUIGrid.refresh(this.AUIcontrolId);
	
    return;
};

// 선택한 줄 뒤로 줄이 추가된다
// pAtRowNum가 생략된다면 현재 마지막에 추가된다
// objectSeq는 데이터 순번으로 선택항목이다
AUIDataSheetM.prototype.addRow = function(atRowNum, Decoration, updateDataset){
    // functionname : [AUIDataSheetM.addRow]

    Decoration = (typeof Decoration == "undefined" ? "last" : (Decoration == null ? "last" : Decoration));

    if(atRowNum == undefined || atRowNum == null) atRowNum = this.maxRows; 
    
    // "선택한 줄 뒤"로 줄이 추가된다
    if (this.multilineHelper != null){
        var nNewRow = atRowNum + 1;
        var wShtRowNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetRowNum(nNewRow) : nNewRow);
        var rtnRow = wShtRowNum;   // 추가되는 첫 줄 번호를 리턴한다
        
        var arrColumnInfos = AUIGrid.getColumnInfoList(this.AUIcontrolId);
         
        for (var i=0; i < this.rowsPerDataRow; i++){
         	var defaultLayoutValue = eval(this.multilineHelper.defaultLayoutValue[i]);
         	defaultLayoutValue["f1"] = atRowNum + 1;
         	
             // 산식때문에 문자열로 받아서 eval하여 넣어준다.
        	AUIGrid.addRow(this.AUIcontrolId, defaultLayoutValue, wShtRowNum - 1);
        	wShtRowNum++;
        }
        this.multilineHelper.resetRowNum();
        AUIGrid.refresh(this.AUIcontrolId);
        
         // 이벤트단계 : 사용자 이벤트
         if (this.inputMode == SHEETMODE_SETCELL){
             if (this.hasAddRowEvent) {
            	 this.fncAddRowEvent(atRowNum);  // OK
             }
         }
         
         // dataset 현재줄 추가 기능 
 		if(updateDataset == undefined || updateDataset){
 			if (typeof(AUIDataSheetM.prototype._UpdateDatasetAddRow) != "undefined"){
 				var availableRowNum = this.getAvailableRowNum(nNewRow);
 				if (availableRowNum > 0){
 					this._UpdateDatasetAddRow(availableRowNum);
 				}
 			}
		}
         
    } else {
    	var wShtRowNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetRowNum(atRowNum) : atRowNum);
        var nNewRow = wShtRowNum + 1;
        
        // 산식때문에 문자열로 받아서 eval하여 넣어준다.
    	AUIGrid.addRow(this.AUIcontrolId, eval(this.defaultLayoutValue), nNewRow - 1);
    
    	// dataset 현재줄 추가 기능 
    	if (typeof(AUIDataSheetM.prototype._UpdateDatasetAddRow) != "undefined"){
    		var availableRowNum = this.getAvailableRowNum(nNewRow);
    		if (availableRowNum > 0){
    			this._UpdateDatasetAddRow(availableRowNum);
    		}
    	}
    }
    
	if (this.multilineHelper != null){
		this.maxRows = AUIGrid.getGridData(this.AUIcontrolId).length / this.rowsPerDataRow;
	} else {
		this.maxRows = AUIGrid.getGridData(this.AUIcontrolId).length;
	}

    return nNewRow;
};

// 지정줄 삭제 (atRowNum 위치의 줄을 삭제한다)
AUIDataSheetM.prototype.delRow = function(atRowNum, Decoration, updateDataset){
	if (this.maxRows == 0) return;

    Decoration = (typeof Decoration == "undefined" ? "last" : (Decoration == null ? "last" : Decoration));

	// rowIndex가 없을시 현재 선택된 줄
	atRowNum = (atRowNum == undefined? this.currentRow: atRowNum);
	var wShtRowNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetRowNum(atRowNum) : atRowNum);
	var uid = AUIGrid.getItemByRowIndex(this.AUIcontrolId, wShtRowNum - 1)._$uid;

    if (this.multilineHelper != null){
    	var AUIRowNum = wShtRowNum - 1;
        for (var i=this.rowsPerDataRow -1; i >= 0; i--){
        	AUIGrid.removeRow(this.AUIcontrolId, AUIRowNum + i);
        } 

        // 이벤트 : 객체.줄삭제
    	if (this.hasDelRowDataEvent) this.fncDelRowDataEvent(atRowNum);  

    	// 삭제된 행 갯수가 0보다 큰 경우(물리적인 행 삭제가 된 경우)
    	this.maxRows--;
    	if (this.currentRow > atRowNum ){ this.currentRow--; } 
    	else if (this.currentRow > this.maxRows ){ this.currentRow = this.maxRows; }
    	
    	this.multilineHelper.resetRowNum();

    	// 삭제 후 사용자 이벤트
    	if (this.hasDelRowEvent) this.fncDelRowEvent(atRowNum);
    
    } else {
    	var delRows = AUIGrid.getSelectedItems(this.AUIcontrolId);
    	var delRowLen  = delRows.length;
    	
    	if(delRowLen < 2 || Decoration){
    		AUIGrid.removeRow(this.AUIcontrolId, atRowNum - 1);
    	}
    	else {
    		var items = [];
    		// rowIdField가 지정되어 있을때 
    		if(this.rowIdField != null){
    			for(var i = 0; i<delRowLen; i++){
    				items.push(delRows[i].item[this.rowIdField]);
    			}
    		}
    		// 지정되어있지 않다면 내부 rowId(_$uid)가 생성되어있다
    		else{
    			for(var i = 0; i<delRowLen; i++){
    				items.push(delRows[i].item._$uid);
    			}
    		}
    		
    		AUIGrid.removeRowByRowId(this.AUIcontrolId, items);
    	}
    }
	
	//auiSheetM_removeRow 호출됨
    // dataset 현재줄 삭제 기능 
	if(updateDataset == undefined || updateDataset){
		if (typeof(AUIDataSheetM.prototype._UpdateDatasetDelRow) != "undefined"){
			this._UpdateDatasetDelRow(uid);
		}	
	}
    return;
};

//지정줄 삭제 ((uid, 의 줄을 삭제한다) 한 데이터내의 두번째이상의 줄의 아이디를 주면 동작 안함
AUIDataSheetM.prototype.delRowByUid = function(uid, Decoration, updateDataset){
	if (this.maxRows == 0) return;
    Decoration = (typeof Decoration == "undefined" ? "last" : (Decoration == null ? "last" : Decoration));

	// rowIndex가 없을시 현재 선택된 줄
	var AUIRowNum = this.getIndexOf_$uid(uid);
   	var atRowNum = (this.multilineHelper != null ? this.multilineHelper.getLogicalRowNum(AUIRowNum + 1) : AUIRowNum + 1);
    	
    if (this.multilineHelper != null){
    	
		// 두번째줄이 선택된 경우 대비
        var sheetRowNum = this.multilineHelper.getSheetRowNum(atRowNum);
		AUIRowNum = sheetRowNum - 1;
    	
    	
        for (var i = this.rowsPerDataRow -1; i >= 0; i--){
        	AUIGrid.removeRow(this.AUIcontrolId, AUIRowNum + i);
        }
        // 이벤트 : 객체.줄삭제
    	if (this.hasDelRowDataEvent) this.fncDelRowDataEvent(atRowNum);  
        
    	// maxRows, currentRow 처리
    	this.maxRows--;
    	if (this.currentRow > atRowNum ){ this.currentRow--; } 
    	else if (this.currentRow > this.maxRows ){ this.currentRow = this.maxRows; }

        
    	this.multilineHelper.resetRowNum();
    	
    	// 삭제 후 사용자 이벤트
    	if (this.hasDelRowEvent) this.fncDelRowEvent(atRowNum);
    	
    } else {
    	var delRows = AUIGrid.getSelectedItems(this.AUIcontrolId);
    	var delRowLen  = delRows.length;
    	
    	if(delRowLen < 2 || Decoration){
    		AUIGrid.removeRow(this.AUIcontrolId, AUIRowNum);
    	}
    	else {
    		var items = [];
    		// rowIdField가 지정되어 있을때 
    		if(this.rowIdField != null){
    			for(var i = 0; i<delRowLen; i++){
    				items.push(delRows[i].item[this.rowIdField]);
    			}
    		}
    		// 지정되어있지 않다면 내부 rowId(_$uid)가 생성되어있다
    		else{
    			for(var i = 0; i<delRowLen; i++){
    				items.push(delRows[i].item._$uid);
    			}
    		}
    		
    		AUIGrid.removeRowByRowId(this.AUIcontrolId, items);
    	}
    }
	
	//auiSheetM_removeRow 호출됨
    // dataset 현재줄 삭제 기능 
	if(updateDataset == undefined || updateDataset){
		if (typeof(AUIDataSheetM.prototype._UpdateDatasetDelRow) != "undefined"){
			this._UpdateDatasetDelRow(uid);
		}
	}
	
    return;
};

AUIDataSheetM.prototype.setMaxRows = function(rows){
    // functionname : [AUIDataSheetM.setMaxRows]
	
	var sheetData = AUIGrid.getGridData(this.AUIcontrolId);

    if (this.multilineHelper != null){
        if (this.maxRows > rows){
            for (var wRowNum = this.maxRows; wRowNum > rows; wRowNum--){
            	var AUIRowNum = wRowNum - 1;
                for (var i=this.rowsPerDataRow - 1; i >= 0; i--){
                	sheetData.pop();
                }
            }
            
        } else if (this.maxRows < rows){
            var arrColumnInfos = AUIGrid.getColumnInfoList(this.AUIcontrolId);
            for (var wRowNum = this.maxRows + 1; wRowNum <= rows; wRowNum++){
            	var AUIRowNum = wRowNum - 1;
                for (var i=0; i < this.rowsPerDataRow; i++){
                 	var defaultLayoutValue = eval(this.multilineHelper.defaultLayoutValue[i]);
                 	defaultLayoutValue["f1"] = wRowNum + 1;
                 	
                 	for (var j=1; j < arrColumnInfos.length;j++){
                 		if (arrColumnInfos[j].cellMerge ){
                 			var dataField = arrColumnInfos[j].dataField;
                 			if (wRowNum % 2 == 1){
                 				defaultLayoutValue[dataField] = "  ";
                 			} else {
                 				defaultLayoutValue[dataField] = " ";
                 			}
                 		}
                 	}
                 	sheetData.push(defaultLayoutValue);
                }
                
            }
        }

    	this.multilineHelper.resetRowNum();
    	
    } else {
        if (this.maxRows > rows){
            for (var wRowNum = this.maxRows; wRowNum > rows; wRowNum--){
            	sheetData.pop();
            }
            
        } else if (this.maxRows < rows){
            var arrColumnInfos = AUIGrid.getColumnInfoList(this.AUIcontrolId);
            for (var wRowNum = this.maxRows; wRowNum < rows; wRowNum++){
              	var defaultLayoutValue = eval(this.defaultLayoutValue);
              	
             	for (var j=1; j < arrColumnInfos.length;j++){
             		if (arrColumnInfos[j].cellMerge ){
             			var dataField = arrColumnInfos[j].dataField;
             			if (wRowNum % 2 == 1){
             				defaultLayoutValue[dataField] = "  ";
             			} else {
             				defaultLayoutValue[dataField] = " ";
             			}
             		}
             	}
                sheetData.push(defaultLayoutValue);
            }
        }    	
    }
	
	//시트 클리어하며 데이터셋도 클리어(시트 클리어하면 시트를 지우고 다시 만듦)
	this.AUIClear();
	
	//생성한 시트에 데이터 입력
	this.setData(sheetData);

	// 삭제된 행 갯수가 0보다 큰 경우(물리적인 행 삭제가 된 경우)
	this.maxRows = rows;
	if (this.currentRow > this.maxRows ){ this.currentRow = this.maxRows; }
    
    return;
};

// 원하는 숫자만큼의 줄을 추가 후, 데이터를 추가할 수 있는 첫줄번호를 리턴
AUIDataSheetM.prototype.addRows = function(rows){
    // functionname : [AUIDataSheetM.addRows]

    var wRow = this.maxRows;
//    while (wRow > 0 && this.isEmptyRow(wRow)) wRow--;
    this.setMaxRows(wRow + rows);
    
    return wRow + rows;
};


AUIDataSheetM.prototype.getValue = function(){
    // functionname : [AUIDataSheetM.getValue]

    // 콤보 스타일에서 인수는 Logical 줄,열번호이다
    var wRowNum = this.currentRow;
    var wColNum = this.currentCol;
    var args = Array.prototype.slice.call(arguments);
    if (args.length == 1){
        wColNum = args[0];
    } else {
        wRowNum = args[0];
        wColNum = args[1];
    }
    

	var jsonPos = this.multilineHelper.getPosition(wRowNum, wColNum);
    var wShtRowNum = jsonPos.sheetRow;
    var wShtColNum = jsonPos.sheetCol;
    
 	var value = "";
 	
    try{
    	var dataField = "f" + wShtColNum;
    	value = AUIGrid.getItemByRowIndex(this.AUIcontrolId, wShtRowNum-1)[dataField];
    } catch(e){
    	value = "";
    }
    
    return value;    
};

//인수가 하나만 넘어왔을 경우 컬럼번호로 인식하고 해당 컬럼의 모든 데이터를 배열로 리턴한다.
AUIDataSheetM.prototype.getColumnValue = function(){
    // functionname : [AUIDataSheetM.getValue]
	// 인수가 하나만 넘어왔을 경우 컬럼번호로 인식하고 해당 컬럼의 모든 데이터를 배열로 리턴한다.
	var returnArray = false;
	// 리턴값
	var returnValue = [];
	
    // 콤보 스타일에서 인수는 Logical 줄,열번호이다
    var wRowNum = this.currentRow;
    var wColNum = this.currentCol;
    var args = Array.prototype.slice.call(arguments);
    if (args.length == 1){
        wColNum = args[0];
        returnArray = true
    } else {
        wRowNum = args[0];
        wColNum = args[1];
    }
    
	var jsonPos = this.multilineHelper.getPosition(wRowNum, wColNum);
    var wShtRowNum = jsonPos.sheetRow;
    var wShtColNum = jsonPos.sheetCol;
    
    
    try{
    	// 해당 컬럼의 데이터필드 값
    	var dataField = "f" + wShtColNum;
    	
    	if(returnArray){
    		returnValue = AUIGrid.getColumnValues(this.AUIcontrolId, dataField);
    	}else{
    		returnValue = AUIGrid.getItemByRowIndex(this.AUIcontrolId,wShtRowNum-1)[dataField];
    	}
    } catch(e){
    	returnValue = "";
    }
    
    return returnValue;
};

// 사용자에 의해 줄추가된 데이터만 가져온다. * 배열로 행,로우 전체를 가져옴
AUIDataSheetM.prototype.getAddedRowItems = function(){
	return AUIGrid.getAddedRowItems(this.AUIcontrolId);
};

//수정된 데이터를 가져온다. * 배열로 행,로우 전체를 가져옴
AUIDataSheetM.prototype.getEditedRowItems = function(){
	return AUIGrid.getEditedRowItems(this.AUIcontrolId);
};

// 삭제된 데이터를 가져온다 ( 줄추가되었다 삭제된 행은 제외) * 배열로 행,로우 전체를 가져옴)
// AUI 줄데이터로 [논리줄수 * 멀티라인수]만큼의 시트 원본데이터를 리컨한다.
AUIDataSheetM.prototype.getRemoveItems = function(){
	return AUIGrid.getRemovedItems(this.AUIcontrolId);
};

// 해당 줄의 I,U,D,N 플래그를 가져온다
AUIDataSheetM.prototype.getIUDNFlag = function(rowNum){
	// 인자값이 없을때는 현재 줄번호
	if(!rowNum) rowNum = this.currentRow;
	
	var wShtRowNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetRowNum(rowNum) : rowNum);
	
    var data = AUIGrid.getItemByRowIndex(this.AUIcontrolId, wShtRowNum-1);
    // 없는 데이터라면 null 리턴
    if(data == undefined || data == null) return null;
    
	var rowId = data._$uid;
	
	// 플래그 찾기
	// 추가된 데이터
	var array_IUDN = this.getAddedRowItems();
	for(var i=0; i<array_IUDN.length; i++){
		if(array_IUDN[i]._$uid == rowId){
			return "I";
		}
	}
	// 수정된 데이터
	array_IUDN = this.getEditedRowItems();
	for(var i=0; i<array_IUDN.length; i++){
		if(array_IUDN[i]._$uid == rowId){
			return "U";
		}
	}
	// 삭제된 데이터
	array_IUDN = this.getRemoveItems();
	for(var i=0; i<array_IUDN.length; i++){
		if(array_IUDN[i]._$uid == rowId){
			return "D";
		}
	}
	
	return "N"    
};

// Logical ColNum 을 받는다.
// 해당 colNum의 [추가된데이터["I"], 수정된데이터["U"], 삭제된데이터["D"], 나머지 데이터["N"]] 배열을 리턴 (I,U,D,N)
AUIDataSheetM.prototype.getIUDNStatusColumnValue = function(colNum){
	var returnValue = [];
	var value = [];
	var array_I = [];
	var array_U = [];
	var array_D = [];
	var array_N = [];
	var rowIdField = AUIGrid.getProperty(this.AUIcontrolId, "rowIdField");
	
	// colNum이 없을 경우 현재 선택된 colNum을 넣어준다.
	if(!colNum) colNum = this.currentCol;
	var wShtColNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetColNum(colNum) : colNum);
	
	// 추가된 데이터
	array_I = this.getAddedRowItems();
	for(var i=0; i<array_I.length; i++){
		value.push(array_I[i]["f" + wShtColNum] == undefined? "": array_I[i]["f" + wShtColNum]);
	}
	returnValue["I"] = value;
	value = [];
	
	// 수정된 데이터
	array_U = this.getEditedRowItems();
	for(var i=0; i<array_U.length; i++){
		value.push(array_U[i]["f" + wShtColNum] == undefined? "": array_U[i]["f" + wShtColNum]);
	}
	returnValue["U"] = value;
	value = [];
	
	// 삭제된 데이터
	array_D = this.getRemoveItems();
	for(var i=0; i<array_D.length; i++){
		value.push(array_D[i]["f" + wShtColNum] == undefined? "": array_D[i]["f" + wShtColNum]);
	}
	returnValue["D"] = value;
	value = [];
	
	// 나머지 일반(조회된) 데이터
	array_N = AUIGrid.getGridData(this.AUIcontrolId);
	N :
	for(var i=0; i<array_N.length; i++){
		for(var j=0; j<array_I.length; j++){
			if(array_I[j][rowIdField] == array_N[i][rowIdField]) continue N;
		}
		for(var j=0; j<array_U.length; j++){
			if(array_U[j][rowIdField] == array_N[i][rowIdField]) continue N;
		}
		for(var j=0; j<array_D.length; j++){
			if(array_D[j][rowIdField] == array_N[i][rowIdField]) continue N;
		}
		value.push(array_N[i]["f" + wShtColNum] == undefined? "": array_N[i]["f" + wShtColNum]);
	}
	returnValue["N"] = value;
	
	
	value = null; array_I = null; array_U = null; array_D = null; array_N = null; rowIdField = null;
	
	return returnValue;
};

// dni 모드인 객체의 데이터 미리 생성
AUIDataSheetM.prototype.onReady = function(){
	this.rows = [null]; // 시트 데이터 rows 초기화
	
	if (this.multilineHelper != null){
		this.maxRows = AUIGrid.getGridData(this.AUIcontrolId).length / this.rowsPerDataRow;
	} else {
		this.maxRows = AUIGrid.getGridData(this.AUIcontrolId).length;
	}
/*	
	if(this.fillKeyField) {
		this.rows[1] = new EXORow();
		return;
	}
	
	var arrData = this.linkedObjects;
	var dataLen = arrData.length;
	var dni = false;
	this.notSetValue = true;
	
	
	for(var i = 0; i < dataLen;i++){
		if(arrData[i].dniMode){
			dni = true;
		}else {
			arrData[i].notSetValue = true;
		}
	}
	
	
	if(!dni){
		this.rows[1] = new EXORow();
		for(var i = 0; i < dataLen;i++){
			arrData[i].recordset[1].updateGu = "N";
		}
	}
	else if(dni){
		for(var i = 0; i < dataLen;i++){
			// 객체의 체인지이벤트를 막고 데이터를 추가한다.
			var dataEvent = arrData[i].hasChangeEvent;
			arrData[i].hasChangeEvent = false;
			// 객체 및 시트 rows 데이터 생성
			for(var wRowNum = 1; wRowNum<=this.maxRows; wRowNum++){
				this.currentRow = wRowNum;
				// 이미 해당 인덱스의 객체가 추가 되어있는경우
				if(this.rows[wRowNum] != null || this.rows[wRowNum] != undefined) {
					arrData[i].seq = this.rows[wRowNum].objectSeq;
					//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
					if( !this.passEvent ){
						if(this.hasChangeEvent) this.fncChangeEvent(wRowNum);
					}
				} 
				// 해당 인덱스의 객체가 없을때 생성
				else {
					this.rows[wRowNum] = new EXORow();
					//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
					if( !this.passEvent ){
						if(this.hasAddRowDataEvent) this.fncAddRowDataEvent(wRowNum);
					}
					arrData[i].seq = this.rows[wRowNum].objectSeq;
					//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
					if( !this.passEvent ){
						if(this.hasChangeEvent) this.fncChangeEvent(wRowNum);
					}
				}
			}
			
			arrData[i].hasChangeEvent = dataEvent;
		}
	}
	
	for(var i = 0; i < dataLen;i++){
		arrData[i].notSetValue = false;
	}
*/	
	this.notSetValue = false;
	
	return;
};

//기존 소스와의 호환성
AUIDataSheetM.prototype.setValueAll = function(){
	return;
};

//한컬럼 전체에 동일한 값 세팅
AUIDataSheetM.prototype.setValueAllColumn = function(colNum, value) {
	
	// updateAllToValue함수는 업데이트 표시가 남지 않아 막음
//	AUIGrid.updateAllToValue(this.AUIcontrolId, "f" + colNum, value);
	
	// 그리드의 전체 데이터를 대상으로 컬럼의 값을 바꿈
	for(var i=1; i<=this.maxRows; i++){
		this.setValue(i, colNum, value);
	}
	
	return;
};

// 이미 해당 인덱스의 객체가 있을때 수정된 필드만 고친다
AUIDataSheetM.prototype.setValue = function(){
	if(this.notSetValue/* || this.fillKeyField*/) return;
	
	var wRowNum = this.currentRow;
    var wColNum = this.currentCol;
    var wValue;
    
    var args = Array.prototype.slice.call(arguments);
    if (args.length == 1){
        wValue = args[0];
    } else if (args.length == 2){
        wColNum = args[0];
        wValue = args[1];
    } else {
        wRowNum = args[0];
        wColNum = args[1];
        wValue = args[2];
    }
    	 
    // 기존과 값이 동일하다면 리턴
    if(this.getValue(wRowNum, wColNum) == wValue) return;

	var jsonPos = this.multilineHelper.getPosition(wRowNum, wColNum);
    var wShtRowNum = jsonPos.sheetRow;
    var wShtColNum = jsonPos.sheetCol;

    var dataField = "f" + wShtColNum;
	var item = {};    
	item[dataField] = wValue;
	
	
	try {
		AUIGrid.updateRow(this.AUIcontrolId, item, wShtRowNum - 1);
	} catch(e){
		try {
			AUIGrid.updateRow(this.AUIcontrolId, item, wShtRowNum - 1);
		} catch(e){
			console.log(e);
		}
	}	
	
	// dataset 갱신 기능 
    if (typeof(AUIDataSheetM.prototype._UpdateDataset) != "undefined"){
    	var wFirstShtRowNum = this.multilineHelper.getSheetRowNum(wRowNum);
    	var row = AUIGrid.getItemByRowIndex(this.AUIcontrolId, wFirstShtRowNum - 1);
		if(row != null){
			var uid = row._$uid;
        	this._UpdateDataset(uid, wColNum);	
		}
    }
	
	if( !this.passEvent ){
	    if (this.hasChangeEvent) this.fncChangeEvent(wRowNum, wColNum, wValue, "");
	}
    
	return;
};

// 수정된 인덱스의 전체 값을 객체로 한줄 추가
AUIDataSheetM.prototype.setValueAUI = function(){
	
	var wRowNum = this.currentRow;
    var wColNum = this.currentCol;
    var wValue = "";
    var wOldValue = "";
    var keyCode = "";
    
    var args = Array.prototype.slice.call(arguments);
    if (args.length == 1){
        wValue = args[0];
    } else if (args.length == 2){
        wColNum = args[0];
        wValue = args[1];
    } else if (args.length == 3){
        wRowNum = args[0];
        wColNum = args[1];
        wValue = args[2];
    } else if (args.length == 4){
        wRowNum = args[0];
        wColNum = args[1];
        wValue = args[2];
        wOldValue = args[3];
    } else if (args.length == 5){
        wRowNum = args[0];
        wColNum = args[1];
        wValue = args[2];
        wOldValue = args[3];
        keyCode = args[4];
    }
    
	this.setCurrentRow(wRowNum);
	this.setCurrentCol(wColNum);
	
    // dataset 갱신 기능 
    if (typeof(AUIDataSheetM.prototype._UpdateDataset) != "undefined"){
	    var wShtRowNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetRowNum(wRowNum) : wRowNum);
        var row = AUIGrid.getItemByRowIndex(this.AUIcontrolId, wShtRowNum -1);
		if(row != null){
			var uid = row._$uid;
        	this._UpdateDataset(uid, wColNum);	
		}
    }

    // 이벤트
	if( !this.passEvent ){
		if(this.hasChangeEvent) this.fncChangeEvent(wRowNum, wColNum, wValue, wOldValue, keyCode);
	}
	
	return;
};


//현재 선택된 시트의 줄을 한칸 올린다
AUIDataSheetM.prototype.upRow = function(){
    // functionname : [AUIDataSheetM.upRow]


	// 현재 선택된 데이터(다중선택도 고려)
	var selectDatas = AUIGrid.getSelectedItems(this.AUIcontrolId);
	if (selectDatas.length == 0) return;
	
	if (this.maxRows <= 1 || selectDatas[0].rowIndex == 0) return;

	var AUIRowNum = selectDatas[0].rowIndex;
	var sheetRowNum = AUIRowNum + 1;

	if (this.multilineHelper != null){
		// 두번째줄이 선택된 경우 대비
		var rowNum = this.multilineHelper.getLogicalRowNum(sheetRowNum)
        sheetRowNum = this.multilineHelper.getSheetRowNum(rowNum);
		AUIRowNum = sheetRowNum - 1;
		
		var rowIds = [];
	    for (var i=0; i < this.rowsPerDataRow; i++){
	    	rowIds[i] = AUIGrid.getItemByRowIndex(this.AUIcontrolId, AUIRowNum + i)._$uid; 
	    }
	    AUIGrid.selectRowsByRowId(this.AUIcontrolId, rowIds);
    }
    
    for (var i=0; i < this.rowsPerDataRow; i++){
    	AUIGrid.moveRows2Up(this.AUIcontrolId);
    }
    
    if (this.multilineHelper != null){
        this.multilineHelper.resetRowNum();
    }
    
    // dataset 현재줄 위로 이동 기능 
    if (typeof(AUIDataSheetM.prototype._UpdateDatasetUpRow) != "undefined"){
    	var rowNum =  (this.multilineHelper != null ? this.multilineHelper.getLogicalRowNum(sheetRowNum) : sheetRowNum);
    	var availableRowNum = this.getAvailableRowNum(rowNum);
    	if (availableRowNum > 0){
        	this._UpdateDatasetUpRow(availableRowNum);
    	}
    }
    
    this.setCurrentRow(this.currentRow - 1);
    
    return;
};

// 현재 선택된 시트의 줄을 한칸 내린다
AUIDataSheetM.prototype.downRow = function(){
    // functionname : [AUIDataSheetM.downRow]
	
	// 현재 선택된 데이터(다중선택도 고려)
	var selectDatas = AUIGrid.getSelectedItems(this.AUIcontrolId);
	if (selectDatas.length == 0) return;
	if (this.maxRows <= 1 || selectDatas[selectDatas.length - 1].rowIndex + 1 == this.maxRows) return;
	
	var AUIRowNum = selectDatas[0].rowIndex;
	var sheetRowNum = AUIRowNum + 1;

	if (this.multilineHelper != null){
		// 두번째줄이 선택된 경우 대비
		var rowNum = this.multilineHelper.getLogicalRowNum(sheetRowNum)
        sheetRowNum = this.multilineHelper.getSheetRowNum(rowNum);
		AUIRowNum = sheetRowNum - 1;

		var rowIds = [];
	    for (var i=0; i < this.rowsPerDataRow; i++){
	    	rowIds[i] = AUIGrid.getItemByRowIndex(this.AUIcontrolId, AUIRowNum + i)._$uid; 
	    }
	    AUIGrid.selectRowsByRowId(this.AUIcontrolId, rowIds);
	}
    for (var i=0; i < this.rowsPerDataRow; i++){
    	AUIGrid.moveRows2Down(this.AUIcontrolId);
    }

    if (this.multilineHelper != null){
        this.multilineHelper.resetRowNum();
    }
	    
    // dataset 현재줄 아래로 이동 기능 
    if (typeof(AUIDataSheetM.prototype._UpdateDatasetDownRow) != "undefined"){
    	var rowNum =  (this.multilineHelper != null ? this.multilineHelper.getLogicalRowNum(sheetRowNum) : sheetRowNum);
    	
    	var availableRowNum = this.getAvailableRowNum(rowNum);
    	if (availableRowNum > 0){
        	this._UpdateDatasetDownRow(availableRowNum);
    	}
    }
    
    this.setCurrentRow(this.currentRow + 1);
    
    return;
};

// 시트 전페이지를 초기화 한다
AUIDataSheetM.prototype.clear = function(){
	if(this.fillKeyField) return;
	// 데이터 클리어
	this.currentRow = 1;
	this.exoRowClear();
	// AUIGrid 지우고 다시 생성
	AUIGrid.destroy(this.AUIcontrolId);
	this.create(this.AUIcontrolId);
	
	this.maxRows = 0;
	this._clicked_row_id = "";
	
	// dataset clear 기능 
    if (typeof(AUIDataSheetM.prototype._UpdateDatasetClear) != "undefined"){
    	this._UpdateDatasetClear();
    }
	
    //passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// clear 이벤트를 호출하고 거기서는 연결된 객체의 시퀀스를 1로한다
		if (this.hasClearEvent) this.fncClearEvent();
	}
    
    return;
};

// 가져오기 실행전 클리어
AUIDataSheetM.prototype.AUIClear = function(){
	// 데이터 클리어
	this.currentRow = 1;
	this.exoRowClear();
	// AUIGrid 지우고 다시 생성
	AUIGrid.destroy(this.AUIcontrolId);
	this.create(this.AUIcontrolId);
	
	this.maxRows = 0;
	this._clicked_row_id = "";
	
	// dataset 현재줄 아래로 이동 기능 
    if (typeof(AUIDataSheetM.prototype._UpdateDatasetClear) != "undefined"){
    	this._UpdateDatasetClear();
    }
	
	return;
};


AUIDataSheetM.prototype.clearRow = function(pRowNum){
    // functionname : [AUIDataSheetM.clearRow]
	AUIGrid.refreshRows(this.AUIcontrolId, [{}], "my-flash-style", 200); 
	
    return;
};

AUIDataSheetM.prototype.clearCurrentSeq = function(){
    // functionname : [AUIDataSheetM.clearCurrentSeq]
    this.clearRow(this.currentRow);
    return;
};

AUIDataSheetM.prototype.cellChange = function(wRowNum, wColNum){
	// 선택한 줄 데이터 로우 생성
	var arrData = this.linkedObjects;
	var dataLen = arrData.length;
	
	if(dataLen > 0) {
		// 화면 체우기 키가 연결된 객체가 있을때는 체인지 이벤트만 호출
		if(this.fillKeyField){
			this.setCurrentRow(wRowNum);
			//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
			if( !this.passEvent ){
				if(this.hasChangeEvent) this.fncChangeEvent(wRowNum);
			}
			return;
		}
		
		var dataloaded = objectManager.dataloaded;
		objectManager.dataloaded = false; // 클릭할때 업데이트 구분이 U로 들어가지 않게 하기위해
		this.notSetValue = true; // 클릭할때는 setValue 함수를 타지 않게 한다.
		
		// 해당 인덱스의 객체가 없을때 생성
		if(this.rows[wRowNum] == null || this.rows[wRowNum] == undefined) {
			// 객체의 체인지이벤트를 막고 데이터를 추가한다.
			for(var i = 0; i < dataLen;i++){
				arrData[i].hasAddRecordEvent = false;
			}
			
			this.rows[wRowNum] = new EXORow();
			//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
			if( !this.passEvent ){
				if(this.hasAddRowDataEvent) this.fncAddRowDataEvent(wRowNum);
			}
			
			for(var i = 0; i < dataLen;i++){
				this.setCurrentRow(wRowNum); // onSeqChange가 일어나야 디폴트값이 들어간다.
				arrData[i].seq = this.rows[wRowNum].objectSeq; // 조회후 바로 첫줄을 클릭할때 currentRow가 1이라 데이터seq가 안바뀜
				arrData[i].hasAddRecordEvent = true;
				//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
				if( !this.passEvent ){
					if (arrData[i].hasAddRecordEvent) arrData[i].fncAddRecordEvent(); // 지금은 change 이벤트가 일어나지 않기 때문에 강제로 addRecordEvent를 호출해준다.
				}
			}
		}
		
		this.setCurrentRow(wRowNum);
		
		if(arrData[0].recordset[this.rows[wRowNum].objectSeq].updateGu != "X"){
			//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
			if( !this.passEvent ){
    			if(this.sheetType == SHEETTYPE_LISTSHEET){ // 리스트 시트는 change 이벤트가 없다.
    				if(this.hasClickEvent) this.fncClickEvent(wRowNum, wColNum);
    			}else{
    				if(this.hasChangeEvent) this.fncChangeEvent(wRowNum, wColNum);
    			}
    		}
		}
		
		objectManager.dataloaded = dataloaded;
		this.notSetValue = false;
	}
	
	return;
};

AUIDataSheetM.prototype.click = function(wRowNum, wColNum){
    // functionname : [AUIDataSheetM.click]
	this.setCurrentRow(wRowNum);
	this.setCurrentCol(wColNum);
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
	    // 사용자 코딩 추가영역을 호출한다
	    if (this.hasClickEvent) {
	        var wResult = this.fncClickEvent(wRowNum, wColNum);
	        if (typeof(wResult)=="boolean" && !wResult) {
	            return false;
	        }            
	    }
	}
	
    return;
};

AUIDataSheetM.prototype.updateSeqFieldOfLinkedObject = function(){
    // functionname : [AUIDataSheetM.updateSeqFieldOfLinkedObject]

	var newSeq = 1;
	for (var wRowNum = 1; wRowNum < this.rows.length; wRowNum++){
		var wRow = this.rows[wRowNum];
		var wObjectSeq = wRow.objectSeq;
		
    	for (var wObjectNum = 0; wObjectNum < this.linkedObjects.length; wObjectNum++){
    		var wObject = this.linkedObjects[wObjectNum];
    		wObject.updateSeqField(wObjectSeq, newSeq);
    	}
    	
    	newSeq++;
	}
	
	return;
};

// 시트 객체 시퀀스 재정렬
AUIDataSheetM.prototype.updateObjectSeq = function(){
	
	var sheetRows = this.rows;
	var rowLength = sheetRows.length;
	
	for (var wRowNum = 1; wRowNum < rowLength; wRowNum++){
		sheetRows.objectSeq = wRowNum;
	}
};

AUIDataSheetM.prototype.getRowNumOfObjectSeq = function(seq){
    // functionname : [AUIDataSheetM.getRowNumOfObjectSeq]

	var wReturn = 1;
	for (var wRowNum = 1; wRowNum < this.rows.length; wRowNum++){
		var wRow = this.rows[wRowNum];
		if(wRow == undefined) continue;
		if (seq == wRow.objectSeq) {
			wReturn = wRowNum; break; 
		}
	}
	
	return wReturn;
};

//엑셀 또는 배열데이터 업로드
function setExcelData(jsonArrayObject, message, commandName, frameName, sheetName){
	// 오류 메시지 먼저 파악 
	if (jsonArrayObject == null){
       alert(message);
		this.errInfo = message;
		return;
	}
	sheetNameToPaste = sheetName;
	controls[sheetNameToPaste].setArrayData(jsonArrayObject, "excel");

	var wControl = controls[commandName];
	
	uploadControls[frameName].clearInfo();
	uploadControls[frameName] = null;
	wControl.uploadFrame = null;
	
	wControl.uploadFrame = uploadControls[frameName] = new IFrame_UploadXL_Command(frameName, commandName, sheetName);
	
	alert(getText("message_AUIDataSheetM_018", "총 {0}건의 데이터를 붙여 넣었습니다.", [jsonArrayObject.data.length]));

	return;
};

AUIDataSheetM.prototype.getDataForExcel = function(){
    // functionname : [AUIDataSheetM.getDataForExcel]

    var arrFromStrings = [",", ":", ";", "&", "%", "?"];
    var arrToStrings   = ["<COMMA>", "<COLON>", "<SEMICOLON>", "<AMP>", "<PERCENT>", "<QUESTION>"];
	
    var generationInfo = new xlGenerationInfo();
	generationInfo.colsNum = this.headCols; // Column Header's Depth
	generationInfo.rowsNum = this.headRows; // Row Header's Depth
	
	generationInfo.rowsColors = "";
	
	/*
	 * var found = false;
     * var selectorText = ".colhead";
     *
	 * for (var cssSheetIndex = 0; cssSheetIndex <
	 * document.styleSheets.length; cssSheetIndex++){ var
	 * cssSheet=document.styleSheets[cssSheetIndex]; var cssRules =
	 * (cssSheet.cssRules? cssSheet.cssRules: cssSheet.rules); for (var
	 * cssRulesIndex = 0; cssRulesIndex < cssRules.length; cssRulesIndex++){
	 * var cssRule = cssRules[cssRulesIndex];
	 * 
	 * if(cssRule.selectorText.toLowerCase() == selectorText){ var
	 * colorString = "" + cssRule.style.backgroundColor; if
	 * (colorString.substring(0,1)=="#"){ colorString =
	 * colorString.substring(1); } else if
	 * (colorString.substring(0,4)=="rgb("){ colorString =
	 * colorString.substring(4, colorString.length - 1); var arrStrColors =
	 * colorString.split(","); var redString =
	 * parseInt(arrStrColors[0].trim(), 10).toString(16); var greenString =
	 * parseInt(arrStrColors[1].trim(), 10).toString(16); var blueString =
	 * parseInt(arrStrColors[2].trim(), 10).toString(16);
	 * 
	 * redString = (redString.length == 1 ? "0" : "") + redString;
	 * greenString = (greenString.length == 1 ? "0" : "") + greenString;
	 * blueString = (blueString.length == 1 ? "0" : "") + blueString;
	 * 
	 * colorString = "" + redString + greenString + blueString; }
	 * 
	 * generationInfo.rowsColors = colorString; found = true; break; }
	 *  } if (found) break; }
	 */

	var wStrColsWidths = this.tagObject.getAttribute("cellsize") || "";
	var wColsWidths = wStrColsWidths.split(";"); wStrColsWidths = "";
	for (var i = 0; i < wColsWidths.length; i++){
		if (wColsWidths[i].trim().length == 0) continue;
		var colWidth = Math.ceil(parseFloat(1 * wColsWidths[i]) / 7,5);
		wStrColsWidths += (i == 0 ? "" : "\t") + colWidth;
	}
	
	generationInfo.colsWidth = wStrColsWidths;
	
	generationInfo.data = "";
	

	// 칼럼해더정보 넘기기
	for (var rowNum = 0; rowNum < this.headRows; rowNum++){
		var wRow = this.dataTable.tBodies[0].rows[rowNum];
		for (var colNum = 1; colNum < wRow.cells.length; colNum++){
			generationInfo.data += (colNum == 0 ? "" : "\t") + escapeCharacter(wRow.cells[colNum].innerHTML,arrFromStrings, arrToStrings);
		}
		//generationInfo.data += ":\r\n";
		generationInfo.data += "<<%ENTER%>>";
	}
	
	// 데이터정보 넘기기
	for (var rowNum = 1; rowNum <= this.maxRows; rowNum++){
		var wHardRow  = this.rowNumOf(rowNum, 1, CONV_LOGICAL_HARD);
		var wRow = this.dataTable.tBodies[0].rows[wHardRow];
		for (var colNum = 0; colNum < this.headCols; colNum++){
			generationInfo.data += (colNum == 0 ? "" : "\t") + escapeCharacter(wRow.cells[colNum].innerHTML,arrFromStrings, arrToStrings);
		}
		
		for (var colNum = 1; colNum <= this.maxCols; colNum++){
			generationInfo.data += "\t" + escapeCharacter(this.rows[rowNum].cells[colNum].value,arrFromStrings, arrToStrings);
		}
		if (generationInfo.data.endsWith("\t")) generationInfo.data += " ";
		//generationInfo.data += (rowNum < this.maxRows ? ":\r\n" : "");
		generationInfo.data += (rowNum < this.maxRows ? "<<%ENTER%>>" : "");
	}
	return generationInfo;
};

// Logical 아닌 시트 칼럼번호를 인수로 받는다.
AUIDataSheetM.prototype.hideColumn = function(colNum){
	
//	var dataField = "f" + colNum;
	//2016-05-02(차중훈) 수정
	var dataField = "";
	//열번호 <-> dataField 변환
	dataField = AUIGrid.getDataFieldByColumnIndex(this.AUIcontrolId, colNum - 1);
	//dataField를 정상적으로 변환한 경우 열 숨기기 동작
	if(typeof dataField != "undefiend" && typeof dataField == "string" && dataField != null && dataField != ""){
		AUIGrid.hideColumnByDataField(this.AUIcontrolId, dataField);
	}
	else{
		return false;
	}
	
	// 염 숨김 : true / 에러 : false
	return true;
	//2016-05-02(차중훈) 수정
};

//Logical 아닌 시트 칼럼번호를 인수로 받는다.
AUIDataSheetM.prototype.showHiddenColumn = function(colNum){
	
//	var dataField = "f" + colNum;
	//2016-05-02(차중훈) 수정
	var dataField = "";
	//열번호 <-> dataField 변환
	dataField = AUIGrid.getDataFieldByColumnIndex(this.AUIcontrolId, colNum - 1);
	//dataField를 정상적으로 변환한 경우 열 보이기 동작
	if(typeof dataField != "undefiend" && typeof dataField == "string" && dataField != null && dataField != ""){
		AUIGrid.showColumnByDataField(this.AUIcontrolId, dataField);
	}
	else{
		return false;
	}
	
	// 염 보이기 : true / 에러 : false
	return true;
	//2016-05-02(차중훈) 수정
};

AUIDataSheetM.prototype.setArrayData = function(jsonArrayObject, type){
	
	var jsonData = "[";
	
	var startRow = jsonArrayObject.row;
	var startCol = jsonArrayObject.col;
	var columnOrder = jsonArrayObject.columnOrder;
	var data = jsonArrayObject.data;
	
	var dataLen = data.length;
	
	for(var i=startRow - 1; i<dataLen; i++){
		jsonData += "{";
		for(var col=1; col<=this.maxCols; col++){
			var column = columnOrder[col];
			var excelData = "";
			if(!(column == undefined || column == null || column < 0)){
				excelData = data[i][column - 1];
			}
			
			jsonData += "f" + col + ':"' + excelData + '"' + (col<this.maxCols? ",": "");
		}
		jsonData += "}" + (i+1<dataLen? ",": "");
	}
	
	jsonData += "]";
	
	this.clear();
	
	//AUIGrid.setGridData(this.AUIcontrolId, eval(jsonData));
	this.setData( eval(jsonData) );
	
	if (this.multilineHelper != null){
		this.maxRows = AUIGrid.getGridData(this.AUIcontrolId).length / this.rowsPerDataRow;
        this.multilineHelper.resetRowNum();
	} else {
		this.maxRows = AUIGrid.getGridData(this.AUIcontrolId).length;
	}
	
	return;
};

/*
*   2016-02-16 추가(차중훈)
*/
// 인수로 Logical 칼럼번호를 받는다. 반환도 Logical
AUIDataSheetM.prototype.getRowNumByValue = function(colNum, value){
	var resultRowNum = -1;

	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		//현재 시트의 열 범위 내 아님, 숫자 아님
		return resultRowNum;
	}
	//배열인지 체크
	var isArray = (value instanceof Array);
	//행번호를 가져옴
	
	var wShtColNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetColNum(colNum) : colNum);
	var dataField = AUIGrid.getDataFieldByColumnIndex(this.AUIcontrolId, wShtColNum - 1);
	var AUIRowNum = AUIGrid.getRowIndexesByValue(this.AUIcontrolId, dataField, value);
	//결과 정리
	if(AUIRowNum.length <= 0){
		return resultRowNum;
	}
	if( !isArray ){
		//배열 아닌 경우 : 행 번호 리턴(Number)
		var wShtRowNum = (AUIRowNum[0] * 1) + 1;
		resultRowNum = (this.multilineHelper != null ? this.multilineHelper.getLogicalRowNum(wShtRowNum) : wShtRowNum);;
	}
	else{
		//배열인 경우 : {"값":"행번호", ...} 형식으로 리턴(JSON)
		var resJson = "{";
		for(var i = 0; i < AUIRowNum.length; i++){
			var wShtRowNum = (AUIRowNum[i] * 1) + 1;
			var logicalRowNum = (this.multilineHelper != null ? this.multilineHelper.getLogicalRowNum(wShtRowNum) : wShtRowNum);;

			resJson += ('"' + value[i] + '":"' + logicalRowNum + '"') + ((i + 1 < AUIRowNum.length) ? "," : "");
		}
		resJson += "}";
		resultRowNum = eval( "(" + resJson + ")" );
	}
	//결과 리턴
	return resultRowNum;
};

AUIDataSheetM.prototype.moveTo = function(rowNum, colNum, isShtControlSet){
	var rownum = 0;
	var colnum = 0;
	var oldRownum = -1;
	var oldColnum = -1;
	
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		//현재 시트의 행 범위 내 아님, 숫자 아님
		return false;
	}
	
	colNum = (typeof colNum == "undefined" ? 1 : (isNaN(colNum) ? 1 : colNum));
	oldRownum = this.currentRow;
	oldColnum = this.currentCol;
	
	var wRowNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetRowNum(rowNum) : rowNum);
	var wColNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetColNum(colNum) : colNum);
	
	if(colNum > this.maxCols || colNum <= 0){
		//현재 시트의 열 범위 내 아님
		return false;
	}
	
	//현재 셀이므로 셀 이동은 안하고 스크롤 위치만 이동
	if(rowNum == oldRownum && colNum == oldColnum){
		if( !isShtControlSet ){
			return true;			
		}
	}
	//입력한 행 선택 후 스크롤 위치 이동
	else{
		AUIGrid.setSelectionByIndex(this.AUIcontrolId, wRowNum - 1, wColNum - 1);
		
		//셀 이동 후 현재 행, 열 번호 변경
		if(rowNum != oldRownum){
			//행 번호 변동이 있으면 행 번호 변경
			this.setCurrentRow(rowNum);
		}
		if(colNum != oldColnum){
			//열 번호 변동이 있으면 열 번호 변경
			this.setCurrentCol(colNum);
		}
	}
	
	//입력한 행에 때라 수직 스크롤 이동
	AUIGrid.setRowPosition(this.AUIcontrolId, wRowNum - 1);
	//입력한 열에 따라 수평스크롤 이동
	AUIGrid.setHScrollPosition(this.AUIcontrolId, wColNum - 1);
	
	//입력 활성화 체크
	if(isShtControlSet){
		this.shtControlSet(rowNum, colNum);
	}
	
	return true;
};

AUIDataSheetM.prototype.moveToRow = function(rowNum){
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		//현재 시트의 행 범위 내 아님, 숫자 아님
		return false;
	}
	
	return this.moveTo(rowNum);
};

AUIDataSheetM.prototype.selectRowByRowNum = function(rowNum){	
	return this.moveToRow(rowNum);
};

// Logical ColNum 을 받는다.
AUIDataSheetM.prototype.countA = function(colNum, btrim){
	var resultCount = -1;
	var istrim = btrim ? true : false;
	
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		//현재 시트의 열 범위 내 아님, 숫자 아님
		return resultRowNum;
	}
	
	if (this.multilineHelper != null){
		var jsonPos = this.multilineHelper.getPosition(1, colNum);
	    var wRowPos = jsonPos.sheetRow;
	    var wShtColNum = jsonPos.sheetCol;
		
		//해당 열번호의 열 목록을 배열로 가져옴
		var dataField = "f" + wShtColNum;
		var colList = this.getColumnValue(colNum); 
		//빈값이 아닌 배열의 갯수를 구함
		resultCount = 0;
		var data = null;
		for(var i = 0; i < colList.length; i++){
			if ((i + 1) % this.rowsPerDataRow != wRowPos % this.rowsPerDataRow) continue;
			data = colList[i];
			if( ((istrim) ? (data + "").trim() : data + "").length > 0 ) resultCount++;
		}
		
	} else {
		//해당 열번호의 열 목록을 배열로 가져옴
		var dataField = "f" + colNum;
		var colList = this.getColumnValue(colNum); 
		//빈값이 아닌 배열의 갯수를 구함
		resultCount = 0;
		var data = null;
		for(var i = 0; i < colList.length; i++){
			data = colList[i];
			if( ((istrim) ? (data + "").trim() : data + "").length > 0 ) resultCount++;
		}
	}
	return resultCount;
};

//Logical ColNum 을 받는다.
AUIDataSheetM.prototype.countBlank = function(colNum, btrim){
	var resultCount = -1;
	var istrim = btrim ? true : false;
	
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		//현재 시트의 열 범위 내 아님, 숫자 아님
		return resultRowNum;
	}

	if (this.multilineHelper != null){
		var jsonPos = this.multilineHelper.getPosition(1, colNum);
	    var wRowPos = jsonPos.sheetRow;
	    var wShtColNum = jsonPos.sheetCol;
		
		//해당 열번호의 열 목록을 배열로 가져옴
		var dataField = "f" + wShtColNum;
		var colList = this.getColumnValue(colNum); 
		//빈값이 아닌 배열의 갯수를 구함
		resultCount = 0;
		var data = null;
		for(var i = 0; i < colList.length; i++){
			if ((i + 1) % this.rowsPerDataRow != wRowPos % this.rowsPerDataRow) continue;
			data = colList[i];
			if( ((istrim) ? (data + "").trim() : data + "").length == 0 ) resultCount++;
		}
		
	} else {
		//해당 열번호의 열 목록을 배열로 가져옴
		var dataField = "f" + wShtColNum;
		var colList = this.getColumnValue(colNum);
		//빈값인 배열의 갯수를 구함
		resultCount = 0;
		var data = null;
		for(var i = 0; i < colList.length; i++){
			data = colList[i];
			if( ((istrim) ? (data + "").trim() : data + "").length == 0 ) resultCount++;
		}		
	}
	
	return resultCount;
};

//Logical ColNum 을 받는다.
AUIDataSheetM.prototype.countIF = function(colNum, condition, btrim){
	var resultCount = -1;
	var istrim = btrim ? true : false;
	
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		//현재 시트의 열 범위 내 아님, 숫자 아님
		return resultRowNum;
	}

	if (this.multilineHelper != null){
		var jsonPos = this.multilineHelper.getPosition(1, colNum);
	    var wRowPos = jsonPos.sheetRow;
	    var wShtColNum = jsonPos.sheetCol;
		
		//해당 열번호의 열 목록을 배열로 가져옴
		var dataField = "f" + wShtColNum;
		var colList = this.getColumnValue(colNum); 
		//빈값이 아닌 배열의 갯수를 구함
		resultCount = 0;
		var data = null;
		for(var i = 0; i < colList.length; i++){
			if ((i + 1) % this.rowsPerDataRow != wRowPos % this.rowsPerDataRow) continue;
			data = colList[i];
			if( eval(((istrim) ? (data + "").trim() : data + "") + condition) ) resultCount++;
		}
		
	} else {
		//해당 열번호의 열 목록을 배열로 가져옴
		var dataField = "f" + colNum;
		var colList = this.getColumnValue(colNum);
		//빈값인 배열의 갯수를 구함
		resultCount = 0;
		var data = null;
		for(var i = 0; i < colList.length; i++){
			data = colList[i];
			if( eval(((istrim) ? (data + "").trim() : data + "") + condition) ) resultCount++;
		}
	}
	
	return resultCount;
};

AUIDataSheetM.prototype.showNoDataMessage = function(isShowNoDataMsg, noDataMessage){
	if(isShowNoDataMsg != true && isShowNoDataMsg != false){
		return false;
	}
	
	try{
		//NO-DATA 이미지 보이기 여부
		AUIGrid.setProperty(this.AUIcontrolId, "showAutoNoDataMessage", isShowNoDataMsg);
		//NO-DATA 이미지 보이고 NO-DATA 메세지 사용자가 입력한 경우
		if(isShowNoDataMsg && noDataMessage && (noDataMessage + "").trim().length > 0){
			AUIGrid.setProperty(this.AUIcontrolId, "noDataMessage", noDataMessage);
		}

		AUIGrid.refresh(this.AUIcontrolId);
	}
	catch(err){
		return false;
	}
	
	return true;
};
/*
*   2016-02-16 추가(차중훈)
*/

AUIDataSheetM.prototype.clearFilterByColNum = function(colNum){
	var dataField = "f" + colNum;
	
	try{
		AUIGrid.clearFilter(this.AUIcontrolId, dataField);
	}
	catch(e){
		return false;
	}
	
	return true;
};

AUIDataSheetM.prototype.clearFilterAllColNum = function(){
	try{
		AUIGrid.clearFilterAll(this.AUIcontrolId);
	}
	catch(e){
		return false;
	}
	
	return true;
};

AUIDataSheetM.prototype.setFilterToColumnByColNum = function(colNum, expression, customFucntion){
	//예외처리
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		//현재 시트의 열 범위 내 아님, 숫자 아님
		return false;
	}
	if(!customFucntion && (expression + "").trim().length <= 0){
		//사용자 정의 함수도 없고 비교 연산식도 없는 경우
		return false;
	}
	try{
		//데이터필드 생성
		var dataField = "f" + colNum;
		//default function :e-x-p-ression식으로 비교연산
		var defaultFunc = function(value, expression){
			return eval( ("\"" + (value + "").replace(/[\"\']/g, "\"") + "\"") + expression );
		};
		//필터적용함수 체크 : customFucntion을 입력하면 customFucntion를 적용
		var applyFilterFunc = (customFucntion) ? customFucntion : defaultFunc;
		//시트 필터 적용
		AUIGrid.setFilter(
				this.AUIcontrolId, 
				dataField, 
				function (dataField, value, item){
					return applyFilterFunc(value, expression);
				}
		);		
	}
	catch(err){
		return false;
	}
	
	return true;
};
/*
*   2016-02-18 추가(차중훈)
*/

/*
 * 	2016-02-23 추가(차중훈)
 */
AUIDataSheetM.prototype.isEmptyRow = function(rowNum){
	//비어있지 않음 : true / 비어있음 : false / 행이 존재하지 않음 : undefined
	var wReturn = true;
	
	//파라메터로 받은 행의 데이터를 가져옴
	var wShtRowNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetRowNum(rowNum) : rowNum);
	var rowItem = AUIGrid.getItemByRowIndex(this.AUIcontrolId, wShtRowNum - 1);
	if(rowItem == null){
		//행이 없으므로 undefined 리턴
		return false;
	}
	
	//연결된 객체가 있는 경우
	//시트와 연결된 객체의 상태플래그를 기준으로 빈 행인지 비교
	if(this.linkedObjects.length > 0){
		//객체 연결된 상태의 경우 기존 DataSheet 분석 후 개발
		return wReturn;
	}
	
	//연결된 객체가 없는 경우
	//그리드 각 컬럼의 데이터 타입을 비교하여 빈값인지 비교
	var columnLayoutList = (typeof AUIGrid.getColumnInfoList == "function" ? 
			                    AUIGrid.getColumnInfoList(this.AUIcontrolId) :
			                    AUIGrid.getColumnLayout(this.AUIcontrolId));
	var columnLayout = null;
	var cellType = null;
	var cellData = null;
	for(var i = 0; i < columnLayoutList.length; i++){
		//컬럼의 정보와 셀의 데이터를 저장
		columnLayout = columnLayoutList[i];
		cellType = columnLayout.dataType;
		cellData = rowItem[columnLayout.dataField];
		//각 셀의 값이 컬럼의 데이터타입에 맞는 빈 값인지 비교
		wReturn = wReturn && (
			/*문자열*/	(cellType == "string" && (cellData + "").length == 0) ||
			/*날짜*/		(cellType == "date" && (cellData + "").length == 0) ||
			/*실수,정수*/	(cellType == "numeric" && (cellData + "" == "0" || cellData + "" == "0.0" || cellData + "" == "")) ||
			/*체크박스*/	(cellType == "checkbox" && (cellData + "").length == 0) ||
			/*콤보박스*/	(cellType == "combobox" && (cellData + "").length == 0) ||
			/*시간*/		(cellType == "time" && (cellData + "").length == 0) );
	}
	
	return wReturn;
};

// 2016-03-19 : 함수 수정 / 콘트롤간 이동 함수에서 클릭된 행이 있는지 체크
AUIDataSheetM.prototype._getClickedRowItem = function(){
	return AUIGrid.getItemByRowId(this.AUIcontrolId, this._clicked_row_id);
};

// 2016-03-29 : 함수 복구 / 콘트롤간 이동에서 기존에 사용한 함수
AUIDataSheetM.prototype.getSelectedCellPostion = function(){
	return this._getClickedRowItem();
};


// 2016-03-19 : 함수 사용 안함 -> 2016-04-18 : 함수 복구 및 수정 / Mi->EM 변환시 사용한 함수
AUIDataSheetM.prototype.getSelectedRowNum = function(){
	return this.currentRow;
};
AUIDataSheetM.prototype.getSelectedColNum = function(){
	return this.currentCol;
};


/*
 * 	2016-02-23 추가(차중훈)
 */

//삭제된 줄을 뺀 줄번호 [ 1부터 시작한다. ]
AUIDataSheetM.prototype.getAvailableRowNum = function(rowNum){
    if (rowNum == undefined){
    	alert(getText("message_AUIDataSheetM_019", "getAvailableRowNum(줄번호)의 형태로 사용하세요."));
    	return -1;
    }
    
    var cnt = 0;
    var array_IUDN = this.getRemoveItems();
    if (array_IUDN.length == 0) {
    	return rowNum;
    }

	var sheetRowNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetRowNum(rowNum) : rowNum);
	    for (var nRowNum = 1; nRowNum < sheetRowNum; nRowNum++){
        var data = AUIGrid.getItemByRowIndex(this.AUIcontrolId, nRowNum -1);
        if(data == undefined || data == null) continue;
        var rowId = data._$uid;
        
    	for(var i=0; i < array_IUDN.length; i++){
    		if(array_IUDN[i]._$uid == rowId) cnt++;
    	}
    }
    
    return this.multilineHelper.getLogicalRowNum(sheetRowNum- cnt); 

};

// AUISheet에 보이는 줄번호 [ 1부터 시작한다. ]
AUIDataSheetM.prototype.getLookingRowNum = function(varRow){
    if (varRow == undefined){
    	alert(getText("message_AUIDataSheetM_020", "getAvailableRowNum(줄번호) 또는 getAvailableRowNum(\"줄ID\")의 형태로 사용하세요."));
    	return -1;
    }

    var rowNum = -1;
    // 문자로 받은 경우 처리
	if (typeof(varRow) == "string" ){
		var uid = varRow;
		var maxShtRows = AUIGrid.getGridData(this.AUIcontrolId).length;
		for (var nRow=1; nRow <= maxShtRows; nRow++){
			if (uid == AUIGrid.getItemByRowIndex(this.AUIcontrolId, nRow - 1)._$uid) {
	            rowNum =  (this.multilineHelper != null ? this.multilineHelper.getLogicalRowNum(nRow) : nRow);
				break;
			}
		}
	    return rowNum;
	}
    
	// 숫자로 받은 경우 처리
	rowNum = varRow;
    if (!getControlById(this.controlId).softRemoveRowMode){
    	return rowNum;
    }
    
    var rsltRowNum = 0;
    var cmprRowNum = 0;
    
    var array_IUDN = this.getRemoveItems();
    if (array_IUDN.length == 0) {
    	return rowNum;
    }
    
	var sheetRowNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetRowNum(rowNum) : rowNum);
	var maxShtRows = AUIGrid.getGridData(this.AUIcontrolId).length;
    for (var nRowNum = 1; nRowNum <= maxShtRows ; nRowNum++){
    	rsltRowNum++;
        var data = AUIGrid.getItemByRowIndex(this.AUIcontrolId, nRowNum - 1);
        if(data == undefined || data == null) continue;
        var rowId = data._$uid;
        
        var found = false;
    	for(var i=0; i < array_IUDN.length; i++){
    		if(array_IUDN[i]._$uid == rowId) {
    			found = true; break;
    		}
    	}
    	if (!found) cmprRowNum++;
    	if (sheetRowNum == cmprRowNum) break;
    }
    
    return this.getLogicalRowNum(rsltRowNum);
};

AUIDataSheetM.prototype.isAvailableRowNum = function(rowNum){
    if (rowNum == undefined){
    	alert(getText("message_AUIDataSheetM_021", "'isAvailableRowNum(줄번호)'의 형태로 사용하세요."));
    	return false;
    }
    if (!getControlById(this.controlId).softRemoveRowMode){
    	return true;
    }
     
    var deleted = false;
	var sheetRowNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetRowNum(rowNum) : rowNum);
    var data = AUIGrid.getItemByRowIndex(this.AUIcontrolId, sheetRowNum-1);
    if(data == undefined || data == null) return false;
    var rowId = data._$uid;
    
	var array_IUDN = this.getRemoveItems();
    if (array_IUDN.length == 0) {
    	return true;
    }
	
	for(var i=0; i<array_IUDN.length; i++){
		if(array_IUDN[i]._$uid == rowId) {
			deleted = true; 
			break;
		}
	}
    
    return !deleted;
};

// AUISheet의 줄번호를 리턴(0부터시작 함을 주의 해서 사용)
AUIDataSheetM.prototype.getIndexOf_$uid = function(uid){
	var nRowToGet = -1;
	var rowCount = AUIGrid.getRowCount(this.AUIcontrolId);
	for (var nRow=0; nRow < rowCount; nRow++){
		if (uid == AUIGrid.getItemByRowIndex(this.AUIcontrolId, nRow)._$uid) {
			nRowToGet = nRow;
			break;
		}
	}
	return nRowToGet;
};

/*
 * 	2016-03-18 추가(차중훈)
 */
AUIDataSheetM.prototype.isAddedRow = function(rowNum){
	var wReturn = false;
	
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		//현재 시트의 행 범위 내 아님, 숫자 아님
		return false;
	}

	if (this.multilineHelper != null){
		var sheetRowNum =  this.multilineHelper.getSheetRowNum(rowNum);
		var AUIRowNum = sheetRowNum - 1;
		for (var i=0; i < this.rowsPerDataRow; i++){
			//행 번호로 행 정보를 가져와 행의 rowId를 찾음
			var _row_uid = (AUIGrid.getItemByRowIndex(this.AUIcontrolId, AUIRowNum + 1))._$uid;
			//행의 rowId로 해당 행이 삭제된 행인지 판별
			wReturn = wReturn || AUIGrid.isAddedById(this.AUIcontrolId, _row_uid);
		}
	} else {
		var sheetRowNum =  rowNum;
		var _row_uid = (AUIGrid.getItemByRowIndex(this.AUIcontrolId, sheetRowNum - 1))._$uid;
		
		wReturn = AUIGrid.isAddedById(this.AUIcontrolId, _row_uid);
	}

	//리턴 : true(추가된 행) / false(추가되지 않은 행)
	return wReturn;
};

AUIDataSheetM.prototype.isEditedRow = function(rowNum){
	var wReturn = false;
	
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		//현재 시트의 행 범위 내 아님, 숫자 아님
		return false;
	}
	
	if (this.multilineHelper != null){
		var sheetRowNum =  this.multilineHelper.getSheetRowNum(rowNum);
		var AUIRowNum = sheetRowNum - 1;
		for (var i=0; i < this.rowsPerDataRow; i++){
			//행 번호로 행 정보를 가져와 행의 rowId를 찾음
			var _row_uid = (AUIGrid.getItemByRowIndex(this.AUIcontrolId, AUIRowNum + 1))._$uid;
			//행의 rowId로 해당 행이 수정된 행인지 판별
			wReturn = wReturn || AUIGrid.isEditedById(this.AUIcontrolId, _row_uid);
		}
	} else {
		//행 번호로 행 정보를 가져와 행의 rowId를 찾음
		var sheetRowNum =  rowNum;
		var _row_uid = (AUIGrid.getItemByRowIndex(this.AUIcontrolId, sheetRowNum - 1))._$uid;
		
		//행의 rowId로 해당 행이 수정된 행인지 판별
		wReturn = AUIGrid.isEditedById(this.AUIcontrolId, _row_uid);
	}
	
	//리턴 : true(수정된 행) / false(수정되지 않은 행)
	return wReturn;
};

AUIDataSheetM.prototype.isDeletedRow = function(rowNum){
	var wReturn = false;
	
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		//현재 시트의 행 범위 내 아님, 숫자 아님
		return false;
	}
    if (!getControlById(this.controlId).softRemoveRowMode){
    	return false;
    }
	
	if (this.multilineHelper != null){
		var sheetRowNum =  this.multilineHelper.getSheetRowNum(rowNum);
		var AUIRowNum = sheetRowNum - 1;
		for (var i=0; i < this.rowsPerDataRow; i++){
			//행 번호로 행 정보를 가져와 행의 rowId를 찾음
			var _row_uid = (AUIGrid.getItemByRowIndex(this.AUIcontrolId, AUIRowNum + 1))._$uid;
			//행의 rowId로 해당 행이 삭제된 행인지 판별
			wReturn = wReturn || AUIGrid.isRemovedById(this.AUIcontrolId, _row_uid);
		}
	} else {
		var sheetRowNum =  rowNum;
		var _row_uid = (AUIGrid.getItemByRowIndex(this.AUIcontrolId, sheetRowNum - 1))._$uid;
		
		wReturn = AUIGrid.isRemovedById(this.AUIcontrolId, _row_uid);
	}
	
	//리턴 : true(삭제된 행) / false(삭제되지 않은 행)
	return wReturn;
};
/*
 * 	2016-03-18 추가(차중훈)
 */

/*
 * 	2016-03-19 추가(차중훈)
 */

//Logical Column 아닌 Sheet Col을 인수로 받음 
AUIDataSheetM.prototype.setColumnProperty = function(colNum, propertyObj){
	var wReturn = true;
	
	//현재 시트의 열 범위 내 아님, 숫자 아님
	var columnCount = AUIGrid.getColumnInfoList(this.AUIcontrolId).length;
	if(isNaN(colNum) || colNum > columnCount || colNum < 1){
		return ;
	}
	//
	if( !propertyObj ){
		return ;
	}
	
	try{
		//열 번호를 컬럼 인덱스로 변환
		var colIndex = AUIGrid.getColumnIndexByDataField(this.AUIcontrolId, "f" + colNum);
		AUIGrid.setColumnProp(this.AUIcontrolId, colIndex, propertyObj);
		//시트 컬럼 정보 변경 완료 : true
		wReturn = true;
	}
	catch(e){
		//시트 컬럼 정보 변경 실패 : false
		wReturn = false;
	}
	
	return wReturn;
};
/*
 * 	2016-03-19 추가(차중훈)
 */

/*
 * 	2016-03-30 추가(차중훈)
 */

AUIDataSheetM.prototype.shtControlSet = function(rowNum, colNum){
	var wReturn = false;
	var oldRownum = -1;
	var oldColnum = -1;
	
	//현재 시트의 행 범위 내 아님, 숫자 아님
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		return wReturn;
	}
	
	//현재 시트의 열 범위 내 아님, 숫자 아님
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		return wReturn;
	}
	
	var wShtRowNum = rowNum;
	var wShtColNum = colNum;

	if (this.multilineHelper != null){
		var jsonPos = this.multilineHelper.getPosition(rowNum, colNum);
		wShtRowNum = jsonPos.sheetRow;
		wShtColNum = jsonPos.sheetCol;
	}
	
	if(this.maxRows * this.rowsPerDataRow == wShtRowNum){
		wShtRowNum = wShtRowNum - 1;
	}
	
	//숨김 열 체크
	if( this.isHiddenColumn(colNum) ){
		return wReturn;
	}
	
	oldRownum = this.currentRow;
	oldColnum = this.currentCol;
	
	//컬럼에 잠금 조건이 있는지 체크
	var columnObject = (AUIGrid.getColumnInfoList(this.AUIcontrolId))[wShtColNum - 1];
	var lockFunction = (columnObject != undefined) ? columnObject.lockFunction : null;
	var isFunction = (typeof(lockFunction) == "function") ? true : false;
	
	//잠금 조건을 입력한 경우, 잠금 조건에 의한 잠금여부 리턴
	var wLockReturn = true;
	if(lockFunction && isFunction){
		//셀 이동 후 현재 행, 열 번호 변경
		if(rowNum != oldRownum){
			//행 번호 변동이 있으면 행 번호 변경
			this.setCurrentRow(rowNum);
		}
		if(colNum != oldColnum){
			//열 번호 변동이 있으면 열 번호 변경
			this.setCurrentCol(colNum);
		}
		
		var jsonPos = this.multilineHelper.getPosition(rowNum, colNum);
	    var sheetRowNum1 = jsonPos.sheetRow;
	    var sheetColNum1 = jsonPos.sheetCol;

		wReturn = lockFunction(sheetRowNum1, sheetColNum1); 
	}
	
	//잠금 여부는 boolean 형으로 리턴되야 하므로 삼항연산으로 true 또는 false로 변환
	wLockReturn = wLockReturn ? true : false;
	
	if(wLockReturn){
		AUIGrid.setSelectionByIndex(this.AUIcontrolId, wShtRowNum - 1, wShtColNum - 1 );
		AUIGrid.openInputer(this.AUIcontrolId);
		wReturn = true;
	}
	
	return wReturn;
};

AUIDataSheetM.prototype.restoreSoftRemoveRow = function(rowNum){
	var wReturn = false;
	var rowIndex = "selectedIndex";
	
	//소프트 행 삭제 모드 true 아님
	if( !this.softRemoveRowMode ){
		return wReturn;
	}
	
	//현재 시트의 행 범위 내 아님, 숫자 아님
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		//행번호를 입력하지 않은 경우 현재 선택된 행을 선택
		if(rowNum != undefined){
			return wReturn;
		}
	}

	//행번호를 입력하지 않은 경우 선택된 행을 복구
	if( rowNum == undefined ){
		AUIGrid.restoreSoftRows(this.AUIcontrolId, "selectedIndex");
		wReturn = true;
	}
	//행번호를 입력한 경우 입혁한 행이 삭제된 행인 경우 복구
	else if( this.isDeletedRow(rowNum) ){
		var sheetRowNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetRowNum(rowNum) : rowNum);

		AUIGrid.restoreSoftRows(this.AUIcontrolId, sheetRowNum - 1);
		wReturn = true;
	}
	
	return wReturn;
};

AUIDataSheetM.prototype.moveToNextCell = function(/*rowNum, colNum, isShtControlSet*/){
	//초기화 : 현재 행, 열번호로 지정
	var rowNum = this.currentRow;
	var colNum = this.currentCol;
	var isShtControlSet = false;
	
	var args = Array.prototype.slice.call(arguments);
	if(args.length == 1){
		if(typeof args[0] == "boolean") isShtControlSet = args[0];
		if(typeof args[0] == "number") rowNum = args[0] * 1;
		if(typeof args[0] == "string") return false;
	}
	else if(args.length == 2){
		if(typeof args[0] != "number" || typeof args[1] != "number") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if(args.length == 3){
		if(typeof args[0] != "number" || typeof args[1] != "number" || typeof args[2] != "boolean") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
		isShtControlSet = args[2];
	}
	
	//시트에 행이 없다면 동작하지 않음
	if(this.maxRows == 0){
		return false;
	}
	
	//현재 열의 다음 셀을 가리킴(검사 시작 위치 지정)
	colNum = colNum + 1;
	
	//가리킨 셀이 이동 가능한 셀인지 검사
	var isFound = false;
	for(var r = rowNum; r <=  this.maxRows; r++){
		//가리킨 셀이 숨김 열이면 한칸 다음 셀을 검사
		for(var c = colNum; c <= this.maxCols; c++){
			if( (!isShtControlSet && !this.isHiddenColumn(c)) || (isShtControlSet && !this.isHiddenColumn(c) && !this.isLockedColumn(r, c)) ){	
				colNum = c;
				rowNum = r;
				isFound = true;
				break;
			}
		}
		//이동 가능한 셀을 찾지 못한 경우 이전 행 마지막 셀을 가리키고 다시 검사
		if( !isFound ){
			colNum = 1;
		}
		//이동 가능한 셀을 찾은 경우 검사 마침
		else{
			break;
		}
	}
	
	//모든 다음 행에서 이동할 셀을 찾지 못함
	if( !isFound ){
		return false;
	}
	
	return this.moveTo(rowNum, colNum, isShtControlSet);
};

AUIDataSheetM.prototype.moveToRightCell = function(/*rowNum, colNum, isShtControlSet*/){
	//초기화 : 현재 행, 열번호로 지정
	var rowNum = this.currentRow;
	var colNum = this.currentCol;
	var isShtControlSet = false;
	
	var args = Array.prototype.slice.call(arguments);
	if(args.length == 1){
		if(typeof args[0] == "boolean") isShtControlSet = args[0];
		if(typeof args[0] == "number") rowNum = args[0] * 1;
		if(typeof args[0] == "string") return false;
	}
	else if(args.length == 2){
		if(typeof args[0] != "number" || typeof args[1] != "number") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if(args.length == 3){
		if(typeof args[0] != "number" || typeof args[1] != "number" || typeof args[2] != "boolean") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
		isShtControlSet = args[2];
	}
	
	//시트에 행이 없다면 동작하지 않음
	if(this.maxRows == 0){
		return false;
	}
	
	//현재 열의 다음 열 중 이동 가능한 셀을 검사
	var isFound = false;
	if(this.maxCols >= colNum + 1){
		//가리킨 셀이 숨김 열이면 한칸 이전 셀을 검사
		for(var c = colNum + 1; c <= this.maxCols; c++){
			if( (!isShtControlSet && !this.isHiddenColumn(c)) || (isShtControlSet && !this.isHiddenColumn(c) && !this.isLockedColumn(rowNum, c)) ){
				colNum = c;
				isFound = true;
				break;
			}
		}	
	}
	
	//마지막 셀인 경우 또는 이동할 셀을 찾지 못한 경우 이동 안 함
	if( !isFound ){
		return false;
	}
	
	return this.moveTo(rowNum, colNum, isShtControlSet);
};

AUIDataSheetM.prototype.moveToFormerCell = function(/*rowNum, colNum, isShtControlSet*/){
	//초기화 : 현재 행, 열번호로 지정
	var rowNum = this.currentRow;
	var colNum = this.currentCol;
	var isShtControlSet = false;
	
	var args = Array.prototype.slice.call(arguments);
	if(args.length == 1){
		if(typeof args[0] == "boolean") isShtControlSet = args[0];
		if(typeof args[0] == "number") rowNum = args[0] * 1;
		if(typeof args[0] == "string") return false;
	}
	else if(args.length == 2){
		if(typeof args[0] != "number" || typeof args[1] != "number") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if(args.length == 3){
		if(typeof args[0] != "number" || typeof args[1] != "number" || typeof args[2] != "boolean") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
		isShtControlSet = args[2];
	}

	//시트에 행이 없다면 동작하지 않음
	if(this.maxRows == 0){
		return false;
	}
	
	//현재 열의 이전 셀을 가리킴(검사 시작 위치 지정)
	colNum = colNum - 1;
	
	//가리킨 셀이 이동 가능한 셀인지 검사
	var isFound = false;
	for(var r = rowNum; r > 0; r--){
		//가리킨 셀이 숨김 열이면 한칸 이전 셀을 검사
		for(var c = colNum; c > 0; c--){
			if( (!isShtControlSet && !this.isHiddenColumn(c)) || (isShtControlSet && !this.isHiddenColumn(c) && !this.isLockedColumn(r, c)) ){
				colNum = c;
				rowNum = r;
				isFound = true;
				break;
			}
		}
		//이동 가능한 셀을 찾지 못한 경우 이전 행 마지막 셀을 가리키고 다시 검사
		if( !isFound ){
			colNum = this.maxCols;
		}
		//이동 가능한 셀을 찾은 경우 검사 마침
		else{
			break;
		}
	}
	
	//모든 이전 행에서 이동할 셀을 찾지 못함
	if( !isFound ){
		return false;
	}
	
	return this.moveTo(rowNum, colNum, isShtControlSet);
};

AUIDataSheetM.prototype.moveToLeftCell = function(/*rowNum, colNum, isShtControlSet*/){
	//초기화 : 현재 행, 열번호로 지정
	var rowNum = this.currentRow;
	var colNum = this.currentCol;
	var isShtControlSet = false;
	
	var args = Array.prototype.slice.call(arguments);
	if(args.length == 1){
		if(typeof args[0] == "boolean") isShtControlSet = args[0];
		if(typeof args[0] == "number") rowNum = args[0] * 1;
		if(typeof args[0] == "string") return false;
	}
	else if(args.length == 2){
		if(typeof args[0] != "number" || typeof args[1] != "number") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if(args.length == 3){
		if(typeof args[0] != "number" || typeof args[1] != "number" || typeof args[2] != "boolean") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
		isShtControlSet = args[2];
	}
	
	//시트에 행이 없다면 동작하지 않음
	if(this.maxRows == 0){ 
		return false;
	}
	
	//현재 열의 이전 열 중 이동 가능한 셀을 검사
	var isFound = false;
	if(0 < colNum - 1){
		//가리킨 셀이 숨김 열이면 한칸 이전 셀을 검사
		for(var c = colNum - 1; c > 0; c--){
			if( (!isShtControlSet && !this.isHiddenColumn(c)) || (isShtControlSet && !this.isHiddenColumn(c) && !this.isLockedColumn(rowNum, c)) ){
				colNum = c;
				isFound = true;
				break;
			}
		}	
	}
	
	//첫번째 셀인 경우 또는 이동할 셀을 찾지 못한 경우 이동 안 함
	if( !isFound ){
		return false;
	}
	
	return this.moveTo(rowNum, colNum, isShtControlSet);
};

AUIDataSheetM.prototype.moveToLowerCell = function(/*rowNum, colNum, isShtControlSet*/){
	//초기화 : 현재 행, 열번호로 지정
	var rowNum = this.currentRow;
	var colNum = this.currentCol;
	var isShtControlSet = false;
	
	var args = Array.prototype.slice.call(arguments);
	if(args.length == 1){
		if(typeof args[0] == "boolean") isShtControlSet = args[0];
		if(typeof args[0] == "number") rowNum = args[0] * 1;
		if(typeof args[0] == "string") return false;
	}
	else if(args.length == 2){
		if(typeof args[0] != "number" || typeof args[1] != "number") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if(args.length == 3){
		if(typeof args[0] != "number" || typeof args[1] != "number" || typeof args[2] != "boolean") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
		isShtControlSet = args[2];
	}
	
	//시트에 행이 없다면 동작하지 않음
	if(this.maxRows == 0){
		return false;
	}
	
	//이동하려는 컬럼이 숨김 열인 경우 이동 안 함
	if( this.isHiddenColumn(colNum) ){	
		return false;
	}
	
	//마지막 행인 경우 해당 열의 마지막 행으로 이동
	rowNum = (this.maxRows < rowNum) ? this.maxRows : rowNum + 1;
	
	//가리킨 셀이 잠김 셀이면 한칸 아래 셀을 검사
	var isFound = false;
	for(var r = rowNum; r <= this.maxRows; r++){
		if( (!isShtControlSet) || (isShtControlSet && !this.isLockedColumn(r, colNum)) ){
			rowNum = r;
			isFound = true;
			break;
		}
	}
	
	//이동할 셀을 찾지 못한 경우 이동 안 함
	if( !isFound ){
		return false;
	}
	
	return this.moveTo(rowNum, colNum, isShtControlSet);
};

AUIDataSheetM.prototype.moveToUpperCell = function(/*rowNum, colNum, isShtControlSet*/){
	//초기화 : 현재 행, 열번호로 지정
	var rowNum = this.currentRow;
	var colNum = this.currentCol;
	var isShtControlSet = false;
	
	var args = Array.prototype.slice.call(arguments);
	if(args.length == 1){
		if(typeof args[0] == "boolean") isShtControlSet = args[0];
		if(typeof args[0] == "number") rowNum = args[0] * 1;
		if(typeof args[0] == "string") return false;
	}
	else if(args.length == 2){
		if(typeof args[0] != "number" || typeof args[1] != "number") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
	}
	else if(args.length == 3){
		if(typeof args[0] != "number" || typeof args[1] != "number" || typeof args[2] != "boolean") return false;
		rowNum = args[0] * 1;
		colNum = args[1] * 1;
		isShtControlSet = args[2];
	}
	
	//시트에 행이 없다면 동작하지 않음
	if(this.maxRows == 0){
		return false;
	}
	
	//이동하려는 컬럼이 숨김 열인 경우 이동 안 함
	if( this.isHiddenColumn(colNum) ){	
		return false;
	}
	
	//첫번째 행인 경우 해당 열의 첫번째 행으로 지정
	rowNum = (1 > rowNum - 1) ? 1 : rowNum - 1;
	
	//가리킨 셀이 잠김 셀이면 한칸 아래 셀을 검사
	var isFound = false;
	for(var r = rowNum; r > 0; r--){
		if( (!isShtControlSet) || (isShtControlSet && !this.isLockedColumn(r, colNum)) ){
			rowNum = r;
			isFound = true;
			break;
		}
	}
	
	//이동할 셀을 찾지 못한 경우 이동 안 함
	if( !isFound ){
		return false;
	}
	
	return this.moveTo(rowNum, colNum, isShtControlSet);
};

AUIDataSheetM.prototype.moveToFirstCell = function(/*rowNum, isShtControlSet*/){
	//초기화 : 현재 행, 열번호로 지정
	var rowNum = this.currentRow;
	var colNum = 1;
	var isShtControlSet = false;

	var args = Array.prototype.slice.call(arguments);
	if(args.length == 1){
		if(typeof args[0] == "boolean") isShtControlSet = args[0];
		if(typeof args[0] == "number") rowNum = args[0] * 1;
		if(typeof args[0] == "string") return false;
	}
	else if(args.length == 2){
		if(typeof args[0] != "number" || typeof args[1] != "boolean") return false;
		rowNum = args[0] * 1;
		isShtControlSet = args[1];
	}
	
	//시트에 행이 없다면 동작하지 않음
	if(this.maxRows == 0){
		return false;
	}
	
	//행 번호가 1보다 작은 경우 첫번째 행으로 지정
	rowNum = (rowNum > 1) ? rowNum : 1;
	
	//행의 이동 가능한 첫번째 셀 검사
	var isFound = false;
	for(var c = 1; c <= this.maxCols; c++){
		if( (!isShtControlSet && !this.isHiddenColumn(c)) || (isShtControlSet && !this.isHiddenColumn(c) && !this.isLockedColumn(rowNum, c)) ){
			colNum = c;
			isFound = true;
			break;
		}
	}
	
	//이동할 셀을 찾지 못한 경우 이동 안 함
	if( !isFound ){
		return false;
	}
	
	return this.moveTo(rowNum, colNum, isShtControlSet);
};

// Logical Column 번호 받음
AUIDataSheetM.prototype.isHiddenColumn = function(colNum){
	var wReturn = false;
	
	//현재 시트의 열 범위 내 아님, 숫자 아님
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		return wReturn;
	}
	
	//컬럼 정보를 가져옴
	var colInfoList = AUIGrid.getColumnInfoList(this.AUIcontrolId);
	//컬럼의 visible 속성이 false인 경우에만 숨김 열
	var wShtColNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetColNum(colNum) : colNum);
	if(colInfoList[wShtColNum - 1].visible == false){
		wReturn = true;
	}
	
	//리턴 : true(숨김 열) / false(숨기지 않은 열)
	return wReturn;
};

// Logical이 아닌 시트 줄번호 열번호를 인수로 받음 
AUIDataSheetM.prototype.isLockedColumn = function(rowNum, colNum){
	var wReturn = true;
	
	//현재 시트의 행 범위 내 아님, 숫자 아님
	if(isNaN(rowNum) || rowNum > this.maxRows || rowNum < 1){
		return false;
	}
	
	//현재 시트의 열 범위 내 아님, 숫자 아님
	if(isNaN(colNum) || colNum > this.maxCols || colNum < 1){
		return wReturn;
	}
	
	//컬럼에 잠금 조건이 있는지 체크
	var wShtColNum =  (this.multilineHelper != null ? this.multilineHelper.getSheetColNum(colNum) : colNum);
	
	var columnObject = (AUIGrid.getColumnInfoList(this.AUIcontrolId))[wShtColNum - 1];
	var lockFunction = (columnObject != undefined) ? columnObject.lockFunction : null;
	var isFunction = (typeof(lockFunction) == "function") ? true : false;
	
	//잠금 조건이 있는 경우, 잠금 조건에 의한 잠금여부 리턴
	if(lockFunction && isFunction){
		var jsonPos = this.multilineHelper.getPosition(rowNum, colNum);
	    var sheetRowNum = jsonPos.sheetRow;
	    var sheetColNum = jsonPos.sheetCol;

		wReturn = lockFunction(sheetRowNum, sheetColNum);
	}

	//잠금 여부는 boolean 형으로 리턴되야 하므로 삼항연산으로 true 또는 false로 변환
	wReturn = !(wReturn ? true : false);
	
	return wReturn;
};
/*
 * 	2016-03-30 추가(차중훈)
 */

/*
 * 	2016-04-07 추가(차중훈)
 */

AUIDataSheetM.prototype.focus = function(){
	AUIGrid.setFocus(this.AUIcontrolId);
}

//컬럼 위치 검색 결과
var FOUND_COLUMN = true;
var NOT_FOUND_COLUMN = false;
//컬럼 타입 오류 정보
var INCORRECT_PROPERTY_VALUE = " is not incorrect";
var UNDEFINED_PROPERTY_NAME = " is not defined";
var UNDEFINED_DATATYPE = "is not defined data type";
var NO_EXIST_COLNUM = "is not exist column number";

AUIDataSheetM.prototype._findColNumByDataField = function(dataField, columnList){
	var resultJson = {found : NOT_FOUND_COLUMN, columnPosition : ""};

	if(typeof dataField == "undefined" || typeof dataField != "string") return resultJson;
	if(!(columnList instanceof Array)) return resultJson;
	if(columnList.length <= 0) return resultJson;
	
	var returnJson = null;
	var children = null;
	var i = 0;
	
	for(i = 0; i < columnList.length; i++){
		if(columnList[i].dataField + "" == dataField + ""){
			resultJson.found = FOUND_COLUMN;
			resultJson.columnPosition = "." + (i + 1);
			return  resultJson;
		}
		
		children = columnList[i].children;
		
		if(children != null && typeof children != "undefined" && children instanceof Array && children.length > 0){
			returnJson = this._findColNumByDataField(dataField, columnList[i].children);
			if(returnJson.found){
				resultJson.found = returnJson.found;
				resultJson.columnPosition = "." + (i + 1) + returnJson.columnPosition;
				return resultJson;
			}
		}
	}
	
	return resultJson;
};

// Logical Column 아닌 Sheet Col을 인수로 받음 
AUIDataSheetM.prototype.setColumnProp = function(colNum, propName, propValue, isClear){
	//현재 시트의 열 범위 내 아님, 숫자 아님
	var columnCount = AUIGrid.getColumnInfoList(this.AUIcontrolId).length;
	
	if( typeof colNum == "number" && (isNaN(colNum) || colNum > columnCount || colNum < 1) ){
		return false;
	}
	//"1.2.3" 형식 아님
	else if( typeof colNum == "string" && !(/^\d+(\.\d+)+$/g).test(colNum + "") && !(/^\d+$/g).test(colNum + "") ){
		return false;
	}
	
	var pValue = null;
	var datatypes = "date,string,numeric,button,combobox,image,checkbox,bar,string";
	var columnLayout = null;
	var findColumn = null;
	
	//파라메터 체크
	try{
		//속성 체크
		switch(propName){
		case "editable" :
		case "sortable" :
		case "visible" :
			if( typeof(propValue) != "boolean" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		case "headerStyle" :
		case "headerText" :
		case "style" :
		case "perfix" :
		case "postfix" :
		case "formatString" :
			if( typeof(propValue) != "string" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		case "width" :
		case "minWidth" :
			var pVal = (propValue + "").replace(/%/, "");
			if( !(/^\d+\.?\d*$/.test(pVal + "")) ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		case "lockFunction" :
			if( typeof(propValue) != "function" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		case "expFunction" :
			if( typeof(propValue) != "function" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			var pValue = function(rowIndex, columnIndex, item, dataField){
				var rowNum = rowIndex + 1;
				var colNum = columnIndex + 1;
				return propValue(rowNum, colNum);
			};
			break;
		case "styleFunction" : 
		case "labelFunction" :
			if( typeof(propValue) != "function" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			var pValue = function(rowIndex, columnIndex, value, headerText, item, dataField){
				var rowNum = rowIndex + 1;
				var colNum = columnIndex + 1;
				return propValue(rowNum, colNum);  // Logical이 아닌 Sheet col
			};
			break;
//		case "dataType" :
//			if(datatypes.indexOf(propValue) < 0) throw propValue + UNDEFINED_DATATYPE;
//			break;
		default :
			throw UNDEFINED_PROPERTY_NAME;
		}
		
		//시트를 클리어 설정 여부
		isClear = (typeof isClear != "undefined" && isClear == true) ? true : false;
		
		//컬럼 체크
		columnLayout = AUIGrid.getColumnLayout(this.AUIcontrolId);
		findColumn = null;
		
		if( !(/^\d+(\.\d+)+$/g).test(colNum + "") && (propName != "headerText" && propName != "headerStyle")){
			var dataField = AUIGrid.getDataFieldByColumnIndex(this.AUIcontrolId, (colNum * 1) - 1);
			findColumn = this._findColNumByDataField(dataField, columnLayout);
			if(findColumn.found == NOT_FOUND_COLUMN) throw colNum + NO_EXIST_COLNUM;
		}
	}
	catch(e){
		return false;
	}
	
	//시트 컬럼 설정
	try{
		var columnIndexes = (findColumn != null ) ? ((findColumn.columnPosition + "").substring(1)).split(".") : (colNum + "").split(".");
		var column = "";
		var columnObject = null;
		
		column = "columnLayout[" + (columnIndexes[0] - 1) + "]";
		for(var i = 1; i < columnIndexes.length; i++){
			column = column + ".children[" + (columnIndexes[i] - 1) + "]";
		}
		
		//시트 컬럼 가져옴.
		columnObject = eval(column);
		if(columnObject == null) return false;
		//속성 값 변경
		columnObject[propName] = pValue;
		//AUIDataSheetM.columnLayout 업데이트
		eval(column + " = columnObject");
		this.columnLayout = columnLayout;

		//headerText 를 변경한 경우 시트를 다시 만들어야함.
		if(propName != "headerText" && propName != "headerStyle"){
			//컬럼 적용
			this.setColumnProperty(colNum, columnObject);
			//시트 refresh
			if(propName != "lockFunction") this.refresh();
			//시트 클리어
			if( isClear ) this.clear();
		}
		else{
			var sheetData = null;
			//시트를 클리어하지 않는다면 시트의 데이터를 백업
			if( !isClear )	sheetData = AUIGrid.getGridData(this.AUIcontrolId);
			//시트 클리어하며 데이터셋도 클리어(시트 클리어하면 시트를 지우고 다시 만듦)
			this.AUIClear();
			//생성한 시트에 데이터 입력
			if( !isClear )	this.setData(sheetData);
		}
	}
	catch(e){
		return false;
	}
	
	return true;
};

// logical 아닌 sheet 열번호 
AUIDataSheetM.prototype.SetColProp = function(colNum, propName, propValue, isClear){
	return this.setColumnProp(colNum, propName, propValue, isClear);
};

AUIDataSheetM.prototype.getColumnProp = function(colNum, propName){
	//현재 시트의 열 범위 내 아님, 숫자 아님
	if( typeof colNum == "number" && (isNaN(colNum) || colNum > this.maxCols || colNum < 1) ){
		return false;
	}
	//"1.2.3" 형식 아님
	else if( typeof colNum == "string" && !(/^\d+(\.\d+)+$/g).test(colNum + "") && !(/^\d+$/g).test(colNum + "") ){
		return false;
	}
	
	var rPropValue = null;
	var columnLayout = null;
	var findColumn = null;
	
	//파라메터 체크
	try{
		//속성 체크
		switch(propName){
		case "editable" :
		case "sortable" :
		case "visible" :
		case "headerText" :
		case "style" :
		case "perfix" :
		case "postfix" :
		case "formatString" :
		case "width" :
		case "minWidth" :
//		case "lockFunction" :
//		case "expFunction" :
//		case "styleFunction" : 
//		case "labelFunction" :
		case "dataType" :
			break;
		default :
			throw UNDEFINED_PROPERTY_NAME;
		}
		
		//컬럼 체크
		columnLayout = AUIGrid.getColumnLayout(this.AUIcontrolId);
		findColumn = null;
		
		if( !(/^\d+(\.\d+)+$/g).test(colNum + "") && propName != "headerText"){
			var dataField = AUIGrid.getDataFieldByColumnIndex(this.AUIcontrolId, (colNum * 1) - 1);
			findColumn = this._findColNumByDataField(dataField, columnLayout);
			if(findColumn.found == NOT_FOUND_COLUMN) throw colNum + NO_EXIST_COLNUM;
		}
	}
	catch(e){
		return ;
	}
	
	//시트 컬럼 설정
	try{
		var columnIndexes = (findColumn != null ) ? ((findColumn.columnPosition + "").substring(1)).split(".") : (colNum + "").split(".");
		var column = "";
		var columnObject = null;
		
		column = "columnLayout[" + (columnIndexes[0] - 1) + "]";
		for(var i = 1; i < columnIndexes.length; i++){
			column = column + ".children[" + (columnIndexes[i] - 1) + "]";
		}
		
		//시트 컬럼 가져옴.
		columnObject = eval(column);
		if(columnObject == null) return ;
		//속성 값 가져옴
		rPropValue = columnObject[propName]
	}
	catch(e){
		return ;
	}
	
	return rPropValue;
};

/*
 * 	2016-04-07 추가(차중훈)
 */

/*
 * 	2016-04-19 추가(차중훈)
 */

AUIDataSheetM.prototype.setZIndex = function(zIndex){
	// functionname : [Control.setZIndex]
	var wReturn = false;
	var oldZIndex = this.zIndex;
	
	try{
		this.zIndex = zIndex;
		this.tagObject.style.zIndex = zIndex;
		wReturn = true;
	}
	catch(err){
		this.zIndex = oldZIndex;
	}
	
	return wReturn;
};

AUIDataSheetM.prototype.setZOrder = function(zOrder){
	// functionname : [Control.setZOrder]
	return this.setZIndex(zOrder);
};

/*
 * 	2016-04-19 추가(차중훈)
 */

/*
 * 	2016-04-26 추가(차중훈)
 */

AUIDataSheetM.prototype.setProperty = function(propName, propValue, isClear){
	var pValue = null;
	
	//파라메터 체크
	try{
		//속성 체크
		switch(propName){
		case "editable" :
		case "editableOnFixedCell" :
		case "enableColumnResize" :
		case "enableMovingColumn" :
		case "enableSorting" :
		case "showHeader" :
		case "useGroupingPanel" :
		case "showAutoNoDataMessage" :
			if( typeof(propValue) != "boolean" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		case "noDataMessage" :
			if( typeof(propValue) != "string" ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		case "rowPosition" :
			if( !(/^\d+\.?\d*$/.test(propValue + "")) ) throw propValue + INCORRECT_PROPERTY_VALUE;
			pValue = propValue;
			break;
		default :
			throw UNDEFINED_PROPERTY_NAME;
		}
		
		//시트를 클리어 설정 여부
		isClear = (typeof isClear != "undefined" && isClear == true) ? true : false;
	}
	catch(e){
		return false;
	}
	
	//시트 설정
	try{
		//시트 객체 설정 적용
		switch(propName){
		case "editable" :
			this.editable = propValue;
			break;
		case "editableOnFixedCell" :
			this.editableOnFixedCell = propValue;
			break;
		case "enableColumnResize" :
			this.enableColumnResize = propValue;
			break;
		case "enableMovingColumn" :
			this.enableMovingColumn = propValue;
			break;
		case "enableSorting" :
			this.enableSorting = propValue;
			break;
		case "showHeader" :
			this.showHeader = propValue;
			break;
		case "useGroupingPanel" :
			this.useGroupingPanel = propValue;
			break;;
		case "showAutoNoDataMessage" :
			this.showAutoNoDataMessage = propValue;
			break;
		case "noDataMessage" :
			this.noDataMessage = propValue;
			break;
		case "rowPosition" :
			this.rowPosition = propValue;
			break;
		}
		//시트 설정 적용
		var prop = {};
		prop[propName] = pValue;
		AUIGrid.setProperty(this.AUIcontrolId, prop);
		AUIGrid.refresh(this.AUIcontrolId);
		//시트 클리어
		if( isClear ) this.clear();
	}
	catch(e){
		return false;
	}
	
	return true;
};

/*
 * 	2016-04-26 추가(차중훈)
 */


function EXORow(){
	this.objectSeq = 1;
    this.hardRowCount = 1; 
    this.hardRowNum = 0;
    this.hardRowNum2 = 0;
    this.cells = [null];  // 데이터가 1번 배열부터 들어간다는 의미
    this.oldNum = 0;      // Sort시 사용된다
    this.hidden = false;  // 줄숨기기시 사용된다
    this.newData = false; // 줄추가된 데이터
    
};

AUIDataSheetM.prototype.setFixedColumnCount = function (cnt) {
//	if(cnt > 8) {
//		alert("현재 고정 칼럼의 최대 개수는 8로 설정되어있습니다.\r\n8이하로 다시 시도해 주십시오.");
//		return;
//	}
	
	// 고정 칼럼을 변경합니다.
	AUIGrid.setFixedColumnCount(this.AUIcontrolId, cnt);
};

/*
var defaultColumn = {
	//텍스트
	string : {
		headerText : "",
		dataField : "f",
		style : "AUIGrid_Align_left",
		editable : true,
		sortable : true,
		dataType : "string",
	},
	//정수형
	string : {
		headerText : "",
		dataField : "f",
		style : "AUIGrid_Align_left",
		editable : true,
		sortable : true,
		dataType : "numeric",
		editRenderer : {
			type : "InputEditRenderer",
    		validator : function(oldValue, newValue, item, dataField, fromClipboard){
				var isIntegerRegx = /^[-|+]?\d+$/; // 문자열의 시작이 -, + 또는 부호가 안 붙거나 숫자로 끝나는지 검사
				var isValid = isIntegerRegx.test(newValue); // 검사결과 정규식 패턴에 맞다면 true, 틀리다면 false 리턴
				return { "validate" : isValid, "message"  : newValue + "은(는) 정수가 아닙니다." };
			}
	    }
	},
	//실수형
	//콤보박스
	combobox : {
		headerText : "",
		dataField : "f",
		style : "AUIGrid_Align_left",
		editable : true,
		sortable : true,
		dataType : "combobox",
	    labelFunction : null,
		editRenderer : {	
			type : "DropDownListRenderer"
	    	, keyField : "value"
	    	, valueField : "text"
	    	, listFunction : null
	    }
	}	
};
*/



AUIDataSheetM.prototype.prepareForMultiLine = function(){
	this.multilineHelper = new MultilineHelper(this);
	// 바인드 정보에 멀티라인 추가
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if (typeof bindInfo == "function") continue;
		
		bindInfo.sheetColNum = this.columns[bindInfo.colIndex].sheetColNum;
		bindInfo.sheetRowNum = this.columns[bindInfo.colIndex].sheetRowNum;
		
	}
	
	// defaultLayoutValue 복사
	var tmpStr = this.defaultLayoutValue.trim();
	if (tmpStr.substring(0,2)== "({"){
		tmpStr = tmpStr.substring(2);
	}
	if (tmpStr.substring(tmpStr.length - 2)== "})"){
		tmpStr = tmpStr.substring(0, tmpStr.length - 2);
	}
	var arrDefaultStr = tmpStr.split(",");
	
	for (var i=0; i < this.rowsPerDataRow; i++){
		jsonStr = "";
		for (var colNum=1; colNum <= this.colsPerDataRow; colNum++){
			var x = i * this.colsPerDataRow + colNum;
			var dataField = "\"" + "f" + x + "\"";
			
			for (var j=0; j < arrDefaultStr.length; j++){
				if (arrDefaultStr[j].trim().startsWith(dataField + ":")){
					jsonStr += (jsonStr.length == 0 ? "" : ", ") + "\"" + "f" + colNum + "\"" + ":" + arrDefaultStr[j].split(":")[1];
					break;
				}
			}
		}
		this.multilineHelper.defaultLayoutValue[i] = "({" + jsonStr + "})";
	}
	
	
	
};

AUIDataSheetM.prototype.addColumn = function(sheetRowNum, sheetColNum, rowSpan, colSpan){
	
    var wColNumToInsert = this.columns.length; 
    this.columns[wColNumToInsert] = new SheetColumn(sheetRowNum, sheetColNum, rowSpan, colSpan);
    this.maxCols = this.columns.length - 1; 
	
};

AUIDataSheetM.prototype.setSelectionMode = function(selectionMode){
	//예외처리
	//파라메터 데이터타입이 올바르지 않음
	if(typeof selectionMode != "string"){
		return false;
	}
	//파라메터 설정값이 올바르지 않음
	else if( selectionMode != "none" 
		&& selectionMode != "singleCell"	&& selectionMode != "singleRow"
		&& selectionMode != "multipleCells"	&& selectionMode != "multipleRows" )
	{
		return fasle;
	}

	//시트 선택모드 속성 변경
	this.selectionMode = selectionMode;
	//시트 선택모드 변경
	AUIGrid.setSelectionMode(this.AUIcontrolId, selectionMode);
	
	return true;
};

// 1 부터 시작된다
function SheetColumn(sheetRowNum, sheetColNum, rowSpan, colSpan){
    this.sheetRowNum = sheetRowNum;
    this.sheetColNum = sheetColNum;
    this.rowSpan = rowSpan;
    this.colSpan = colSpan;
};

//시트에 딸려 있다 , 바인드 끝나고 선언해야 한다
function MultilineHelper(sheet){
	this.sheet = sheet;
	this.AUIcontrolId = sheet.AUIcontrolId;
    this.rowsPerDataRow = sheet.rowsPerDataRow; 
    this.colsPerDataRow = sheet.colsPerDataRow; 
    
    this.columns = sheet.columns;
    this.maxRows = 0;
    this.currentRow = 0;
    this.defaultLayoutValue = [];  // 문자열 배열이 들어간다, 한줄에 문자열 하나
};

// 논리적인 위치를 받아 시트 칼럼의 정보를 반환한다
MultilineHelper.prototype.getPosition = function(rowNum, colNum) {
	var column = this.columns[colNum];
	return {sheetRow: (rowNum - 1) * this.rowsPerDataRow + column.sheetRowNum, sheetCol:column.sheetColNum, rowSpan:column.rowSpan, colSpan:column.colSpan};
};
//시트의 위치를 받아 논리적인  칼럼의 정보를 반환한다
MultilineHelper.prototype.getLogicalPosition = function(sheetRowNum, sheetColNum) {
	var colNum = -1;
	for (var i=1; i < this.columns.length; i++ ){
		if (this.columns[i].sheetColNum == sheetColNum && 
			this.columns[i].sheetRowNum % this.rowsPerDataRow == sheetRowNum % this.rowsPerDataRow){
			colNum = i;
			break;;
		}
	}
	return {logicalRow: 1 + (Math.floor((sheetRowNum - 1) / this.rowsPerDataRow)), logicalCol:colNum};
};

// 첫줄의 좌표 리턴
MultilineHelper.prototype.getSheetRowNum = function(logicalRowNum) {
	return (logicalRowNum - 1) * this.rowsPerDataRow + 1;
};
MultilineHelper.prototype.getLogicalRowNum = function(sheetRowNum) {
	return 1 + (Math.floor((sheetRowNum - 1) / this.rowsPerDataRow));
};
MultilineHelper.prototype.getSheetColNum = function(logicalColNum) {
	var column = this.columns[logicalColNum];
	return column.sheetColNum;
};
MultilineHelper.prototype.getLogicalColNum = function(sheetRowNum, sheetColNum) {
	
	for (var i=1; i < this.columns.length; i++ ){
		if (this.columns[i].sheetColNum == sheetColNum && 
			this.columns[i].sheetRowNum % this.rowsPerDataRow == sheetRowNum % this.rowsPerDataRow){
			return i;
		}
	}
	return -1;
};

// 로지컬한 데이터 이다 두줄짜리도 한줄로 합쳐서 넘어온 데이터를 처리한다.[{키:값, 키:값}, {키:값, 키:값}] 의 형태이며, "f1" ... 으로 시작되는 키 아니다.
// 현재 사용하는 곳은 없다
MultilineHelper.prototype.setData = function(varData, updateDataset) {
	var updated = false;
	if(data.length > 0){
		if (typeof varData == "Array"){
			var arrData = data;
			
			var ndx = 0;
			for (var nRow=0; nRow < arrData.length; nRow++){
				var jsonData = dataset.records[nRow];
				
				for (var sheetRowNum = 1; sheetRowNum <= this.rowsPerDataRow; sheetRowNum++){
					var subData = eval(this.defaultLayoutValue[sheetRowNum -1]); 
					
					subData["f1"] = nRow + 1;   // 1부터 시작
					for (var key in this.sheet.dataBinds){
						var bindInfo = this.sheet.dataBinds[key];
						if( typeof(bindInfo) == "function" ) continue;

						if (bindInfo.sheetRowNum == sheetRowNum){
							subData["f" + bindInfo.sheetColNum] = jsonData[bindInfo.colId];
						}
					}
					data[ndx++] = subData;
				}
			}
			
			if (arrData.length > 0){
				this.sheet.clear();
				this.sheet.setData(data, false);
				
				//무한루핑 방지
				if(updateDataset == undefined || updateDataset){
					//Dataset을 사용하지 않은 경우
					if(typeof(AUIDataSheetM.prototype._UpdateDatasetList) != "undefined"){
						this.sheet._UpdateDatasetList(this.getDatasetData());			
					}
				}
			}
		}
		if (varData instanceof DataSet){
			var dataset = data;

			var ndx = 0;
			for (var nRow=0; nRow < dataset.records.length; nRow++){
				var record = dataset.records[nRow];
				for (var sheetRowNum = 1; sheetRowNum <= this.rowsPerDataRow; sheetRowNum++){
					var subData = eval(this.defaultLayoutValue[sheetRowNum - 1]);
					
					subData["f1"] = nRow + 1;   // 1부터 시작
					for (var key in this.sheet.dataBinds){
						var bindInfo = this.sheet.dataBinds[key];
						if( typeof(bindInfo) == "function" ) continue;

						if (bindInfo.sheetRowNum == sheetRowNum){
							subData["f" + bindInfo.sheetColNum] = record.values[bindInfo.colId];
						}
					}
					data[ndx++] = subData;
				}
			}
			if (ataset.records.length > 0){
				this.sheet.clear();
				this.sheet.setData(data, false);
				
				//무한루핑 방지
				if(updateDataset == undefined || updateDataset){
					//Dataset을 사용하지 않은 경우
					if(typeof(AUIDataSheetM.prototype._UpdateDatasetList) != "undefined"){
						this.sheet._UpdateDatasetList(this.getDatasetData());			
					}
				}
			}
		}
 	}	
	return;
};

MultilineHelper.prototype.resetRowNum = function() {
	for (var rowNum=1 ; rowNum <= this.sheet.maxRows; rowNum++){
		var sheetRow = this.getSheetRowNum(rowNum);
        var AUIRow = sheetRow - 1;
        
        AUIGrid.setCellMerge(this.AUIcontrolId, false);
		for (var i = 0; i < this.rowsPerDataRow; i++){
			AUIRow += i;
			
			var item = {"f1": rowNum};    
			try {
				AUIGrid.updateRow(this.AUIcontrolId, item, AUIRow);
			} catch(e){
				try {
					AUIGrid.updateRow(this.AUIcontrolId, item, AUIRow);
				} catch(e){
					console.log(e);
				}
			}	
		}
        AUIGrid.setCellMerge(this.AUIcontrolId, true);
	}
};

MultilineHelper.prototype.getDatasetData = function() {
	var arrJsonObjects = new Array(this.sheet.maxRows);
	for (var AUIRowNum = 0; AUIRowNum < this.sheet.maxRows; AUIRowNum++){
		arrJsonObjects[AUIRowNum] = {};
	}

	var arrGridData = AUIGrid.getGridData(this.sheet.AUIcontrolId);
	for (var AUIRowNum=0; AUIRowNum < arrGridData.length; AUIRowNum++){
		var jsonObject = arrGridData[AUIRowNum];
		var sheetRowNum = AUIRowNum + 1;
		var logicalRowNum = this.getLogicalRowNum(sheetRowNum);
		var DataSetRowNum = logicalRowNum - 1;
		
		if (AUIRowNum % this.rowsPerDataRow == 0){
			arrJsonObjects[DataSetRowNum]._$uid = (AUIGrid.getItemByRowIndex(this.AUIcontrolId, AUIRowNum))._$uid;
		}
		
		for (var key in jsonObject){
			var value = jsonObject[key];
			if (typeof value == "function") continue;
			if (key.substring(0,1) != "f") continue;
			
			var sheetColNum = parseInt(key.substring(1));
			var logicalPos = this.getLogicalPosition(sheetRowNum, sheetColNum);
			
			arrJsonObjects[logicalPos.logicalRow - 1]["f" + logicalPos.logicalCol] = value;
		}
	}

	return arrJsonObjects;
};/******************************************************************************* 전역상수 *******************************************************************************/
    // 필요한 구조체
    function HeadData(){
        this.sortKey = "";
        this.captions  = ["","","","",""];
        this.values    = ["","","","",""];
        this.Level = 0;
        this.childInfo = "";
        this.hideChild = false;
        this.functionName  = "";
        this.merged    = ["N","N","N","N","N"];
    };

    
    function chartKey(chartName, seriesRCType, seriesStepNum, seriesLevel, pointRCType, pointStepNum, pointLevel){
    	this.chartName = "";     // 차트명
    	
    	this.seriesRCType = 0;   // BY_ROW or BY_COL
    	this.seriesStepNum = 0;
    	this.seriesLevel = 0;
    	
    	this.pointRCType = 0;    // BY_ROW or BY_COL
    	this.pointStepNum = 0;
    	this.pointLevel = 0;
    	
    	// Constants
    	this.BY_ROW_HTYPE = 1;
    	this.BY_COL_HTYPE = 2;
    	this.BY_ROW_VTYPE = 2;
    	this.BY_COL_VTYPE = 1;
    };
    
	// Constants
	var BY_COL_HTYPE = 1;
	var BY_ROW_HTYPE = 2;
	var BY_ROW_VTYPE = 2;
	var BY_COL_VTYPE = 1;
//	var GAP_BETWEEN_CELL  = (BrowserDetect.browser == "Explorer" ? 1 : 0);
//	var GAP_BETWEEN_CELL  = 1;
	var GAP_BETWEEN_CELL  = 0;	//2019-03-28 jaeik box-sizing: border-box; 속성으로 1->0으로 수정함
    // 익스플로러가 아닌 경우 전역변수 GAP_BETWEEN은 0이다
    // GAP_BETWEEN은 cross
	
	/***************************************************************************
	    데이터시트 콘트롤의 정의 부분이다
	    인수로는 콘트롤 명과 , 테그객체를 갖는다
	***************************************************************************/
	function CrossSheet(controlId, controlName, tagObject) //constructor 
    {
        // 시트 외형에 관한 설정 
        this.controlId = controlId;   
        this.id   = this.controlId;
        this.controlName = controlName;   
        this.tagObject = tagObject;
        
        this.reportId = "";
        this.parameters = [];
        this.editable = false;
        
        this.actionObject = null;
        
        
        if (tagObject != undefined){
//            setEventHandler(tagObject, "mousedown", sheet_onmousedown);
//            setEventHandler(tagObject, "mouseup", sheet_onmouseup);
//            setEventHandler(tagObject, "mousemove", sheet_onmousemove);
//            setEventHandler(tagObject, "mouseout", sheet_onmouseout);
        	setEventHandler(tagObject, "mousewheel", sheet_DisplayWheel);
        	  
			crosssheets[crosssheets.length] = this;
        }
        
        this.busy = false;
    };
    
    
    CrossSheet.prototype.clear = function(){
    	// functionname : [CrossSheet.clear]

        this.parameters = [];
        
        if(this.actionObject != null){
        	this.actionObject.clear();
        }
        
        return;
    };

    CrossSheet.prototype.setParameter = function(paramName, dataValue){
    	// functionname : [CrossSheet.setParameter]

        this.parameters[paramName] = new Parameter(paramName, dataValue);
        return;
    };
    
    CrossSheet.prototype.getData = function(){
    	// functionname : [CrossSheet.getData]

        var controlId = this.controlId;   
        var controlName = this.controlName;   
        
        var wParamInfo = "";
        for (var wKey in this.parameters){
                 if (typeof(this.parameters[wKey])=="function") continue;
                 wParamInfo  += this.parameters[wKey].value() +":";
        }
    	// 로드할 객체의 키값들을 리턴한다
        var wQueryString = "cogu=" + USER_COGU
                         + "&personalId=" + USER_PERSONALID
                         + "&crossid=" + this.reportId
                         + "&paramInfo=" + wParamInfo
    			         + "&lang=" + USER_LANGUAGE
    	                 + "&tm=" + (new Date()).valueOf();

     	// http://localhost/FlexFrame/groupware/analyze.action?cogu=19&crossid=271&paramInfo=20090601:20090731:
    	var wControl = this;
    	this.busy = true;
    	setTimeout(showAjaxBox(getText("message_crosssheet_001", "분석데이터 가저오기 중입니다.")),1,NEED_NOT_COUNT_UP);
    	if (TEST_MODE == undefined || !TEST_MODE){
    		ajaxCall("POST", getContextPath()+"/analyze.do", wQueryString, this, "analyze", 30);
    	} else {
    		ajaxCall("POST", getContextPath()+"/test/analyze.do", wQueryString, this, "analyze", 30);
    	}
        
        return;
     };
    
    CrossSheet.prototype.parseData = function(jsonActionObject, message, pFlag){
    	// functionname : [CrossSheet.parseData]
    	this.busy = false;                   
    	var controlId = this.controlId;   
    	
    	// 오류 메시지 먼저 파악 
    	if (jsonActionObject == null){
    		callEvent(this.controlId + "_LoadFailed", message, this.controlName);
    		hideAjaxBox();
    		return;
    	}
    	
    	if( typeof jsonActionObject.errorMsg != "undefined" && jsonActionObject.errorMsg != null && jsonActionObject.errorMsg.length > 0 ){
    		callEvent(this.controlId + "_LoadFailed", jsonActionObject.errorMsg);
    		hideAjaxBox();
    		return;
    	}
    	
    	// 데이터분석
    	this.analyze(jsonActionObject);
    	
    	/*
    	this.showChart();
	    callEvent(this.controlId + "_LoadSuccess");
    	 * */
    	
    	return;
    };
    
    CrossSheet.prototype.analyze = function(dataObject){
    	// functionname : [CrossSheet.analyze]

        if (dataObject.direction == "RowChange"){
        	this.actionObject = new CrossSheetV(this.controlId, this.controlName, this.tagObject);
        } else if (dataObject.direction == "ColChange"){
        	this.actionObject = new CrossSheetH(this.controlId, this.controlName, this.tagObject);
        }
        
    	this.actionObject.addChartInfo(this.chartInfo);
    	
        this.actionObject.analyze(dataObject);
        
        return;

    };

    //  
    CrossSheet.prototype.getDataForExcel = function(){
    	// functionname : [CrossSheet.getDataForExcel]

    	var arrFromStrings = [",", ":", ";", "&", "%", "?"];
        var arrToStrings   = ["<COMMA>", "<COLON>", "<SEMICOLON>", "<AMP>", "<PERCENT>", "<QUESTION>"];
    	                   
    	var generationInfo = new xlGenerationInfo();
    	generationInfo.colsNum = this.actionObject.headRows; // Column Header's Depth
    	generationInfo.rowsNum = this.actionObject.headCols; // Row Header's Depth
    	generationInfo.sheetType = "1";
    	
    	var found = false;
    	generationInfo.rowsColors = "";
    	/*
	    for (var cssSheetIndex = 0; cssSheetIndex < document.styleSheets.length; cssSheetIndex++){
        	var cssSheet=document.styleSheets[cssSheetIndex];
        	var cssRules = (cssSheet.cssRules? cssSheet.cssRules: cssSheet.rules);
        	
        	for (var wLevel = 1; wLevel <= 5; wLevel++){
        	    var selectorText = ".headlevel" + wLevel;
        		
	        	for (var cssRulesIndex = 0; cssRulesIndex < cssRules.length; cssRulesIndex++){
	        	    var cssRule = cssRules[cssRulesIndex];
	        	    
	        		if(cssRule.selectorText.toLowerCase() == selectorText){ 
	        			var colorString = "" + cssRule.style.backgroundColor;
	        			if (colorString.substring(0,1)=="#"){
	        				colorString = colorString.substring(1);
	        			} else if (colorString.substring(0,4)=="rgb("){
	        				colorString = colorString.substring(4, colorString.length - 1);
	        				var arrStrColors = colorString.split(",");
	        				var redString = parseInt(arrStrColors[0].trim(), 10).toString(16);
	        				var greenString = parseInt(arrStrColors[1].trim(), 10).toString(16);
	        				var blueString = parseInt(arrStrColors[2].trim(), 10).toString(16);
	        				
	        				redString = (redString.length == 1 ? "0" : "") + redString;
	        				greenString = (greenString.length == 1 ? "0" : "") + greenString;
	        				blueString = (blueString.length == 1 ? "0" : "") + blueString;
	                        
	        				colorString = "" + redString + greenString + blueString;
	        			} 
	        			
	        			found = true;
	        			break;
	        		}
	        		
	        	}
	        	
    			generationInfo.rowsColors = (wLevel == 1 ? "" : ",") + colorString;

        	}
    	}
    	*/

    	var wStrColsWidths = this.actionObject.tagObject.getAttribute("cellsize") || "";
    	var wColsWidths = wStrColsWidths.split(";"); wStrColsWidths = "";
    	for (var i = 0; i < wColsWidths.length; i++){
    		if (wColsWidths[i].trim().length == 0) continue;
    		var colWidth = Math.ceil(parseFloat(1 * wColsWidths[i]) / 7,5);
    		wStrColsWidths += (i == 0 ? "" : "\t") + colWidth;
    	}
    	
    	generationInfo.colsWidth = wStrColsWidths;
    	
    	generationInfo.data = "";

     	var wRows = this.actionObject.dataTable.tBodies[0].rows;
    	for (var rowNum = 0; rowNum < wRows.length; rowNum++){
    		var wRow = wRows[rowNum];
    		
    		for (var colNum = 0; colNum < wRow.cells.length; colNum++){  // 칼럼해더정보 넘기기
    			var wCell = wRow.cells[colNum];
        		var decimal = wCell.getAttribute("decimal");
        		
	    		if (rowNum < this.actionObject.headRows){
        			generationInfo.data += (colNum == 0 ? "" : "\t") + escapeCharacter(wCell.innerHTML,arrFromStrings, arrToStrings);
        			generationInfo.decimal += (colNum == 0 ? "" : "\t") + (decimal == undefined || decimal == "" ? "0" : decimal);
	    		} else if (colNum < this.actionObject.headCols){                      // 칼럼헤드가 아니고 로우헤드인 경우
        			generationInfo.data += (colNum == 0 ? "" : "\t") + escapeCharacter(wCell.innerHTML,arrFromStrings, arrToStrings);
        			generationInfo.decimal += (colNum == 0 ? "" : "\t") + (decimal == undefined || decimal == "" ? "0" : decimal);
	    		} else {                                                 // 데이터 셀인 경우
        			generationInfo.data += (colNum == 0 ? "" : "\t") + escapeCharacter(wCell.innerHTML,arrFromStrings, arrToStrings);
        			generationInfo.decimal += (colNum == 0 ? "" : "\t") + (decimal == undefined || decimal == "" ? "0" : decimal);
	    		}
    		}
    		if (rowNum < wRows.length -1) {
        		//generationInfo.data += ":\r\n";
    			generationInfo.data += "<<%ENTER%>>";
    			generationInfo.decimal += "<<%ENTER%>>";
    		}
    	}
    	return generationInfo;
    };
    
    CrossSheet.prototype.preview = function(){
    	// functionname : [CrossSheet.preview]


    };

    
    CrossSheet.prototype.print = function(){
    	// functionname : [CrossSheet.print]
    	
    	
    };

    CrossSheet.prototype.addChartInfo = function(pChartInfo){
    	// functionname : [CrossSheet.addChartInfo]

        this.chartInfo = pChartInfo;
    };
    
    //CrossSheet.prototype.getChartData = function(pChartId){
    //	return this.actionObject.getChartData(pChartId);
    //}

    CrossSheet.prototype.showChart = function(){
    	// functionname : [CrossSheet.showChart]

    	this.actionObject.showChart();
    	return;
    };

    CrossSheet.prototype.scrollAction = function(scrollTop, scrollLeft){
        // functionname : [DataSheet.scrollAction]
                           
 	   // 사용자 코딩 추가영역을 호출한다
 	   var scrollPanel = this.tagObject.getElementsByTagName("DIV")[0];
 	   var checkEvent = false;
 	   try {
 	       if (eval(this.controlId + "_onscroll")) checkEvent = true;
 	   } catch(e){}
 	       if (checkEvent){
 	           eval(this.controlId + "_onscroll(scrollPanel, scrollTop, scrollLeft);");
 	   }
        
 	   return;
    };
    
    
    
    /*******************************************************************************
    필요함수 
    *******************************************************************************/
    function sortfnHead(a,b){
        dt1 = (a.sortKey || "").toLowerCase();
        dt2 = (b.sortKey || "").toLowerCase();
        
        if (dt1 == dt2) return 0;
        if (dt1 < dt2) return -1;

        return 1;
    };
    
    function parseRangeToRC(row, col, row2, col2){
        var wReturn = "R" + row + "C" + col;
        if (!row2) row2 = row;
        if (!col2) col2 = col;
        
        if (row != row2 || col != col2){
            wReturn += ":R" + row2 + "C" + col2;
        }
        return wReturn;
    };
    
    function sortedArrayWithOrderTag(parentArray, startIndex, indexAfterEndPoint, startNum){
    	// 배열을 카피한다
    	var length = parentArray.length;
    	var newArray = new Array(length);
    	for (var i = 0; i < length;i++)
    		newArray[i] = parentArray[i].values.slice(startIndex, indexAfterEndPoint);
    	
    	// 순서 테그를 마지막 배열값으로 추가한다
     	for (var i=0; i < newArray.length; i++){
    		newArray[i].push(startNum + i);
    	}
    	
    	// 배열을 소트한다
    	newArray.sort(compareArray);
    	
    	// 소트된 배열을 리턴한다.

    	return newArray;
    };
    

    // -----------------------------------------------------------------------------------
    //     여기서 부터는 클릭동작 
    // -----------------------------------------------------------------------------------
	function crosssheet_onmouseup(e) {
        e = e||window.event;                      // IE에 적용
    	var em = getSrcElement(e);

    	call_crosssheet_onmouseup(em);
    	
        stopPropagation(e);
		return true;
	};
    
	function call_crosssheet_onmouseup(em) {
		var wCSheet = searchSheet(em); 
        if (wCSheet == null)  return false;
//        if (!wCSheet.editable)  return false; 클릭 이벤트 동작 때문에 막음 2014.08.28
        var wSheet = wCSheet.actionObject;
        
    	// TD이고 줄인것 
        if (em.tagName != "TD") return;

	    var wCell = em;
	    var wRow = em.parentNode;

    	// 현재 줄번호를 서칭해서 대입하고
        var rowNum = wCell.parentNode.rowIndex;
        var colNum = wCell.cellIndex;
        
        if (rowNum < wSheet.headRows) return false;
        if (colNum < wSheet.headCols) return false;
        if (wCell.getAttribute("formula") != null) return false;
    	
        // 2단계 : 새로운 셀을 Edit 모드로 바꾼다.
        var oChild = null;
        var wValue = "";
        
    	
        // 사용자 코딩 추가영역을 호출한다
        if (wSheet.hasClickEvent) {
            var wResult = wSheet.fncClickEvent(rowNum, colNum);
            if (typeof(wResult)=="boolean" && !wResult) {
                return false;
            }            
        } 

        // 좌표 탐색
        var coords = wCSheet._getSetPosition(wCell);
        var oChild  = null;
        if (wCSheet.textControl != null){
            oChild = wCSheet.textControl; 
        } else {
        	if (BrowserDetect.browser == "Explorer" && !isNaN(parseFloat(BrowserDetect.version)) && parseFloat(BrowserDetect.version) < 9) {
        		oChild = document.createElement("<INPUT type='text' id='shtText" + wSheet.id + "' name='shtText" + wSheet.id + "' class='shtText'>");
        	} else {
        		oChild = document.createElement("input");
        		oChild.type = "text";
        		oChild.name = "shtText" + wSheet.id;
        		oChild.id = "shtText" + wSheet.id;
        		oChild.className = "shtText";
        		
        		
        		oChild.style.display = "block";
        	} 
        	wSheet.dataTable.insertAdjacentElement('afterEnd', oChild);
        	wCSheet.textControl = oChild; 

    	    setEventHandler(oChild, "keydown", xCell_onKeyDown);
    	    setEventHandler(oChild, "keypress", xCell_onKeyPress);
    	    setEventHandler(oChild, "blur", xCell_onBlur);
            //setEventHandler(oChild, "mousewheel", sheet_DisplayWheel);
        }
        
    	oChild.value = (wCell.getAttribute("value") || "");
    	
	    oChild.style.left = coords.x + "px";
	    oChild.style.top = coords.y + "px";
	    oChild.style.width = coords.w + "px";
	    oChild.style.height = coords.h + "px";
	    
	    oChild.setAttribute("row", rowNum);
	    oChild.setAttribute("col", colNum);
        
	    if (wCell.align.length > 0){
	    	oChild.style.textAlign = wCell.align;
	    }
	    
	    oChild.style.lineHeight = (coords.h - 2) + "px";
        oChild.focus();
        oChild.select();
        
        // 툴팁 보여주기
        oChild.title = (wCell.title != null && wCell.title != undefined && wCell.title != "" ? wCell.title : "");
        
        wCell = null; oChild = null; wTable = null;
    	
		
		return true;
	};
    
	CrossSheet.prototype._getSetPosition= function(cell){
        // functionname : [CrossSheetV.getSetPosition]
        
		var coords = { x: 0, y: 0, w: 0, h: 0 };
		
		coords.w = cell.offsetWidth - 3;
		coords.h = cell.offsetHeight - 3;
		while (cell && cell.tagName != "DIV") {
			coords.x += cell.offsetLeft;
			coords.y += cell.offsetTop;
			cell = cell.offsetParent;
		}   
		coords.x = coords.x;
		coords.y = coords.y;
    
        return coords;
    };
    
    CrossSheet.prototype._hideCellEdit = function(){
        // functionname : [CrossSheetV._hideCellEdit]

        if (this.textControl != null){
            this.textControl.style.left = "-10000px"; 
            this.textControl.setAttribute("row", "0");
            this.textControl.setAttribute("col", "0");
        }

    	return;
    };

    
    CrossSheet.prototype.getHeaderInfo = function(rowNum, ColNum){
    	var wReturn = {columnValue: [], columnText: [], rowValue: [], rowText: []};
    	
    	var wSheetBody = this.actionObject.dataTable.tBodies[0];
    	// 상단 칼럼의 값
    	for (var wRowNum = 0; wRowNum <= this.actionObject.headRows; wRowNum++){
            var wCell   = wSheetBody.rows[wRowNum].cells[ColNum];
            var value = wCell.getAttribute("value") || "";
            var text = wCell.innerText || "";
            
            wReturn.columnText[wRowNum] = text;
            wReturn.columnValue[wRowNum] = value;
     	}
    	
    	// 좌측 줄헤더의 값
     	for (var wColNum = 0; wColNum < this.actionObject.headCols; wColNum++){
            var wCell   = wSheetBody.rows[rowNum].cells[wColNum];
            var value = wCell.getAttribute("value") || "";
            var text = wCell.innerText || "";
            
            wReturn.rowValue[wColNum] = text;
            wReturn.rowValue[wColNum] = value;
     	}
    	return wReturn;
    };

    CrossSheet.prototype.getCellValue = function(rowNum, ColNum){
    	
    	var wSheetBody = this.actionObject.dataTable.tBodies[0];
        var wCell   = wSheetBody.rows[rowNum].cells[ColNum];
        var value = wCell.getAttribute("value") || "";
        return value;
    };
    
    function xCell_onKeyPress(e){
    	
    	if (!e) e = window.event;
    	var em = getSrcElement(e);
    	
        var wKeyCode = (e.which ? e.which : e.keyCode);
        if (BrowserDetect.browser == "Explorer" && !isNaN(parseFloat(BrowserDetect.version)) && parseFloat(BrowserDetect.version) <= 7) {
        	if (wKeyCode == 13){
        		xCell_onKeyDown(e);
        	}
        }
         
        return true;
    };
    
    function xCell_onKeyDown(e){
    	if (!e) e = window.event;
    	var em = getSrcElement(e);
    	
		var wCSheet = searchSheet(em); 
        if (wCSheet == null)  return false;
        var wSheet = wCSheet.actionObject;

        var KeyCode = (event.which) ? event.which : event.keyCode ;
   	
        if (KeyCode==9)                                                                  
        {                                                                           
        	stopEvent(e)
	   		return true;
        } else if (KeyCode == 13){
        	call_xcell_onBlur(em);
			stopEvent(e);
			
	   		//var name = em.getAttribute("name");
            // setTimeout("keyAction(\"" + name + "\");" ,1); 

            return true;
        } else if (KeyCode == 38 || (getShiftKeyPressed(e) && KeyCode == 104)){    // 38 : up
	   		//var name = em.getAttribute("name");
            // setTimeout("keyAction(\"" + name + "\", \"upper\");" ,1); 
			//stopEvent(e);
	   		return true;
        } else if (KeyCode == 40 || (getShiftKeyPressed(e) && KeyCode == 98)){    // 40 : down
	   		var name = em.getAttribute("name");
            //setTimeout("keyAction(\"" + name + "\", \"lower\");" ,1); 
			stopEvent(e);
	   		return true;
	   		
        } else if (KeyCode == 37 || (getShiftKeyPressed(e) && KeyCode == 100)){    // 37 : to Left
     	    //var selLength = getCaretLength(em);
	 	    //var startPos = getCaretPosition(em);
	 	    //if (startPos == 0 && selLength == 0){
		   	//	var name = em.getAttribute("name");
	            //setTimeout("keyAction(\"" + name + "\", \"left\");" ,1); 
			//	stopEvent(e);
	    	//} 

	   		return true;
        } else if (KeyCode == 39 || (getShiftKeyPressed(e) && KeyCode == 102)){    // 39 : to Right
     	    //var selLength = getCaretLength(em);
	 	    //var startPos = getCaretPosition(em);
	 	    //var value = ("" + em.value);
		    
	    	//if (value.length == startPos){
		   	//	var name = em.getAttribute("name");
	            //setTimeout("keyAction(\"" + name + "\", \"right\");" ,1); 
			//	stopEvent(e);
	    	//} 
	        	
	   		return true;
        } else {
            var wRowNum = parseInt(1 * em.getAttribute("row"));
            var wColNum = parseInt(1 * em.getAttribute("col"));
            var wCell   = wSheet.dataTable.tBodies[0].rows[wRowNum].cells[wColNum];
            
            var stepNum = (wSheet instanceof CrossSheetH ? wSheet.stepNumOf(wColNum) : wSheet.stepNumOf(wRowNum));
            
            var wCellType = wSheet.dataObject.steps[stepNum].cellType; 
            
            if (!getShiftKeyPressed(e) && KeyCode >= 48 && KeyCode <= 57){          // 숫자코드
         		// 모든경우에 OK
         	} else 
            if (!getShiftKeyPressed(e) && KeyCode >= 96 && KeyCode <= 105){         // 숫자코드
             		// 모든경우에 OK
         	} else 
            if (KeyCode == 8){         // 백스페이스 코드
             		// 모든경우에 OK
         	} else 
         	if (wCellType == CELLTYPE_FLOAT) {
         	    if (KeyCode == 45){  // 45 : "-"
    	     	    // 빈양식인 경우
    	     	    if (("" + em.value).length == 0){
    	     	    	// 통과
    	     	    } else {
    		     	    var selLength = getCaretLength(em);
    		     	    var startPos = getCaretPosition(em);
    		     	    var value = ("" + em.value);
    		     	    
    	     	    	// 전체 선택 상태에서 "-" 친경우 ok
    	     	    	if (value.length == selLength){
    		     	    	// 통과
    	     	    	} 
    		     	    // 캐럿이 첫번째 위치에 있고, 뒤에가 숫자인 경우
    	     	    	else if (startPos == 0 &&  value.length != 0 && value.substring(0,1) >= "0" && value.substring(0,1) <= "9"){
    		     	    	// 통과
    	     	    	} else {
    	     	    		stopEvent(e);
    	     	       		return true;
    	     	    	}
    	     	    }
         	    	
         	    } else if (KeyCode == 190 || KeyCode == 110){  // 46 : "."
         	    	if (("" + em.value).length == 0){
         	    		stopEvent(e);
         	       		return true;
         	    	}
         	    } else {
         	    	stopEvent(e);
         	   		return true;
         	    }
         	}
        }

        return true;                                                                           
    };
    
    function xCell_onBlur(e){

    	if (!e) e = window.event;
    	var em = getSrcElement(e);
    	
    	call_xcell_onBlur(em);

        stopEvent(e);
        return;
    };    
    
    function call_xcell_onBlur(em){

		var wCSheet = searchSheet(em); 
        if (wCSheet == null)  return false;
        var wSheet = wCSheet.actionObject;

        var wRowNum = parseInt(1 * em.getAttribute("row"));
        if (wRowNum == 0) return;
        
        var wColNum = parseInt(1 * em.getAttribute("col"));
        if (wColNum == 0) return;
        
        var wCell   = wSheet.dataTable.tBodies[0].rows[wRowNum].cells[wColNum];
        
        var stepNum = (wSheet instanceof CrossSheetH ? wSheet.stepNumOf(wColNum) : wSheet.stepNumOf(wRowNum));
        var wCellType = wSheet.dataObject.steps[stepNum].cellType; 

        var oldValue = wCell.getAttribute("value");
        var wValue = em.value;
        
        if ("" + oldValue != "" + wValue){
        	
        	wCell.setAttribute("value", wValue);
        	
         	if (wCellType == CELLTYPE_FLOAT) {
            	var decemal = parseInt(1 * wCell.getAttribute("decimal"));
                wCell.innerText = mask(wValue, "###,###,###,###,##0" + (decemal > 0 ? ".0000000000".substring(0, decemal + 1) : ""));
                wCell.align     = "right";
            } else { 
                wCell.innerText = wValue;
                wCell.align     = "left";
            }
        	
         	// 집계값갱신
         	// 1: 현재 칼럼의 각셀 갱신
         	for (var wColNum1 = wSheet.headCols; wColNum1 <  wSheet.headCols + wSheet.maxCols; wColNum1++){
                var wCell1   = wSheet.dataTable.tBodies[0].rows[wRowNum].cells[wColNum1];
                var wFormula = wCell1.getAttribute("formula") || "";
                if (wFormula.length > 0){
                	wSheet.calculateCell(wCell1, wFormula);
                }
         	}
         	for (var wRowNum1 = wSheet.headRows; wRowNum1 <  wSheet.headRows + wSheet.maxRows; wRowNum1++){
                var wCell1   = wSheet.dataTable.tBodies[0].rows[wRowNum1].cells[wColNum];
                var wFormula = wCell1.getAttribute("formula") || "";
                if (wFormula.length > 0){
                	wSheet.calculateCell(wCell1, wFormula);
                }
         	}
         	
         	
         	// 2: 현재 줄의 각셀 갱신
         	
    		if (wSheet.hasChangeEvent) {
                var wResult = wSheet.fncChangeEvent(wRowNum, wColNum, wValue, oldValue, wCell);
            } 
        } 

        wCSheet._hideCellEdit();
        
        return;
    };
    
    
    
    function sheet_DisplayWheel(e) {
    	e = window.event || e;
    	var em = getSrcElement(e);
    	var delta = 0;
    	
    	// Opera는 detail, 기타 브라우저는 wheelDelta
    	if (event.wheelDelta) {
    		delta = event.wheelDelta / 120; 
    	} else if (event.detail) {
    		delta = -event.detail;
    	}
    	if (delta){
            var wSheet = searchSheet(em);
            var scrollPanel = wSheet.tagObject.getElementsByTagName("DIV")[0];
            scrollPanel.scrollTop = scrollPanel.scrollTop - delta * 15;
    		
    	}
    	
    	stopEvent(e);

    	return;
    };/***************************************************************************
    데이터시트 콘트롤의 정의 부분이다
    인수로는 콘트롤 명과 , 테그객체를 갖는다
***************************************************************************/
    function CrossSheetV(controlId, controlName, tagObject) //constructor 
    {
        // 시트 외형에 관한 설정
        this.controlId = controlId;   
        this.id   = this.controlId;
        this.controlName = controlName;   
        this.tagObject = tagObject;
        this.enabled = true;
        
        this.headRows = 1;
        this.headCols = 1;
        this.frozenCols = 0;
        this.frozenRows = 0;
        this.maxCols = 0;  // MaxCols와 MaxRows엔 비고난이 들어 가지 않는 숫자다
        this.maxRows = 0;
        this.remarkCols = 0;
        this.remarkRows = 0;
        this.chartInfo = "";
        
        var wTables = this.tagObject.getElementsByTagName("table");
        this.dataTable    = wTables[DATA_TABLE];
        this.colHeadTable = wTables[COL_TABLE];
        this.rowHeadTable = wTables[ROW_TABLE];
        this.fixCellTable = wTables[FIX_TABLE];
        
        // 데이터처리에 관한 설정 
        this.headDatas = [];          // HeadData구조체의 배열이다
        this.headDatasSorted = null;    // HeadData구조체의 정렬된 배열이다
        this.stepHeadDatas= [null];   // 스텝갯수만큼 위 HeadDatas배열이 들어간다
        this.stepstartNums= [null];   // 스텝갯수만큼 위 시작 줄,열번호가 들어간다
        this.stepRCs      = [null];   // 스텝별로 로우데이터의 RC정보가 들어간다
        
        this.printHead = "";  // 인쇄시 페이지 헤더로 들어갈 내용
        this.printFoot = "";  // 인쇄시 페이지 푸터로 들어갈 내용
        this.needRemarks = false;
        
        // 참고: 최상위 레벨이 1레벨이고 하위 데이터가 붙을수록 5레벨까지 
        //       계속 레벨번호가 올라간다
        //       Value, Caption데이터는 상위레벨부터 채워진다
        //       즉 0번값이 최상위이다 (쿼리 필드 순서)
        
        this.colLevelCnt = 0; // 칼럼헤더의 레벨계층숫자
        this.rowLevelCnt = 0; // 로우헤더의 레벨계층숫자
        
        // 서버에서 받은 채우기 객체
        this.dataObject = null;

        if (tagObject != undefined){
            tagObject.setAttribute("tabIndex", "-1");
            
            //setEventHandler(tagObject, "mouseup", crosssheetv_onmouseup);
//            setEventHandler(this.dataTable, "mouseup", crosssheet_onmouseup);	//2019-03-28 jaeik 텍스트박스 입력 막음
        }

        this.hasClickEvent = false; this.fncClickEvent = null;
        this.hasChangeEvent = false; this.fncChangeEvent = null;
        if (this.controlId.length > 0) {
        	try {
            	if (eval(this.controlId + "_onclick")) this.hasClickEvent = true;
            } catch(e){}
            if (this.hasClickEvent){
        	    eval("this.fncClickEvent = function(rowNum, colNum){ return " + this.controlId + "_onclick(rowNum, colNum);}");
            }
        	try {
            	if (eval(this.controlId + "_onchange")) this.hasChangeEvent = true;
            } catch(e){}
            if (this.hasChangeEvent){
        	    eval("this.fncChangeEvent = function(rowNum, colNum, value, oldValue, cell){ return " + this.controlId + "_onchange(rowNum, colNum, value, oldValue, cell);}");
            }
        }
    
    };
    
    /* -----------------------------------------------------------------------
        셀과 관련된 기초동작 
     -------------------------------------------------------------------------*/
    CrossSheetV.prototype.getText = function(row, col){
        // functionname : [CrossSheetV.getText]

    	var wCell = this.dataTable.tBodies[0].rows[row + this.headRows - 1].cells[col + this.headCols - 1];
        var wValue = wCell.getAttribute("value");
        
    	return wValue;
    };

    // MaxRows, MaxCols를 0으로 세팅한다
    CrossSheetV.prototype.clear = function(){
        // functionname : [CrossSheetV.clear]

        var wTables = this.tagObject.getElementsByTagName("table");
        for (var wTableNum = 0; wTableNum < wTables.length; wTableNum++){
            var wTable = wTables[wTableNum];
            for (var wRow = wTable.tBodies[0].rows.length - 1; wRow > 0; wRow--){
                    wTable.deleteRow(wRow);
            }
            
            var wRow = wTable.tBodies[0].rows[0];
            wRow.style.display = "";
            for (var wColNum = wRow.cells.length - 1; wColNum > 0; wColNum--){
                    wRow.deleteCell(wColNum);
            }
            wRow.cells[0].innerText = " ";
        }

        // 시트 외형에 관한 설정 
        this.headRows = 1;
        this.headCols = 1;
        this.frozenCols = 0;
        this.frozenRows = 0;
        this.maxCols = 0;  // MaxCols와 MaxRows엔 비고난이 들어 가지 않는 숫자다
        this.maxRows = 0;
        this.remarkCols = 0;
        this.remarkRows = 0;
        
        // 데이터처리에 관한 설정
        this.headDatas.clear();       this.headDatas = [];          // HeadData구조체의 배열이다
        this.stepHeadDatas.clear();   this.stepHeadDatas= [null];   // 스텝갯수만큼 위 HeadDatas배열이 들어간다
        this.stepstartNums.clear();   this.stepstartNums= [null];   // 스텝갯수만큼 위 시작 줄,열번호가 들어간다
        this.stepRCs.clear();         this.stepRCs      = [null];   // 스텝별로 로우데이터의 RC정보가 들어간다
        
        this.printHead = "";  // 인쇄시 페이지 헤더로 들어갈 내용
        this.printFoot = "";  // 인쇄시 페이지 푸터로 들어갈 내용
        this.needRemarks = false;
        
        this.colLevelCnt = 0; // 칼럼헤더의 레벨계층숫자
        this.rowLevelCnt = 0; // 로우헤더의 레벨계층숫자

        return;
    };

    CrossSheetV.prototype.getTag = function(row, col){
        // functionname : [CrossSheetV.getTag]

    	if (row + this.headRows - 1 > this.maxRows || 
    	    col + this.headCols - 1 > this.maxCols) return "";
    	    
    	return this.dataTable.tBodies[0].rows[row + this.headRows - 1].cells[col + this.headCols - 1].getAttribute("tag");
    };

    /* -------------------------------------------------------------------------
       서버로 부터 받은 데이터를 곧바로 헤드오 뿌릴 수 있도록 데이터를 만든다.
       인수 : 
           heads : 서버로 부터 받은 데이터 2차원배열[레코드번호][필드번호]
           sumPosition : 합계를 앞에 표시할 것인지 구분 ("AFTER", "BEFORE")
           sums : 합계갑 표시캡션들의 1차원 배열["합계","평균","최대",...]
       결과 : 
           this.headDatas : 결과값이 들어갈 1차원배열 (HeadData 구조체가 들어감) 
     ------------------------------------------------------------------------ */
    CrossSheetV.prototype.makeHeads = function(heads, sumPosition, sums, levelCnt, hidden, headDatas){
        // functionname : [CrossSheetV.makeHeads]

        var wIndex = -1;
        
        var AC = (sumPosition == "AFTER" ? "C" : "A");
        for (var i = 0; i < heads.length; i++){
            var wHeadData = headDatas[++wIndex] = new HeadData();
            var wColData = heads[i];
            
            wHeadData.values   = wColData.slice(0, 5);
            wHeadData.captions = wColData.slice(5, 10);
            
            var wSortKey = "";
            for (var k = 1; k <= levelCnt; k++){
                wSortKey += "B" + mask(i, "0000");
            }
            wHeadData.sortKey = wSortKey;
            
            wHeadData.childInfo = "NONE";
            wHeadData.Level = 1;
            
            var wNextData = (i == heads.length - 1 ? [null,null,null,null,null] : heads[i + 1]);
            
            // 1레벨의 합계부터 5레벨의 합계까지 루핑 
            for (var wLevel = 1; wLevel <= levelCnt; wLevel++){
                var wLevelIndex = wLevel - 1;
                // 마지막 데이터는 무조건 true이다(전체합계를 찍기위해서)
                var wChecked = (i == heads.length - 1); 
                // 상위 요소의 변화를 체크한다
                for (var j = 0; j < wLevelIndex;j++)
                    wChecked = wChecked || (wColData[j] != wNextData[j]);
                
                if (wChecked && sums[wLevelIndex] != null && sums[wLevelIndex] != getText("message_crosssheetv_009", "표시안함")
                		 								  && sums[wLevelIndex] != getText("message_crosssheetv_015", "(None)")){
                    var wNewHeadData = headDatas[++wIndex] = new HeadData();
                    for (var k = 0; k < wLevelIndex; k++){
                        wNewHeadData.values[k]   = wHeadData.values[k];
                        wNewHeadData.captions[k] = wHeadData.captions[k];
                    }
                    wNewHeadData.captions[wLevelIndex] = sums[wLevelIndex]; // "합계","소계"
                    wNewHeadData.functionName = sums[wLevelIndex];
                    wNewHeadData.Level = levelCnt - wLevel + 1 + 1;
                    
                    wNewHeadData.hideChild = hidden[wLevelIndex];
                    
                    var wSortKey = "";
                    for (var k = 1; k <= levelCnt; k++){
                        if (k >= wLevel){
                            wSortKey += AC  + mask(i, "0000");
                        } else {
                            wSortKey += "B" + mask(i, "0000");
                        }
                        if (k > wLevel){
                            wSortKey += AC  + mask(i, "0000");
                            wNewHeadData.merged[k - 1] = "X"; // 셀합치기 동작에 필요해서 기억해 놓음
                            wNewHeadData.captions[k - 1] = wNewHeadData.captions[wLevelIndex];
                        }
                    }
                    wNewHeadData.sortKey = wSortKey;
                    
                }
            }
        }

        headDatas.sort(sortfnHead);
        
        for (var i = 0; i < headDatas.length; i++){
            if (headDatas[i].childInfo == "NONE")
                this.setChildInfo(headDatas[i], headDatas, levelCnt, i + 1);
            // 여기서 1을 더한 이유는 sheetCol, SheetRow가 1부터 시작하기 때문이다    
        }
        
        // 더이상 필요없게된 메모리는 지운다
        heads.clear();
        
        return;
    };
    
    CrossSheetV.prototype.setChildInfo = function(headData, headDatas, levelCnt, indexNum){
        // functionname : [CrossSheetV.setChildInfo]

        for (var i = 0; i < headDatas.length; i++){
            if (headDatas[i].childInfo == "NONE") continue;
            var wHeadData = headDatas[i];
            var wChecked = true;
            for (wLevel = 1; wLevel < levelCnt; wLevel++){
                var wLevelIndex = wLevel - 1;
                if (wHeadData.values[wLevelIndex] != "" && 
                   (headData.values[wLevelIndex] != wHeadData.values[wLevelIndex])){
                   wChecked = false;
                   break;
                }
            }
            
            if (!wChecked) continue;
            
            wHeadData.childInfo += (wHeadData.childInfo.length > 0 ? "," : "") + indexNum;
        }
        return;
    };

    // 데이터를 넣을 빈셀과 빈 헤더셀들을 만든다. 셀들의 Span은 아직 없다.
    CrossSheetV.prototype.makeBlankCells = function(){
        // functionname : [CrossSheetV.makeBlankCells]

        // MaxCols와 MaxRows를 계산
        this.maxCols = this.headDatas.length; 
        this.maxRows = 0;
        for (var wStepNum = 1; wStepNum < this.stepHeadDatas.length; wStepNum++){
            this.maxRows += this.stepHeadDatas[wStepNum].length;
        }

        // this.headCols와 this.headRows를 계산
    	var wTables = this.tagObject.getElementsByTagName("table");
        var wArrStrCellLen = (this.tagObject.getAttribute("cellSize") || "").split(";");
        for (var i = 0; i <= 3;i++){
            var wTable = wTables[i];
            var wTableRow = null;var wCell = null;
    	
            var ColsTo = this.headCols + (i == ROW_TABLE || i == FIX_TABLE ? this.frozenCols : this.maxCols + this.remarkCols);
            var RowsTo = this.headRows + (i == COL_TABLE || i == FIX_TABLE ? this.frozenRows : this.maxRows + this.remarkRows);
            
            for (var wRow = 0; wRow < RowsTo; wRow++){
                // 줄을 선택한다, 없으면 만든후 선택한다
                if (wTable.tBodies[0].rows.length <= wRow) {
                	wTableRow = wTable.insertRow(wRow);
                } else {
                	wTableRow = wTable.tBodies[0].rows[wRow];
                }
                wTableRow.style.height = 19 + "px";
                
                for (var wCol = 0; wCol < ColsTo; wCol++){
                    if (wTableRow.cells.length <= wCol)  {
                    	wCell = wTableRow.insertCell(wCol);
                    } else {
                    	wCell = wTableRow.cells[wCol];
                    }
                         
                    wCell.innerText = " ";
                    if (i == DATA_TABLE) wCell.setAttribute("value", "");
                    wCell.vAlign = "middle";
//                    wCell.vAlign = "baseline";
                    
                    // 헤더셀들은 셀사이즈를 주어 Span에 대비한다
                    if (wRow < this.headRows) {
                        wCell.style.width = 50 + "px";
                        wCell.className = "HeadLevel" + (wRow + 1);
                        wCell.innerHTML = "&nbsp;";
                        wArrStrCellLen[wRow] = "50" + "px";
                    } else if (wCol < this.headCols) {
                        wCell.className = "HeadLevel" + (wCol + 1);
                        wCell.innerHTML = "&nbsp;";
                    }
                }
            }
                    
            wTable.style.width = (ColsTo * (50 + GAP_BETWEEN_CELL) + GAP_BETWEEN_CELL) + "px";
            
            if (i == DATA_TABLE)
                this.tagObject.setAttribute("cellSize", wArrStrCellLen.join(";"));    
                
        }
        return;
    };

    CrossSheetV.prototype.makeColTitle = function(){
        // functionname : [CrossSheetV.makeColTitle]
        
        var wArrHeadDatas = this.headDatas;
    
    	var dataTableBody = this.dataTable.tBodies[0];
    	var colHeadTableBody = this.colHeadTable.tBodies[0];
    	var dataTableRow = null;
    	var colHeadTableRow = null;
    	var wCell = null;

    	for (var i = 0; i < wArrHeadDatas.length; i++){
    	    var wColNum = i + this.headCols;
    	    var wHeadData = wArrHeadDatas[i];
    		
    	    for (var j = 0; j < this.headRows; j++){
    	        var wRowNum = j;
    		
                var wCell = dataTableBody.rows[wRowNum].cells[wColNum];
                wCell.innerText = wHeadData.captions[j];
                wCell.setAttribute("value", wHeadData.values[j]);
    	        
                var wCell = colHeadTableBody.rows[wRowNum].cells[wColNum];
                wCell.innerText = wHeadData.captions[j];
                wCell.setAttribute("NeedDel", (wRowNum > 0 && wHeadData.values[j] == wHeadData.values[j - 1] && wHeadData.captions[j] == wHeadData.captions[j - 1] ? "true" : "false"));
    	    }
    	    
    	    for (var wRowNum = this.headRows; wRowNum < this.headRows + this.maxRows; wRowNum++){
    	        if (wHeadData.Level > 1)
    	            dataTableBody.rows[wRowNum].cells[wColNum].className = "CSumBack" + wHeadData.Level;
    	    }
    	    
    	}
    	
    	/**
		 * 2019-06-19 jaeik 로우타이틀 채우기
		 */
    	var rowHeadTableBody = this.rowHeadTable.tBodies[0];
        var fixCellTableBody = this.fixCellTable.tBodies[0];
    	var rowTitle = this.dataObject.head.rowTitle;
    	if (rowTitle != null && rowTitle.length > 0) {
    		for (var i = 0; i < rowTitle.length; i++){
        	    var wRowNum = i;
        	    var wHeadData = rowTitle[rowTitle.length-i-1];
        	    var wHeadData1 = (rowTitle[rowTitle.length-i] == undefined ? "" : rowTitle[rowTitle.length-i]);
        	    dataTableRow = dataTableBody.rows[wRowNum];
        	    rowHeadTableRow = rowHeadTableBody.rows[wRowNum];
        	    colHeadTableRow = colHeadTableBody.rows[wRowNum];
        	    fixCellTableRow = fixCellTableBody.rows[wRowNum];
        	    
        	    for (var j = 0; j < this.headCols; j++){
        	        var wColNum = j;
        		
                    wCell = dataTableRow.cells[wColNum];
                    wCell.innerText = wHeadData[j];
                    wCell.setAttribute("value", wHeadData[j]);
        	        
                    wCell = rowHeadTableRow.cells[wColNum];
                    wCell.innerText = wHeadData[j];
                    wCell.setAttribute("NeedDel", (wColNum > 0 && 
                    		(wHeadData[j] == wHeadData[j - 1]) &&
                    		(wHeadData[j - 1] != (wHeadData1 != "" ? wHeadData1[j - 1] : "")) ? "true" : "false"));
                    
                    wCell = colHeadTableRow.cells[wColNum];
                    wCell.innerText = wHeadData[j];
                    wCell.setAttribute("NeedDel", (wColNum > 0 && 
                    		(wHeadData[j] == wHeadData[j - 1]) &&
                    		(wHeadData[j - 1] != (wHeadData1 != "" ? wHeadData1[j - 1] : "")) ? "true" : "false"));
                    
                    wCell = fixCellTableRow.cells[wColNum];
                    wCell.innerText = wHeadData[j];
                    wCell.setAttribute("NeedDel", (wColNum > 0 && 
                    		(wHeadData[j] == wHeadData[j - 1]) &&
                    		(wHeadData[j - 1] != (wHeadData1 != "" ? wHeadData1[j - 1] : "")) ? "true" : "false"));
        	    }
        	}
    	}
    	
        return;
    };

    CrossSheetV.prototype.makeRowTitles = function(stepNum, decimal, startNum){
        // functionname : [CrossSheetV.makeRowTitles]

        var wStartNum = startNum[0];
        var wArrHeadDatas = this.stepHeadDatas[stepNum];
    	var wRCs = "";

    	var dataTableBody = this.dataTable.tBodies[0];
    	var rowHeadTableBody = this.rowHeadTable.tBodies[0];
    	var wCell = null;
    	
    	for (var i = 0; i < wArrHeadDatas.length; i++){
    	    var wRowNum = wStartNum + i;
    	    var wSheetRowNum = wRowNum - this.headRows + 1; 
    	    var wHeadData = wArrHeadDatas[i];
        
    	    for (j = 0; j < this.headCols; j++){
    	        var wColNum = j;
        
                wCell = dataTableBody.rows[wRowNum].cells[wColNum];
                if (typeof wCell == "undefined") continue;
                wCell.innerText = wHeadData.captions[j];
                wCell.setAttribute("value", wHeadData.values[j]);
                wCell.setAttribute("NeedDel", (wColNum > 0 && wHeadData.values[j] == wHeadData.values[j - 1] && wHeadData.captions[j] == wHeadData.captions[j - 1] ? "true" : "false"));
    	        
                wCell = rowHeadTableBody.rows[wRowNum].cells[wColNum];
                wCell.innerText = wHeadData.captions[j];
                wCell.setAttribute("NeedDel", (wColNum > 0 && wHeadData.values[j] == wHeadData.values[j - 1] && wHeadData.captions[j] == wHeadData.captions[j - 1] ? "true" : "false"));
    	    }

    	    for (var wColNum = this.headCols; wColNum < this.maxCols + this.headCols; wColNum++){
    	        wCell = dataTableBody.rows[wRowNum].cells[wColNum];
    	        wCell.setAttribute("decimal", decimal);
    	        if (wHeadData.Level > 1)
    	            wCell.className = "CSumBack" + wHeadData.Level + " CSumLineR" + wLevel;
    	    }
        
            if (wHeadData.childInfo == "NONE") {
                if (wRCs.length > 0) wRCs += ",";
                wRCs += "CELL(\"R" + wRowNum + "CXX\")";
            }

    	    wRowNum++;
    	}

    	this.stepRCs[stepNum] = wRCs;
    	startNum[0] = wRowNum;
        return;
    };

    CrossSheetV.prototype.fillRowData = function(stepNum, stepObject){
        // functionname : [CrossSheetV.fillRowData]

        var wStartNum = this.stepstartNums[stepNum];
        var wFieldPoint = stepObject.fieldPoint;
        var wColLevelCnt = this.colLevelCnt;
        var wRowLevelCnt = stepObject.levelCnt;
        
        var keyCount     = 0;
        var headKeyCount = 0;
        var bodyKeyCount  = 0;

        var wArrDatas = stepObject.datas;
	    // key count 계산
        if (wArrDatas.length >= 1){
            for (var i = 1; wArrDatas[0].length;i++) {
            	if (wArrDatas[0][i] == null) break; 
            	keyCount++;
            }
        }
        
        // 첫데이터로 셀타입을 판단한다 
        if (stepObject.datas.length == 0){
    		stepObject.cellType = CELLTYPE_FLOAT;

        } else if (stepObject.datas[0].length == 0){
    		stepObject.cellType = CELLTYPE_FLOAT;
    		
    	} else if (("" + stepObject.datas[0][0]).isNum()){
            stepObject.cellType = CELLTYPE_FLOAT;
        } else {
            stepObject.cellType = CELLTYPE_EDIT;
        }

	    // 시트 해더 데이터를 정렬한다 
	    var startKeyPos = wColLevelCnt - wFieldPoint;
        if (this.headDatasSorted == null){
	    	this.headDatasSorted = sortedArrayWithOrderTag(this.headDatas, startKeyPos, wColLevelCnt, wRowLevelCnt);
	    }
        var wArrHeadDatas1 = this.headDatasSorted;
        
        startKeyPos = wRowLevelCnt - (keyCount - wFieldPoint);
	    var wArrHeadDatas2 = stepObject.headDatasSorted = sortedArrayWithOrderTag(this.stepHeadDatas[stepNum], startKeyPos, wRowLevelCnt, wStartNum);
	    
        headKeyCount = wFieldPoint;
        bodyKeyCount = keyCount - wFieldPoint;
        
        // 내부변수 선언 
        var wData = null; var wValue = null; var wWorkKey = null;
        var wData1 = null; var wCompKey = null;
        var wColNum = -1; var wRowNum = -1; 
        
        var wColArrData = null; var wRowArrData = null; 
        var dataTableBody = this.dataTable.tBodies[0];
    
        for (var i = 0; i < wArrDatas.length; i++){
            wData = wArrDatas[i];
            wValue = wData[0];

            // 칼럼번호 찾기 
            wWorkKey = wData.slice(1, wFieldPoint + 1); 
            wColArrData = searchArray(wArrHeadDatas1, wWorkKey);
            wColNum = (wColArrData != null ? wColArrData[wColArrData.length - 1] : -1);
            
            // 줄번호 찾기
            if (!stepObject.isSQL){
                wRowNum = wStartNum;
            } else {
                wWorkKey = wData.slice(headKeyCount + 1, keyCount + 1); 
                wRowArrData = searchArray(wArrHeadDatas2, wWorkKey);
                wRowNum = (wRowArrData != null ? wRowArrData[wRowArrData.length - 1] : -1);
            }
            
            	
            if (wRowNum >= 0 && wColNum >= 0){
                var wCell = dataTableBody.rows[wRowNum].cells[wColNum];
                wCell.setAttribute("value", wValue);
                if (("" + wValue).isNum())  { 
                	var decemal = parseInt(1 * wCell.getAttribute("decimal"));
                    wCell.innerText = mask(wValue, "###,###,###,###,##0" + (decemal > 0 ? ".0000000000".substring(0, decemal + 1) : ""));
                    wCell.align     = "right";
                } else { 
                    wCell.innerText = wValue;
                    wCell.align     = "left";
                }
            }
        }

        if (wWorkKey) wWorkKey.clear();
//        if (wArrHeadDatas2) wArrHeadDatas2.clear(); 
//        wArrHeadDatas2 = null;
        
        return;
    };

    CrossSheetV.prototype.makeRowFormula = function(stepNum, stepObject){
        // functionname : [CrossSheetV.makeRowFormula]
    	
        var dataTableRows = this.dataTable.tBodies[0].rows;
        
        // 산식중 괄호를 찾아낸다
        var wFormula = stepObject.datas[0][0];
        while (wFormula.indexOf("( ") >= 0) wFormula.replaceWord("( ","(");
        while (wFormula.indexOf(" )") >= 0) wFormula.replaceWord(" )",")");
        
        // 괄호의 내용을 RC타입의 ","문자 연결열로 변환한다.
        // R은 변화하고 C는 고정이다 RnCXX로 
        for (var wStepNum = 1; wStepNum < this.stepRCs.length; wStepNum++){
           while (wFormula.indexOf("(" + wStepNum + ")") >= 0) 
               wFormula = wFormula.replaceWord("(" + wStepNum + ")","(" + this.stepRCs[wStepNum] + ")");
        }
        
        // 칼럼별로 루핑하며 산식을 넣는다(합계셀은 제외)
        // RnCXX의 XX를 칼럼번호로 변환
        var wStartNum = this.stepstartNums[stepNum];

        var wRowLevelCnt = stepObject.levelCnt;
        for (var i = 0; i < this.headDatas.length; i++){
            if (this.headDatas[i].childInfo == "NONE"){
                var wHardRowNum = wStartNum;
                var wHardColNum = this.headCols + i;
                var wColNum = i + 1;
                
                var wCell = dataTableRows[wHardRowNum].cells[wHardColNum];
                wCell.setAttribute("formula", wFormula.replaceWord("XX" , wHardColNum + ""));
                // this.addToFormulaRefs(wRowNum, wColNum, wCell.formula);
            }
        }
        return;
    };


    CrossSheetV.prototype.makeColSums = function(){
        // functionname : [CrossSheetV.makeColSums]

        var wArrHeadDatas = this.headDatas;
        var dataTableRows = this.dataTable.tBodies[0].rows;
    	
    	for (var i = 0; i < wArrHeadDatas.length; i++){
    	    var wColNum = i + this.headCols;
    	    var wHeadData = wArrHeadDatas[i];
            
            // 산식을 먼저 만든다. 
            if (wHeadData.childInfo != "NONE"){
                var wArrColNums = wHeadData.childInfo.split(",");
                var wFormula = "";
                var wLastRC  = "";
                for (var j = 0; j < wArrColNums.length; j++){
                    if (j > 0) wFormula += ",";
                    var wwColNum = parseInt(wArrColNums[j]) + this.headCols - 1;

                    wFormula += "CELL(\"RXXC" + wwColNum + "\")";
                    wLastRC   = "CELL(\"RXXC" + wwColNum + "\")";
                }
                                
                if (wHeadData.functionName == getText("message_crosssheetv_010", "합계") || wHeadData.functionName == getText("message_crosssheetv_016", "Sum")){
                    wFormula = "SUM(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheetv_011", "평균") || wHeadData.functionName == getText("message_crosssheetv_017", "Average")){
                    wFormula = "AVG(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheetv_012", "최대값") || wHeadData.functionName == getText("message_crosssheetv_018", "Max Value")){
                    wFormula = "MAX(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheetv_013", "최소값") || wHeadData.functionName == getText("message_crosssheetv_019", "Min Value")){
                    wFormula = "MIN(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheetv_014", "최종값") || wHeadData.functionName == getText("message_crosssheetv_020", "Last value")){
                    wFormula = wLastRC;
                }
                
                // 셀에 산식값 
                for (var j = 0; j < this.maxRows; j++){
                    var wRowNum = this.headRows + j;
                    var wSheetRowNum = j + 1;
                    var wCell = dataTableRows[wRowNum].cells[wColNum];
                    wCell.setAttribute("formula", wFormula.replaceWord("XX" , wRowNum + ""));
                    
                    // this.addToFormulaRefs(wRowNum, wColNum, wCell.formula);
                }
            }
            
    	}

        return;
    };
    
    CrossSheetV.prototype.makeStepSums = function(stepNum){
        // functionname : [CrossSheetV.makeStepSums]

        var wStartNum = this.stepstartNums[stepNum];
        var wArrHeadDatas = this.stepHeadDatas[stepNum];
    	var dataTableRows = this.dataTable.tBodies[0].rows;

    	for (var i = 0; i < wArrHeadDatas.length; i++){
    	    var wRowNum = wStartNum + i;
    	    var wHeadData = wArrHeadDatas[i];
    	    
            // 산식을 먼저 만든다. 
            if (wHeadData.childInfo != "NONE"){
                var wArrRowNums = wHeadData.childInfo.split(",");
    	    
                var wFormula = "";
                var wLastRC  = "";
                for (var j = 0; j < wArrRowNums.length; j++){
                    if (j > 0) wFormula += ",";
                    wFormula += "CELL(\"R" + (wStartNum + parseInt(wArrRowNums[j], 10) - 1) + "CXX\")";
                    wLastRC   = "CELL(\"R" + (wStartNum + parseInt(wArrRowNums[j], 10) - 1) + "CXX\")";
                }
                
                if (wHeadData.functionName == getText("message_crosssheetv_010", "합계") || wHeadData.functionName == getText("message_crosssheetv_016", "Sum")){
                    wFormula = "SUM(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheetv_011", "평균") || wHeadData.functionName == getText("message_crosssheetv_017", "Average")){
                    wFormula = "AVG(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheetv_012", "최대값") || wHeadData.functionName == getText("message_crosssheetv_018", "Max Value")){
                    wFormula = "MAX(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheetv_013", "최소값") || wHeadData.functionName == getText("message_crosssheetv_019", "Min Value")){
                    wFormula = "MIN(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheetv_014", "최종값") || wHeadData.functionName == getText("message_crosssheetv_020", "Last value")){
                    wFormula = wLastRC;
                }
                
                // 셀에 산식값 
                for (var j = 0; j < this.maxCols; j++){
                    var wColNum = this.headCols + j;
                    var wSheetColNum = j + 1;
                    var wCell = dataTableRows[wRowNum].cells[wColNum];
                    wCell.setAttribute("formula", wFormula.replaceWord("XX" , wColNum + ""));
                    // this.addToFormulaRefs(wRowNum, wColNum, wCell.formula);
                }
            }
            
    	}

        return;
    };
    
    CrossSheetV.prototype.makeStepRemarks = function(stepNum, remark){
        // functionname : [CrossSheetV.makeStepRemarks]

        if (this.remarkCols == 0) return;
        if ((remark || "").trim().length == 0) return;
        
        var dataTableRows = this.dataTable.tBodies[0].rows;
        
        var wStartNum = this.stepstartNums[stepNum];
        var wEndNum = (stepNum < this.stepstartNums.length - 1 ? this.stepstartNums[stepNum + 1] - 1: this.headRows + this.maxRows - 1);
        
    	var wDataTable = this.dataTable;    
    	for (var i = wStartNum; i <= wEndNum; i++){
            var wRowNum = i;
            var wColNum = this.headCols + this.maxCols + this.remarkCols - 1;
    	    
            if (i == wEndNum)
            	dataTableRows[wRowNum].cells[wColNum].innerText = remark;
    	}
        return;
    };

    CrossSheetV.prototype.adjustColWidth = function(){
        // functionname : [CrossSheetV.adjustColWidth]

    	var dataTableRows = this.dataTable.tBodies[0].rows;
    	var colTableRows = this.colHeadTable.tBodies[0].rows;
    	var rowTableRows = this.rowHeadTable.tBodies[0].rows;
    	var fixTableRows = this.fixCellTable.tBodies[0].rows;
    	
    	//for (var wColNum = this.headCols; wColNum < this.headCols + this.maxCols + this.remarkCols; wColNum++){
    	for (var wColNum = 0; wColNum < this.headCols + this.maxCols + this.remarkCols; wColNum++){
        	var wMaxLen = 50;
        	//for (var wRowNum = this.headRows; wRowNum < this.headRows + this.maxRows; wRowNum++){
//        	for (var wRowNum = 0; wRowNum < this.headRows + this.maxRows; wRowNum++){
//     		for (var wRowNum = 0; wRowNum < this.headRows + this.maxRows + this.remarkRows; wRowNum++){
        	for (var wRowNum = (this.headRows-1); wRowNum < this.headRows + this.maxRows + this.remarkRows; wRowNum++){
//                var wText = dataTableRows[wRowNum].cells[wColNum].innerText || "0";
//                var wByteLength = wText.bytes();
//                var WIDTH_PLUS = ((/[A-Z]/).test(wText) ? 1 : 0);	// 문자에 대문자가 있는 경우 폰트를 +1 해준다
//        	    wMaxLen = (wMaxLen < wByteLength * (FONT_WIDTH + WIDTH_PLUS) ? wByteLength * (FONT_WIDTH + WIDTH_PLUS) : wMaxLen);
       			var wTextPixel = this.getTextLengthInPixel(dataTableRows[wRowNum].cells[wColNum]);
       			wMaxLen = (wMaxLen < wTextPixel ? wTextPixel : wMaxLen);
    	    } 
        	
//        	wMaxLen += 10;	//2019-03-28 jaeik 좌우padding 사이즈 만큼 늘려줌
        	wMaxLen += 20;	//2019-12-03 jaeik 좌우padding 사이즈 만큼 늘려줌
    	    
            // 헤드 칼럼들만의 사이즈를 조정한다
        	for (var wRowNum = 0; wRowNum < this.headRows; wRowNum++){
        		dataTableRows[wRowNum].cells[wColNum].style.width = wMaxLen + "px";
        		colTableRows[wRowNum].cells[wColNum].style.width = wMaxLen + "px";
        		dataTableRows[wRowNum].cells[wColNum].style.maxWidth = wMaxLen + "px";
        		colTableRows[wRowNum].cells[wColNum].style.maxWidth = wMaxLen + "px";
                if (wColNum < this.headCols){
                	dataTableRows[wRowNum].cells[wColNum].style.width = wMaxLen + "px";
                	colTableRows[wRowNum].cells[wColNum].style.width = wMaxLen + "px";
                	rowTableRows[wRowNum].cells[wColNum].style.width = wMaxLen + "px";
                	fixTableRows[wRowNum].cells[wColNum].style.width = wMaxLen + "px";
                }
    	    } 
    	}
    	
    	// 테이블 사이즈 조정
    	this.adjustTableWidth();
    	
        return;
    };
    
    CrossSheetV.prototype.getTextLengthInPixel = function(cell) {
        var myId = 'my_span_ruler';
        var ruler = document.getElementById(myId);
       
        if (!ruler) {
            ruler = document.createElement('span');
            ruler.id = myId;
            // 안보이게
            ruler.setAttribute('style', 'visibility:hidden; white-space:nowrap; position:absolute; left:-9999px; top: -9999px;');
            document.body.appendChild(ruler);
        }
       
        // 폰트 스타일
        ruler.style.font = getComputedStyle(cell).font;
        ruler.innerText = cell.innerText || "0";
       
        return ruler.offsetWidth;
    };
    
    CrossSheetV.prototype.adjustTableWidth= function(){
        // functionname : [CrossSheetV.adjustTableWidth]

    	var wTableWidth = GAP_BETWEEN_CELL;
    	var wTableWidth1 = GAP_BETWEEN_CELL;
    	var wTableWidthString = "";

        var wDataTableBody = this.dataTable.tBodies[0];
        var wMaxColNum = wDataTableBody.rows[0].cells.length;
        for (var wColNum = 0; wColNum < wMaxColNum; wColNum++){
    	    var wWidth = parseIntSize(wDataTableBody.rows[0].cells[wColNum].style.width);
    	    wTableWidth += wWidth + (wWidth == 0 ? 0 : GAP_BETWEEN_CELL);
    	    if (wColNum < this.headCols) 
    	    	wTableWidth1 += wWidth + (wWidth == 0 ? 0 : GAP_BETWEEN_CELL);
    	    wTableWidthString += (wColNum == 0 ? "" : ";") + wWidth;
        }
    
    	this.tagObject.setAttribute("cellSize", wTableWidthString);
        this.dataTable.style.width = wTableWidth + "px";
        this.colHeadTable.style.width = wTableWidth + "px";
        this.rowHeadTable.style.width = wTableWidth1 + "px";
        this.fixCellTable.style.width = wTableWidth1 + "px";
        return;    
    };
    
    CrossSheetV.prototype.setRowTitleMerge = function(tableBody){
    	// functionname : [CrossSheetH.setRowTitleMerge]
    	
    	var wColSpan = 1;
    	for (var wRowNum = 0; wRowNum < this.headRows; wRowNum++){
    	    var wRow = tableBody.rows[wRowNum];
    	    
    	    for (var i = this.headCols-1; i >= 0; i--) {
       	    	var col = wRow.cells[i];
       	    	var wWidthToAdd = 0;
       	    	
       	    	if (col.getAttribute("NeedDel") == "false") {
       	    		wColSpan = 1;
           	    	for (var wColNum = i+1; wColNum < this.headCols; wColNum++) {
               	    	var wCell = wRow.cells[wColNum];
               	    	if (wCell.getAttribute("NeedDel") == "false") break;
            	        if (wCell.getAttribute("NeedDel") == "true" || wCell.innerText == ""){
            	        	wWidthToAdd += (parseIntSize(wCell.style.width) + GAP_BETWEEN_CELL);
            	        	wColSpan++;
            	        }
               	    }
       	    	}
           	    
       	    	if (wColSpan > 1) {
       	    		col.colSpan = wColSpan;
           	    	col.style.width = (parseIntSize(col.style.width) + wWidthToAdd) + "px";
       	    	}
       	    }
       	    
           	 for (var wColNum = this.headCols-1; wColNum >= 0; wColNum--) {
        	    	var wCell = wRow.cells[wColNum];
     	        if (wCell.getAttribute("NeedDel") == "true" || wCell.innerText == ""){
     	        	wRow.deleteCell(wColNum);
     	        }
    	    }        	    
        }
    };
    
    CrossSheetV.prototype.setColHeadSpan = function(noneCaption){
        // functionname : [CrossSheetV.setColHeadSpan]

        var wArrHeadDatas = this.headDatas;
        var wColHeadTableBody = this.colHeadTable.tBodies[0];

        for (var wLevel = 1; wLevel < this.headRows; wLevel++){
            var wRowNum = wLevel;
            var wColSpan = 1;
            var wWidthToAdd = 0;
            
    	    for (var i = wArrHeadDatas.length - 1; i >= 0; i--){ 
                var wColNum = this.headCols + i;
                var wHeadData  = wArrHeadDatas[i];
                var wHeadData0 = new HeadData(); // 0일때 에러방지
                if (i > 0){
                    wHeadData0 = wArrHeadDatas[i - 1] ; 
                }

                var wChecked = true;
                for (var j = 0; j <= wLevel - 1; j++)
                    wChecked = wChecked && (wHeadData.values[j] == wHeadData0.values[j]);
                
                if (wChecked){
                    wWidthToAdd += parseIntSize(wColHeadTableBody.rows[wRowNum].cells[wColNum].style.width) + GAP_BETWEEN_CELL;
                    wColHeadTableBody.rows[wRowNum].deleteCell(wColNum);
                    wHeadData.merged[wRowNum] = "Y";
                    
                    wColSpan++;
                } else {
                    var wCell = wColHeadTableBody.rows[wRowNum].cells[wColNum];
                    wCell.colSpan = wColSpan;
                    wCell.style.width = (parseIntSize(wCell.style.width) + wWidthToAdd)  + "px";
                    
                    wColSpan = 1;
                    wWidthToAdd = 0;
                    
                    var wRowSpan = 1;
                    for (var j = wRowNum + 1; j <= this.headRows; j++)
                         wRowSpan += (wHeadData.values[j] == "" ? 1 : 0);

                    if (wRowSpan > 1){
                        wCell.rowSpan = wRowSpan;
                    }
                }
            }
        }
        
    	for (var wRowNum = 1; wRowNum <= this.headRows; wRowNum++){
    	    var wRow = wColHeadTableBody.rows[wRowNum];
    	    for (var wColNum = wRow.cells.length - 1; wColNum >= this.headCols; wColNum--){
    	        if (wRow.cells[wColNum].getAttribute("NeedDel") == "true" || wRow.cells[wColNum].innerText == ""){
    	            wRow.deleteCell(wColNum);
    	        }
    	    }
        }
    	
    	/**
       	 * 2019-06-19 jaeik 로우타이틀 colTable,fixedTable 병합처리
       	 */
       	var rowTitle = this.dataObject.head.rowTitle;
    	if (rowTitle != null && rowTitle.length > 0) {
    		this.setRowTitleMerge(wColHeadTableBody);
    		this.setRowTitleMerge(this.fixCellTable.tBodies[0]);    		
    	}
        
        if (this.remarkCols > 0){
            var wColNum = wColHeadTableBody.rows[1].cells.length - 1;
            
            var wCell = wColHeadTableBody.rows[1].cells[wColNum];
            wCell.innerText = getText("message_crosssheetv_021", "비고");
            wCell.rowSpan = this.headRows;
            
            var dataTableBody = this.dataTable.tBodies[0];
            var wColNum2 = dataTableBody.rows[1].cells.length - 1;
            var rows = dataTableBody.rows;
            for (var wRowNum = 0; wRowNum < this.headRows; wRowNum++){
            	rows[wRowNum].cells[wColNum2].innerText = wCell.innerText;
            }
            
            for (var wRowNum = 2; wRowNum <= this.headRows; wRowNum++){
                wColNum = wColHeadTableBody.rows[wRowNum].cells.length - 1;
                wColHeadTableBody.rows[wRowNum].deleteCell(wColNum);
            }
        }        
        
        return;
    };
    
    CrossSheetV.prototype.setRowHeadSpans = function(stepNum, levelCnt, noneCaption, titleBySQL){
        // functionname : [CrossSheetV.setRowHeadSpans]

        var wStartNum = this.stepstartNums[stepNum];
        var wEndNum = (stepNum < this.stepstartNums.length - 1 ? this.stepstartNums[stepNum + 1] - 1: this.headRows + this.maxRows - 1);
	    var wRows = this.rowHeadTable.tBodies[0].rows;
        var wArrHeadDatas = this.stepHeadDatas[stepNum];
        
        var wRowTableBody = this.rowHeadTable.tBodies[0];
        for (var wLevel = levelCnt -1; wLevel >= 1; wLevel--){
            var wColNum = wLevel - 1;
            var wRowSpan = 1;
        
    	    for (var i = wArrHeadDatas.length - 1; i >= 0; i--){ 
                var wRowNum = wStartNum + i;
                var wHeadData  = wArrHeadDatas[i];
                var wRow = wRowTableBody.rows[wRowNum];
                var wCell = wRow.cells[wColNum];
                if (typeof wCell == "undefined") continue;
        
                var wHeadData0 = new HeadData(); // 0일때 에러방지
                if (i > 0){
                    wHeadData0 = wArrHeadDatas[i - 1] ; // 0일때 에러방지
                }
                
                var wChecked = true;
                for (var j = 0; j <= wColNum; j++)
                	wChecked = wChecked && (wHeadData.values[j] == wHeadData0.values[j]) && (wHeadData.captions[j] == wHeadData0.captions[j]);
                
                if (wChecked){
                    wRow.deleteCell(wColNum);
                    wHeadData.merged[wColNum] = "Y";
                    
                    wRowSpan++;

                } else {
                    if (wRowSpan > 1) wCell.rowSpan = wRowSpan;
                    wRowSpan = 1;

                    var wColSpan = 1;
                    for (var j = wColNum + 1; j <= this.headCols - 1; j++){
                        wColSpan += (wHeadData.values[j] == "" ? 1 : 0);
                    }
                    if (wColSpan > 1)  {
                        wCell.colSpan = wColSpan;
                    }
                }
            }
        }
        
        if (!titleBySQL){  // 쿼리에 의하지 않고 인위적으로 타이틀을 만든 경우라면 
            var wRowNum = wStartNum;
    	    var wRow = wRows[wRowNum];
    	    var wColSpan = 1;

    	    for (var wColNum = wRow.cells.length -1 ; wColNum > 0; wColNum--){
    	        var wCell = wRow.cells[wColNum];
    	        if (wCell.getAttribute("NeedDel") == "true" || wCell.innerText == ""){
    	            wColSpan++;
    	        }
    	    }
    	    wRow.cells[0].colSpan = wColSpan;
        }
        
        for (var wRowNum = wStartNum; wRowNum <= wEndNum; wRowNum++){
    	    var wRow = wRows[wRowNum];
    	    var wColSpan = 1;
    	    for (var wColNum = wRow.cells.length -1 ; wColNum >= 0; wColNum--){
    	        var wCell = wRow.cells[wColNum];
    	        if (wCell.getAttribute("NeedDel") == "true" || wCell.innerText == ""){
    	            wRow.deleteCell(wColNum);wColSpan++;
    	        } else {
    	            if (wColSpan > 1) {
    	                wCell.colSpan = wColSpan;
    	                wColSpan = 1;
    	            }
    	        }
    	    }
        }
//        for (var wRowNum = wStartNum; wRowNum <= wEndNum; wRowNum++){
//    	    var wRow = wRows[wRowNum];
//    	    for (var wColNum = wRow.cells.length -1 ; wColNum >= 0; wColNum--){
//    	        var wCell = wRow.cells[wColNum];
//    	        if (wCell.getAttribute("NeedDel") == "true" || wCell.innerText == ""){
//    	            wRow.deleteCell(wColNum);
//    	        }
//    	    }
//        }
        return;
    };

    // 여기서 부터는 열숨기기
    CrossSheetV.prototype.hideChildCols = function(cell, showAction){
        // functionname : [CrossSheetV.hideChildCols]


        var wRowNum = cell.parentNode.rowIndex;
        var wColNum = cell.cellIndex;
        
        var wHeadIndex = this.findHeadIndex(wColNum, wRowNum);
        
        var wArrHeadDatas = this.headDatas;
        var wKeyData = ["","","","",""];
           
        var wHeadData = wArrHeadDatas[wHeadIndex];
        for (var j = 0; j <= pLevelNum; j++){
            wKeyData[j] = wHeadData.values[j];
        } 
        
        for (var wHeadIndex = 0; wHeadIndex < this.headDatas.length; wHeadIndex++){
            if (wArrHeadDatas[wHeadIndex].values[pLevelNum].length == 0) continue;

            var wChecked = true;
            var wHeadDataTo = wArrHeadDatas[wHeadIndex];
            for (var j = 0; j <= pLevelNum; j++){
                wChecked = wChecked && (wKeyData[j] == wHeadDataTo.values[j]);
            } 

            if (wChecked && showAction == ACTION_HIDE) {
                this.hideCol(wHeadIndex);
            } else if (wChecked && showAction == ACTION_SHOW) {
                this.showCol(wHeadIndex);
            }
        }
        
        // 전체 테이블 크기정보 갱신
    	this.adjustTableWidth();
    };
    
    CrossSheetV.prototype.hideColLevels = function(levelCount, levelNum){
        // functionname : [CrossSheetV.hideColLevels]

        var wArrHeadDatas = this.headDatas;
        var wKeyData = ["","","","",""];

        for (var i = 0; i < this.headDatas.length; i++){
            if (!wArrHeadDatas[i].hideChild) continue;
            
            var wHeadData = wArrHeadDatas[i];
            for (var j = 0; j < levelNum; j++){
                wKeyData[j] = wHeadData.values[j];
            } 
            
            for (var wHeadIndex = 0; wHeadIndex < this.headDatas.length; wHeadIndex++){
                if (wArrHeadDatas[wHeadIndex].values[levelNum].length == 0) continue;

                var wChecked = true;
                var wHeadDataTo = wArrHeadDatas[wHeadIndex];
                for (var j = 0; j < levelNum; j++){
                    wChecked = wChecked && (wKeyData[j] == wHeadDataTo.values[j]);
                } 
                
                if (wChecked) this.hideCol(wHeadIndex);
            }
        }
        
        // 전체 테이블 크기정보 갱신
    	this.adjustTableWidth();
    	
        return;
    };
    
    CrossSheetV.prototype.hideCol = function(headIndex){
        // functionname : [CrossSheetV.hideCol]

        // 최소레벨부터 상위레벨로 돌면서 셀사이즈를 줄여나간다
        var wColNum = this.headCols + headIndex;
        var wWidth = parseIntSize(this.dataTable.tBodies[0].rows[0].cells[wColNum].style.width) + "px";
        wCell.setAttribute("oldWidth", wWidth);
        
        for (var wLevel = 1; wLevel <= this.colLevelCnt; wLevel++){
            var wRowNum = wLevel - 1;
            var wCellIndex = this.FindCellIndex(headIndex, wLevel - 1);
            if (wCellIndex >= 0){
        	    wCell = this.colHeadTable.tBodies[0].rows[wRowNum].cells[this.headCols +wCellIndex];
                var wCurrnetWidth = parseIntSize(wCell.style.width);
                wCell.style.width = (wCurrnetWidth - wWidth 
                                  - (wCurrnetWidth > wWidth ? GAP_BETWEEN_CELL : 0)) + "px";
                
            }
        }
        
        for (var wRowNum = 0; wRowNum < this.dataTable.tBodies[0].rows.length; wRowNum++){
            this.dataTable.tBodies[0].rows[wRowNum].cells[wColNum].style.width = 0 + "px";
        }
        
        return;
    };
    
    CrossSheetV.prototype.showCol = function(headIndex){
        // functionname : [CrossSheetV.showCol]

        // 최소레벨부터 상위레벨로 돌면서 셀사이즈를 줄여나간다
        var wColNum = this.headCols + headIndex;
        var wWidth = parseIntSize(this.dataTable.tBodies[0].rows[wRowNum].cells[wColNum].oldWidth);
        
        for (var wLevel = 1; wLevel <= this.colLevelCnt; wLevel++){
            var wRowNum = wLevel - 1;
            var wHardColNum = this.headCols + this.FindCellIndex(headIndex, wLevel);

    	    wCell = this.colHeadTable.tBodies[0].rows[wRowNum].cells[wHardColNum];
            wCell.style.width = (parseIntSize(wCell.style.width) + wWidth) + "px";
        }
        for (var wRowNum = 0; wRowNum < this.dataTable.tBodies[0].rows.length; wRowNum++){
            this.dataTable.tBodies[0].rows[wRowNum].cells[wColNum].style.width = wWidth + "px";
        }
        
        return;
    };
    
    // 좌측상단의 셀을 통합한다
    CrossSheetV.prototype.mergeUpperMost = function(){
        // functionname : [CrossSheetH.mergeUpperMost]

        var wTable = this.fixCellTable;
        var firstRow  = wTable.tBodies[0].rows[0];
        var firstCell = firstRow.cells[0];
        var wHeight = 0;
        var wWidth  = parseIntSize(wTable.style.width);
        
        for (var wRow = 0; wRow < wTable.tBodies[0].rows.length; wRow++){
            wHeight += parseIntSize(wTable.tBodies[0].rows[0].style.height) + GAP_BETWEEN_CELL; 
        }

        var wTable = this.fixCellTable;
        for (var wRow = wTable.tBodies[0].rows.length - 1; wRow > 0; wRow--){
                wTable.deleteRow(wRow);
        }
        
        var wRow = wTable.tBodies[0].rows[0];
        wRow.style.display = "";
        for (var wColNum = wRow.cells.length - 1; wColNum > 0; wColNum--){
                wRow.deleteCell(wColNum);
        }
        firstCell.style.width = wWidth + "px";
        firstRow.style.height = wHeight + "px";
        return;
    };
    
    // 여기서 부터는 줄숨기기
    CrossSheetV.prototype.hideStepChildRows = function(cell, showAction){
        // functionname : [CrossSheetV.hideStepChildRows]

        var wRowNum = cell.parentNode.rowIndex;
        var wColNum = cell.cellIndex;
        
        var wStepNum = this.findStepNum(wRowNum, wColNum);
        var wHeadIndex = this.findHeadIndex(wRowNum, wColNum, wStepNum);
        
        var wArrHeadDatas = this.stepHeadDatas[wStepNum];
        var wKeyData = ["","","","",""];
           
        var wHeadData = wArrHeadDatas[wHeadIndex];
        for (var j = 0; j <= levelNum; j++){
            wKeyData[j] = wHeadData.values[j];
        } 
        
        for (var wHeadIndex = 0; wHeadIndex <= this.headDatas.length; wHeadIndex++){
            if (wArrHeadDatas[wHeadIndex].values[levelNum].length == 0) continue;

            var wChecked = true;
            var wHeadDataTo = wArrHeadDatas[wHeadIndex];
            for (var j = 0; j <= levelNum; j++){
                wChecked = wChecked && (wKeyData[j] == wHeadDataTo.values[j]);
            } 
            
            if (wChecked && showAction == ACTION_HIDE) {
                this.hideRow(wHeadIndex, wStepNum);
            } else if (wChecked && showAction == ACTION_SHOW) {
                this.showRow(wHeadIndex, wStepNum);
            }
        }
        
        return;
    };
    
    CrossSheetV.prototype.hideStepRowLevels = function(levelCount, levelNum, stepNum){
        // functionname : [CrossSheetV.hideStepRowLevels]

        var wArrHeadDatas = this.stepHeadDatas[stepNum];
        var wKeyData = ["","","","",""];
        
        for (var i = 0; i <= this.headDatas.length; i++){
            if (!wArrHeadDatas[i].hideChild) continue;
            
            var wHeadData = wArrHeadDatas[i];
            for (var j = 0; j <= levelNum; j++){
                wKeyData[j] = wHeadData.values[j];
            } 
            
            for (var wHeadIndex = 0; wHeadIndex <= this.headDatas.length; wHeadIndex++){
                if (wArrHeadDatas[wHeadIndex].values[levelNum].length == 0) continue;

                var wChecked = true;
                var wHeadDataTo = wArrHeadDatas[wHeadIndex];
                for (var j = 0; j <= levelNum; j++){
                    wChecked = wChecked && (wKeyData[j] == wHeadDataTo.values[j]);
                } 
                
                if (wChecked) this.hideRow(wHeadIndex, stepNum);
            }
        }
    	
        return;
    };
    
    CrossSheetV.prototype.hideRow = function(headIndex, stepNum){
        // functionname : [CrossSheetV.hideRow]

        // 최소레벨부터 상위레벨로 돌면서 셀사이즈를 줄여나간다
        var wRowNum = this.headRows + headIndex;
        
        var wRow = this.dataTable.tBodies[0].rows[wRowNum];
        wRow.oldheight = parseIntSize(wRow.style.height);
        wRow.style.height = 0 + "px";
        
        wRow = this.colHeadTable.tBodies[0].rows[wRowNum];
        wRow.style.height = 0 + "px";
        
        return;
    };
    
    CrossSheetV.prototype.showRow = function(headIndex, stepNum){
        // functionname : [CrossSheetV.showRow]

        // 최소레벨부터 상위레벨로 돌면서 셀사이즈를 줄여나간다
        var wRowNum = this.headRows + headIndex;
        
        var wRow = this.dataTable.tBodies[0].rows[wRowNum];
        var wHeight = wRow.oldheight;
        wRow.style.height = wHeight + "px";
        wRow = this.colHeadTable.tBodies[0].rows[wRowNum];
        wRow.style.height = wHeight + "px";
        
        return;
    };


    CrossSheetV.prototype.findCellIndex = function(headIndex, hardLevel, stepNum){
        // functionname : [CrossSheetV.findCellIndex]

        // stepNum이 생략되면 전체헤더이다
        var wArrHeadDatas = (stepNum ? this.stepHeadDatas[stepNum] : this.headDatas);
        
        // 상하로 머지된 경우 X가 붙는다
        if (wArrHeadDatas[headIndex].merged[hardLevel] == "X") return -1;
        
        var wReturn = -1;
        for (var i = 0; i <= headIndex; i++){
            wReturn += (wArrHeadDatas[i].merged[hardLevel] == "N" ? 1 : 0);
        }
        return wReturn;
    };
    
    CrossSheetV.prototype.findHeadIndex = function(cellIndex, hardLevel, stepNum){
        // functionname : [CrossSheetV.findHeadIndex]

        // stepNum이 생략되면 전체헤더이다
        var wArrHeadDatas = (stepNum ? this.stepHeadDatas[stepNum] : this.headDatas);
        var wReturn = -1; var wIndex = this.headCols - 1;
        for (var i = 0; i < wArrHeadDatas.length; i++){
            wIndex += (wArrHeadDatas[i].merged[hardLevel] ? 0 : 1);
            if (cellIndex >= wIndex) {wReturn = i; break;}
        }
        return wReturn;
    };
    
    CrossSheetV.prototype.findStepNum = function(cellIndex, hardLevel){
        // functionname : [CrossSheetV.findStepNum]

        // stepNum이 생략되면 전체헤더이다
        var wReturn = this.stepstartNums.length - 1; 
        for (var i = 1; i < this.stepstartNums.length; i++){
            if (this.stepstartNums[i] > cellIndex){
                wReturn = i - 1; break;
            }
        }
        return wReturn;
    };
    
    /***************************************************************************
        시트 함수의 동작에관한 부분이다
    ***************************************************************************/
    CrossSheetV.prototype.recalculate = function(){
            // functionname : [CrossSheetV.recalculate]

        for (var wRowNum = 1; wRowNum < this.maxRows + this.headRows; wRowNum++){
            //var wRow = this.dataTable.rows[wRowNum+ this.headRows - 1];
            var wRow = this.dataTable.rows[wRowNum];
            for (var wColNum = 1; wColNum < this.maxCols + this.headCols; wColNum++){
                var wCell = wRow.cells[wColNum];
                //var wCell = wRow.cells[wColNum + this.headCols - 1];
                var wFormula = wCell.getAttribute("formula") || "";
                if (wFormula.length > 0){
                    this.calculateCell(wCell, wFormula);
                }
            }  
        }  
        
        return;
    };
    
    // 자기자신을 먼저 계산후에 다른 참조셀을 바꾼다
    CrossSheetV.prototype.calculateCell = function(cell, formula){
        // functionname : [CrossSheetV.calculateCell]

	    var wFormula = formula || "";

        // wLogic.clear();
    	var wCell = cell;
    	
    	wFormula = this.replaceToEasyFormula(wFormula);
        var wValue = calc(wFormula);

        if (wValue != wCell.getAttribute("value")){
            wCell.setAttribute("value", wValue);
            wCell.align = "right";
            wCell.valign = "middle";
//            wCell.valign = "baseline";
            var decemal = parseInt(1 * wCell.getAttribute("decimal"));
            wCell.innerText = mask(wValue, "###,###,###,###,##0" + (decemal > 0 ? ".0000000000".substring(0, decemal + 1) : "")); 

        }

        return; 
    };
    
    // 산식의 셀문자열에 셀값을 대치하여 준다 예: R1C1 -> "142" 
    CrossSheetV.prototype.replaceToEasyFormula = function(formula){
        // functionname : [CrossSheetV.replaceToEasyFormula]

        // Cell함수를 루핑하면서 계속 찾는다 
	    var wFormula = formula || "";
        // 케리지리턴이나 탭등을 제거한다 
    	wFormula = wFormula.replace(/\r\n/g," ").replace(/\t/g," ").trim();
    	
	    // 대문자로 변환
    	wFormula = wFormula.toUpperCase();
	    
        //--- 메인동작 기능-----------------------------------------------------
        var wArrRange = [0,0,0,0];
        var wMaxRows = this.maxRows;       var wMaxCols = this.maxCols;
	    while (wFormula.indexOf("CELL ") >= 0) wFormula.replaceWord("CELL ","CELL");

	    var wFuncPosition = wFormula.indexOf("CELL(");
	    while (wFuncPosition >= 0){
	        var wEndPosion = wFormula.indexOf(")", wFuncPosition);
	        var wCellString = wFormula.substring(wFuncPosition + 5, wEndPosion); //6은 "CELL("의 길이
	            wCellString = wCellString.replaceWord("\"","");
	        var wValueString = "";
	        
            // 괄호사이의 셀값을 셀값으로 바꾼다(문자와 숫자 셀타입을 구분)
	        var wArrCellRanges = wCellString.split(",");
	        for (var i=0; i < wArrCellRanges.length; i++){
                this.parseRCToRange(wArrCellRanges[i], wArrRange);
                
                for (var wRowNum = wArrRange[0]; wRowNum <= wArrRange[2]; wRowNum++){
                    //var wRow = this.dataTable.rows[wRowNum + this.headRows - 1];
                    var wRow = this.dataTable.rows[wRowNum];
                    for (var wColNum = wArrRange[1]; wColNum <= wArrRange[3]; wColNum++){
                        //var wCell = wRow.cells[wColNum + this.headCols - 1];
                        var wCell = wRow.cells[wColNum];
	                    wValueString += (wValueString.length > 0 ? "," : "") + wCell.getAttribute("value");
	                }
	            }
	        }
	        
	        wFormula = wFormula.substring(0, wFuncPosition) + wValueString + wFormula.substring(++wEndPosion);
	        
	        wFuncPosition = wFormula.indexOf("CELL(");
	    }    

        return wFormula;
    };
    
    /*--------------------------------------------------------------------------
     RC스타일의 문법 (기본 R1C1:R2C3 상대좌표 R[1]C[1]:R[3]C[4] <-커런트 셀기준
     단일셀은 :이 없다 (R1C1  R[1]C[2])
     줄선택은 R1:R2와 같다 열선택은 C1C2와 같이 표현한다
     인수중에 배열은 [Row, Col, Row2, Col2] 이다 결과를 리턴한다
    ----------------------------------------------------------------------------*/
    CrossSheetV.prototype.parseRCToRange = function(RCString, arrRange){
         // functionname : [CrossSheetV.parseRCToRange]

        // 1. 콜론으로 범위값을 분리한다 없으면시작셀값과 같은 값을 준다
        var wArrRanges = RCString.split(":");
        
        // 2. 시작셀을 파싱한다
        //    열번호가 없으면 전체열 선택이다 줄번호가 없으면 전체줄 선택이다 
        var wRange = wArrRanges[0];
        var wRowString = wRange.split("C")[0].substring(1);
        var wColString = wRange.split("C")[1];

        arrRange[0] = parseInt(wRowString, 10);
        arrRange[1] = parseInt(wColString, 10);
        
        if (wArrRanges.length == 1) {
            arrRange[2] = arrRange[0];
            arrRange[3] = arrRange[1];
        } else {
            // 3. 종료셀을 파싱한다 
            wRange = wArrRanges[1];
            wRowString = wRange.split("C")[0].substring(1);
            wColString = wRange.split("C")[1];
            
            arrRange[2] = parseInt(wRowString, 10);
            arrRange[3] = parseInt(wColString, 10);
        }
        
        return;
    };
     /* -----------------------------------------------------------------------
     데이터를 모두채운후에는 스크롤에 테이블 사이즈를 반영한다
     --------------------------------------------------------------------------*/
     CrossSheetV.prototype.resetScroll = function(){

	   	var scrollPanel = this.tagObject.getElementsByTagName("DIV")[0];
	   	var scrollChildPanel = scrollPanel.getElementsByTagName("DIV")[0];
	   	if (this.dataTable.scrollWidth == 0){
	    	var w = 1; 
	   		var h = 1;
	   		var tbody = this.dataTable.tBodies[0];
	   		for (var wRowNum = 0; wRowNum < tbody.rows.length; wRowNum++){
	   			h++;
	   			h += parseIntSize(tbody.rows[wRowNum].style.height);
	   		}
	   		var tr = tbody.rows[0];
	   		for (var wColNum = 0; wColNum < tr.cells.length; wColNum++){
	   			w++;
	   			w += parseIntSize(tr.cells[wColNum].style.width);
	   		}
	   	   	scrollChildPanel.style.width = ++w + "px";
	   	   	scrollChildPanel.style.height = ++h + "px";
	   		
	   	} else {
	   	   	scrollChildPanel.style.width = this.dataTable.scrollWidth + "px";
	   	   	scrollChildPanel.style.height = this.dataTable.scrollHeight + "px";
	   	}
	   	
    	scrollPanel.scrollTop = 0;
    	scrollPanel.scrollLeft = 0;
    };

    /* -----------------------------------------------------------------------
       여기서 부터 크로스 데이터 처리부분이다
    --------------------------------------------------------------------------*/
    CrossSheetV.prototype.analyze = function(dataObject){
        // functionname : [CrossSheetV.analyze]
    	this.dataObject = dataObject;
    
        // 없는 속성 추가
	    for (var i=1; i < dataObject.steps.length; i++){
	    	var stepObject = this.dataObject.steps[i];
	    	stepObject.headDatasSorted = null;
	    	
	    	stepObject.cellType = 0;
	    	if (stepObject.datas.length == 0){
	    		stepObject.cellType = CELLTYPE_FLOAT;
	    	} else if (stepObject.datas[0].length == 0){
	    		stepObject.cellType = CELLTYPE_FLOAT;
	    		
	    	} else if (("" + stepObject.datas[0][0]).isNum()){
	            stepObject.cellType = CELLTYPE_FLOAT;
	        } else {
	            stepObject.cellType = CELLTYPE_EDIT;
	        }
	    }
	    
        // 첫데이터로 셀타입을 판단한다 
	    
        showAjaxBox(getText("message_crosssheetv_001", "서버 데이터를 분석중입니다."), 0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep1()", 10);
        return;
    };
    
    CrossSheetV.prototype.executeStep1 = function(){
        // functionname : [CrossSheetV.executeStep1]
        
	    // ==== 0. 시트 클리어  ============================================
	    // 줄수, 칼럼수를 1로하고 MaxRows, MaxCols를 0으로 한다 
        var wTables = this.tagObject.getElementsByTagName("table");
	    for (var i = 0; i <= 3;i++){
	        wTables[i].style.display="none";
	    } 
	    
	    this.clear();
	    var dataObject = this.dataObject;
	    
	    // ==== 1. 전역변수 세팅 ===========================================
        this.colLevelCnt = dataObject.head.levelCnt;
        this.rowLevelCnt = 0;
        for (var wStepNum = 1; wStepNum < dataObject.steps.length; wStepNum++){
            if (this.rowLevelCnt < dataObject.steps[wStepNum].levelCnt && dataObject.steps[wStepNum].isSQL)
                   this.rowLevelCnt = dataObject.steps[wStepNum].levelCnt;
        }
        this.headRows = this.colLevelCnt;
        this.headCols = this.rowLevelCnt;
        
        // 비고난의 갯수 설정
        if (dataObject.direction == "RowChange"){
            this.remarkCols = (dataObject.head.needRemarks ? 1 : 0);
        } else if (dataObject.direction == "ColChange"){
            this.remarkRows = (dataObject.head.needRemarks ? 1 : 0);
        }
        
        showAjaxBox(getText("message_crosssheetv_002", "분석 데이터를 작성하는 중입니다."), 0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep2()", 10);
        return;
    };
    
    CrossSheetV.prototype.executeStep2 = function(){
        // functionname : [CrossSheetV.executeStep2]
    
        // 데이터가 들어갈 빈헤더와 셀들을 모두 만든다
        // 상단헤더를 만든다
        var dataObject = this.dataObject;
        this.makeHeads(dataObject.head.heads, 
                       dataObject.sumPosition, 
                       dataObject.head.sums,
                       dataObject.head.levelCnt, 
                       dataObject.head.hidden, 
                       this.headDatas);
                       
        // Step헤더를 만든다
        for (var i=1; i < dataObject.steps.length; i++){
            this.stepHeadDatas[i] = [];
            if (dataObject.steps[i].isSQL){
                this.makeHeads(dataObject.steps[i].heads, 
                               dataObject.sumPosition, 
                               dataObject.steps[i].sums, 
                               dataObject.steps[i].levelCnt, 
                               dataObject.steps[i].hidden, 
                               this.stepHeadDatas[i]);
            } else {
                var wHeadData = this.stepHeadDatas[i][0] = new HeadData();
                wHeadData.captions = [dataObject.steps[i].heads[0][5],"","","",""];
                wHeadData.values   = ["","","","",""];
            }
        }
        
        // 시트에 집어 넣는다
        this.makeBlankCells();
    
        showAjaxBox(getText("message_crosssheetv_003", "상단과 좌측 타이틀을 채우고 있습니다."), 0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep3()", 10);
        return;
    };
    
    CrossSheetV.prototype.executeStep3 = function(){
        // functionname : [CrossSheetV.executeStep3]
                           
        var dataObject = this.dataObject;
	    // ==== 2. 타이틀을 먼저 만들고 ===============================
        //  2.1 칼럼 타이틀 채우기
        this.makeColTitle();
	    
        //  2.2 스텝별 타이틀 채우기
        var wStartNum = [this.headRows];
        var wArrSteps = dataObject.steps;
            for (var wStep = 1; wStep < wArrSteps.length; wStep++){
                this.stepstartNums[wStep] = wStartNum[0];
                this.makeRowTitles(wStep, dataObject.steps[wStep].decimal, wStartNum);
            }
    
        showAjaxBox(getText("message_crosssheetv_004", "데이터를 채우는 중입니다."), 0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep4()", 10);
        
        return;
    };
    
    CrossSheetV.prototype.executeStep4 = function(){
        // functionname : [CrossSheetV.executeStep4]
        
    	// ==== 3. 스텝별로 몸통데이터를 찍는다. =============================
    	var wArrSteps = this.dataObject.steps;
        for (var wStep = 1; wStep < wArrSteps.length; wStep++){
            var wStepObject = wArrSteps[wStep];
            this.mCrrentFieldTypeIsNumeric = true;
            
            if (wStepObject.isSQL1)
                this.fillRowData(wStep, wStepObject);
        }
                           
    
        showAjaxBox(getText("message_crosssheetv_005", "셀에 산식을 작성하는 중입니다."), 0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep5()", 10);
        return;
    };
    
    CrossSheetV.prototype.executeStep5 = function(){
        // functionname : [CrossSheetV.executeStep5]
        
        var dataObject = this.dataObject;
    	// ==== 4. 산식데이터 채우기  =============================
        //  4.1 스텝별 산식 채우기(산식)
        var wArrSteps = this.dataObject.steps;
        for (var wStep = 1; wStep < wArrSteps.length; wStep++){
            var wStepObject = wArrSteps[wStep];
            this.mCrrentFieldTypeIsNumeric = true;
            if (!wStepObject.isSQL1){
                this.makeRowFormula(wStep, wStepObject);
            }
        }
        
        //  4.2 열단위 합계 채우기(산식)
        this.makeColSums();
        
        //  4.3 줄단위 합계 채우기(산식)
        for (var wStep = 1; wStep < wArrSteps.length; wStep++){
            var wStepObject = wArrSteps[wStep];
            if (wStepObject.isSQL && wStepObject.isSQL1){
                this.makeStepSums(wStep);
            }
        }
        
        //  4.4 줄단위 비고난 채우기
        for (var wStep = 1; wStep < wArrSteps.length; wStep++){
            this.makeStepRemarks(wStep, dataObject.steps[wStep].remark);
        }
        
        
        showAjaxBox(getText("message_crosssheetv_006", "산식을 일괄 계산하는 중입니다."), 0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep6()", 10);
        return;
    };
    
    CrossSheetV.prototype.executeStep6 = function(){
        // functionname : [CrossSheetV.executeStep6]
        
        // ==== 5. 산식셀을 일괄 계산 해준다. =====================================================
        this.recalculate();
        
        showAjaxBox(getText("message_crosssheetv_007", "칼럼사이즈를 조정하고, 타이틀을 정비하는 중입니다"), 0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep7()", 10);
        return;
    };
    
    
    CrossSheetV.prototype.executeStep7 = function(){
        // functionname : [CrossSheetV.executeStep7]
        
        var dataObject = this.dataObject;
        // ==== 6. 헤더 칼럼을 사이즈를 조정한다===================
        // 6.1 칼럼사이즈 조정
        this.adjustColWidth();

        // 6.2 열 헤더 칼럼 병합
        var wTableRow = document.createElement("TR"); 
        var wRow0 = this.colHeadTable.tBodies[0].rows[0];
        
        if (wRow0.insertAdjacentElement){
        	wRow0.insertAdjacentElement('beforeBegin', wTableRow);
 		}
 		else if (wRow0.appendChild) {
 			insertAdjacentElement('beforeBegin' ,wRow0, wTableRow);
 		}
        
        for (var wColNum = 0; wColNum < this.colHeadTable.tBodies[0].rows[1].cells.length; wColNum++){
            wTableRow.insertCell(wColNum);
            wTableRow.cells[wColNum].style.width = wRow0.cells[wColNum].style.width;
        }
    	this.colHeadTable.tBodies[0].rows[0].style.display="none";
        this.mNoneCaption = dataObject.noCaption;
        this.setColHeadSpan(this.mNoneCaption);
        
        // 6.3 줄 헤더 칼럼 병합
        var wArrSteps = this.dataObject.steps;
        for (var wStep = wArrSteps.length - 1; wStep >= 1; wStep--){
            this.setRowHeadSpans(wStep, dataObject.steps[wStep].levelCnt, 
                                        this.mNoneCaption ,
                                        dataObject.steps[wStep].isSQL);
        }

        // 6.3 빈데이터 셀을 정리한다
        for (var wRowNum=0; wRowNum < this.dataTable.tBodies[0].rows.length; wRowNum++){
        	var wRow = this.dataTable.tBodies[0].rows[wRowNum];
        	for (var wColNum=0; wColNum < wRow.cells.length; wColNum++){
        		if (wRow.cells[wColNum].innerHTML=="") wRow.cells[wColNum].innerHTML="&nbsp;";
        	}
        }
        
        /*            

        // 열 헤더 칼럼 숨기기
        for (var wLevelNum = 0; wLevelNum < this.dataObject.head.levelCnt; wLevelNum++){
            if (this.dataObject.head.hidden[wLevelNum])
                this.hideColLevels(this.dataObject.head.levelCnt, wLevelNum);
        }
        

        // 줄 헤더 칼럼 숨기기
        for (var wStep = wArrSteps.length - 1; wStep >= 1; wStep--){
            for (var wLevelNum = 0; wLevelNum < this.dataObject.steps[wStep].levelCnt; wLevelNum++){
                if (this.dataObject.steps[wStep].hidden[i])
                    this.HideStepColLevels(this.dataObject.steps[wStep].levelCnt, wLevelNum, wStep);
            }
        }
        */
        
        showAjaxBox(getText("message_crosssheetv_008", "자료를 정리합니다."), 0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep8()", 10);
        return;
    };
    
    
    CrossSheetV.prototype.executeStep8 = function(){
        // functionname : [CrossSheetV.executeStep8]
    
    	// ==== 7. 데이터 작업 후속처리 ===================
        var wTables = this.tagObject.getElementsByTagName("table");
	    for (var i = 0; i <= 3;i++){
	        wTables[i].style.display="block";
	    }     
	       
     	// 7.1 메모리 해제 
        //this.dataObject = null;
    
    	// 7.2 차트 그리기 호출
		this.showChart();
		
		// 7.3 채우기 완료 이벤트 호출 
		callEvent(this.controlId + "_LoadSuccess");
    
		// 7.4 시트 스크롤 초기화 
    	this.resetScroll();
    	
    	// 7.5 진행 상태 박스 숨기기
    	hideAjaxBox();
    	
    	// 7.6 좌상단 셀 조정
    	var rowTitle = this.dataObject.head.rowTitle;
    	if (rowTitle == null || rowTitle.length == 0)
    		this.mergeUpperMost();
    	
        return;
    };

       
    CrossSheetV.prototype.clearData = function(dataObject){
        // functionname : [CrossSheetV.clearData]

           for (var wStepNum = 1; wStepNum < dataObject.steps.length; wStepNum++){
        	   var wStep = dataObject.steps[wStepNum];
        	   if (wStep.sums) wStep.sums.clear();
        	   if (wStep.sums) wStep.hidden.clear();
        	   if (wStep.sums) wStep.heads.clear();
        	   if (wStep.sums) wStep.datas.clear();
           }
    	   dataObject.steps.clear();
    	   
       	   var wHead = dataObject.head;
    	   if (wHead.sums) wHead.sums.clear();
    	   if (wHead.sums) wHead.hidden.clear();
    	   if (wHead.sums) wHead.heads.clear();
    	   dataObject.head = null;
    	   
    	   dataObject = null;
    };

    CrossSheetV.prototype.addChartInfo = function(pChartInfo){
        // functionname : [CrossSheetV.addChartInfo]

        this.chartInfo = pChartInfo;      
    };
    
    CrossSheetV.prototype.getChartData = function(pChartId){
       // functionname : [CrossSheetV.getChartData]

       var arrFromStrings = [",", ":", ";", "&", "%", "?"];
       var arrToStrings   = ["<COMMA>", "<COLON>", "<SEMICOLON>", "<AMP>", "<PERCENT>", "<QUESTION>"];

       var wChartInfo = "";
	   var wInfos = this.chartInfo.split("[S1]");
	   for(var i = 0; i < wInfos.length; i++){
		   var wInfo = wInfos[i];
		   if (wInfo.trim().length == 0) continue;
		   var chartId = wInfo.split(";")[2];
		   
		   if (pChartId == chartId) {
			   wChartInfo = wInfo; break;
		   }
	   }
	   
	   if (wChartInfo.length == 0) return "";
	   
	   var wArr = wChartInfo.split(";");
 	   var wArr1 = wArr[0].split("_");
 	   var wArr2 = wArr[1].split("_");
 	   
	   var wPointRCType      = parseInt(wArr1[0]);
	   var wPointStepNum     = parseInt(wArr1[1]);     // 포인트데이터를 뽑을 스텝명
	   var wPonitLevel       = parseInt(wArr1[2]);     // 포인트 데이터를 뽑을 레벨명
	   
	   
	   // wSeriesLevel의 주의사항  예를들어 "대분류-중분류-상품"이라면 대분류는 1이고 상품은 3으로 화면이 만들어 진다
	   // 크로스 시트의 경우 상품데이터는1, 중분류 합계는 2, 대분류합계는 3이다
	   if (wPointRCType == BY_ROW_VTYPE){
		   wPonitLevel = this.rowLevelCnt - wPonitLevel + 1;
	   } else if (wPointRCType == BY_COL_VTYPE){
		   wPonitLevel = this.colLevelCnt - wPonitLevel + 1;
	   }
	   
	   var wSeriesRCType	 = parseInt(wArr2[0]); 
	   var wSeriesStepNum	 = parseInt(wArr2[1]);     // 계열값 데이터를 뽑을 스텝명
	   var wSeriesLevel	     = parseInt(wArr2[2]);     // 계열값 데이터를 뽑을 레벨명
	   
	   if (wSeriesRCType == BY_ROW_VTYPE){
		   wSeriesLevel = this.rowLevelCnt - wSeriesLevel + 1;
	   } else if (wSeriesRCType == BY_COL_VTYPE){
		   wSeriesLevel = this.colLevelCnt - wSeriesLevel + 1;
	   }
 	   
        var wPointRcNums = [];
        
        // point data set 
        var wData = "";      // 함수가 리턴할 문자열값
        var wPointSeq = 0;   // 선택된 헤더들 집합 내의 새로 매긴 순번
        
        if (wPointRCType == BY_COL_VTYPE){
            var wHeadCols = this.headCols;
            for (var i=0; i < this.headDatas.length; i++){
                var wHeadData = this.headDatas[i];
                if (wHeadData.Level != wPonitLevel) continue;
                
                wData += "," + escapeCharacter(wHeadData.captions[this.colLevelCnt - wPonitLevel] ,arrFromStrings, arrToStrings);
                wPointRcNums[wPointSeq] = i + wHeadCols;
                
                wPointSeq++;
            }
        
        } else if (wPointRCType == BY_ROW_VTYPE){
            var wStartRowNum = this.stepstartNums[wPointStepNum];
            wHeadDatas = this.stepHeadDatas[wPointStepNum];
            
            for (var i=0; i < wHeadDatas.length; i++){
                var wHeadData = wHeadDatas[i];
                if (wHeadData.Level != wPonitLevel) continue;
                
                wData += "," + escapeCharacter(wHeadData.captions[this.rowLevelCnt - wPonitLevel] ,arrFromStrings, arrToStrings);
                wPointRcNums[wPointSeq] = i + wStartRowNum;
                
                wPointSeq++;
            }
        
        }
        wData += ":";
        
        // Series Data Set
        var wRows = this.dataTable.tBodies[0].rows;
        
        if (wSeriesRCType == BY_COL_VTYPE){
            var wHeadCols = this.headCols;
            for (var i=0; i < this.headDatas.length; i++){
                var wHeadData = this.headDatas[i];
                if (wHeadData.Level != wSeriesLevel) continue;
                
                wData += escapeCharacter(wHeadData.captions[this.colLevelCnt - wSeriesLevel] ,arrFromStrings, arrToStrings);
                
                var wColNum = i + wHeadCols;
                for (var j = 0; j < wPointRcNums.length; j++){
                    var wRowNum = wPointRcNums[j];
                    var wValue = wRows[wRowNum].cells[wColNum].getAttribute("value");
                    
                    wData += "," + escapeCharacter(wValue ,arrFromStrings, arrToStrings);
                    
                }
                wData += ":";

            }
        
        } else if (wSeriesRCType == BY_ROW_VTYPE){
            var wStartRowNum = this.stepstartNums[wSeriesStepNum];
            wHeadDatas = this.stepHeadDatas[wSeriesStepNum];

            for (var i=0; i < wHeadDatas.length; i++){

            	wHeadData = wHeadDatas[i];
                if (wHeadData.Level != wSeriesLevel) continue;
                
                wData += escapeCharacter(wHeadData.captions[this.rowLevelCnt - wSeriesLevel] ,arrFromStrings, arrToStrings);
                
                var wRowNum = i + wStartRowNum;
                for (var j = 0; j < wPointRcNums.length; j++){
                    var wColNum = wPointRcNums[j];
                    var wValue = wRows[wRowNum].cells[wColNum].getAttribute("value");
                    
                    wData += "," + escapeCharacter(wValue ,arrFromStrings, arrToStrings);
                    
                }
                wData += ":";
            }
        }
    	return wData;
    };


    CrossSheetV.prototype.showChart = function(){
        // functionname : [CrossSheetV.showChart]

 	   var wChartInfo = "";
 	   var wInfos = this.chartInfo.split("[S1]");
 	   for(var i = 0; i < wInfos.length; i++){
 		   var wInfo = wInfos[i];
 		   if (wInfo.trim().length == 0) continue;
 		   var chartId = wInfo.split(";")[2];
 		   
            var chartControl = getControlById(chartId);
            chartControl.data =this.getChartData(chartId);
            
            if (chartControl.data.indexOf(":") < chartControl.data.length - 1){
                chartControl.show();
            }
 	   }
 	   return;
    };
    
    CrossSheetV.prototype.setCellStyle = function(stepNum, styleJSON, arrKeyDatas, tooltip){
        // functionname : [CrossSheetV.setCellStyle]

        var stepObject = this.dataObject.steps[stepNum];
        var wStartNum = this.stepstartNums[stepNum];
        var wFieldPoint = stepObject.fieldPoint;
        
	    // key count 계산
        var keyCount = 0;
        var wArrDatas = stepObject.datas;
        if (wArrDatas.length >= 1){
            for (var i = 1; wArrDatas[0].length;i++) {
            	if (wArrDatas[0][i] == null) break; 
            	keyCount++;
            }
        }

        var headKeyCount = wFieldPoint;
        var bodyKeyCount = keyCount - wFieldPoint;
        
        var wData = arrKeyDatas;

        // 칼럼번호 찾기 
        var wWorkKey = wData.slice(1, wFieldPoint + 1); 
        var wColArrData = searchArray(this.headDatasSorted, wWorkKey);
        var wColNum = (wColArrData != null ? wColArrData[wColArrData.length - 1] : -1);
        
        // 줄번호 찾기
        var wRowNum = -1; var wRowArrData = null; 
        if (!stepObject.isSQL){
            wRowNum = wStartNum;
        } else {
            wWorkKey = wData.slice(headKeyCount + 1, keyCount + 1); 
            wRowArrData = searchArray(stepObject.headDatasSorted, wWorkKey);
            wRowNum = (wRowArrData != null ? wRowArrData[wRowArrData.length - 1] : -1);
        }
        
        if (wRowNum >= 0 && wColNum >= 0){
            var wCell = this.dataTable.tBodies[0].rows[wRowNum].cells[wColNum];
            this.setTypeStyle(wCell, styleJSON, tooltip);	
         }
        
            
        if (wWorkKey) wWorkKey.clear();
        
        return;
    };
    
    // 사용방법 : wSheet.setTypeStyle({"text-align":"left", "font": "normal normal normal 12pt 굴림,Courier"});
    // 만들어진 스타일을 지우려면 : wSheet.setTypeStyle({"text-align":""});
    CrossSheetV.prototype.setTypeStyle = function(cell, styleJSON, tooltip){
        // functionname : [CrossSheetV.setTypeStyle]

          var wCell = cell;
          var styleString = "";
          if (wCell.style){
        	  styleString = wCell.style.cssText;  
          } else {
        	  styleString = wCell.getAttribute("style");  
          }
          
          var arrStyleItems = (styleString == null ? [] : styleString.split(";"));
          var arrStyles = [];
          
          for (var i = 0; i < arrStyleItems.length; i++){
              var styleItem = ("" + arrStyleItems[i]).trim();
              if (styleItem.length == 0) continue;
              
              var arrInfos = styleItem.split(":");
              var itemStyleName  = ("" + arrInfos[0]).trim();
              var itemStyleValue = ("" + arrInfos[1]).trim();
              
              arrStyles[i] = [itemStyleName, itemStyleValue];
          }


          styleString = "";
          
          for (var wKey in styleJSON){
	         if (styleJSON[wKey] instanceof Function) continue;
             var styleName  = wKey;
             var styleValue = styleJSON[wKey];
             
             var found = false;
             for (var j = 0; j < arrStyles.length; j++){
                 var itemStyleName  = arrStyles[j][0];
                 var itemStyleValue = arrStyles[j][1];
                 
                 if (styleName == itemStyleName) {
                     arrStyles[j] = [styleName, styleValue];

                     found  = true; break;
                 }
             }
             
             if (!found){
                 var newIndex = arrStyles.length;
                 arrStyles[newIndex ] = [styleName, styleValue];
             }
          }
          
          for (var i = 0; i < arrStyles.length; i++){
              if (arrStyles[i][1].length == 0) continue;
              styleString +=  arrStyles[i][0] + ":" + arrStyles[i][1] + "; ";
          }

          wCell.setAttribute("style", styleString);
    	  wCell.style.cssText = styleString;

          wCell.title= tooltip;

          return;
    };

    CrossSheetV.prototype.stepNumOf = function(rowNum){
    	var wStepNum = 0;
	    for (var i=1; i < this.stepstartNums.length; i++){
	    	if (rowNum < this.stepstartNums[i]) break;
	    	wStepNum++;
	    }
	    return wStepNum;
    };

    /***************************************************************************
    데이터시트 콘트롤의 정의 부분이다
    인수로는 콘트롤 명과 , 테그객체를 갖는다
***************************************************************************/
    function CrossSheetH(controlId, controlName, tagObject) //constructor 
    {
        // 시트 외형에 관한 설정 
        this.controlId = controlId;   
        this.id   = this.controlId;
        this.controlName = controlName;   
        this.tagObject = tagObject;
        this.enabled = true;
        
        this.headRows = 1;
        this.headCols = 1;
        this.frozenCols = 0;
        this.frozenRows = 0;
        this.maxCols = 0;  // MaxCols와 MaxRows엔 비고난이 들어 가지 않는 숫자다
        this.maxRows = 0;
        this.remarkCols = 0;
        this.remarkRows = 0;
        this.chartInfo = "";
        
        var wTables = this.tagObject.getElementsByTagName("table");
        this.dataTable    = wTables[DATA_TABLE];
        this.colHeadTable = wTables[COL_TABLE];
        this.rowHeadTable = wTables[ROW_TABLE];
        this.fixCellTable = wTables[FIX_TABLE];
        
        // 데이터처리에 관한 설정 
        this.headDatas = [];          // HeadData구조체의 배열이다
        this.headDatasSorted = null;    // HeadData구조체의 정렬된 배열이다
        this.stepHeadDatas= [null];   // 스텝갯수만큼 위 HeadDatas배열이 들어간다
        this.stepstartNums= [null];   // 스텝갯수만큼 위 시작 줄,열번호가 들어간다
        this.stepRCs      = [null];   // 스텝별로 로우데이터의 RC정보가 들어간다
        
        this.printHead = "";  // 인쇄시 페이지 헤더로 들어갈 내용
        this.printFoot = "";  // 인쇄시 페이지 푸터로 들어갈 내용
        this.needRemarks = false;
        
        // 참고: 최상위 레벨이 1레벨이고 하위 데이터가 붙을수록 5레벨까지 
        //       계속 레벨번호가 올라간다
        //       Value, Caption데이터는 상위레벨부터 채워진다
        //       즉 0번값이 최상위이다 (쿼리 필드 순서)
        
        this.colLevelCnt = 0; // 칼럼헤더의 레벨계층숫자
        this.rowLevelCnt = 0; // 로우헤더의 레벨계층숫자
        
        // 서버에서 받은 채우기 객체
        this.dataObject = null;

        if (tagObject != undefined){
            tagObject.setAttribute("tabIndex", "-1");
//            setEventHandler(this.dataTable, "mouseup", crosssheet_onmouseup);	//2019-03-28 jaeik 텍스트박스 입력 막음
        }
        
        this.hasClickEvent = false; this.fncClickEvent = null;
        this.hasChangeEvent = false; this.fncChangeEvent = null;
        if (this.controlId.length > 0) {
        	try {
            	if (eval(this.controlId + "_onclick")) this.hasClickEvent = true;
            } catch(e){}
            if (this.hasClickEvent){
        	    eval("this.fncClickEvent = function(rowNum, colNum){ return " + this.controlId + "_onclick(rowNum, colNum);}");
            }
        	try {
            	if (eval(this.controlId + "_onchange")) this.hasChangeEvent = true;
            } catch(e){}
            if (this.hasChangeEvent){
        	    eval("this.fncChangeEvent = function(rowNum, colNum, value, oldValue, cell){ return " + this.controlId + "_onchange(rowNum, colNum, value, oldValue, cell);}");
            }
        }
        // this.FormulaRefs = [];
    };
    
    /* -----------------------------------------------------------------------
        셀과 관련된 기초동작 
     -------------------------------------------------------------------------*/
    CrossSheetH.prototype.getText = function(row, col){
        // functionname : [CrossSheetH.getText]

    	var wCell = this.dataTable.tBodies[0].rows[row + this.headRows - 1].cells[col + this.headCols - 1];
        var wValue = wCell.getAttribute("value");
        
    	return wValue;
    };

    // MaxRows, MaxCols를 0으로 세팅한다
    CrossSheetH.prototype.clear = function(){
        // functionname : [CrossSheetH.clear]

        var wTables = this.tagObject.getElementsByTagName("table");
        for (var wTableNum = 0; wTableNum < wTables.length; wTableNum++){
            var wTable = wTables[wTableNum];
            for (var wRow = wTable.tBodies[0].rows.length - 1; wRow > 0; wRow--){
                    wTable.deleteRow(wRow);
            }
            
            var wRow = wTable.tBodies[0].rows[0];
            wRow.style.display = "";
            for (var wColNum = wRow.cells.length - 1; wColNum > 0; wColNum--){
                    wRow.deleteCell(wColNum);
            }
            wRow.cells[0].innerText = " ";
        }

        // 시트 외형에 관한 설정 
        this.headRows = 1;
        this.headCols = 1;
        this.frozenCols = 0;
        this.frozenRows = 0;
        this.maxCols = 0;  // MaxCols와 MaxRows엔 비고난이 들어 가지 않는 숫자다
        this.maxRows = 0;
        this.remarkCols = 0;
        this.remarkRows = 0;
        
        // 데이터처리에 관한 설정
        this.headDatas.clear();       this.headDatas = [];          // HeadData구조체의 배열이다
        this.stepHeadDatas.clear();   this.stepHeadDatas= [null];   // 스텝갯수만큼 위 HeadDatas배열이 들어간다
        this.stepstartNums.clear();   this.stepstartNums= [null];   // 스텝갯수만큼 위 시작 줄,열번호가 들어간다
        this.stepRCs.clear();         this.stepRCs      = [null];   // 스텝별로 로우데이터의 RC정보가 들어간다
        
        this.printHead = "";  // 인쇄시 페이지 헤더로 들어갈 내용
        this.printFoot = "";  // 인쇄시 페이지 푸터로 들어갈 내용
        this.needRemarks = false;
        
        this.colLevelCnt = 0; // 칼럼헤더의 레벨계층숫자
        this.rowLevelCnt = 0; // 로우헤더의 레벨계층숫자

        return;
    };

    CrossSheetH.prototype.getTag = function(row, col){
        // functionname : [CrossSheetH.getTag]

    	if (row + this.headRows - 1 > this.maxRows || 
    	    col + this.headCols - 1 > this.maxCols) return "";
    	    
    	return this.dataTable.tBodies[0].rows[row + this.headRows - 1].cells[col + this.headCols - 1].getAttribute("tag");
    };

    /* -------------------------------------------------------------------------
       서버로 부터 받은 데이터를 곧바로 헤드오 뿌릴 수 있도록 데이터를 만든다.
       인수 : 
           heads : 서버로 부터 받은 데이터 2차원배열[레코드번호][필드번호]
           sumPosition : 합계를 앞에 표시할 것인지 구분 ("AFTER", "BEFORE")
           sums : 합계갑 표시캡션들의 1차원 배열["합계","평균","최대",...]
       결과 : 
           this.headDatas : 결과값이 들어갈 1차원배열 (HeadData 구조체가 들어감) 
     ------------------------------------------------------------------------ */
    CrossSheetH.prototype.makeHeads = function(heads, sumPosition, sums, levelCnt, hidden, headDatas){
        // functionname : [CrossSheetH.makeHeads]

        var wIndex = -1;
        
        var AC = (sumPosition == "AFTER" ? "C" : "A");
        for (var i = 0; i < heads.length; i++){
            var wHeadData = headDatas[++wIndex] = new HeadData();
            var wColData = heads[i];
            
            wHeadData.values   = wColData.slice(0, 5);
            wHeadData.captions = wColData.slice(5, 10);
            
            var wSortKey = "";
            for (var k = 1; k <= levelCnt; k++){
                wSortKey += "B" + mask(i, "0000");
            }
            wHeadData.sortKey = wSortKey;
            
            wHeadData.childInfo = "NONE";
            wHeadData.Level = 1;
            
            var wNextData = (i == heads.length - 1 ? [null,null,null,null,null] : heads[i + 1]);
            
            // 1레벨의 합계부터 5레벨의 합계까지 루핑 
            for (var wLevel = 1; wLevel <= levelCnt; wLevel++){
                var wLevelIndex = wLevel - 1;
                // 마지막 데이터는 무조건 true이다(전체합계를 찍기위해서)
                var wChecked = (i == heads.length - 1); 
                // 상위 요소의 변화를 체크한다
                for (var j = 0; j < wLevelIndex;j++)
                    wChecked = wChecked || (wColData[j] != wNextData[j]);
                
                if (wChecked && sums[wLevelIndex] != null && sums[wLevelIndex] != getText("message_crosssheeth_009", "표시안함")
                										  && sums[wLevelIndex] != getText("message_crosssheeth_015", "(None)")){
                    var wNewHeadData = headDatas[++wIndex] = new HeadData();
                    for (var k = 0; k < wLevelIndex; k++){
                        wNewHeadData.values[k]   = wHeadData.values[k];
                        wNewHeadData.captions[k] = wHeadData.captions[k];
                    }
                    wNewHeadData.captions[wLevelIndex] = sums[wLevelIndex]; // "합계","소계"
                    wNewHeadData.functionName = sums[wLevelIndex];
                    wNewHeadData.Level = levelCnt - wLevel + 1 + 1;
                    
                    wNewHeadData.hideChild = hidden[wLevelIndex];
                    
                    var wSortKey = "";
                    for (var k = 1; k <= levelCnt; k++){
                        if (k >= wLevel){
                            wSortKey += AC  + mask(i, "0000");
                        } else {
                            wSortKey += "B" + mask(i, "0000");
                        }
                        if (k > wLevel){
                            wSortKey += AC  + mask(i, "0000");
                            wNewHeadData.merged[k - 1] = "X"; // 셀합치기 동작에 필요해서 기억해 놓음
                            wNewHeadData.captions[k - 1] = wNewHeadData.captions[wLevelIndex];
                        }
                    }
                    wNewHeadData.sortKey = wSortKey;
                    
                }
            }
        }

        headDatas.sort(sortfnHead);
        
        for (var i = 0; i < headDatas.length; i++){
            if (headDatas[i].childInfo == "NONE")
                this.setChildInfo(headDatas[i], headDatas, levelCnt, i + 1);
            // 여기서 1을 더한 이유는 sheetCol, SheetRow가 1부터 시작하기 때문이다    
        }
        
        // 더이상 필요없게된 메모리는 지운다
        heads.clear();
        
        return;
    };
    
    CrossSheetH.prototype.setChildInfo = function(headData, headDatas, levelCnt, indexNum){
        // functionname : [CrossSheetH.setChildInfo]
                           
        for (var i = 0; i < headDatas.length; i++){
            if (headDatas[i].childInfo == "NONE") continue;
            var wHeadData = headDatas[i];
            var wChecked = true;
            for (wLevel = 1; wLevel < levelCnt; wLevel++){
                var wLevelIndex = wLevel - 1;
                if (wHeadData.values[wLevelIndex] != "" && 
                   (headData.values[wLevelIndex] != wHeadData.values[wLevelIndex])){
                   wChecked = false;
                   break;
                }
            }
            
            if (!wChecked) continue;
            
            wHeadData.childInfo += (wHeadData.childInfo.length > 0 ? "," : "") + indexNum;
        }
        return;
    };

    // 데이터를 넣을 빈셀과 빈 헤더셀들을 만든다. 셀들의 Span은 아직 없다.
    CrossSheetH.prototype.makeBlankCells = function(){
        // functionname : [CrossSheetH.makeBlankCells]
                           
    	// MaxCols와 MaxRows를 계산
        this.maxRows = this.headDatas.length; 
        this.maxCols = 0;
        for (var wStepNum = 1; wStepNum < this.stepHeadDatas.length; wStepNum++){
            this.maxCols += this.stepHeadDatas[wStepNum].length;
        }
    	
        // this.headCols와 this.headRows를 계산
    	var wTables = this.tagObject.getElementsByTagName("table");
        var wArrStrCellLen = (this.tagObject.getAttribute("cellSize") || "").split(";");
        for (var i = 0; i <= 3;i++){
            var wTable = wTables[i];
            var wTableRow = null;var wCell = null;
    	
            var ColsTo = this.headCols + (i == ROW_TABLE || i == FIX_TABLE ? this.frozenCols : this.maxCols + this.remarkCols);
            var RowsTo = this.headRows + (i == COL_TABLE || i == FIX_TABLE ? this.frozenRows : this.maxRows + this.remarkRows);
            
            for (var wRow = 0; wRow < RowsTo; wRow++){
                // 줄을 선택한다, 없으면 만든후 선택한다
                if (wTable.tBodies[0].rows.length <= wRow) {
                	wTableRow = wTable.insertRow(wRow);
                } else {
                	wTableRow = wTable.tBodies[0].rows[wRow];
                }
                wTableRow.style.height = 19 + "px";
                
                for (var wCol = 0; wCol < ColsTo; wCol++){
                    if (wTableRow.cells.length <= wCol)  {
                    	wCell = wTableRow.insertCell(wCol);
                    } else {
                    	wCell = wTableRow.cells[wCol];
                    }
                         
                    wCell.innerText = " ";
                    if (i == DATA_TABLE) wCell.setAttribute("value", "");
                    wCell.vAlign = "middle";
//                    wCell.vAlign = "baseline";
                    
                    // 헤더셀들은 셀사이즈를 주어 Span에 대비한다
                    if (wRow < this.headRows) {
                        wCell.style.width = 50 + "px";
                        wCell.className = "HeadLevel" + (wRow + 1);
                        wCell.innerHTML = "&nbsp;";
                        wArrStrCellLen[wRow] = "50" + "px";
                    } else if (wCol < this.headCols) {
                        wCell.className = "HeadLevel" + (wCol + 1);
                        wCell.innerHTML = "&nbsp;";
                    }
                }
            }
                    
            wTable.style.width = (ColsTo * (50 + GAP_BETWEEN_CELL) + GAP_BETWEEN_CELL) + "px";
            
            if (i == DATA_TABLE)
                this.tagObject.setAttribute("cellSize", wArrStrCellLen.join(";"));    
                
        }
        return;
    };

    CrossSheetH.prototype.makeRowTitle = function(){
        // functionname : [CrossSheetH.makeRowTitle]
        
        var wArrHeadDatas = this.headDatas;
    
    	var dataTableBody = this.dataTable.tBodies[0];
    	var rowHeadTableBody = this.rowHeadTable.tBodies[0];
    	var dataTableRow = null;
    	var rowHeadTableRow = null;
    	var wCell = null;
    	for (var i = 0; i < wArrHeadDatas.length; i++){
    	    var wRowNum = i + this.headRows;
    	    var wHeadData = wArrHeadDatas[i];
    	    var wHeadData1 = (wArrHeadDatas[i+1] == undefined ? "" : wArrHeadDatas[i+1]);
    	    dataTableRow = dataTableBody.rows[wRowNum];
    	    rowHeadTableRow = rowHeadTableBody.rows[wRowNum];
    		
    	    for (var j = 0; j < this.headCols; j++){
    	        var wColNum = j;
    		
                wCell = dataTableRow.cells[wColNum];
                wCell.innerText = wHeadData.captions[j];
                wCell.setAttribute("value", wHeadData.values[j]);
    	        
                wCell = rowHeadTableRow.cells[wColNum];
                wCell.innerText = wHeadData.captions[j];
//                wCell.setAttribute("NeedDel", (wColNum > 0 && (wHeadData.values[j] == wHeadData.values[j - 1] && wHeadData.captions[j] == wHeadData.captions[j - 1]) ? "true" : "false"));
                wCell.setAttribute("NeedDel", (wColNum > 0 && 
                		(wHeadData.captions[j] == wHeadData.captions[j - 1]) &&
                		(wHeadData.captions[j - 1] != (wHeadData1 != "" ? wHeadData1.captions[j - 1] : "")) ||
                		wHeadData.merged[j] == "X" ? "true" : "false"));
//                		(wHeadData.values[j] == wHeadData.values[j - 1] && wHeadData.captions[j] == wHeadData.captions[j - 1]) &&
//                		(wHeadData.values[j - 1] != (wHeadData1 != "" ? wHeadData1.values[j - 1] : "") && wHeadData.captions[j - 1] != (wHeadData1 != "" ? wHeadData1.captions[j - 1] : "")) ? "true" : "false"));
    	    }
    	    
    	    for (var wColNum = this.headCols; wColNum < this.headCols + this.maxCols; wColNum++){
    	        if (wHeadData.Level > 1)
    	        	dataTableRow.cells[wColNum].className = "CSumBack" + wHeadData.Level;
    	    }
    	    
    	}
    	
    	/**
		 * 2019-05-10 jaeik 로우타이틀 채우기
		 */
    	var colHeadTableBody = this.colHeadTable.tBodies[0];
        var fixCellTableBody = this.fixCellTable.tBodies[0];
    	var rowTitle = this.dataObject.head.rowTitle;
    	if (rowTitle != null && rowTitle.length > 0) {
    		for (var i = 0; i < rowTitle.length; i++){
        	    var wRowNum = i;
        	    var wHeadData = rowTitle[rowTitle.length-i-1];
        	    var wHeadData1 = (rowTitle[rowTitle.length-i] == undefined ? "" : rowTitle[rowTitle.length-i]);
        	    dataTableRow = dataTableBody.rows[wRowNum];
        	    rowHeadTableRow = rowHeadTableBody.rows[wRowNum];
        	    colHeadTableRow = colHeadTableBody.rows[wRowNum];
        	    fixCellTableRow = fixCellTableBody.rows[wRowNum];
        	    
        	    for (var j = 0; j < this.headCols; j++){
        	        var wColNum = j;
        		
                    wCell = dataTableRow.cells[wColNum];
                    wCell.innerText = wHeadData[j];
                    wCell.setAttribute("value", wHeadData[j]);
        	        
                    wCell = rowHeadTableRow.cells[wColNum];
                    wCell.innerText = wHeadData[j];
                    wCell.setAttribute("NeedDel", (wColNum > 0 && 
                    		(wHeadData[j] == wHeadData[j - 1]) &&
                    		(wHeadData[j - 1] != (wHeadData1 != "" ? wHeadData1[j - 1] : "")) ? "true" : "false"));
                    
                    wCell = colHeadTableRow.cells[wColNum];
                    wCell.innerText = wHeadData[j];
                    wCell.setAttribute("NeedDel", (wColNum > 0 && 
                    		(wHeadData[j] == wHeadData[j - 1]) &&
                    		(wHeadData[j - 1] != (wHeadData1 != "" ? wHeadData1[j - 1] : "")) ? "true" : "false"));
                    
                    wCell = fixCellTableRow.cells[wColNum];
                    wCell.innerText = wHeadData[j];
                    wCell.setAttribute("NeedDel", (wColNum > 0 && 
                    		(wHeadData[j] == wHeadData[j - 1]) &&
                    		(wHeadData[j - 1] != (wHeadData1 != "" ? wHeadData1[j - 1] : "")) ? "true" : "false"));
        	    }
        	}
    	}
    		
        return;
    };

    CrossSheetH.prototype.makeColTitles = function(stepNum, decimal, startNum){
        // functionname : [CrossSheetH.makeColTitles]

        var wStartNum = startNum[0];
        var wArrHeadDatas = this.stepHeadDatas[stepNum];
    	var wRCs = "";

    	var dataTableBody = this.dataTable.tBodies[0];
    	var colHeadTableBody = this.colHeadTable.tBodies[0];
    	var wCell = null;
    	
    	for (var i = 0; i < wArrHeadDatas.length; i++){
    	    var wColNum = wStartNum + i;
    	    var wSheetColNum = wColNum - this.headCols + 1; 
    	    var wHeadData = wArrHeadDatas[i];
    	    var wHeadData1 = (wArrHeadDatas[i+1] == undefined ? "" : wArrHeadDatas[i+1]);
        
    	    for (var j = 0; j < this.headRows; j++){
    	        var wRowNum = j;
        
                wCell = dataTableBody.rows[wRowNum].cells[wColNum];
                if (typeof wCell == "undefined") continue;
                wCell.innerText = wHeadData.captions[j];
                wCell.setAttribute("value", wHeadData.values[j]);
                wCell.setAttribute("NeedDel", (wColNum > 0 && (wHeadData.values[j] == wHeadData.values[j - 1] && wHeadData.captions[j] == wHeadData.captions[j - 1]) ? "true" : "false"));
    	        
                wCell = colHeadTableBody.rows[wRowNum].cells[wColNum];
                wCell.innerText = wHeadData.captions[j];
                wCell.setAttribute("NeedDel", (wRowNum > 0 && 
                		(wHeadData.captions[j] == wHeadData.captions[j - 1]) &&
                		(wHeadData.captions[j-1] != (wHeadData1 != "" ? wHeadData1.captions[j - 1] : "")) ? "true" : "false"));
//                		(wHeadData.values[j] == wHeadData.values[j - 1] && wHeadData.captions[j] == wHeadData.captions[j - 1]) &&
//                		(wHeadData.values[j-1] != (wHeadData1 != "" ? wHeadData1.values[j - 1] : "") && wHeadData.captions[j-1] != (wHeadData1 != "" ? wHeadData1.captions[j - 1] : "")) ? "true" : "false"));
    	    }

    	    for (var wRowNum = this.headRows; wRowNum < this.maxRows + this.headRows; wRowNum++){
    	        wCell = dataTableBody.rows[wRowNum].cells[wColNum];
    	        wCell.setAttribute("decimal", decimal);
    	        if (wHeadData.Level > 1)
    	            wCell.className = "CSumBack" + wHeadData.Level + " CSumLineR" + wLevel;
    	    }
        
            if (wHeadData.childInfo == "NONE") {
                if (wRCs.length > 0) wRCs += ",";
                wRCs += "CELL(\"RXXC" + wSheetColNum + "\")";
            }

    	    wColNum++;
    	}

    	this.stepRCs[stepNum] = wRCs;
    	startNum[0] = wColNum;

        return;
    };

    CrossSheetH.prototype.fillColData = function(stepNum, stepObject){
        // functionname : [CrossSheetH.fillColData]
        
        var wStartNum = this.stepstartNums[stepNum];
        var wFieldPoint = stepObject.fieldPoint;
        var wRowLevelCnt = this.rowLevelCnt;
        var wColLevelCnt = stepObject.levelCnt;
        
        var keyCount     = 0;
        var headKeyCount = 0;
        var bodyKeyCount  = 0;

    	var wArrDatas = stepObject.datas; 
	    // key count 계산
        if (wArrDatas.length >= 1){
            for (var i = 1; wArrDatas[0].length;i++) {
            	if (wArrDatas[0][i] == null) break; 
            	keyCount++;
            }
        }

	    // 시트 해더 데이터를 정렬한다 
	    var startKeyPos = wRowLevelCnt - wFieldPoint;
        if (this.headDatasSorted == null){
	    	this.headDatasSorted = sortedArrayWithOrderTag(this.headDatas, startKeyPos, wRowLevelCnt, wColLevelCnt);
	    }
        var wArrHeadDatas1 = this.headDatasSorted;
        
        startKeyPos = wColLevelCnt - (keyCount - wFieldPoint);
	    var wArrHeadDatas2 = stepObject.headDatasSorted = sortedArrayWithOrderTag(this.stepHeadDatas[stepNum], startKeyPos, wColLevelCnt, wStartNum);
	    
        headKeyCount = wFieldPoint;
        bodyKeyCount = keyCount - wFieldPoint;
        
        // 내부변수 선언 
        var wData = null; var wValue = null; var wWorkKey = null;
        var wData1 = null; var wCompKey = null;
        var wColNum = -1; var wRowNum = -1; 
        
        var wRowArrData = null; var wColArrData = null;
        var dataTableBody = this.dataTable.tBodies[0];
        
        for (var i = 0; i < wArrDatas.length; i++){
            wData = wArrDatas[i];
            wValue = wData[0];
            
            // 줄번호 찾기 
            wWorkKey = wData.slice(1, wFieldPoint + 1); 
            wRowArrData = searchArray(wArrHeadDatas1, wWorkKey);
            wRowNum = (wRowArrData != null ? wRowArrData[wRowArrData.length - 1] : -1);
            // 칼럼번호 찾기
            if (!stepObject.isSQL){
            	wColNum = wStartNum;
            } else {
                wWorkKey = wData.slice(headKeyCount + 1, keyCount + 1); 
                wColArrData = searchArray(wArrHeadDatas2, wWorkKey);
                wColNum = (wColArrData != null ? wColArrData[wColArrData.length - 1] : -1);
            }
            
            
            if (wRowNum >= 0 && wColNum >= 0){
                var wCell = dataTableBody.rows[wRowNum].cells[wColNum];
                wCell.setAttribute("value", wValue);
                if (("" + wValue).isNum())  { 
                	var decemal = parseInt(1 * wCell.getAttribute("decimal"));
                    wCell.innerText = mask(wValue, "###,###,###,###,##0" + (decemal > 0 ? ".0000000000".substring(0, decemal + 1) : ""));
                    wCell.align     = "right";
                } else { 
                    wCell.innerText = wValue;
                    wCell.align     = "left";
                }
            }
        }

        if (wWorkKey) wWorkKey.clear();
//        if (wArrHeadDatas2) wArrHeadDatas2.clear(); 
//        wArrHeadDatas2 = null;
        
        return;
    };

    CrossSheetH.prototype.makeColFormula = function(stepNum, stepObject){
        // functionname : [CrossSheetH.makeColFormula]\
    	
        var dataTableRows = this.dataTable.tBodies[0].rows;
        
        // 산식중 괄호를 찾아낸다
        var wFormula = stepObject.datas[0][0];
        while (wFormula.indexOf("( ") >= 0) wFormula.replaceWord("( ","(");
        while (wFormula.indexOf(" )") >= 0) wFormula.replaceWord(" )",")");
        
        // 괄호의 내용을 RC타입의 ","문자 연결열로 변환한다.
        // R은 변화하고 C는 고정이다 RnCXX로 
        for (var wStepNum = 1; wStepNum < this.stepRCs.length; wStepNum++){
           while (wFormula.indexOf("(" + wStepNum + ")") >= 0) 
               wFormula = wFormula.replaceWord("(" + wStepNum + ")","(" + this.stepRCs[wStepNum] + ")");
        }
        
        // 칼럼별로 루핑하며 산식을 넣는다(합계셀은 제외)
        // RnCXX의 XX를 칼럼번호로 변환
        var wStartNum = this.stepstartNums[stepNum];

        var wRowLevelCnt = stepObject.levelCnt;
        for (var i = 0; i < this.headDatas.length; i++){
            if (this.headDatas[i].childInfo == "NONE"){
                var wHardColNum = wStartNum;
                var wHardRowNum = this.headRows + i;
                var wRowNum = i + 1;
                
                var wCell = dataTableRows[wHardRowNum].cells[wHardColNum];
                wCell.setAttribute("formula", wFormula.replaceWord("XX" , wHardRowNum + ""));
            }
        }
        return;
    };

    CrossSheetH.prototype.makeRowSums = function(){
        // functionname : [CrossSheetH.makeColFormula]

        var wArrHeadDatas = this.headDatas;
        var dataTableRows = this.dataTable.tBodies[0].rows;
    	
    	for (var i = 0; i < wArrHeadDatas.length; i++){
    	    var wRowNum = i + this.headRows;
    	    var wHeadData = wArrHeadDatas[i];
            
            // 산식을 먼저 만든다. 
            if (wHeadData.childInfo != "NONE"){
                var wArrRowNums = wHeadData.childInfo.split(",");
                var wFormula = "";
                var wLastRC  = "";
    
                for (var j = 0; j < wArrRowNums.length; j++){
                    if (j > 0) wFormula += ",";
                    var wwRowNum = parseInt(wArrRowNums[j]) + this.headRows - 1;
                    wFormula += "CELL(\"R" + wwRowNum + "CXX\")";
                    wLastRC   = "CELL(\"R" + wwRowNum + "CXX\")";
                }

                if (wHeadData.functionName == getText("message_crosssheeth_010", "합계") || wHeadData.functionName == getText("message_crosssheeth_016", "Sum")){
                    wFormula = "SUM(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheeth_011", "평균") || wHeadData.functionName == getText("message_crosssheeth_017", "Average")){
                    wFormula = "AVG(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheeth_012", "최대값") || wHeadData.functionName == getText("message_crosssheeth_018", "Max Value")){
                    wFormula = "MAX(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheeth_013", "최소값") || wHeadData.functionName == getText("message_crosssheeth_019", "Min Value")){
                    wFormula = "MIN(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheeth_014", "최종값") || wHeadData.functionName == getText("message_crosssheeth_020", "Last value")){
                    wFormula = wLastRC;
                }
                
                // 셀에 산식값 
                for (var j = 0; j < this.maxCols; j++){
                    var wColNum = this.headCols + j;
                    var wSheetColNum = j + 1;
                    var wCell = dataTableRows[wRowNum].cells[wColNum];
                    wCell.setAttribute("formula", wFormula.replaceWord("XX" , wColNum + ""));
                   
                    // this.addToFormulaRefs(wRowNum, wColNum, wCell.formula);
                }
            }
            
    	}

        return;
    };
    
    CrossSheetH.prototype.makeStepSums = function(stepNum){
        // functionname : [CrossSheetH.makeStepSums]

        var wStartNum = this.stepstartNums[stepNum];
        var wArrHeadDatas = this.stepHeadDatas[stepNum];
    	var dataTableRows = this.dataTable.tBodies[0].rows;
    	
    	for (var i = 0; i < wArrHeadDatas.length; i++){
    	    var wColNum = wStartNum + i;
    	    var wHeadData = wArrHeadDatas[i];
    	    
            // 산식을 먼저 만든다. 
            if (wHeadData.childInfo != "NONE"){
                var wArrColNums = wHeadData.childInfo.split(",");
    	    
                var wFormula = "";
                var wLastRC  = "";
                for (var j = 0; j < wArrColNums.length; j++){
                    if (j > 0) wFormula += ",";
                    wFormula += "CELL(\"RXXC" + (wStartNum + parseInt(wArrColNums[j], 10) - 1) + "\")";
                    wLastRC   = "CELL(\"RXXC" + (wStartNum + parseInt(wArrColNums[j], 10) - 1) + "\")";
                }
                
                if (wHeadData.functionName == getText("message_crosssheeth_010", "합계") || wHeadData.functionName == getText("message_crosssheeth_016", "Sum")){
                    wFormula = "SUM(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheeth_011", "평균") || wHeadData.functionName == getText("message_crosssheeth_017", "Average")){
                    wFormula = "AVG(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheeth_012", "최대값") || wHeadData.functionName == getText("message_crosssheeth_018", "Max Value")){
                    wFormula = "MAX(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheeth_013", "최소값") || wHeadData.functionName == getText("message_crosssheeth_019", "Min Value")){
                    wFormula = "MIN(" + wFormula + ")";
                } else if (wHeadData.functionName == getText("message_crosssheeth_014", "최종값") || wHeadData.functionName == getText("message_crosssheeth_020", "Last value")){
                    wFormula = wLastRC;
                }
                
                // 셀에 산식값 
                for (var j = 0; j < this.maxRows; j++){
                    var wRowNum = this.headRows + j;
                    var wSheetRowNum = j + 1;
                    var wCell = dataTableRows[wRowNum].cells[wColNum];
                    wCell.setAttribute("formula", wFormula.replaceWord("XX" , wRowNum + ""));
                    // this.addToFormulaRefs(wRowNum, wColNum, wCell.formula);
                }
            }
            
    	}

        return;
    };
    
    CrossSheetH.prototype.makeStepRemarks = function(stepNum, remark){
        // functionname : [CrossSheetH.makeStepRemarks]

        if (this.remarkRows == 0) return;
        if ((remark || "").trim().length == 0) return;
        
        var dataTableRows = this.dataTable.tBodies[0].rows;
        
        var wStartNum = this.stepstartNums[stepNum];
        var wEndNum = (stepNum < this.stepstartNums.length - 1 ? this.stepstartNums[stepNum + 1] - 1: this.headCols + this.maxCols - 1);
        
    	var wDataTable = this.dataTable;    
    	for (var i = wStartNum; i <= wEndNum; i++){
            var wColNum = i;
            var wRowNum = this.headRows + this.maxRows + this.remarkRows - 1;
    	    
            if (i == wEndNum)
            	dataTableRows[wRowNum].cells[wColNum].innerText = remark;
    	}
        return;
    };

    CrossSheetH.prototype.adjustColWidth = function(){
        // functionname : [CrossSheetH.adjustColWidth]

    	var dataTableRows = this.dataTable.tBodies[0].rows;
    	var colTableRows = this.colHeadTable.tBodies[0].rows;
    	var rowTableRows = this.rowHeadTable.tBodies[0].rows;
    	var fixTableRows = this.fixCellTable.tBodies[0].rows;
    	
    	//for (var wColNum = this.headCols; wColNum < this.headCols + this.maxCols + this.remarkCols; wColNum++){
    	for (var wColNum = 0; wColNum < this.headCols + this.maxCols + this.remarkCols; wColNum++){
        	var wMaxLen = 50;
        	//for (var wRowNum = this.headRows; wRowNum < this.headRows + this.maxRows; wRowNum++){
//        	for (var wRowNum = 0; wRowNum < this.headRows + this.maxRows; wRowNum++){
//       	for (var wRowNum = 0; wRowNum < this.headRows + this.maxRows + this.remarkRows; wRowNum++){
      		for (var wRowNum = (this.headRows-1); wRowNum < this.headRows + this.maxRows + this.remarkRows; wRowNum++){
//                var wText = dataTableRows[wRowNum].cells[wColNum].innerText || "0";
//                var wByteLength = wText.bytes();
//                var WIDTH_PLUS = ((/[A-Z]/).test(wText) ? 1 : 0);	// 문자에 대문자가 있는 경우 폰트를 +1 해준다
//        	    wMaxLen = (wMaxLen < wByteLength * (FONT_WIDTH + WIDTH_PLUS) ? wByteLength * (FONT_WIDTH + WIDTH_PLUS) : wMaxLen);
       			var wTextPixel = this.getTextLengthInPixel(dataTableRows[wRowNum].cells[wColNum]);
       			wMaxLen = (wMaxLen < wTextPixel ? wTextPixel : wMaxLen);
    	    } 
        	
//        	wMaxLen += 10;	//2019-03-28 jaeik 좌우padding 사이즈 만큼 늘려줌
        	wMaxLen += 20;	//2019-12-03 jaeik 좌우padding 사이즈 만큼 늘려줌
    	    
            // 헤드 칼럼들만의 사이즈를 조정한다
        	for (var wRowNum = 0; wRowNum < this.headRows; wRowNum++){
        		dataTableRows[wRowNum].cells[wColNum].style.width = wMaxLen + "px";
        		colTableRows[wRowNum].cells[wColNum].style.width = wMaxLen + "px";
        		dataTableRows[wRowNum].cells[wColNum].style.maxWidth = wMaxLen + "px";
        		colTableRows[wRowNum].cells[wColNum].style.maxWidth = wMaxLen + "px";
                if (wColNum < this.headCols){
                	dataTableRows[wRowNum].cells[wColNum].style.width = wMaxLen + "px";
                	colTableRows[wRowNum].cells[wColNum].style.width = wMaxLen + "px";
                	rowTableRows[wRowNum].cells[wColNum].style.width = wMaxLen + "px";
                	fixTableRows[wRowNum].cells[wColNum].style.width = wMaxLen + "px";
                }
    	    } 
    	}
    	
    	// 테이블 사이즈 조정
    	this.adjustTableWidth();
    	
        return;
    };
    
    CrossSheetH.prototype.getTextLengthInPixel = function(cell) {
        var myId = 'my_span_ruler';
        var ruler = document.getElementById(myId);
       
        if (!ruler) {
            ruler = document.createElement('span');
            ruler.id = myId;
            // 안보이게
            ruler.setAttribute('style', 'visibility:hidden; white-space:nowrap; position:absolute; left:-9999px; top: -9999px;');
            document.body.appendChild(ruler);
        }
       
        // 폰트 스타일
        ruler.style.font = getComputedStyle(cell).font;
        ruler.innerText = cell.innerText || "0";
       
        return ruler.offsetWidth;
    };
    
    CrossSheetH.prototype.adjustTableWidth= function(){
        // functionname : [CrossSheetH.adjustTableWidth]

    	var wTableWidth = GAP_BETWEEN_CELL;
    	var wTableWidth1 = GAP_BETWEEN_CELL;
    	var wTableWidthString = "";

        var wDataTableBody = this.dataTable.tBodies[0];
        var wMaxColNum = wDataTableBody.rows[0].cells.length;
        for (var wColNum = 0; wColNum < wMaxColNum; wColNum++){
    	    var wWidth = parseIntSize(wDataTableBody.rows[0].cells[wColNum].style.width);
    	    wTableWidth += wWidth + (wWidth == 0 ? 0 : GAP_BETWEEN_CELL);
    	    if (wColNum < this.headCols) 
    	    	wTableWidth1 += wWidth + (wWidth == 0 ? 0 : GAP_BETWEEN_CELL);
    	    wTableWidthString += (wColNum == 0 ? "" : ";") + wWidth;
        }
    
    	this.tagObject.setAttribute("cellSize", wTableWidthString);
        this.dataTable.style.width = wTableWidth + "px";
        this.colHeadTable.style.width = wTableWidth + "px";
        this.rowHeadTable.style.width = wTableWidth1 + "px";
        this.fixCellTable.style.width = wTableWidth1 + "px";
        return;    
    };
    
    CrossSheetH.prototype.setRowTitleMerge = function(tableBody){
    	// functionname : [CrossSheetH.setRowTitleMerge]
    	
    	var wColSpan = 1;
    	for (var wRowNum = 0; wRowNum < this.headRows; wRowNum++){
    	    var wRow = tableBody.rows[wRowNum];
    	    
    	    for (var i = this.headCols-1; i >= 0; i--) {
       	    	var col = wRow.cells[i];
       	    	var wWidthToAdd = 0;
       	    	
       	    	if (col.getAttribute("NeedDel") == "false") {
       	    		wColSpan = 1;
           	    	for (var wColNum = i+1; wColNum < this.headCols; wColNum++) {
               	    	var wCell = wRow.cells[wColNum];
               	    	if (wCell.getAttribute("NeedDel") == "false") break;
            	        if (wCell.getAttribute("NeedDel") == "true" || wCell.innerText == ""){
            	        	wWidthToAdd += (parseIntSize(wCell.style.width) + GAP_BETWEEN_CELL);
            	        	wColSpan++;
            	        }
               	    }
       	    	}
           	    
       	    	if (wColSpan > 1) {
       	    		col.colSpan = wColSpan;
           	    	col.style.width = (parseIntSize(col.style.width) + wWidthToAdd) + "px";
       	    	}
       	    }
       	    
           	 for (var wColNum = this.headCols-1; wColNum >= 0; wColNum--) {
        	    	var wCell = wRow.cells[wColNum];
     	        if (wCell.getAttribute("NeedDel") == "true" || wCell.innerText == ""){
     	        	wRow.deleteCell(wColNum);
     	        }
    	    }        	    
        }
    };

    CrossSheetH.prototype.setRowHeadSpan = function(noneCaption){
        // functionname : [CrossSheetH.setRowHeadSpan]

        var wArrHeadDatas = this.headDatas;
        var wRowHeadTableBody = this.rowHeadTable.tBodies[0];

        for (var wLevel = this.headCols; wLevel >= 1; wLevel--){
            var wColNum = wLevel - 1;
            var wRowSpan = 1;
        
    	    for (var i = wArrHeadDatas.length - 1; i >= 0; i--){ 
                var wRowNum = this.headRows + i;
                var wHeadData  = wArrHeadDatas[i];
                var wRow = wRowHeadTableBody.rows[wRowNum];
                var wCell = wRow.cells[wColNum];
        
                var wHeadData0 = (i > 0 ? wArrHeadDatas[i - 1] : new HeadData()); // 0일때 에러방지
                
                var wChecked = true;
                for (var j = 0; j <= wColNum; j++)
                    wChecked = wChecked && (wHeadData.values[j] == wHeadData0.values[j]);
                
                if (wChecked){
                    wRow.deleteCell(wColNum);
                    wHeadData.merged[wColNum] = "Y";
                    
                    wRowSpan++;

                } else {
                    if (wRowSpan > 1) {
                    	wCell.rowSpan = wRowSpan;
                    }
                    wRowSpan = 1;

                    var wColSpan = 1;
                    
                    for (var j = wColNum + 1; j <= this.headCols - 1; j++){
//                        wColSpan += (wHeadData.values[j] == "" ? 1 : 0);
                    	wColSpan += (wRow.cells[j].getAttribute("NeedDel") == "true" || wHeadData.values[j] == "" ? 1 : 0);
                    }
                    if (wColSpan > 1)  {
                        wCell.colSpan = wColSpan;
                    }
                }
            }
        }
        var wRowNum = 0;
	    var wRow = wRowHeadTableBody.rows[wRowNum];
	    var wColSpan = 1;

	    for (var wColNum = wRow.cells.length -1 ; wColNum > 0; wColNum--){
	        var wCell = wRow.cells[wColNum];
	        if (wCell.getAttribute("NeedDel") == "true" || wCell.innerText == ""){
	            wColSpan++;
	        }
	    }
	    wRow.cells[0].colSpan = wColSpan;
        
	    for (var wRowNum = this.headRows; wRowNum < wRowHeadTableBody.rows.length; wRowNum++){
    	    var wRow = wRowHeadTableBody.rows[wRowNum];
    	    for (var wColNum = wRow.cells.length -1 ; wColNum >= 0; wColNum--){
    	        var wCell = wRow.cells[wColNum];
    	        if (wCell.getAttribute("NeedDel") == "true" || wCell.innerText == ""){
    	            wRow.deleteCell(wColNum);
    	        }
    	    }
        }
       	
       	/**
       	 * 2019-05-13 jaeik 로우타이틀 rowTable,fixedTable 병합처리
       	 */
       	var rowTitle = this.dataObject.head.rowTitle;
    	if (rowTitle != null && rowTitle.length > 0) {
    		this.setRowTitleMerge(wRowHeadTableBody);
    		this.setRowTitleMerge(this.fixCellTable.tBodies[0]);    		
    	}
        
        if (this.remarkRows > 0){
            var wRowNum = wRowHeadTableBody.rows.length - 1;
            
            var wCell = wRowHeadTableBody.rows[wRowNum].cells[0];
            wCell.innerText = getText("message_crosssheeth_021", "비고");
            wCell.colSpan = this.headCols;
            
            var wRow = this.dataTable.tBodies[0].rows[wRowNum];
            for (var wColNum = this.headCols - 1; wColNum >= 0; wColNum--){
            	wRow.cells[wColNum].innerText = wCell.innerText;
            }
            
            for (var wColNum = this.headCols - 1; wColNum > 0; wColNum--){
            	wRowHeadTableBody.rows[wRowNum].deleteCell(wColNum);
            }
        }        
        
        return;
    };
    
    CrossSheetH.prototype.setColHeadSpans = function(stepNum, levelCnt, noneCaption, titleBySQL){
        // functionname : [CrossSheetH.setColHeadSpans]

        var wStartNum = this.stepstartNums[stepNum];
        var wEndNum = (stepNum < this.stepstartNums.length - 1 ? this.stepstartNums[stepNum + 1] - 1: this.headRows + this.maxRows - 1);
        var wArrHeadDatas = this.stepHeadDatas[stepNum];
        
        var wColHeadTableBody = this.colHeadTable.tBodies[0];
        
        for (var wLevel = levelCnt - 1; wLevel >= 1; wLevel--){
            // var wRowNum = wLevel - 1;
            var wRowNum = wLevel;
            var wColSpan = 1;
            var wWidthToAdd = 0;

    	    for (var i = wArrHeadDatas.length - 1; i >= 0; i--){ 
                var wColNum = wStartNum + i;
                var wHeadData  = wArrHeadDatas[i];
                var wHeadData0 = (i > 0 ? wArrHeadDatas[i - 1] : new HeadData()); // 0일때 에러방지

                var wChecked = true;
                for (var j = 0; j <= wLevel - 1; j++)
                    wChecked = wChecked && (wHeadData.values[j] == wHeadData0.values[j]);
                
                if (wChecked){
                    wWidthToAdd += (parseIntSize(wColHeadTableBody.rows[wRowNum].cells[wColNum].style.width) + GAP_BETWEEN_CELL);
                    wColHeadTableBody.rows[wRowNum].deleteCell(wColNum);
                    wHeadData.merged[wRowNum] = "Y";
                    
                    wColSpan++;
                } else {
                    var wCell = wColHeadTableBody.rows[wRowNum].cells[wColNum];
                    if (typeof wCell == "undefined") continue;
                    wCell.colSpan = wColSpan;
                    wCell.style.width = (parseIntSize(wCell.style.width) + wWidthToAdd) + "px";
                                     
                    wColSpan = 1;
                    wWidthToAdd = 0;
                    
                    var wRowSpan = 1;
                    for (var j = wRowNum + 1; j <= this.headRows; j++)
//                         wRowSpan += (wHeadData.values[j] == "" ? 1 : 0);
                    	wRowSpan += ((typeof wColHeadTableBody.rows[j].cells[wColNum] != "undefined" && wColHeadTableBody.rows[j].cells[wColNum].getAttribute("NeedDel") == "true") || wHeadData.values[j] == "" ? 1 : 0);

                    if (wRowSpan > 1){
                        wCell.rowSpan = wRowSpan;
                    }
                }
            }
        }

    	if (!titleBySQL){  // 쿼리에 의하지 않고 인위적으로 타이틀을 만든 경우라면 
            var wColNum = wStartNum;
 	        var wRowSpan = 1;

    	    //for (var wRowNum = this.headRows -1 ; wRowNum > 0; wRowNum--){
        	for (var wRowNum = this.headRows ; wRowNum > 1; wRowNum--){
           	    var wRow = wColHeadTableBody.rows[wRowNum];
     	        var wCell = wRow.cells[wColNum];
    	        if (wCell.getAttribute("NeedDel") == "true" || wCell.innerText == ""){
    	            wRowSpan++;
    	        }
    	    }
    	    wColHeadTableBody.rows[1].cells[wColNum].rowSpan=wRowSpan;
        }
        
        
    	for (var wRowNum = 1; wRowNum <= this.headRows; wRowNum++){
    	    var wRow = wColHeadTableBody.rows[wRowNum];
    	    for (var wColNum = wRow.cells.length - 1; wColNum >= wStartNum; wColNum--){
    	        if (wRow.cells[wColNum].getAttribute("NeedDel") == "true" || wRow.cells[wColNum].innerText == ""){
    	            wRow.deleteCell(wColNum);
    	        }
    	    }
        }
        return;
    };

    // 여기서 부터는 열숨기기
    CrossSheetH.prototype.hideChildCols = function(cell, showAction){
        // functionname : [CrossSheetH.hideChildCols]


        var wRowNum = cell.parentNode.rowIndex;
        var wColNum = cell.cellIndex;
        
        var wHeadIndex = this.findHeadIndex(wColNum, wRowNum);
        
        var wArrHeadDatas = this.headDatas;
        var wKeyData = ["","","","",""];
           
        var wHeadData = wArrHeadDatas[wHeadIndex];
        for (var j = 0; j <= pLevelNum; j++){
            wKeyData[j] = wHeadData.values[j];
        } 
        
        for (var wHeadIndex = 0; wHeadIndex < this.headDatas.length; wHeadIndex++){
            if (wArrHeadDatas[wHeadIndex].values[pLevelNum].length == 0) continue;

            var wChecked = true;
            var wHeadDataTo = wArrHeadDatas[wHeadIndex];
            for (var j = 0; j <= pLevelNum; j++){
                wChecked = wChecked && (wKeyData[j] == wHeadDataTo.values[j]);
            } 

            if (wChecked && showAction == ACTION_HIDE) {
                this.hideCol(wHeadIndex);
            } else if (wChecked && showAction == ACTION_SHOW) {
                this.showCol(wHeadIndex);
            }
        }
        
        // 전체 테이블 크기정보 갱신
    	this.adjustTableWidth();
    };
    
    CrossSheetH.prototype.hideColLevels = function(levelCount, levelNum){
        // functionname : [CrossSheetH.hideChildCols]

        var wArrHeadDatas = this.headDatas;
        var wKeyData = ["","","","",""];

        for (var i = 0; i < this.headDatas.length; i++){
            if (!wArrHeadDatas[i].hideChild) continue;
            
            var wHeadData = wArrHeadDatas[i];
            for (var j = 0; j < levelNum; j++){
                wKeyData[j] = wHeadData.values[j];
            } 
            
            for (var wHeadIndex = 0; wHeadIndex < this.headDatas.length; wHeadIndex++){
                if (wArrHeadDatas[wHeadIndex].values[levelNum].length == 0) continue;

                var wChecked = true;
                var wHeadDataTo = wArrHeadDatas[wHeadIndex];
                for (var j = 0; j < levelNum; j++){
                    wChecked = wChecked && (wKeyData[j] == wHeadDataTo.values[j]);
                } 
                
                if (wChecked) this.hideCol(wHeadIndex);
            }
        }
        
        // 전체 테이블 크기정보 갱신
    	this.adjustTableWidth();
    	
        return;
    };
    
    CrossSheetH.prototype.hideCol = function(headIndex){
        // functionname : [CrossSheetH.hideCol]

        // 최소레벨부터 상위레벨로 돌면서 셀사이즈를 줄여나간다
        var wColNum = this.headCols + headIndex;
        var wWidth = parseIntSize(this.dataTable.tBodies[0].rows[0].cells[wColNum].style.width) + "px";
        wCell.setAttribute("oldWidth", wWidth);
        
        for (var wLevel = 1; wLevel <= this.colLevelCnt; wLevel++){
            var wRowNum = wLevel - 1;
            var wCellIndex = this.FindCellIndex(headIndex, wLevel - 1);
            if (wCellIndex >= 0){
        	    wCell = this.colHeadTable.tBodies[0].rows[wRowNum].cells[this.headCols +wCellIndex];
                var wCurrnetWidth = parseIntSize(wCell.style.width);
                wCell.style.width = (wCurrnetWidth - wWidth 
                                  - (wCurrnetWidth > wWidth ? GAP_BETWEEN_CELL : 0)) + "px";
                
            }
        }
        
        for (var wRowNum = 0; wRowNum < this.dataTable.tBodies[0].rows.length; wRowNum++){
            this.dataTable.tBodies[0].rows[wRowNum].cells[wColNum].style.width = 0 + "px";
        }
        
        return;
    };
    
    CrossSheetH.prototype.showCol = function(headIndex){
        // functionname : [CrossSheetH.showCol]

        // 최소레벨부터 상위레벨로 돌면서 셀사이즈를 줄여나간다
        var wColNum = this.headCols + headIndex;
        var wWidth = parseIntSize(this.dataTable.tBodies[0].rows[wRowNum].cells[wColNum].oldWidth);
        
        for (var wLevel = 1; wLevel <= this.colLevelCnt; wLevel++){
            var wRowNum = wLevel - 1;
            var wHardColNum = this.headCols + this.FindCellIndex(headIndex, wLevel);

    	    wCell = this.colHeadTable.tBodies[0].rows[wRowNum].cells[wHardColNum];
            wCell.style.width = (parseIntSize(wCell.style.width) + wWidth) + "px";
        }
        for (var wRowNum = 0; wRowNum < this.dataTable.tBodies[0].rows.length; wRowNum++){
            this.dataTable.tBodies[0].rows[wRowNum].cells[wColNum].style.width = wWidth + "px";
        }
        
        return;
    };
    
    // 좌측상단의 셀을 통합한다
    CrossSheetH.prototype.mergeUpperMost = function(){
        // functionname : [CrossSheetH.mergeUpperMost]

        var wTable = this.fixCellTable;
        var firstRow  = wTable.tBodies[0].rows[0];
        var firstCell = firstRow.cells[0];
        var wHeight = 0;
        var wWidth  = parseIntSize(wTable.style.width);
        
        for (var wRow = 0; wRow < wTable.tBodies[0].rows.length; wRow++){
//            wHeight += parseIntSize(wTable.tBodies[0].rows[0].style.height) + GAP_BETWEEN_CELL; 
        	wHeight += parseIntSize(wTable.tBodies[0].rows[0].style.height);
        }

        var wTable = this.fixCellTable;
        for (var wRow = wTable.tBodies[0].rows.length - 1; wRow > 0; wRow--){
            wTable.deleteRow(wRow);
        }
        
        var wRow = wTable.tBodies[0].rows[0];
        wRow.style.display = "";
        for (var wColNum = wRow.cells.length - 1; wColNum > 0; wColNum--){
            wRow.deleteCell(wColNum);
        }
        firstCell.style.width = wWidth + "px";
        firstRow.style.height = wHeight + "px";
        return;
    };
    
    // 여기서 부터는 줄숨기기
    CrossSheetH.prototype.hideStepChildRows = function(cell, showAction){
        // functionname : [CrossSheetH.hideStepChildRows]

        var wRowNum = cell.parentNode.rowIndex;
        var wColNum = cell.cellIndex;
        
        var wStepNum = this.findStepNum(wRowNum, wColNum);
        var wHeadIndex = this.findHeadIndex(wRowNum, wColNum, wStepNum);
        
        var wArrHeadDatas = this.stepHeadDatas[wStepNum];
        var wKeyData = ["","","","",""];
           
        var wHeadData = wArrHeadDatas[wHeadIndex];
        for (var j = 0; j <= levelNum; j++){
            wKeyData[j] = wHeadData.values[j];
        } 
        
        for (var wHeadIndex = 0; wHeadIndex <= this.headDatas.length; wHeadIndex++){
            if (wArrHeadDatas[wHeadIndex].values[levelNum].length == 0) continue;

            var wChecked = true;
            var wHeadDataTo = wArrHeadDatas[wHeadIndex];
            for (var j = 0; j <= levelNum; j++){
                wChecked = wChecked && (wKeyData[j] == wHeadDataTo.values[j]);
            } 
            
            if (wChecked && showAction == ACTION_HIDE) {
                this.hideRow(wHeadIndex, wStepNum);
            } else if (wChecked && showAction == ACTION_SHOW) {
                this.showRow(wHeadIndex, wStepNum);
            }
        }
        
        return;
    };
    
    CrossSheetH.prototype.hideStepRowLevels = function(levelCount, levelNum, stepNum){
        // functionname : [CrossSheetH.hideStepRowLevels]

        var wArrHeadDatas = this.stepHeadDatas[stepNum];
        var wKeyData = ["","","","",""];
        
        for (var i = 0; i <= this.headDatas.length; i++){
            if (!wArrHeadDatas[i].hideChild) continue;
            
            var wHeadData = wArrHeadDatas[i];
            for (var j = 0; j <= levelNum; j++){
                wKeyData[j] = wHeadData.values[j];
            } 
            
            for (var wHeadIndex = 0; wHeadIndex <= this.headDatas.length; wHeadIndex++){
                if (wArrHeadDatas[wHeadIndex].values[levelNum].length == 0) continue;

                var wChecked = true;
                var wHeadDataTo = wArrHeadDatas[wHeadIndex];
                for (var j = 0; j <= levelNum; j++){
                    wChecked = wChecked && (wKeyData[j] == wHeadDataTo.values[j]);
                } 
                
                if (wChecked) this.hideRow(wHeadIndex, stepNum);
            }
        }
    	
        return;
    };
    
    CrossSheetH.prototype.hideRow = function(headIndex, stepNum){
        // functionname : [CrossSheetH.hideRow]

        // 최소레벨부터 상위레벨로 돌면서 셀사이즈를 줄여나간다
        var wRowNum = this.headRows + headIndex;
        
        var wRow = this.dataTable.tBodies[0].rows[wRowNum];
        wRow.oldheight = parseIntSize(wRow.style.height);
        wRow.style.height = 0 + "px";
        
        wRow = this.colHeadTable.tBodies[0].rows[wRowNum];
        wRow.style.height = 0 + "px";
        
        return;
    };
    
    CrossSheetH.prototype.showRow = function(headIndex, stepNum){
        // functionname : [CrossSheetH.showRow]

        // 최소레벨부터 상위레벨로 돌면서 셀사이즈를 줄여나간다
        var wRowNum = this.headRows + headIndex;
        
        var wRow = this.dataTable.tBodies[0].rows[wRowNum];
        var wHeight = wRow.oldheight;
        wRow.style.height = wHeight + "px";
        wRow = this.colHeadTable.tBodies[0].rows[wRowNum];
        wRow.style.height = wHeight + "px";
        
        return;
    };


    CrossSheetH.prototype.findCellIndex = function(headIndex, hardLevel, stepNum){
        // functionname : [CrossSheetH.showRow]

        // stepNum이 생략되면 전체헤더이다
        var wArrHeadDatas = (stepNum ? this.stepHeadDatas[stepNum] : this.headDatas);
        
        // 상하로 머지된 경우 X가 붙는다
        if (wArrHeadDatas[headIndex].merged[hardLevel] == "X") return -1;
        
        var wReturn = -1;
        for (var i = 0; i <= headIndex; i++){
            wReturn += (wArrHeadDatas[i].merged[hardLevel] == "N" ? 1 : 0);
        }
        return wReturn;
    };
    
    CrossSheetH.prototype.findHeadIndex = function(cellIndex, hardLevel, stepNum){
        // functionname : [CrossSheetH.findHeadIndex]

        // stepNum이 생략되면 전체헤더이다
        var wArrHeadDatas = (stepNum ? this.stepHeadDatas[stepNum] : this.headDatas);
        var wReturn = -1; var wIndex = this.headCols - 1;
        for (var i = 0; i < wArrHeadDatas.length; i++){
            wIndex += (wArrHeadDatas[i].merged[hardLevel] ? 0 : 1);
            if (cellIndex >= wIndex) {wReturn = i; break;}
        }
        return wReturn;
    };
    
    CrossSheetH.prototype.findStepNum = function(cellIndex, hardLevel){
        // functionname : [CrossSheetH.findStepNum]

        // stepNum이 생략되면 전체헤더이다
        var wReturn = this.stepstartNums.length - 1; 
        for (var i = 1; i < this.stepstartNums.length; i++){
            if (this.stepstartNums[i] > cellIndex){
                wReturn = i - 1; break;
            }
        }
        return wReturn;
    };
    
    /***************************************************************************
        시트 함수의 동작에관한 부분이다
    ***************************************************************************/
    CrossSheetH.prototype.recalculate = function(){
            // functionname : [CrossSheetH.recalculate]

        for (var wRowNum = 1; wRowNum < this.maxRows + this.headRows; wRowNum++){
            var wRow = this.dataTable.rows[wRowNum];
            for (var wColNum = 1; wColNum < this.maxCols + this.headCols; wColNum++){
                var wCell = wRow.cells[wColNum];
                var wFormula = wCell.getAttribute("formula") || "";
                if (wFormula.length > 0){
                    this.calculateCell(wCell, wFormula);
                }
            }  
        }  
        
        return;
    };
    
    // 자기자신을 먼저 계산후에 다른 참조셀을 바꾼다
    CrossSheetH.prototype.calculateCell = function(cell, formula){
        // functionname : [CrossSheetH.calculateCell]

	    var wFormula = formula || "";

        // wLogic.clear();
    	var wCell = cell;
    	
    	wFormula = this.replaceToEasyFormula(wFormula);
        var wValue = calc(wFormula);

        if (wValue != wCell.getAttribute("value")){
            wCell.setAttribute("value", wValue);
            wCell.align = "right";
            wCell.valign = "middle";
//            wCell.valign = "baseline";
            
            var decemal = parseInt(1 * wCell.getAttribute("decimal"));
            wCell.innerText = mask(wValue, "###,###,###,###,##0" + (decemal > 0 ? ".0000000000".substring(0, decemal + 1) : "")); 

        }

        return; 
    };
    
    // 산식의 셀문자열에 셀값을 대치하여 준다 예: R1C1 -> "142" 
    CrossSheetH.prototype.replaceToEasyFormula = function(formula){
        // functionname : [CrossSheetH.replaceToEasyFormula]

        // Cell함수를 루핑하면서 계속 찾는다 
	    var wFormula = formula || "";
        // 케리지리턴이나 탭등을 제거한다 
    	wFormula = wFormula.replace(/\r\n/g," ").replace(/\t/g," ").trim();
    	
	    // 대문자로 변환
    	wFormula = wFormula.toUpperCase();
	    
        //--- 메인동작 기능-----------------------------------------------------
        var wArrRange = [0,0,0,0];
        var wMaxRows = this.maxRows;       var wMaxCols = this.maxCols;
	    while (wFormula.indexOf("CELL ") >= 0) wFormula.replaceWord("CELL ","CELL");

	    var wFuncPosition = wFormula.indexOf("CELL(");
	    while (wFuncPosition >= 0){
	        var wEndPosion = wFormula.indexOf(")", wFuncPosition);
	        var wCellString = wFormula.substring(wFuncPosition + 5, wEndPosion); //6은 "CELL("의 길이
	            wCellString = wCellString.replaceWord("\"","");
	        var wValueString = "";
	        
            // 괄호사이의 셀값을 셀값으로 바꾼다(문자와 숫자 셀타입을 구분)
	        var wArrCellRanges = wCellString.split(",");
	        for (var i=0; i < wArrCellRanges.length; i++){
                this.parseRCToRange(wArrCellRanges[i], wArrRange);
                
                for (var wRowNum = wArrRange[0]; wRowNum <= wArrRange[2]; wRowNum++){
                    var wRow = this.dataTable.rows[wRowNum];
                    for (var wColNum = wArrRange[1]; wColNum <= wArrRange[3]; wColNum++){
                        var wCell = wRow.cells[wColNum];
	                    wValueString += (wValueString.length > 0 ? "," : "") + wCell.getAttribute("value");
	                }
	            }
	        }
	        
	        wFormula = wFormula.substring(0, wFuncPosition) + wValueString + wFormula.substring(++wEndPosion);
	        
	        wFuncPosition = wFormula.indexOf("CELL(");
	    }    

        return wFormula;
    };
    
    /*--------------------------------------------------------------------------
     RC스타일의 문법 (기본 R1C1:R2C3 상대좌표 R[1]C[1]:R[3]C[4] <-커런트 셀기준
     단일셀은 :이 없다 (R1C1  R[1]C[2])
     줄선택은 R1:R2와 같다 열선택은 C1C2와 같이 표현한다
     인수중에 배열은 [Row, Col, Row2, Col2] 이다 결과를 리턴한다
    ----------------------------------------------------------------------------*/
    CrossSheetH.prototype.parseRCToRange = function(RCString, arrRange){
         // functionname : [CrossSheetH.parseRCToRange]

        // 1. 콜론으로 범위값을 분리한다 없으면시작셀값과 같은 값을 준다
        var wArrRanges = RCString.split(":");
        
        // 2. 시작셀을 파싱한다
        //    열번호가 없으면 전체열 선택이다 줄번호가 없으면 전체줄 선택이다 
        var wRange = wArrRanges[0];
        var wRowString = wRange.split("C")[0].substring(1);
        var wColString = wRange.split("C")[1];

        arrRange[0] = parseInt(wRowString, 10);
        arrRange[1] = parseInt(wColString, 10);
        
        if (wArrRanges.length == 1) {
            arrRange[2] = arrRange[0];
            arrRange[3] = arrRange[1];
        } else {
            // 3. 종료셀을 파싱한다 
            wRange = wArrRanges[1];
            wRowString = wRange.split("C")[0].substring(1);
            wColString = wRange.split("C")[1];
            
            arrRange[2] = parseInt(wRowString, 10);
            arrRange[3] = parseInt(wColString, 10);
        }
        
        return;
    };

    /* -----------------------------------------------------------------------
     데이터를 모두채운후에는 스크롤에 테이블 사이즈를 반영한다
     --------------------------------------------------------------------------*/
    CrossSheetH.prototype.resetScroll = function(){

	   	var scrollPanel = this.tagObject.getElementsByTagName("DIV")[0];
	   	var scrollChildPanel = scrollPanel.getElementsByTagName("DIV")[0];
	   	if (this.dataTable.scrollWidth == 0){
	    	var w = 1; 
	   		var h = 1;
	   		var tbody = this.dataTable.tBodies[0];
	   		for (var wRowNum = 0; wRowNum < tbody.rows.length; wRowNum++){
	   			h++;
	   			h += parseIntSize(tbody.rows[wRowNum].style.height);
	   		}
	   		var tr = tbody.rows[0];
	   		for (var wColNum = 0; wColNum < tr.cells.length; wColNum++){
	   			w++;
	   			w += parseIntSize(tr.cells[wColNum].style.width);
	   		}
	   	   	scrollChildPanel.style.width = ++w + "px";
	   	   	scrollChildPanel.style.height = ++h + "px";
	   		
	   	} else {
	   	   	scrollChildPanel.style.width = this.dataTable.scrollWidth + "px";
	   	   	scrollChildPanel.style.height = this.dataTable.scrollHeight + "px";
	   	}
	   	
    	scrollPanel.scrollTop = 0;
    	scrollPanel.scrollLeft = 0;
    	 
    };

    /* -----------------------------------------------------------------------
       여기서 부터 크로스 데이터 처리부분이다
    --------------------------------------------------------------------------*/
    CrossSheetH.prototype.analyze = function(dataObject){
        // functionname : [CrossSheetH.analyze]
    	this.dataObject = dataObject;
    
        // 없는 속성 추가
	    for (var i=1; i < dataObject.steps.length; i++){
	    	var stepObject = this.dataObject.steps[i];
	    	stepObject.headDatasSorted = null;
	    	
	    	stepObject.cellType = 0;
	    	if (stepObject.datas.length == 0){
	    		stepObject.cellType = CELLTYPE_FLOAT;
	    		
	    	} else if (stepObject.datas[0].length == 0){
	    		stepObject.cellType = CELLTYPE_FLOAT;
	    		
	    	} else if (("" + stepObject.datas[0][0]).isNum()){
	            stepObject.cellType = CELLTYPE_FLOAT;
	        } else {
	            stepObject.cellType = CELLTYPE_EDIT;
	        }
	    }
        showAjaxBox(getText("message_crosssheeth_001", "서버 데이터를 분석중입니다."), 0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep1()", 10);
        return;
    };

    CrossSheetH.prototype.executeStep1 = function(){
        // functionname : [CrossSheetH.executeStep1]
        
	    // ==== 0. 시트 클리어  ============================================
	    // 줄수, 칼럼수를 1로하고 MaxRows, MaxCols를 0으로 한다 
        var wTables = this.tagObject.getElementsByTagName("table");
	    for (var i = 0; i <= 3;i++){
	        wTables[i].style.display="none";
	    } 
	    
	    this.clear();
	    
	    // ==== 1. 전역변수 세팅 ===========================================
	    this.rowLevelCnt = this.dataObject.head.levelCnt;
	    this.colLevelCnt = 0;
	    for (var wStepNum = 1; wStepNum < this.dataObject.steps.length; wStepNum++){
	        if (this.colLevelCnt < this.dataObject.steps[wStepNum].levelCnt && this.dataObject.steps[wStepNum].isSQL)
	               this.colLevelCnt = this.dataObject.steps[wStepNum].levelCnt;
	    }
	    this.headRows = this.colLevelCnt;
	    this.headCols = this.rowLevelCnt;
	    
	    // 비고난의 갯수 설정
	    if (this.dataObject.direction == "RowChange"){
	        this.remarkCols = (this.dataObject.head.needRemarks ? 1 : 0);
	    } else if (this.dataObject.direction == "ColChange"){
	        this.remarkRows = (this.dataObject.head.needRemarks ? 1 : 0);
	    }
	    
        showAjaxBox(getText("message_crosssheeth_002", "분석 데이터를 작성하는 중입니다.") ,0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep2()", 10);
	    
        return;
    };
    
    CrossSheetH.prototype.executeStep2 = function(){
        // functionname : [CrossSheetH.executeStep2]
    
        // 데이터가 들어갈 빈헤더와 셀들을 모두 만든다
        // 좌측 헤더를 만든다
	    this.makeHeads( this.dataObject.head.heads, 
			            this.dataObject.sumPosition, 
			            this.dataObject.head.sums,
			            this.dataObject.head.levelCnt, 
			            this.dataObject.head.hidden, 
			            this.headDatas);
	    
        // Step헤더를 만든다
	    for (var i=1; i < this.dataObject.steps.length; i++){
	        this.stepHeadDatas[i] = [];
	        if (this.dataObject.steps[i].isSQL){
	            this.makeHeads(this.dataObject.steps[i].heads, 
	                           this.dataObject.sumPosition, 
	                           this.dataObject.steps[i].sums, 
	                           this.dataObject.steps[i].levelCnt, 
	                           this.dataObject.steps[i].hidden, 
	                           this.stepHeadDatas[i]);
	        } else {
	            var wHeadData = this.stepHeadDatas[i][0] = new HeadData();
	            wHeadData.captions = [this.dataObject.steps[i].heads[0][5],"","","",""];
	            wHeadData.values   = ["","","","",""];
	        }
	    }

        // 시트에 집어 넣는다
	    this.makeBlankCells();
 
        showAjaxBox(getText("message_crosssheeth_003", "상단과 좌측 타이틀을 채우고 있습니다.") ,0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep3()", 10);
        return;
    };
    
    CrossSheetH.prototype.executeStep3 = function(){
        // functionname : [CrossSheetH.executeStep3]
    
	    // ==== 2. 타이틀을 먼저 만들고 ===============================
        //  2.1 왼쪽 타이틀 채우기
	    this.makeRowTitle();
	    
        
        //  2.2 스텝별 타이틀 채우기
        var wStartNum = [this.headCols];
        var wArrSteps = this.dataObject.steps;
        for (var wStep = 1; wStep < wArrSteps.length; wStep++){
        	this.stepstartNums[wStep] = wStartNum[0];
            this.makeColTitles(wStep, this.dataObject.steps[wStep].decimal, wStartNum);
        }
    
        showAjaxBox(getText("message_crosssheeth_004", "데이터를 채우는 중입니다.") ,0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep4()", 10);
        return;
    };
    
    CrossSheetH.prototype.executeStep4 = function(){
        // functionname : [CrossSheetH.executeStep4]
        

    	// ==== 3. 칼럼별로 몸통데이터를 찍는다. =============================
    	var wArrSteps = this.dataObject.steps;
	    for (var wStep = 1; wStep < wArrSteps.length; wStep++){
	        var wStepObject = wArrSteps[wStep];
	        this.mCrrentFieldTypeIsNumeric = true;
	        
	        if (wStepObject.isSQL1)
	            this.fillColData(wStep, wStepObject);
	    }
    
        showAjaxBox(getText("message_crosssheeth_005", "셀에 산식을 작성하는 중입니다.") ,0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep5()", 10);
        return;
    };
    
    CrossSheetH.prototype.executeStep5 = function(){
        // functionname : [CrossSheetH.executeStep5]
        
    	// ==== 4. 산식데이터 채우기  =============================
        //  4.1 스텝별 산식 채우기(산식)
        var wArrSteps = this.dataObject.steps;
        for (var wStep = 1; wStep < wArrSteps.length; wStep++){
	        var wStepObject = wArrSteps[wStep];
	        this.mCrrentFieldTypeIsNumeric = true;
	        if (!wStepObject.isSQL1){
	            this.makeColFormula(wStep, wStepObject);
	        }
	    }
        
        //  4.2 열단위 합계 채우기(산식)
        this.makeRowSums();
        
        //  4.3 줄단위 합계 채우기(산식)
        for (var wStep = 1; wStep < wArrSteps.length; wStep++){
            var wStepObject = wArrSteps[wStep];
            // 스템헤더와 푸터 모두 SQL로 가저와야만 산식적용
            if (wStepObject.isSQL && wStepObject.isSQL1){
                this.makeStepSums(wStep);
            }
        }
        
        //  4.4 줄단위 비고난 채우기
        for (var wStep = 1; wStep < wArrSteps.length; wStep++){
            this.makeStepRemarks(wStep, this.dataObject.steps[wStep].remark);
        }
        
        
        showAjaxBox(getText("message_crosssheeth_006", "산식을 일괄 계산하는 중입니다."), 0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep6()", 10);
        return;
    };
    
    CrossSheetH.prototype.executeStep6 = function(){
        // functionname : [CrossSheetH.executeStep6]
        
        // ==== 5. 산식셀을 일괄 계산 해준다. =====================================================
        this.recalculate();
        
        showAjaxBox(getText("message_crosssheeth_007", "칼럼사이즈를 조정하고, 타이틀을 정비하는 중입니다"), 0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep7()", 10);
        return;
    };
    
    
    CrossSheetH.prototype.executeStep7 = function(){
        // functionname : [CrossSheetH.executeStep7]
        
        // ==== 6. 헤더 칼럼을 사이즈를 조정한다===================
        // 6.1 칼럼사이즈 조정
        this.adjustColWidth();
        
        // 6.2 줄 헤더 칼럼 병합
        this.mNoneCaption = this.dataObject.noCaption;
        this.setRowHeadSpan(this.mNoneCaption);
        
        // 6.3 열 헤더 칼럼 병합
        var wRow0 = this.colHeadTable.tBodies[0].rows[0];
        
        var wTableRow = document.createElement("TR"); 
        
        if (wRow0.insertAdjacentElement){
        	wRow0.insertAdjacentElement('beforeBegin', wTableRow); 
 		}
 		else if (wRow0.appendChild) {
 			insertAdjacentElement('beforeBegin' ,wRow0, wTableRow);
 		}
        
        for (var wColNum = 0; wColNum < this.colHeadTable.tBodies[0].rows[1].cells.length; wColNum++){
            wTableRow.insertCell(wColNum);
            wTableRow.cells[wColNum].style.width = wRow0.cells[wColNum].style.width;
        }

    	this.colHeadTable.tBodies[0].rows[0].style.display="none";
        
    	var wArrSteps = this.dataObject.steps;
        for (var wStep = wArrSteps.length - 1; wStep >= 1; wStep--){
            this.setColHeadSpans(wStep, this.dataObject.steps[wStep].levelCnt, 
                                        this.mNoneCaption ,
                                        this.dataObject.steps[wStep].isSQL);
        
        
        }
        
        // 6.3 빈데이터 셀을 정리한다
        for (var wRowNum=0; wRowNum < this.dataTable.tBodies[0].rows.length; wRowNum++){
        	var wRow = this.dataTable.tBodies[0].rows[wRowNum];
        	for (var wColNum=0; wColNum < wRow.cells.length; wColNum++){
        		if (wRow.cells[wColNum].innerHTML=="") wRow.cells[wColNum].innerHTML="&nbsp;";
        	}
        }
        
        /*            

        // 열 헤더 칼럼 숨기기
        for (var wLevelNum = 0; wLevelNum < this.dataObject.head.levelCnt; wLevelNum++){
            if (this.dataObject.head.hidden[wLevelNum])
                this.hideColLevels(this.dataObject.head.levelCnt, wLevelNum);
        }
        

        // 줄 헤더 칼럼 숨기기
        for (var wStep = wArrSteps.length - 1; wStep >= 1; wStep--){
            for (var wLevelNum = 0; wLevelNum < this.dataObject.steps[wStep].levelCnt; wLevelNum++){
                if (this.dataObject.steps[wStep].hidden[i])
                    this.HideStepColLevels(this.dataObject.steps[wStep].levelCnt, wLevelNum, wStep);
            }
        }
        */
        
        showAjaxBox(getText("message_crosssheeth_008", "자료를 정리합니다."), 0,NEED_NOT_COUNT_UP);
        setTimeout("controls['" + this.controlName + "'].actionObject.executeStep8()", 10);
        return;
    };
    
    
    CrossSheetH.prototype.executeStep8 = function(){
        // functionname : [CrossSheetH.executeStep8]
    
    	// ==== 7. 데이터 작업 후속처리 ===================
        var wTables = this.tagObject.getElementsByTagName("table");
	    for (var i = 0; i <= 3;i++){
	        wTables[i].style.display="block";
	    }        
    	// 7.1 메모리 해제 
        // this.dataObject = null;
    
    	// 7.2 차트 그리기 호출
		this.showChart();
		
		// 7.3 채우기 완료 이벤트 호출 
		callEvent(this.controlId + "_LoadSuccess");
    
		// 7.4 시트 스크롤 초기화 
    	this.resetScroll();
    	
    	// 7.5 진행 상태 박스 숨기기
    	hideAjaxBox();
    	
    	// 7.6 좌상단 셀 조정
    	var rowTitle = this.dataObject.head.rowTitle;
    	if (rowTitle == null || rowTitle.length == 0)
    		this.mergeUpperMost();
    	
        return;
    };

    CrossSheetH.prototype.clearData = function(dataObject){
        // functionname : [CrossSheetV.clearData]

           for (var wStepNum = 1; wStepNum < dataObject.steps.length; wStepNum++){
        	   var wStep = dataObject.steps[wStepNum];
        	   if (wStep.sums) wStep.sums.clear();
        	   if (wStep.sums) wStep.hidden.clear();
        	   if (wStep.sums) wStep.heads.clear();
        	   if (wStep.sums) wStep.datas.clear();
           }
    	   dataObject.steps.clear();
    	   
       	   var wHead = dataObject.head;
    	   if (wHead.sums) wHead.sums.clear();
    	   if (wHead.sums) wHead.hidden.clear();
    	   if (wHead.sums) wHead.heads.clear();
    	   dataObject.head = null;
    	   
    	   dataObject = null;
    };
    
       CrossSheetH.prototype.addChartInfo = function(pChartInfo){
           // functionname : [CrossSheetH.addChartInfo]

           this.chartInfo = pChartInfo;
       };
       
       CrossSheetH.prototype.getChartData = function(pChartId){
        // functionname : [CrossSheetH.getChartData]

    	   var arrFromStrings = [",", ":", ";", "&", "%", "?"];
           var arrToStrings   = ["<COMMA>", "<COLON>", "<SEMICOLON>", "<AMP>", "<PERCENT>", "<QUESTION>"];
        
    	   var wChartInfo = "";
    	   var wInfos = this.chartInfo.split("[S1]");
    	   for(var i = 0; i < wInfos.length; i++){
    		   var wInfo = wInfos[i];
    		   if (wInfo.trim().length == 0) continue;
    		   var chartId = wInfo.split(";")[2];
    		   
    		   if (pChartId == chartId) {
    			   wChartInfo = wInfo; break;
    		   }
    	   }
    	   
    	   if (wChartInfo.length == 0) return "";
    	   
    	   var wArr = wChartInfo.split(";");
    	   var wArr1 = wArr[0].split("_");
    	   var wArr2 = wArr[1].split("_");
     	   
    	   var wPointRCType      = parseInt(wArr1[0]);
    	   var wPointStepNum     = parseInt(wArr1[1]);     // 포인트 데이터를 뽑을 스텝명
    	   var wPonitLevel       = parseInt(wArr1[2]);     // 포인트 데이터를 뽑을 레벨명
    	   
    	   // wSeriesLevel의 주의사항  예를들어 "대분류-중분류-상품"이라면 대분류는 1이고 상품은 3으로 화면이 만들어 진다
    	   // 크로스 시트의 경우 상품데이터는1, 중분류 합계는 2, 대분류합계는 3이다
    	   if (wPointRCType == BY_ROW_HTYPE){
    		   wPonitLevel = this.rowLevelCnt - wPonitLevel + 1;
    	   } else if (wPointRCType == BY_COL_HTYPE){
    		   wPonitLevel = this.colLevelCnt - wPonitLevel + 1;
    	   }
   	   
    	   var wSeriesRCType	 = parseInt(wArr2[0]); 
    	   var wSeriesStepNum	 = parseInt(wArr2[1]);     // 계열값 데이터를 뽑을 스텝명
    	   var wSeriesLevel	     = parseInt(wArr2[2]);     // 계열값 데이터를 뽑을 레벨명
    	   if (wSeriesRCType == BY_ROW_HTYPE){
    		   wSeriesLevel = this.rowLevelCnt - wSeriesLevel + 1;
    	   } else if (wSeriesRCType == BY_COL_HTYPE){
    		   wSeriesLevel = this.colLevelCnt - wSeriesLevel + 1;
    	   }
    	   
    	   
           var wPointRcNums = [];
           
           // point data set 
           var wData = "";      // 함수가 리턴할 문자열값
           var wPointSeq = 0;   // 선택된 헤더들 집합 내의 새로 매긴 순번

           if (wPointRCType == BY_ROW_HTYPE){
               var wHeadRows = this.headRows;
               for (var i=0; i < this.headDatas.length; i++){
                   var wHeadData = this.headDatas[i];
                   if (wHeadData.Level != wPonitLevel) continue;
                   
                   wData += "," +  escapeCharacter(wHeadData.captions[this.rowLevelCnt - wPonitLevel] ,arrFromStrings, arrToStrings);
                   wPointRcNums[wPointSeq] = i + wHeadRows;
                   
                   wPointSeq++;
               }
           
           } else if (wPointRCType == BY_COL_HTYPE){
               var wStartColNum = this.stepstartNums[wPointStepNum];
               wHeadDatas = this.stepHeadDatas[wPointStepNum];
               
               for (var i=0; i < wHeadDatas.length; i++){
                   var wHeadData = wHeadDatas[i];
                   if (wHeadData.Level != wPonitLevel) continue;
                   
                   wData += "," + escapeCharacter(wHeadData.captions[this.colLevelCnt - wPonitLevel] ,arrFromStrings, arrToStrings);
                   wPointRcNums[wPointSeq] = i + wStartColNum;
                   
                   wPointSeq++;
               }
           
           }
           wData += ":";
           
           // Series Data Set
           var wRows = this.dataTable.tBodies[0].rows;
           
           if (wSeriesRCType == BY_ROW_HTYPE){
               var wHeadRows = this.headRows;
               for (var i=0; i < this.headDatas.length; i++){
                   var wHeadData = this.headDatas[i];
                   if (wHeadData.Level != wSeriesLevel) continue;
                   
                    wData += escapeCharacter(wHeadData.captions[this.rowLevelCnt - wSeriesLevel] ,arrFromStrings, arrToStrings);
                   
                   var wRowNum = i + wHeadRows;
                   for (var j = 0; j < wPointRcNums.length; j++){
                       var wColNum = wPointRcNums[j];
                       var wValue = wRows[wRowNum].cells[wColNum].getAttribute("value");
                       
                       wData += "," + escapeCharacter(wValue ,arrFromStrings, arrToStrings);
                       
                   }
                   wData += ":";

               }
           
           } else if (wSeriesRCType == BY_COL_HTYPE){
               var wStartColNum = this.stepstartNums[wSeriesStepNum];
               wHeadDatas = this.stepHeadDatas[wSeriesStepNum];
               
               for (var i=0; i < wHeadDatas.length; i++){
                   var wHeadData = wHeadDatas[i];
                   if (wHeadData.Level != wSeriesLevel) continue;
                   
                   wData += escapeCharacter(wHeadData.captions[this.colLevelCnt - wSeriesLevel] ,arrFromStrings, arrToStrings);
                   
                   var wColNum = i + wStartColNum;
                   for (var j = 0; j < wPointRcNums.length; j++){
                       var wRowNum = wPointRcNums[j];
                       var wValue = wRows[wRowNum].cells[wColNum].getAttribute("value");
                       
                       wData += "," + escapeCharacter(wValue ,arrFromStrings, arrToStrings);
                       
                   }
                   wData += ":";
               }
           }
       	return wData;
       };

       CrossSheetH.prototype.showChart = function(){
           // functionname : [CrossSheetH.showChart]

    	   var wChartInfo = "";
    	   var wInfos = this.chartInfo.split("[S1]");
    	   for(var i = 0; i < wInfos.length; i++){
    		   var wInfo = wInfos[i];
    		   if (wInfo.trim().length == 0) continue;
    		   var chartId = wInfo.split(";")[2];
    		   
               var chartControl = getControlById(chartId);
               chartControl.data =this.getChartData(chartId);
               
               if (chartControl.data.indexOf(":") < chartControl.data.length - 1){
                   chartControl.show();
               }
    	   }
    	   return;
       };
       
    
    CrossSheetH.prototype.setCellStyle = function(stepNum, styleJSON, arrKeyDatas, tooltip){
        // functionname : [CrossSheetH.setCellStyle]

                           var stepObject = this.dataObject.steps[stepNum];
    var wStartNum = this.stepstartNums[stepNum];
    var wFieldPoint = stepObject.fieldPoint;
    
    // key count 계산
    var keyCount = 0;
	var wArrDatas = stepObject.datas;
    if (wArrDatas.length >= 1){
        for (var i = 1; wArrDatas[0].length;i++) {
        	if (wArrDatas[0][i] == null) break; 
        	keyCount++;
        }
    }

    var headKeyCount = wFieldPoint;

    var wData = arrKeyDatas;
        
    // 줄번호 찾기 
    var wWorkKey = wData.slice(1, wFieldPoint + 1); 
    var wRowArrData = searchArray(this.headDatasSorted, wWorkKey);
    var wRowNum = (wRowArrData != null ? wRowArrData[wRowArrData.length - 1] : -1);
    
    // 칼럼번호 찾기
    var wColNum = -1; var wColArrData = null; 
    if (!stepObject.isSQL){
    	wColNum = wStartNum;
    } else {
        wWorkKey = wData.slice(headKeyCount + 1, keyCount + 1); 
        wColArrData = searchArray(stepObject.headDatasSorted, wWorkKey);
        wColNum = (wColArrData != null ? wColArrData[wColArrData.length - 1] : -1);
    }
    
    if (wRowNum >= 0 && wColNum >= 0){
        var wCell = this.dataTable.tBodies[0].rows[wRowNum].cells[wColNum];
        this.setTypeStyle(wCell, styleJSON, tooltip);	
    }
        
    if (wWorkKey) wWorkKey.clear();
        
        return;
    };
    
    // 사용방법 : wSheet.setTypeStyle({"text-align":"left", "font": "normal normal normal 12pt 굴림,Courier"});
    // 만들어진 스타일을 지우려면 : wSheet.setTypeStyle({"text-align":""});
    CrossSheetH.prototype.setTypeStyle = function(cell, styleJSON, tooltip){
        // functionname : [CrossSheetV.setTypeStyle]

          var wCell = cell;
          var styleString = "";
          if (wCell.style){
        	  styleString = wCell.style.cssText;  
          } else {
        	  styleString = wCell.getAttribute("style");  
          }
          
          var arrStyleItems = (styleString == null ? [] : styleString.split(";"));
          var arrStyles = [];
          
          for (var i = 0; i < arrStyleItems.length; i++){
              var styleItem = ("" + arrStyleItems[i]).trim();
              if (styleItem.length == 0) continue;
              
              var arrInfos = styleItem.split(":");
              var itemStyleName  = ("" + arrInfos[0]).trim();
              var itemStyleValue = ("" + arrInfos[1]).trim();
              
              arrStyles[i] = [itemStyleName, itemStyleValue];
          }


          styleString = "";
          
          for (var wKey in styleJSON){
	         if (styleJSON[wKey] instanceof Function) continue;
             var styleName  = wKey;
             var styleValue = styleJSON[wKey];
             
             var found = false;
             for (var j = 0; j < arrStyles.length; j++){
                 var itemStyleName  = arrStyles[j][0];
                 var itemStyleValue = arrStyles[j][1];
                 
                 if (styleName == itemStyleName) {
                     arrStyles[j] = [styleName, styleValue];

                     found  = true; break;
                 }
             }
             
             if (!found){
                 var newIndex = arrStyles.length;
                 arrStyles[newIndex ] = [styleName, styleValue];
             }
          }
          
          for (var i = 0; i < arrStyles.length; i++){
              if (arrStyles[i][1].length == 0) continue;
              styleString +=  arrStyles[i][0] + ":" + arrStyles[i][1] + "; ";
          }

          wCell.setAttribute("style", styleString);
    	  wCell.style.cssText = styleString;
    	  
          wCell.title= tooltip;

        return;
    };

    CrossSheetH.prototype.stepNumOf = function(colNum){
    	var wStepNum = 0;
	    for (var i=1; i < this.stepstartNums.length; i++){
	    	if (colNum < this.stepstartNums[i]) break;
	    	wStepNum++;
	    }
	    return wStepNum;
    };
var FRAME_OLD_3D            	= 0;
var FRAME_OLD_LINE          	= 1;
var FRAME_OLD_RECT          	= 2;
var FRAME_NEW_3D            	= 4;
var FRAME_NEW_LINE          	= 5;
var FRAME_IMAGE          		= 6;
var FRAME_NEW_ROUND         	= 7;
var FRAME_NEW_FLOATINGLAYER		= 98;
var FRAME_NEW_FLOATINGLAYER_NEW	= 98.1;
var FRAME_NEW_NONE				= 99;

var frameMoveStart = false;
/**
 * @class FrameBox를 만들어주는 클래스
 * @description 미결
 * @param controlId
 *            {String} Control의 id를 입니다.
 * @param controlName
 *            {String} Control의 name을 입니다.
 * @param tagObject
 *            {Object} 태그객체 입니다.
 * @example 미결
 */ 
function FrameBox(controlId, controlName, tagObject){
    // 상속선언부
    this.base = ControlBase;              			//부모클래스 지정
    this.base(controlId, controlName, tagObject);   //부모클래스 생성자호출
    
    // 상수 선언부
    
    // 속성 선언부
    this.controlId = controlId;
    this.backcolor = "";
    this.bordercolor = "";
    this.sbackcolor = "";
    this.sbordercolor = "";
    this.style = 0;
    this.frameType = "";
    this.alignment = "";
    this.fontBold = "";
    this.fontItalic = "";
    this.fontName = "";
    this.fontSize = "";
    this.fontStrikethru = "";
    this.fontUnderline = "";
    this.caption = "";
    this.labelObject = null;
    
	this.top	= (tagObject.style.top == "" ? window.getComputedStyle(tagObject).top.replace(/px/g,'') : parseIntSize(tagObject.style.top));
	this.left	= (tagObject.style.left == "" ? window.getComputedStyle(tagObject).left.replace(/px/g,'') : parseIntSize(tagObject.style.left));
	this.width	= (tagObject.style.width == "" ? window.getComputedStyle(tagObject).width.replace(/px/g,'') : parseIntSize(tagObject.style.width));
	this.height	= (tagObject.style.height == "" ? window.getComputedStyle(tagObject).height.replace(/px/g,'') : parseIntSize(tagObject.style.height));
	
	var lastDIVIndex = this.tagObject.getElementsByTagName("div").length - 1;
	var firstDiv = null;
	
	this.frameType = FRAME_OLD_3D;
	// 0 - 입체 3D (C/S) : 사용안함
	if (tagObject.className=="FrameBoxA"){
		this.frameType = FRAME_OLD_3D;
		this.labelObject = this.tagObject.getElementsByTagName("legend")[0];
	}
	// 1 - 라인 (C/S) : 사용안함
	else if (tagObject.className=="FrameBoxB"){
		this.frameType = FRAME_OLD_LINE;
		this.labelObject = this.tagObject.getElementsByTagName("td")[1];
	}
	// 2 - 사각형 (C/S) : 사용안함
	else if (tagObject.className=="FrameBoxC"){
		this.frameType = FRAME_OLD_RECT;
		this.labelObject = this.tagObject.getElementsByTagName("td")[1];
	}
	// 4 - 입체 3D (WEB) : 사용안함
	else if (tagObject.className=="Frame_NEW_3D"){
		this.frameType = FRAME_NEW_3D;
		this.labelObject = this.tagObject.getElementsByTagName("div")[lastDIVIndex];
	}
	// 5 - 라인 (WEB) : 사용(직사각형)
	else if (tagObject.className=="Frame_NEW_LINE"){
		this.frameType = FRAME_NEW_LINE;
		this.labelObject = this.tagObject.getElementsByTagName("div")[lastDIVIndex];
	}
	// 6 - 이미지프레임 (WEB) : 사용안함
	else if (tagObject.className=="FRAME_IMAGE"){
		this.frameType = FRAME_IMAGE;
		this.labelObject = this.tagObject.getElementsByTagName("div")[lastDIVIndex];
	}
	// 7 - 둥근사각 (WEB) : 사용(둥근사각형)
	else if (tagObject.className=="Frame_NEW_ROUND"){
		this.frameType = FRAME_NEW_ROUND;
		this.labelObject = this.tagObject.getElementsByTagName("div")[lastDIVIndex];
	}
	// 98 - 이동창 (WEB) : 사용
//	else if (tagObject.className=="Frame_NEW_FLOATINGLAYER"){
//	else if ( /^Frame_NEW_FLOATINGLAYER\s+/.test(tagObject.className) ){
	else if ( /^Frame_NEW_FLOATINGLAYER\s*.*/.test(tagObject.className) ){
		firstDiv = this.tagObject.getElementsByTagName("div")[0];
		//첫번째 div의 클래스가 layer 라면 4.1 이후 생성되는 이동창으로 이전 버전의 이동창과는 html 태그 소스가 다름
		if( "" + firstDiv.getAttribute("class") == "layer" ){
			this.frameType = FRAME_NEW_FLOATINGLAYER_NEW;
			this.labelObject = firstDiv.getElementsByTagName("div")[0];
		}
		else{
			this.frameType = FRAME_NEW_FLOATINGLAYER;
			this.labelObject = this.tagObject.getElementsByTagName("div")[lastDIVIndex];
		}
		//메모리 초기화
		firstDiv = null;
	}
	// 99 - 윤곽없음 (WEB) : 사용
	else if (tagObject.className=="Frame_NEW_NONE"){
		this.frameType = FRAME_NEW_NONE;
		this.labelObject = this.tagObject.getElementsByTagName("div")[lastDIVIndex];
	}
	
	if( typeof tagObject != "undefined" ){
		tagObject.setAttribute("tabIndex", "-1");
	}
	
	// 이벤트 부여
	var childDIV = this.tagObject;
	setEventHandler(childDIV, "click", FrameBox_onclick);
	setEventHandler(childDIV, "keydown", FrameBox_onkeydown);
	
	// 프로팅창의 닫기버튼과 타이틀의 마우스 이벤트
	if( this.frameType == FRAME_NEW_FLOATINGLAYER ){
		if( childDIV.getElementsByTagName("IMG")[0] ){
			var ndx = childDIV.getElementsByTagName("IMG").length - 1;
			setEventHandler(childDIV.getElementsByTagName("IMG")[ndx], "click", frameBox_onClick_X);
		}
		
		childDIV = this.labelObject;
		setEventHandler(childDIV, "mousedown", frameBox_onmousedown);
		setEventHandler(document, "mousemove", frameBox_onmousemove);
		setEventHandler(document, "mouseup",   frameBox_onmouseup);
	}
	else if( this.frameType == FRAME_NEW_FLOATINGLAYER_NEW ){
		childDIV = this.labelObject;
		
		if( childDIV.getElementsByTagName("div")[0] ){
			setEventHandler(childDIV.getElementsByTagName("div")[0], "click", frameBox_onClick_X);
		}
		
		setEventHandler(childDIV, "mousedown", frameBox_onmousedown);
		setEventHandler(document, "mousemove", frameBox_onmousemove);
		setEventHandler(document, "mouseup",   frameBox_onmouseup);
	}
	
	this.hasClickEvent = false;		this.fncClickEvent = null;
	this.hasKeyDownEvent = false;	this.fncKeyDownEvent = null;
	this.hasOpenEvent = false;		this.fncOpenEvent = null;
	this.hasCloseEvent = false;		this.fncCloseEvent = null;
	
	if( this.controlId.length > 0 ){
		try {
			if( typeof self[this.controlId + "_onclick"] == "function" ){
				this.hasClickEvent = true;
				this.fncClickEvent = function(){ self[this.controlId + "_onclick"](); };
			}
		} catch(e){}
		
		try {
			if( typeof self[this.controlId + "_onkeydown"] == "function" ){
				this.hasKeyDownEvent = true;
				this.fncKeyDownEvent = function(){ self[this.controlId + "_onkeydown"](); };
			}
		} catch(e){}
		
		try {
			if( typeof self[this.controlId + "_onOpen"] == "function" ){
				this.hasOpenEvent = true;
				this.fncOpenEvent = function(){ self[this.controlId + "_onOpen"](); };
			}
		} catch(e){}

    	try {
    		if( typeof self[this.controlId + "_onClose"] == "function" ){
				this.hasCloseEvent = true;
				this.fncCloseEvent = function(){ self[this.controlId + "_onClose"](); };
			}
        } catch(e){}
    }
};

FrameBox.prototype = new ControlBase(); // 의미없음 코딩 편의기능을 활용하기 위함

/**
 * @description	미결
 * @param		{Object}	em
 * @return		{String}
 * @example		미결
 */
function searchControl_Frame(em){
	var wReturn = null;
	var pEm = em;
	var image = pEm.getAttribute("image");
	var classNames = ["FrameBoxA", "FrameBoxB", "FrameBoxC", "Frame_NEW_3D", "Frame_NEW_LINE", "FRAME_IMAGE", "Frame_NEW_ROUND", "Frame_NEW_FLOATINGLAYER", "Frame_NEW_NONE"];
	
//	while (pEm.parentNode && classNames.indexOf(pEm.className) < 0)
//		pEm = pEm.parentNode;
//	if (classNames.indexOf(pEm.className) >= 0)
//		wReturn = getControlById(pEm.id);
	
	while(pEm.parentNode && pEm.tagName != "body"){
		if( classNames.indexOf(image) >= 0 ){
			wReturn = getControlById(pEm.id);
			break;
		}
		
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}
	
	if( wReturn == null ){
		pEm = null;
		pEm = em;
		
		while(pEm.parentNode && classNames.indexOf(pEm.className) < 0)
			pEm = pEm.parentNode;
		
		if( classNames.indexOf(pEm.className) >= 0 )
			wReturn = getControlById(pEm.id);
	}
	
	classNames.clear(); classNames = null;
	pEm = null;
	
	return wReturn;
};

/**
 * @description	미결
 * @param 		{object}	frameType
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.setFrameType = function(frameType){
	// functionname : [FrameBox.setFrameType]
	
	this.frameType = frameType;
	
	return;
};
/**
 * @description	미결
 * @param 		{object}	alignment
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.setAlignment = function(alignment){
    // functionname : [FrameBox.setAlignment]
	
	this.alignment = alignment;
    this.labelObject.style.textAlign = alignment;
    
	return;
};

/**
 * @description	미결
 * @param 		{string}	fontBold
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.setFontBold = function(fontBold){
	// functionname : [FrameBox.setFontBold]
	
	this.fontBold = fontBold;
	this.labelObject.style.fontWeight = ("" + fontBold == "true" ? "bold" : "normal");
	
	return;
};
/**
 * @description	미결
 * @param 		{string}	fontItalic
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.setFontItalic = function(fontItalic){
	// functionname : [FrameBox.setFontItalic]
	
	this.fontItalic = fontItalic;
	this.labelObject.style.fontStyle = ("" + fontItalic == "true" ? "italic" : "normal");
	
	return;
};
/**
 * @description	미결
 * @param 		{string}	fontName
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.setFontName = function(fontName){
	// functionname : [FrameBox.setFontName]
	
	this.fontName = fontName;
	this.labelObject.style.fontFamily = fontName;
	
	return;
};

/**
 * @description	미결
 * @param 		{number}	fontSize
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.setFontSize = function(fontSize){
    // functionname : [FrameBox.setFontSize]

	this.fontSize = fontSize;
    this.labelObject.style.fontSize = fontSize + "pt";
    
    if( this.frameType == FRAME_NEW_FLOATINGLAYER_NEW ){
    	//font-size pt 를 px 로 변환
    	var fontSizePtToPx = Math.round(fontSize * 1.3);
    	//닫기 버튼 Div
    	var closeBtnDiv = this.labelObject.getElementsByTagName("div")[0];
    	//내용 박스 Div
    	var divItems = this.labelObject.parentNode.getElementsByTagName("div");
    	var contentDiv = null;
    	for(var i = 0; i < divItems.length; i++){
    		if( divItems[i].getAttribute("class") == "content" ){
    			contentDiv = divItems[i]; break;
    		}
    	}
    	
    	//div[class="title"] 의 height, line-height 설정, font-size 는 위에서 설정하였으므로 설정 안함
    	this.labelObject.style.height = fontSizePtToPx + "px";
    	this.labelObject.style.lineHeight  = fontSizePtToPx + "px";
    	//div[class="title"] > div[class="closeBtn"] 의 height, font-size, line-height 설정
    	closeBtnDiv.style.fontSize = fontSize + "pt";
    	closeBtnDiv.style.height = fontSizePtToPx + "px";
    	closeBtnDiv.style.lineHeight = fontSizePtToPx + "px";
    	//div[class="content"] 의 height 설정
    	contentDiv.style.height = ((this.height * 1) - 7 - fontSizePtToPx - 7) + "px";
    	
    	//메모리 초기화
    	closeBtnDiv = null;
    	divItems = null;
    	contentDiv = null;
    }
    
	return;
};
/*///*/

/**
 * @description	미결
 * @param 		{object}	fontStrikethru
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.setFontStrikethru = function(fontStrikethru){
	// functionname : [FrameBox.setFontStrikethru]
	
	this.fontStrikethru = fontStrikethru;
	
	var textDecorationStr = ""; 
	if( "" + this.fontStrikethru == "true" )	textDecorationStr += "line-through ";
	if( "" + this.fontUnderline == "true" )		textDecorationStr += "underline ";
	if( textDecorationStr.length <= 0 )			textDecorationStr = "none";
	
	this.labelObject.style.textDecoration = textDecorationStr;
	
	return;
};
/**
 * @description	미결
 * @param 		{object}	fontUnderline
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.setFontUnderline = function(fontUnderline){
	// functionname : [FrameBox.setFontUnderline]
	
	this.fontUnderline = fontUnderline;
	
	var textDecorationStr = ""; 
	if( "" + this.fontStrikethru == "true" )	textDecorationStr += "line-through ";
	if( "" + this.fontUnderline == "true" )		textDecorationStr += "underline ";
	if( textDecorationStr.length <= 0 )			textDecorationStr = "none";
	
	this.labelObject.style.textDecoration = textDecorationStr;
	
	return;
};
/**
 * @description	미결
 * @param 		{object}	caption
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.setCaption = function(caption){
    // functionname : [FrameBox.setCaption]
	
	this.caption = caption;
	
	if( this.frameType == FRAME_NEW_FLOATINGLAYER_NEW ){
		var captionSpan = this.labelObject.getElementsByTagName("span")[0];
		captionSpan.innerText = caption;
		
		//메모리 초기화
		captionSpan = null;
	}
	else{
		this.labelObject.innerText = caption;
	}
	
	return;
};
/**
 * @description	미결
 * @param 		{object}	caption
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.setValue = function(caption){
    // functionname : [FrameBox.setCaption]
	
	this.setCaption(caption);
	
	return;
};
/**
 * @description	미결
 * @param 		{object}	pBackcolor
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.setBackColor = function(pBackcolor){
	// functionname : [FrameBox.setBackColor]
	
	this.backcolor = pBackcolor;

	if (this.frameType == FRAME_OLD_3D){
	} else if (this.frameType == FRAME_OLD_LINE){
	} else if (this.frameType == FRAME_OLD_RECT){
	} else if (this.frameType == FRAME_NEW_3D){
//		this.tagObject.getElementsByTagName("DIV")[0].style.backgroundColor  = pBackcolor;
	} else if (this.frameType == FRAME_NEW_LINE){
//		for (var i=0; i < 5; i++){
//			this.tagObject.getElementsByTagName("DIV")[i].style.backgroundColor  = pBackcolor;
//		}
		this.tagObject.style.backgroundColor = pBackcolor;
	} else if (this.frameType == FRAME_IMAGE){
		this.tagObject.getElementsByTagName("DIV")[3].style.backgroundColor  = pBackcolor;
	} else if (this.frameType == FRAME_NEW_ROUND){
//		for (var i=0; i < 10; i++){
//			this.tagObject.getElementsByTagName("DIV")[i].style.backgroundColor  = pBackcolor;
//		}
		this.tagObject.style.backgroundColor = pBackcolor;
	} else if (this.frameType == FRAME_NEW_FLOATINGLAYER){
		for (var i=0; i < 5; i++){
			this.tagObject.getElementsByTagName("DIV")[i].style.backgroundColor  = pBackcolor;
		}
	} else if (this.frameType == FRAME_NEW_FLOATINGLAYER_NEW){
		this.tagObject.style.backgroundColor = pBackcolor;
	} else if (this.frameType == FRAME_NEW_NONE){
//		this.tagObject.getElementsByTagName("DIV")[0].style.backgroundColor  = pBackcolor;
		this.tagObject.style.backgroundColor = pBackcolor;
	}

	return;
};
/**
 * @description	미결
 * @param 		{object}	pBordercolor
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.setBordercolor = function(pBordercolor){
	// functionname : [FrameBox.setBackColor]
	
	this.bordercolor = pBordercolor;
	
	var em = null;
	if (this.frameType == FRAME_OLD_3D){
	} else if (this.frameType == FRAME_OLD_LINE){
	} else if (this.frameType == FRAME_OLD_RECT){
	} else if (this.frameType == FRAME_NEW_3D){
		em = this.tagObject.getElementsByTagName("DIV")[0];
		em.style.borderRightColor  = pBordercolor;
		em.style.borderLeftColor   = pBordercolor;
		em.style.borderBottomColor = pBordercolor;
		em.style.borderTopColor    = pBordercolor;
	} else if (this.frameType == FRAME_NEW_LINE){
//		for (var i=0; i < 6; i++){
//			em = this.tagObject.getElementsByTagName("DIV")[i];
//			em.style.borderRightColor  = pBordercolor;
//			em.style.borderLeftColor   = pBordercolor;
//		}
//		em = this.tagObject.getElementsByTagName("DIV")[4];
//		em.style.borderBottomColor = pBordercolor;
//		em = this.tagObject.getElementsByTagName("DIV")[5];
//		em.style.borderTopColor = pBordercolor;
//		em.style.borderBottomColor = pBordercolor;
		this.tagObject.style.borderColor = pBordercolor;
	} else if (this.frameType == FRAME_IMAGE){
		em = this.tagObject.getElementsByTagName("DIV")[3];
		em.style.borderRightColor  = pBordercolor;
		em.style.borderLeftColor   = pBordercolor;
		em.style.borderBottomColor = pBordercolor;
	} else if (this.frameType == FRAME_NEW_ROUND){
//		for (var i=0; i < 9; i++){
//			em = this.tagObject.getElementsByTagName("DIV")[i];
//			em.style.borderRightColor  = pBordercolor;
//			em.style.borderLeftColor   = pBordercolor;
//		}
//		em = this.tagObject.getElementsByTagName("DIV")[3];
//		em.style.borderTopColor = pBordercolor;
//		em = this.tagObject.getElementsByTagName("DIV")[5];
//		em.style.borderBottomColor = pBordercolor;
		this.tagObject.style.borderColor = pBordercolor;
	} else if (this.frameType == FRAME_NEW_FLOATINGLAYER){
		for (var i=0; i < 5; i++){
			em = this.tagObject.getElementsByTagName("DIV")[i];
			em.style.borderRightColor  = pBordercolor;
			em.style.borderLeftColor   = pBordercolor;
		}
		em = this.tagObject.getElementsByTagName("DIV")[3];
		em.style.borderTopColor = pBordercolor;
		em = this.tagObject.getElementsByTagName("DIV")[4];
		em.style.borderBottomColor = pBordercolor;
	} else if (this.frameType == FRAME_NEW_FLOATINGLAYER_NEW){
		this.tagObject.style.borderColor = pBordercolor;	
	} else if (this.frameType == FRAME_NEW_NONE){
	}
	
	return;
};
/**
 * @description	미결
 * @param 		{object}	pSbackcolor
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.setSbackcolor = function(pSbackcolor){
	// functionname : [FrameBox.setSbackcolor]
	
	this.sbackcolor = pSbackcolor;
	
	var em = null;
	if (this.frameType == FRAME_OLD_3D){
	} else if (this.frameType == FRAME_OLD_LINE){
	} else if (this.frameType == FRAME_OLD_RECT){
	} else if (this.frameType == FRAME_NEW_3D){
	} else if (this.frameType == FRAME_NEW_LINE){
	} else if (this.frameType == FRAME_IMAGE){
	} else if (this.frameType == FRAME_NEW_ROUND){
//		for (var i=10; i < 19; i++){
//			em = this.tagObject.getElementsByTagName("DIV")[i];
//			em.style.backgroundColor  = pSbackcolor;
//		}
	} else if (this.frameType == FRAME_NEW_FLOATINGLAYER){
		this.tagObject.getElementsByTagName("DIV")[5].style.backgroundColor = pSbackcolor;
	} else if (this.frameType == FRAME_NEW_FLOATINGLAYER){
		//내용 박스 Div
    	var divItems = this.labelObject.parentNode.getElementsByTagName("div");
    	var innerConentDiv = null;
    	for(var i = 0; i < divItems.length; i++){
    		if( divItems[i].getAttribute("class") == "content" ){
    			innerConentDiv = divItems[i].getElementsByTagName("div")[0]; break;
    		}
    	}
    	innerConentDiv.style.backgroundColor = pSbordercolor;
    	
    	//메모리 초기화
    	innerConentDiv = null;
    	divItems = null;
	} else if (this.frameType == FRAME_NEW_NONE){
	}
	
	return;
};
/**
 * @description	미결
 * @param 		{object}	pSbordercolor
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.setSbordercolor = function (pSbordercolor ){
	// functionname : [FrameBox.setSbordercolor]
	
	this.sbordercolor = pSbordercolor;
	
	var em = null;
	if (this.frameType == FRAME_OLD_3D){
	} else if (this.frameType == FRAME_OLD_LINE){
	} else if (this.frameType == FRAME_OLD_RECT){
	} else if (this.frameType == FRAME_NEW_3D){
	} else if (this.frameType == FRAME_NEW_LINE){
	} else if (this.frameType == FRAME_IMAGE){
	} else if (this.frameType == FRAME_NEW_ROUND){
//		for (var i=10; i < 19; i++){
//			em = this.tagObject.getElementsByTagName("DIV")[i];
//			em.style.borderRightColor  = pSbordercolor;
//			em.style.borderLeftColor  = pSbordercolor;
//		}
//		this.tagObject.getElementsByTagName("DIV")[13].style.borderTopColor = pSbordercolor;
//		this.tagObject.getElementsByTagName("DIV")[15].style.borderBottomColor = pSbordercolor;
//		em = null;
	} else if (this.frameType == FRAME_NEW_FLOATINGLAYER){
		em = this.tagObject.getElementsByTagName("DIV")[5];
		em.style.borderRightColor  = pSbordercolor;
		em.style.borderLeftColor   = pSbordercolor;
		em.style.borderBottomColor = pSbordercolor;
		em.style.borderTopColor    = pSbordercolor;
		em = null;
	} else if (this.frameType == FRAME_NEW_FLOATINGLAYER_NEW){
		//내용 박스 Div
    	var divItems = this.labelObject.parentNode.getElementsByTagName("div");
    	var innerConentDiv = null;
    	for(var i = 0; i < divItems.length; i++){
    		if( divItems[i].getAttribute("class") == "content" ){
    			innerConentDiv = divItems[i].getElementsByTagName("div")[0]; break;
    		}
    	}
    	innerConentDiv.style.borderColor = pSbordercolor;
    	
    	//메모리 초기화
    	innerConentDiv = null;
    	divItems = null;
	} else if (this.frameType == FRAME_NEW_NONE){
	}
	
	return;
};

/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
FrameBox.prototype.getStyle = function (){
    return this.style; 
};
/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
FrameBox.prototype.getFrameType = function (){
    return this.frameType; 
};

/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
FrameBox.prototype.getbackcolor = function (    ){
      return this.backcolor;
};

/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
FrameBox.prototype.getbordercolor = function ( ){
      return this.bordercolor;
};
/**
 * @description	미결
 * @param 		{number}	pLeft
 * @param		{number}	pTop
 * @param		{number}	pWidth
 * @param		{number}	pHeight
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.moveWindow = function(pLeft, pTop, pWidth, pHeight){
	// functionname : [FrameBox.moveWindow]
	
	var em = null;
	var wGap = pWidth - this.width;
	var hGap = pHeight - this.height;
	
	this.height = pHeight;
	this.tagObject.style.height = pHeight+'px';
	
	this.width = pWidth;
	this.tagObject.style.width = pWidth+'px';
	
	this.left = pLeft;
	this.tagObject.style.left = pLeft+'px';
	
	this.top = pTop;
	this.tagObject.style.top = pTop+'px';

//	var arrTopIndex=[];
//	var arrLeftIndex=[];
//	var arrWidthIndex=[];
//	var arrHeightIndex=[];

	if (this.frameType == FRAME_OLD_3D){
	} else if (this.frameType == FRAME_OLD_LINE){
	} else if (this.frameType == FRAME_OLD_RECT){
	} else if (this.frameType == FRAME_NEW_3D){
//		arrWidthIndex=[0,1];
//		arrHeightIndex=[0];
	} else if (this.frameType == FRAME_NEW_LINE){
//		arrWidthIndex=[0,1,2,3,4,5];
//		arrHeightIndex=[4];
		this.tagObject.style.left = this.left;
		this.tagObject.style.top = this.top;
		this.tagObject.style.width = this.width;
		this.tagObject.style.height = this.height;
	} else if (this.frameType == FRAME_IMAGE){
//		arrWidthIndex=[1,3];
//		arrLeftIndex=[2];
//		arrHeightIndex=[3];
	} else if (this.frameType == FRAME_NEW_ROUND){
//		arrTopIndex=[5,6,7,8,15,16,17,18];
//		arrWidthIndex=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19];
//		arrHeightIndex=[4,9,14,19];
		this.tagObject.style.left = this.left;
		this.tagObject.style.top = this.top;
		this.tagObject.style.width = this.width;
		this.tagObject.style.height = this.height;
	} else if (this.frameType == FRAME_NEW_FLOATINGLAYER){
//		arrWidthIndex=[0,1,2,4,5,6,7,8];
//		arrHeightIndex=[0,1,2];
//		if(this.tagObject.getElementsByTagName("IMG")[0]){
//			em = this.tagObject.getElementsByTagName("IMG")[0];
//			em.style.left=((em.style.left == "" ? parseIntSize(window.getComputedStyle(em).left.replace(/px/g,'')) : parseIntSize(em.style.left)) + wGap) +'px';
//		}
	} else if (this.frameType == FRAME_NEW_FLOATINGLAYER_NEW){
		this.tagObject.style.left = this.left;
		this.tagObject.style.top = this.top;
		this.tagObject.style.width = this.width;
		this.tagObject.style.height = this.height;
		
		//내용 박스 Div
		var titleHeight = getComputedStyle(this.labelObject).height.replace("px", "");
    	var divItems = this.tagObject.getElementsByTagName("div");
    	var contentDiv = null;
    	for(var i = 0; i < divItems.length; i++){
    		if( divItems[i].getAttribute("class") == "content" ){
    			contentDiv = divItems[i]; break;
    		}
    	}
    	contentDiv.style.height = (this.height - 7 - (titleHeight * 1) - 7) + "px";
	} else if (this.frameType == FRAME_NEW_NONE){
//		arrWidthIndex=[0,1];
//		arrHeightIndex=[0];
		this.tagObject.style.left = this.left;
		this.tagObject.style.top = this.top;
		this.tagObject.style.width = this.width;
		this.tagObject.style.height = this.height;
	}
	
//	for (var i=0; i < arrTopIndex.length; i++){
//		em = this.tagObject.getElementsByTagName("DIV")[(arrTopIndex[i])];
//		em.style.top=((em.style.top == "" ? parseIntSize(window.getComputedStyle(em).top.replace(/px/g,'')) : parseIntSize(em.style.top)) + hGap) +'px';
//	}
//	for (var i=0; i < arrLeftIndex.length; i++){
//		em = this.tagObject.getElementsByTagName("DIV")[(arrLeftIndex[i])];
//		em.style.left=((em.style.left == "" ? parseIntSize(window.getComputedStyle(em).left.replace(/px/g,'')) : parseIntSize(em.style.left)) + wGap) +'px';
//	}
//	for (var i=0; i < arrWidthIndex.length; i++){
//		em = this.tagObject.getElementsByTagName("DIV")[(arrWidthIndex[i])];
//		em.style.width=((em.style.width == "" ? parseIntSize(window.getComputedStyle(em).width.replace(/px/g,'')) : parseIntSize(em.style.width)) + wGap) +'px';
//	}
//	for (var i=0; i < arrHeightIndex.length; i++){
//		em = this.tagObject.getElementsByTagName("DIV")[(arrHeightIndex[i])];
//		em.style.height=((em.style.height == "" ? parseIntSize(window.getComputedStyle(em).height.replace(/px/g,'')) : parseIntSize(em.style.height)) + hGap) +'px';
//	}
	
	return;
};

/**
 * @description	미결
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.click = function(){
	// functionname : [FrameBox.click]
	
	this.tagObject.click();
	
	return;
};
/**
 * @description	미결
 * @return		{void}
 * @example		미결
 */
FrameBox.prototype.SetFocus = function(){
	// functionname : [FrameBox.SetFocus]
	
	this.tagObject.focus();
	
	return;
};
/**
 * @description	미결
 * @param		{Object}	tagObject
 * @param		{Object}	grabx
 * @param		{Object}	graby
 * @return		{undefined}
 * @example		미결
 */
function MoveObject(tagObject, grabx, graby){
    this.tagObject=tagObject;
    this.grabx=grabx;
    this.graby=graby;
};

/**
 * @description	미결
 * @returns 	{Boolean}
 * @example		미결
 */
function FrameBox_onclick(){
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		var checkEvent = false;
		var control = searchControl_Frame(getSrcElement(event));
		
//		try {
//			if (eval(control.controlId + "_onclick")){ checkEvent = true;
//			}
//		} catch(e){}
//		if (checkEvent){
//		   var result = eval(control.controlId + "_onclick()");
//		   if (typeof(result)=="boolean" && !result) {
//			   return false;
//		   }
//		}
		
		//이벤트 처리
		if( control.hasClickEvent ){
			var result = control.fncClickEvent();
			if( typeof result == "boolean" && !result ){
				return false;
			}
		}
	}
	
	return true;
};
/**
 * @name		FrameBox#FrameBox_onkeydown
 * @event
 * @return		{boolean}
 * @description 미결
 */
function FrameBox_onkeydown(e){
	e = window.event || e;
    //입력된 키 정보
    var wKeyCode = (e.which) ? e.which : e.keyCode;	// 키 코드
    var wCtrlDown = e.ctrlKey || e.metaKey;			// 컨트롤 // 커맨드(Mac지원)
    var wAltDown = e.altKey;						// 알트
    var wShiftDown = getShiftKeyPressed(e);			// 쉬프트
	
    //passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		var checkEvent = false;
		var result = false;
		var control = searchControl_Frame(getSrcElement(event));
		
//		//이벤트 처리 함수 체크
//		try{
//			if( typeof self[control.controlId + "_onkeydown"] == "function" ){
//				checkEvent = true;
//			}
//		}
//		catch(e){ }
//		//이벤트 처리
//		if( checkEvent ){
//			result = self[control.controlId + "_onkeydown"](wKeyCode, wShiftDown, wCtrlDown, wAltDown);
//			if( typeof(result) == "boolean" && !result ){
//				return false;
//			}
//		}
		
		//이벤트 처리
		if( control.hasKeyDownEvent ){
			var result = control.fncKeyDownEvent();
			if( typeof result == "boolean" && !result ){
				return false;
			}
		}
    }
	
    return true;
};
/**
 * @name		FrameBox#frameBox_onClick_X
 * @event
 * @return		{boolean}
 * @description 미결
 */
function frameBox_onClick_X(e){
	if (!e) e = window.event;
	
	var control = searchControl_Frame(getSrcElement(e));
	control.setVisible(false);

    stopEvent(e);
    
	return;
};

/**
 * @name		FrameBox#frameBox_onmousedown
 * @event
 * @return		{boolean}
 * @description 미결
 */
function frameBox_onmousedown(e){
	if (!e) e = window.event;
	
	var em = getSrcElement(e);
	
	var control = searchControl_Frame(em);
	movingFrame = control.tagObject;		// 최상의 frame1의 테그를 기억
    offsetx = event.clientX;				// 마우스 다운시 X좌표 기억
    offsety = event.clientY;				// 마우스 다운시 Y좌표 기억
    
    var comp = movingFrame.currentStyle ? movingFrame.currentStyle : getComputedStyle(movingFrame, null);
    nowX = parseInt(comp.left);				// 마우스 다운시 frame1의  left값 기억
    nowY = parseInt(comp.top);				// 마우스 다운시 frame1의  top값 기억
    frameMoveStart=true;
    
    stopEvent(e);
};
/**
 * @name		FrameBox#frameBox_onmousemove
 * @event
 * @return		{boolean}
 * @description 미결
 */
function frameBox_onmousemove(e){
	if (!e) e = window.event;

	if (!frameMoveStart) return false; /// 마우스 다운했는지여부 판단
	
	movingFrame.style.position = "absolute";
	movingFrame.style.left=(nowX+event.clientX-offsetx) + "px";	//마우스 다운시 x좌표와 left의 기억값을 frame1의 테그의 값에다가 적용
	movingFrame.style.top=(nowY+event.clientY-offsety) + "px";	//마우스 다운시 x좌표와 left의 기억값을 frame1의 테그의 값에다가 적용
	
	stopEvent(e);
	
	return true;  
};

/*function frameBox_onmouseout(e){
	if (!e) e = window.event;
	
	frameMoveStart = false; /// 마우스 업했을경우 더이상 동작못하게 설정.
    stopEvent(e);
};*/
/**
 * @name		FrameBox#frameBox_onmouseup
 * @event
 * @return		{boolean}
 * @description 미결
 */
function frameBox_onmouseup(e){
	if (!e) e = window.event;
	
    frameMoveStart = false;	// 마우스 업했을경우 더이상 동작못하게 설정.
    
    stopEvent(e);
};/**
 * @class Label 컨트롤 클래스
 * @constructor Label Class 생성자 함수
 * 
 * @param controlId
 *            해당 컨트롤의 ID를 지정합니다.
 * @param controlName
 *            해당 컨트롤의 Name을 지정합니다.
 * @param tagObject
 *            해당 컨트롤의 태그 객체를 지정합니다.
 * 
 * @return 객체 생성 성공하면 객체의 errorMsg 필드가 null 입니다.<br>
 *         만약 에러가 발생한다면 errorMsg 필드에 에러메시지를 반환합니다.
 * 
 * @example var wControl = controls["label_1"] = new Label( "label_1",
 *          "Label_1", document.getElementsByName("label_1")[0] );
 *          if(wControl.errorMsg != null){ //객체 생성 실패하였습니다. 에러처리 코드를 입력해주세요. }
 */
function Label(controlId, controlName, tagObject){
    this.base = ControlBase;      //부모클래스 지정
    this.base(controlId, controlName, tagObject);         //부모클래스 생성자호출
//    this.value = tagObject.innerHTML.replaceWord("<BR/>", "\r\n");
    this.value = trim(tagObject.getElementsByTagName("td")[0].innerText);
};

Label.prototype = new ControlBase();

/**
 * @description 라벨 컨트롤의 ID를 반환합니다.
 * @param em
 *            {Object} 라벨 컨트롤 객체를 입력합니다.
 * @return 라벨 컨트롤의 ID를 반환합니다.<br>
 *         만약 에러가 발생할 경우, false 반환합니다.
 * @example var wControl = searchControl_Label(
 *          document.getElementsByName("label_1")[0] ); if(wControl == null){ //
 *          라벨 컨트롤을 찾는데 실패하였습니다. } if(wControl == false){ // searchControl_Label
 *          함수 동작 중 에러가 발생하였습니다. }
 *  // 후속코드 생략...
 */
function searchControl_Label(em){
	var pEm = em;
	var image = pEm.getAttribute("image");
	var wReturn = null;
	
//	while (pEm.parentNode && !pEm.className.startsWith("Label")) 
//		pEm = pEm.parentNode;
//	if (pEm.className.startsWith("Label")) 
//	    wReturn = getControlById(pEm.id);
	
	while(pEm.parentNode && image !== "Label"){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}
	
	if( pEm.getAttribute("image") === "Label" ){
		wReturn = getControlById(pEm.id);
	}
	else{
		pEm = null;
		pEm = em;
		
		while(pEm.parentNode && !pEm.className.startsWith("Label"))
			pEm = pEm.parentNode;
		
		if( pEm.className.startsWith("Label") )
			wReturn = getControlById(pEm.id);
	}
	
	image = null;
	pEm = null;
	
	return wReturn;
};

/**
 * @description 라벨 컨트롤의 표시문자열을 설정합니다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @param caption
 *            {String} 라벨 컨트롤의 표시문자열에 설정할 문자열을 입력합니다.
 * @return 표시문자열을 설정하는데 성공한다면 true를 반환하고<br>
 *         설정하기를 실패하거나 에러가 발생한다면 false를 반환합니다.
 * @example var wControl = controls["label_1"]; //라벨 컨트롤의 표시문자열을 '위너소프트'로 변경합니다.
 *          if( false == wControl.setValue("위너소프트") ){ //표시문자열 지정에 실패하였습니다. 에러처리
 *          코드를 입력해주세요. //에러 발생시 setValue 메소드는 false 를 반환합니다. //에러에 관한 메세지는
 *          Label.errorMsg 필드로 확인할 수 있습니다. }
 */
Label.prototype.setValue = function(caption){
    // functionname : [FrameBox.setCaption]
    
    this.setCaption(caption);
	return;
};

/**
 * @description 라벨 컨트롤의 표시문자열을 가져온다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @return 표시문자열을 가져오는데 성공한다면 표시문자열을 반환합니다.<br>
 *         가져오기에 실패하거나 에러가 발생한다면 false를 반환합니다.
 * @example var wControl = controls["label_1"]; //라벨 컨트롤의 표시문자열을 가져옵니다. var res =
 *          wControl.getValue(); if( false == res ){ //표시문자열을 가져오는데 실패하였습니다.
 *          에러처리 코드를 입력해주세요. //가져오기에 실패하거나 에러 발생시 getValue 메소드는 false 를 반환합니다.
 *          //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다. }
 */
Label.prototype.getValue = function(){
    // functionname : [FrameBox.setCaption]
    
	return this.getCaption();
};

/**
 * @description 라벨 컨트롤의 표시문자열을 설정합니다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @param caption
 *            {String} 라벨 컨트롤의 표시문자열에 설정할 문자열을 입력합니다.
 * @return 표시문자열을 설정하는데 성공한다면 true를 반환합니다<br>
 *         가져오기에 실패하거나 에러가 발생한다면 false를 반환합니다.
 * @example var wControl = controls["label_1"]; //라벨 컨트롤의 표시문자열을 '위너소프트'로 변경합니다.
 *          var res = wControl.setCaption("위너소프트") if( false == res ){ //표시문자열을
 *          설정하는데 실패하였습니다. 에러처리 코드를 입력해주세요. //설정하기에 실패하거나 에러 발생시 setCaption 메소드는
 *          false 를 반환합니다. //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다. }
 */
Label.prototype.setCaption = function(caption){
    // functionname : [FrameBox.setCaption]
                       
    caption = "" + caption;
    var wHTML = caption.replaceWord("\r\n", "<BR/>").replaceWord("\n", "<BR/>");
    var wObjectTD = this.tagObject.getElementsByTagName("td")[0];
    if(typeof wObjectTD != "undefined" || wObjectTD == null){
    	wObjectTD.innerText = wHTML;
    }
    else{
    	this.tagObject.innerHTML = wHTML;
    }
    this.value = caption;
    
	return;
};

/**
 * @description 라벨 컨트롤의 표시문자열을 가져옵니다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @return 표시문자열을 가져오는데 성공한다면 표시문자열을 반환하고, 에러가 발생한다면 undefined를 가져온다.
 * @example var wControl = controls["label_1"]; //라벨 컨트롤의 표시문자열을 '위너소프트'로 변경합니다.
 *          var res = wControl.setCaption("위너소프트") if( false == res ){ //표시문자열을
 *          설정하는데 실패하였습니다. 에러처리 코드를 입력해주세요. //설정하기에 실패하거나 에러 발생시 setCaption 메소드는
 *          false 를 반환합니다. //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다. }
 */
Label.prototype.getCaption = function(){
    // functionname : [FrameBox.setCaption]
    
    //var wHTML = this.tagObject.innerHTML;
	//return wHTML.replaceWord("<BR/>", "\r\n");
	
	var wHTML = "";
	var wObjectTD = this.tagObject.getElementsByTagName("td")[0];
	if(typeof wObjectTD != "undefined" || wObjectTD == null){
		wHTML = wObjectTD.innerText;
    }
    else{
    	wHTML = this.tagObject.innerHTML;
    }
	
	return wHTML.replaceWord("<BR/>", "\r\n");
};
/**
 *       @class          TabBox 컨트롤 클래스
 *       @constructor    TabBox
 *
 *       @param          controlId     해당 컨트롤의 ID를 지정한다.
 *       @param          controlName   해당 컨트롤의 Name을 지정한다.
 *       @param          tagObject     해당 컨트롤의 태그 속성을 설정하는 객체를 지정한다.
 *
 *       @return         생성자 호출에 성공했다면 true를 리턴하지만, 실패했다면 false를 리턴한다.
 *
 *       @example        var wControls = controls["TabBox_1"] = new TabBox("tabbox_1", "TabBox_1", document.getElementsByName("tabbox_1")[0]);
 *        if(wControl.errorMsg != null){
 *            //객체 생성 실패하였습니다. 에러처리 코드를 입력해주세요.
 *        }
 *
 *        // 후속코드 생략...
 */
function TabBox(controlId, controlName, tagObject){
	// 상속선언부
	this.base = ControlBase;						//부모클래스 지정
	this.base(controlId, controlName, tagObject);	//부모클래스 생성자호출
	this.tagObject = tagObject;
	
	// 상수 선언부
	// 속성 선언부
	this.tabcount = 0;
	this.currentTab = 0;
	this.tabSideBtnMouseDowned = false;
	
	var tabHeaderRow = document.getElementById(controlId + "_header");
	var tabCells = null;
	var tabSelCell = null;
	var sideBarLeftArrow = null;
	var sideBarRightArrow = null;
	
	if( tabHeaderRow != null ){
		tabCells = tabHeaderRow.getElementsByClassName("TabGen");
		tabSelCell = tabHeaderRow.getElementsByClassName("TabSel")[0];
		sideBarLeftArrow = tabHeaderRow.getElementsByClassName("LeftArrow")[0];
		sideBarRightArrow = tabHeaderRow.getElementsByClassName("RightArrow")[0];
		
//		this.tabcount = tabCells.length - 1;
		this.tabcount = tabCells.length;
		
		if( tabSelCell != null && typeof tabSelCell != "undefined" )
			this.currentTab = (1 * tabSelCell.getAttribute("tabnum"));
	}
	
	if( tagObject != undefined ){
		tagObject.setAttribute("tabIndex", "-1");
	}
	
	// 이벤트 선언부
	// 탭 클립 이벤트
	for(var i = 0; i < tabCells.length; i++){
		setEventHandler(tabCells[i], "click", tabbox_Click);
	}
	// 사이드 버튼 클릭 이벤트
	if( sideBarLeftArrow != null ){
		setEventHandler(sideBarLeftArrow, "mousedown", tabbox_SideBtn_Mousedown);
		setEventHandler(sideBarLeftArrow, "mouseup", tabbox_SideBtn_Mouseup);
		setEventHandler(sideBarLeftArrow, "mouseout", tabbox_SideBtn_Mouseup);
	}
	if( sideBarLeftArrow != null ){
		setEventHandler(sideBarRightArrow, "mousedown", tabbox_SideBtn_Mousedown);
		setEventHandler(sideBarRightArrow, "mouseup", tabbox_SideBtn_Mouseup);
		setEventHandler(sideBarRightArrow, "mouseout", tabbox_SideBtn_Mouseup);
	}
	
	// 사용자 이벤트 처리
	this.hasClickEvent = false; this.fncClickEvent = null;
	
	if( this.controlId.length > 0 ){
		//이벤트 함수 코드 생성 여부
		this.hasClickEvent = (typeof self[this.controlId + "_ontabclick"] != "undefined");
		//이벤트 함수 코드가 생성되었다면 이벤트 호출 함수 생성
		if( this.hasClickEvent ){
			this.fncClickEvent = new Function("return function (oldTabNum, newTabNum) { return " + this.controlId + "_ontabclick(oldTabNum, newTabNum); }")();
		}
	}
	
	// 메모리 해제
	sideBarRightArrow = null; sideBarLeftArrow = null;
	tabSelCell = null; tabCells = null; tabHeaderRow = null;
};

TabBox.prototype = new ControlBase(); // 의미없음 코딩 편의기능을 활용하기 위함

/**
 *       @description    탭박스 컨트롤을 찾습니다.
 *       @param          em        {Object}      컨트롤의 태그 객체를 입력합니다.
 *       @return         탭박스 컨트롤을 찾는다면 탭박스의 컨트롤 ID를 반환하고, 찾지 못한다면 null을 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
 *       @example        var wControl = searchControl_CheckBox( document.getElementsByName("tabbox_1")[0] )
 *        if(wControl == null){  // 탭박스 컨트롤을 찾는데 실패하였습니다. }
 *        if(wControl == false){ // searchControl_CheckBox 함수 동
 *        작 중 에러가 발생하였습니다. }
 *
 *        // 후속코드 생략...
 */
function searchControl_TabBox(em){
	var pEm = em;
	var image = pEm.getAttribute("image");
	var wReturn = null;
	
//	while(pEm.parentNode && !pEm.className.startsWith("TabBox")) 
//		pEm = pEm.parentNode;
//	if( pEm.className.startsWith("TabBox") ) 
//		wReturn = getControlById(pEm.id);
	
	while(pEm.parentNode && image !== "TabBox"){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}
	
	if( pEm.getAttribute("image") === "TabBox" ){
		wReturn = getControlById(pEm.id);
	}
	else{
		pEm = null;
		pEm = em;
		
		while(pEm.parentNode && !pEm.className.startsWith("TabBox"))
			pEm = pEm.parentNode;
		
		if( pEm.className.startsWith("TabBox") )
			wReturn = getControlById(pEm.id);
	}
	
	image = null;
	pEm = null;
	
	return wReturn;
};

/**
 *     	@description  미결
 *     	@return       {undefined}
 *     	@example      미결
 */
TabBox.prototype.tabResize = function(){
	var tabHeaderRow = document.getElementById(this.controlId + "_header");
	
	if( tabHeaderRow != null ){
		var tabTable = tabHeaderRow.getElementsByClassName("TabTable")[0];
		var tabGenCells = tabHeaderRow.getElementsByClassName("TabGen");
		var tabBlankCells = tabHeaderRow.getElementsByClassName("TabBlank")[0];
		var tabSideBar = tabHeaderRow.getElementsByClassName("TabSideBar")[0];
		var cellStyle = null;
		
		var tabBoxWidth = parseIntSize(getComputedStyle(this.tagObject, null).width);
		var tabTableMarginLeft = parseIntSize(tabTable.style.marginLeft);
		var tabSideBarLeft = parseIntSize(getComputedStyle(tabSideBar, null).left);
		var tabWidthSum = 0;
		var tabWidthBlank = 0;
		var i = 0;
		
		//탭의 너비의 총 합을 구합니다.
		for(i = 0; i < tabGenCells.length; i++, cellStyle = null){
			cellStyle = getComputedStyle(tabGenCells[i], null);
			tabWidthSum += (tabGenCells[i].getAttribute("hidetab") == "true") ? 0 : parseIntSize(cellStyle.width);
		}
		
		//Blank탭 및 탭 테이블의 너비 등 재계산
		tabWidthBlank = tabBoxWidth - tabWidthSum;
		
		tabTable.style.width = (tabWidthBlank < 0) ? tabWidthSum : tabBoxWidth;
		if( tabTableMarginLeft < 0 && tabWidthSum + tabTableMarginLeft <= tabSideBarLeft )
			tabTable.style.marginLeft = ((tabTableMarginLeft < 0 && tabWidthBlank <= 0) ? tabBoxWidth - 40 - tabWidthSum : 0) + "px";
		tabBlankCells.style.width = (tabWidthBlank <= 0 ? 0 : tabWidthBlank) + "px";
		
		//탭 사이드바 보이기
//		tabSideBar.style.display = (tabWidthBlank <= 0) ? "block" : "none";
//		tabSideBar.style.display = (tabWidthBlank <= 0) ? "table" : "none";	//2019.04.19 jaeik firefox에서 하위 콘트롤 top위치가 맞지 않는 문제가 있어 display = "table" 로 변경
		tabSideBar.style.display = (tabWidthBlank <= 0) ? "table" : "";
		tabSideBar.style.visibility = (tabWidthBlank <= 0) ? "visible" : "hidden";
		
		//메모리 초기화
		cellStyle = null;
		tabSideBar = null;
		tabBlankCells = null;
		tabGenCells = null;
		tabTable = null;
	}
	
	//메모리 초기화
	tabHeaderRow = null;
};

/**
 *       @description    지정한 인덱스의 탭을 보여줍니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *       @param          tabIndex        {Number}        선택하고 싶은 탭의 인덱스 입니다.
 *       @return         지정한 인덱스의 탭을 선택하면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
 *       @example        var wControls = controls["TabBox_1"];
 *        //2번 탭을 보여줍니다.
 *        if( wControl.showTab(2) == false ){
 *           //2번 인덱스 탭 보여주기 실패하였습니다. 에러처리 코드를 입력해주세요.
 *           //탭 보여주기를 실패하거나 에러 발생시 showTab 메소드는 false 를 반환합니다.
 *           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
 *        }
 */
TabBox.prototype.showTab = function(tabIndex){
	// functionname : [TabBox.showTab]
	
	//예외처리
	//tabIndex는 0부터 시작
	if( tabIndex < 0 )
		return false;
	//tabIndex 초과
	if( tabIndex > this.tabcount )
		return false;
	
	var result = false;
	var tabHeaderRow = document.getElementById(this.controlId + "_header");
	
	if( tabHeaderRow != null ){
		var tabs = tabHeaderRow.getElementsByClassName("TabGen");
		var tab = tabs[tabIndex];
		
		//해당 tabIndex의 탭을 가져오지 못한 경우
		if( tab == null || typeof tab == "undefined" ){
			tab = null; tabs = null; tabHeaderRow = null;	//메모리 해제
			return false;			
		}
		
		//탭 속성 설정
		tab.setAttribute("hidetab", "false");
		//탭 사이즈 조정
		this.tabResize();
		//탭 보이기
		tab.style.display = "";
		
		//처리 결과
		result = true;
		
		//메모리 해제
		tab = null; tabs = null;
	}
	
	//메모리 해제
	tabHeaderRow = null;
	
	return result;
};

/**
 *       @description    지정한 인덱스의 탭을 숨깁니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *       @param          tabIndex        {Number}        선택하고 싶은 탭의 인덱스 입니다.
 *       @return         지정한 인덱스의 탭을 선택하면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
 *       @example        var wControls = controls["TabBox_1"];
 *        //2번 탭을 숨깁니다.
 *        if( wControl.showTab(2) == false ){
 *           //2번 인덱스 탭 숨기기 실패하였습니다. 에러처리 코드를 입력해주세요.
 *           //탭 숨기기를 실패하거나 에러 발생시 hideTab 메소드는 false 를 반환합니다.
 *           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
 *        }
 */
TabBox.prototype.hideTab = function(tabIndex){
	// functionname : [TabBox.hideTab]
	
	//예외처리
	//tabIndex는 0부터 시작
	if( tabIndex < 0 )
		return false;
	//tabIndex 초과
	if( tabIndex > this.tabcount )
		return false;
	
	var result = false;
	var tabHeaderRow = document.getElementById(this.controlId + "_header");
	
	if( tabHeaderRow != null ){
		var tabs = tabHeaderRow.getElementsByClassName("TabGen");
		var tab = tabs[tabIndex];
		
		//해당 tabIndex의 탭을 가져오지 못한 경우
		if( tab == null || typeof tab == "undefined" ){
			tab = null; tabs = null; tabHeaderRow = null;	//메모리 해제
			return false;			
		}
		
		//탭 속성 설정
		tab.setAttribute("hidetab", "true");
		//탭 사이즈 조정
		this.tabResize();
		//탭 숨기기
//		tab.style.display = "none";
		tab.style.display = "";
		tab.style.visibility = "hidden";
		
		//처리 결과
		result = true;
		
		//메모리 해제
		tab = null; tabs = null;
	}
	
	//메모리 해제
	tabHeaderRow = null;
	
	return result;
};

/**
 *     	@description  미결	
 *     	@param		  {String}  tabIndex
 *     	@param		  {String}  title
 *     	@return       {Boolean}
 *     	@example      미결
 */
TabBox.prototype.setTabTitle = function(tabIndex, title){
	// functionname : [TabBox.setTabTitle]
	
	//예외처리
	//tabIndex는 0부터 시작
	if( tabIndex < 0 )
		return false;
	//tabIndex 초과
	if( tabIndex > this.tabcount )
		return false;
	
	var result = false;
	var tabHeaderRow = document.getElementById(this.controlId + "_header");
	
	if( tabHeaderRow != null ){
		var tabs = tabHeaderRow.getElementsByClassName("TabGen");
		var tab = tabs[tabIndex];
		
		//해당 tabIndex의 탭을 가져오지 못한 경우
		if( tab == null || typeof tab == "undefined" ){
			tab = null; tabs = null; tabHeaderRow = null;	//메모리 해제
			return false;			
		}
		
		//타이틀 설정
		tab.setAttribute("title", title);
		tab.innerText = title;
		
		//처리 결과
		result = true;
		
		//메모리 초기화
		tab = null; tabs = null;
	}
	
	//메모리 해제
	tabHeaderRow = null;
	
	return result;
};

/**
 *     	@description  미결
 *     	@param		  {String}	tabIndex
 *     	@return       {String}
 *     	@example      미결
 */
TabBox.prototype.getTabTitle = function(tabIndex){
	// functionname : [TabBox.setTabTitle]
	
	//예외처리
	//tabIndex는 0부터 시작
	if( tabIndex < 0 )
		return false;
	//tabIndex 초과
	if( tabIndex > this.tabcount )
		return false;
	
	var title = null;
	var tabHeaderRow = document.getElementById(this.controlId + "_header");
	
	if( tabHeaderRow != null ){
		var tabs = this.tagObject.getElementsByClassName("TabGen");
		var tab = tabs[tabIndex - 1];
		
		//해당 tabIndex의 탭을 가져오지 못한 경우
		if( tab == null || typeof tab == "undefined" ){
			tab = null; tabs = null; tabHeaderRow = null;	//메모리 해제
			return null;
		}
		
		title = tab.innerText.trim();
		
		//메모리 초기화
		tab = null; tabs = null;
	}
	
	//메모리 초기화
	tabHeaderRow = null;
	
	return title;
};

/**
 *       @description    지정한 인덱스의 탭을 선택하고 탭 내용을 보여줍니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *       @param          tabIndex        {Number}        선택하고 싶은 탭의 인덱스 입니다.
 *       @return         지정한 인덱스의 탭을 선택하면 true를 반환합니다.<br>만약 에러가 발생한다면 false를 반환합니다.
 *       @example        var wControls = controls["TabBox_1"];
 *        //2번 탭을 선택합니다.
 *        if( wControl.setTabIndex(2) == false ){
 *           //2번 인덱스 탭 선택 실패하였습니다. 에러처리 코드를 입력해주세요.
 *           //탭 선택을 실패하거나 에러 발생시 setTabIndex 메소드는 false 를 반환합니다.
 *           //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다.
 *        }
 */
TabBox.prototype.setTabIndex = function(tabIndex){
	// functionname : [TabBox.setTabIndex]
	
	var tabHeaderRow = document.getElementById(this.controlId + "_header");
	
	if( tabHeaderRow != null ){
		var tabGenCells = tabHeaderRow.getElementsByClassName("TabGen");
		var tabGenCell = null;
		var paneName = null;
		var paneBox = null;
		
		var oldTab = this.currentTab;
		var tabCount = tabGenCells.length;
		var i = 0;
		
		//현재 탭 인덱스 설정
		this.currentTab = tabIndex;
		
		for(i = 0; i < tabCount; i++, tabGenCell = null, paneName = null, paneBox = null){
			tabGenCell = tabGenCells[i];
			paneName = tabGenCell.getAttribute("pane");
			
			//탭 본문 객체 찾음
			if( paneName != null && (typeof paneName == "string" && paneName != "") )
				paneBox = document.getElementsByName(paneName)[0];
			
			//탭 선택여부에 따른 탭 클래스 및 본문 보이기 여부 설정
			if( i == tabIndex ){
				//텝 클래스 설정
				tabGenCell.setAttribute("class", "TabGen TabSel");
				//탭 선택여부에 따른 본문 보이기
				if( paneBox != null && typeof paneBox != "undefined" ){
//					paneBox.style.display = "block";
//					paneBox.style.display = "table"; //2019.04.19 jaeik firefox에서 하위 콘트롤 top위치가 맞지 않는 문제가 있어 display = "table" 로 변경
					paneBox.style.display = "table";
					paneBox.style.visibility = "visible";
					//탭 안의 시트 리사이즈
					_resizeSheetInTabbox(paneBox);
				}
			}
			else{
				//텝 클래스 설정
				tabGenCell.setAttribute("class", "TabGen");
				//탭 선택여부에 따른 본문 숨기기
//				if( paneBox != null ) paneBox.style.display = "none";
				if( paneBox != null ) paneBox.style.display = "";
				if( paneBox != null ) paneBox.style.visibility = "hidden";
			}
		}
		
		//이벤트 호출
		if( this.hasClickEvent ){
			if( !this.fncClickEvent(oldTab, this.currentTab) ){
				this.hasClickEvent = false;	//탭 클릭 이벤트 발생을 막기위해 임시로 false로 설정
				this.setTabIndex(oldTab);	//이전 탭 인덱스로 복구
				this.hasClickEvent = true;	//원래 상태 복구
			}
		}
		
		//메모리 해제
		paneBox = null; paneName = null; tabGenCell = null; tabGenCells = null;
	}
	
	//메모리 해제
	tabHeaderRow = null;
	
	return;
};

/**
 * 		탭 활성화
 *     	@description  미결
 *     	@param		  {String}  tabIndex
 *     	@return       {Boolean}
 *     	@example      미결
 */
TabBox.prototype.setEnabled = function(tabIndex){
	// functionname : [TabBox.setEnabled]
	
	var wReturn = true;
	
	if( typeof tabIndex == "number" && (tabIndex >= 0 && tabIndex < this.tabCount) ){
		var tabHeaderRow = document.getElementById(this.controlId + "_header");
		var tabs = null;
		var tab = null;
		
		if( tabHeaderRow != null ){
			tabs = tabHeaderRow.getElementsByClassName("TabGen");
			tab = tabs[tabIndex];
			
			//해당 tabIndex의 탭을 가져오지 못한 경우
			if( tab == null || typeof tab == "undefined" ){
				tab = null; tabs = null; tabHeaderRow = null;	//메모리 해제
				return null;
			}
			
			tab.style.pointerEvents = "";
			tab.style.opacity = "";
			tab.style.filter = "";
			
			//메모리 해제
			tab = null; tabs = null;
		}
		
		//메모리 해제
		tabHeaderRow = null;
	}
	else if( typeof tabIndex == "boolean" ){
		var childObject = null;
		var childCount = this.tagObject.children.length;
		var i = 0;
		var j = 0;
		
		this.enabled = tabIndex;
		this.tagObject.disabled = !this.enabled;
		
		//하위 테그들 조정
		for(i = 0; i < childCount; i++, childObject = null){
			childObject = this.tagObject.children[i];
			childTag.disabled = !enabled;
			
			for(j = 0; j < childTag.children.length; j++){
				childTag.children[j].disabled = !this.enabled;
			}
		}
	}
	else{
		wReturn = false;
	}
	
	return wReturn;
};

/**
 *		탭비활성화
 *     	@description  미결
 *     	@param		  {String}  tabIndex
 *     	@return       {Boolean}
 *     	@example      미결
 */
TabBox.prototype.setDisabled = function(tabIndex){
	// functionname : [TabBox.setDisabled]
	
	var wReturn = true;
	var enabled = null;
	var childTag = null;
	
	if( typeof tabIndex == "number" && (tabIndex >= 0 && tabIndex < this.tabCount) ){
		var tabHeaderRow = document.getElementById(this.controlId + "_header");
		var tabs = null;
		var tab = null;
		
		if( tabHeaderRow != null ){
			tabs = tabHeaderRow.getElementsByClassName("TabGen");
			tab = tabs[tabIndex];
			
			//해당 tabIndex의 탭을 가져오지 못한 경우
			if( tab == null || typeof tab == "undefined" ){
				tab = null; tabs = null; tabHeaderRow = null;	//메모리 해제
				return null;
			}
			
			tab.style.pointerEvents = "none";
			tab.style.opacity = "0.9";
			tab.style.filter = 'Alpha(Opacity=60)';	
			
			//메모리 해제
			tab = null; tabs = null;
		}
		
		//메모리 해제
		tabHeaderRow = null;
	}
	else if( typeof tabIndex == "boolean" ){ 
		var childObject = null;
		var childCount = this.tagObject.children.length;
		var i = 0;
		var j = 0;
		
		this.enabled = tabIndex;
		this.tagObject.disabled = !this.enabled;
		
		//하위 테그들 조정
		for(i = 0; i < childCount; i++, childObject = null){
			childObject = this.tagObject.children[i];
			childTag.disabled = !enabled;
			
			for(j = 0; j < childTag.children.length; j++){
				childTag.children[j].disabled = !this.enabled;
			}
		}
	}
	else{
		wReturn = false;
	}
	
	return wReturn;
};

/**
 *     	@description  미결
 *     	@param        {String}		panetabbox       
 *     	@return       {undefined}
 *     	@example      미결
 */
function _resizeSheetInTabbox(paneTabbox){
	if( paneTabbox == null || typeof paneTabbox == "undefined" )
		return;
	
	var childsInTab = paneTabbox.children;
	var childObject = null;
	var childCount = childsInTab.length;
	var i = 0;
	
	var className = null;
	var control = null;
	
	for(className = "", i = 0; i < childCount; i++, childObject = null, className = "", control = null){
		childObject = childsInTab[i];
		className = ("" + childObject.getAttribute("class"));
		control = controls[("" + childObject.getAttribute("ctlname"))];
		
		//시트인 경우 리사이즈
		if( className.indexOf("DataSheet") >= 0 ){
			if( control != null && typeof control != "undefined" ){
				if( typeof control.setPosition == "function" ) control.setPosition();
				if( typeof control.refresh == "function" ) control.refresh();
				if( typeof control.resize == "function" ) control.resize();
			}
		}
		//탭인 경우 선택된 탭 안의 시트 리사이즈
		else if( className.indexOf("TabBox") >= 0 ){
			if( control != null && typeof control != "undefined" ){
				var tabHeaderRow = document.getElementById(control.controlId + "_header");
				var tabs = null;
				var tab = null;
				var tabCount = 0;
				var j = 0;
				
				if( tabHeaderRow != null ){
					tabs = tabHeaderRow.getElementsByClassName("TabGen");
					
					for(tabCount = tabs.length, j = 0; j < tabCount; j++, tab = null){
						tab = tabs[j];
						
						if( ("" + tab.getAttribute("class")).indexOf("TabSel") >= 0 ){
							//텝 안의 시트 리사이즈
							_resizeSheetInTabbox( document.getElementsByName(("" + tab.getAttribute("pane")))[0] );
						}
					}
					
					//메모리 해제
					tab = null; tabs = null;
				}
				
				if( typeof control.tabResize == "function" ) control.tabResize();
				
				//메모리 해제
				tabHeaderRow = null;
			}
		}
		//프레임 박스인 경우 프레임 박스 안의 시트 리사이즈
		else if( typeof FrameBox == "function" && control instanceof FrameBox ){
			if( control != null && typeof control != "undefined"
				&& control.tagObject != null && typeof control.tagObject != "undefined"
			){
				//텝 안의 시트 리사이즈
				_resizeSheetInTabbox( control.tagObject );
			}
		}
	}
	
	//메모리 해제
	control = null; className = null; childObject = null; childsInTab = null;
};

/**
 *     	@description  미결
 *     	@return       {Boolean}
 *     	@example      미결
 */
function tabbox_Click(){
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? event.target : event.srcElement);
	var control = searchControl_TabBox(em);
	
	if( control.enabled == false ){
		control = null; em = null;	//메모리 해제
		return false;
	}
	
	var oldTab = 1 * control.currentTab;
	var tabIndex = 1 * em.cellIndex;
	
	if( oldTab == tabIndex ){
		control = null; em = null;	//메모리 해제
		return false;
	}
	
	var tabHeaderRow = document.getElementById(control.controlId + "_header");
	var tabs = null;
	var tab = null;
	var paneName = null;
	var paneBox = null;
	var tabCount = 0;
	var i = 0;
	
	if( tabHeaderRow != null ){
		tabs = tabHeaderRow.getElementsByClassName("TabGen");
		tabCount = tabs.length;
		
		//현재 탭 인덱스 설정
		control.currentTab = tabIndex;
		
		for(i = 0; i < tabCount; i++, tab = null, paneName = null, paneBox = null){
			tab = tabs[i];
			paneName = tab.getAttribute("pane");
			
			//탭 본문 객체 찾음
			if( paneName != null && (typeof paneName == "string" && paneName != "") )
				paneBox = document.getElementsByName(paneName)[0];
			
			//탭 선택여부에 따른 탭 클래스 및 본문 보이기 여부 설정
			if( i == tabIndex ){
				//텝 클래스 설정
				tab.setAttribute("class", "TabGen TabSel");
				//탭 선택여부에 따른 본문 보이기
				if( paneBox != null && typeof paneBox != "undefined" ){
//					paneBox.style.display = "block";
//					paneBox.style.display = "table"; //2019.04.19 jaeik firefox에서 하위 콘트롤 top위치가 맞지 않는 문제가 있어 display = "table" 로 변경
					paneBox.style.display = "table";
					paneBox.style.visibility = "visible";
					//탭 안의 시트 리사이즈
					_resizeSheetInTabbox(paneBox);
				}
			}
			else{
				//텝 클래스 설정
				tab.setAttribute("class", "TabGen");
				//탭 선택여부에 따른 본문 숨기기
				if( paneBox != null ) paneBox.style.display = "none";
//				if( paneBox != null ) paneBox.style.display = "";
				if( paneBox != null ) paneBox.style.visibility = "hidden";
			}
		}
		
		//이벤트 호출
		/*if( this.hasClickEvent ){
			if( !this.fncClickEvent(oldTab, control.currentTab) ){
				this.hasClickEvent = false;	//탭 클릭 이벤트 발생을 막기위해 임시로 false로 설정
				this.setTabIndex(oldTab);	//이전 탭 인덱스로 복구
				this.hasClickEvent = true;	//원래 상태 복구
			}
		}*/
		if( control.hasClickEvent ){
			if( !control.fncClickEvent(oldTab, control.currentTab) ){
				control.hasClickEvent = false;	//탭 클릭 이벤트 발생을 막기위해 임시로 false로 설정
				control.setTabIndex(oldTab);	//이전 탭 인덱스로 복구
				control.hasClickEvent = true;	//원래 상태 복구
			}
		}
		
		//메모리 해제
		paneBox = null; paneName = null; tab = null; tabGenCells = null;
	}
	
	//메모리 해제
	tabHeaderRow = null;
	
	return true;
};

function tabbox_SideBtn_Mousedown(){
	var em = null;
	var control = null;
	var pEm = null;
	var className = null;
	var direction = 0;
	
	em = (navigator.userAgent.indexOf('Firefox') >= 0 ? event.target : event.srcElement);
	control = searchControl_TabBox(em);
	
	if( control.enabled == false ){
		control = null; em = null;	//메모리 해제
		return false;
	}
	
	pEm = em;
	className = pEm.getAttribute("class");
	className = (className == null || typeof className == "undefined") ? "" : className;
	
	while( pEm.parentNode && !(className.indexOf("LeftArrow") >= 0 || className.indexOf("RightArrow") >= 0) ){
		pEm = pEm.parentNode;
		className = pEm.getAttribute("class");
		className = (className == null || typeof className == "undefined") ? "" : className;
	}
	
	if( pEm.getAttribute("class").indexOf("LeftArrow") >= 0 )
		direction = 1;
	else if( pEm.getAttribute("class").indexOf("RightArrow") >= 0 )
		direction = -1;
	
	self._movTabMouseDown = true;
	self._movTabDirection = direction;
	self._movTabControl = control;
	
	tabbox_TabTableMove();
	
	stopEvent(event);
	
	className = null;
	pEm = null;
	control = null;
	em = null;
	
	return true;
}

function tabbox_SideBtn_Mouseup(){
	var em = null;
	var control = null;
	var pEm = null;
	var className = null;
	var direction = 0;
	
	em = (navigator.userAgent.indexOf('Firefox') >= 0 ? event.target : event.srcElement);
	control = searchControl_TabBox(em);
	
	if( control.enabled == false ){
		control = null; em = null;	//메모리 해제
		return false;
	}
	
	self._movTabMouseDown = false;
	delete self._movTabDirection;
	delete self._movTabControl;
	
	stopEvent(event);
	
	className = null;
	pEm = null;
	control = null;
	em = null;
	
	return true;
};

function tabbox_TabTableMove(){
	if( !self._movTabMouseDown )
		return false;
	
	var tabHeaderRow = document.getElementById(self._movTabControl.controlId + "_header");
	
	if( tabHeaderRow == null )
		return false;
	
	var tabTable = tabHeaderRow.getElementsByClassName("TabTable")[0];
	var tabTableWidth = parseIntSize((tabTable.currentStyle ? tabTable.currentStyle : getComputedStyle(tabTable, null)).width);
	var sideBar = tabHeaderRow.getElementsByClassName("TabSideBar")[0];
	var sideBarWidth = parseIntSize((sideBar.currentStyle ? sideBar.currentStyle : getComputedStyle(sideBar, null)).width);
	var tabBox = self._movTabControl.tagObject;
	var tabBoxWidth = parseIntSize((tabBox.currentStyle ? tabBox.currentStyle : getComputedStyle(tabBox, null)).width);
	
	var maxMove = ((tabTableWidth + sideBarWidth) - tabBoxWidth) * -1;
	var leftMove = 1 * (("" + tabTable.style.marginLeft).replace("px", ""));
	
	leftMove = leftMove + (10 * self._movTabDirection);
	leftMove = (leftMove < maxMove) ? maxMove : leftMove;
	leftMove = (leftMove > 0) ? 0 : leftMove;
	
	tabTable.style.marginLeft = leftMove + "px";
	
	setTimeout(tabbox_TabTableMove, 200);
	
	tabBox = null;
	sideBar = null;
	tabTable = null;
};    /**
     * @class TreeView를 만들어주는 클래스
     * @param controlId
     *            {String} Control의 id를 입니다.
     * @param controlName
     *            {String} Control의 name을 입니다.
     * @param tagObject
     *            {Object} 태그객체 입니다.
     * @example 미결
     */   
function TreeView(controlId, controlName, tagObject){
    // 상속선언부
    this.base = ControlBase;              			//부모클래스 지정
    this.base(controlId, controlName, tagObject);   //부모클래스 생성자호출
    
    // 상수 선언부
    // 속성 선언부
    this.expandFirst = false;
    this.selectedItem = null;
    this.nodes = new Nodes();
    this.linkInfo = "";
    this.levelCount = 0;
    this.workNode = null;
    this.levelIcons = [];       // image 배열
    this.didIconDefined = [false, false, false, false, false, false, false, false, false, false, false];   // true / false
    this.fillAtOnce = [false, false, false, false, false, false, false, false, false, false, false];   // 단번에 채우는 스텝인가 여부
    this.innerDataset = null;
    
    // 최초 트리생성시 펼쳐지는 레벨
    this.firstOpenNodeLevel = 0;

    // 초기화 동작
    this.nodes.parentControl = this;
    
    if (tagObject != undefined){
        tagObject.setAttribute("tabIndex", "-1");
    }

    //  트리채우기 함수 
    this.hasfillTreeEvent = []; 
    this.fncfillTreeEvent = [];

    for (var i=0; i < 11; i++){
        var exist = this.hasfillTreeEvent[i] = (typeof self[ "fillTree_" + this.controlId + "_Step" + i ] != "undefined");
        if (!exist) continue;

        this.fncfillTreeEvent[i] = new Function("return function (nodeKey) { return fillTree_" + this.controlId  + "_Step" + i + "(nodeKey); }")();
    }
    
    // 클릭과 더블클릭 이벤트 
    this.hasNodeClickEvent = false; this.fncNodeClickEvent = null;
    this.hasNodeDblClickEvent = false;  this.fncNodeDblClickEvent = null;

    this.hasNodeClickEvent = (typeof self[this.controlId + "_onnodeclick"] != "undefined");
    if (this.hasNodeClickEvent){
        this.fncNodeClickEvent = new Function("return function (node) { return " + this.controlId + "_onnodeclick(node); }")();
    }

    this.hasNodeDblClickEvent = (typeof self[this.controlId + "_onnodedblclick"] != "undefined");
    if (this.hasNodeDblClickEvent){
        this.fncNodeDblClickEvent = new Function("return function (node) { return " + this.controlId + "_onnodedblclick(node); }")();
    }

};

TreeView.prototype = new ControlBase(); // 의미없음 코딩 편의기능을 활용하기 위함

/**
 * @description	미결
 * @param		{Object}	em
 * @return		{String}
 * @example		미결
 */
function searchControl_TreeView(em){
	var pEm = em;
	var image = pEm.getAttribute("image");
	var wReturn = null;
	
//	while (pEm.parentNode && !pEm.className.startsWith("TreeView")) 
//		pEm = pEm.parentNode;
//	if (pEm.className.startsWith("TreeView")) 
//		wReturn = getControlById(pEm.id);
	
	while(pEm.parentNode && image !== "TreeView"){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}
	
	if( pEm.getAttribute("image") === "TreeView" ){
		wReturn = getControlById(pEm.id);
	}
	else{
		pEm = null;
		pEm = em;
		
		while(pEm.parentNode && !pEm.className.startsWith("TreeView"))
			pEm = pEm.parentNode;
		
		if(pEm.className.startsWith("TreeView"))
			wReturn = getControlById(pEm.id);
	}
	
	image = null;
	pEm = null;
	
	return wReturn;
};

/**
 * @description	미결
 * @param		{Object}	em
 * @return		{String}
 * @example		미결
 */
function search_Node(em){
	var nodeTag = em;
	var wNode =  null;
	var wReturn = null;
	
	while (nodeTag.parentNode && nodeTag.className != "Node"){
		nodeTag = nodeTag.parentNode;
	}
	
	var control = searchControl_TreeView(em);
    for (var i=control.nodes.arrNodes.length - 1; i >= 0; i--){
        wNode = control.nodes.arrNodes[i];
        if (wNode.tagObject == nodeTag){
        	wReturn = wNode;
        }
    }
	
	
	return wReturn;
};

/**
 * @description	미결
 * @param		{Object}	em
 * @return		{String}
 * @example		미결
 */
function search_NodeTag(em){
	var nodeTag = em;
	var wReturn = null;
	
	while (nodeTag.parentNode && nodeTag.className != "Node") 
		nodeTag = nodeTag.parentNode;
	if (nodeTag.className == "Node") 
	    wReturn = nodeTag;

	return wReturn;
};

/**
 * @description	미결
 * @param 		{String}	key
 * @return		{String}
 * @example		미결
 */
TreeView.prototype.getNode = function(key){
	// functionname : [TreeView.getNode]

	return this.nodes.item(key);
};

/**
 * @description	미결
 * @param 		{String}	nLevel
 * @param		{String}	imageName
 * @return		{void}
 * @example		미결
 */
TreeView.prototype.setStepIcon = function(nLevel, imageName){
	// functionname : [TreeView.setStepIcon]
	this.levelIcons[nLevel] = new Image();
	this.levelIcons[nLevel].src = CONTEXT_ROOT + "/winnersoft/images/tree/" + imageName;
	
	for (var i=1; i < this.levelCount; i++){
		if (typeof this.didIconDefined[i] == "undefined") this.didIconDefined[i] = false;
	}
	this.didIconDefined[nLevel] = true;
	
	return;
};

/**
 * @description	미결
 * @param 		{number}	pStepNum
 * @param		{number}	recordset
 * @param		{number}	pExpanded
 * @param		{number}	byAllLevel
 * @param		{number}	useSelfLevel
 * @param		{number}	useCheckBox
 * @param		{number}	skipIfNotFound
 * @return		{boolean}
 * @example		미결
 */
TreeView.prototype.fillTree = function(pStepNum, recordset, pExpanded, byAllLevel, useSelfLevel, useCheckBox, skipIfNotFound){
	// functionname : [TreeView.fillTree]
	
	//hideAjaxBox();

	if (byAllLevel == undefined)   {byAllLevel = false;} 
	if (useSelfLevel == undefined) {useSelfLevel = false;} 
	if (useCheckBox == undefined)  {useCheckBox = false;}
	if (skipIfNotFound == undefined)  {skipIfNotFound = false;}
	
	this.fillAtOnce[pStepNum] = byAllLevel;
	
	var wNodes = this.nodes;
    var wNode  = null;

    while (!recordset.EOF){
        var wParentId = (recordset.fields.length < 3 ? "" : ("" + recordset.fields[2].value()).trim());
        
        // 1. 무조건 AllLevel이면 모든 레벨에서 찾는다.
        // 2. AllLevel이 아니면 Expanded인 경우 "상위스텝코드:키" 로 찾는다
        // 3. Expanded가 아니면 현재 포커싱된 노드에서 찾는다.
        
        if (byAllLevel){
        	var found = false;
            if (useSelfLevel){
                for (var i = this.nodes.arrNodes.length - 1; i >= 0; i--){
                    wNode = this.nodes.arrNodes[i];
                    if (wNode.key == wParentId){
                    	wParentId = wNode.id;
                    	found = true;
                    	break;
                    }
                }
            	if (!found) wParentId = "";
            } else {
                for (var i = this.nodes.arrNodes.length - 1; i >= 0; i--){
                    wNode = this.nodes.arrNodes[i];
                    if (wNode.key == wParentId && parseInt(wNode.id.split(":")[0]) != pStepNum){
                    	wParentId = wNode.id;
                    	found = true;
                    	break;
                    }
                }
            	if (!found) wParentId = "";
            }
        } else {
            // Expanded인 경우 레벨 1이 아니면 반드시 상위키가 있다
            // Expanded가 아닌 경우 반드시 상위키가 없으므로 레벨 1인지 아닌지 판단한다
            if (pStepNum == 1){
            	wParentId = "";
            } else {
            	if (pExpanded && wParentId.trim() != ""){
            		wParentId = (pStepNum - 1) + ":" + wParentId;
            	} else {
            		wParentId = this.workNode.tag;  //상위테그값
            	} 
            }
        }
        
        // Parent를 못찾으면 채우지 말라는 조건이 있는 경우 
        // 해당 레코드는 스킵된다. 단 첫레벨에는 적용되지 않는다
    	if (skipIfNotFound && wParentId.length == 0 && pStepNum > 1) {
    		 recordset.moveNext();
    		 continue; 
    	}

        // 상위 노드가 있고, 자기는 
        var targetNodeId = null; var relation = null;
        if (wParentId.length != 0) {
        	var pNode = this.getNode(wParentId);
        	if (pNode == null){
        		console.warn(wParentId + " not Found");
       		    recordset.moveNext();
        		continue;
        	}
            if (pNode.level != pStepNum) {
            	// 하위노드를 넣는 경우이고
                if (pNode.multiDepth) {
                	// 상위노드가 multiDepth이고,  
                	var pNode = this.getNode(wParentId);

                	// 부모노드의 첫 자식 노드를 찾는다
                    var eldestChild = this.nodes.getEldestNode(wParentId);

                	if (eldestChild == null) {
                    	// eldestChild가 없으면 부모 밑에 바로 붙이고
                    	targetNodeId = wParentId; 
                    	relation = tvwChild;
                    
                    } else if (eldestChild.level == pNode.level) {
                    	// eldestChild의 level이 부모의 레벨과 같으면 그 콘트롤의 앞에 
                    	targetNodeId = eldestChild.tag; 
                    	relation = tvwPrevious;
                    
                    } else { 
    	            	// 아니면 자기와 같은 레벨(pStepNum)의 맨마지막 노드 다음에 붙인다
    	                var eldestChild = this.nodes.getLastNodeOfChildLevel(wParentId);
    	            	targetNodeId = eldestChild.tag; 
    	            	relation = tvwNext;
                     }
                } else {
                	// 같은 레벨의 노드를 넣는 경우이고
                	targetNodeId = wParentId; 
                	relation = tvwChild;
                }
            } else {
            	targetNodeId = wParentId; 
            	relation = tvwChild;
            }
        } else {
        	targetNodeId = null;
            relation = null;
        }
        
        
    	var wChildId  = pStepNum + ":" + recordset.fields[0].value();
        var wText = recordset.fields[1].value();

        wNodes.add(targetNodeId, relation, wChildId, wText, "", "", useCheckBox, byAllLevel);
        
        
/*
        if (wParentId.length == 0) {
        	wNodes.add(null, null, wChildId, wText, "", "", useCheckBox, byAllLevel);
        } else {
        	wNodes.add(wParentId, tvwChild, wChildId, wText, "", "", useCheckBox, byAllLevel);
        }
 * */        
        
        recordset.moveNext();
    }
    recordset.close();
    
    if (this.workNode && this.workNode.children > 0){
    	this.workNode.expanded = pExpanded;
    	if (this.levelCount > 1) {
    		if (this.expandFirst) this.workNode.expanded = false;	// 트리펼침이 true 인 경우 노드의 확정여부를 false로 설정한다
    		this.workNode.state = "12"; // 하위노드의 디폴트 상태값이 열린(ㅏ)상태이므로 닫힌(ㄴ)상태로 변경하여 으픈폴더 이미지가 되도록 함 
    		this.workNode.setVisible();
    	}
    }
    
    return true;
};

TreeView.prototype.fillTreeByDataSet = function(datasetId, levelBindColId, textBindColId){
	// functionname : [TreeView.fillTreeByDataSet]
    var dataSet = dataSets[datasetId];
    var lastKeyOfLevel = [];
    
	for (var nRow=0; nRow < dataSet.records.length; nRow++){
		var record = dataSet.records[nRow];
		var level = parseInt(1 * record.values[levelBindColId]);
		this.fillAtOnce[level] = true;
		
		var text = record.values[textBindColId];
		
		lastKeyOfLevel[level] = text;
		var childId  = level + ":" + text;

		if (level == 1){
			wNodes.add(null, null, childId, text, "", "");
		} else {
			var parentId  = (level - 1) + ":" + lastKeyOfLevel[level - 1];
			wNodes.add(parentId, tvwChild, childId, text, "", "");
		}
	}
    
    if (this.workNode && this.workNode.children > 0){
    	this.workNode.expanded = pExpanded;
    }
    
    return true;
};

TreeView.prototype.fillTreeByJob = function(JSONObject, keyColInfos, textColInfos){
	// functionname : [TreeView.fillTreeByJob]
	// 가져오기 결과물로 채움
	
    var recordList = JSONObject.recordList;
    var lastKeyOfLevel = [];
    var levelCounts = keyColInfos.length;
    
	for (var nRow=0; nRow < recordList.length; nRow++){
		var record = recordList[nRow];
		
	    for (var i = 0; i < levelCounts; i++){
	    	var level = i + 1;
			this.fillAtOnce[level] = true;
			
	    	var key  = record[keyColInfos[i]];
	    	var text = record[textColInfos[i]];
	    	
	    	if (lastKeyOfLevel[level] != key){
	    		var childId   = level + ":" + key;
	    		
	    		if (level == 1){
	    			wNodes.add(null, null, childId, text, "", "");
	    		} else {
	    			var parentId  = (level - 1) + ":" + lastKeyOfLevel[level - 1];
	    			wNodes.add(parentId, tvwChild, childId, text, "", "");
	    		}
	    		
	    		// 상위가 바뀌면 하위키들은 무조건 바뀐것으로 처리한다
	    		for (var j = level + 1; j < levelCounts; j++){
	    			lastKeyOfLevel[j] = "QaWER$#@1MNBbV345635435";
	    		}
	    		
	    	}
	    }
	}
    
    if (this.workNode && this.workNode.children > 0){
    	this.workNode.expanded = pExpanded;
    }    
    
    return true;
};

/**
 * @description	미결
 * @return		{boolean}
 * @example		미결
 */
TreeView.prototype.nodeClick = function(){
	// functionname : [TreeView.nodeClick]

	if (event.button==2) return false;
    var em=(navigator.userAgent.indexOf('Firefox') >= 0 ? event.target : event.srcElement);
    var control = searchControl_TreeView(em);

    // 서버에서 작업이 진행중이면 클릭은 동작하지 않는다.
    if (inProcess) {
    	alert(getText("message_treeview_001", "Yet, requeted task is processing at data server!"));
    	return true;
    }

    //상위의 테그중 노드 클라스를 갖는 것에 키속성이 있다.
    var id = search_Node(em).key;
    var tag = search_Node(em).tag;
    
    // 먼저 클릭한 노드를 파악한다
    var wNode = control.nodes.item(tag);
    
    // 링크된 콘트롤들을 채운다
    control.fillLinkControl(wNode);
    
    // 보이기 옵션을 조정한다.
    wNode.setVisible();
    if (control.selectedItem == wNode) {
    	return true;
    }
    
    // 현재선택한 노드가 있으면 원래색깔로 돌린다
    if (control.selectedItem != null){
    	// control.selectedItem.textTagObject.className = "NodeNot";
    	control.selectedItem.textTagObject.className = "";
    }    
    
    // 선택한 노드의 속성을 바꾼다
    control.selectedItem = wNode;
	control.selectedItem.textTagObject.className = "NodeSel";
	
    
    // 노드 클릭이벤트를 일으킨다.
    if (control.hasNodeClickEvent) {
        var result = control.fncNodeClickEvent(wNode);
    }

    // 하위 노드 채우기를 수행한다.
    var checkEvent = false;
    
    if(wNode.children>0){
		wNode.setVisible();
	}
    
    var childLevel = wNode.level + 1;
	if (!control.fillAtOnce[childLevel] && (wNode.children == 0 || wNode.multiDepth) && !wNode.filled){    
        var childLevel = wNode.level + 1;
        var nodeKey = wNode.tag;

        if (control.hasfillTreeEvent[childLevel]) {
            var result = control.fncfillTreeEvent[childLevel](nodeKey);
            wNode.filled = true;
        }
    }
    // 보이기 옵션을 조정한다.
//    wNode.setVisible();
	
   	
    return true;
};

/**
 * @description	미결
 * @return		{boolean}
 * @example		미결
 */
TreeView.prototype.nodeDblClick = function(){
    // functionname : [TreeView.nodeClick]

    if (event.button==2) return false;

    var em=(navigator.userAgent.indexOf('Firefox') >= 0 ? event.target : event.srcElement);
    var control = searchControl_TreeView(em);

    //상위의 테그중 노드 클라스를 갖는 것에 키속성이 있다.
     var tag = search_Node(em).tag;
    
    // 먼저 클릭한 노드를 파악한다
    var wNode = control.nodes.item(tag);
    
    // 노드 클릭이벤트를 일으킨다.
    if (control.hasNodeDblClickEvent) {
        var result = control.fncNodeDblClickEvent(wNode);
    }
     
    return true;
};

/**
 * @description	미결
 * @param 		{object}	tag
 * @param 		{object}	startIndex
 * @return		{undefined}
 * @example		미결
 */
TreeView.prototype.open = function(tag, startIndex){
	// functionname : [TreeView.open]

	// 닫혀 있으면 연다 
	var wNodes = this.nodes.arrNodes;
    for (var i = startIndex; i < wNodes.length; i++){
        if (wNodes[i].parent != null && wNodes[i].parent.tag == tag){
            var wNode = wNodes[i];
            if (wNode.children > 0 && wNode.expanded) this.open(wNode.tag, i);
            wNode.tagObject.parentNode.style.display = "inline";
        }
    }
};

/**
 * @description	미결
 * @param 		{object}	tag
 * @param 		{object}	startIndex
 * @return		{undefined}
 * @example		미결
 */
TreeView.prototype.close = function(tag, startIndex){
	// functionname : [TreeView.close]

	// 열려 있으면 닫는다 
	var wNodes = this.nodes.arrNodes;
    for (var i = startIndex; i < wNodes.length; i++){
        if (wNodes[i].parent != null &&  wNodes[i].parent.tag == tag){
            var wNode = wNodes[i];
            if (wNode.children > 0) this.close(wNode.tag, i);
            wNode.tagObject.parentNode.style.display = "none";
        }
    }
};

/**
 * @description	미결
 * @param 		{object}	node
 * @return		{undefined}
 * @example		미결
 */
TreeView.prototype.fillLinkControl = function(node){
	// functionname : [TreeView.fillLinkControl]

	var arrLinkInfo = this.linkInfo.split(";");
	var parentTags = node.tag.split(";");
	var parentKey = parentTags[parentTags.length-2] != undefined? parentTags[parentTags.length-2].split(":")[1] : "";
	
	//var wArr = [node.key, node.text, parentKey];
	var wArr = [];
	
	var nodeKey = ""; var parentKey = ""; var levelOfParent = 0; var ndx = 0;
	for (var i = 0; i < parentTags.length; i++){
		nodeKey += parentTags[i];
		var tmpNode = this.nodes.item(nodeKey);
		
		// 상위레벨과 스텝번호가 같으면 하위것이 더 구체적인 것으로 판단하여
		// 덮어 쓴다
		if (levelOfParent == tmpNode.level) ndx = ndx - 1;
		
		wArr[ndx * 3 + 0] = tmpNode.key;		// 노드의 키
		wArr[ndx * 3 + 1] = tmpNode.text;     // 노드의 텍스트
		wArr[ndx * 3 + 2] = parentKey ;       // 노드의 상위키
		
		parentKey = tmpNode.key;
		levelOfParent = tmpNode.level;
		ndx++;
		nodeKey += ";"; 
	}
	
	for (var i=0;i < wArr.length && i < arrLinkInfo.length;i++){
		var controlName = arrLinkInfo[i].trim();
		if (controlName.length == 0) continue;
		controls[controlName].setValue(wArr[i]);
		
		
/*		if (i < wArr.length && wArr[i] != undefined){
	 	    controls[controlName].setValue(wArr[i]);
		} else {
			controls[controlName].setValue("");
		}
*/	}
};

/**
 * @description	미결
 * @return		{undefined}
 * @example		미결
 */
function Nodes() //constructor 
{
    this.arrNodes = [];
    this.parentControl = null;
    this.expanded = false;
};

/*
 *  노드 찾기  (아래 방법중 하나를 써도 상관없다 )
 *    0. SelectedItem이 있고 그것이 키이면 그것을 리턴한다.
 *    1. 어디서든 중복나지 않는 경우 첫데이터 리턴 
 *       wControl.SelectedItem = wControl.nodes.item("키3");
 *    2. 키번호뒤에 레벨번호(1부터시작)
 *       wControl.SelectedItem = wControl.nodes.item("키3", 2);
 *    3. 키속에 레벨번호를 선행, : 으로 구분
 *       wControl.SelectedItem = wControl.nodes.item("2:키3");
 *    4. 루트부터 상위키 모두를 포함 (키의 중복이 우려되는 경우)
 *       wControl.SelectedItem = wControl.nodes.item("1:키1;2:키3"); 
 *
 * */
/**
 * @description	미결
 * @param 		{number}	key
 * @param 		{number}	level
 * @return		{String}
 * @example		미결
 */
Nodes.prototype.item = function(key, level){
    // functionname : [Nodes.item]

    var selectedItem = this.parentControl.selectedItem;
    if (selectedItem != null){
    	if (key.indexOf(":") < 0){
    		if (level == undefined){     	// Case 1
    			if (selectedItem.key == key) return selectedItem;
    		} else {						// Case 2
    			if (selectedItem.level == level && selectedItem.key == key) return selectedItem;
    		}
    	} else {
    		if (key.indexOf(";") < 0){     // Case 3
    			if (selectedItem.id == key) return selectedItem;
    		} else {						// Case 4
    			if (selectedItem.tag == key) return selectedItem;
    		}	
    	}	
    }

    var node = null;
	if (key.indexOf(":") < 0){
		if (level == undefined){     	// Case 1
		    for (var i = this.arrNodes.length - 1; i >= 0; i--){
		        if (this.arrNodes[i].key == key){
		            node = this.arrNodes[i];
		            break;
		        }
		    }
		} else {						// Case 2
		    for (var i = this.arrNodes.length - 1; i >= 0; i--){
		    	var wNode = this.arrNodes[i];
		        if (wNode.level == level && wNode.key == key){
		            node = wNode;
		            break;
		        }
		    }
		}
	} else {
	
		if (key.indexOf(";") < 0){     // Case 3
		    for (var i = this.arrNodes.length - 1; i >= 0; i--){
		    	var wNode = this.arrNodes[i];
		        if (wNode.id == key){
		            node = wNode;
		            break;
		        }
		    }
			
		} else {						// Case 4
		    for (var i = this.arrNodes.length - 1; i >= 0; i--){
		    	var wNode = this.arrNodes[i];
		        if (wNode.tag == key){
		            node = wNode;
		            break;
		        }
		    }
		}	
	}
	
    return node;
};

/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
Nodes.prototype.count = function(){
    // functionname : [Nodes.count]

    return this.arrNodes.length;
};

/**
 * @description	미결
 * @param 		{object}	tag
 * @return		{String}
 * @example		미결
 */
Nodes.prototype.getIndexOf = function(tag){
    // functionname : [Nodes.getIndexOf]

    var wIndex = -1;
    var wNodes = this.arrNodes;
    for (var i = wNodes.length - 1; i >= 0; i--){
        if (wNodes[i].tag == tag){
            wIndex = i;
            break;
        }
    }
    return wIndex;
};

/**
 * @description	미결
 * @param 		{object}	tag
 * @return		{String}
 * @example		미결
 */
Nodes.prototype.getLastNodeOf = function(tag){
    // functionname : [Nodes.getLastNodeOf]

    var wNode = null;
    var wNodes = this.arrNodes;
    
    for (var i = wNodes.length - 1; i >= 0; i--){
        if (tag == "" && wNodes[i].parent == null){
            wNode = wNodes[i];
            break;
        	
        } else if (tag != "" && wNodes[i].parent != null &&  wNodes[i].parent.tag == tag){
            wNode = wNodes[i];
            break;
        }
    }
    if (tag == "" && wNode != null) wNode = this.getLastNodeOf(wNode.tag);
    if (tag != "" && wNode == null) wNode = this.item(tag);
    
    return wNode;
};

/**
 * @description	미결
 * @param 		{object}	tag
 * @return		{String}
 * @example		미결
 */
Nodes.prototype.getPrevNodeOf = function(tag){
    // functionname : [Nodes.getPrevNodeOf]

    var wNode = null;
    var wNodes = this.arrNodes;
    var wPosOfTag = -1; var wDepth = 1; var wParentTag = "";
    for (var i = wNodes.length - 1; i >= 0; i--){
    	var wwNode = wNodes[i];
        if (wwNode.tag == tag){
        	if (wwNode.parent) wParentTag = wwNode.parent.tag;
        	
        	wDepth = wwNode.depth;
        	wPosOfTag = i;
            break;
        }
    }
    
    if (wPosOfTag >= 0){
        for (var i = wPosOfTag - 1; i >= 0; i--){
        	var wwNode = wNodes[i];
            if (wDepth == 1 && wwNode.parent == null){
                wNode = wwNode;
                break;
            } else if (wDepth > 1 && wwNode.parent && wwNode.parent.tag == wParentTag){
                wNode = wwNode;
                break;
            }
        }
    }
    
    
    return wNode;
};


/* *****************************************************************************
  All 타입 Parent의 자식노드중 제일 먼저 나오는 노드를 가져온다 
 * ****************************************************************************/
/**
 * @description	미결
 * @param 		{String}	id
 * @return		{String}
 * @example		미결
 */

Nodes.prototype.getEldestNode = function(id){
    // functionname : [Nodes.getLastNodeOf]

    var wNode = null;
    var wNodes = this.arrNodes;
        
    // 만들어진 순서대로 들어가 있다
    // 중간이 끼었어도 맨앞에 들어가 있을 것이다.

    // 먼저 자식레벨의 노드 가 있는 지 확인한다
    for (var i = 0; i < wNodes.length; i++){
        if (wNodes[i].parent && wNodes[i].parent.id == id && wNodes[i].parent.level != wNodes[i].level){
            wNode = wNodes[i];
            break;
        }
    }
    
    // 자식 레벨 노드 가 없는 경우 같은 레벨의 테그를 뒤진다
    if (wNode == null){
        for (var i = 0; i < wNodes.length; i++){
            if (wNodes[i].parent && wNodes[i].parent.id == id && wNodes[i].parent.level == wNodes[i].level){
                wNode = wNodes[i];
                break;
            }
        }
    }
    
    return wNode;
};

/* *****************************************************************************
  All 타입 Parent의 자식노드중 하위노드이면서 제일 나중에 있는 노드를 가져온다 
 * ****************************************************************************/
/**
 * @description	미결
 * @param 		{String}	id
 * @return		{String}
 * @example		미결
 */
Nodes.prototype.getLastNodeOfChildLevel = function(id){
    // functionname : [Nodes.getLastNodeOfChildLevel]
    
    if (this.item(id).children == 0) {
    	return null;
    }
    var wNode = null;
    var wNodes = this.arrNodes;
    
    // 먼저 자식레벨의 노드 가 있는 지 확인한다
    for (var i = 0; i < wNodes.length; i++){
        if (wNodes[i].parent && wNodes[i].parent.id == id){
            wNode = wNodes[i];
        }
    }
    if (wNode != null && wNode.children > 0) {
    	wNode = this.getLastNodeOfChildLevel(wNode.id);
    }
    
    return wNode;
};

/**
 * @description	미결
 * @param		{object}	parentTag
 * @param 		{object}	tag
 * @return		{String}
 * @example		미결
 */
Nodes.prototype.isLastNode = function(parentTag, tag){
    // functionname : [Nodes.isLastNode]

    var wIsLastNode = true;

    var wPosOfTag = -1;
    var wDepth = 1;

    var wNodes = this.arrNodes;
    for (var i = 0; i < wNodes.length; i++){

        if (wNodes[i].tag == tag){
        	wDepth = wNodes[i].depth;
            wPosOfTag = i;
            break;
        }
    }

    if (wPosOfTag >= 0){
        for (var i = wPosOfTag + 1; i < wNodes.length; i++){
            if (wDepth == 1 && wNodes[i].parent == null){
                wIsLastNode = false;
                break;
            } else if (wDepth > 1  && wNodes[i].parent != null &&  wNodes[i].parent.tag == parentTag){
                wIsLastNode = false;
                break;
            }
        }
    }
    
    return wIsLastNode;
};

/**
 * @description	미결
 * @param		{boolean}	relativeId
 * @param 		{boolean}	relationship
 * @param 		{boolean}	id
 * @param 		{boolean}	text
 * @param 		{boolean}	imagePath
 * @param 		{boolean}	expandedImage
 * @param 		{boolean}	useCheckBox
 * @param 		{boolean}	byAllLevel
 * @return		{String}
 * @example		미결
 */
Nodes.prototype.add = function(relativeId, relationship, id, text, imagePath, expandedImage, useCheckBox, byAllLevel){
    // functionname : [Nodes.add]

	if (useCheckBox == undefined)  {useCheckBox = false;} 

    var wSpan = null;
    var wLink = null;
    var tag = "";
    // 오류의 사전 체크
    if (relativeId != null && relativeId.length > 0){
        if (this.item(relativeId) == null){
            //alert(id + " 키를 추가할 " + relativeId + " 키는 유효한 키가 아닙니다.");
            return;
        }
    }
    
    // 노드의 속성을 부여한다 
    var wParentNode = null;
    var  wNode = new Node();
    
    wNode.parentControl = this.parentControl;
    wNode.parent = this;
    
    var firstOpenNodeLevel = wNode.parentControl.firstOpenNodeLevel;
    
    wNode.level = parseInt(id.split(":")[0]);
    wNode.key   = id.split(":")[1];
    wNode.id    = id;
    wNode.text  = text;
    wNode.image = imagePath;
    wNode.expandedImage = expandedImage;
    wNode.multiDepth = (byAllLevel ? true : false);
    
    wNode.parent = null;
    if (relativeId == null){
    	// null로 그냥 둔다
    } else if (relationship == tvwChild){
        if (relativeId.length > 0){
            wNode.parent = this.item(relativeId);
        }
    } else {
        wNode.parent = this.item(relativeId).parent;
    }
    var wParentNode = wNode.parent;
    if (wNode.parent){
        wNode.depth = wParentNode.depth + 1;
        tag = wNode.tag   = wParentNode.tag + ";" + id;
    } else {
        wNode.depth = 1;
        tag = wNode.tag   = id;
    }
    
    // HTML을 추가한다
    if (wNode.parent == null){
        // 먼저 노드 객체에 더하고
        this.arrNodes.push(wNode); 
        
        this.arrNodes[this.arrNodes.length - 1] = wNode;

        // HTML을 추가한다
        wSpan = this.parentControl.tagObject.appendChild(document.createElement("SPAN")); 
        
        if (this.arrNodes.length > 1) {
            if (wSpan.insertAdjacentElement){
            	wSpan.insertAdjacentElement('afterBegin', document.createElement("br"));
     		}
     		else if (wSpan.appendChild) {
     			insertAdjacentElement('afterBegin' ,wSpan, document.createElement("br"));
     		}
        }
        
        wLink = document.createElement("SPAN");
        wLink.key = id;
        wLink.tag = wNode.tag;
        wLink.className = "Node";
        var checkString = (useCheckBox ? "<span class='TreeCheck' onclick='treeCheck_onClick(event);'>&#9744;</span>" : "");

        var imgSrc = (this.parentControl.didIconDefined[wNode.level] ? this.parentControl.levelIcons[wNode.level].src : 
                      ( wNode.level == this.parentControl.levelCount ? icons[PAGE_ICON].src : icons[FOLDER_NORMAL].src));

        wLink.innerHTML = "<img src='" + imgSrc + "' align='absbottom' alt='' />" + checkString + "<SPAN>" + text + "</SPAN>" ;
        
        wLink.onclick = this.parentControl.nodeClick;
        wLink.ondblclick = this.parentControl.nodeDblClick;

        wNode.tagObject = wSpan.appendChild(wLink);
        
        wNode.checked = false;
        wNode.useCheckBox = useCheckBox;
        
        wNode.lineTagObject = null;
        wNode.imageTagObject = wNode.tagObject.childNodes[0];
        if (useCheckBox){
            wNode.checkTagObject = wNode.tagObject.childNodes[1];
            wNode.textTagObject = wNode.tagObject.childNodes[2];
        } else {
            wNode.checkTagObject = null;
            wNode.textTagObject = wNode.tagObject.childNodes[1];
        }
        
    } else {
        // tvwFirst    : 0 : relative에서 명명된 같은 단계에 있는 노드의 앞에 위치한다.
        // tvwLast     : 1 : relative에서 명명된 같은 단계에 있는 노드의 뒤에 위치한다.
        // tvwNext     : 2 : relative에서 명명된 노드의 뒤에 위치한다.                 
        // tvwPrevious : 3 : relative에서 명명된 노드의 앞에 위치한다.                 
        // tvwChild    : 4 : relative에서 명명된 노드의 하위노드가 된다.               
    	
        var wNodeOfInsertionPos = null;
        var wAppendPoint = 0;
        // 자기 아이콘의 추가
        if (relationship == tvwFirst){
            wNodeOfInsertionPos = wParentNode;
            wAppendPoint = this.getIndexOf(wParentNode.tag);
        } else if (relationship == tvwLast){
            wNodeOfInsertionPos = this.getLastNodeOf(wParentNode.tag);
            if (wNodeOfInsertionPos == null){
                wAppendPoint = this.getIndexOf(wParentNode.tag);
            } else {
                wAppendPoint = this.getIndexOf(wNodeOfInsertionPos.tag);
            }
        } else if (relationship == tvwNext){
            wAppendPoint = this.getIndexOf(relativeId);
        } else if (relationship == tvwPrevious){
            wNodeOfInsertionPos = this.getPrevNodeOf(this.item(relativeId).tag);
            if (wNodeOfInsertionPos == null){
                wAppendPoint = this.getIndexOf(wParentNode.tag);
            } else {
                wAppendPoint = this.getIndexOf(wNodeOfInsertionPos.tag) - 1;
            }
        } else if (relationship == tvwChild){
        	if (relativeId == ""){
                wNodeOfInsertionPos = this.getLastNodeOf("");
        	} else {
                wNodeOfInsertionPos = this.getLastNodeOf(this.item(relativeId).tag);
                if (wNodeOfInsertionPos == null){
                    wAppendPoint = this.getIndexOf(wParentNode.tag);
                } else {
                	var wNodeOfInsertionPos1 = this.getLastNodeOfChildLevel(wNodeOfInsertionPos.id);
                    if (wNodeOfInsertionPos1 == null){
                        wAppendPoint = this.getIndexOf(wNodeOfInsertionPos.tag);
                    } else {
                        wAppendPoint = this.getIndexOf(wNodeOfInsertionPos1.tag);
                    }
                }
        	}
        }
        
        // beforeBegin	엘레멘트 oElem을 개체의 바로 전에 삽입한다.
        // afterBegin	엘레멘트 oElem을 개체가 시작되고 모든 다른 내용들 전에 삽입한다.
        // beforeEnd	엘레멘트 oElem을 개체가 종료되기 전에 모든 다른 내용들 다음에 삽입한다.
        // afterEnd	    엘레멘트 oElem을 개체가 종료된 바로 다음에 삽입한다.

        // 노드의 위치를 셋팅
            
        //  먼저 HTML을 추가한다
        wSpan = document.createElement("SPAN");
        var critTag = this.arrNodes[wAppendPoint].tagObject.parentNode;
        
        if (critTag.insertAdjacentElement){
        	critTag.insertAdjacentElement('afterEnd', wSpan);
 		} else if (critTag.appendChild) {
 			insertAdjacentElement('afterEnd' ,critTag, wSpan);
 		}

        // 노드 객체에 더하고
        if (wAppendPoint == this.arrNodes.length - 1){
        	this.arrNodes.push(wNode); 
        } else {
        	this.arrNodes.splice(wAppendPoint + 1, 0, wNode);
        }
        
        // 노드의 위치를 참조로 한 변수 셋팅
        if (wParentNode == null){
            wNode.isLast = this.isLastNode("", tag);
        } else {
            wNode.isLast = this.isLastNode(wParentNode.tag, tag);
        }
        
        wNode.state = (wNode.isLast ? "02" : "01");
        
        if (wSpan.insertAdjacentElement){
        	wSpan.insertAdjacentElement("afterBegin", document.createElement("br"));
 		} else if (wSpan.appendChild) {
 			insertAdjacentElement('afterBegin' ,wSpan, document.createElement("br"));
 		}
        
        // 노드레벨의 상위노드별로 
        // 각 레벨의 노드이후에 노드가 있으면 '|' 를 넣고 마지막 노드면 ' '
        var newImg = null;
        var wArrKeys = wNode.tag.split(";");
        for (wDepth= 1 ;wDepth < wNode.depth; wDepth++){ 
            var wTempNode = this.item(wArrKeys[wDepth - 1]);
            if (wTempNode.isLast){
                newImg = document.createElement("img");
                newImg.setAttribute("src", icons[EMPTY_ICON].src);
                newImg.setAttribute("align", 'absbottom');
                newImg.setAttribute("alt", '');
            } else {
                newImg = document.createElement("img");
                newImg.setAttribute("src", icons[LINE_BLANK].src);
                newImg.setAttribute("align", 'absbottom');
                newImg.setAttribute("alt", '');
            }
            wSpan.appendChild(newImg);
        }
        wArrKeys = null;
        
        // 자기레벨 아이콘의 처리 
         wLink = document.createElement("SPAN");
        wLink.key = id;
        wLink.tag = wNode.tag;
        wLink.className = "Node";
        wNode.tagObject = wSpan.appendChild(wLink);
        wLink.onclick = this.parentControl.nodeClick;
        wLink.ondblclick = this.parentControl.nodeDblClick;

        if (wNode.isLast){  
            newImg = document.createElement("img");
            newImg.setAttribute("src", icons[JOIN_BOTTOM].src);
            newImg.setAttribute("align", 'absbottom');
            newImg.setAttribute("alt", '');
        } else {  
            newImg = document.createElement("img");
            newImg.setAttribute("src", icons[JOIN_NORMAL].src);
            newImg.setAttribute("align", 'absbottom');
            newImg.setAttribute("alt", '');
        }
        wLink.appendChild(newImg);

        var imgSrc = (this.parentControl.didIconDefined[wNode.level] ? this.parentControl.levelIcons[wNode.level].src : 
                      ( wNode.level == this.parentControl.levelCount ? icons[PAGE_ICON].src : icons[FOLDER_NORMAL].src));

        newImg = document.createElement("img");
        newImg.setAttribute("src", imgSrc);
        newImg.setAttribute("align", 'absbottom');
        newImg.setAttribute("alt", '');
        
        wLink.appendChild(newImg); 
        
        if (useCheckBox){
            var wCheckSpan = document.createElement("SPAN");
            wLink.appendChild(wCheckSpan);
            wCheckSpan.className="TreeCheck";
            wCheckSpan.innerHTML = "&#9744;";
            setEventHandler(wCheckSpan, "click", treeCheck_onClick);
        }
        
        var wCaptionSpan = document.createElement("SPAN");
        wLink.appendChild(wCaptionSpan);
        wCaptionSpan.innerHTML = text;
        
        
        wNode.checked = false;
        wNode.useCheckBox = useCheckBox;
        
        wNode.lineTagObject = wNode.tagObject.childNodes[0];
        wNode.imageTagObject = wNode.tagObject.childNodes[1];
        if (useCheckBox){
            wNode.checkTagObject = wNode.tagObject.childNodes[2];
            wNode.textTagObject = wNode.tagObject.childNodes[3];
        } else {
            wNode.checkTagObject = null;
            wNode.textTagObject = wNode.tagObject.childNodes[2];
        }
        
        // 부모노드의 아이콘변경 : ㄴ-> +ㄴ ㅏ -> +ㅏ 페이지 이미콘 -> 폴더 
        wParentNode.children++;
        var imgSrc_open   = (this.parentControl.didIconDefined[wNode.level -1] ? this.parentControl.levelIcons[wNode.level - 1].src : icons[FOLDER_OPEN].src);
        var imgSrc_normal = (this.parentControl.didIconDefined[wNode.level - 1] ? this.parentControl.levelIcons[wNode.level - 1].src : icons[FOLDER_NORMAL].src);
        if (wParentNode.depth == 1){
            var wPageImg = wParentNode.imageTagObject;
            if (wParentNode.state == "01") {    // "ㅏ"
                wParentNode.state = "21";
//                if(this.expandFirst || firstOpenNodeLevel >= wNode.depth){
//               	if(this.parentControl.expandFirst || firstOpenNodeLevel >= wNode.depth){
               	if(this.expanded || firstOpenNodeLevel >= wNode.depth){
                	wPageImg.src = imgSrc_open;
                }else{
                	wPageImg.src = imgSrc_normal;
                }
            } else if (wParentNode.state == "02") {    // "ㄴ"
                wParentNode.state = "22";
//                if(this.expandFirst || firstOpenNodeLevel >= wNode.depth){
//               	if(this.parentControl.expandFirst || firstOpenNodeLevel >= wNode.depth){
               	if(this.expanded || firstOpenNodeLevel >= wNode.depth){
                	wPageImg.src = imgSrc_open;
                }else{
                	wPageImg.src = imgSrc_normal;
                }
            }
        } else {
            var wLineImg = wParentNode.lineTagObject;
            var wPageImg = wParentNode.imageTagObject;
            if (wParentNode.state == "01") {    // "ㅏ"
                wParentNode.state = "21";
//                if(this.expandFirst || firstOpenNodeLevel >= wNode.depth){
//               	if(this.parentControl.expandFirst || firstOpenNodeLevel >= wNode.depth){
              		if(this.expanded || firstOpenNodeLevel >= wNode.depth){
                	wLineImg.src = icons[MINUS_NORMAL].src;  
                    wPageImg.src = imgSrc_open;
                }else{
	                wLineImg.src = icons[PLUS_NORMAL].src;  
	                wPageImg.src = imgSrc_normal;
                }
            
            } else if (wParentNode.state == "02") {    // "ㄴ"
                wParentNode.state = "12";
//                if(this.expandFirst || firstOpenNodeLevel >= wNode.depth){
//               	if(this.parentControl.expandFirst || firstOpenNodeLevel >= wNode.depth){
               	if(this.expanded || firstOpenNodeLevel >= wNode.depth){
                	wLineImg.src = icons[MINUS_BOTTOM].src;  
                    wPageImg.src = imgSrc_open;
                }else{
	                wLineImg.src = icons[PLUS_BOTTOM].src;  
	                wPageImg.src = imgSrc_normal;
                }
            }
        }
        
        // 바로 자기위 아이콘의 변경 : ㄴ자이면 ㅏ자로 변경한다
        // 차일드가 있으면 -ㄴ+ㄴ을 -ㅏ +ㅏ 로변경한다
        
        var prevNode = this.getPrevNodeOf(tag);
        if (prevNode != null && wNode.depth > 1){
            prevNode.isLast = false;
            var wLineImg = prevNode.lineTagObject;
            if (prevNode.state == "02") {    // "ㅏ"
                prevNode.state = "01";
                wLineImg.src = icons[JOIN_NORMAL].src;
            
            } else if (wParentNode.state == "12") {    // "ㅏ"
                prevNode.state = "11";
//                if(this.expandFirst || firstOpenNodeLevel >= wNode.depth){
//               	if(this.parentControl.expandFirst || firstOpenNodeLevel >= wNode.depth){
               	if(this.expanded || firstOpenNodeLevel >= wNode.depth){
                	wLineImg.src = icons[MINUS_NORMAL].src;
                }else{
                	wLineImg.src = icons[PLUS_NORMAL].src;
                }
            } else if (wParentNode.state == "22") {    // "ㅏ"
                prevNode.state = "21";
//                if(this.expandFirst || firstOpenNodeLevel >= wNode.depth){
//                if(this.parentControl.expandFirst || firstOpenNodeLevel >= wNode.depth){
                if(this.expanded || firstOpenNodeLevel >= wNode.depth){
                	wLineImg.src = icons[MINUS_NORMAL].src;
                }else{
                	wLineImg.src = icons[PLUS_NORMAL].src;
                }
            }
        }
        
    }
    if (wNode.parent != null && wNode.parent.level != wNode.level ) {
    	wNode.parent.filled = true;
    }
    
    
    // byAllLevel로 채우는 경우 첫줄이 아니면 숨긴다
    if (wNode.multiDepth && wNode.depth > 1){
        wNode.expanded = false;
        // 최초 어디까지 펼치는지 판단
        if(!this.expandFirst && wNode.depth>firstOpenNodeLevel){
        	wNode.tagObject.parentNode.style.display = "none";
        }
    }
    
    return wNode;
};

/**
 * @description	미결
 * @return		{undefined}
 * @example		미결
 */
Nodes.prototype.clear = function(){
    // functionname : [Nodes.clear]

	while(this.arrNodes.length > 0) this.arrNodes.pop();

    this.arrNodes = [];
    this.parentControl.tagObject.innerHTML = "";
    
    this.parentControl.expandFirst = false;
    this.parentControl.selectedItem = null;
    //this.parentControl.levelCount = 0;
    this.parentControl.workNode = null;
    
};

/**
 * @description	미결
 * @param		{object}	tag
 * @return		{undefined}
 * @example		미결
 */
Nodes.prototype.remove = function(tag){
    // functionname : [Nodes.remove]

	 var wIndex = this.getIndexOf(tag);
	 var wNode = this.arrNodes[wIndex];
	 
	 // 부모노드의 아이콘변경 : +ㄴ-> ㄴ, +ㅏ -> ㅏ, 폴더-> 페이지
	 if (wNode.children > 0){
	 	alert(getText("message_treeview_002", "먼저 {0}의 하위 노드를 제거하여야만 삭제할 수 있습니다", [wNode.text]));
	 	return;
	 } else if(wNode.parent != null){
	 	var wParentNode = wNode.parent;
	     wParentNode.children--;




        var imgSrc = (this.parentControl.didIconDefined[wNode.level] ? this.parentControl.levelIcons[wNode.level].src : 
                      ( wNode.level == this.parentControl.levelCount ? icons[PAGE_ICON].src : icons[FOLDER_NORMAL].src));

	 	if (wParentNode.depth == 1 && wParentNode.children == 1){
	         var wPageImg = wParentNode.imageTagObject;
	         if (wParentNode.state == "11" || wParentNode.state == "21"){ // "ㅏ"
	             wParentNode.state = "01";
	             wPageImg.src =imgSrc; 
	         }
	     } else if (wParentNode.depth > 1 && wParentNode.children == 1){
	         var wLineImg = wParentNode.lineTagObject;
	         var wPageImg = wParentNode.imageTagObject;
	         if (wParentNode.state == "11" || wParentNode.state == "21") {    // "ㅏ"
	             wParentNode.state = "01";
	             wLineImg.src = icons[JOIN_NORMAL].src;
	             wPageImg.src = imgSrc;
	         
	         } else if (wParentNode.state == "12" || wParentNode.state == "22") {    // "ㄴ"
	             wParentNode.state = "02";
	             wLineImg.src = icons[JOIN_BOTTOM].src;
	             wPageImg.src = imgSrc;
	         }
	     }
	     
	 }

	 // 바로 자기위 아이콘의 변경 : ㄴ자이면 ㅏ자로 변경한다
	 // 차일드가 있으면  -ㅏ +ㅏ을 -ㄴ+ㄴ로변경한다
	 if (wNode.isLast && wNode.depth > 1){
	     var prevNode = this.getPrevNodeOf(tag);
	     if (prevNode != null){
	         prevNode.isLast = true;
	 
	         var wLineImg = prevNode.lineTagObject;
	         if (prevNode.state == "01") {    // "ㅏ"
	             prevNode.state = "02";
	             wLineImg.src = icons[JOIN_BOTTOM].src;
	         
	         } else if (wParentNode.state == "11") {    // "+ㅏ"
	             prevNode.state = "12";
	             wLineImg.src = icons[PLUS_BOTTOM].src;
	             
	         } else if (wParentNode.state == "21") {    // "-ㅏ"
	             prevNode.state = "22";
	             wLineImg.src = icons[MINUS_BOTTOM].src;
	         }
	     }
	 }
	
	
	 // 해당 노드의 삭제
	 removeTag(wNode.tagObject.parentNode);
	 this.arrNodes.splice(wIndex,1);

};

/**
 * @description	미결
 * @return		{undefined}
 * @example		미결
 */
function Node() //constructor 
{
    // 변수 선언부
    this.tagObject = null;
    this.parentControl = null;
    this.parent = null;
    this.children = 0;
    this.filled = false;
    this.isLast = true;
    this.expanded = true;
    this.expandedImage = "";
    this.image = "";
    this.state = "01";
    
    this.checked = false;
    this.useCheckBox = false;
    this.lineTagObject = null;
    this.imageTagObject = null;
    this.checkTagObject = null;
    this.textTagObject = null;
    
    this.depth  = 1;   // ex: 2  트리의 깊이
    this.level = 1;    // ex: 2  트리의 스텝
    this.key = "";     // ex: "30493"
    this.text = "";    // ex: "홍길동"
    this.id = "";      // ex: "2:30493" <-- 2레벨 데이터이다
    this.tag = "";     // ex: "1:9998;2:30493"
    this.multiDepth = false;
    
    
 };

 /**
  * @description	미결
  * @param		{String}	pText
  * @return		{undefined}
  * @example		미결
  */
Node.prototype.setText = function(pText){
    // functionname : [Node.setText]

    this.textTagObject.innerText = pText;
};

/**
 * @description	미결
 * @param		{object}	depth
 * @return		{String}
 * @example		미결
 */
Node.prototype.getParentStepKey = function(depth){
    // functionname : [Node.getParentStepKey]

	if (depth < 1 || depth > this.depth) return null;
	
	var node = this;
	
	for (var depthNum = this.depth; depthNum > depth; depthNum--){
		node = node.parent;
	}
	
	return node.key;
};

/**
 * @description	미결
 * @param		{object}	depth
 * @return		{String}
 * @example		미결
 */
Node.prototype.getParentStepText = function(depth){
    // functionname : [Node.getParentStepKey]

//	if (depth < 1 || depth > this.depth) return null;
	
	var node = this;
	
//	for (var depthNum = this.depth; depthNum > depth + 1; depthNum--){
//		node = node.parent;
//	}
	
	return node.text;
};

/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
Node.prototype.getFullPath = function(){
    // functionname : [Node.getFullPath]

    var wFullPath = "";
    
    var wNode = this;
    for (wDepth = this.depth; wDepth > 0 ;wDepth--){
        if (wNode == null) break;
        if (wFullPath.length == 0) {
            wFullPath = wNode.key;
        } else {
            wFullPath = wNode.key + "/" + wFullPath;
        }
        wNode = wNode.parent;
    }
    wNode=null;
    
    return wFullPath;
};

/**
 * @description	미결
 * @return		{undefined}
 * @example		미결
 */
Node.prototype.setVisible = function(){
    // functionname : [Node.setVisible]

    this.expanded = !this.expanded;
    var imgSrc_normal = (this.parentControl.didIconDefined[this.level] ? this.parentControl.levelIcons[this.level].src : icons[FOLDER_NORMAL].src);
    var imgSrc_open   = (this.parentControl.didIconDefined[this.level] ? this.parentControl.levelIcons[this.level].src : icons[FOLDER_OPEN].src);
    if (this.children > 0) {
     	
        var wPageImg = null;
        var wLineImg = null;
        if (this.depth == 1) {
            wPageImg = this.imageTagObject;
        } else {
            wLineImg = this.lineTagObject;
            wPageImg = this.imageTagObject;
        } 
        
        if (this.expanded)  {
            //  - -> +, 닫힌 폴더 -> 열린 폴더 
            if (this.state == "11") {    // "+ㅏ" -> "-ㅏ"
                this.state = "21";
                if (this.depth > 1) 
                    wLineImg.src = icons[MINUS_NORMAL].src;
                wPageImg.src = imgSrc_open;
                
            } else if (this.state == "12") {    // "+ㄴ" -> "-ㄴ"
                this.state = "22";
                if (this.depth > 1) 
                    wLineImg.src = icons[MINUS_BOTTOM].src;
                wPageImg.src = imgSrc_open;
            }
            
            // 하위 개체 보이기 
       	    this.parentControl.open(this.tag, 0);
       	    
       	} else { 
            //  + -> -, 열린 폴더 -> 닫힌 폴더
            if (this.state == "21") {    // "-ㅏ" -> "+ㅏ"
                this.state = "11";
                if (this.depth > 1) 
                    wLineImg.src = icons[PLUS_NORMAL].src;
                wPageImg.src = imgSrc_normal;
                
            } else if (this.state == "22") {    // "-ㄴ" -> "+ㄴ"
                this.state = "12";
                if (this.depth > 1) 
                    wLineImg.src = icons[PLUS_BOTTOM].src;
                wPageImg.src = imgSrc_normal;
            }
            
            // 하위개체 숨기기  
       		this.parentControl.close(this.tag, 0);
        }
    }
};


/**
 * @description	미결
 * @param		{number}	checked
 * @return		{undefined}
 * @example		미결
 */
Node.prototype.setCheckValue = function(checked){
    // functionname : [Node.setCheckValue]
	
	if (checked) {
		this.checkTagObject.innerHTML = "&#9745;"; 
	} else {
		this.checkTagObject.innerHTML = "&#9744;";
	}
	
	this.checked = checked;
	
	//자식노드의 체크를 일괄 조정
	if (this.children > 0){
	    for (var i=this.parentControl.nodes.arrNodes.length - 1; i >= 0; i--){
	       var node2 = this.parentControl.nodes.arrNodes[i];
	       if (node2.parent == this){
        	   if (checked != node2.checked)
	    	       node2.setCheckValue(this.checked);
	       }
	   }
	}
	
	var checkEvent = false;
	try {
    	if (eval(this.parentControl.controlId + "_oncheckclick")) checkEvent = true;
    } catch(e){}
    
    if (checkEvent){
        eval(this.parentControl.controlId + "_oncheckclick(this);");
    }
		
	
};

/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
Node.prototype.getTextValueInfo = function(){
	
	var wArrKey = new Array(this.parentControl.levelCount);
	var wArrTxt = new Array(this.parentControl.levelCount);
	var wNode = this;
	
	var lastLevelNum = 0;
	while (wNode != null){
		if (wNode.level != lastLevelNum){
			wArrKey[wNode.level - 1] = wNode.key;  wArrTxt[wNode.level - 1] = wNode.text;
			lastLevelNum = wNode.level 
		}
		wNode = wNode.parent;
	}
	
	var jsonStr = "{\"nodeArray\":[";
	for (var i=0; i < wArrKey.length; i++){
		jsonStr += "{\"key\":\"" + wArrKey[i] + "\",\"text\":\"" + wArrTxt[i] + "\"}";
		jsonStr += (i < wArrKey.length - 1 ? "," : "");
	}
	jsonStr += "]}";
	
	var jObject = eval("(" + jsonStr + ")");
	
	return jObject;
};

/**
 * @description	미결
 * @param		{object}	tag
 * @return		{undefined}
 * @example		미결
 */
TreeView.prototype.nodeClear = function(tag){
	// functionname : [TreeView.nodeclear]

    var node = this.nodes.item(tag);
    if (node.children = 0) return;
    
    for (var i=this.nodes.arrNodes.length - 1; i >= 0; i--){
         var node2 = this.nodes.arrNodes[i];
        if (node2.parent == node){
            if (node2.children > 0) {
	        	this.nodeClear(node2.tag);
            }
            this.nodes.remove(node2.tag);
        }
    }
};

/**
 * @description	미결
 * @param		{object}	tag
 * @return		{undefined}
 * @example		미결
 */
TreeView.prototype.refreshNode = function(tag){
	// functionname : [TreeView.refreshNode]


    this.nodeClear(tag);

    var node = this.nodes.item(tag);
    node.children = 0;
    if (this.selectedItem != null){
    	this.selectedItem.textTagObject.className = "";
        this.selectedItem = null;
    }

    var childLevel = node.level + 1;
    var nodeKey = node.tag;

    if (this.hasfillTreeEvent[childLevel]) {
        var result = this.fncfillTreeEvent[childLevel](nodeKey);
    }
};

/**
 * @description	미결
 * @return		{undefined}
 * @example		미결
 */
TreeView.prototype.reset = function(){
	// functionname : [TreeView.reset]
	while (this.nodes.count() > 0){
		var tag = this.nodes.arrNodes[0].tag;
		this.nodeClear(tag);
		this.nodes.remove(tag);
	}

    var childLevel = 1;
    var nodeKey = "";

    if (this.hasfillTreeEvent[childLevel]) {
        var result = this.fncfillTreeEvent[childLevel](nodeKey);
    }    
};

/**
 * @description	미결
 * @return		{undefined}
 * @example		미결
 */
TreeView.prototype.focus = function(){
	this.tagObject.focus();
};

function treeCheck_onClick(e){
    e = window.event || e;
	var em = getSrcElement(e);
	var control = searchControl_TreeView(em);
	
	var wNode = search_Node(em);
	
	wNode.checked = !wNode.checked;
    if (wNode.checked) {
    	wNode.checkTagObject.innerHTML = "&#9745;"; 
    } else {
    	wNode.checkTagObject.innerHTML = "&#9744;";
    }
	
    wNode.checked != wNode.checked;
    
	var checkEvent = false;
	try {
    	if (eval(wNode.parentControl.controlId + "_oncheckclick")) checkEvent = true;
    } catch(e){}
    
    if (checkEvent){
        eval(wNode.parentControl.controlId + "_oncheckclick(wNode);");
    }
    
    //자식노드의 체크를 일괄 조정
    if (wNode.children > 0){
        for (var i=control.nodes.arrNodes.length - 1; i >= 0; i--){
           var node2 = control.nodes.arrNodes[i];
           if (node2.parent == wNode){
        	   if (wNode.checked != node2.checked)
        	       node2.setCheckValue(wNode.checked);
           }
       }
    }
    
    stopEvent(e);
    
    return;
};

/**
 * 트리에서 인수로 받은 텍스트 값을 겁색하고 포커스를 이동하고 클릭이벤트를 발생시킨다.
 * 현재선택된 노드의 뒤로부터 겁색하고 없으면 앞에서 부터 검색한다. 
 * 
 * find(text)
 * find(text, level)
 * 
 * @param  text            검색할 텍스트의 값  
 * @param  level           검색할 레벨 , 상위 또는 하위레벨의 노드에 같은 텍스트 값이 있는 경우 사용
 * @return                 검색된 노드
*/

/**
 * @description	미결
 * @param		text
 * @param		level
 * @return		{String}
 * @example		미결
 */
TreeView.prototype.find =  function(text, level){
    // functionname : [TreeView.getIndexOf]
    
    var checkLevel = (typeof level != "undefined");

    var currentIndex = (this.selectedItem ? this.nodes.getIndexOf(this.selectedItem.tag) : -1);
    var wNodes = this.nodes.arrNodes;
    var wNode = null;

    // 현재 선택된 노드위치로 부터 뒤로 찾고 없으면 앞에서 부터 찾는다 
    for (var i = currentIndex + 1; i < wNodes.length; i++){
//        if (wNodes[i].text !== text) continue;
    	if (wNodes[i].text.substr(0,text.length) !== text) continue;
        if (checkLevel && level !== wNodes[i].level) continue;

        wNode = wNodes[i]
        break;
    }

    if (wNode == null){
        for (var i = 0; i < currentIndex; i++){
//            if (wNodes[i].text !== text) continue;
        	if (wNodes[i].text.substr(0,text.length) !== text) continue;
            if (checkLevel && level !== wNodes[i].level) continue;

            wNode = wNodes[i]
            break;
        }
    }

    if (wNode == null){
    	if(this.selectedItem == null){
    		alert(getText("message_treeview_003", "{0}를 찾을 수 없습니다.", [text]));
    	}
//    	else {
//    		alert(text + "를 더 이상 찾을 수 없습니다.");
//    	}
    	
        return null;
    }

    // 탐색된 노드를 펼쳐준다ㅏ 
    var parentNode = wNode;
//    var level = (("" + wNode.tag).split(";")).length;
//    for (var i = level - 1; i > 0; i--) {	
//        parentNode = parentNode.parent;
//        //if (!parentNode.expanded) parentNode.open();
//        //if (!parentNode.expanded) parentNode.parentControl.open(parentNode.tag, this.nodes.getIndexOf(parentNode.tag));
//        parentNode.parentControl.open(parentNode.tag, this.nodes.getIndexOf(parentNode.tag));
//    }
    while(parentNode.parent != null){
    	parentNode = parentNode.parent;
    	parentNode.parentControl.open(parentNode.tag, this.nodes.getIndexOf(parentNode.tag));
    }
    parentNode = null;
    
    // 현재선택한 노드가 있으면 원래색깔로 돌린다
    if (this.selectedItem != null){
    	this.selectedItem.textTagObject.className = "";
    }    
    
    // 선택한 노드의 속성을 바꾼다
    this.selectedItem = wNode;
    this.selectedItem.textTagObject.className = "NodeSel";

    // 노드 클릭이벤트를 일으킨다.
    if (this.hasNodeClickEvent) {
        var result = this.fncNodeClickEvent(wNode);
    }

    return wNode;
};
/**
 * @class ChartBox 차트박스
 * @description ChartBox ControlBase를 상속받고 해당 컨트롤의 ID, Name, 태그 속성을 설정합니다.
 * @param {string} controlId 			해당 컨트롤의 ID
 * @param {string} controlName 			해당 컨트롤의 Name
 * @param {object} tagObject 			해당 컨트롤의 태그 속성을 설정하는 객체
 * @return 반환값 없음
 * 
 * @property {string} chartName 		차트 태그 네임		
 * @property {string} title 			차트 제목
 * @property {number} gallery 			차트 종류(1:Line,2:Column,3:Curve,4:Scatter,5:Pie,6:Area,7:Pareto,8:Step,9:High-Low-Close,10:Surface,11:Radar,12:Cube,13:Doughnut,14:Pyramid,15:Bubble,16:Open-High-Low-Close,17:CandleStick,18:Contour,19:Curve-Area,20:Bar)
 * @property {number} stacked 			누적 그래프(0 : 누적아님, 1 : 누적)
 * @property {number} grid 				그리드선(1 : 가로선, 2 : 세로선, 3 : 가로,세로선)
 * @property {boolean} chart3d 			차트형태 (True:3D, False:2D)
 * @property {string} backcolor			배경색상
 * @property {string} fillcolor			채우기색상
 * @property {string} stripe 			영역 강조
 * @property {string} constantline 		기준라인 문자
 * @property {string} bottomtitle    	x축 제목
 * @property {number} xmax  			x축 최대값
 * @property {number} xmin  			x축 최소값
 * @property {number} xstep  			x축 증분값
 * @property {string} lefttitle  		y축 제목
 * @property {number} ymax 				y축 최대값
 * @property {number} ymin 				y축 최소값
 * @property {number} ystep  			y축 증분값
 * @property {number} ydecimals			y축 소수점 자릿수
 * @property {string} seriescode2  		y2축 계열코드
 * @property {string} lefttitle2  		y2축 제목
 * @property {number} ymax2 			y2축 최대값
 * @property {number} ymin2 			y2축 최소값
 * @property {number} ystep2  			y2축 증분값
 * @property {number} ydecimals2		y2축 소수점 자릿수
 * @property {string} data  			데이터
 * @property {boolean} busy 			현재 작업이 진행중이면 true 아니면 false
 */
function ChartBox(controlId, controlName, tagObject){
    // 상속선언부
    this.base = ControlBase;              			//부모클래스 지정
    this.base(controlId, controlName, tagObject);   //부모클래스 생성자호출
    
    // 상수 선언부
    
    // 속성 선언부
//    this.width = tagObject.style.width;
//    this.height = tagObject.style.height;
    /**
     * @property {number} width 폭
     */
    this.width = getComputedStyle(tagObject).width;
    /**
     * @property {number} height 높이
     */
    this.height = getComputedStyle(tagObject).height;
    
    if (tagObject != undefined){
        tagObject.setAttribute("tabIndex", "-1");
        charts[charts.length] = this;
    }
    
    this.chartName  = "";
    this.title = tagObject.getAttribute("charttitle");
    /**
     * @description 미결
     */
    this.gallery = (!tagObject.getAttribute("gallery") ? "2" : tagObject.getAttribute("gallery"));
    this.stacked = tagObject.getAttribute("stacked");     // 0 or 1
    this.grid = tagObject.getAttribute("grid");
    this.chart3d = tagObject.getAttribute("chart3d");
    this.backcolor = (!tagObject.getAttribute("backcolor") ? "FFFFFF" : tagObject.getAttribute("backcolor"));
    this.fillcolor = (!tagObject.getAttribute("fillcolor") ? "FFFFFF" : tagObject.getAttribute("fillcolor"));
    this.stripe = tagObject.getAttribute("stripe");
    this.constantline = tagObject.getAttribute("constantline");
//    this.rgb2dbk = (!tagObject.getAttribute("rgb2dbk") ? 16777215 : tagObject.getAttribute("rgb2dbk"));
//    this.rgb3dbk = (!tagObject.getAttribute("rgb3dbk") ? 16777215 : tagObject.getAttribute("rgb3dbk"));
//    this.rgbbk = (!tagObject.getAttribute("rgbbk") ? 16777215 : tagObject.getAttribute("rgbbk"));
//    this.min1 = tagObject.getAttribute("min1");   // no use
//    this.max1 = tagObject.getAttribute("max1");   // no use
//    this.color1 = tagObject.getAttribute("color1");   // no use
//    this.constantlinevalue1 = tagObject.getAttribute("constantlinevalue1"); // 배열
//    this.constantlinelabel1 = tagObject.getAttribute("constantlinelabel1"); // 배열
//    this.view3ddepth = 0; // no use
    this.bottomtitle = tagObject.getAttribute("bottomtitle"); 
    this.xmax = (!tagObject.getAttribute("xmax") ? 100 : tagObject.getAttribute("xmax"));
    this.xmin = (!tagObject.getAttribute("xmin") ? 0 : tagObject.getAttribute("xmin"));
    this.xstep = (!tagObject.getAttribute("xstep") ? 1 : tagObject.getAttribute("xstep"));
    this.xdecimals = tagObject.getAttribute("xdecimals");
    this.lefttitle = tagObject.getAttribute("lefttitle");
    this.ymax = (!tagObject.getAttribute("ymax") ? 100 : tagObject.getAttribute("ymax"));
    this.ymin = (!tagObject.getAttribute("ymin") ? 0 : tagObject.getAttribute("ymin"));
    this.ystep = (!tagObject.getAttribute("ystep") ? 1 : tagObject.getAttribute("ystep"));
    this.ydecimals = tagObject.getAttribute("ydecimals");
    this.seriescode2 = tagObject.getAttribute("seriescode2");
    this.lefttitle2 = tagObject.getAttribute("lefttitle2");
    this.ymax2 = (!tagObject.getAttribute("ymax2") ? 100 : tagObject.getAttribute("ymax2"));
    this.ymin2 = (!tagObject.getAttribute("ymin2") ? 0 : tagObject.getAttribute("ymin2"));
    this.ystep2 = (!tagObject.getAttribute("ystep2") ? 1 : tagObject.getAttribute("ystep2"));
    this.ydecimals2 = tagObject.getAttribute("ydecimals2");
    this.data = "";    
    this.busy = false;
};
ChartBox.prototype = new ControlBase(); // 의미없음 코딩 편의기능을 활용하기 위함
/**
 * @description	설정된 데이터값으로 차트를 채워줍니다.
 * @param	{object}	strXml 
 * @param	{object}	swfName
 * @param	{object}	dataFormat
 * @return	{undefined}
 */
//ChartBox.prototype.setChartXml = function (strXml, swfDir, swfName, dataFormat) {
ChartBox.prototype.setChartXml = function (strXml, swfName, dataFormat) {
	// functionname : [ChartBox.setChartXml]
	
//    var chart = new FusionCharts(getContextPath() + "/pages/groupware/images/"+swfDir+"/"+swfName+".swf", this.controlId, this.width, this.height);
//    chart.setDataXML(strXml);
//    chart.render(this.id);
    
	var chart = new FusionCharts({
        type: swfName,
        renderAt: this.controlId,
//        width: getComputedStyle(this.tagObject).width,
//        height: this.height,
        width: "100%",
        height: "100%",
        dataFormat: dataFormat,
        dataSource: strXml
    });
	
    // Render the chart.
	chart.render();
    
    // 데이터 처리가 끝나면 로딩 박스를 숨긴다
    //hideAjaxBox();
    //document.getElementsByName("ajaxBox")[0].style.display = 'none';
};

/**
 * @description 설정된 값으로 채워진 차트를 화면에 보여줍니다.
 * @param em 해당 태그객체
 * @return 반환값 없음
 */
ChartBox.prototype.show =  function(em) {		
	this.busy = true;
//	showAjaxBox("차트작성중입니다.", 0); // 로딩 박스를 보여준다
	
	var wQueryString = "data=" + encodeURIComponent(this.data)
		            + "&title=" + encodeURIComponent(this.title)
		            + "&gallery=" + this.gallery
		            + "&stacked=" + this.stacked
		            + "&grid=" + this.grid
					+ "&chart3d=" + this.chart3d
					+ "&backcolor=" + this.backcolor
					+ "&fillcolor=" + this.fillcolor
					+ "&stripe=" + this.stripe
					+ "&constantline=" + this.constantline
//					+ "&rgb2dbk=" + this.rgb2dbk
//					+ "&rgb3dbk=" + this.rgb3dbk
//					+ "&rgbbk=" + this.rgbbk
//					+ "&min1=" + this.min1
//					+ "&max1=" + this.max1
//					+ "&color1=" + this.color1
//					+ "&constantlinevalue1=" + this.constantlinevalue1
//					+ "&constantlinelabel1=" + encodeURIComponent(this.constantlinelabel1)
					+ "&bottomtitle=" + encodeURIComponent(this.bottomtitle)
					+ "&xmax=" + this.xmax
					+ "&xmin=" + this.xmin
					+ "&xstep=" + this.xstep
					+ "&xdecimals=" + this.xdecimals
					+ "&lefttitle=" + encodeURIComponent(this.lefttitle)
					+ "&ymax=" + this.ymax
					+ "&ymin=" + this.ymin
					+ "&ystep=" + this.ystep
					+ "&ydecimals=" + this.ydecimals
					+ "&seriescode2=" + encodeURIComponent(this.seriescode2)
					+ "&lefttitle2=" + encodeURIComponent(this.lefttitle2)
					+ "&ymax2=" + this.ymax2
					+ "&ymin2=" + this.ymin2
					+ "&ystep2=" + this.ystep2
					+ "&ydecimals2=" + this.ydecimals2
			        + "&lang=" + USER_LANGUAGE
					+ "&tm=" + (new Date()).valueOf();
	
	if (TEST_MODE == undefined || !TEST_MODE){
		ajaxCall("POST", getContextPath() + "/ViewChart.do", wQueryString, this, "textChart");
	} else {
		ajaxCall("POST", getContextPath() + "/test/ViewChart.do", wQueryString, this, "textChart");
	}
	
	return;
		
};

/**
 * @description 미결
 * @param	{String}	info
 * @param	{String}	message
 * @param	{Object}	pFlag
 * @return	{void}
 * @example 미결
 */
ChartBox.prototype.parseData = function(info, message, pFlag){
	// functionname : [ChartBox.parseData]
	this.busy = false;               	
	// 오류 메시지 먼저 파악 
	if (info == null){
		callEvent("Chart_" + this.id + "_MakeFailed", message);
		return;
	}
	
	//window.clipboardData.setData("Text", info);
	
	// 데이터분석 플래시 전달
    var data = info.split("^&^");
    this.setChartXml(data[0], data[1], data[2]);
    
    callEvent("Chart_" + this.id + "_MakeSuccess");
	
	return;
};
	//christopheviau.com/d3list/gallery.html
	//http://www.tutorialsteacher.com/d3js


/*
	
	1  Line : O
	2  Column : O
	3  Curve Line : O
	4  Scatter : O
	5  Pie : O
	6  Area : O
	7  Combo : O
	8  Step : O
	9  High-Low-Close : O
	11 Radea : O
	13 Doughnut : O
	14 Pyramid : O
	15 Bubble : O
	16 Open-High-Low-Close : O
	17 Candlestick : O
	19 Curve Area : O
	20 Bar : O
	21 Pareto : O
	22 Gantt : O
	//97 : Candlestick
	//98 : Cube
	//99 : 막대형 누적 라인
*/
	

	//document.write("<script src='https://d3js.org/d3.v4.min.js'></script>");

	
	
	function d3Chart(controlId, controlName, tagObject) {
		
		if (tagObject != null) {
			
			//색 가져오기
			var wQueryString = "";
			if (TEST_MODE == undefined || !TEST_MODE){
				ajaxCall("POST", getContextPath() + "/D3ViewChart.do", wQueryString, this, "textChart");
			} else {
				ajaxCall("POST", getContextPath() + "/test/D3ViewChart.do", wQueryString, this, "textChart");
			}
			
			
		    // 상속선언부
		    this.base = ControlBase;              			//부모클래스 지정
		    this.base(controlId, controlName, tagObject);   //부모클래스 생성자호출
		    
		    if (tagObject != undefined){
		        tagObject.setAttribute("tabIndex", "-1");
		        charts[charts.length] = this;
		    }
		    
		    this.charttitle = tagObject.getAttribute("charttitle");
		    this.gallery = (!tagObject.getAttribute("gallery") ? "2" : tagObject.getAttribute("gallery"));
		    this.stacked = tagObject.getAttribute("stacked");     // 1: stack, 2: stack percent
		    this.grid = tagObject.getAttribute("grid");
		    this.ymax = (!tagObject.getAttribute("ymax") ? 100 : tagObject.getAttribute("ymax"));
		    this.ymin = (!tagObject.getAttribute("ymin") ? 0 : tagObject.getAttribute("ymin"));
		    this.chart3d = tagObject.getAttribute("chart3d");
		    this.backcolor = (!tagObject.getAttribute("backcolor") ? "#FFFFFF" : tagObject.getAttribute("backcolor"));
		    this.fillcolor = (!tagObject.getAttribute("fillcolor") ? "#FFFFFF" : tagObject.getAttribute("fillcolor"));
			this.stripe = tagObject.getAttribute("stripe");
			this.constantline = tagObject.getAttribute("constantline");
		    this.bottomtitle = tagObject.getAttribute("bottomtitle"); 
		    this.lefttitle = tagObject.getAttribute("lefttitle");
		    this.xmax = (!tagObject.getAttribute("xmax") ? 100 : tagObject.getAttribute("xmax"));
		    this.xmin = (!tagObject.getAttribute("xmin") ? 0 : tagObject.getAttribute("xmin"));
		    this.seriescode2 = tagObject.getAttribute("seriescode2");
		    this.lefttitle2 = tagObject.getAttribute("lefttitle2");
		    this.ymax2 = (!tagObject.getAttribute("ymax2") ? 100 : tagObject.getAttribute("ymax2"));
		    this.ymin2 = (!tagObject.getAttribute("ymin2") ? 0 : tagObject.getAttribute("ymin2"));
		    this.data = "";
		    
		} else {
			this.controlId = controlId;
			this.controlName = controlName;
		    this.charttitle;
		    this.gallery;
		    this.stacked;     // 1: stack, 2: stack percent
		    this.grid;  //0:없음, 1:가로, 2:세로, 3:모두
		    this.ymax;
		    this.ymin;
		    this.chart3d;
		    this.backcolor = "#FFFFFF";
			this.fillcolor = "#FFFFFF";
			this.stripe;  //영역강조의 구간을 설정합니다. 시작과 종료 순서를 여러개의 영역으로 설정할 수 있으며, 구분자는 세미콜론(;)을 사용합니다. ex)50;60;보통;90;100;좋음
			this.constantline;  //기준선을 표시할 좌표와 표시문자를 설정합니다. 좌표와 표시문자 순서로 여러개의 기준선을 설정할 수 있으며, 구분자는 세미콜론(;)을 사용합니다. ex)80;주의;90;경고
		    this.bottomtitle; 
		    this.lefttitle;
		    this.xmax;
		    this.xmin;
		    this.seriescode2;
		    this.lefttitle2;
		    this.ymax2;
		    this.ymin2;
		    this.data = "";
		    
		    
//			this.seriesColor = d3.schemeCategory10;
//			this.seriesColor = ["#5E4FA2", "#3288BD", "#66C2A5", "#ABDDA4", "#E6F598", "#FFFFBF", "#FEE08B", "#FDAE61", "#F46D43", "#D53E4F", "#9E0142"];		
			this.seriesColor = ["#FDC12E","#56B9F9","#C9198D","#FF8E46","#008E8E","#D64646","#8E468E","#588526","#B3AA00","#008ED6",
				               "#9D080D","#A186BE","#00CED1","#CD853F","#778899","#696969","#2F4F4F","#708090","#2E8B57","#20B2AA",
				               "#FDC12E","#56B9F9","#C9198D","#FF8E46","#008E8E","#D64646","#8E468E","#588526","#B3AA00","#008ED6",
				               "#9D080D","#A186BE","#00CED1","#CD853F","#778899","#696969","#2F4F4F","#708090","#2E8B57","#20B2AA",
				               "#FDC12E","#56B9F9","#C9198D","#FF8E46","#008E8E","#D64646","#8E468E","#588526","#B3AA00","#008ED6",
				               "#9D080D","#A186BE","#00CED1","#CD853F","#778899","#696969","#2F4F4F","#708090","#2E8B57","#20B2AA"];
			this.seriesColorIndex = []; 
			for (var i = 0; i < this.seriesColor.length; i++) {
				this.seriesColorIndex[i] = i;
			}
			
			this.highlightColor = ["#D5FFD5","#C6C6FF","#FFC6C6","#FFC6DD","#BBFFD6","#009900","#0000FF","#FF0000","#FF33CC","#11FFAA"];
		    this.highlightColorIndex = [];
		    for (var i = 0; i < this.highlightColor.length; i++) {
		    	this.highlightColorIndex[i] = i;
		    }
		    
		    this.data_month_label = ["1월","2월","3월","4월","5월","6월","7월","8월","9월","10월","11월","12월"];
		    this.data_week_label = ["1주","2주","3주","4주","5주","6주","7주","8주","9주","10주","11주","12주","13주"];
		    this.data_dayOfWeek_label = ["일요일","월요일","화요일","수요일","목요일","금요일","토요일"];
		    this.data_time_label = ["00:00:00,02:59:59,Midnight","03:00:00,05:59:59,3AM","06:00:00,08:59:59,6AM","09:00:00,11:59:59,9AM","12:00:00,14:59:59,12PM","15:00:00,17:59:59,3PM","18:00:00,20:59:59,6PM","21:00:00,23:59:59,9PM"];
			
		}
	    
		
		
		
		this.legendType = "right";  /* 기본값:오른쪽, bottom:아래쪽 */
		this.animateFlag = true;  /* true:차트 animate 사용, false:차트 animate 미사용 */
		
		this.curveType = 0;
		
		this.outLegendData = [];  /* 데이터의 index가 있으면 해당 데이터를 안보이게 함 */
		this.outDataFlag = "false";  /* outLegendData에 모든 index가 있으면 차트를 제거함 */
		
		this.pyramidSliceIndex = -1;
		
		this.pieSliceIndex = [];  /* 배열 안에 있는 값에 대한 pie를 한칸씩 떼어 놓는다. */
		this.pieRotate = 0;  /* pie를 회전 시킬 각도  [3시방향(시작지점):0, 6시방향:PI/2, 9시방향:PI, 12시방향:PI+(PI/2)]*/
		this.pieStartRotate = 0;  /* 이미 회전되어 있는 pie 각도 */
		this.pieStartAngle = "";
	};
	
	
	/**
	 * @description 미결
	 * @param	{String}	info
	 * @param	{String}	message
	 * @param	{Object}	pFlag
	 * @return	{void}
	 * @example 미결
	 */
	d3Chart.prototype.parseData = function(info, message, pFlag){
		// functionname : [d3Chart.parseData]
		this.busy = false;               	
		// 오류 메시지 먼저 파악 
		if (info == null){
			callEvent("Chart_" + this.id + "_MakeFailed", message);
			return;
		}
		
		//window.clipboardData.setData("Text", info);
		
		//data[0]만 사용하고 data[1], data[2]는 퓨전차트에서 사용해서 여기서는 사용 안함 
	    var data = info.split("^&^");
	    
	    parser = new DOMParser();
	    xmlDoc = parser.parseFromString(data[0],"text/xml");
	    
	    var seriesColor = xmlDoc.getElementsByTagName("seriesColor")[0].childNodes[0].nodeValue.split(";");
	    var highlightColor = xmlDoc.getElementsByTagName("highlightColor")[0].childNodes[0].nodeValue.split(";");
	    var month = xmlDoc.getElementsByTagName("month")[0].childNodes[0].nodeValue.split(";");
	    var week = xmlDoc.getElementsByTagName("week")[0].childNodes[0].nodeValue.split(";");
	    var dayOfWeek = xmlDoc.getElementsByTagName("dayOfWeek")[0].childNodes[0].nodeValue.split(";");
	    var time = xmlDoc.getElementsByTagName("time")[0].childNodes[0].nodeValue.split(";");
	    
	    
	    this.seriesColor = [];
	    this.seriesColorIndex = []; 
	    for (var i = 0; i < seriesColor.length; i++) {
	    	this.seriesColor[i] = "#" + seriesColor[i];
	    	this.seriesColorIndex[i] = i;
	    }
	    
	    this.highlightColor = [];
	    this.highlightColorIndex = [];
	    for (var i = 0; i < highlightColor.length; i++) {
	    	this.highlightColor[i] = "#" + highlightColor[i];
	    	this.highlightColorIndex[i] = i;
	    }
	    
	    this.data_month_label = [];
	    for (var i = 0; i < month.length; i++) {
	    	this.data_month_label[i] = month[i];
	    }
	    
	    this.data_week_label = [];
	    for (var i = 0; i < month.length; i++) {
	    	this.data_week_label[i] = week[i];
	    }
	    
	    this.data_dayOfWeek_label = [];
	    for (var i = 0; i < month.length; i++) {
	    	this.data_dayOfWeek_label[i] = dayOfWeek[i];
	    }
	    
	    this.data_time_label = [];
	    for (var i = 0; i < time.length; i++) {
	    	this.data_time_label[i] = time[i];
	    }
	    
	    
		
		return;
	};
	
	
	/*
	 * outsideFalg
	 *   - null 또는 true : 외부에서 show() 함수 실행
	 *   - false : 내부에서 show() 함수 실행
	 */
	d3Chart.prototype.show = function(outsideFalg) {
		
		var gThis = this;
		
		gThis.drawChartFlag = false;  /* true : resize함수에서 차트의 크기가 바뀌면 다시 그리기,  false : 차트 안 그리기 */
		gThis.fontSize = 11;
		gThis.xtick = 5;
		gThis.ytick = 5;
		
		var data;
		var jsonData;
		var stackData;
		
		var margin = {top: 15, right: 30, bottom: 15, left: 30};
		var bar3DLen = this.chart3d == "true" ? 10 : 0;  /* column, bar 차트에서 3D로 만들 때 길이 */
		var delay = 500;
		var duration = 1500;
		var color = d3.scaleOrdinal().domain(this.seriesColorIndex).range(this.seriesColor);
		var highlightColor = d3.scaleOrdinal().domain(this.highlightColorIndex).range(this.highlightColor);
		
		var ymax = this.ymax * 1;
		var ymin = this.ymin * 1;
		var ymax2 = this.ymax2 * 1;
		var ymin2 = this.ymin2 * 1;
		var yStart = "";
		var yStart2 = "";
		var xmax = this.xmax * 1;
		var xmin = this.xmin * 1;
		var xStart = "";
		
		var stripe = new Array();
		var constantline = new Array();
		var seriescode2 = gThis.seriescode2 == null ? "" : gThis.seriescode2.split(";");
		for (var i = seriescode2.length - 1; i >= 0 ; i--) {
			if (seriescode2[i] == "") seriescode2.splice(i, i + 1);
		}
		
		var tickValues = [];  /* pareto에서 사용 */
		var volumeHeight = 0;  /* Candlestick에서 사용, volume그래프 높이 비율 */
		
		/* line에서 사용 시작 */
		var lineDuration = 250;
		var lineOpacity = "0.5";
		var lineOpacityHover = "0.75";
		var otherLinesOpacityHover = "0.1";
		var lineStroke = "2px";
		var lineStrokeHover = "3px";

		var circleOpacity = '1';
		var circleOpacityOnLineHover = "0.25"
		var circleRadius = 4;
		var circleRadiusHover = 6;
		/* line에서 사용 종료 */
		
		var curveArray = [
			    d3.curveLinear,
			    d3.curveStep,
			    d3.curveStepBefore,
			    d3.curveStepAfter,
			    d3.curveBasis,
			    d3.curveCardinal,
			    d3.curveMonotoneX,
			    d3.curveCatmullRom
		    ];

		var sybolArray = [ 
				d3.symbolCircle,
	            d3.symbolCross,
	            d3.symbolDiamond,
	            d3.symbolSquare,
	            d3.symbolStar,
	            d3.symbolTriangle,
	            d3.symbolWye 
	        ];
		
		var svg = "";
		var chart = "";
		var axis = "";
		var label = "";
		var legend = "";
		var trendzone = "";
		var trendline = "";
		
		var trendmax;  /* trendzone, trendline 중에 가장 큰 값 */
		var trendmin;  /* trendzone, trendline 중에 가장 작은 값 */
		var trendwidth = 0;  /* trendzone, trendline 중에 가장 큰 값(trendmargin 포함) */
		var trendheight = 0;  /* trendzone, trendline 중에 가장 큰 값(trendmargin 미포함) */
		var trendmargin = 10;  /* trend label 그릴 때 차트에서 이 값 만큼 여백을 주고 label을 그림 */
		
		var tooltip = "";
		var tooltipLine = "";
		
		var gettitle = "";
		var getbottomtitle = "";
		var getlefttitle = "";
		var getlegend = "";
		var gettrendzone = "";
		var gettrendline = "";
		
		var gradient = "";
		
		var bottomScale = "";
		var leftScale = "";
		var rightScale = "";
		
		
		
		
		
		
		/* show()를 외부에서 실행 시키면 설정값 초기화 */
		if (outsideFalg == null || outsideFalg != false) {
			gThis.animateFlag = true;
			gThis.outLegendData = [];
			gThis.outDataFlag = "false";
			
			gThis.pyramidSliceIndex = -1;
			
			gThis.pieSliceIndex = [];
			gThis.pieRotate = 0;
			gThis.pieStartRotate = 0;
			gThis.pieStartAngle = "";
		}
		
		if (gThis.animateFlag == false) {
			delay = 0;
			duration = 0;
		}
		
		if (this.tagObject != null) {
			gThis.left = getComputedStyle(gThis.tagObject).left.split("px")[0] * 1;
			gThis.top = getComputedStyle(gThis.tagObject).top.split("px")[0] * 1;
			gThis.width = getComputedStyle(gThis.tagObject).width.split("px")[0] * 1;
			gThis.height = getComputedStyle(gThis.tagObject).height.split("px")[0] * 1;
		} else {
			gThis.left = document.getElementsByName(gThis.controlName)[0].offsetLeft * 1;
			gThis.top = document.getElementsByName(gThis.controlName)[0].offsetTop * 1;
			gThis.width = (document.getElementsByName(gThis.controlName)[0].offsetWidth * 1) - 3;  /* border넓이 뺌 */
			gThis.height = (document.getElementsByName(gThis.controlName)[0].offsetHeight * 1) - 3;  /* border넓이 뺌 */
		}
		
		/* 차트의 크기가 바뀌면 다시 그리기 */
		setInterval(resize, 200);
		
		/* 숫자가 아니면 종료 */
		if (isNaN(gThis.left) || isNaN(gThis.top) || isNaN(gThis.width) || isNaN(gThis.height)) {
			gThis.drawChartFlag = true;
			return;
		}
		
		
		/* 이지메이커에서 넘겨 받은 데이터를 json으로 만들기 */
		makeData();
		data = JSON.parse(JSON.stringify(jsonData));
		
		
		
		if (gThis.gallery == 7 && this.tagObject != null) {
			/* Y2축이 있으면 해당 계열을 Line으로 그리기 */
			if (seriescode2.length > 0) {
				for (var i = 0; i < data.length; i++) {
					for (var j = 0; j < seriescode2.length; j++) {
						if (data[i].cValue.indexOf(seriescode2[j]) > -1) {
							data[i].renderas = "line";
						}
					}
				}
				
			/* Y2축이 없으면 마지막 계열만  Line으로 그리기 */
			} else {
				data[data.length - 1].renderas = "line";
			}
		}
		
		
		/* line, area 차트의 curve 모양 설정 */
		if (gThis.gallery == 3 || gThis.gallery == 19) gThis.curveType = 5;
		else if (gThis.gallery == 8) gThis.curveType = 2;
		
		
		/* svg 만들기 */
		makeSvg();
		
		/* 위로 갈수록 밝아지는 gradient 만들기 */
		makeGradient();
		
		/* 툴팁 만들기 */
		makeTooltip();
		
		/* 라벨 만들기 */
		makeLabel();
		
		/* 범례 만들기 */
		makeLegend();
		
		/* trend 0 만들기 */
		makeTrend(0);
		
		/* trend 1 만들기 : scale 사용하는 차트만 */
		if (gThis.gallery == 1 || gThis.gallery == 2 || gThis.gallery == 3 || gThis.gallery == 4 || gThis.gallery == 6 || gThis.gallery == 7 || gThis.gallery == 8 || gThis.gallery == 9 || gThis.gallery == 15 || gThis.gallery == 16 || gThis.gallery == 17 || gThis.gallery == 19 || gThis.gallery == 20 || gThis.gallery == 21 || gThis.gallery == 98 || gThis.gallery == 99) {
			makeTrend(1);
		}
		
		/* 데이터 타입 format */
		formatData();
		
		/* 데이터 역순 정렬 */
		inverseOrder();
		
		/* 필요한 컬럼 추가  */
		setColumn();
		
		/* 범례에서 불 꺼진 데이터 삭제 */
		outLegend();
		
		/* x, y의 max값과 min값 구하기 */
		getMaxMin();
		
		
		
		if (gThis.gallery == 1 || gThis.gallery == 3 || gThis.gallery == 8) makeLineChart();
		else if (gThis.gallery == 2 || gThis.gallery == 98) makeColumnChart();
		else if (gThis.gallery == 4) makeScatterChart();
		else if (gThis.gallery == 5 || gThis.gallery == 13) makePieChart();
		else if (gThis.gallery == 6 || gThis.gallery == 19) makeAreaChart();
		else if (gThis.gallery == 7) makeComboChart();
		else if (gThis.gallery == 11) makeRadeaChart();
		else if (gThis.gallery == 14) makePyramidChart();
		else if (gThis.gallery == 15) makeBubbleChart();
		else if (gThis.gallery == 9 || gThis.gallery == 16 || gThis.gallery == 17) makeCandlestickChart();
		else if (gThis.gallery == 20) makeBarChart();
		else if (gThis.gallery == 21) makeParetoChart();
		else if (gThis.gallery == 22) makeGanttChart();
		
		else if (gThis.gallery == 97) makeCandlestick();
		else if (gThis.gallery == 99) makeTest01();

		/* bottomtitle, lefttitle 안쓰면 차트에서 데이터를 넣으면 보이기 때문에 삭제함 */
		if (gThis.gallery == 13 || gThis.gallery == 11 || gThis.gallery == 14 || gThis.gallery == 22) {
			label.select(".bottomtitle").remove();
			label.select(".lefttitle").remove();
		}
		
		
		
		/* trend 2 만들기 : scale 사용하는 차트만 */
		if (gThis.gallery == 1 || gThis.gallery == 2 || gThis.gallery == 3 || gThis.gallery == 4 || gThis.gallery == 6 || gThis.gallery == 7 || gThis.gallery == 8  || gThis.gallery == 9 || gThis.gallery == 15 || gThis.gallery == 16 || gThis.gallery == 17 || gThis.gallery == 19 || gThis.gallery == 20 || gThis.gallery == 21 || gThis.gallery == 98 || gThis.gallery == 99) {
			makeTrend(2);
		}
		
		/* 모든 데이터에 불이 꺼지면 axis, label만 남기고 chart를 제거 */
		if (gThis.outDataFlag == "true") chart.remove();
		
		gThis.animateFlag = false;
		gThis.drawChartFlag = true;
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		/**
		 * @description	미결
		 * @param		{String}	pValue
		 * @param		{String}	formatStr
		 * @returns		{String}
		 * @example		미결
		 */
		function mask(pValue, formatStr) {
//			if (format)
//				return format("" + pValue, formatStr);

			var wIsNumeric = false;
			var wReturn = "";
			var wDigitPos = 0;

			if (typeof (pValue) == "number") {
				pValue = "" + pValue;
			}

			if (pValue == "")
				return "";

			if (formatStr.length > 1
					&& (formatStr.substring(formatStr.length - 1, formatStr.length) == "0"
							|| formatStr.substring(formatStr.length - 1,
									formatStr.length) == "#" || formatStr.substring(
							formatStr.length - 1, formatStr.length) == "%")) {
				wIsNumeric = true;
			}

			// 숫자인 경우 소수점이하 자릿수를 맞추어 준다. 이상태에서 소숫점 을 없애준다
			if (wIsNumeric) {
				// 포멧 소수점의 위치
				var dotPosOfFormat = formatStr.indexOf(".");
				// 포멧 소수점이후 자릿수
				var countAfterDotOfFormat = (dotPosOfFormat < 0 ? 0 : formatStr.length
						- dotPosOfFormat - 1);

				var dotPosOfValue = pValue.indexOf(".");
				var countAfterDotOfValue = pValue.length - dotPosOfValue - 1;

				// 퍼센트
				if (formatStr.substr(formatStr.length - 1, formatStr.length) == "%")
					countAfterDotOfFormat += -1;

				if (countAfterDotOfFormat > 0) {
					var num = parseFloat(pValue);
					var n = num.toFixed(countAfterDotOfFormat);

					pValue = "" + n;
					var formatLength = formatStr.length;

					for (var i = 0; i < countAfterDotOfFormat; i++) {
						if (formatStr.charAt(formatLength - 1 - i) == '#'
								&& pValue.charAt(pValue.length - 1) == '0') {
							pValue = pValue.substring(0, pValue.length - 1);
							formatStr = formatStr.substring(0, formatStr.length - 1);
						} else {
							break;
						}
					}

					if (pValue.charAt(pValue.length - 1) == '.') {
						pValue = pValue.substring(0, pValue.length - 1);
						formatStr = formatStr.substring(0, formatStr.length - 1);
					}
				} else {
					var num = parseFloat(pValue);
					var n = num.toFixed();

					pValue = "" + n;
				}

				pValue = pValue.replace(/\./g, "");

				// 소수점이하 자리가 맞은 상태에서 아래 로직 동작

				wDigitPos = pValue.length - 1;
				for (var i = formatStr.length - 1; i >= 0; i--) {
					if (formatStr.charAt(i) == "0") {
						if (wDigitPos >= 0) {
							wReturn = pValue.charAt(wDigitPos) + wReturn;
						} else {
							wReturn = "0" + wReturn;
						}
						wDigitPos--;
					} else if (formatStr.charAt(i) == "#") {
						if (wDigitPos >= 0) {
							wReturn = pValue.charAt(wDigitPos) + wReturn;
						}
						wDigitPos--;
					} else if (formatStr.charAt(i) == ".") {
						if (wDigitPos >= 0) {
							wReturn = "." + wReturn;
						}
					} else if (formatStr.charAt(i) == ",") {
						if (wDigitPos >= 0) {
							if (pValue.charAt(wDigitPos) != '-')
								wReturn = "," + wReturn;
						}
					} else if (formatStr.charAt(i) == "+") {
						wReturn = "+" + wReturn;
					} else if (formatStr.charAt(i) == "-") {
						wReturn = "-" + wReturn;
					} else if (formatStr.charAt(i) == "/") {
						wReturn = "/" + wReturn;
					} else if (formatStr.charAt(i) == "$") {
						wReturn = "$" + wReturn;
					} else if (formatStr.charAt(i) == "%") {
						wReturn = wReturn + "%";
					} else {
						wReturn = formatStr.charAt(i) + wReturn;
					}
				}

				if (wDigitPos >= 0) {
					wReturn = pValue.substring(0, wDigitPos + 1) + wReturn;
				}
				// 표시형식이 .으로 끝난경우 제거해준다
				if (wReturn.charAt(wReturn.length - 1) == ".") {
					wReturn = wReturn.substring(0, wReturn.length - 1);
				}

				var pattern = /^[-#,.]+$/;
				if (wReturn == "0" && pattern.test(formatStr))
					wReturn = "";

			} else {
				wDigitPos = 0;
				for (var i = 0; i < formatStr.length; i++) {
					if (formatStr.charAt(i) == "@") {
						if (wDigitPos >= 0) {
							wReturn += pValue.charAt(wDigitPos);
						} else {
							wReturn += " ";
						}
						wDigitPos++;
					} else if (formatStr.charAt(i) == "&") {
						if (wDigitPos >= 0) {
							wReturn += pValue.charAt(wDigitPos);
						}
						wDigitPos++;
					} else {
						wReturn += formatStr.charAt(i);
					}
				}
				if (wDigitPos < pValue.length) {
					wReturn += pValue.substring(0, wDigitPos);
				}
			}

			return wReturn;
		};
		
		
		/* 차트의 크기가 바뀌면 다시 그리기 */
		function resize() {
			if (gThis.drawChartFlag == true) {
				var resizeleft = "";
				var resizetop = "";
				var resizewidth = "";
				var resizeheight = "";
				
				if (gThis.tagObject != null) {
					resizeleft = getComputedStyle(gThis.tagObject).left.split("px")[0] * 1;
					resizetop = getComputedStyle(gThis.tagObject).top.split("px")[0] * 1;
					resizewidth = getComputedStyle(gThis.tagObject).width.split("px")[0] * 1;
					resizeheight = getComputedStyle(gThis.tagObject).height.split("px")[0] * 1;
				} else {
					resizeleft = document.getElementsByName(gThis.controlName)[0].offsetLeft * 1;
					resizetop = document.getElementsByName(gThis.controlName)[0].offsetTop * 1;
					resizewidth = (document.getElementsByName(gThis.controlName)[0].offsetWidth * 1) - 3;  /* border넓이 뺌 */
					resizeheight = (document.getElementsByName(gThis.controlName)[0].offsetHeight * 1) - 3;  /* border넓이 뺌 */
				}
				
				/* 현재 값이 NaN이 아니면서 기존 값과 서로 다르면 차트를 다시 만든다.*/
				if (!isNaN(resizeleft) && 
					!isNaN(resizetop) && 
					!isNaN(resizewidth) && 
					!isNaN(resizeheight)) {
					
					if (gThis.left != resizeleft || 
						gThis.top != resizetop || 
						gThis.width != resizewidth || 
						gThis.height != resizeheight)
						
						gThis.show(false);
				}
			}
		}
		
		
		/* 이지메이커에서 넘겨 받은 데이터를 json으로 만들기 */
		function makeData() {
			
			if (gThis.data instanceof Array) {
				jsonData = gThis.data;
				
			} else {
				if (gThis.gallery == 4 || gThis.gallery == 15) {
					jsonData = new Array();
					var dataArray = gThis.data.split(":");
					var cValueArray = new Array();
					var cValue = "";
					var temp1 = {};
					var values = new Array();
					
					for (var i = dataArray.length - 1; i >= 0 ; i--) {
						if (dataArray[i] == "") dataArray.splice(i, i + 1);
					}
					
					for (var i = 0; i < dataArray.length; i++) {
						var imsi = dataArray[i].split(",")[0];
						
						/* 첫 번째 데이터 */
						if (i == 0) {
							cValue = imsi;
							values.push({"index" : i});
						
						/* cValue가 같으면서 마지막 데이터 */
						} else if (cValue == imsi && i == dataArray.length - 1) {
							values.push({"index" : i});
							
							temp1["cValue"] = cValue;
							temp1["values"] = values;
							cValueArray.push(temp1);
						
						/* cValue가 다르면서 마지막 데이터 */
						} else if (cValue != imsi && i == dataArray.length - 1) {
							temp1["cValue"] = cValue;
							temp1["values"] = values;
							cValueArray.push(temp1);
							
							temp1 = {};
							values = new Array();
							
							cValue = imsi;
							values.push({"index" : i});
							
							temp1["cValue"] = cValue;
							temp1["values"] = values;
							cValueArray.push(temp1);
						
						/* cValue가 다른 경우 */
						} else if (cValue != imsi) {
							temp1["cValue"] = cValue;
							temp1["values"] = values;
							cValueArray.push(temp1);
							
							temp1 = {};
							values = new Array();
							
							cValue = imsi;
							values.push({"index" : i});
						
						/* cValue가 같은 경우 */
						} else {
							values.push({"index" : i});
						}
					}
					
					for (var i = 0; i < cValueArray.length; i++) {
						var temp1 = {};
						var values = new Array();
						
						for (var j = 0; j < cValueArray[i].values.length; j++) {
							var index = cValueArray[i].values[j].index;
							var dataArray2 = dataArray[index].split(",");
							var temp2 = {};
							cValue = dataArray2[0];
							temp2["xValue"] = dataArray2[1];
							temp2["yValue"] = dataArray2[2];
							if (gThis.gallery == 15) temp2["zValue"] = dataArray2[3];
							temp2["colorIndex"] = i;
							values.push(temp2);
						}
						
						temp1["cValue"] = cValueArray[i].cValue;
						temp1["values"] = values;
						jsonData.push(temp1);
					}
					
				} else if (gThis.gallery == 9 || gThis.gallery == 16 || gThis.gallery == 17) {
					jsonData = new Array();
					var dataArray = gThis.data.split(":");
					
					for (var i = dataArray.length - 1; i >= 0 ; i--) {
						if (dataArray[i] == "") dataArray.splice(i, i + 1);
					}
					
					for (var i = 0; i < dataArray.length; i++) {
						var temp1 = {};
						var imsiArray = dataArray[i].split(",");
						
						if (gThis.gallery == 9) {
							temp1["xValue"] = i;
							temp1["label"] = imsiArray[0];
							temp1["high"] = imsiArray[1];
							temp1["low"] = imsiArray[2];
							temp1["close"] = imsiArray[3];
							
						} else if (gThis.gallery == 16) {
							temp1["xValue"] = i;
							temp1["label"] = imsiArray[0];
							temp1["open"] = imsiArray[1];
							temp1["high"] = imsiArray[2];
							temp1["low"] = imsiArray[3];
							temp1["close"] = imsiArray[4];
							
						} else if (gThis.gallery == 17) {
							temp1["xValue"] = i;
							temp1["label"] = imsiArray[0];
							temp1["open"] = imsiArray[1];
							temp1["high"] = imsiArray[2];
							temp1["low"] = imsiArray[3];
							temp1["close"] = imsiArray[4];
							temp1["volume"] = imsiArray[5];
						}
						
						jsonData.push(temp1);
					}
					
				} else if (gThis.gallery == 22) {
					jsonData = new Array();
					var dataArray = gThis.data.split(":");
					
					for (var i = dataArray.length - 1; i >= 0 ; i--) {
						if (dataArray[i] == "") dataArray.splice(i, i + 1);
					}
					
					for (var i = 0; i < dataArray.length; i++) {
						var temp1 = {};
						var imsiArray = dataArray[i].split(",");
						
						temp1["task"] = imsiArray[0];
						temp1["start"] = imsiArray[1].replace(/<COLON>/g, ":");
						temp1["end"] = imsiArray[2].replace(/<COLON>/g, ":");
						temp1["percent"] = imsiArray[3];
						
						jsonData.push(temp1);
					}
					
				} else {
					jsonData = new Array();
					var dataArray = gThis.data.split(":");
					var xValueArray = dataArray[0].split(",");
					
					for (var i = dataArray.length - 1; i >= 0 ; i--) {
						if (dataArray[i] == "") dataArray.splice(i, i + 1);
					}
					
					for (var i = xValueArray.length - 1; i >= 0 ; i--) {
						if (xValueArray[i] == "") xValueArray.splice(i, i + 1);
					}
					
					for (var i = 1; i < dataArray.length; i++) {
						var temp1 = {};
						var values = new Array();
						var yValueArray = dataArray[i].split(",");
						
						for (var j = 0; j < xValueArray.length; j++) {
							var temp2 = {};
							temp2["xValue"] = xValueArray[j];
							temp2["yValue"] = yValueArray[j + 1];
							temp2["colorIndex"] = i - 1;
							values.push(temp2);
						}
						
						temp1["cValue"] = yValueArray[0];
						temp1["values"] = values;
						jsonData.push(temp1);
					}
				}
			}
		}
		
		
		/* svg 만들기 */
		function makeSvg() {
			d3.select("#" + gThis.controlId).select("svg").remove();
			d3.select("#" + gThis.controlId).select("div").remove();
			
			svg = d3.select("#" + gThis.controlId)
					.append("svg")
					.style("width", gThis.width + "px")
					.style("height", gThis.height + "px")
					.style("background", gThis.backcolor)
					.style("user-select", "none")  /* 드래그 방지*/
					;
			
			
			chart = svg.append("g").attr("class","chart");
			axis = svg.append("g").attr("class","axis");
			label = svg.append("g").attr("class","label");
			
			chart.append("rect").attr("class","chartBG");
			trendzone = chart.append("g").attr("class","trendzone");
			trendline = chart.append("g").attr("class","trendline");
		}
		
		
		/* 위로 갈수록 밝아지는 gradient 만들기 */
		function makeGradient() {
			
			gradient = chart.append("defs")
							.selectAll(".linearGradient")
							.data(gThis.seriesColor).enter()
							.append("linearGradient").attr("class", "linearGradient")
							.attr("id", function(d, i) { return gThis.controlId + "_gradient" + i; })
							.attr("x1", "100%")
							.attr("y1", "100%")
							.attr("x2", "100%")
							.attr("y2", "0%")
							.attr("spreadMethod", "pad");

			gradient.append("stop")
			    .attr("offset", "0%")
			    .attr("stop-color", function(d, i) { return d3.rgb(color(i)); })
			    .attr("stop-opacity", "1");
		
			gradient.insert("stop")
			    .attr("offset", "100%")
			    .attr("stop-color", function(d, i) { return d3.rgb(color(i)).brighter(0.2); })
			    .attr("stop-opacity", "1");
		}
		
		
		/* 툴팁 만들기 */
		function makeTooltip() {
			tooltip = d3.select("#" + gThis.controlId)
			.append('div')
		    .attr('class', 'tooltip')
		    .style("background", "white")
		    .style("box-shadow", "0 0 5px #999999")
		    .style("border-radius", "5px")
		    .style("color", "#333")
		    .style("font-size", gThis.fontSize + "px")
		    .style("padding", "5px")
		    .style("position", "absolute")
		    .style("text-align", "center")
		    .style("display", "none")
		    .style("opacity", 0)
		    .style("pointer-events", "none");

			tooltip.append('div').attr('class', 'tooltipText');
			
			tooltipLine = chart.append("rect")
			.attr("class","tooltipLine")
			.attr("width", 1)
			.style("fill", "#EEEEEE")
			.style("opacity", 0);
		}
		
		
		/* 라벨 만들기 */
		function makeLabel() {
			
			label.append("text")
				 .attr("class","charttitle")
				 .attr("y", 0)
				 .attr("text-anchor", "middle")
				 .attr("font-size", (gThis.fontSize + 4) + "px")
				 .attr("font-weight", "bold")
				 .text(gThis.charttitle);
			
			label.append("text")
				 .attr("class","bottomtitle")
				 .attr("y", 0)
				 .attr("text-anchor", "middle")
				 .attr("font-size", gThis.fontSize + "px")
				 .text(gThis.bottomtitle);
			
			label.append("text")
				 .attr("class","lefttitle")
				 .attr("transform", "rotate(-90)")
				 .attr("x", 0)
				 .attr("y", 0)
				 .attr("text-anchor", "middle")
				 .attr("font-size", gThis.fontSize + "px")
				 .text(gThis.lefttitle);
			
			label.append("text")
			 	 .attr("class","righttitle")
			 	 .attr("transform", "rotate(90)")
			 	 .attr("x", 0)
			 	 .attr("y", 0)
			 	 .attr("text-anchor", "middle")
			 	 .attr("font-size", gThis.fontSize + "px")
			 	 .text(gThis.righttitle);
			
			gettitle = label.select(".charttitle").node().getBBox();
			getbottomtitle = label.select(".bottomtitle").node().getBBox();
			getlefttitle = label.select(".lefttitle").node().getBBox();
			getrighttitle = label.select(".righttitle").node().getBBox();
			getlegend = "";
		}
		
		
		/*
		 * 개요 : 데이터를 stack데이터로 가공
		 */
		function getStackData() {
			
			function formatData(d) {
	            //d.xValue = parseDate(new Date(d.xValue));
	            group.forEach(function(c) {
	                d[c] = +d[c];
	            });
	            return d;
	        }
	        
	        function stackMin(stackData) {
	            return d3.min(stackData, function(d, i) {
	                return d[0];
	            });
	        }
	
	        function stackMax(stackData) {
	            return d3.max(stackData, function(d, i) {
	                return  d[1];
	            });
	        }
	        
			
			//데이터 JSON 모양 변경
			var group = [];
			var newData = "[";
			for (var i = 0; i < data[0].values.length; i++) {
				newData +=	"{ \"xValue\":\"" +  data[0].values[i].xValue + "\","
				for (var j = 0; j < data.length; j++) {
					group[j] =  data[j].cValue;
					newData += "\"" + data[j].cValue + "\":\"" + data[j].values[i].yValue + "\"";
					if (j+1 < data.length) newData+=","; 
				}
				newData += "}";
				if (i+1 < data[0].values.length) newData+=","; 
			}
			newData += "]";
			newData = JSON.parse(newData);
			
			
			/* Format Data */
			newData.forEach(function(d, i) {
	            d = formatData(d);
	        });
			
	        /* 누적형 */
			if (gThis.stacked == "1")
				stackData = d3.stack().keys(group).offset(d3.stackOffsetDiverging)(newData);
			
			/* 100% 누적형 */
			else if (gThis.stacked == "2")
				stackData = d3.stack().keys(group).offset(d3.stackOffsetExpand)(newData);
			
	        
	        /* stackData의 배열이 1개 일 때 음수가 있어도 음수 인식을 못해서 수동으로 변경함 */
	        if (stackData.length == 1) {
	        	for (var i = 0; i < stackData[0].length; i++) {
	        		var num0 = stackData[0][i][0];
	        		var num1 = stackData[0][i][1];
	        		
	        		if (num1 < 0) {
	        			stackData[0][i][0] = num1;
	        			stackData[0][i][1] = num0;
	        		}
	        	}
	        }
	        
	        /* 
			 * 필요한 컬럼 추가 
			 */
	        var dataIndex = 0;
	        for (var i = 0; i < stackData.length; i++) {
	        	for (var j = 0; j < data.length; j++) {
	        		if (stackData[i].key == data[j].cValue) {
	        			stackData[i].colorIndex = data[j].colorIndex;
	        			
	        			for (var k = 0; k < stackData[i].length; k++) {
	        				stackData[i][k].colorIndex = data[j].colorIndex;
	        			}
	        			
	        			break;
	        		}
	        	}
	        }
	        
	        
	        /* x, y의 max값과 min값 구하기 */
			ymax = this.ymax * 1;
			ymin = this.ymin * 1;
			
			max = d3.max(stackData, stackMax);
			min = d3.min(stackData, stackMin);
			
			if (isNaN(ymax)) ymax = max;
			else ymax = ymax > max ? ymax : max;
			
			if (stripemax != null && stripemax > ymax) ymax = stripemax;
			
			
			if ((isNaN(ymin) || ymin == 0) && min > 0) ymin = 0; 
			else ymin = ymin < min ? ymin : min;
			
			if (stripemin != null && stripemin < ymin) ymin = stripemin;
			
			yStart = ymin > 0 ? ymin : 0;
		}
		
		/*
		 * 개요 : 데이터 타입 포맷
		 */
		function formatData() {
			
			if (gThis.gallery == 4) {
				data.forEach(function(d, i) { 
					  d.values.forEach(function(d, i) {
						d.xValue = +d.xValue;
					    d.yValue = +d.yValue;
					  });
					});
				
			} else if (gThis.gallery == 15) {
				data.forEach(function(d, i) { 
					  d.values.forEach(function(d, i) {
						d.xValue = +d.xValue;
					    d.yValue = +d.yValue;
					    d.zValue = +d.zValue;
					  });
					});
				
			} else if (gThis.gallery == 9 || gThis.gallery == 16 || gThis.gallery == 17) {
				data.forEach(function(d, i) {
					if (d.open != null) d.open = +d.open;
					d.high = +d.high;
					d.low = +d.low;
					d.close = +d.close;
					if (d.volume != null) d.volume = +d.volume;
				});
				
			} else if (gThis.gallery == 97) {
				var parseDate = d3.timeParse("%d-%b-%y");
				data.forEach(function(d, i) { 
				    d.date = parseDate(d.date) != null ? parseDate(d.date) : d.date;
				    d.high = +d.high;
				    d.low = +d.low;
				    d.open = +d.open;
				    d.close = +d.close;
				});
			
//			} else if (gThis.gallery == 1 || gThis.gallery == 6) {
//				var parseDate = d3.timeParse("%Y");
//				data.forEach(function(d, i) { 
//				  d.values.forEach(function(d, i) {
//				    d.xValue = parseDate(d.xValue) != null ? parseDate(d.xValue) : d.xValue;
//				    d.yValue = +d.yValue;    
//				  });
//				});
					
			} else if (gThis.gallery == 21){
				data.forEach(function(d, i) { 
					  d.values.forEach(function(d, i) {
					    d.yValue = Math.abs(+d.yValue);    
					  });
					});
				
			} else if (gThis.gallery == 22){
				
			} else {
				data.forEach(function(d, i) {
					d.values.forEach(function(d, i) {
						d.yValue = +d.yValue;    
					});
				});
			}
			
			/* stack인데 percent이면 음수는 사용 할 수 없으므로 양수로 변환 */
			if (gThis.stacked == "2") {
				data.forEach(function(d, i) { 
					d.values.forEach(function(d, i) {
						d.yValue = (d.yValue < 0 ? d.yValue * -1 : d.yValue);    
					});
				});
			}
		}
		
		
		/*
		 * 개요 : 범례 만들기 
		 */
		function makeLegend() {
			
			var legendsWidth;  //범례들마다 같은 넓이를 주기 위한 변수
			
			if (gThis.gallery == 5 || gThis.gallery == 13) {
				//legends 최대 넓이 구하기 시작 -------------------------------------------------
				legend = svg.append("g").attr("class", "legend");
				var legends = legend.selectAll(".legend")
									.data(data).enter()
									.append("g")
									.attr("class", "legends");
				
				legends.append("rect").attr("class","legend-tiles")
        	  		   .attr("x", 0)
        	  		   .attr("width",  gThis.fontSize)
        	  		   .attr("height", gThis.fontSize);
				
				legends.append("text").attr("class","legend-labels")
		    		   .attr("x", gThis.fontSize + 2)
		    		   .attr("font-size", gThis.fontSize + "px")
		    		   .text(function(d, i) { return d.cValue; });
				
				legendsWidth = svg.select(".legend").node().getBBox().width;
				svg.select(".legend").remove();
				//legends 최대 넓이 구하기 종료 -------------------------------------------------
				
				
				
				for (var i = 1; i <= data.length; i++) {  //데이터 개수 만큼 반복
					if (gThis.legendType == "right") {
						i = data[0].values.length;
					}
					
					var n = Math.ceil(data[0].values.length / i); //행에  표시할 legends 개수
					var translateX = 0;  //legends x축 위치
					
					legend = svg.append("g").attr("class", "legend");
					
					for (var j = 0; j < i; j++) {  //legends 행 그리기
						for (var k = 0; k < n ; k++) {  //legends 열 그리기 
							var me = j * n + k;  //데이터의 현재 위치
							
							if (me >= data[0].values.length) break;
							
							if (i == 1 && me > 0) {
								//legend 행이 1개 이면 상대위치 간격 주기
								var getlegends = legend.selectAll(".legends").filter(":nth-child(" + me + ")").node().getBBox();
								translateX += getlegends.width + 15;		
								
							} else {
								//legend 행이 2개 이상이면 모두 같은 간격 주기
								translateX = (legendsWidth + 15) * k;
							}
							
							var legends = legend.append("g").attr("class", "legends")
												.attr("transform", "translate(" + translateX  + ", 0)") ;
							
							/* 동그라미 아이콘 만들기 */
							legends.append("circle").attr("class","legend-tiles")
			        		   .attr("cx", gThis.fontSize / 2)
			        		   .attr("cy", (j * (gThis.fontSize + 2)) + (j * 2) + (gThis.fontSize / 2))
			        		   .attr("r", gThis.fontSize / 2)
			        		   .attr("fill", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : "url(#" + gThis.controlId + "_gradient" + me + ")");
							
							/* Doughnut 차트이면 동그라미 아이콘 안에 더 작은 흰색 동그라미 아이콘 만들기  */
							if (gThis.gallery == 13) {
								legends.append("circle").attr("class","legend-tiles")
				        		   .attr("cx", gThis.fontSize * 0.5)
				        		   .attr("cy", (j * (gThis.fontSize + 2)) + (j * 2) + (gThis.fontSize / 2))
				        		   .attr("r", gThis.fontSize * 0.3)
				        		   .style("fill", "#ffffff")
				        		   .style("stroke", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : "url(#" + gThis.controlId + "_gradient" + me + ")");
							}
							
							
							legends.append("text").attr("class","legend-labels")
				    		   .attr("x", gThis.fontSize + 2)
				    		   .attr("y", (j * (gThis.fontSize + 2)) + (j * 2) + gThis.fontSize - 1.5)
				    		   .attr("fill", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : "#000000")
				    		   .attr("font-size", gThis.fontSize + "px")
				    		   .text(data[0].values[me].xValue);
							
							
							var getlegends = legends.node().getBBox();
							var imsiData = new Array();
							imsiData.push(data[me]);

							var cover = legends
							.data(imsiData)
							.append("rect").attr("class", "legend-cover")
							.attr("x", getlegends.x)
							.attr("y", getlegends.y)
							.attr("width", getlegends.width)
							.attr("height", getlegends.height)
							.attr("cursor", "pointer")
							.style('opacity', 0)

						}
					}
					
					getlegend = legend.node().getBBox();
					if (gThis.width * 0.7 > getlegend.width) break;
					
					legend.remove();
				}
				
				
				
			} else if (data.length != 1 && gThis.gallery != 9 && gThis.gallery != 16 && gThis.gallery != 17 && gThis.gallery != 21 && gThis.gallery != 22 &&gThis.gallery != 97) {
				//legends 최대 넓이 구하기 시작 -------------------------------------------------
				legend = svg.append("g").attr("class", "legend");
				var legends = legend.selectAll(".legend")
									.data(data).enter()
									.append("g")
									.attr("class", "legends");
				
				if (gThis.gallery == 4) {
					legends.append("path").attr("class","legend-tiles")
		        		   .attr("d", d3.symbol().size([gThis.fontSize * 7]).type(sybolArray[0]))
		        		   .attr("transform", "translate(" + (gThis.fontSize / 2) + ", 0)");
					
				} else {
					legends.append("rect").attr("class","legend-tiles")
	        	  		   .attr("x", 0)
	        	  		   .attr("width",  gThis.fontSize)
	        	  		   .attr("height", gThis.fontSize);
				}
				
				legends.append("text").attr("class","legend-labels")
		    		   .attr("x", gThis.fontSize + 2)
		    		   .attr("font-size", gThis.fontSize + "px")
		    		   .text(function(d, i) { return d.cValue; });
				
				legendsWidth = svg.select(".legend").node().getBBox().width;
				svg.select(".legend").remove();
				//legends 최대 넓이 구하기 종료 -------------------------------------------------
				
				
				
				for (var i = 1; i <= data.length; i++) {  //데이터 개수 만큼 반복
					if (gThis.legendType == "right") i = data.length;
					
					var n = Math.ceil(data.length / i); //행에  표시할 legends 개수
					var translateX = 0;  //legends x축 위치
					
					legend = svg.append("g").attr("class", "legend");
					
					for (var j = 0; j < i; j++) {  //legends 행 그리기
						for (var k = 0; k < n ; k++) {  //legends 열 그리기 
							var me = j * n + k;  //데이터의 현재 위치
							
							if (me >= data.length) break;
							
							if (i == 1 && me > 0) {
								//legend 행이 1개 이면 상대위치 간격 주기
								var getlegends = legend.selectAll(".legends").filter(":nth-child(" + me + ")").node().getBBox();
								translateX += getlegends.width + 15;		
								
							} else {
								//legend 행이 2개 이상이면 모두 같은 간격 주기
								translateX = (legendsWidth + 15) * k;
							}
							
							var legends = legend.append("g").attr("class", "legends").attr("transform", "translate(" + translateX  + ", 0)") ;
							
							if (gThis.gallery == 1 || gThis.gallery == 3 || gThis.gallery == 8) {
								make_legend_titles_line();
								
							} else if (gThis.gallery == 2) {
								if (gThis.stacked) make_legend_titles_rect();
								else make_legend_titles_column();
								
							} else if (gThis.gallery == 4) {
								make_legend_titles_scatter();
							
							} else if (gThis.gallery == 6 || gThis.gallery == 19) {
								make_legend_titles_area();
								
							} else if (gThis.gallery == 15) {
								make_legend_titles_bubble();
								
							}  else if (gThis.gallery == 20) {
								if (gThis.stacked) make_legend_titles_rect();
								else make_legend_titles_bar();
								
							} else if (gThis.gallery == 7) {
								var renderas = data[me].renderas == null ? "" : data[me].renderas;
								
								if (renderas.toLowerCase() == "line") make_legend_titles_line();
								else if (renderas.toLowerCase() == "area") make_legend_titles_area();
								else make_legend_titles_column();
								
							} else {
								make_legend_titles_rect();
							}
							
							make_legend_labels();
							
							make_legend_cover();
						}
					}
					
					getlegend = legend.node().getBBox();
					if (gThis.width * 0.7 > getlegend.width) break;  /* 범례의 넓이가 전체 넓이의 70% 이하가 되면 종료 */
					
					legend.remove();
				}
				
				
				
				function make_legend_titles_line() {
					var line = d3.line().x(function(d, i) { return d.x; }).y(function(d, i) { return d.y; }).curve(d3.curveLinear);
					
					legends.append("path").attr("class","legend-tiles")
	        			.attr("d", function(d, i) { 
		        			var imsiData = new Array();
				            var temp = {};
				            temp["x"] = 0;
				            temp["y"] = (j * (gThis.fontSize + 2)) + (j * 2) + (gThis.fontSize / 2);
				            imsiData.push(temp);
				               
				            temp = {};
				            temp["x"] = gThis.fontSize;
				            temp["y"] = (j * (gThis.fontSize + 2)) + (j * 2) + (gThis.fontSize / 2);
				            imsiData.push(temp);
				                
		        			return line(imsiData);
		        		})
		        		.style('stroke', gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : color(me))
		        		.style('stroke-width', '1px')
		        		.style('fill', 'none')
		        		.style('stroke-linecap', 'round');
					
					legends.append("circle").attr("class","legend-tiles")
	        			.attr("cx", gThis.fontSize * 0.5)
	        			.attr("cy", (j * (gThis.fontSize + 2)) + (j * 2) + (gThis.fontSize / 2))
	        			.attr("r", gThis.fontSize * 0.25)
	        			.style("fill", "#ffffff")
	        			.style("stroke", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : color(me))
	        			.style('stroke-width', '1px');
				}
				
				function make_legend_titles_column() {
					legends.append("rect").attr("class","legend-tiles")
			 	  		   .attr("x", 0)
			 	  		   .attr("y", (j * (gThis.fontSize + 2)) + (j * 2) + (gThis.fontSize * 0.3))
			 	  		   .attr("width", gThis.fontSize * 0.25)
			 	  		   .attr("height", gThis.fontSize * 0.7)
			 	  		   .attr("fill", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : "url(#" + gThis.controlId + "_gradient" + me + ")");
					
					legends.append("rect").attr("class","legend-tiles")
			 	  		   .attr("x", gThis.fontSize * 0.375)
			 	  		   .attr("y", (j * (gThis.fontSize + 2)) + (j * 2))
			 	  		   .attr("width", gThis.fontSize * 0.25)
			 	  		   .attr("height", gThis.fontSize)
			 	  		   .attr("fill", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : "url(#" + gThis.controlId + "_gradient" + me + ")");
					
					legends.append("rect").attr("class","legend-tiles")
			 	  		   .attr("x", gThis.fontSize * 0.75)
			 	  		   .attr("y", (j * (gThis.fontSize + 2)) + (j * 2) + (gThis.fontSize * 0.6))
			 	  		   .attr("width", gThis.fontSize * 0.25)
			 	  		   .attr("height", gThis.fontSize * 0.4)
			 	  		   .attr("fill", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : "url(#" + gThis.controlId + "_gradient" + me + ")");
				}
				
				function make_legend_titles_scatter() {
					legends.append("path").attr("class","legend-tiles")
				 		   .attr("d", d3.symbol().size([gThis.fontSize * 7]).type(sybolArray[me]))
				 		   .attr("transform", "translate(" + (gThis.fontSize / 2) + ", " + ((j * (gThis.fontSize + 2)) + (j * 2) + (gThis.fontSize / 2)) + ")")
				 		   .attr("fill", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : "url(#" + gThis.controlId + "_gradient" + me + ")");
				}
				
				function make_legend_titles_area() {
					var area = d3.area()
					   			 .x(function(d, i) { return d.x; })
					   			 .y0(function(d, i) { return d.y0; })
					   			 .y1(function(d, i) { return d.y1; })
					   			 .curve(curveArray[gThis.curveType]);
						
					legends.append("path").attr("class","legend-tiles")
						.attr("d", function(d, i) { 
							var imsiData = new Array();
							var temp = {};
							temp["x"] = 0;
							temp["y0"] = (j * (gThis.fontSize + 2)) + (j * 2) + gThis.fontSize;
							temp["y1"] = (j * (gThis.fontSize + 2)) + (j * 2) + (gThis.fontSize * 0.7);
							imsiData.push(temp);
							
							temp = {};
							temp["x"] = gThis.fontSize * 0.3;
							temp["y0"] = (j * (gThis.fontSize + 2)) + (j * 2) + gThis.fontSize;
							temp["y1"] = (j * (gThis.fontSize + 2)) + (j * 2) + (gThis.fontSize * 0.2);
							imsiData.push(temp);
							
							temp = {};
							temp["x"] = gThis.fontSize * 0.6;
							temp["y0"] = (j * (gThis.fontSize + 2)) + (j * 2) + gThis.fontSize;
							temp["y1"] = (j * (gThis.fontSize + 2)) + (j * 2) + (gThis.fontSize * 0.7);
							imsiData.push(temp);
							
							temp = {};
							temp["x"] = gThis.fontSize;
							temp["y0"] = (j * (gThis.fontSize + 2)) + (j * 2) + gThis.fontSize;
							temp["y1"] = (j * (gThis.fontSize + 2)) + (j * 2);
							imsiData.push(temp);
							
							return area(imsiData);
					   })
					   .style("fill", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : "url(#" + gThis.controlId + "_gradient" + me + ")")
					   .style('opacity', 0.7);
				}
				
				function make_legend_titles_bubble() {
					legends.append("circle").attr("class","legend-tiles")
		    			   .attr("cx", gThis.fontSize / 2)
		    			   .attr("cy", (j * (gThis.fontSize + 2)) + (j * 2) + (gThis.fontSize / 2))
		    			   .attr("r", gThis.fontSize / 2)
		    			   .attr("fill", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : "url(#" + gThis.controlId + "_gradient" + me + ")");
				}
				
				function make_legend_titles_bar() {
					legends.append("rect").attr("class","legend-tiles")
			 	  		   .attr("x", 0)
			 	  		   .attr("y", (j * (gThis.fontSize + 2)) + (j * 2))
			 	  		   .attr("width", gThis.fontSize * 0.7)
			 	  		   .attr("height", gThis.fontSize * 0.25)
			 	  		   .attr("fill", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : "url(#" + gThis.controlId + "_gradient" + me + ")");
					
					legends.append("rect").attr("class","legend-tiles")
			 	  		   .attr("x", 0)
			 	  		   .attr("y", (j * (gThis.fontSize + 2)) + (j * 2) + (gThis.fontSize * 0.375))
			 	  		   .attr("width", gThis.fontSize)
			 	  		   .attr("height", gThis.fontSize * 0.25)
			 	  		   .attr("fill", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : "url(#" + gThis.controlId + "_gradient" + me + ")");
					
					legends.append("rect").attr("class","legend-tiles")
			 	  		   .attr("x", 0)
			 	  		   .attr("y", (j * (gThis.fontSize + 2)) + (j * 2) + (gThis.fontSize * 0.75))
			 	  		   .attr("width", gThis.fontSize * 0.4)
			 	  		   .attr("height", gThis.fontSize * 0.25)
			 	  		   .attr("fill", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : "url(#" + gThis.controlId + "_gradient" + me + ")");
				}
				
				function make_legend_titles_rect() {
					legends.append("rect").attr("class","legend-tiles")
		     	  		.attr("x", 0)
		     	  		.attr("y", (j * (gThis.fontSize + 2)) + (j * 2))
		     	  		.attr("width", gThis.fontSize)
		     	  		.attr("height", gThis.fontSize)
		     	  		.attr("fill", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : "url(#" + gThis.controlId + "_gradient" + me + ")");
				}
				
				function make_legend_labels() {
					legends.append("text").attr("class","legend-labels")
		    		   .attr("x", gThis.fontSize + 2)
		    		   .attr("y", (j * (gThis.fontSize + 2)) + (j * 2) + gThis.fontSize - 1.5)
		    		   .attr("fill", gThis.outLegendData.indexOf(me) > -1 ? "#CBCBCB" : "#000000")
		    		   .attr("font-size", gThis.fontSize + "px")
		    		   .text(data[me].cValue);
				}
				
				function make_legend_cover() {
					var getlegends = legends.node().getBBox();
					var imsiData = new Array();
					imsiData.push(data[me]);

					var cover = legends
						.data(imsiData)
						.append("rect").attr("class", "legend-cover")
						.attr("x", getlegends.x)
						.attr("y", getlegends.y)
						.attr("width", getlegends.width)
						.attr("height", getlegends.height)
						.attr("cursor", "pointer")
						.style('opacity', 0)
						.on("click", function(d, i) {
							var index = gThis.outLegendData.indexOf(d.colorIndex);
							if (index > -1) {
								gThis.outLegendData.splice(index, 1)
							} else {
								gThis.outLegendData[gThis.outLegendData.length] = d.colorIndex;
							}
							
							//if (gThis.outLegendData.length == jsonData.length) gThis.outLegendData = [];  /* gThis.outLegendData에 모든 colorIndex가 있으면 데이터가 하나도 없어서 에러가 나니까 초기화 */
							
							gThis.show(false);
					    });
				}
			}
		}
		
		
		/*
		 * 개요 : 기준선, 영역강조 만들기
		 * order 0 : json 데이터를 만든다.
		 * order 1 : label을 먼저 만들어서 크기를 측정한다.
		 * order 2 : line 및 zone을 만든 후  label의 위치를 조정한다.
		 */
		function makeTrend(order) {
			if (order == 0) {
				/* constantline json으로 만들기 */
				if (gThis.constantline == null) gThis.constantline = "";
				var constantlineArray = gThis.constantline.split(";");
				var colorIndex = 0;
				
				for (var i = 0; i < constantlineArray.length; i+=3) {
					var min = constantlineArray[i] == "" ? "NaN" : constantlineArray[i] * 1;
					var max = constantlineArray[i + 1] == "" ? "NaN" : constantlineArray[i + 1] * 1;
					var label = constantlineArray[i + 2];
					
					if (isNaN(min) == false && isNaN(max) == false) {
						if (min > max) {
							var temp = min;
							min = max;
							max = temp;
						}
						constantline.push({"min":min, "max":max, "label":label, "colorIndex":colorIndex});
						colorIndex++;
					}
				}
				
				
				/* stripe json으로 만들기 */
				if (gThis.stripe == null) gThis.stripe = "";
				var stripeArray = gThis.stripe.split(";");
				var colorIndex = 0;
				
				for (var i = 0; i < stripeArray.length; i+=2) {
					var value = stripeArray[i] == "" ? "NaN" : stripeArray[i] * 1;
					var label = stripeArray[i + 1];
					
					if (isNaN(value) == false) {
						stripe.push({"value":value, "label":label, "colorIndex":(constantline.length + colorIndex)});
						colorIndex++;
					}
				}
				
			} else if (order == 1) {
				/* trendzone label 만들기 */
				trendzone.append("g").attr("class", "labels")
				.selectAll("text")
				.data(constantline)
				.enter().append("text")
				.attr("font-size", gThis.fontSize + "px")
				.attr("text-anchor", gThis.gallery == 20 ? "middle" : null)
				.style("fill", function(d, i) { return highlightColor(d.colorIndex); })
				.attr("transform", function(d, i) { return "translate(0,0)"; })
				.text(function(d, i) { return d.label; });
				
				/* trendzone text 개행 */
				for (var i = 0; i < constantline.length; i++) {
					var textNode = trendzone.select(".labels").selectAll("text").filter(":nth-child(" + (i + 1) + ")");
					var getText = textNode.node().getBBox();
					var text = textNode.text();
					var br = "{br}";
					
					if (text.indexOf(br) > -1) {
						textNode.text("");
						var textArray = text.split(br);
						
						for (var j = 0; j < textArray.length; j++) {
							textNode.append("tspan")
							.attr("dy", j == 0 ? 0 : gThis.fontSize)
							.attr("x", "0")
							.attr("aa", 1)
							.text(textArray[j]);
						}
					}
				}
				
				
				/* trendline label 만들기 */
				trendline.append("g").attr("class", "labels")
				.selectAll("text")
				.data(stripe)
				.enter().append("text")
				.attr("font-size", gThis.fontSize + "px")
				.attr("text-anchor", gThis.gallery == 20 ? "middle" : null)
				.style("fill", function(d, i) { return highlightColor(d.colorIndex); })
				.attr("transform", function(d, i) { return "translate(0,0)"; })
				.text(function(d, i) { return d.label; });
				
				/* trendline text 개행 */
				for (var i = 0; i < stripe.length; i++) {
					var textNode = trendline.select(".labels").selectAll("text").filter(":nth-child(" + (i + 1) + ")");
					var getText = textNode.node().getBBox();
					var text = textNode.text();
					var br = "{br}";
					
					if (text.indexOf(br) > -1) {
						textNode.text("");
						var textArray = text.split(br);
						
						for (var j = 0; j < textArray.length; j++) {
							textNode.append("tspan")
							.attr("dy", j == 0 ? 0 : gThis.fontSize)
							.attr("x", "0")
							.text(textArray[j]);
						}
					}
				}
				
				
				/* trendwidth, trendheight 구하기 */
				gettrendzone = trendzone.node().getBBox();
				gettrendline = trendline.node().getBBox();
				
				if (gettrendzone.width > 0 || gettrendline.width > 0) {
					trendwidth = gettrendline.width > gettrendzone.width ? gettrendline.width : gettrendzone.width;
					trendwidth += trendmargin;
				}
				
				if (gettrendzone.height > 0 || gettrendline.height > 0) {
					trendheight = gettrendline.height > gettrendzone.height ? gettrendline.height : gettrendzone.height;
				}
				
			} else if (order == 2) {
				if (gThis.gallery == 20) {
					var getbottomAxis = axis.select(".bottomAxis").node().getBBox();
					
					/* trendzone zone 만들기 */
					trendzone.append("g").attr("class", "zones")
					.selectAll("rect")
					.data(constantline)
					.enter().append("rect")
					.attr("x", function(d, i) { return bottomScale(d.min); })
					.attr("y", leftScale.range()[1])
					.attr("width", function(d, i) { return bottomScale(d.max) - bottomScale(d.min); })
					.attr("height", leftScale.range()[0] - leftScale.range()[1])
					.style("fill", function(d, i) { return highlightColor(d.colorIndex); });
					
					/* trendzone label 위치조정 */
					trendzone.select(".labels").selectAll("text").attr("transform", function(d, i) { return "translate(" + (bottomScale(d.min) + ((bottomScale(d.max) - bottomScale(d.min)) / 2)) + "," + (leftScale.range()[0] + getbottomAxis.height + (trendmargin / 2) + (- d3.select(this).node().getBBox().y)) + ")"; });
					
					
					/* trendline line 만들기 */
					trendline.append("g").attr("class", "lines")
					.selectAll("rect")
					.data(stripe)
					.enter().append("rect")
					.attr("x",  function(d, i) { return bottomScale(d.value); })
					.attr("y", leftScale.range()[1])
					.attr("width", 1)
					.attr("height", leftScale.range()[0] - leftScale.range()[1])
					.style("fill", function(d, i) { return highlightColor(d.colorIndex); });
					
					/* trendline label 위치조정 */
					trendline.select(".labels").selectAll("text").attr("transform", function(d, i) { return "translate(" + bottomScale(d.value) + "," + (leftScale.range()[0] + getbottomAxis.height + (trendmargin / 2) + (- d3.select(this).node().getBBox().y)) + ")"; });
					
				} else {
					/* Candlestick은 rightScale만 있어서 leftScale에 담아서 사용 */
					if (gThis.gallery == 9 || gThis.gallery == 16 || gThis.gallery == 17) leftScale = rightScale;
					
					/* trendzone zone 만들기 */
					trendzone.append("g").attr("class", "zones")
					.selectAll("rect")
					.data(constantline)
					.enter().append("rect")
					.attr("x", bottomScale.range()[0])
					.attr("y", function(d, i) { return leftScale(d.max); })
					.attr("width", bottomScale.range()[1] - bottomScale.range()[0])
					.attr("height", function(d, i) { return leftScale(d.min) - leftScale(d.max); })
					.style("fill", function(d, i) { return highlightColor(d.colorIndex); });
					
					/* trendzone label 위치조정 */
					trendzone.select(".labels").selectAll("text").attr("transform", function(d, i) { return "translate(" + (bottomScale.range()[1] + trendmargin) + "," + (leftScale(d.max) + ((leftScale(d.min) - leftScale(d.max)) / 2) + (- d3.select(this).node().getBBox().y) - (d3.select(this).node().getBBox().height / 2)) + ")"; });
					
					
					/* trendline line 만들기 */
					trendline.append("g").attr("class", "lines")
					.selectAll("rect")
					.data(stripe)
					.enter().append("rect")
					.attr("x", bottomScale.range()[0])
					.attr("y", function(d, i) { return leftScale(d.value); })
					.attr("width", bottomScale.range()[1] - bottomScale.range()[0])
					.attr("height", 1)
					.style("fill", function(d, i) { return highlightColor(d.colorIndex); });
					
					/* trendline label 위치조정 */
					trendline.select(".labels").selectAll("text").attr("transform", function(d, i) { return "translate(" + (bottomScale.range()[1] + trendmargin) + "," + (leftScale(d.value) + (- d3.select(this).node().getBBox().y) - (d3.select(this).node().getBBox().height / 2)) + ")"; })
				}
			}
		}
		
		
		/* 데이터 역순 정렬 */
		function inverseOrder() {
			if (gThis.gallery == 20 || gThis.gallery == 14) {
				data.forEach(function(d, i) {
					if (d.values != undefined) {
						return d.values.reverse();
					}
				});
			}
		}
		
		
		/* 
		 * 필요한 컬럼 추가 
		 * colorIndex = 범례에서 불 꺼진 데이터 삭제전 data의 index
		 * dataIndex = 범례에서 불 꺼진 데이터 사제후 data의 index
		 * index = data의 values 안에 index
		 */
		function setColumn() {
			var dataIndex = 0;
			
			data.forEach(function(d, i) {
				d.colorIndex = i;
				var index = 0;
				if (d.values != undefined) {
					d.values.map(function(b){ 
						b.cValue = d.cValue;
						b.colorIndex = i;
						b.dataIndex = dataIndex;
						b.index = index++;
						return b;
					});
					
					if (gThis.outLegendData.indexOf(data[i].colorIndex) == -1) dataIndex++;
				}
			});
			
			if (gThis.gallery == 99) {
				data.forEach(function(d, i) { 
					sum = 0;  /* 누적합계 */
					  d.values.forEach(function(d, i) {
						  sum += d.yValue;
						  d["yValueT"] = sum;  
					  });
					});
			}
			
			if (gThis.gallery == 21) {
				/* 계열 한 개만 사용 */
				if (data.length > 1) data = data.splice(0, 1);
				
				/* yValue 내림차순 정렬 */
				function custonSort(a, b) { 
					if(a.yValue == b.yValue){ return 0} return a.yValue < b.yValue ? 1 : -1;
				}
				
				data[0].values.sort(custonSort);
				
				data.forEach(function(d, i) { 
					total = d3.sum(d.values, function(d) { return d.yValue; });  /* 총합계 */
					sum = 0;  /* 누적합계 */
					
					d.values.forEach(function(d, i) {
						d["total"] = total;
						
						sum += d.yValue;
						d["yValueT"] = sum; 
					});
				});
			}
			
			/* 보조축 */
			if (gThis.gallery == 7) {
				data.forEach(function(d, i) {
					var left_right = "left";  
					
					if (seriescode2.indexOf(d.cValue) > -1) left_right = "right";
					
					d.left_right = left_right;
					
					d.values.forEach(function(d, i) {
						d.left_right = left_right;
					});
				});
			}
		}
		
		
		/* 범례에서 불 꺼진 데이터 삭제 */
		function outLegend() {
			for (var i = data.length - 1; i >= 0; i--) {
				if (gThis.outLegendData.indexOf(data[i].colorIndex) > -1) {
					
					/* 모두 불이 꺼져서 데이터를 다 삭제하면 에러가 나서 데이터 하나 남기고 값을  0으로 바꿈 */
					if (data.length == 1) {
						gThis.outDataFlag = "true"; 
						data.forEach(function(d, i) {
							if (d.values != undefined) {
								d.values.map(function(b){ 
									b.yValue = 0;
									return b;
								})
							}
						});
						
					} else {
						gThis.outDataFlag = "false";
						data.splice(i, 1);
					}
				}
			}
		}
		
		
		/* x, y의 max값과 min값 구하기 */
		function getMaxMin() {
			
			/* 기준선, 영역강조 max, min 구하기 */
			stripemax = d3.max(stripe, function(d, i) { return d.value; });
			stripemin = d3.min(stripe, function(d, i) { return d.value; });
			constantlinemax = d3.max(constantline, function(d, i) { return d.max; });
			constantlinemin = d3.min(constantline, function(d, i) { return d.min; });
			
			if (stripemax != null && constantlinemax != null) trendmax = stripemax > constantlinemax ? stripemax : constantlinemax;
			else if (stripemax != null && constantlinemax == null) trendmax = stripemax;
			else if (stripemax == null && constantlinemax != null) trendmax = constantlinemax;
			
			if (stripemin != null && constantlinemin != null) trendmax = stripemin > constantlinemin ? stripemin : constantlinemin;
			else if (stripemin != null && constantlinemin == null) trendmin = stripemin;
			else if (stripemin == null && constantlinemin != null) trendmin = constantlinemin;
			
			
			
			
			var max = "";
			var min = "";
			
			/* ymax 구하기 */
			if (gThis.gallery == 9 || gThis.gallery == 16 || gThis.gallery == 17 || gThis.gallery == 97)
				max = d3.max(data, function(d, i) { return d.high; });
			else if (gThis.gallery == 99)
				max = d3.max(data, function(d, i) { return d3.max(d.values, function(d, i) { return d.yValueT; }); });
			else if (gThis.gallery == 7) {
				max = d3.max(data, function(d, i) { 
						if (seriescode2.indexOf(d.cValue) == -1) {
							return d3.max(d.values, function(d, i) { return d.yValue; });
						}
					});
			} else if (gThis.gallery == 22) {
				
			} else
				max = d3.max(data, function(d, i) { return d3.max(d.values, function(d, i) { return d.yValue; }); });
			
			if (isNaN(ymax)) ymax = max;
			else ymax = ymax > max ? ymax : max;
			
			if (trendmax != null && trendmax > ymax) ymax = trendmax;
			else if (trendmax != null && ymax == null) ymax = trendmax;
			
			
			/* ymax2 구하기 */
			if (gThis.gallery == 7) {
				max = d3.max(data, function(d, i) { 
						if (seriescode2.indexOf(d.cValue) > -1) {
							return d3.max(d.values, function(d, i) { return d.yValue; });
						}
					});
				
				if (isNaN(ymax2)) ymax2 = max;
				else ymax2 = ymax2 > max ? ymax2 : max;
			}
			
			
			/* ymin 구하기 */
			if (gThis.gallery == 9 || gThis.gallery == 16 || gThis.gallery == 17 || gThis.gallery == 97)
				min = d3.min(data, function(d, i) { return d.low; });
			else if (gThis.gallery == 7) {
				min = d3.min(data, function(d, i) { 
					if (seriescode2.indexOf(d.cValue) == -1) {
						return d3.min(d.values, function(d, i) { return d.yValue; });
					}
				});
			} else if (gThis.gallery == 22) {
				
			} else
				min = d3.min(data, function(d, i) { return d3.min(d.values, function(d, i) { return d.yValue; }); });
			
			if (gThis.gallery == 9 || gThis.gallery == 16 || gThis.gallery == 17 || gThis.gallery == 97) ymin = min;
			else if ((isNaN(ymin) || ymin == 0) && min > 0) ymin = 0; 
			else ymin = ymin < min ? ymin : min;
			
			if (trendmin != null && trendmin < ymin) ymin = trendmin;
			
			yStart = ymin > 0 ? ymin : 0;
			
			
			/* ymin2 구하기 */
			if (gThis.gallery == 7) {
				min = d3.min(data, function(d, i) { 
					if (seriescode2.indexOf(d.cValue) > -1) {
						return d3.min(d.values, function(d, i) { return d.yValue; });
					}
				});
				
				if ((isNaN(ymin2) || ymin2 == 0) && min > 0) ymin2 = 0; 
				else ymin2 = ymin2 < min ? ymin2 : min;
				
				yStart2 = ymin2 > 0 ? ymin2 : 0;
			}
			
			
			/* xmax, xmin 구하기 */
			if (gThis.gallery == 4 || gThis.gallery == 15) {
				max = d3.max(data, function(d, i) { return d3.max(d.values, function(d, i) { return d.xValue; }); });
				
				if (isNaN(xmax)) xmax = max;
				else xmax = xmax > max ? xmax : max;
				
				
				min = d3.min(data, function(d, i) { return d3.min(d.values, function(d, i) { return d.xValue; }); });
				
				if ((isNaN(xmin) || xmin == 0) && min > 0) xmin = 0;  
				else xmin = xmin < min ? xmin : min;
				
				xStart = xmin > 0 ? xmin : 0;
			}
			
			/* stack percent의 경우 max 값이 1이기 때문에 사용자가 ymax값을 입력해도 강제로 1로 바꿈 */
			if (gThis.stacked == "2") ymax = 1;
		}
		
		
		/*
		 * 개요 차트 배경 만들기
		 */
		function makeChartBG() {
			chart.select(".chartBG")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
			.attr("width", gThis.width - margin.left - margin.right)
			.attr("height", gThis.height - margin.top - margin.bottom)
			.style("fill", gThis.fillcolor);
		}
		
		
		/*
		 * 개요 차트 clipPath 만들기 (clipPath로 덮인 픽셀만(부분만) 화면에 출력한다.)
		 */
		function create_clipPath(id, x, y, width, height) {
			chart.append("clipPath").attr("id", id)
				 .append("rect").attr("x", x)
				 				.attr("y", y)
				 				.attr("width", width)
				 				.attr("height", height);
		}
		
		
		/*
		 * 개요 : bottomAxis의 text 길이가 길면 줄바꿈 처리
		 */
		function bottomAxisLF() {
			if (bottomScale.type == "scaleBand" && gThis.gallery != 9 && gThis.gallery != 16 && gThis.gallery != 17 && gThis.gallery != 97) {
				var tickLen = axis.select(".bottomAxis").selectAll(".tick")._groups[0].length;  /* bottomScale 보이는 text 수 */
				
				/* 첫 번째에 path태그가 있어서 i는 1부터 시작 */
				for (var i = 1; i <= tickLen; i++) {
					var textNode = axis.select(".bottomAxis").selectAll(".tick").filter(":nth-child(" + (i + 1) + ")").select("text");
					var getText = textNode.node().getBBox();
					var text = textNode.text();
					var step = bottomScale.step();  /* bandwidth + (step * paddingInner) */
					var stepWidth = step * 0.7;  /* 보여지는 글자의 넓이 */
					var cut = 2;  /* 등분 */
					var dy = "1em";  /* 글자의 세로 간격 */
					
					if (getText.width > stepWidth && text.length > 1) {
						
						while (true) {
							textNode.text("");
							var charLen = Math.round(text.length / cut);  /* 자를 글자수 */
							
							for (var j = 1; j <= Math.round(text.length / charLen); j++) {
								var t = text.substr((j - 1) * charLen, charLen);
								textNode.append("tspan").attr("dy", j == 1 ? "0.71em" : dy).attr("x", "0").text(t);
							}
							
							/* 글자수를 초과해서 자르려고 하면 종료  */
							if (Math.round(text.length / charLen) >= text.length) {
								break;
							}
							
							/* 잘랐는데도 width가 길면 다시 자름 */
							getText = textNode.node().getBBox();
							if (getText.width > stepWidth) {
								cut += 1;
								continue;
							}
								
							break;
						}
						
					}
				}
			}
			
			var x = getTransform(axis.select(".bottomAxis"), 0);
			var y = getTransform(axis.select(".bottomAxis"), 1);
			var h = axis.select(".bottomAxis").node().getBBox().height;
			setTransform(axis.select(".bottomAxis"), x, y - h);
			margin.bottom += h
			
			/* lefttitle 추가 위치 조정 */
			var x = label.select(".lefttitle").attr("x") * 1;
			label.select(".lefttitle").attr("x", x + (h/2));
			
			/* righttitle 추가 위치 조정 */
			var x = label.select(".righttitle").attr("x") * 1;
			label.select(".righttitle").attr("x", x - (h/2));
		}
		
		
		/*
		 * 개요      : transform 속성 값 가져오기
		 * 파라미터 : select = 대상
		 *         index = 0 또는 1
		 */
		function getTransform(select, index) {
			var str = select.attr("transform");
			var result = 0;
			if (str != null) {
				/*
				 * 크롬은 str의 값이 "translate(0,100)" 이렇게 콤마(,)로 구분되어서 만들어 지는데
				 * IE는  str의 값이 "translate(0 100)" 이렇게 공백( )으로 구분되어서 만들어 짐
				 */
				if (str.indexOf(",") > -1) result = str.substring(str.indexOf("(")+1, str.indexOf(")")).split(",")[index].trim() * 1;
				else result = str.substring(str.indexOf("(")+1, str.indexOf(")")).split(" ")[index].trim() * 1;
			}
			
			return result;
		}
		
		
		/*
		 * 개요      : transform 속성 값 변경
		 * 파라미터 : select = 대상
		 *         num1 = 첫 번째 변경 값
		 *         num2 = 두 번째 변경 값
		 */
		function setTransform(select, num1, num2) {
			select.attr("transform", "translate(" + num1 + "," + num2 + ")");
		}
		
		
		/*
		 * 개요      : 마우스 위치에 가까운 bottomAxis에 세로줄, 세로영역 그리기
		 * 파라미터 : lineType = null(기본값), area
		 * 리턴      : 
		 */
		function tooltipLine_mousemove(lineType) {
			var offsetX = mouse_offsetX();
			var offsetY = mouse_offsetY();
			var xValue = "";
			
			if (bottomScale.type == "scaleBand") xValue = current_position_bottom_scaleBand();
	        else if (bottomScale.type == "scaleTime") xValue = current_position_bottom_scaleTime();
			
			/* 그래프 범위 밖에서는 tooltipLine을 만들지 않음 */
			if (offsetX < bottomScale.range()[0] || offsetX > bottomScale.range()[1]) return;
			if (offsetY > leftScale.range()[0] || offsetY < leftScale.range()[1]) return;
			
			if (bottomScale.type == "scaleBand") {
				/* 세로영역 그리기 */
				if (lineType == "area") {
					var step = bottomScale.step();
					var paddingInner = bottomScale.paddingInner();
					
					tooltipLine
					   .attr("x", bottomScale(xValue.data) - (step * paddingInner / 2))
					   .attr("y", leftScale.range()[1])
					   .attr("width", step)
					   .attr("height", leftScale.range()[0] - leftScale.range()[1])
					   .style("opacity", 1);
				
				/* 세로줄 그리기 */
				} else {
					tooltipLine
					   .attr("x", bottomScale(xValue.data) + (bottomScale.bandwidth() / 2))
					   .attr("y", leftScale.range()[1])
					   .attr("height", leftScale.range()[0] - leftScale.range()[1])
					   .style("opacity", 1);
				}
				
	        } else if (bottomScale.type == "scaleTime") {
				tooltipLine
				   .attr("x", bottomScale(xValue.data))
				   .attr("y", leftScale.range()[1])
				   .attr("height", leftScale.range()[0] - leftScale.range()[1])
				   .style("opacity", 1);
	        }

		}
		
		
		/*
		 * 개요      : Candlestick 마우스 위치에 가까운 bottomAxis에 세로줄, 세로영역 그리기
		 * 파라미터 : lineType = null(기본값), area
		 * 리턴      : 
		 */
		function tooltipLine_Candlestick_mousemove(lineType) {
			var offsetX = mouse_offsetX();
			var offsetY = mouse_offsetY();
			var xValue = "";
			
			if (bottomScale.type == "scaleBand") xValue = current_position_bottom_scaleBand();
	        else if (bottomScale.type == "scaleTime") xValue = current_position_bottom_scaleTime(offsetX);
			
			/* 그래프 범위 밖에서는 tooltipLine을 만들지 않음 */
			if (offsetX < bottomScale.range()[0] || offsetX > bottomScale.range()[1]) return;
			if (offsetY > rightScale2.range()[0] || offsetY < rightScale.range()[1]) return;
			
			if (bottomScale.type == "scaleBand") {
				/* 세로영역 그리기 */
				if (lineType == "area") {
					var step = bottomScale.step();
					var paddingInner = bottomScale.paddingInner();
					
					tooltipLine
					   .attr("x", bottomScale(xValue.data) - (step * paddingInner / 2))
					   .attr("y", rightScale.range()[1])
					   .attr("width", step)
					   .attr("height", rightScale2.range()[0] - rightScale.range()[1])
					   .style("opacity", 1);
				
				/* 세로줄 그리기 */
				} else {
					tooltipLine
					   .attr("x", bottomScale(xValue.data) + (bottomScale.bandwidth() / 2))
					   .attr("y", rightScale2.range()[1])
					   .attr("height", rightScale2.range2()[0] - rightScale2.range()[1])
					   .style("opacity", 1);
				}
			}
		}
		
		
		/*
		 * 개요      : 마우스 위치에 가까운 scaleBand 값 가져오기
		 * 파라미터 : 
		 * 리턴      : currentPosition.index = index
		 *         currentPosition.data = 값
		 */
        function current_position_bottom_scaleBand() {
        	var offsetX = mouse_offsetX();
        	var currentPosition = {};
        	var domain = bottomScale.domain();
        	var step = bottomScale.step();
        	var paddingInner = bottomScale.paddingInner();
        	var padding = step * paddingInner;
        	var bandwidth = bottomScale.bandwidth();
        	
	        for (var i = 0; i < bottomScale.domain().length; i++) {
	        	var domainPosition = bottomScale(domain[i]);
	        	
	        	if (i == 0 && offsetX <= domainPosition) {
	        		currentPosition.index = i;
	        		currentPosition.data = domain[i];
	        		break;
	        	} else if (i == bottomScale.domain().length - 1 && offsetX >= domainPosition) {
	        		currentPosition.index = i;
	        		currentPosition.data = domain[i];
	        		break;
	        	} 
	        	
	        	if (offsetX >= domainPosition - (padding / 2) && offsetX <= domainPosition + bandwidth + (padding / 2)) {
	        		currentPosition.index = i;
	        		currentPosition.data = domain[i];
	        		break;
	        	}
	        }
	        
	        return currentPosition;
        }
        
		/*
		 * 개요      : 마우스 위치에 가까운 scaleTime 값 가져오기
		 * 파라미터 : 
		 * 리턴      : currentPosition.index = index
		 *         currentPosition.data = 값
		 */
        function current_position_bottom_scaleTime() {
        	var offsetX = mouse_offsetX();
        	var currentPosition = {};
			var xPointArray = [];
			var xPoint = 0;
			
			for (var i = 0; i < data[0].values.length; i++) {
				xPointArray[i] = bottomScale(data[0].values[i].xValue);
			}
			
			if (xPointArray.length > 1) xPoint = (xPointArray[1] - xPointArray[0]) / 2;
			
			for (var i = 0; i < data[0].values.length; i++) {
				var x1 = xPointArray[i] - xPoint;
				var x2 = xPointArray[i] + xPoint;
				
				if (offsetX >= x1 && offsetX <= x2) {
	        		currentPosition.index = i;
	        		currentPosition.data = data[0].values[i].xValue;
	        		break;
				}
			}
			
			return currentPosition;
        }
        
		/*
		 * 개요      : 마우스 위치에 가까운 scaleLinear 값 가져오기
		 * 파라미터 : 
		 * 리턴      : currentPosition.index = index
		 *         currentPosition.data = 값
		 */
        function current_position_scaleLinear() {
        	var offsetX = mouse_offsetX();
        	var currentPosition = {};
			var xPointArray = [];
			var xPoint = 0;
			
			for (var i = 0; i < data[0].values.length; i++) {
				xPointArray[i] = bottomScale(data[0].values[i].xValue);
			}
			
			if (xPointArray.length > 1) xPoint = (xPointArray[1] - xPointArray[0]) / 2;
			
			for (var i = 0; i < data[0].values.length; i++) {
				var x1 = xPointArray[i] - xPoint;
				var x2 = xPointArray[i] + xPoint;
				
				if (offsetX >= x1 && offsetX <= x2) {
	        		currentPosition.index = i;
	        		currentPosition.data = data[0].values[i].xValue;
	        		break;
				}
			}
			
			return currentPosition;
        }
        
        /*
		 * 개요      : 마우스 위치에 가까운 scaleBand 값 가져오기
		 * 파라미터 : 
		 * 리턴      : currentPosition.index = index
		 *         currentPosition.data = 값
		 */
        function current_position_left_scaleBand() {
	        for (var i = 0; i < leftScale.domain().length; i++) {
	        	var offsetX = mouse_offsetX();
	        	var currentPosition = {};
	        	var domain = leftScale.domain();
	        	var domainPosition = leftScale(domain[i]);
	        	var step = leftScale.step();
	        	var paddingInner = leftScale.paddingInner();
	        	var padding = step * paddingInner;
	        	var bandwidth = leftScale.bandwidth();
	        	
	        	if (i == 0 && offsetX >= domainPosition) {
	        		currentPosition.index = i;
	        		currentPosition.data = domain[i];
	        		break;
	        	} else if (i == leftScale.domain().length - 1 && offsetX <= domainPosition) {
	        		currentPosition.index = i;
	        		currentPosition.data = domain[i];
	        		break;
	        	} 
	        	
	        	if (offsetX >= domainPosition - (padding / 2) && offsetX <= domainPosition + bandwidth + (padding / 2)) {
	        		currentPosition.index = i;
	        		currentPosition.data = domain[i];
	        		break;
	        	}
	        }
	        
	        return currentPosition;
        }
		
		/*
		 * 개요      : 마우스 위치에 가까운 bottomAxis에 세로줄 지우기
		 * 파라미터 : 
		 * 리턴      : 
		 */
		function tooltipLine_mouseout() {
			tooltipLine.style('opacity', 0);
        }
        
		/*
		 * 개요      : 마우스 위치에 가까운 bottomAxis에 툴팁 그리기
		 * 파라미터 : 
		 * 리턴      : 
		 */
        function tooltip_mousemove() {
        	
        	/* 모든 데이터의 불이 꺼져 있으면 툴팁을 표시하지 않음 */
        	if (gThis.data.length == gThis.outLegendData.length) return;
        	
			var offsetX = mouse_offsetX();
			var offsetY = mouse_offsetY();
			var selectedColor = "";
			var total = 0;
			var xValue = "";
			var tooltipText = "";
			
			if (gThis.gallery == 20) {
				if (leftScale.type == "scaleBand") xValue = current_position_left_scaleBand();
			} else {
				if (bottomScale.type == "scaleBand") xValue = current_position_bottom_scaleBand();
		        else if (bottomScale.type == "scaleTime") xValue = current_position_bottom_scaleTime();
			}
			
			/* 그래프 범위 밖에서는 tooltip을 만들지 않음 */
			if (offsetX < bottomScale.range()[0] || offsetX > bottomScale.range()[1] + bar3DLen) return;
			if (offsetY > leftScale.range()[0] || offsetY < leftScale.range()[1] - bar3DLen) return;
			
			
			tooltipText += "<table class='tooltip_table'>";
			tooltipText += "<thead>";
			tooltipText += "<tr class='tooltip_tr'>";
			tooltipText += "<th class='tooltip_th0' colspan='3'>" + xValue.data + "</th>";
			tooltipText += "</tr>";
			tooltipText += "</thead>";
			tooltipText += "<tbody>";
			
			for (var i = 0; i < data.length; i++) {
				var selected = "";
//    			if (d != undefined && d.cValue == tooltipData[i].values[j].cValue) {
//    				selected = " selected";
//    				selectedColor = color(j);
//    			}
				
				total += data[i].values[xValue.index].yValue;
    			tooltipText += "<tr class='tooltip_tr'>";
//    			tooltipText += "<td class='tooltip_td0" + selected + "'><div style='background:" + color(data[i].values[0].colorIndex) + ";'></div></td>";
    			tooltipText += "<td class='tooltip_td0" + selected + "'><div></div></td>";
    			tooltipText += "<td class='tooltip_td1" + selected + "'>" + data[i].cValue + "</td>";
    			tooltipText += "<td class='tooltip_td2" + selected + "'>" + mask(data[i].values[xValue.index].yValue, "#,###,###,###,###,###,###,###,##0.###############") + "</td>";
    			if (gThis.stacked == "2") {
    				if (stackData[i] != null) {  /* comboChart에서 stack percent가 아닌 계열은 에러나서 null 처리 */
	    				var f = d3.format(".2%");
	    				var percent = f(stackData[i][xValue.index][1] - stackData[i][xValue.index][0]);
	    				tooltipText += "<td class='tooltip_td3" + selected + "'>(" + percent + ")</td>";
    				}
    			}
    			
    			tooltipText += "</tr>";
    			
//    			tooltipCircles.selectAll(".tooltipCircle").filter(":nth-child(" + (j + 1) + ")")
//	 				  		  .attr("cx", bottomScale(tooltipData[i].xValue))
//	 				  		  .attr("cy", leftScale(tooltipData[i].values[j].yValue))
//	 				  		  .attr("r", 5)
//	 				  		  .style("fill", color(j));
			}
			
			if (data.length > 1) {
        		tooltipText += "<tr class='tooltip_tr'>";
    			tooltipText += "<td class='tooltip_td0'><div></div></td>";
    			tooltipText += "<td class='tooltip_td1' style='font-weight:bold';>Total</td>";
    			tooltipText += "<td class='tooltip_td2'>" + mask(total, "#,###,###,###,###,###,###,###,##0.###############") + "</td>";
    			if (gThis.stacked == "2") {
    				tooltipText += "<td class='tooltip_td2'>(100.00%)</td>";
    			}
    			tooltipText += "</tr>";		        		
			}
    		tooltipText += "</tbody>";
			
			
			tooltipText += "</table>";		
        	tooltip.select('.tooltipText').html(tooltipText);
        	
        	
        	tooltip.selectAll('.tooltip_table')
		 		   .style("border-collapse", "collapse");
		 	
		 	tooltip.selectAll('.tooltip_table')
		  		   .selectAll('th, td')
		  		   .style("padding", "1px 1px 1px 1px")
		  		   .style("font-size", gThis.fontSize + "px");
		 	
		 	tooltip.selectAll('.tooltip_table')
		   		   .selectAll('th')
		   		   .style("text-align", "left")
		   		   .style("vertical-align", "middle");
		 	
		 	tooltip.selectAll('.tooltip_table')
		   		   .selectAll('.tooltip_td0')
		   		   .style("text-align", "center")
		   		   .style("vertical-align", "middle");
		 	
		 	tooltip.selectAll('.tooltip_table')
		   		   .selectAll('div')
		   		   .style("height", gThis.fontSize + "px")
		   		   .style("width", gThis.fontSize + "px")
//		   		   .style("border", "1px solid black")
		   		   ;
		 	
		 	tooltip.selectAll('.tooltip_table')
		   		   .selectAll('.tooltip_td1')
		   		   .style("text-align", "left")
		   		   .style("vertical-align", "middle");
		 	
		 	tooltip.selectAll('.tooltip_table')
		   		   .selectAll('.tooltip_td2')
		   		   .style("text-align", "right")
		   		   .style("vertical-align", "middle")
		   		   .style("font-weight", "bold");
		 	
		 	tooltip.selectAll('.tooltip_table')
		   		   .selectAll('.tooltip_td3')
		   		   .style("text-align", "right")
		   		   .style("vertical-align", "middle")
		   		   .style("font-weight", "bold");
		 	
		 	tooltip.selectAll('.tooltip_table')
		   		   .selectAll('.selected')
		   		   .style("border-top", "1px solid " + selectedColor)
		   		   .style("border-bottom", "1px solid " + selectedColor);
		 	
		 	tooltip_posiction();
		 	
		 	
        	/* tooltip 첫 번째 td에 legend_titles 그리기 */
        	for (var i = 0; i < data.length; i++) {
        		var tooltipSvg = d3.select("#" + gThis.controlId).select(".tooltip").select(".tooltipText").select("tbody").selectAll("tr").filter(":nth-child(" + (i + 1) + ")").select(".tooltip_td0").select("div")
        		.append("svg")
				.style("width", gThis.fontSize + "px")
				.style("height", gThis.fontSize + "px")
				.style("background", gThis.backcolor)
				.style("user-select", "none")  /* 드래그 방지*/
				;
        		
        		if (gThis.gallery == 1 || gThis.gallery == 3 || gThis.gallery == 8) {
					make_legend_titles_line();
					
				} else if (gThis.gallery == 2) {
					if (gThis.stacked) make_legend_titles_rect();
					else make_legend_titles_column();
					
				} else if (gThis.gallery == 4) {
					make_legend_titles_scatter();
				
				} else if (gThis.gallery == 6 || gThis.gallery == 19) {
					make_legend_titles_area();
					
				} else if (gThis.gallery == 15) {
					make_legend_titles_bubble();
					
				}  else if (gThis.gallery == 20) {
					if (gThis.stacked) make_legend_titles_rect();
					else make_legend_titles_bar();
					
				} else if (gThis.gallery == 7) {
					var renderas = data[i].renderas == null ? "" : data[i].renderas;
					
					if (renderas.toLowerCase() == "line") make_legend_titles_line();
					else if (renderas.toLowerCase() == "area") make_legend_titles_area();
					else make_legend_titles_column();
					
				} else {
					make_legend_titles_rect();
				}
        		
        		
        		function make_legend_titles_line() {
					var line = d3.line().x(function(d, i) { return d.x; }).y(function(d, i) { return d.y; }).curve(d3.curveLinear);
					
					tooltipSvg.append("path").attr("class","legend-tiles")
	        			.attr("d", function(d, i) { 
		        			var imsiData = new Array();
				            var temp = {};
				            temp["x"] = 0;
				            temp["y"] = gThis.fontSize / 2;
				            imsiData.push(temp);
				               
				            temp = {};
				            temp["x"] = gThis.fontSize;
				            temp["y"] = gThis.fontSize / 2;
				            imsiData.push(temp);
				                
		        			return line(imsiData);
		        		})
		        		.style('stroke', color(data[i].colorIndex))
		        		.style('stroke-width', '1px')
		        		.style('fill', 'none')
		        		.style('stroke-linecap', 'round');
					
					tooltipSvg.append("circle").attr("class","legend-tiles")
	        			.attr("cx", gThis.fontSize * 0.5)
	        			.attr("cy", gThis.fontSize / 2)
	        			.attr("r", gThis.fontSize * 0.25)
	        			.style("fill", "#ffffff")
	        			.style("stroke", color(data[i].colorIndex))
	        			.style('stroke-width', '1px');
				}
				
				function make_legend_titles_column() {
					tooltipSvg.append("rect").attr("class","legend-tiles")
			 	  		   .attr("x", 0)
			 	  		   .attr("y", gThis.fontSize * 0.3)
			 	  		   .attr("width", gThis.fontSize * 0.25)
			 	  		   .attr("height", gThis.fontSize * 0.7)
			 	  		   .attr("fill", "url(#" + gThis.controlId + "_gradient" + data[i].colorIndex + ")");
					
					tooltipSvg.append("rect").attr("class","legend-tiles")
			 	  		   .attr("x", gThis.fontSize * 0.375)
			 	  		   .attr("y", 0)
			 	  		   .attr("width", gThis.fontSize * 0.25)
			 	  		   .attr("height", gThis.fontSize)
			 	  		   .attr("fill", "url(#" + gThis.controlId + "_gradient" + data[i].colorIndex + ")");
					
					tooltipSvg.append("rect").attr("class","legend-tiles")
			 	  		   .attr("x", gThis.fontSize * 0.75)
			 	  		   .attr("y", gThis.fontSize * 0.6)
			 	  		   .attr("width", gThis.fontSize * 0.25)
			 	  		   .attr("height", gThis.fontSize * 0.4)
			 	  		   .attr("fill", "url(#" + gThis.controlId + "_gradient" + data[i].colorIndex + ")");
				}
				
				function make_legend_titles_area() {
					var area = d3.area()
					   			 .x(function(d, i) { return d.x; })
					   			 .y0(function(d, i) { return d.y0; })
					   			 .y1(function(d, i) { return d.y1; })
					   			 .curve(curveArray[gThis.curveType]);
						
					tooltipSvg.append("path").attr("class","legend-tiles")
						.attr("d", function(d, i) { 
							var imsiData = new Array();
							var temp = {};
							temp["x"] = 0;
							temp["y0"] = gThis.fontSize;
							temp["y1"] = (gThis.fontSize * 0.7);
							imsiData.push(temp);
							
							temp = {};
							temp["x"] = gThis.fontSize * 0.3;
							temp["y0"] = gThis.fontSize;
							temp["y1"] = (gThis.fontSize * 0.2);
							imsiData.push(temp);
							
							temp = {};
							temp["x"] = gThis.fontSize * 0.6;
							temp["y0"] = gThis.fontSize;
							temp["y1"] = (gThis.fontSize * 0.7);
							imsiData.push(temp);
							
							temp = {};
							temp["x"] = gThis.fontSize;
							temp["y0"] = gThis.fontSize;
							temp["y1"] = 0;
							imsiData.push(temp);
							
							return area(imsiData);
					   })
					   .style("fill", "url(#" + gThis.controlId + "_gradient" + data[i].colorIndex + ")")
					   .style('opacity', 0.7);
				}
				
				function make_legend_titles_bar() {
					tooltipSvg.append("rect").attr("class","legend-tiles")
			 	  		   .attr("x", 0)
			 	  		   .attr("y", 0)
			 	  		   .attr("width", gThis.fontSize * 0.7)
			 	  		   .attr("height", gThis.fontSize * 0.25)
			 	  		   .attr("fill", "url(#" + gThis.controlId + "_gradient" + data[i].colorIndex + ")");
					
					tooltipSvg.append("rect").attr("class","legend-tiles")
			 	  		   .attr("x", 0)
			 	  		   .attr("y", (gThis.fontSize * 0.375))
			 	  		   .attr("width", gThis.fontSize)
			 	  		   .attr("height", gThis.fontSize * 0.25)
			 	  		   .attr("fill", "url(#" + gThis.controlId + "_gradient" + data[i].colorIndex + ")");
					
					tooltipSvg.append("rect").attr("class","legend-tiles")
			 	  		   .attr("x", 0)
			 	  		   .attr("y", (gThis.fontSize * 0.75))
			 	  		   .attr("width", gThis.fontSize * 0.4)
			 	  		   .attr("height", gThis.fontSize * 0.25)
			 	  		   .attr("fill", "url(#" + gThis.controlId + "_gradient" + data[i].colorIndex + ")");
				}
				
				function make_legend_titles_rect() {
					tooltipSvg.append("rect").attr("class","legend-tiles")
		     	  		.attr("x", 0)
		     	  		.attr("y", 0)
		     	  		.attr("width", gThis.fontSize)
		     	  		.attr("height", gThis.fontSize)
		     	  		.attr("fill", "url(#" + gThis.controlId + "_gradient" + data[i].colorIndex + ")");
				}
        	}
        	
        	
        	
        	
        }
        
        
        /*
		 * 개요      : 마우스 위치에 가까운 bottomAxis에 툴팁 그리기
		 * 파라미터 : 
		 * 리턴      : 
		 */
        function tooltip_Candlestick_mousemove() {
        	/* 모든 데이터의 불이 꺼져 있으면 툴팁을 표시하지 않음 */
        	if (gThis.data.length == gThis.outLegendData.length) return;
        	
			var offsetX = mouse_offsetX();
			var offsetY = mouse_offsetY();
			var selectedColor = "";
			var total = 0;
			var xValue = "";
			var tooltipText = "";
			
			if (gThis.gallery == 20) {
				if (leftScale.type == "scaleBand") xValue = current_position_left_scaleBand();
			} else {
				if (bottomScale.type == "scaleBand") xValue = current_position_bottom_scaleBand();
		        else if (bottomScale.type == "scaleTime") xValue = current_position_bottom_scaleTime();
			}
			
			/* 그래프 범위 밖에서는 tooltip을 만들지 않음 */
			if (offsetX < bottomScale.range()[0] || offsetX > bottomScale.range()[1]) return;
			if (offsetY > rightScale2.range()[0] || offsetY < rightScale.range()[1]) return;
			
			var d = data[xValue.index];
			
			if (gThis.gallery == 9) {
				tooltip.select('.tooltipText').html(
						"<b>" + d.label + "</b>" +
	   					"<br>Close : <b>" + d.close + "</b>" +
	   					"<br>Low &nbsp : <b>" + d.low + "</b>" +
	   					"<br>High &nbsp: <b>" + d.high + "</b>" +
	   					(volumeHeight > 0 ? "<br>Volume &nbsp: <b>" + d.volume + "</b>" : ""));
			} else {
				tooltip.select('.tooltipText').html(
						"<b>" + d.label + "</b>" +
						"<br>Open : <b>" + d.open + "</b>" +
	   					"<br>Close : <b>" + d.close + " (<span style='color:" + (d.open > d.close ? "#E11C27" : d.close > d.open ? "#51AC53" : color(3)) + ";'>" + formatChange(d.open, d.close) + "</span>)" + "</b>" +
	   					"<br>Low &nbsp : <b>" + d.low + "</b>" +
	   					"<br>High &nbsp: <b>" + d.high + "</b>" +
	   					(volumeHeight > 0 ? "<br>Volume &nbsp: <b>" + d.volume + "</b>" : ""));
			}
			
			tooltip.select('.tooltipText').style("text-align", "left");
			
        	tooltip_posiction();
        }
        
        
        /*
		 * 개요      : 툴팁 위치조정
		 * 파라미터 : 
		 * 리턴      : 
		 */
        function tooltip_posiction() {
        	tooltip_mouseout();
        	
        	var offsetX = mouse_offsetX();
			var offsetY = mouse_offsetY();
			
			/* 그래프 범위 밖에서는 tooltip을 만들지 않음 */
			if (bottomScale != null && leftScale != null && bottomScale != "" && leftScale != "") {
				if (offsetX < bottomScale.range()[0] || offsetX > bottomScale.range()[1] + bar3DLen) return;
				if (gThis.gallery == 9 || gThis.gallery == 16 || gThis.gallery == 17) {
					if (offsetY > rightScale2.range()[0] || offsetY < rightScale.range()[1]) return;
				} else {
					if (offsetY > leftScale.range()[0] || offsetY < leftScale.range()[1] - bar3DLen) return;
				}
			}
			
        	tooltip.style('display', 'block');
        	
        	var tooltipLeft = "";
        	var tooltipTop = "";
        	var tooltipHeight = tooltip.style("height").split("px")[0] * 1;
        	var tooltipWidth = tooltip.style("width").split("px")[0] * 1;
        	var tooltipPadding = 30;

        	tooltipLeft = mouse_layerX() + 15 ;
        	if (tooltipLeft + tooltipWidth > gThis.left + gThis.width - tooltipPadding) {
        		tooltipLeft = gThis.left + gThis.width - tooltipWidth - tooltipPadding;
        	} 
        	
        	tooltipTop = mouse_layerY() + 15;
        	if (tooltipTop + tooltipHeight > top + gThis.height - tooltipPadding) {
        		tooltipTop = gThis.top + gThis.height - tooltipHeight - tooltipPadding;
        	}
        	
        	tooltip.style('top', tooltipTop + 'px')
			       .style('left', tooltipLeft + 'px');
			
	        tooltip.style('opacity', 1);
        }
		
		/*
		 * 개요      : 마우스 위치에 가까운 bottomAxis에 툴팁 지우기
		 * 파라미터 : 
		 * 리턴      : 
		 */
        function tooltip_mouseout() {
        	tooltip.style('display', 'none');
        	tooltip.style('opacity', 0);
        }
        
        
        /*
		 * 개요      : svg 안에서 마우스 x좌표 리턴
		 * 파라미터 : 
		 * 리턴      : 마우스 x좌표
		 */
        function mouse_offsetX() {
        	return d3.mouse(svg.node())[0];
        }
        
        /*
		 * 개요      : svg 안에서 마우스 y좌표 리턴
		 * 파라미터 : 
		 * 리턴      : 마우스 y좌표
		 */
        function mouse_offsetY() {
        	return d3.mouse(svg.node())[1];
        }
        
        /*
		 * 개요      : svg 밖으로부터의 기준으로 마우스 x좌표 리턴 (tooltip 좌표에 사용)
		 * 파라미터 : 
		 * 리턴      : 마우스 x좌표
		 */
        function mouse_layerX() {
        	var position = d3.select("#" + gThis.controlId).style("position");
        	
			if (position == "absolute")
				return mouse_offsetX();
			else 
				return d3.event.layerX;
        }
        
        /*
		 * 개요      : svg 밖으로부터의 기준으로 마우스 y좌표 리턴 (tooltip 좌표에 사용)
		 * 파라미터 : 
		 * 리턴      : 마우스 y좌표
		 */
        function mouse_layerY() {
        	var position = d3.select("#" + gThis.controlId).style("position");
        	
			if (position == "absolute")
				return mouse_offsetY();
			else
				return d3.event.layerY;
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        function makeLineChart() {
        	
        	/* 크기 측정용 임시 축 만들기 시작 ------------------------------------------------- */
//			bottomScale = d3.scaleTime().domain(d3.extent(data[0].values, function(d, i) { return d.xValue; }));
			bottomScale = d3.scaleBand().range([margin.left, gThis.width - margin.right]).domain(data[0].values.map(function(d, i){ return d.xValue; }));
			leftScale = d3.scaleLinear().domain([ymin, ymax]);
			
			axis.append("g").attr("class", "bottomAxis").call(d3.axisBottom(bottomScale));
			axis.append("g").attr("class", "leftAxis").call(d3.axisLeft(leftScale).ticks(gThis.ytick));
			
			var getbottomAxis = axis.select(".bottomAxis").node().getBBox();
			var getleftAxis = axis.select(".leftAxis").node().getBBox();
			
			axis.select(".bottomAxis").remove();
			axis.select(".leftAxis").remove();
			/* 크기 측정용 임시 축 만들기 종료 ------------------------------------------------- */
			
			
			/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			margin.top += gettitle.height > 0 ? gettitle.height + 20 : 0;
			
			if (getlegend != "" && gThis.legendType == "right") {
				legend.attr("transform", "translate(" + (gThis.width - getlegend.width - margin.right) + ", " + margin.top + ")");
				margin.right += getlegend.width + 10;
			} else if (getlegend != "") {
				legend.attr("transform", "translate(" + ((gThis.width / 2) - (getlegend.width / 2)) + ", " + (gThis.height - margin.bottom - getlegend.height + (0 - getlegend.y)) + ")");
				margin.bottom += getlegend.height + 10;
			}
			
			label.select(".bottomtitle").attr("y", gThis.height - margin.bottom - getbottomtitle.height + (0 - getbottomtitle.y));
			margin.bottom += getbottomtitle.height > 0 ? getbottomtitle.height + 10 : 0;
			
			label.select(".lefttitle").attr("x", - (margin.top + ((gThis.height - margin.top - margin.bottom ) / 2)));
			label.select(".lefttitle").attr("y", margin.left + (0 - getlefttitle.y));
			margin.left += getlefttitle.height > 0 ? getlefttitle.height + 10 : 0;
			margin.left += getleftAxis.width;
			
			if (trendwidth > 0) margin.right += trendwidth;
			
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			label.select(".bottomtitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
			
//			bottomScale = d3.scaleTime()
//						   .range([margin.left, gThis.width - margin.right])
//						   .domain(d3.extent(data[0].values, function(d, i) { return d.xValue; }));
			
			bottomScale = d3.scaleBand().range([margin.left, gThis.width - margin.right])
			   .domain(data[0].values.map(function(d, i){ return d.xValue; }));
			bottomScale.type = "scaleBand";
			
			axis.append("g").attr("class", "bottomAxis")
				.call(d3.axisBottom(bottomScale).ticks(gThis.ytick))
				.attr("transform", "translate(0," + (gThis.height - margin.bottom) + ")")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("bottom");
			
			bottomAxisLF();
			
			
			leftScale = d3.scaleLinear()
			   .range([gThis.height - margin.bottom, margin.top])
			   .domain([ymin, ymax]);
			leftScale.type = "scaleLinear";
			
			axis.append("g").attr("class", "leftAxis")
				.call(d3.axisLeft(leftScale).ticks(gThis.ytick))
				.attr("transform", "translate(" + margin.left + ", 0)")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("left");
			
			makeChartBG();
			
			
			//차트 가로줄 그리기
			if (true || gThis.grid == 1 || gThis.grid == 3) {
				chart.append("g").attr("class","xLines")
				     .selectAll(".xLine")
				     .data(leftScale.ticks(gThis.ytick))
				     .enter().append("rect")
				     .attr("class","xLine")
				     .attr("x", margin.left)
				     .attr("y", function(d, i) { return leftScale(d); })
				     .attr("width", gThis.width - margin.left - margin.right)
				     .attr("height", 1)
				     .style("fill", "#EEEEEE");
			}
			
			//차트 세로줄 그리기
			if (gThis.grid == 2 || gThis.grid == 3) {		
				chart.append("g").attr("class","yLines")
				     .selectAll(".yLine")
				     .data(data[0].values)
				     .enter().append("rect")
				     .attr("class","yLine")
				     .attr("x", function(d, i) { return bottomScale(d.xValue); })
				     .attr("y", margin.top)
				     .attr("width", 1)
				     .attr("height", gThis.height - margin.top - margin.bottom)
				     .style("fill", "#EEEEEE");
			}
			
			svg.on("mousemove", function(d, i) { tooltipLine_mousemove(); tooltip_mousemove(); })
			   .on("mouseout", function(d, i) { tooltipLine_mouseout(); tooltip_mouseout(); });
		
			var line = d3.line()
						 .x(function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2)/*bottomScale(d.xValue)*/; })
						 .y(function(d, i) { return leftScale(d.yValue); })
						 .curve(curveArray[gThis.curveType]);

			var lines = chart.append('g').attr('class', 'lines');

			lines.append('g').attr('class', 'line-group')
				 .selectAll(".path")
				 .data(data).enter()
			     .append('path')
			     .attr('class', 'line')  
			     .attr('d', function(d, i) { return line(d.values); })
			     .style('stroke', function(d, i) { return color(d.colorIndex); })
			     .style('stroke-width', lineStroke)
			     .style('opacity', lineOpacity)
			     .style('fill', 'none')
			     .on("mouseover", function(d, i) {
			    	 lines.selectAll('.line').style('opacity', otherLinesOpacityHover);
			    	 lines.selectAll('.circle').style('opacity', circleOpacityOnLineHover);
			    	 
			    	 lines.selectAll(".line").filter(":nth-child(" + (i + 1) + ")")
			    	   .style('opacity', lineOpacityHover)
			    	   .style("stroke-width", lineStrokeHover)
			    	   .style("cursor", "pointer"); 
			    })
			    .on("mouseout", function(d, i) {
			    	lines.selectAll(".line").style('opacity', lineOpacity);
			    	lines.selectAll('.circle').style('opacity', circleOpacity);
			    	lines.selectAll(".line").filter(":nth-child(" + (i + 1) + ")").style("stroke-width", lineStroke).style("cursor", "none");
			    });
				

			/* Add circles in the line */
			lines.selectAll("circle-group")
				 .data(data).enter()
				 .append("g")
				 .attr("class", "circle-group")
				 .style("fill", "#ffffff")
				 .style("stroke", function(d, i) { return color(d.colorIndex); })
				 .selectAll("circle")
				 .data(function(d, i) { return d.values; }).enter()
				 .append("g")
				 .attr("class", "circle")  
				 .on("mouseover", function(d, i) {
					 d3.select(this)     
					   .style("cursor", "pointer")
					   .append("text")
					   .attr("class", "text")
					   .attr("text-anchor", "middle")
					   .text(function(d, i) { return d.yValue; })
					   .attr("x", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2)/*bottomScale(d.xValue)*/; })
					   .attr("y", function(d, i) { return leftScale(d.yValue) - 10; });
				 })
				 .on("mouseout", function(d, i) {
					 d3.select(this)
					   .style("cursor", "none")  
					   .transition()
					   .duration(lineDuration)
					   .selectAll(".text").remove();
				 })
				 .append("circle")
				 .attr("cx", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2)/*bottomScale(d.xValue)*/; })
				 .attr("cy", function(d, i) { return leftScale(d.yValue); })
				 .attr("r", circleRadius)
				 .style('opacity', gThis.animateFlag == true ? 0 : circleOpacity)
				 .on("mouseover", function(d, i) {
					 d3.select(this)
					   .transition()
					   .duration(lineDuration)
					   .attr("r", circleRadiusHover);
				 })
				 .on("mouseout", function(d, i) {
					 d3.select(this) 
					   .transition()
					   .duration(lineDuration)
					   .attr("r", circleRadius);  
				 });
			
			if (gThis.animateFlag == true) {
				lines.selectAll(".line-group")
				.selectAll(".line")
				.attr("stroke-dasharray", function(d, i) { totalLength = d3.select(this).node().getTotalLength(); return totalLength + " " + totalLength; })
				.attr("stroke-dashoffset", function(d, i) { return d3.select(this).node().getTotalLength();})
				.transition()
				.delay(delay)
				.duration(duration)
				.ease(d3.easeLinear)
				.attr("stroke-dashoffset", 0);
				
				lines.selectAll(".circle-group")
				.selectAll(".circle").select("circle")
				.transition()
				.delay(delay + (duration))
				.style("opacity", 1);
			}
        }
        
        
        function makeColumnChart() {
        	
        	if (gThis.gallery == 2 && (gThis.stacked == "1" || gThis.stacked == "2")) getStackData();
				
			/* 크기 측정용 임시 축 만들기 시작 ------------------------------------------------- */
			bottomScale = d3.scaleBand().domain(data[0].values.map(function(d, i){ return d.xValue; }));
			leftScale = d3.scaleLinear().domain([ymin, ymax]);
			
			axis.append("g").attr("class", "bottomAxis").call(d3.axisBottom(bottomScale));
			if (gThis.stacked == "2") axis.append("g").attr("class", "leftAxis").call(d3.axisLeft(leftScale).ticks(gThis.ytick, "%"));
			else axis.append("g").attr("class", "leftAxis").call(d3.axisLeft(leftScale).ticks(gThis.ytick));
			
			var getbottomAxis = axis.select(".bottomAxis").node().getBBox();
			var getleftAxis = axis.select(".leftAxis").node().getBBox();
			
			axis.select(".bottomAxis").remove();
			axis.select(".leftAxis").remove();
			/* 크기 측정용 임시 축 만들기 종료 ------------------------------------------------- */
			
			/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			margin.top += gettitle.height > 0 ? gettitle.height + 20 : 0;
			margin.top += bar3DLen;
			
			if (getlegend != "" && gThis.legendType == "right") {
				legend.attr("transform", "translate(" + (gThis.width - getlegend.width - margin.right) + ", " + margin.top + ")");
				margin.right += getlegend.width + 10;
			} else if (getlegend != "") {
				legend.attr("transform", "translate(" + ((gThis.width / 2) - (getlegend.width / 2)) + ", " + (gThis.height - margin.bottom - getlegend.height + (0 - getlegend.y)) + ")");
				margin.bottom += getlegend.height + 10;
			}
			
			label.select(".bottomtitle").attr("y", gThis.height - margin.bottom - getbottomtitle.height + (0 - getbottomtitle.y));
			margin.bottom += getbottomtitle.height > 0 ? getbottomtitle.height + 10 : 0;
			
			label.select(".lefttitle").attr("x", - (margin.top + ((gThis.height - margin.top - margin.bottom ) / 2)));
			label.select(".lefttitle").attr("y", margin.left + (0 - getlefttitle.y));
			margin.left += getlefttitle.height > 0 ? getlefttitle.height + 10 : 0;
			margin.left += getleftAxis.width;
			
			if (trendwidth > 0) margin.right += trendwidth;
			
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			label.select(".bottomtitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
			
			bottomScale = d3.scaleBand()
						   .range([margin.left, gThis.width - margin.right])
						   .domain(data[0].values.map(function(d, i){ return d.xValue; }))
						   .padding(0.4).paddingOuter(0.2);
			
			bottomScale.type = "scaleBand";
			
			axis.append("g").attr("class", "bottomAxis")
				.call(d3.axisBottom(bottomScale))
				.attr("transform", "translate(0," + (gThis.height - margin.bottom) + ")")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("bottom");
			
			bottomAxisLF();
			
			
			leftScale = d3.scaleLinear()
						   .range([gThis.height - margin.bottom, margin.top])
						   .domain([ymin, ymax]);
			leftScale.type = "scaleLinear";
			
			/* stack percent의 경우 max 값이 1이기 때문에 100% 보이게 함*/
			if (gThis.stacked == "2") {
				axis.append("g").attr("class", "leftAxis")
					.call(d3.axisLeft(leftScale).ticks(gThis.ytick, "%"))
					.attr("transform", "translate(" + margin.left + ", 0)")
					
					.style("font-size", gThis.fontSize + "px");
			} else {
				axis.append("g").attr("class", "leftAxis")
					.call(d3.axisLeft(leftScale).ticks(gThis.ytick))
					.attr("transform", "translate(" + margin.left + ", 0)")
					.style("font-size", gThis.fontSize + "px");
			}
			
			findTicks("left");
			
			makeChartBG();
			
			
			//차트 가로줄 그리기
        	if (true || gThis.grid == 1 || gThis.grid == 3) {
				chart.append("g").attr("class","xLines")
					 .selectAll(".xLine")
					 .data(leftScale.ticks(gThis.ytick))
					 .enter().append("rect")
					 .attr("class","xLine")
					 .attr("x", margin.left)
					 .attr("y", function(d, i) { return leftScale(d); })
					 .attr("width", gThis.width - margin.left - margin.right)
					 .attr("height", 1)
					 .style("fill", "#EEEEEE");
			}
			
			//차트 세로줄 그리기
			if (gThis.grid == 2 || gThis.grid == 3) {		
				chart.append("g").attr("class","yLines")
				     .selectAll(".yLine")
				     .data(bottomScale.domain())
				     .enter().append("rect")
				     .attr("class","yLine")
				     .attr("x", function(d, i) { return bottomScale(d) + (bottomScale.bandwidth() / 2) ; })
				     .attr("y", margin.top)
				     .attr("width", 1)
				     .attr("height", gThis.height - margin.top - margin.bottom)
				     .style("fill", "#EEEEEE");
			}		

			if (ymin < 0) {
				if (gThis.chart3d == "true") {
					chart.append("rect").attr("class", "zero-plane")
					.attr("width", bottomScale.range()[1] - bottomScale.range()[0])
					.attr("height", bar3DLen)
					.attr("transform", function(d, i) { return "translate (" + (bottomScale.range()[0] + bar3DLen) + "," + (leftScale(yStart) - bar3DLen) + ") skewX(-45)"; })
					.style("fill", "#EEEEEE")
					.style("opacity", 1);
					
				} else {
					chart.append("rect").attr("class", "zero-plane")
					.attr("x", bottomScale.range()[0])
					.attr("y", leftScale(yStart) - 1)
					.attr("width", bottomScale.range()[1] - bottomScale.range()[0])
					.attr("height", 3)
					.style("fill", "#EEEEEE");
				}
			}
			
			
			var rects = chart.append("g").attr("class", "rects");
			
			if (gThis.gallery == 2) {
				
				if (gThis.stacked == "1" || gThis.stacked == "2") {
					
					if (gThis.chart3d == "true") {
						
				        var rectTop = rects.append("g").attr("class", "rectTop")
				        .selectAll("rects")
						.data(stackData).enter()
						.append("g").attr("class", "rects")
						.attr("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; });
				        
				        rectTop
			        	.selectAll("rect")
			            .data(function(d, i) {
			                d.forEach(function(d1) {
			                    d1.key = d.key;
			                    return d1;
			                });
			                return d;
			            })
			            .enter().append("rect")
			            .attr("width", bottomScale.bandwidth)
						.attr("height", bar3DLen)
						.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.data.xValue) + bar3DLen) + "," + (leftScale(d[1]) - bar3DLen) + ") skewX(-45)"; })
						.on("mousemove", onMouseMove)
					 	.on("mouseout", onMouseOut);
				        
						
						
				        var rectRight = rects.append("g").attr("class", "rectRight")
				        .selectAll("rects")
						.data(stackData).enter()
						.append("g").attr("class", "rects")
						.attr("fill", function(d, i) { return d3.rgb(color(d.colorIndex)); });
				         
				        rectRight
			        	.selectAll("rect")
			            .data(function(d, i) {
			                d.forEach(function(d1) {
			                    d1.key = d.key;
			                    return d1;
			                });
			                return d;
			            })
			            .enter().append("rect")
			            .attr("width", bar3DLen)
			            .attr("height", function(d, i) { return leftScale(d[0]) - leftScale(d[1]); })	
						.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.data.xValue) + bottomScale.bandwidth()) + "," + leftScale(d[1]) + ") skewY(-45)"; })
						.on("mousemove", onMouseMove)
					 	.on("mouseout", onMouseOut);
					}
					
					
			        var rectBody = rects.append("g").attr("class", "rectBody")
			        .selectAll("rects")
					.data(stackData).enter()
					.append("g").attr("class", "rects")
					.attr("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; });
					
			        rectBody.selectAll("rect")
			            .data(function(d, i) {
			                d.forEach(function(d1) {
			                    d1.key = d.key;
			                    return d1;
			                });
			                return d;
			            })
			            .enter().append("rect")
			            .attr("width", bottomScale.bandwidth)
			            .attr("x", function(d, i) { return bottomScale(d.data.xValue); })
			            .attr("y", function(d, i) { return leftScale(d[1]); })
			            .attr("height", function(d, i) { return leftScale(d[0]) - leftScale(d[1]); })
					 	.on("mousemove", onMouseMove)
					 	.on("mouseout", onMouseOut);
			        
			        
				} else {
					/*
					if (gThis.chart3d == "true") {
						
						rects.append("g").attr("class", "rectRight")
						.selectAll("rect")
						 .data(function(d, i){ d.values.map(function(b){ b.dataIndex=i; return b; }); return d.values; })
						 .enter().append("rect")
						 .attr("width", bar3DLen)
						 .attr("height", 0)
						 .attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + (bottomScale.bandwidth() / data.length)) + "," + leftScale(yStart) + ") skewY(-45)"; })
						 .style("fill", function(d, i) { return d3.rgb(color(d.colorIndex)).darker(0.5); })
						 .on("mousemove", onMouseMove)
						 .on("mouseout", onMouseOut)
						 .transition()
						 .delay(delay)
						 .duration(duration)
						 .attr("height", function(d, i) { return d.yValue > yStart ? leftScale(yStart) - leftScale(d.yValue) : leftScale(d.yValue) - leftScale(yStart); })
						 .attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + (bottomScale.bandwidth() / data.length)) + "," + (leftScale(d.yValue < yStart ? yStart : d.yValue)) + ") skewY(-45)"; });
						
						rects.append("g").attr("class", "rectTop")
						.selectAll("rect")
						 .data(function(d, i){ d.values.map(function(b){ b.dataIndex=i; return b; }); return d.values; })
						 .enter().append("rect")
						 .attr("width", bottomScale.bandwidth() / data.length)
						 .attr("height", bar3DLen)
						 .attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + bar3DLen) + "," + (leftScale(yStart) - bar3DLen) + ") skewX(-45)"; })
						 .style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
						 .on("mousemove", onMouseMove)
						 .on("mouseout", onMouseOut)
						 .transition()
						 .delay(delay)
						 .duration(duration)
						 .attr("height", bar3DLen)
						 .attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + bar3DLen) + "," + (leftScale(d.yValue < yStart ? yStart : d.yValue) - bar3DLen) + ") skewX(-45)"; });
						
					}
					
					rects.append("g").attr("class", "rectBody")
					 .selectAll("rect")
					 .data(function(d, i){ d.values.map(function(b){ b.dataIndex=i; return b; }); return d.values; })
					 .enter().append("rect")
					 .attr("x", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex); })
					 .attr("y", leftScale(yStart))
					 .attr("width", bottomScale.bandwidth() / data.length)
					 .attr("height", 0)
					 .style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
					 .on("mousemove", onMouseMove)
					 .on("mouseout", onMouseOut)
					 .transition()
					 .delay(delay)
					 .duration(duration)
					 .attr("y", function(d, i) { return leftScale(d.yValue < yStart ? yStart : d.yValue); })
					 .attr("height", function(d, i) { return d.yValue > yStart ? leftScale(yStart) - leftScale(d.yValue) : leftScale(d.yValue) - leftScale(yStart); });
					*/
					
					for (var i = 0; i < data[0].values.length; i++) {
					    for (var j = 0; j < data.length; j++) {
					    	var imsidata = new Array();
					    	imsidata.push(data[j].values[i]);
					      
						    //top
						    rects.append("rect")
						    .data(imsidata)
							.attr("width", bottomScale.bandwidth() / data.length)
							.attr("height", bar3DLen)
							.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + bar3DLen) + "," + (leftScale(yStart) - bar3DLen) + ") skewX(-45)"; })
							.style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
							.on("mousemove", onMouseMove)
							.on("mouseout", onMouseOut)
							.transition()
							.delay(delay)
							.duration(duration)
							.attr("height", bar3DLen)
							.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + bar3DLen) + "," + (leftScale(d.yValue < yStart ? yStart : d.yValue) - bar3DLen) + ") skewX(-45)"; })
							;
					        
	      					//right 
	      					rects.append("rect")
	      					.data(imsidata)
							.attr("width", bar3DLen)
							.attr("height", 0)
							.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + (bottomScale.bandwidth() / data.length)) + "," + leftScale(yStart) + ") skewY(-45)"; })
							.style("fill", function(d, i) { return d3.rgb(color(d.colorIndex)).darker(0.5); })
							.on("mousemove", onMouseMove)
							.on("mouseout", onMouseOut)
							.transition()
							.delay(delay)
							.duration(duration)
							.attr("height", function(d, i) { return d.yValue > yStart ? leftScale(yStart) - leftScale(d.yValue) : leftScale(d.yValue) - leftScale(yStart); })
							.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + (bottomScale.bandwidth() / data.length)) + "," + (leftScale(d.yValue < yStart ? yStart : d.yValue)) + ") skewY(-45)"; })
						    ;
	      					
						    //body
						    rects.append("rect")
						    .data(imsidata)
	      					.attr("x", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex); })
	      					.attr("y", leftScale(yStart))
	      					.attr("width", bottomScale.bandwidth() / data.length)
	      					.attr("height", 0)
	      					.style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
	      					.on("mousemove", onMouseMove)
	      					.on("mouseout", onMouseOut)
	      					.transition()
	      					.delay(delay)
	      					.duration(duration)
	      					.attr("y", function(d, i) { return leftScale(d.yValue < yStart ? yStart : d.yValue); })
	      					.attr("height", function(d, i) { return d.yValue > yStart ? leftScale(yStart) - leftScale(d.yValue) : leftScale(d.yValue) - leftScale(yStart); })
	      					;
					    }
					}
				}

				


				
			
			} else if (gThis.gallery == 98) {
				/*
				if (gThis.chart3d == "true") {
					rects.append("g").attr("class", "rectRight")
					.selectAll("rect")
					 .data(function(d, i){ d.values.map(function(b){ b.dataIndex=i; return b; }); return d.values; })
					 .enter().append("rect")
					 .attr("width", bar3DLen)
					 .attr("height", 0)
					 .attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + (bottomScale.bandwidth() / data.length)) + "," + leftScale(yStart) + ") skewY(-45)"; })
					 .style("fill", function(d, i) { return d3.rgb(color(d.colorIndex)).darker(0.5); })
					 .on("mousemove", onMouseMove)
					 .on("mouseout", onMouseOut)
					 .transition()
					 .delay(delay)
					 .duration(duration)
					 .attr("height", function(d, i) { return d.yValue > yStart ? leftScale(yStart) - leftScale(d.yValue) : leftScale(d.yValue) - leftScale(yStart); })
					 .attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + (bottomScale.bandwidth() / data.length)) + "," + (leftScale(d.yValue < yStart ? yStart : d.yValue)) + ") skewY(-45)"; });
					
					rects.append("g").attr("class", "rectTop")
					.selectAll("rect")
					 .data(function(d, i){ d.values.map(function(b){ b.dataIndex=i; return b; }); return d.values; })
					 .enter().append("rect")
					 .attr("width", bottomScale.bandwidth() / data.length)
					 .attr("height", bar3DLen)
					 .attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + bar3DLen) + "," + (leftScale(yStart) - bar3DLen) + ") skewX(-45)"; })
					 .style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
					 .on("mousemove", onMouseMove)
					 .on("mouseout", onMouseOut)
					 .transition()
					 .delay(delay)
					 .duration(duration)
					 .attr("height", bar3DLen)
					 .attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + bar3DLen) + "," + (leftScale(d.yValue < yStart ? yStart : d.yValue) - bar3DLen) + ") skewX(-45)"; });	
				}
				
				rects.append("g").attr("class", "rectBody")
				 .selectAll("rect")
				 .data(function(d, i){ d.values.map(function(b){ b.dataIndex=i; return b; }); return d.values; })
				 .enter().append("rect")
				 .attr("x", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex); })
				 .attr("y", function(d, i) { return leftScale(d.yValue) + (bottomScale.bandwidth() / data.length * (d.yValue > yStart ? 1 : -1)); })
				 .attr("width", bottomScale.bandwidth() / data.length)
				 .attr("height", 0)
				 .style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
				 .on("mousemove", onMouseMove)
				 .on("mouseout", onMouseOut)
				 .transition()
				 .delay(delay)
				 .duration(duration)
				 .attr("y", function(d, i) { return leftScale(d.yValue); })
				 .attr("height", function(d, i) { return bottomScale.bandwidth() / data.length; });
				*/
				
				for (var i = 0; i < data[0].values.length; i++) {
				    for (var j = 0; j < data.length; j++) {
				    	var imsidata = new Array();
				    	imsidata.push(data[j].values[i]);
				      
					    //top
					    rects.append("rect")
					    .data(imsidata)
						.attr("width", bottomScale.bandwidth() / data.length)
						.attr("height", bar3DLen)
						.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + bar3DLen) + "," + (leftScale(d.yValue) + (bottomScale.bandwidth() / data.length * (d.yValue > yStart ? 1 : -1)) - bar3DLen) + ") skewX(-45)"; })
						.style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
						.on("mousemove", onMouseMove)
						.on("mouseout", onMouseOut)
						.transition()
						.delay(delay)
						.duration(duration)
						.attr("height", bar3DLen)
						.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + bar3DLen) + "," + (leftScale(d.yValue < yStart ? yStart : d.yValue) - bar3DLen) + ") skewX(-45)"; })
						;
				        
      					//right 
      					rects.append("rect")
      					.data(imsidata)
						.attr("width", bar3DLen)
						.attr("height", 0)
						.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + (bottomScale.bandwidth() / data.length)) + "," + (leftScale(d.yValue) + (bottomScale.bandwidth() / data.length * (d.yValue > yStart ? 1 : -1))) + ") skewY(-45)"; })
						.style("fill", function(d, i) { return d3.rgb(color(d.colorIndex)).darker(0.5); })
						.on("mousemove", onMouseMove)
						.on("mouseout", onMouseOut)
						.transition()
						.delay(delay)
						.duration(duration)
						.attr("height", bottomScale.bandwidth() / data.length)
						.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + (bottomScale.bandwidth() / data.length)) + "," + (leftScale(d.yValue < yStart ? yStart : d.yValue)) + ") skewY(-45)"; })
					    ;
      					
					    //body
					    rects.append("rect")
					    .data(imsidata)
      					.attr("x", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex); })
      					.attr("y", function(d, i) { return leftScale(d.yValue) + (bottomScale.bandwidth() / data.length * (d.yValue > yStart ? 1 : -1)); })
      					.attr("width", bottomScale.bandwidth() / data.length)
      					.attr("height", 0)
      					.style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
      					.on("mousemove", onMouseMove)
      					.on("mouseout", onMouseOut)
      					.transition()
      					.delay(delay)
      					.duration(duration)
      					.attr("y", function(d, i) { return leftScale(d.yValue < yStart ? yStart : d.yValue); })
      					.attr("height", bottomScale.bandwidth() / data.length)
      					;
				    }
				}
			}
			
			

		    function onMouseOver(d, i) { };
		    
		    function onMouseMove(d, i) {
		    	if (gThis.gallery == 2 && (gThis.stacked == "1" || gThis.stacked == "2")) {
					var p = d3.select(this.parentNode.parentNode.parentNode);
					p.select(".rectBody").selectAll(".rects").filter(":nth-child(" + (d.colorIndex + 1) + ")").selectAll("rect").filter(":nth-child(" + (i + 1) + ")").style('opacity', 0.7);
			    	p.select(".rectTop").selectAll(".rects").filter(":nth-child(" + (d.colorIndex + 1) + ")").selectAll("rect").filter(":nth-child(" + (i + 1) + ")").style('opacity', 0.7);
			    	p.select(".rectRight").selectAll(".rects").filter(":nth-child(" + (d.colorIndex + 1) + ")").selectAll("rect").filter(":nth-child(" + (i + 1) + ")").style('opacity', 0.7);
			    	
		    	} else {
			    	var p = d3.select(this.parentNode);
			    	var column3d = 3;  /* column, bar를 3d로 만들면 node가 1개에서 3개가 되므로 */
			    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 1) + ")").style('opacity', 0.7);
			    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 2) + ")").style('opacity', 0.7);
			    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 3) + ")").style('opacity', 0.7);
		    	}
		    	
		        tooltip_mousemove();
		    };
		    
		    function onMouseOut(d, i) {
		    	if (gThis.gallery == 2 && (gThis.stacked == "1" || gThis.stacked == "2")) {
		    		var p = d3.select(this.parentNode.parentNode.parentNode);
					p.select(".rectBody").selectAll(".rects").filter(":nth-child(" + (d.colorIndex + 1) + ")").selectAll("rect").filter(":nth-child(" + (i + 1) + ")").style('opacity', 1);
			    	p.select(".rectTop").selectAll(".rects").filter(":nth-child(" + (d.colorIndex + 1) + ")").selectAll("rect").filter(":nth-child(" + (i + 1) + ")").style('opacity', 1);
			    	p.select(".rectRight").selectAll(".rects").filter(":nth-child(" + (d.colorIndex + 1) + ")").selectAll("rect").filter(":nth-child(" + (i + 1) + ")").style('opacity', 1);
			    	
		    	} else {
			    	var p = d3.select(this.parentNode);
			    	var column3d = 3;  /* column, bar를 3d로 만들면 node가 1개에서 3개가 되므로 */
			    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 1) + ")").style('opacity', 1);
			    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 2) + ")").style('opacity', 1);
			    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 3) + ")").style('opacity', 1);
		    	}
		    	
		    	tooltip_mouseout();
		    };
		}
        
        
        function makeScatterChart() {
        	/* 크기 측정용 임시 축 만들기 시작 ------------------------------------------------- */
			bottomScale = d3.scaleLinear().domain([xmin, xmax]);
			leftScale = d3.scaleLinear().domain([ymin, ymax]);
			
			axis.append("g").attr("class", "bottomAxis").call(d3.axisBottom(bottomScale).ticks(gThis.xtick));
			axis.append("g").attr("class", "leftAxis").call(d3.axisLeft(leftScale).ticks(gThis.ytick));
			
			var getbottomAxis = axis.select(".bottomAxis").node().getBBox();
			var getleftAxis = axis.select(".leftAxis").node().getBBox();
			
			axis.select(".bottomAxis").remove();
			axis.select(".leftAxis").remove();
			/* 크기 측정용 임시 축 만들기 종료 ------------------------------------------------- */
			
			/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			margin.top += gettitle.height > 0 ? gettitle.height + 20 : 0;
			margin.top += bar3DLen;
			
			if (getlegend != "" && gThis.legendType == "right") {
				legend.attr("transform", "translate(" + (gThis.width - getlegend.width - margin.right) + ", " + margin.top + ")");
				margin.right += getlegend.width + 10;
			} else if (getlegend != "") {
				legend.attr("transform", "translate(" + ((gThis.width / 2) - (getlegend.width / 2)) + ", " + (gThis.height - margin.bottom - getlegend.height + (0 - getlegend.y)) + ")");
				margin.bottom += getlegend.height + 10;
			}
			
			label.select(".bottomtitle").attr("y", gThis.height - margin.bottom - getbottomtitle.height + (0 - getbottomtitle.y));
			margin.bottom += getbottomtitle.height > 0 ? getbottomtitle.height + 10 : 0;
			
			label.select(".lefttitle").attr("x", - (margin.top + ((gThis.height - margin.top - margin.bottom ) / 2)));
			label.select(".lefttitle").attr("y", margin.left + (0 - getlefttitle.y));
			margin.left += getlefttitle.height > 0 ? getlefttitle.height + 10 : 0;
			margin.left += getleftAxis.width;
			
			if (trendwidth > 0) margin.right += trendwidth;
			
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			label.select(".bottomtitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
			
			bottomScale = d3.scaleLinear()
						   .range([margin.left, gThis.width - margin.right])
						   .domain([xmin, xmax]);
			bottomScale.type = "scaleLinear";
			
			axis.append("g").attr("class", "bottomAxis")
				.call(d3.axisBottom(bottomScale).ticks(gThis.xtick))
				.attr("transform", "translate(0," + (gThis.height - margin.bottom) + ")")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("bottom");
			
			bottomAxisLF();
			
			
			leftScale = d3.scaleLinear()
						   .range([gThis.height - margin.bottom, margin.top])
						   .domain([ymin, ymax]);
			leftScale.type = "scaleLinear";
			
			axis.append("g").attr("class", "leftAxis")
				.call(d3.axisLeft(leftScale).ticks(gThis.ytick))
				.attr("transform", "translate(" + margin.left + ", 0)")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("left");
			
			makeChartBG();
			
			
			//차트 가로줄 그리기
			if (true || gThis.grid == 1 || gThis.grid == 3) {
				chart.append("g").attr("class","xLines")
					 .selectAll(".xLine")
					 .data(leftScale.ticks(gThis.ytick))
					 .enter().append("rect")
					 .attr("class","xLine")
					 .attr("x", margin.left)
					 .attr("y", function(d, i) { return leftScale(d); })
					 .attr("width", gThis.width - margin.left - margin.right)
					 .attr("height", 1)
					 .style("fill", "#EEEEEE");
			}
			
			//차트 세로줄 그리기
			if (gThis.grid == 2 || gThis.grid == 3) {	
				chart.append("g").attr("class","yLines")
				     .selectAll(".yLine")
				     .data(bottomScale.ticks(gThis.xtick))
				     .enter().append("rect")
				     .attr("class","yLine")
				     .attr("x", function(d, i) { return bottomScale(d); })
				     .attr("y", margin.top)
				     .attr("width", 1)
				     .attr("height", gThis.height - margin.top - margin.bottom)
				     .style("fill", "#EEEEEE");
			}		

//			if (ymin < 0) {
//				if (gThis.chart3d == "true") {
//					chart.append("rect").attr("class", "zero-plane")
//					.attr("width", bottomScale.range()[1] - bottomScale.range()[0])
//					.attr("height", bar3DLen)
//					.attr("transform", function(d, i) { return "translate (" + (bottomScale.range()[0] + bar3DLen) + "," + (leftScale(yStart) - bar3DLen) + ") skewX(-45)"; })
//					.style("fill", "#EEEEEE")
//					.style("opacity", 1);
//					
//				} else {
//					chart.append("rect").attr("class", "zero-plane")
//					.attr("x", bottomScale.range()[0])
//					.attr("y", leftScale(yStart) - 1)
//					.attr("width", bottomScale.range()[1] - bottomScale.range()[0])
//					.attr("height", 3)
//					.style("fill", "#EEEEEE");
//				}
//			}
			
			
			var paths = chart.selectAll(".paths")
			 .data(data).enter()
			 .append("g").attr("class", "paths");
			
			var symbol = d3.symbol().size([gThis.fontSize * 7]);
			
			paths.selectAll("path")
				 .data(function(d, i){ d.values.map(function(b){ b.dataIndex=i; return b; }); return d.values; })
				 .enter().append("path")
				 .attr("d", symbol.type(function(d, i) { return sybolArray[d.colorIndex]; }))
				 .attr("transform", function(d, i) { return "translate(" + bottomScale(d.xValue) + ", " + leftScale(d.yValue) + ")"  })
				 .style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")" })
				 .style('opacity', 0.95)
				 .on("mousemove", function(d, i) {
					 d3.select(this).style('opacity', 0.7);
				     tooltip.select('.tooltipText').html("<b>" + jsonData[d.colorIndex].cValue + " : " + d.xValue + ", " + d.yValue + "</b>");
				     tooltip_posiction();
				 })
				 .on("mouseout", function(d, i) {
					 d3.select(this).style('opacity', 0.95);
				     tooltip_mouseout();
				 });
        }
        
        
        function makePieChart() {
        	/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			margin.top += gettitle.height > 0 ? gettitle.height + 20 : 0;
			
			if (getlegend != "" && gThis.legendType == "right") {
				legend.attr("transform", "translate(" + (gThis.width - getlegend.width - margin.right) + ", " + margin.top + ")");
				margin.right += getlegend.width + 10;
			} else if (getlegend != "") {
				legend.attr("transform", "translate(" + ((gThis.width / 2) - (getlegend.width / 2)) + ", " + (gThis.height - margin.bottom - getlegend.height + (0 - getlegend.y)) + ")");
				margin.bottom += getlegend.height + 10;
			}
			
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
			
			makeChartBG();
			
			
			var innerWidth = gThis.width - margin.left - margin.right;
			var innerHeight = gThis.height - margin.top - margin.bottom;
			
			var h = gThis.chart3d == "true" ? 15 : 0;
			var x = margin.left + (innerWidth / 2);
			var y = margin.top + ((innerHeight - h) / 2);
			var rx = innerWidth / 2;
			var ry = (innerHeight - h) / 2;
			var r = (rx > ry ? ry : rx) * 0.75;
			var ir = gThis.gallery == 5 ? 0 : 0.4;
			
			/* 크기 측정용 임시 라벨 만들기 시작 ------------------------------------------------- */
			draw2(chart, data[0].values, x, y, r, r, h, ir);
			
			var getLabels = chart.select(".paths").node().getBBox();
			chart.select(".paths").remove();
			
			if (getLabels.width > innerWidth) rx = (innerWidth - (getLabels.width - innerWidth)) / 2;
			if (getLabels.height > innerHeight) ry = ((innerHeight - h) - (getLabels.height - (innerHeight - h))) / 2;
			
			r = (rx > ry ? ry : rx) * 0.75;
			/* 크기 측정용 임시 라벨 만들기 종료 ------------------------------------------------- */
			
			draw(chart, data[0].values, x, y, r, r, h, ir);
			
			
			function pieInner(d, rx, ry, h, ir ){
				/* 회전 시키면 안 그려지는 영역이 있어서 주석으로 막음
				var startAngle = (d.startAngle < Math.PI ? Math.PI : d.startAngle);
				var endAngle = (d.endAngle < Math.PI ? Math.PI : d.endAngle);
				*/
				var startAngle =  d.startAngle;
				var endAngle = d.endAngle;
				
				var sx = ir*rx*Math.cos(startAngle),
					sy = ir*ry*Math.sin(startAngle),
					ex = ir*rx*Math.cos(endAngle),
					ey = ir*ry*Math.sin(endAngle);

					var ret =[];
					ret.push("M",sx, sy,"A",ir*rx,ir*ry,"0 0 1",ex,ey, "L",ex,h+ey,"A",ir*rx, ir*ry,"0 0 0",sx,h+sy,"z");
					return ret.join(" ");
			}
			
			function pieLeft(d, rx, ry, h, ir ){
				var x1 = Math.cos(d.startAngle);
				var startAngle = (x1 > 0 ? Math.PI : d.startAngle);
				var endAngle = (x1 > 0? Math.PI : d.endAngle);
				var len = data[0].values.length;
				
//				if (startAngle == Math.PI && endAngle != Math.PI ) startAngle =  0;
				
				if(endAngle - startAngle == 0 ) return "M 0 0";
				var sx = rx*Math.cos(startAngle),
					sy = ry*Math.sin(startAngle),
					ex = rx*Math.cos(endAngle),
					ey = ry*Math.sin(endAngle);
				
				var sx2 = ir*(rx+0.5)*Math.cos(startAngle),
					sy2 = ir*(ry+0.5)*Math.sin(startAngle),
					ex2 = ir*(rx+0.5)*Math.cos(endAngle),
					ey2 = ir*(ry+0.5)*Math.sin(endAngle);
				
				var ret =[];
				ret.push("M",sx, sy,"A",ir*rx,ir*ry,"0 0 0",sx, h+sy, "L",sx2,h+sy2,"A",0,0,"0 0 0",ir*sx,ir*sy,"z");
				
				return ret.join(" ");
			}
			
			function pieRight(d, rx, ry, h, ir ){
				var x1 = Math.cos(d.endAngle);
				var startAngle = (x1 < 0 ? Math.PI : d.startAngle);
				var endAngle = (x1 < 0? Math.PI : d.endAngle);
				var len = data[0].values.length;
				
//				if (startAngle == Math.PI && endAngle != Math.PI ) startAngle =  0;
				
				if(endAngle - startAngle == 0 ) return "M 0 0";
				var sx = rx*Math.cos(startAngle),
					sy = ry*Math.sin(startAngle),
					ex = rx*Math.cos(endAngle),
					ey = ry*Math.sin(endAngle);
				
				var sx2 = ir*(rx+0.5)*Math.cos(startAngle),
					sy2 = ir*(ry+0.5)*Math.sin(startAngle),
					ex2 = ir*(rx+0.5)*Math.cos(endAngle),
					ey2 = ir*(ry+0.5)*Math.sin(endAngle);
				
				var ret =[];
				ret.push("M",ex, ey,"A",ir*rx,ir*ry,"0 0 0",ex, h+ey, "L",ex2,h+ey2,"A",0,0,"0 0 0",ir*ex,ir*ey,"z");
				
				return ret.join(" ");
			}

			function pieOuter(d, rx, ry, h ){
				/* 이 소스가 원본 소스인데 회전 이벤트 주면은 깨져서 아래 소스로 변경
				var startAngle = (d.startAngle > Math.PI ? Math.PI : d.startAngle);
				var endAngle = (d.endAngle > Math.PI ? Math.PI : d.endAngle);
				
				var sx = rx*Math.cos(startAngle),
					sy = ry*Math.sin(startAngle),
					ex = rx*Math.cos(endAngle),
					ey = ry*Math.sin(endAngle);
					
					var ret =[];
					ret.push("M",sx,h+sy,"A",rx,ry,"0 0 1",ex,h+ey,"L",ex,ey,"A",rx,ry,"0 0 0",sx,sy,"z");
					return ret.join(" ");
				*/
				
				var y1 = Math.sin(d.startAngle);
				var y2 = Math.sin(d.endAngle);
					
				var startAngle = (y1 < 0 ? Math.PI : d.startAngle);
				var endAngle = (y2 < 0 ? Math.PI : d.endAngle);
				
				if (startAngle == Math.PI && endAngle != Math.PI ) startAngle =  0;
				
				var sx = rx*Math.cos(startAngle),
					sy = ry*Math.sin(startAngle),
					ex = rx*Math.cos(endAngle),
					ey = ry*Math.sin(endAngle);
					
					var ret =[];
					ret.push("M",sx,h+sy,"A",rx,ry,"0 0 1",ex,h+ey,"L",ex,ey,"A",rx,ry,"0 0 0",sx,sy,"z");
					return ret.join(" ");
			}
			
			function pieTop(d, rx, ry, ir ){
				if(d.endAngle - d.startAngle == 0 ) return "M 0 0";
				var sx = rx*Math.cos(d.startAngle),
					sy = ry*Math.sin(d.startAngle),
					ex = rx*Math.cos(d.endAngle),
					ey = ry*Math.sin(d.endAngle);
					
				var ret =[];
				ret.push("M",sx,sy,"A",rx,ry,"0",(d.endAngle-d.startAngle > Math.PI? 1: 0),"1",ex,ey,"L",ir*ex,ir*ey);
				ret.push("A",ir*rx,ir*ry,"0",(d.endAngle-d.startAngle > Math.PI? 1: 0), "0",ir*sx,ir*sy,"z");
				return ret.join(" ");
			}

			function getPercent(d){
				return (d.endAngle-d.startAngle > 0.2 ? 
						Math.round(1000*(d.endAngle-d.startAngle)/(Math.PI*2))/10+'%' : '');
			}
			
			function draw (id, data, x /*center x*/, y/*center y*/, rx/*radius x*/, ry/*radius y*/, h/*height*/, ir/*inner radius*/){
				
				var _data = d3.pie().sort(null).value(function(d, i) {return d.yValue;})(data);  /* 실제로 사용되는 데이터  */
				var _data2 = d3.pie().sort(null).value(function(d, i) {return d.yValue;})(data);  /* 회전 이벤트의 처리를 위해서 필요한 원본 데이터 */
				
				var paths = id.append("g").attr("class", "paths").attr("transform", "translate(" + x + "," + y + ")").style("cursor", "pointer")
							  .call(d3.drag().on("start", dragstarted)
									  		 .on("drag", dragged)
									  		 .on("end", dragended));
				
				var line = d3.line().x(function(d, i) { return d.x; }).y(function(d, i) { return d.y; }).curve(d3.curveLinear);
				
				/* 회전 시키기 위해서 데이터에 회전할 각도를 더함 */
				for (var i = 0; i < _data.length; i++) {
					_data[i].startAngle = _data2[i].startAngle + gThis.pieRotate;
					_data[i].endAngle = _data2[i].endAngle + gThis.pieRotate;
				}
				
				paths.selectAll(".innerSlice").data(_data).enter().append("path").attr("class", "innerSlice")
					 .style("fill", function(d, i) { return d3.hsl(color(i)).darker(0.7); })
					 .attr("d",function(d, i){ return pieInner(d, rx+0.5,ry+0.5, h, ir);})
					 .each(function(d, i){this._current=d;})
					 .attr("transform", function(d, i){ return pieSice(d, i); })
					 .on("click", onClick);
				
				paths.selectAll(".leftSlice").data(_data).enter().append("path").attr("class", "leftSlice")
					 .style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + i + ")"; })
					 .style("stroke", function(d, i) {
						 var stroke = "";
						 var len = data.length;
						 indexOf = gThis.pieSliceIndex.indexOf(i);
						 var prevIndex = i == 0 ? len - 1 : i - 1;
						 var nextIndex = i == len - 1 ? 0 : i + 1;
						 var prevIndexOf = gThis.pieSliceIndex.indexOf(prevIndex);
						 var nextIndexOf = gThis.pieSliceIndex.indexOf(nextIndex);
						
						 if (indexOf > -1) {
							 stroke = "url(#" + gThis.controlId + "_gradient" + i + ")";
						 } else {
							 if (prevIndexOf > -1) stroke = "url(#" + gThis.controlId + "_gradient" + i + ")";
						 }
						 
						 return stroke;
					 })
					 .attr("d",function(d, i){ return pieLeft(d, rx, ry, h, ir);})
					 .each(function(d, i){this._current=d;})
					 .attr("transform", function(d, i){ return pieSice(d, i); })
					 .attr("fill-opacity", function(d, i) {
						 var opacity = 0;
						 var len = data.length;
						 indexOf = gThis.pieSliceIndex.indexOf(i);
						 var prevIndex = i == 0 ? len - 1 : i - 1;
						 var nextIndex = i == len - 1 ? 0 : i + 1;
						 var prevIndexOf = gThis.pieSliceIndex.indexOf(prevIndex);
						 var nextIndexOf = gThis.pieSliceIndex.indexOf(nextIndex);
						
						 if (indexOf > -1) {
							 opacity = 1;
						 } else {
							 if (prevIndexOf > -1) opacity = 1;
						 }
							
						 return opacity;
					 })
					 .on("click", onClick);
				
				paths.selectAll(".rightSlice").data(_data).enter().append("path").attr("class", "rightSlice")
					 .style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + i + ")"; })
					 .style("stroke", function(d, i) { 
						 var stroke = "";
						 var len = data.length;
						 indexOf = gThis.pieSliceIndex.indexOf(i);
						 var prevIndex = i == 0 ? len - 1 : i - 1;
						 var nextIndex = i == len - 1 ? 0 : i + 1;
						 var prevIndexOf = gThis.pieSliceIndex.indexOf(prevIndex);
						 var nextIndexOf = gThis.pieSliceIndex.indexOf(nextIndex);
						
						 if (indexOf > -1) {
							 stroke = "url(#" + gThis.controlId + "_gradient" + i + ")";
						 } else {
							 if (nextIndexOf > -1) stroke = "url(#" + gThis.controlId + "_gradient" + i + ")";
						 }
							
						 return stroke;
					 })
					 .attr("d",function(d, i){ return pieRight(d, rx, ry, h, ir);})
					 .each(function(d, i){this._current=d;})
					 .attr("transform", function(d, i){ return pieSice(d, i); })
					 .attr("fill-opacity", function(d, i) {
						 var opacity = 0;
						 var len = data.length;
						 indexOf = gThis.pieSliceIndex.indexOf(i);
						 var prevIndex = i == 0 ? len - 1 : i - 1;
						 var nextIndex = i == len - 1 ? 0 : i + 1;
						 var prevIndexOf = gThis.pieSliceIndex.indexOf(prevIndex);
						 var nextIndexOf = gThis.pieSliceIndex.indexOf(nextIndex);
						
						 if (indexOf > -1) {
							 opacity = 1;
						 } else {
							 if (nextIndexOf > -1) opacity = 1;
						 }
							
						 return opacity;
					 })
					 .on("click", onClick);
					 
				paths.selectAll(".outerSlice").data(_data).enter().append("path").attr("class", "outerSlice")
					 .style("fill", function(d, i) { return d3.hsl(color(i)).darker(0.7); })
					 .attr("d",function(d, i){ return pieOuter(d, rx-.5,ry-.5, h);})
					 .each(function(d, i){this._current=d;})
					 .attr("transform", function(d, i){ return pieSice(d, i); })
					 .on("click", onClick);
				
				paths.selectAll(".topSlice").data(_data).enter().append("path").attr("class", "topSlice")
					 .style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + i + ")"; })
					 .style("stroke", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + i + ")"; })
					 .attr("d",function(d, i){ return pieTop(d, rx, ry, ir);})
					 .each(function(d, i){this._current=d;})
					 .attr("transform", function(d, i){ return pieSice(d, i); })
					 .on("click", onClick);
				
				/* 그래프 중앙에 텍스트 그리기
				paths.selectAll(".percent").data(_data).enter().append("text").attr("class", "percent")
					 .attr("x",function(d, i){ return 0.6*rx*Math.cos(0.5*(d.startAngle+d.endAngle));})
					 .attr("y",function(d, i){ return 0.6*ry*Math.sin(0.5*(d.startAngle+d.endAngle));})
					 .text(getPercent).each(function(d, i){this._current=d;})
					 .style("fill", "white")
					 .style("text-anchor", "middle")
					 .style("font-size",  gThis.fontSize + "px")
					 .on("click", onClick);
				*/
				
				/* 그래프 외각에 텍스트 그리기 */
				paths.selectAll(".percent").data(_data).enter().append("text").attr("class", "percent")
				 .attr("x", function(d) {
						var circleX = rx*Math.cos(0.5*(d.startAngle+d.endAngle));
		                return circleX > 0 ? rx*1.3 : -rx*1.3;
				 })
				 .attr("y", function(d) {
					 var circleY = ry*Math.sin(0.5*(d.startAngle+d.endAngle));
					 return circleY * 1.1;
				 })
				 .text(function(d, i) { return Math.round(1000*(d.endAngle-d.startAngle)/(Math.PI*2))/10+'%'; })
				 .style('text-anchor', function(d) { 
					 var circleX = rx*Math.cos(0.5*(d.startAngle+d.endAngle));
					 return 0 < circleX ? 'start' : 'end';  
				 })
				 .style("fill", "black")
				 .style("alignment-baseline", "middle")
				 .style("font-size",  gThis.fontSize + "px")
				 .attr("transform", function(d, i){ return pieSice(d, i); })
				 .on("click", onClick);
				
				/* 그래프 외각 있는 텍스트까지 라인 그리기 */
				paths.selectAll(".polyLines").data(_data).enter().append("path").attr("class", "polyLines")
	            .attr('d', function(d, i) {
	            	var circleX = rx*Math.cos(0.5*(d.startAngle+d.endAngle));
	            	var circleY = ry*Math.sin(0.5*(d.startAngle+d.endAngle));
	                var lineData = new Array();
	                var temp = {};
	                temp["x"] = circleX * 0.6;
	                temp["y"] = circleY * 0.6;
	                lineData.push(temp);
	                temp = {};
	                temp["x"] = circleX * 1.1;
	                temp["y"] = circleY * 1.1;
	                lineData.push(temp);
	                temp = {};
	                temp["x"] = circleX > 0 ? rx * 1.2 : -rx * 1.2;;
	                temp["y"] = circleY * 1.1;
	                lineData.push(temp);
	                return line(lineData);
	            })
	            .style('stroke', 'black')
			    .style('stroke-width', '2px')
			    .style('opacity', '0.3')
			    .style('fill', 'none')
			    .attr("transform", function(d, i){ return pieSice(d, i); })
			    .on("click", onClick);
				
				legend.selectAll(".legends").select(".legend-cover").on("click", function(d, i) { return onClick(_data[i], i); });
				
				function pieSice(d, i) {
					var x = 0;
	                var y = 0;
					var circleX = rx*Math.cos(0.5*(d.startAngle+d.endAngle));
		            var circleY = ry*Math.sin(0.5*(d.startAngle+d.endAngle));
		            var index = gThis.pieSliceIndex.indexOf(i);
		            
		            if (index > -1) {
		            	x = circleX * 0.3;
			            y = circleY * 0.3;
		            }
		            
		            return "translate(" + x + "," + y + ")";
			    };
			    
				function onClick(d, i) {
					var len = data.length;
					var x = 0;
	                var y = 0;
					var circleX = rx*Math.cos(0.5*(d.startAngle+d.endAngle));
		            var circleY = ry*Math.sin(0.5*(d.startAngle+d.endAngle));
		            var indexOf = gThis.pieSliceIndex.indexOf(i);
		            
		            if (indexOf > -1) {
		            	gThis.pieSliceIndex.splice(indexOf, 1);
		            } else {
		            	gThis.pieSliceIndex[gThis.pieSliceIndex.length] = i;
		            	x = circleX * 0.3;
			            y = circleY * 0.3;
		            }
		            
		            chart.select(".paths").selectAll(".innerSlice").filter(":nth-child(" + ((len * 0) + i + 1) + ")").attr("transform", "translate(" + x + "," + y + ")");
		            chart.select(".paths").selectAll(".leftSlice").filter(":nth-child(" + ((len * 1) + i + 1) + ")").attr("transform", "translate(" + x + "," + y + ")");
		            chart.select(".paths").selectAll(".rightSlice").filter(":nth-child(" + ((len * 2) + i + 1) + ")").attr("transform", "translate(" + x + "," + y + ")");
					chart.select(".paths").selectAll(".outerSlice").filter(":nth-child(" + ((len * 3) + i + 1) + ")").attr("transform", "translate(" + x + "," + y + ")");
					chart.select(".paths").selectAll(".topSlice").filter(":nth-child(" + ((len * 4) + i + 1) + ")").attr("transform", "translate(" + x + "," + y + ")");
					chart.select(".paths").selectAll(".percent").filter(":nth-child(" + ((len * 5) + i + 1) + ")").attr("transform", "translate(" + x + "," + y + ")");
					chart.select(".paths").selectAll(".polyLines").filter(":nth-child(" + ((len * 6) + i + 1) + ")").attr("transform", "translate(" + x + "," + y + ")");
					
					
					indexOf = gThis.pieSliceIndex.indexOf(i);
					var prevIndex = i == 0 ? len - 1 : i - 1;
					var nextIndex = i == len - 1 ? 0 : i + 1;
					var prevIndexOf = gThis.pieSliceIndex.indexOf(prevIndex);
					var nextIndexOf = gThis.pieSliceIndex.indexOf(nextIndex);
					
					if (indexOf > -1) {
						chart.select(".paths").selectAll(".leftSlice").filter(":nth-child(" + ((len * 1) + i + 1) + ")").attr("fill-opacity", 1);
						chart.select(".paths").selectAll(".leftSlice").filter(":nth-child(" + ((len * 1) + i + 1) + ")").attr("stroke", "url(#" + gThis.controlId + "_gradient" + i + ")");
				        chart.select(".paths").selectAll(".rightSlice").filter(":nth-child(" + ((len * 2) + i + 1) + ")").attr("fill-opacity", 1);
				        chart.select(".paths").selectAll(".rightSlice").filter(":nth-child(" + ((len * 2) + i + 1) + ")").attr("stroke", "url(#" + gThis.controlId + "_gradient" + i + ")");
				        
				        chart.select(".paths").selectAll(".leftSlice").filter(":nth-child(" + ((len * 1) + nextIndex + 1) + ")").attr("fill-opacity", 1);
				        chart.select(".paths").selectAll(".leftSlice").filter(":nth-child(" + ((len * 1) + nextIndex + 1) + ")").attr("stroke", "url(#" + gThis.controlId + "_gradient" + nextIndex + ")");
						chart.select(".paths").selectAll(".rightSlice").filter(":nth-child(" + ((len * 2) + prevIndex + 1) + ")").attr("fill-opacity", 1);
						chart.select(".paths").selectAll(".rightSlice").filter(":nth-child(" + ((len * 2) + prevIndex + 1) + ")").attr("stroke", "url(#" + gThis.controlId + "_gradient" + prevIndex + ")");
					} else {
						if (prevIndexOf > -1) {
							chart.select(".paths").selectAll(".leftSlice").filter(":nth-child(" + ((len * 1) + i + 1) + ")").attr("fill-opacity", 1);
							chart.select(".paths").selectAll(".leftSlice").filter(":nth-child(" + ((len * 1) + i + 1) + ")").attr("stroke", "url(#" + gThis.controlId + "_gradient" + i + ")");
							chart.select(".paths").selectAll(".rightSlice").filter(":nth-child(" + ((len * 2) + prevIndex + 1) + ")").attr("fill-opacity", 1);
							chart.select(".paths").selectAll(".rightSlice").filter(":nth-child(" + ((len * 2) + prevIndex + 1) + ")").attr("stroke", "url(#" + gThis.controlId + "_gradient" + prevIndex + ")");
						} else {
							chart.select(".paths").selectAll(".leftSlice").filter(":nth-child(" + ((len * 1) + i + 1) + ")").attr("fill-opacity", 0);
							chart.select(".paths").selectAll(".leftSlice").filter(":nth-child(" + ((len * 1) + i + 1) + ")").attr("stroke", null);
							chart.select(".paths").selectAll(".rightSlice").filter(":nth-child(" + ((len * 2) + prevIndex + 1) + ")").attr("fill-opacity", 0);
							chart.select(".paths").selectAll(".rightSlice").filter(":nth-child(" + ((len * 2) + prevIndex + 1) + ")").attr("stroke", null);
						}
						
						if (nextIndexOf > -1) {
							chart.select(".paths").selectAll(".rightSlice").filter(":nth-child(" + ((len * 2) + i + 1) + ")").attr("fill-opacity", 1);
							chart.select(".paths").selectAll(".rightSlice").filter(":nth-child(" + ((len * 2) + i + 1) + ")").attr("stroke", "url(#" + gThis.controlId + "_gradient" + i + ")");
							chart.select(".paths").selectAll(".leftSlice").filter(":nth-child(" + ((len * 1) + nextIndex + 1) + ")").attr("fill-opacity", 1);
							chart.select(".paths").selectAll(".leftSlice").filter(":nth-child(" + ((len * 1) + nextIndex + 1) + ")").attr("stroke", "url(#" + gThis.controlId + "_gradient" + nextIndex + ")");
						} else {
							chart.select(".paths").selectAll(".rightSlice").filter(":nth-child(" + ((len * 2) + i + 1) + ")").attr("fill-opacity", 0);
							chart.select(".paths").selectAll(".rightSlice").filter(":nth-child(" + ((len * 2) + i + 1) + ")").attr("stroke", null);
							chart.select(".paths").selectAll(".leftSlice").filter(":nth-child(" + ((len * 1) + nextIndex + 1) + ")").attr("fill-opacity", 0);
							chart.select(".paths").selectAll(".leftSlice").filter(":nth-child(" + ((len * 1) + nextIndex + 1) + ")").attr("stroke", null);
						}
					}
			    };
				
			    
			    /* pie 회전 이벤트 시작 ----------------------------------------------- */
				function  dragstarted(d) {
					var topSlice = d3.select(this).selectAll(".topSlice").filter(":nth-child(" + ((data.length * 4) + 1) + ")").data()[0];  /* pie의 첫 번째 조각 */
					var topSliceAngle = getAngle(Math.cos(topSlice.startAngle), Math.sin(topSlice.startAngle));  /* pie의 첫 번째 조각의 startAngle의 각도 */
					var mouseAngle = getAngle(d3.mouse(this)[0], d3.mouse(this)[1]);  /* 마우스의 각도 */
					 
					gThis.pieStartRotate = topSliceAngle;
					gThis.pieStartAngle = mouseAngle;
				}

				function  dragged(d) {
					var mouseAngle = getAngle(d3.mouse(this)[0], d3.mouse(this)[1]);  /* 마우스의 각도 */
					
					gThis.pieRotate = mouseAngle + gThis.pieStartRotate - gThis.pieStartAngle;
					
					/* 회전 시키기 위해서 데이터에 회전할 각도를 더함 */
					for (var i = 0; i < _data.length; i++) {
						_data[i].startAngle = _data2[i].startAngle + gThis.pieRotate;
						_data[i].endAngle = _data2[i].endAngle + gThis.pieRotate;
					}
					
					paths.selectAll(".innerSlice")
						 .attr("d",function(d, i){ return pieInner(d, rx+0.5,ry+0.5, h, ir);})
						 .each(function(d, i){this._current=d;})
						 .attr("transform", function(d, i){ return pieSice(d, i); });
					
					paths.selectAll(".leftSlice")
						 .attr("d",function(d, i){ return pieLeft(d, rx, ry, h, ir);})
						 .each(function(d, i){this._current=d;})
						 .attr("transform", function(d, i){ return pieSice(d, i); });
					
					paths.selectAll(".rightSlice")
						 .attr("d",function(d, i){ return pieRight(d, rx, ry, h, ir);})
						 .each(function(d, i){this._current=d;})
						 .attr("transform", function(d, i){ return pieSice(d, i); });
					
					paths.selectAll(".outerSlice")
						 .attr("d",function(d, i){ return pieOuter(d, rx-.5,ry-.5, h);})
						 .each(function(d, i){this._current=d;})
						 .attr("transform", function(d, i){ return pieSice(d, i); });
					
					paths.selectAll(".topSlice")
						 .attr("d",function(d, i){ return pieTop(d, rx, ry, ir);})
						 .each(function(d, i){this._current=d;})
						 .attr("transform", function(d, i){ return pieSice(d, i); });
					
					/* 그래프 중앙에 텍스트 그리기
					paths.selectAll(".percent")
						 .attr("x",function(d, i){ return 0.6*rx*Math.cos(0.5*(d.startAngle+d.endAngle));})
						 .attr("y",function(d, i){ return 0.6*ry*Math.sin(0.5*(d.startAngle+d.endAngle));})
						 .text(getPercent).each(function(d, i){this._current=d;});
					*/
					
					/* 그래프 외각에 텍스트 그리기 */
					paths.selectAll(".percent")
						 .attr("x", function(d) {
								var circleX = rx*Math.cos(0.5*(d.startAngle+d.endAngle));
				                return circleX > 0 ? rx*1.3 : -rx*1.3;
						 })
						 .attr("y", function(d) {
							 var circleY = ry*Math.sin(0.5*(d.startAngle+d.endAngle));
							 return circleY * 1.1;
						 })
						 .text(function(d, i) { return Math.round(1000*(d.endAngle-d.startAngle)/(Math.PI*2))/10+'%'; })
						 .style('text-anchor', function(d) { 
							 var circleX = rx*Math.cos(0.5*(d.startAngle+d.endAngle));
							 return 0 < circleX ? 'start' : 'end';  
						 })
						 .attr("transform", function(d, i){ return pieSice(d, i); });
					
					/* 그래프 외각 있는 텍스트까지 라인 그리기 */
					paths.selectAll(".polyLines")
			             .attr('d', function(d, i) {
			            	 var circleX = rx*Math.cos(0.5*(d.startAngle+d.endAngle));
			            	 var circleY = ry*Math.sin(0.5*(d.startAngle+d.endAngle));
			                 var lineData = new Array();
			                 var temp = {};
			                 temp["x"] = circleX * 0.6;
			                 temp["y"] = circleY * 0.6;
			                 lineData.push(temp);
			                 temp = {};
			                 temp["x"] = circleX * 1.1;
			                 temp["y"] = circleY * 1.1;
			                 lineData.push(temp);
			                 temp = {};
			                 temp["x"] = circleX > 0 ? rx * 1.2 : -rx * 1.2;;
			                 temp["y"] = circleY * 1.1;
			                 lineData.push(temp);
			                 return line(lineData);
			             })
					     .attr("transform", function(d, i){ return pieSice(d, i); });
				}

				function  dragended(d) { }
				
				function getAngle(x, y){
					var angle = Math.atan2(y, x) * 180 / Math.PI;
					if (angle < 0) angle += 360;
					
					var piece = 180 / Math.PI;  /*  */
					
					return angle / piece;
				}
				/* pie 회전 이벤트 종료 ----------------------------------------------- */
			}
			
			
			/* 그려진 그래프의 크기를 측정하기 위해 라벨만 그려서 크기 측정하는 용도 */
			function draw2 (id, data, x /*center x*/, y/*center y*/, rx/*radius x*/, ry/*radius y*/, h/*height*/, ir/*inner radius*/){
				
				var _data = d3.pie().sort(null).value(function(d, i) {return d.yValue;})(data);
				
				var paths = id.append("g").attr("class", "paths").attr("transform", "translate(" + x + "," + y + ")");
				
				var line = d3.line().x(function(d, i) { return d.x; }).y(function(d, i) { return d.y; }).curve(d3.curveLinear);
				
				
				/* 그래프 외각에 텍스트 그리기 */
				paths.selectAll(".percent").data(_data).enter().append("text").attr("class", "percent")
				.attr('transform', function(d) { 
					var circleX = rx*Math.cos(0.5*(d.startAngle+d.endAngle));
	        		var circleY = ry*Math.sin(0.5*(d.startAngle+d.endAngle));
	                return 'translate(' + (circleX > 0 ? rx*1.3 : -rx*1.3) + ',' + circleY * 1.1 + ')';
	             })
				 .text(function(d, i) { return Math.round(1000*(d.endAngle-d.startAngle)/(Math.PI*2))/10+'%'; })
				 .style('text-anchor', function(d) { 
					 var circleX = rx*Math.cos(0.5*(d.startAngle+d.endAngle));
					 return 0 < circleX ? 'start' : 'end';  
				 })
				 .style("alignment-baseline", "middle")
				 .style("font-size",  gThis.fontSize + "px")
				 .style('opacity', '0');
				
				/* 그래프 외각 있는 텍스트까지 라인 그리기 */
				paths.selectAll(".polyLines").data(_data).enter().append("path").attr("class", "polyLines")
	            .attr('d', function(d, i) {
	            	var circleX = rx*Math.cos(0.5*(d.startAngle+d.endAngle));
	            	var circleY = ry*Math.sin(0.5*(d.startAngle+d.endAngle));
	                var lineData = new Array();
	                var temp = {};
	                temp["x"] = circleX * 0.6;
	                temp["y"] = circleY * 0.6;
	                lineData.push(temp);
	                temp = {};
	                temp["x"] = circleX * 1.1;
	                temp["y"] = circleY * 1.1;
	                lineData.push(temp);
	                temp = {};
	                temp["x"] = circleX > 0 ? rx * 1.2 : -rx * 1.2;;
	                temp["y"] = circleY * 1.1;
	                lineData.push(temp);
	                return line(lineData);
	            })
			    .style('stroke-width', '2px')
			    .style('opacity', '0');
			}
        }
        
        
        function makeAreaChart() {
        	if ((gThis.stacked == "1" || gThis.stacked == "2")) getStackData();
			
			/* 크기 측정용 임시 축 만들기 시작 ------------------------------------------------- */
//			bottomScale = d3.scaleTime().domain(d3.extent(data[0].values, function(d, i) { return d.xValue; }));
			bottomScale = d3.scaleBand().range([margin.left, gThis.width - margin.right]).domain(data[0].values.map(function(d, i){ return d.xValue; }));
			leftScale = d3.scaleLinear().domain([ymin, ymax]);
			
			axis.append("g").attr("class", "bottomAxis").call(d3.axisBottom(bottomScale));
			if (gThis.stacked == "2") axis.append("g").attr("class", "leftAxis").call(d3.axisLeft(leftScale).ticks(gThis.ytick, "%"));
			else axis.append("g").attr("class", "leftAxis").call(d3.axisLeft(leftScale).ticks(gThis.ytick));
			
			var getbottomAxis = axis.select(".bottomAxis").node().getBBox();
			var getleftAxis = axis.select(".leftAxis").node().getBBox();
			
			axis.select(".bottomAxis").remove();
			axis.select(".leftAxis").remove();
			/* 크기 측정용 임시 축 만들기 종료 ------------------------------------------------- */
			
			
			/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			margin.top += gettitle.height > 0 ? gettitle.height + 20 : 0;
			
			if (getlegend != "" && gThis.legendType == "right") {
				legend.attr("transform", "translate(" + (gThis.width - getlegend.width - margin.right) + ", " + margin.top + ")");
				margin.right += getlegend.width + 10;
			} else if (getlegend != "") {
				legend.attr("transform", "translate(" + ((gThis.width / 2) - (getlegend.width / 2)) + ", " + (gThis.height - margin.bottom - getlegend.height + (0 - getlegend.y)) + ")");
				margin.bottom += getlegend.height + 10;
			}
			
			label.select(".bottomtitle").attr("y", gThis.height - margin.bottom - getbottomtitle.height + (0 - getbottomtitle.y));
			margin.bottom += getbottomtitle.height > 0 ? getbottomtitle.height + 10 : 0;
			
			label.select(".lefttitle").attr("x", - (margin.top + ((gThis.height - margin.top - margin.bottom ) / 2)));
			label.select(".lefttitle").attr("y", margin.left + (0 - getlefttitle.y));
			margin.left += getlefttitle.height > 0 ? getlefttitle.height + 10 : 0;
			margin.left += getleftAxis.width;
			
			if (trendwidth > 0) margin.right += trendwidth;
			
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			label.select(".bottomtitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
			
//			bottomScale = d3.scaleTime()
//							   .range([margin.left, gThis.width - margin.right])
//							   .domain(d3.extent(data[0].values, function(d, i) { return d.xValue; }));
			bottomScale = d3.scaleBand().range([margin.left, gThis.width - margin.right])
			.domain(data[0].values.map(function(d, i){ return d.xValue; }))
			.padding(1).paddingOuter(0);
			bottomScale.type = "scaleBand";
			
			axis.append("g").attr("class", "bottomAxis")
				.call(d3.axisBottom(bottomScale).ticks(gThis.ytick))
				.attr("transform", "translate(0," + (gThis.height - margin.bottom) + ")")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("bottom");
			
			bottomAxisLF();
			
			
			leftScale = d3.scaleLinear()
			   .range([gThis.height - margin.bottom, margin.top])
			   .domain([ymin, ymax]);
			leftScale.type = "scaleLinear";
			
			/* stack percent의 경우 max 값이 1이기 때문에 100% 보이게 함*/
			if (gThis.stacked == "2") {
				axis.append("g").attr("class", "leftAxis")
					.call(d3.axisLeft(leftScale).ticks(gThis.ytick, "%"))
					.attr("transform", "translate(" + margin.left + ", 0)")
					.style("font-size", gThis.fontSize + "px");
				
			} else {
				axis.append("g").attr("class", "leftAxis")
					.call(d3.axisLeft(leftScale).ticks(gThis.ytick))
					.attr("transform", "translate(" + margin.left + ", 0)")
					.style("font-size", gThis.fontSize + "px");
			}
			
			findTicks("left");
			
			makeChartBG();
			
			
			//차트 가로줄 그리기
			if (true || gThis.grid == 1 || gThis.grid == 3) {
				chart.append("g").attr("class","xLines")
				     .selectAll(".xLine")
				     .data(leftScale.ticks(gThis.ytick))
				     .enter().append("rect")
				     .attr("class","xLine")
				     .attr("x", margin.left)
				     .attr("y", function(d, i) { return leftScale(d); })
				     .attr("width", gThis.width - margin.left - margin.right)
				     .attr("height", 1)
				     .style("fill", "#EEEEEE");
			}
			
			//차트 세로줄 그리기
			if (gThis.grid == 2 || gThis.grid == 3) {		
				chart.append("g").attr("class","yLines")
				     .selectAll(".yLine")
				     .data(data[0].values)
				     .enter().append("rect")
				     .attr("class","yLine")
				     .attr("x", function(d, i) { return bottomScale(d.xValue); })
				     .attr("y", margin.top)
				     .attr("width", 1)
				     .attr("height", gThis.height - margin.top - margin.bottom)
				     .style("fill", "#EEEEEE");
			}
			
			
			svg.on("mousemove", function(d, i) { tooltipLine_mousemove(); tooltip_mousemove(); })
			   .on("mouseout", function(d, i) { tooltipLine_mouseout(); tooltip_mouseout(); });
			
			var areas = chart.append('g').attr('class', 'areas');
			
			if ((gThis.stacked == "1" || gThis.stacked == "2")) {
				var startArea = d3.area()
			    .x(function(d, i) { return bottomScale(d.data.xValue); })
			    .y0(leftScale(yStart))
			    .y1(leftScale(yStart))
			    .curve(curveArray[gThis.curveType]);
				
				var endArea = d3.area()
			    .x(function(d, i) { return bottomScale(d.data.xValue); })
			    .y0(function(d, i) { return leftScale(d[0]); })
			    .y1(function(d, i) { return leftScale(d[1]); })
			    .curve(curveArray[gThis.curveType]);
				
				areas.selectAll('.area')
					 .data(stackData).enter()
					 .append("path")
			         .data(stackData)
			         .attr("class", "area")
			         .attr('d', function(d, i) { return startArea(d); })
			         .style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
			         .style('opacity', 0.7)
			         .on('mousemove', onMouseMove)
			         .on('mouseout', onMouseOut)		         
			         .transition()
			         .delay(delay)
					 .duration(duration)
			         .attr('d', function(d, i) { return endArea(d); });
				
			} else {
				var startArea = d3.area()
			    .x(function(d, i) { return bottomScale(d.xValue); })
			    .y0(leftScale(yStart))
			    .y1(leftScale(yStart))
			    .curve(curveArray[gThis.curveType]);
				
				var endArea = d3.area()
			    .x(function(d, i) { return bottomScale(d.xValue); })
			    .y0(leftScale(yStart))
			    .y1(function(d, i) { return leftScale(d.yValue); })
			    .curve(curveArray[gThis.curveType]);
				
				areas.selectAll('.area')
					 .data(data).enter()
					 .append("path")
			         .data(data)
			         .attr("class", "area")
			         .attr('d', function(d, i) { return startArea(d.values); })
			         .style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
			         .style('opacity', 0.7)
			         .on('mousemove', onMouseMove)
			         .on('mouseout', onMouseOut)		         
			         .transition()
			         .delay(delay)
					 .duration(duration)
			         .attr('d', function(d, i) { return endArea(d.values); });
			}
			
			
			/* tooltipLine을 그래프 맨 위로 올리기 위해서 다시 선언함 */
			tooltipLine = svg.append("rect")
							 .attr("class","tooltipLine")
							 .attr("y", margin.top)
							 .attr("width", 1)
							 .attr("height", gThis.height - margin.top - margin.bottom)
							 .style("fill", "#EEEEEE")
							 .style("opacity", 0);
					
			function onMouseMove(d, i) {
				
			};
			
			function onMouseOut(d, i) {

			};
        }
        
        
        function makeComboChart() {
			
			/*
			 * column, line, area를 그리기 위해서 각각의 데이터로 분리
			 */
			var columnData = [];
			var lineData = [];
			var areaData = [];
			
			for (var i = 0; i < data.length; i++) {
				var renderas = data[i].renderas == null ? "" : data[i].renderas;
				var imsiData = JSON.parse(JSON.stringify(data));
				
				if (renderas.toLowerCase() == "line") lineData[lineData.length] = imsiData.splice(i,1)[0];
				else if (renderas.toLowerCase() == "area") areaData[areaData.length] = imsiData.splice(i,1)[0];
				else columnData[columnData.length] = imsiData.splice(i,1)[0];
			}
			
			/* 
			 * column에 사용할 필요한 컬럼 추가
			 * dataIndex = 범례에서 불 꺼진 데이터 삭제후 data의 index
			 * index = data의 values 안에 index
			 */
			var dataIndex = 0;
			columnData.forEach(function(d, i) {
				var index = 0;
				if (d.values != undefined) {
					d.values.map(function(b){ 
						b.dataIndex = dataIndex;
						b.index = index++;
						return b;
					})
					if (gThis.outLegendData.indexOf(columnData[i].colorIndex) == -1) dataIndex++;
				}
			});
			
			/*
			 * stack데이터 만들기
			 */
			if ((gThis.stacked == "1" || gThis.stacked == "2")) {
				if (columnData.length > 0) columnData = getComboStackData(columnData);
				if (areaData.length > 0) areaData = getComboStackData(areaData);
			}
			
			/*
			 * 개요 : 데이터를 stack데이터로 가공
			 */
			function getComboStackData(sliceData) {
				
				function formatData(d) {
		            //d.xValue = parseDate(new Date(d.xValue));
		            group.forEach(function(c) {
		                d[c] = +d[c];
		            });
		            return d;
		        }
		        
		        function stackMin(stackData) {
		            return d3.min(stackData, function(d, i) {
		                return d[0];
		            });
		        }
		
		        function stackMax(stackData) {
		            return d3.max(stackData, function(d, i) {
		                return  d[1];
		            });
		        }
		        
				//데이터 JSON 모양 변경
				var group = [];
				var newData = "[";
				for (var i = 0; i < sliceData[0].values.length; i++) {
					newData +=	"{ \"xValue\":\"" +  sliceData[0].values[i].xValue + "\","
					for (var j = 0; j < sliceData.length; j++) {
						group[j] =  sliceData[j].cValue;
						newData += "\"" + sliceData[j].cValue + "\":\"" + sliceData[j].values[i].yValue + "\"";
						if (j+1 < sliceData.length) newData+=","; 
					}
					newData += "}";
					if (i+1 < sliceData[0].values.length) newData+=","; 
				}
				newData += "]";
				newData = JSON.parse(newData);
				
				
				/* Format Data */
				newData.forEach(function(d, i) {
		            d = formatData(d);
		        });
				
		        
				/* 누적형 */
				if (gThis.stacked == "1")
					stackData = d3.stack().keys(group).offset(d3.stackOffsetDiverging)(newData);
				
				/* 100% 누적형 */
				else if (gThis.stacked == "2")
					stackData = d3.stack().keys(group).offset(d3.stackOffsetExpand)(newData);
				
		        
		        /* stackData의 배열이 1개 일 때 음수가 있어도 음수 인식을 못해서 수동으로 변경함 */
		        if (stackData.length == 1) {
		        	for (var i = 0; i < stackData[0].length; i++) {
		        		var num0 = stackData[0][i][0];
		        		var num1 = stackData[0][i][1];
		        		
		        		if (num1 < 0) {
		        			stackData[0][i][0] = num1;
		        			stackData[0][i][1] = num0;
		        		}
		        	}
		        }
		        
		        /* 
				 * 필요한 컬럼 추가 
				 */
		        var dataIndex = 0;
		        for (var i = 0; i < stackData.length; i++) {
		        	for (var j = 0; j < data.length; j++) {
		        		if (stackData[i].key == data[j].cValue) {
		        			stackData[i].colorIndex = data[j].colorIndex;
		        			
		        			for (var k = 0; k < stackData[i].length; k++) {
		        				stackData[i][k].colorIndex = data[j].colorIndex;
		        			}
		        			
		        			break;
		        		}
		        	}
		        }
		        
				max = d3.max(stackData, stackMax);
				min = d3.min(stackData, stackMin);
				if (max > ymax) ymax = max;
				if (min < ymin) ymin = min;
				yStart = ymin > 0 ? ymin : 0;
				
		        return stackData;
			}
			
			
				
			/* 크기 측정용 임시 축 만들기 시작 ------------------------------------------------- */
			bottomScale = d3.scaleBand().domain(data[0].values.map(function(d, i){ return d.xValue; }));
			leftScale = d3.scaleLinear().domain([ymin, ymax]);
			rightScale = d3.scaleLinear().domain([ymin2, ymax2]);
			
			axis.append("g").attr("class", "bottomAxis").call(d3.axisBottom(bottomScale));
			if (gThis.stacked == "2") axis.append("g").attr("class", "leftAxis").call(d3.axisLeft(leftScale).ticks(gThis.ytick, "%"));
			else axis.append("g").attr("class", "leftAxis").call(d3.axisLeft(leftScale).ticks(gThis.ytick));
			axis.append("g").attr("class", "rightAxis").call(d3.axisRight(rightScale).ticks(gThis.ytick));
			
			var getbottomAxis = axis.select(".bottomAxis").node().getBBox();
			var getleftAxis = axis.select(".leftAxis").node().getBBox();
			var getrightAxis = axis.select(".rightAxis").node().getBBox();
			
			axis.select(".bottomAxis").remove();
			axis.select(".leftAxis").remove();
			axis.select(".rightAxis").remove();
			/* 크기 측정용 임시 축 만들기 종료 ------------------------------------------------- */
			
			/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			margin.top += gettitle.height > 0 ? gettitle.height + 20 : 0;
			margin.top += bar3DLen;
			
			if (getlegend != "" && gThis.legendType == "right") {
				legend.attr("transform", "translate(" + (gThis.width - getlegend.width - margin.right) + ", " + margin.top + ")");
				margin.right += getlegend.width + 10;
			} else if (getlegend != "") {
				legend.attr("transform", "translate(" + ((gThis.width / 2) - (getlegend.width / 2)) + ", " + (gThis.height - margin.bottom - getlegend.height + (0 - getlegend.y)) + ")");
				margin.bottom += getlegend.height + 10;
			}
			
			label.select(".bottomtitle").attr("y", gThis.height - margin.bottom - getbottomtitle.height + (0 - getbottomtitle.y));
			margin.bottom += getbottomtitle.height > 0 ? getbottomtitle.height + 10 : 0;
			
			label.select(".lefttitle").attr("x", - (margin.top + ((gThis.height - margin.top - margin.bottom ) / 2)));
			label.select(".lefttitle").attr("y", margin.left + (0 - getlefttitle.y));
			margin.left += getlefttitle.height > 0 ? getlefttitle.height + 10 : 0;
			margin.left += getleftAxis.width;
			
			label.select(".righttitle").attr("x", (margin.top + ((gThis.height - margin.top - margin.bottom ) / 2)));
			label.select(".righttitle").attr("y", - (gThis.width - margin.right - (0 - getrighttitle.y)));
			margin.right += getrighttitle.height > 0 ? getrighttitle.height + 10 : 0;
			
			if (trendwidth > 0 && !(isNaN(ymax2) && isNaN(ymin2)))
				margin.right += trendwidth > getrightAxis.width ? trendwidth : getrightAxis.width;
			else if (trendwidth > 0)
				margin.right += trendwidth;
			else if (!(isNaN(ymax2) && isNaN(ymin2)))
				margin.right += getrightAxis.width;
			
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			label.select(".bottomtitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
			
			bottomScale = d3.scaleBand()
						   .range([margin.left, gThis.width - margin.right])
						   .domain(data[0].values.map(function(d, i){ return d.xValue; }))
						   .padding(0.4).paddingOuter(0.2);
			
			bottomScale.type = "scaleBand";
			
			axis.append("g").attr("class", "bottomAxis")
				.call(d3.axisBottom(bottomScale))
				.attr("transform", "translate(0," + (gThis.height - margin.bottom) + ")")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("bottom");
			
			bottomAxisLF();
			
			
			leftScale = d3.scaleLinear()
						   .range([gThis.height - margin.bottom, margin.top])
						   .domain([ymin, ymax]);
			leftScale.type = "scaleLinear";
			
			/* stack percent의 경우 max 값이 1이기 때문에 100% 보이게 함*/
			if (gThis.stacked == "2") {
				axis.append("g").attr("class", "leftAxis")
					.call(d3.axisLeft(leftScale).ticks(gThis.ytick, "%"))
					.attr("transform", "translate(" + margin.left + ", 0)")
					.style("font-size", gThis.fontSize + "px");
				
			} else {
				axis.append("g").attr("class", "leftAxis")
				.call(d3.axisLeft(leftScale).ticks(gThis.ytick))
				.attr("transform", "translate(" + margin.left + ", 0)")
				.style("font-size", gThis.fontSize + "px");
			}
			
			findTicks("left");
			
			
			rightScale = d3.scaleLinear()
						   .range([gThis.height - margin.bottom, margin.top])
						   .domain([ymin2, ymax2]);
			rightScale.type = "scaleLinear";
			
			/* y2축이 있으면 만들기 */
			if (!(isNaN(ymax2) && isNaN(ymin2))) {
				if (leftScale.ticks(gThis.ytick).length > 0) {
					/* leftScale이 있으면 leftScale의 tick에 해당하는 px의 값으로 rightScale의 tick 그리기 */
					rightTickValues = [];
					
					for (var i = 0; i < leftScale.ticks(gThis.ytick).length; i++) {
						/* leftScale tick -> px 변환 -> px 값을 rightScale 역변환 */
						rightTickValues[i] = rightScale.invert(leftScale(leftScale.ticks(gThis.ytick)[i]));
					}
					
					axis.append("g").attr("class", "rightAxis")
					.call(d3.axisRight(rightScale).tickValues(rightTickValues))
					.attr("transform", "translate(" + (gThis.width - margin.right) + ", 0)")
					.style("font-size", gThis.fontSize + "px");
					
				} else {
					/* leftScale이 없으면 자체적으로 rightScale의 tick 그리기 */
					axis.append("g").attr("class", "rightAxis")
					.call(d3.axisRight(rightScale).ticks(gThis.ytick))
					.attr("transform", "translate(" + (gThis.width - margin.right) + ", 0)")
					.style("font-size", gThis.fontSize + "px");
					
					findTicks("right");
				}
			}
			
			
			makeChartBG();
			
			
			//차트 가로줄 그리기
        	if (true || gThis.grid == 1 || gThis.grid == 3) {
        		if (leftScale.ticks(gThis.ytick).length > 0) {
        			/* leftScale이 있으면 leftScale의 tick으로 그리기 */
					chart.append("g").attr("class","xLines")
						 .selectAll(".xLine")
						 .data(leftScale.ticks(gThis.ytick))
						 .enter().append("rect")
						 .attr("class","xLine")
						 .attr("x", margin.left)
						 .attr("y", function(d, i) { return leftScale(d); })
						 .attr("width", gThis.width - margin.left - margin.right)
						 .attr("height", 1)
						 .style("fill", "#EEEEEE");
					
        		} else {
        			/* leftScale이 없으면 rightScale의 tick으로 그리기 */
        			chart.append("g").attr("class","xLines")
						 .selectAll(".xLine")
						 .data(rightScale.ticks(gThis.ytick))
						 .enter().append("rect")
						 .attr("class","xLine")
						 .attr("x", margin.left)
						 .attr("y", function(d, i) { return rightScale(d); })
						 .attr("width", gThis.width - margin.left - margin.right)
						 .attr("height", 1)
						 .style("fill", "#EEEEEE");
        		}
			}
			
			//차트 세로줄 그리기
			if (gThis.grid == 2 || gThis.grid == 3) {		
				chart.append("g").attr("class","yLines")
				     .selectAll(".yLine")
				     .data(bottomScale.domain())
				     .enter().append("rect")
				     .attr("class","yLine")
				     .attr("x", function(d, i) { return bottomScale(d) + (bottomScale.bandwidth() / 2) ; })
				     .attr("y", margin.top)
				     .attr("width", 1)
				     .attr("height", gThis.height - margin.top - margin.bottom)
				     .style("fill", "#EEEEEE");
			}		

//			if (ymin < 0) {
//				if (gThis.chart3d == "true") {
//					chart.append("rect").attr("class", "zero-plane")
//					.attr("width", bottomScale.range()[1] - bottomScale.range()[0])
//					.attr("height", bar3DLen)
//					.attr("transform", function(d, i) { return "translate (" + (bottomScale.range()[0] + bar3DLen) + "," + (leftScale(yStart) - bar3DLen) + ") skewX(-45)"; })
//					.style("fill", "#EEEEEE")
//					.style("opacity", 1);
//					
//				} else {
//					chart.append("rect").attr("class", "zero-plane")
//					.attr("x", bottomScale.range()[0])
//					.attr("y", leftScale(yStart) - 1)
//					.attr("width", bottomScale.range()[1] - bottomScale.range()[0])
//					.attr("height", 3)
//					.style("fill", "#EEEEEE");
//				}
//			}
			
			
			svg.on("mousemove", function(d, i) { tooltipLine_mousemove("area"); tooltip_mousemove(); })
			   .on("mouseout", function(d, i) { tooltipLine_mouseout(); tooltip_mouseout(); });
			
			
			if (columnData.length > 0) {
				
				var rects = chart.append("g").attr("class", "rects");
				
				if ((gThis.stacked == "1" || gThis.stacked == "2")) {
					
					if (gThis.chart3d == "true") {
						
				        var rectTop = rects.append("g").attr("class", "rectTop")
				        .selectAll("rects")
						.data(columnData).enter()
						.append("g").attr("class", "rects")
						.attr("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; });
				        
				        rectTop
			        	.selectAll("rect")
			            .data(function(d, i) {
			                d.forEach(function(d1) {
			                    d1.key = d.key;
			                    return d1;
			                });
			                return d;
			            })
			            .enter().append("rect")
			            .attr("width", bottomScale.bandwidth)
						.attr("height", bar3DLen)
						.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.data.xValue) + bar3DLen) + "," + (leftScale(d[1]) - bar3DLen) + ") skewX(-45)"; })
						.on("mousemove", onMouseMove)
					 	.on("mouseout", onMouseOut);
				        
						
						
				        var rectRight = rects.append("g").attr("class", "rectRight")
				        .selectAll("rects")
						.data(columnData).enter()
						.append("g").attr("class", "rects")
						.attr("fill", function(d, i) { return d3.rgb(color(d.colorIndex)); });
				         
				        rectRight
			        	.selectAll("rect")
			            .data(function(d, i) {
			                d.forEach(function(d1) {
			                    d1.key = d.key;
			                    return d1;
			                });
			                return d;
			            })
			            .enter().append("rect")
			            .attr("width", bar3DLen)
			            .attr("height", function(d, i) { return leftScale(d[0]) - leftScale(d[1]); })	
						.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.data.xValue) + bottomScale.bandwidth()) + "," + leftScale(d[1]) + ") skewY(-45)"; })
						.on("mousemove", onMouseMove)
					 	.on("mouseout", onMouseOut);
					}
					
					
			        var rectBody = rects.append("g").attr("class", "rectBody")
			        .selectAll("rects")
					.data(columnData).enter()
					.append("g").attr("class", "rects")
					.attr("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; });
					
			        rectBody.selectAll("rect")
			            .data(function(d, i) {
			                d.forEach(function(d1) {
			                    d1.key = d.key;
			                    return d1;
			                });
			                return d;
			            })
			            .enter().append("rect")
			            .attr("width", bottomScale.bandwidth)
			            .attr("x", function(d, i) { return bottomScale(d.data.xValue); })
			            .attr("y", function(d, i) { return leftScale(d[1]); })
			            .attr("height", function(d, i) { return leftScale(d[0]) - leftScale(d[1]); })
					 	.on("mousemove", onMouseMove)
					 	.on("mouseout", onMouseOut);
			        
			        
				} else {
					
					for (var i = 0; i < columnData[0].values.length; i++) {
					    for (var j = 0; j < columnData.length; j++) {
					    	var imsidata = new Array();
					    	imsidata.push(columnData[j].values[i]);
					      
						    //top
						    rects.append("rect")
						    .data(imsidata)
							.attr("width", bottomScale.bandwidth() / columnData.length)
							.attr("height", bar3DLen)
							.attr("transform", function(d, i) {
								var left_right_scale = (d.left_right == "right" ? rightScale : leftScale);
								var left_right_yStart = (d.left_right == "right" ? yStart2 : yStart);
								return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / columnData.length * d.dataIndex) + bar3DLen) + "," + (left_right_scale(left_right_yStart) - bar3DLen) + ") skewX(-45)";
							})
							.style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
							.on("mousemove", onMouseMove)
							.on("mouseout", onMouseOut)
							.transition()
							.delay(delay)
							.duration(duration)
							.attr("height", bar3DLen)
							.attr("transform", function(d, i) {
								var left_right_scale = (d.left_right == "right" ? rightScale : leftScale);
								var left_right_yStart = (d.left_right == "right" ? yStart2 : yStart);
								return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / columnData.length * d.dataIndex) + bar3DLen) + "," + (left_right_scale(d.yValue < left_right_yStart ? left_right_yStart : d.yValue) - bar3DLen) + ") skewX(-45)";
							});
					        
	      					//right 
	      					rects.append("rect")
	      					.data(imsidata)
							.attr("width", bar3DLen)
							.attr("height", 0)
							.attr("transform", function(d, i) {
								var left_right_scale = (d.left_right == "right" ? rightScale : leftScale);
								var left_right_yStart = (d.left_right == "right" ? yStart2 : yStart);
								return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / columnData.length * d.dataIndex) + (bottomScale.bandwidth() / columnData.length)) + "," + left_right_scale(left_right_yStart) + ") skewY(-45)";
							})
							.style("fill", function(d, i) { return d3.rgb(color(d.colorIndex)).darker(0.5); })
							.on("mousemove", onMouseMove)
							.on("mouseout", onMouseOut)
							.transition()
							.delay(delay)
							.duration(duration)
							.attr("height", function(d, i) {
								var left_right_scale = (d.left_right == "right" ? rightScale : leftScale);
								var left_right_yStart = (d.left_right == "right" ? yStart2 : yStart);
								return d.yValue > left_right_yStart ? left_right_scale(left_right_yStart) - left_right_scale(d.yValue) : left_right_scale(d.yValue) - left_right_scale(left_right_yStart);
							})
							.attr("transform", function(d, i) {
								var left_right_scale = (d.left_right == "right" ? rightScale : leftScale);
								var left_right_yStart = (d.left_right == "right" ? yStart2 : yStart);
								return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / columnData.length * d.dataIndex) + (bottomScale.bandwidth() / columnData.length)) + "," + (left_right_scale(d.yValue < left_right_yStart ? left_right_yStart : d.yValue)) + ") skewY(-45)";
							});
	      					
						    //body
						    rects.append("rect")
						    .data(imsidata)
	      					.attr("x", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / columnData.length * d.dataIndex); })
	      					.attr("y", function(d, i) {
	      						var left_right_scale = (d.left_right == "right" ? rightScale : leftScale);
	      						var left_right_yStart = (d.left_right == "right" ? yStart2 : yStart);
	      						return left_right_scale(left_right_yStart);
	      					})
	      					.attr("width", bottomScale.bandwidth() / columnData.length)
	      					.attr("height", 0)
	      					.style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
	      					.on("mousemove", onMouseMove)
	      					.on("mouseout", onMouseOut)
	      					.transition()
	      					.delay(delay)
	      					.duration(duration)
	      					.attr("y", function(d, i) {
	      						var left_right_scale = (d.left_right == "right" ? rightScale : leftScale);
	      						var left_right_yStart = (d.left_right == "right" ? yStart2 : yStart);
	      						return left_right_scale(d.yValue < left_right_yStart ? left_right_yStart : d.yValue);
	      					})
	      					.attr("height", function(d, i) {
	      						var left_right_scale = (d.left_right == "right" ? rightScale : leftScale);
	      						var left_right_yStart = (d.left_right == "right" ? yStart2 : yStart);
	      						return d.yValue > left_right_yStart ? left_right_scale(left_right_yStart) - left_right_scale(d.yValue) : left_right_scale(d.yValue) - left_right_scale(left_right_yStart);
	      					});
					    }
					}
				}
			}
			
			
			if (areaData.length > 0) {
				
				var areas = chart.append('g').attr('class', 'areas');
				
				if ((gThis.stacked == "1" || gThis.stacked == "2")) {
					var startArea = d3.area()
				    .x(function(d, i) { return bottomScale(d.data.xValue) + (bottomScale.bandwidth() / 2); })
				    .y0(function(d, i) { return leftScale(yStart); })
				    .y1(function(d, i) { return leftScale(yStart); })
				    .curve(curveArray[gThis.curveType]);
					
					var endArea = d3.area()
				    .x(function(d, i) { return bottomScale(d.data.xValue) + (bottomScale.bandwidth() / 2); })
				    .y0(function(d, i) { return leftScale(d[0]); })
				    .y1(function(d, i) { return leftScale(d[1]); })
				    .curve(curveArray[gThis.curveType]);
					
					areas.selectAll('.area')
						 .data(areaData).enter()
						 .append("path")
				         .data(areaData)
				         .attr("class", "area")
				         .attr('d', function(d, i) { return startArea(d); })
				         .style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
				         .style('opacity', 0.7)
				         .on('mousemove', onMouseMove)
				         .on('mouseout', onMouseOut)		         
				         .transition()
				         .delay(delay)
						 .duration(duration)
				         .attr('d', function(d, i) { return endArea(d); });
					
				} else {
					var startArea = d3.area()
				    .x(function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2); })
				    .y0(function(d, i) {
				    	var left_right_scale = (d.left_right == "right" ? rightScale : leftScale);
				    	var left_right_yStart = (d.left_right == "right" ? yStart2 : yStart);
				    	return left_right_scale(left_right_yStart);
				    })
				    .y1(function(d, i) {
				    	var left_right_scale = (d.left_right == "right" ? rightScale : leftScale);
				    	var left_right_yStart = (d.left_right == "right" ? yStart2 : yStart);
				    	return left_right_scale(left_right_yStart);
				    })
				    .curve(curveArray[gThis.curveType]);
					
					var endArea = d3.area()
				    .x(function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2); })
				    .y0(function(d, i) {
				    	var left_right_scale = (d.left_right == "right" ? rightScale : leftScale);
				    	var left_right_yStart = (d.left_right == "right" ? yStart2 : yStart);
				    	return left_right_scale(left_right_yStart);
				    })
				    .y1(function(d, i) { var left_right_scale = (d.left_right == "right" ? rightScale : leftScale); return left_right_scale(d.yValue); })
				    .curve(curveArray[gThis.curveType]);
					
					areas.selectAll('.area')
						 .data(areaData).enter()
						 .append("path")
				         .data(areaData)
				         .attr("class", "area")
				         .attr('d', function(d, i) { return startArea(d.values); })
				         .style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
				         .style('opacity', 0.7)
				         .on('mousemove', onMouseMove)
				         .on('mouseout', onMouseOut)		         
				         .transition()
				         .delay(delay)
						 .duration(duration)
				         .attr('d', function(d, i) { return endArea(d.values); });
				}
				
				function onMouseMove(d, i) {
					
				};
				
				function onMouseOut(d, i) {

				};
			
			}
			
			
			if (lineData.length > 0) {
				var line = d3.line()
				 .x(function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2)/*bottomScale(d.xValue)*/; })
				 .y(function(d, i) { var left_right_scale = (d.left_right == "right" ? rightScale : leftScale); return left_right_scale(d.yValue); })
				 .curve(curveArray[gThis.curveType]);

				var lines = chart.append('g').attr('class', 'lines');
			
				lines.append('g').attr('class', 'line-group')
					 .selectAll(".path")
					 .data(lineData).enter()
				     .append('path')
				     .attr('class', 'line')  
				     .attr('d', function(d, i) { return line(d.values); })
				     .style('stroke', function(d, i) { return color(d.colorIndex); })
				     .style('stroke-width', lineStroke)
				     .style('opacity', lineOpacity)
				     .style('fill', 'none')
				     .on("mouseover", function(d, i) {})
				    .on("mouseout", function(d, i) {});
				
				lines.selectAll("circle-group")
				 .data(lineData).enter()
				 .append("g")
				 .attr("class", "circle-group")
				 .style("fill", "#ffffff")
				 .style("stroke", function(d, i) { return color(d.colorIndex); })
				 .selectAll("circle")
				 .data(function(d, i) { return d.values; }).enter()
				 .append("g")
				 .attr("class", "circle")  
				 .on("mouseover", function(d, i) {})
				 .on("mouseout", function(d, i) {})
				 .append("circle")
				 .attr("cx", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2)/*bottomScale(d.xValue)*/; })
				 .attr("cy", function(d, i) {
					 var left_right_scale = (d.left_right == "right" ? rightScale : leftScale);
					 return left_right_scale(d.yValue);
				 })
				 .attr("r", circleRadius)
				 .style('opacity', gThis.animateFlag == true ? 0 : circleOpacity)
				 .on("mouseover", function(d, i) {})
				 .on("mouseout", function(d, i) {});
				
				if (gThis.animateFlag == true) {
					lines.selectAll(".line-group")
					.selectAll(".line")
					.attr("stroke-dasharray", function(d, i) { totalLength = d3.select(this).node().getTotalLength(); return totalLength + " " + totalLength; })
					.attr("stroke-dashoffset", function(d, i) { return d3.select(this).node().getTotalLength();})
					.transition()
					.delay(delay)
					.duration(duration)
					.ease(d3.easeLinear)
					.attr("stroke-dashoffset", 0);
					
					lines.selectAll(".circle-group")
					.selectAll(".circle").select("circle")
					.transition()
					.delay(delay + (duration))
					.style("opacity", 1);
				}
			}
		}
		
        
        function makeRadeaChart() {
        	
        	//http://bl.ocks.org/chrisrzhou/2421ac6541b68c1680f8
			
			/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			margin.top = gettitle.height > 0 ? (margin.top * 2 + 15) + gettitle.height : 0;
			
			if (getlegend != "" && gThis.legendType == "right") {
				legend.attr("transform", "translate(" + (gThis.width - getlegend.width - margin.right) + ", " + margin.top + ")");
				margin.right += getlegend.width + 10;
			} else if (getlegend != "") {
				legend.attr("transform", "translate(" + ((gThis.width / 2) - (getlegend.width / 2)) + ", " + (gThis.height - margin.bottom - getlegend.height + (0 - getlegend.y)) + ")");
				margin.bottom += getlegend.height + 10;
			} else {
				margin.bottom = 0;
			}
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
		    // add touch to mouseover and mouseout
		    var over = "ontouchstart" in window ? "touchstart" : "mouseover";
		    var out = "ontouchstart" in window ? "touchend" : "mouseout";

		    /** Initiate default configuration parameters and vis object
		     *
		     **/
		    // initiate default config
			var w = gThis.height - margin.top - margin.bottom > gThis.width - margin.right ? gThis.width - margin.right : gThis.height - margin.top - margin.bottom;
			var h = gThis.height - margin.top - margin.bottom > gThis.width - margin.right ? gThis.width - margin.right : gThis.height - margin.top - margin.bottom;
			
		    var config = {
		      w: w,
		      h: h,
		      facet: false,
		      levels: 5,
		      levelScale: 0.6,
		      labelScale: 1.0,
		      facetPaddingScale: 2.5,
		      maxValue: 0,
		      radians: 2 * Math.PI,
		      polygonAreaOpacity: 0.3,
		      polygonStrokeOpacity: 1,
		      polygonPointSize: 4,
		      legendBoxSize: 10,
		      translateX: w / 4,
		      translateY: h / 4 > margin.top ? h / 4 : margin.top,
		      paddingX: w,
		      paddingY: h,
		      colors: d3.scaleOrdinal(d3.schemeCategory10),
		      showLevels: true,
		      showLevelsLabels: true,
		      showAxesLabels: true,
		      showAxes: true,
		      showLegend: true,
		      showVertices: true,
		      showPolygons: true
		    };

		    // initiate main vis component
		    var vis = {
		      svg: null,
		      tooltip: null,
		      levels: null,
		      axis: null,
		      vertices: null,
		      legend: null,
		      allAxis: null,
		      total: null,
		      radius: null
		    };

		    // feed user configuration options
		    if ("undefined" !== typeof options) {
		      for (var i in options) {
		        if ("undefined" !== typeof options[i]) {
		          config[i] = options[i];
		        }
		      }
		    }

		    render(data); // render the visualization





		    /** helper functions
		     *
		     * @function: render: render the visualization
		     * @function: updateConfig: update configuration parameters
		     * @function: buildVis: build visualization using the other build helper functions
		     * @function: buildVisComponents: build main vis components
		     * @function: buildLevels: build "spiderweb" levels
		     * @function: buildLevelsLabels: build out the levels labels
		     * @function: buildAxes: builds out the axes
		     * @function: buildAxesLabels: builds out the axes labels
		     * @function: buildCoordinates: builds [x, y] coordinates of polygon vertices.
		     * @function: buildPolygons: builds out the polygon areas of the dataset
		     * @function: buildVertices: builds out the polygon vertices of the dataset
		     * @function: buildLegend:  builds out the legend
		     **/
		    // render the visualization
		    function render(data) {
		      // remove existing svg if exists
		      //d3.select("#" + id).selectAll("svg").remove();
		      updateConfig();
		      
		      
		      if (false/*config.facet*/) {
		        data.forEach(function(d, i) {
		          buildVis([d]); // build svg for each data group

		          // override colors
		          vis.svg.selectAll(".polygon-areas")
		            .attr("stroke", config.colors(i))
		            .attr("fill", config.colors(i));
		          vis.svg.selectAll(".polygon-vertices")
		            .attr("fill", config.colors(i));
		          vis.svg.selectAll(".legend-tiles")
		            .attr("fill", config.colors(i));
		        });
		      } else {
		        buildVis(data); // build svg
		      }
		      
		      
		      //차트 크기 재조정
		      var getRadar = chart.select(".radar").node().getBBox();
		      var w = config.translateX + getRadar.width < gThis.width - margin.right ? gThis.width - margin.right - config.translateX - getRadar.width : 0;
		      var h = config.translateY + getRadar.height < gThis.height - margin.top - margin.bottom ? gThis.height - margin.top - margin.bottom  - getRadar.height : 0;
		      chart.select(".radar").remove()
		      config.w += w > h ? h : w;
		      config.h += w > h ? h : w;
		      buildVis(data);
		      
		      //차트 위치 재조정
		      getRadar = chart.select(".radar").node().getBBox();
		      chart.attr("transform", "translate(" + (((gThis.width - margin.right) / 2) - (getRadar.width / 2) - config.translateX - getRadar.x) + ", " + (margin.top - 10 - config.translateY - getRadar.y) + ")");
		      
		      //라벨 위치 조정
		      //label.select(".charttitle").attr("x", config.translateX + (config.w / 2));
		      label.select(".charttitle").attr("x", gThis.width / 2);
		       
		    }


		    // update configuration parameters
		    function updateConfig() {
		      // adjust config parameters
		      config.maxValue = Math.max(config.maxValue, d3.max(data, function(d, i) { return d3.max(d.values, function(d, i) { return d.yValue; }); }));
		      config.w *= config.levelScale;
		      config.h *= config.levelScale;
		      config.paddingX = config.w * config.levelScale;
		      config.paddingY = config.h * config.levelScale;


		      // if facet required:
		      if (config.facet) {
		        config.w /= data.length;
		        config.h /= data.length;
		        config.paddingX /= (data.length / config.facetPaddingScale);
		        config.paddingY /= (data.length / config.facetPaddingScale);
		        config.polygonPointSize *= Math.pow(0.9, data.length);
		      }
		    }


		    //build visualization using the other build helper functions
		    function buildVis(data) {
		      buildVisComponents();
		      buildCoordinates(data);
		      if (config.showLevels) buildLevels();
		      if (config.showLevelsLabels) buildLevelsLabels();
		      if (config.showAxes) buildAxes();
		      if (config.showAxesLabels) buildAxesLabels();
//		      if (config.showLegend) buildLegend(data);
		      if (config.showPolygons) buildPolygons(data);
		      if (config.showVertices) buildVertices(data);
		    }

		    // build main vis components
		    function buildVisComponents() {
		      // update vis parameters
		      vis.allAxis = data[0].values.map(function(d, i){ return d.xValue; });
		      vis.totalAxes = vis.allAxis.length;
		      vis.radius = Math.min(config.w / 2, config.h / 2);

		      // create main vis svg
//		      vis.svg = d3.select("#" + id)
//		        .append("svg").classed("svg-vis", true)
//		        .attr("width", config.w + (config.translateX * 2))
//		        .attr("height", config.h + (config.translateY * 2))
//		        .append("svg:g")
//		        .attr("transform", "translate(" + config.translateX + "," + config.translateY + ")");
		      
		      vis.svg = chart.append("g").attr("class", "radar")
		      				 .attr("transform", "translate(" + config.translateX + "," + config.translateY + ")");

		      // create verticesTooltip
//		      vis.verticesTooltip = d3.select("body")
//		        .append("div").classed("verticesTooltip", true)
//		        .attr("opacity", 0)
//		        .style("position", "absolute")
//		      .style("color", "black")
//		      .style("font-size", "10px")
//		      .style("width", "100px")
//		      .style("height", "auto")
//		      .style("padding", "5px")
//		      .style("border", "2px solid gray")
//		      .style("border-radius", "5px")
//		      .style("pointer-events", "none")
//		      .style("opacity", "0")
//		      .style("background", "#f4f4f4");
		      
		      
		      
		      
		      
		      vis.verticesTooltip = d3.select("body")
				.append('div')
			    .attr('class', 'verticesTooltip')
			    .style("background", "white")
			    .style("box-shadow", "0 0 5px #999999")
			    .style("border-radius", "5px")
			    .style("color", "#333")
			    .style("font-size", gThis.fontSize + "px")
			    .style("left", "130px")
			    .style("font-size", gThis.fontSize + "px")
			    .style("position", "absolute")
			    .style("padding", "5px")
			    .style("text-align", "center")
			    .style("top", "95px")
			    .style("z-index", 10)
//			    .style("display", "none")
			    .style("opacity", 0);


		      // create levels
		      vis.levels = vis.svg.selectAll(".levels")
		        .append("svg:g").classed("levels", false);

		      // create axes
		      vis.axes = vis.svg.selectAll(".axes")
		        .append("svg:g").classed("axes", true);

		      // create vertices
		      vis.vertices = vis.svg.selectAll(".vertices");

		      //Initiate Legend	
		      vis.legend = vis.svg.append("svg:g").classed("legend", true)
		        .attr("height", config.h / 2)
		        .attr("width", config.w / 2)
		        .attr("transform", "translate(" + 0 + ", " + config.h + ")");
		    }


		    // builds out the levels of the spiderweb
		    function buildLevels() {
		      for (var level = 0; level < config.levels; level++) {
		        var levelFactor = vis.radius * ((level + 1) / config.levels);

		        // build level-lines
		        vis.levels
		          .data(vis.allAxis).enter()
		          .append("svg:line").classed("level-lines", true)
		          .attr("x1", function(d, i) { return levelFactor * (1 - Math.sin(i * config.radians / vis.totalAxes)); })
		          .attr("y1", function(d, i) { return levelFactor * (1 - Math.cos(i * config.radians / vis.totalAxes)); })
		          .attr("x2", function(d, i) { return levelFactor * (1 - Math.sin((i + 1) * config.radians / vis.totalAxes)); })
		          .attr("y2", function(d, i) { return levelFactor * (1 - Math.cos((i + 1) * config.radians / vis.totalAxes)); })
		          .attr("transform", "translate(" + (config.w / 2 - levelFactor) + ", " + (config.h / 2 - levelFactor) + ")")
		          .attr("stroke", "gray")
		          .attr("stroke-width", "0.5px");
		      }
		    }


		    // builds out the levels labels
		    function buildLevelsLabels() {
		      for (var level = 0; level < config.levels; level++) {
		        var levelFactor = vis.radius * ((level + 1) / config.levels);

		        // build level-labels
		        vis.levels
		          .data([1]).enter()
		          .append("svg:text").classed("level-labels", true)
		          .text((config.maxValue * (level + 1) / config.levels).toFixed(2))
		          .attr("x", function(d, i) { return levelFactor * (1 - Math.sin(0)); })
		          .attr("y", function(d, i) { return levelFactor * (1 - Math.cos(0)); })
		          .attr("transform", "translate(" + (config.w / 2 - levelFactor + 5) + ", " + (config.h / 2 - levelFactor) + ")")
		          .attr("fill", "gray")
		          .attr("font-family", "sans-serif")
		          .attr("font-size", 10 * config.labelScale + "px");
		      }
		    }


		    // builds out the axes
		    function buildAxes() {
		      vis.axes
		        .data(vis.allAxis).enter()
		        .append("svg:line").classed("axis-lines", true)
		        .attr("x1", config.w / 2)
		        .attr("y1", config.h / 2)
		        .attr("x2", function(d, i) { return config.w / 2 * (1 - Math.sin(i * config.radians / vis.totalAxes)); })
		        .attr("y2", function(d, i) { return config.h / 2 * (1 - Math.cos(i * config.radians / vis.totalAxes)); })
		        .attr("stroke", "grey")
		        .attr("stroke-width", "1px");
		    }


		    // builds out the axes labels
		    function buildAxesLabels() {
		      vis.axes
		        .data(vis.allAxis).enter()
		        .append("svg:text").classed("axis-labels", true)
		        .text(function(d, i) { return d; })
		        .attr("text-anchor", "middle")
		        .attr("x", function(d, i) { return config.w / 2 * (1 - 1.3 * Math.sin(i * config.radians / vis.totalAxes)); })
		        .attr("y", function(d, i) { return config.h / 2 * (1 - 1.1 * Math.cos(i * config.radians / vis.totalAxes)); })
		        .attr("font-family", "sans-serif")
		        .attr("font-size", 11 * config.labelScale + "px");
		    }


		    // builds [x, y] coordinates of polygon vertices.
		    function buildCoordinates(data) {
		      data.forEach(function(group) {
		        group.values.forEach(function(d, i) {
		          d.coordinates = { // [x, y] coordinates
		            x: config.w / 2 * (1 - (parseFloat(Math.max(d.yValue, 0)) / config.maxValue) * Math.sin(i * config.radians / vis.totalAxes)),
		            y: config.h / 2 * (1 - (parseFloat(Math.max(d.yValue, 0)) / config.maxValue) * Math.cos(i * config.radians / vis.totalAxes))
		          };
		        });
		      });
		    }


		    // builds out the polygon vertices of the dataset
		    function buildVertices(data) {
		      data.forEach(function(group, g) {
		        vis.vertices
		          .data(group.values).enter()
		          .append("svg:circle").classed("polygon-vertices", true)
		          .attr("r", config.polygonPointSize)
		          .attr("cx", function(d, i) { return d.coordinates.x; })
		          .attr("cy", function(d, i) { return d.coordinates.y; })
		          .attr("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
		          .on("mousemove", verticesTooltipShow)
		          .on("mouseout", verticesTooltipHide);
		      });
		    }


		    // builds out the polygon areas of the dataset
		    function buildPolygons(data) {
		      vis.vertices
		        .data(data).enter()
		        .append("svg:polygon").classed("polygon-areas", true)
		        .attr("points", function(group) { // build verticesString for each group
		          var verticesString = "";
		          group.values.forEach(function(d, i) { verticesString += d.coordinates.x + "," + d.coordinates.y + " "; });
		          return verticesString;
		        })
		        .attr("stroke-width", "2px")
		        .attr("stroke", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
		        .attr("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
		        .attr("fill-opacity", config.polygonAreaOpacity)
		        .attr("stroke-opacity", config.polygonStrokeOpacity)
		        .on(over, function(d, i) {
		          vis.svg.selectAll(".polygon-areas") // fade all other polygons out
		          .transition(250)
		            .attr("fill-opacity", 0.1)
		            .attr("stroke-opacity", 0.1);
		          d3.select(this) // focus on active polygon
		          .transition(250)
		            .attr("fill-opacity", 0.7)
		            .attr("stroke-opacity", config.polygonStrokeOpacity);
		        })
		        .on(out, function() {
		          d3.selectAll(".polygon-areas")
		            .transition(250)
		            .attr("fill-opacity", config.polygonAreaOpacity)
		            .attr("stroke-opacity", 1);
		        });
		    }


		    // builds out the legend
		    function buildLegend(data) {
		      //Create legend squares
		      vis.legend.selectAll(".legend-tiles")
		        .data(data).enter()
		        .append("svg:rect").classed("legend-tiles", true)
		        .attr("x", config.w - config.paddingX / 2)
		        .attr("y", function(d, i) { 
		        	return i * 2 * config.legendBoxSize; })
		        .attr("width", config.legendBoxSize)
		        .attr("height", config.legendBoxSize)
		        .attr("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; });

		      //Create text next to squares
		      vis.legend.selectAll(".legend-labels")
		        .data(data).enter()
		        .append("svg:text").classed("legend-labels", true)
		        .attr("x", config.w - config.paddingX / 2 + (1.5 * config.legendBoxSize))
		        .attr("y", function(d, i) { return i * 2 * config.legendBoxSize; })
		        .attr("dy", 0.07 * config.legendBoxSize + "em")
		        .attr("font-size", 11 * config.labelScale + "px")
		        .attr("fill", "gray")
		        .text(function(d, i) {
		          return d.cValue;
		        });
		    }


		    // show tooltip of vertices
		    function verticesTooltipShow(d) {
		      vis.verticesTooltip.style("opacity", 1)
		        .html("<b>" + d.xValue + " : " + d.yValue + "</b>")
		        .style("left", (mouse_layerX + 10) + "px")
		        .style("top", (mouse_layerY + 10) + "px");
		    }

		    // hide tooltip of vertices
		    function verticesTooltipHide() {
		      vis.verticesTooltip.style("opacity", 0);
		    }
        }
        
        
        function makePyramidChart() {
        	/* 좌우 가운데 기준으로 오른쪽만 어둡게 */
			var gradient2 = chart.select("defs")
			.selectAll(".linearGradient2")
			.data(data[0].values).enter()
			.append("linearGradient").attr("class", "linearGradient2")
		 	.attr("id", function(d, i) { return gThis.controlId + "_gradient2_" + i; })
		    .attr("x1", "0%")
		    .attr("y1", "100%")
		    .attr("x2", "100%")
		    .attr("y2", "100%")
		    .attr("spreadMethod", "pad");

			gradient2.append("stop")
			.attr("offset", "0%")
			.attr("stop-color", function(d, i) { return d3.rgb(color(i)); })
			.attr("stop-opacity", "1");
			
			gradient2.insert("stop")
			.attr("offset", "50%")
			.attr("stop-color", function(d, i) { return d3.rgb(color(i)); })
			.attr("stop-opacity", "1");
			
			gradient2.insert("stop")
			.attr("offset", "50%")
			.attr("stop-color", function(d, i) { return d3.rgb(color(i)).darker(0.5); })
			.attr("stop-opacity", "1");
			
			gradient2.insert("stop")
			.attr("offset", "100%")
			.attr("stop-color", function(d, i) { return d3.rgb(color(i)).darker(0.5); })
			.attr("stop-opacity", "1");
			
			
			/* */
			var gradient3 = chart.select("defs")
								.selectAll(".linearGradient3")
								.data(data[0].values).enter()
								.append("linearGradient").attr("class", "linearGradient3")
							 	.attr("id", function(d, i) { return gThis.controlId + "_gradient3_" + i; })
							    .attr("x1", "0%")
							    .attr("y1", "100%")
							    .attr("x2", "100%")
							    .attr("y2", "100%")
							    .attr("spreadMethod", "pad");

			gradient3.append("stop")
			    .attr("offset", "0%")
			    .attr("stop-color", function(d, i) { return d3.rgb(color(i)); })
			    .attr("stop-opacity", "1");
		
			gradient3.insert("stop")
			    .attr("offset", "100%")
			    .attr("stop-color", function(d, i) { return d3.rgb(color(i)).brighter(1); })
			    .attr("stop-opacity", "1");
			
			
			/* */
			var gradient4 = chart.select("defs")
								.selectAll(".linearGradient4")
								.data(data[0].values).enter()
								.append("linearGradient").attr("class", "linearGradient4")
							 	.attr("id", function(d, i) { return gThis.controlId + "_gradient4_" + i; })
							    .attr("x1", "0%")
							    .attr("y1", "100%")
							    .attr("x2", "100%")
							    .attr("y2", "100%")
							    .attr("spreadMethod", "pad");
			
			gradient4.append("stop")
			    .attr("offset", "0%")
			    .attr("stop-color", function(d, i) { return d3.rgb(color(i)).brighter(1); })
			    .attr("stop-opacity", "1");
		
			gradient4.insert("stop")
			    .attr("offset", "100%")
			    .attr("stop-color", function(d, i) { return d3.rgb(color(i)); })
			    .attr("stop-opacity", "1");
			
			
			
			
			/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			margin.top += gettitle.height > 0 ? gettitle.height + 20 : 0;
			
			if (getlegend != "" && gThis.legendType == "right") {
				legend.attr("transform", "translate(" + (gThis.width - getlegend.width - margin.right) + ", " + margin.top + ")");
				margin.right += getlegend.width + 10;
			} else if (getlegend != "") {
				legend.attr("transform", "translate(" + ((gThis.width / 2) - (getlegend.width / 2)) + ", " + (gThis.height - margin.bottom - getlegend.height + (0 - getlegend.y)) + ")");
				margin.bottom += getlegend.height + 10;
			}
			
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
			
			makeChartBG();
			
	        
	        /* 피라미드 넓이 범위 설정 */
			var leftP = gThis.width * 0.2;
			var rightP = gThis.width * 0.6;
			var centerP = leftP + ((gThis.width - leftP - (gThis.width - rightP)) / 2);
	        
			var gap = 40;  /* 피라미드 차트에서 그래프 상하단 간격 벌려줄 높이에 대한 갭 */
			
			
			var group = [];
			var newData = new Array();
			var temp = {};
			for (var i = 0; i < data[0].values.length; i++) {
				group[i] = data[0].values[i].xValue;
				temp[data[0].values[i].xValue] = data[0].values[i].yValue;
			}
			newData.push(temp);
			
	        var stackData = d3.stack()
			   .keys(group)
			   .offset(d3.stackOffsetDiverging)
			   (newData);
	        
	        
	        function stackMax(stackData) {
				 return d3.max(stackData, function(d, i) {
				     return  d[1];
				 });
				}
	        
	        
	        /* colorIndex 추가 */
	        for (var i = 0; i < stackData.length; i++) {
	        	stackData[i].colorIndex = stackData.length - stackData[i].index - 1;
	        }
	        
			
			var leftbottomScale = d3.scaleLinear()
						   .range([leftP, centerP])
						   .domain([0, d3.max(stackData, stackMax)]);
			
			var rightbottomScale = d3.scaleLinear()
			   .range([rightP, centerP])
			   .domain([0, d3.max(stackData, stackMax)]);
			
			

			leftScale = d3.scaleLinear()
						   .range([gThis.height - margin.bottom - (gap / 2), margin.top + (gap / 2)])
						   .domain([0, d3.max(stackData, stackMax)]);
			
			
			function pyramidGap(colorIndex) {
				var gapHeight = 0;
				
				if (gThis.pyramidSliceIndex > -1) {
					if (colorIndex == gThis.pyramidSliceIndex) {
						if (colorIndex == 0) gapHeight = gap;
						else if (colorIndex == stackData.length - 1) gapHeight = gap * -1;
						else gapHeight = 0;
					}
					else if (colorIndex < gThis.pyramidSliceIndex) gapHeight = gap;
					else if (colorIndex > gThis.pyramidSliceIndex) gapHeight = gap * -1;
				}
				
				return gapHeight;
			}
			
			
			function skewY(xValue) {
				var skew = 10;
				return (rightbottomScale(xValue) - centerP) * Math.sin(skew * Math.PI / 180);
			}
			
			
			/* 전체 면적 */
			function pyramidData1(d, i) {
				var temp = {};
				var values = new Array();
				var gapHeight = pyramidGap(d.colorIndex);
				var skewY0 = gThis.chart3d == "true" ? skewY(d[0][0]) : 0;
				var skewY1 = gThis.chart3d == "true" ? skewY(d[0][1]) : 0;
				
				//좌측 사격형 왼쪽 위
				temp = {};
				temp["xValue"] = leftbottomScale(d[0][1]);
				temp["yValue"] = leftScale(d[0][1] + gapHeight) - skewY1;
				values.push(temp);
				
				//좌측 사각형 왼쪽 아래
				temp = {};
				temp["xValue"] = leftbottomScale(d[0][0]);
				temp["yValue"] = leftScale(d[0][0] + gapHeight) - skewY0;
				values.push(temp);
				
				//좌측 사격형 오른쪽 아래
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][0] + gapHeight);
				values.push(temp);
				
				//좌측 사격형 오른쪽 위
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][1] + gapHeight);
				values.push(temp);
				
				//좌측 사격형 왼쪽 위
				temp = {};
				temp["xValue"] = leftbottomScale(d[0][1]);
				temp["yValue"] = leftScale(d[0][1] + gapHeight) - skewY1;
				values.push(temp);
				
				
				//상단 사각형 위쪽
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][1] + gapHeight) - (skewY1 * 2);
				values.push(temp);		
				
				
				//우측 사각형 오른쪽 위
				temp = {};
				temp["xValue"] = rightbottomScale(d[0][1]);
				temp["yValue"] = leftScale(d[0][1] + gapHeight) - skewY1;
				values.push(temp);
				
				//우측 사각형 오른쪽 아래
				temp = {};
				temp["xValue"] = rightbottomScale(d[0][0]);
				temp["yValue"] = leftScale(d[0][0] + gapHeight) - skewY0;
				values.push(temp);
				
				//우측 사격형 왼쪽 아래
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][0] + gapHeight);
				values.push(temp);
				
				//상단 사격형 왼쪽 위
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][1] + gapHeight);
				values.push(temp);
				
				return values;						
			}
			
			
			/* 좌, 우 사각형 */
			function pyramidData2(d, i) {
				var temp = {};
				var values = new Array();
				var colorIndex = stackData.length - 1 - i;
				var gapHeight = pyramidGap(d.colorIndex);
				var skewY0 = gThis.chart3d == "true" ? skewY(d[0][0]) : 0;
				var skewY1 = gThis.chart3d == "true" ? skewY(d[0][1]) : 0;
				
				//좌측 사격형 오른쪽 위
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][1] + gapHeight);
				values.push(temp);
				
				//좌측 사격형 왼쪽 위
				
				temp = {};
				temp["xValue"] = leftbottomScale(d[0][1]);
				temp["yValue"] = leftScale(d[0][1] + gapHeight) - skewY1;
				values.push(temp);
				
				//좌측 사각형 왼쪽 아래
				temp = {};
				temp["xValue"] = leftbottomScale(d[0][0]);
				temp["yValue"] = leftScale(d[0][0] + gapHeight) - skewY0;
				values.push(temp);
				
				//좌측 사격형 오른쪽 아래
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][0] + gapHeight);
				values.push(temp);
				

				//우측 사각형 오른쪽 아래
				temp = {};
				temp["xValue"] = rightbottomScale(d[0][0]);
				temp["yValue"] = leftScale(d[0][0] + gapHeight) - skewY0;
				values.push(temp);
				
				//우측 사각형 오른쪽 위
				temp = {};
				temp["xValue"] = rightbottomScale(d[0][1]);
				temp["yValue"] = leftScale(d[0][1] + gapHeight) - skewY1;
				values.push(temp);
				
				//상단 사격형 왼쪽 위
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][1] + gapHeight);
				values.push(temp);
				
				return values;
			}
			
			
			/* 좌, 우 사각형 사이에 좌측 세로 선 */
			function pyramidData3(d, i) {
				var temp = {};
				var values = new Array();
				var gapHeight = pyramidGap(d.colorIndex);
				var lineWidth = 3;
				
				function skewY(xValue) {
					var skew = 10;
					return (centerP - xValue) * Math.sin(skew * Math.PI / 180);
				}
				
				//좌측 사격형 왼쪽 위
				temp = {};
				temp["xValue"] = d.colorIndex == 0 ? centerP : centerP - lineWidth;
				temp["yValue"] = d.colorIndex == 0 ? leftScale(d[0][1] + gapHeight) : leftScale(d[0][1] + gapHeight) - skewY(centerP - lineWidth);
				values.push(temp);
				
				//좌측 사각형 왼쪽 아래
				temp = {};
				temp["xValue"] = centerP - lineWidth;
				temp["yValue"] = leftScale(d[0][0] + gapHeight) - skewY(centerP - lineWidth);
				values.push(temp);
				
				//좌측 사격형 오른쪽 아래
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][0] + gapHeight);
				values.push(temp);
				
				//좌측 사격형 오른쪽 위
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][1] + gapHeight);
				values.push(temp);
				
				return values;		
			}
			
			
			/* 좌, 우 사각형 사이에 우측 세로 선 */
			function pyramidData4(d, i) {
				var temp = {};
				var values = new Array();
				var gapHeight = pyramidGap(d.colorIndex);
				var lineWidth = 3;
				
				function skewY(xValue) {
					var skew = 10;
					return (xValue - centerP) * Math.sin(skew * Math.PI / 180);
				}
				
				//사격형 왼쪽 위
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][1] + gapHeight);
				values.push(temp);
				
				//사각형 왼쪽 아래
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][0] + gapHeight);
				values.push(temp);
				
				//사각형 오른쪽 아래
				temp = {};
				temp["xValue"] = centerP + lineWidth;
				temp["yValue"] = leftScale(d[0][0] + gapHeight) - skewY(centerP + lineWidth);
				values.push(temp);
				
				//사격형 오른쪽 위
				temp = {};
				temp["xValue"] = d.colorIndex == 0 ? centerP : centerP + lineWidth;
				temp["yValue"] = d.colorIndex == 0 ? leftScale(d[0][1] + gapHeight) : leftScale(d[0][1] + gapHeight) - skewY(centerP + lineWidth);
				values.push(temp);
				
				return values;		
			}
			
			
			/* 상단 사각형 */
			function pyramidData5(d, i) {
				var temp = {};
				var values = new Array();
				var gapHeight = pyramidGap(d.colorIndex);
				
				//상단 사격형 왼쪽
				temp = {};
				temp["xValue"] = leftbottomScale(d[0][1]);
				temp["yValue"] = leftScale(d[0][1] + gapHeight) - skewY(d[0][1]);
				values.push(temp);
				
				//상단 사각형 위쪽
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][1] + gapHeight) - (skewY(d[0][1]) * 2);
				values.push(temp);
				
				//상단 사각형 오른쪽
				temp = {};
				temp["xValue"] = rightbottomScale(d[0][1]);
				temp["yValue"] = leftScale(d[0][1] + gapHeight) - skewY(d[0][1]);
				values.push(temp);
				
				//상단 사격형 아래
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][1] + gapHeight);
				values.push(temp);
				
				return values;		
			}
			
			
			/* 좌측 사각형 상단 가로선 */
			function pyramidData6(d, i) {
				var temp = {};
				var values = new Array();
				var gapHeight = pyramidGap(d.colorIndex);
				var lineWidth = 3;	
				
				//좌측 사격형 왼쪽 위
				temp = {};
				temp["xValue"] = leftbottomScale(d[0][1]);
				temp["yValue"] = d.colorIndex == 0 ? leftScale(d[0][1] + gapHeight) : leftScale(d[0][1] + gapHeight) - skewY(d[0][1]);
				values.push(temp);
				
				//좌측 사격형 왼쪽 아래
				temp = {};
				temp["xValue"] = leftbottomScale(d[0][1]);
				temp["yValue"] = leftScale(d[0][1] + gapHeight) - skewY(d[0][1]);
				values.push(temp);
				
				//좌측 사격형 오른쪽 아래
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][1] + gapHeight);
				values.push(temp);
				
				//좌측 사격형 오른쪽 위
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = d.colorIndex == 0 ? leftScale(d[0][1] + gapHeight) : leftScale(d[0][1] + gapHeight) - lineWidth;
				values.push(temp);
				
				return values;
			}
			
			
			/* 우측 사각형 상단 가로선 */
			function pyramidData7(d, i) {
				var temp = {};
				var values = new Array();
				var gapHeight = pyramidGap(d.colorIndex);
				var lineWidth = 3;
				
				//상단 사격형 왼쪽 위
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = d.colorIndex == 0 ? leftScale(d[0][1] + gapHeight) : leftScale(d[0][1] + gapHeight) - lineWidth;
				values.push(temp);
				
				//상단 사격형 왼쪽 아래
				temp = {};
				temp["xValue"] = centerP;
				temp["yValue"] = leftScale(d[0][1] + gapHeight);
				values.push(temp);
				
				//우측 사각형 오른쪽 아래
				temp = {};
				temp["xValue"] = rightbottomScale(d[0][1]);
				temp["yValue"] = leftScale(d[0][1] + gapHeight) - skewY(d[0][1]);
				values.push(temp);
				
				//우측 사각형 오른쪽 위
				temp = {};
				temp["xValue"] = rightbottomScale(d[0][1]);
				temp["yValue"] = d.colorIndex == 0 ? leftScale(d[0][1] + gapHeight) : leftScale(d[0][1] + gapHeight) - skewY(d[0][1]);
				values.push(temp);
				
				
				return values;		
			}

			
			
			var line = d3.line()
						 .x(function(d, i) { return d.xValue; })
						 .y(function(d, i) { return d.yValue; })
						 .curve(curveArray[gThis.curveType]);

			var graph = chart.append("g").attr("class", "graph");

			var groupLine = graph.append('g').attr('class', 'group')
			 .selectAll('g')
			 .data(stackData).enter()
			 .append('g').attr('class', 'groupLine');
			
			if (gThis.chart3d == "true") {
				groupLine
				.insert("path")
				.attr('d', function(d, i) { return line(pyramidData2(d, i)); })
				.style('fill', function(d, i) { return "url(#" + gThis.controlId + "_gradient2_" + d.colorIndex + ")"; });
	
				groupLine
				.insert("path")
				.attr('d', function(d, i) { return line(pyramidData3(d, i)); })
				.attr("stroke", "#000000")
				.attr("stroke-width", "0")
				.style('fill', function(d, i) { return "url(#" + gThis.controlId + "_gradient3_" + d.colorIndex + ")"; });
				
				groupLine
				.insert("path")
				.attr('d', function(d, i) { return line(pyramidData4(d, i)); })
				.attr("stroke", "#000000")
				.attr("stroke-width", "0")
				.style('fill', function(d, i) { return "url(#" + gThis.controlId + "_gradient4_" + d.colorIndex + ")"; });
				
				groupLine
				.insert("path")
				.attr('d', function(d, i) { return line(pyramidData5(d, i)); })
				.style('fill', function(d, i) { return color(d.colorIndex); });
				
				groupLine
				.insert("path")
				.attr('d', function(d, i) { return line(pyramidData6(d, i)); })
				.attr("stroke-width", "0")
				.style('fill', function(d, i) { return "url(#" + gThis.controlId + "_gradient3_" + d.colorIndex + ")"; });
				
				groupLine
				.insert("path")
				.attr('d', function(d, i) { return line(pyramidData7(d, i)); })
				.attr("stroke-width", "0")
				.style('fill', function(d, i) { return "url(#" + gThis.controlId + "_gradient4_" + d.colorIndex + ")"; });
				
			} else {
				groupLine
				.insert("path")
				.attr('d', function(d, i) { return line(pyramidData2(d, i)); })
				.style('fill', function(d, i) { return "url(#" + gThis.controlId + "_gradient2_" + d.colorIndex + ")"; });
			}
			
			graph.append('g').attr('class', 'cover')
			 .selectAll('path')
			 .data(stackData).enter()
			 .append('path')
		     .attr('d', function(d, i) { return line(pyramidData1(d, i)); })
		     .attr("fill-opacity", 0)
		     .attr("cursor", "pointer")
		     .on("mouseover", onMouseOver)
			 .on("mousemove", onMouseMove)
			 .on("mouseout", onMouseOut)
			 .on("click", onClick);
			
			graph.append('g')
			 .attr('class', 'labels')
			 .selectAll('text')
			 .data(stackData).enter()
		     .append('text')
		     .attr('x', function(d, i) { return rightbottomScale(d[0][0]) + 10; })
			 .attr('y', function(d, i) {
				 var gapHeight = pyramidGap(d.colorIndex);
				 var skewY0 = gThis.chart3d == "true" ? skewY(d[0][0]) : 0;
				 var skewY1 = gThis.chart3d == "true" ? skewY(d[0][1]) : 0;
				 
				 function skewY(xValue) {
					var skew = 10;
					return (rightbottomScale(xValue) - centerP) * Math.sin(skew * Math.PI / 180);
				 }
				 
				 var y0 = leftScale(d[0][1] + gapHeight) - skewY1;
				 var y1 = leftScale(d[0][0] + gapHeight) - skewY0;
				 
				 return y0 + ((y1 - y0) / 2); 
			 })
			 .attr("cursor", "pointer")
			 .style("font-size",  gThis.fontSize + "px")
			 .text(function(d, i) { return d.key + " : " + d[0].data[d.key] + " (" + (d[0].data[d.key] / d3.max(stackData, stackMax) * 100).toFixed(2) + "%)"; })
			 .on("click", onClick);
			
		    
			
		    function onMouseOver(d, i) {
		    	
		    };
		    
		    function onMouseMove(d, i) {
		    	groupLine.filter(":nth-child(" + (i + 1) + ")").selectAll("path").style('opacity', 0.7);
		        tooltip.select('.tooltipText').html("<b>" + d.key + " : " + d[0].data[d.key] + " (" + (d[0].data[d.key] / d3.max(stackData, stackMax) * 100).toFixed(2) + "%)" + "</b>");
		    	tooltip_posiction();
		    };
		    
		    function onMouseOut(d, i) {
		    	groupLine.filter(":nth-child(" + (i + 1) + ")").selectAll("path").style('opacity', 1);
		    	
		    	tooltip_mouseout();
		    };
		    
		    function onClick(d, i) {
		    	gThis.pyramidSliceIndex = gThis.pyramidSliceIndex == d.colorIndex ? -1 : d.colorIndex;
		    	gThis.show(false);
		    };
        }
        
        
        function makeBubbleChart() {
        	/* 크기 측정용 임시 축 만들기 시작 ------------------------------------------------- */
			bottomScale = d3.scaleLinear().domain([xmin, xmax]);
			leftScale = d3.scaleLinear().domain([ymin, ymax]);
			
			axis.append("g").attr("class", "bottomAxis").call(d3.axisBottom(bottomScale).ticks(gThis.xtick));
			axis.append("g").attr("class", "leftAxis").call(d3.axisLeft(leftScale).ticks(gThis.ytick));
			
			var getbottomAxis = axis.select(".bottomAxis").node().getBBox();
			var getleftAxis = axis.select(".leftAxis").node().getBBox();
			
			axis.select(".bottomAxis").remove();
			axis.select(".leftAxis").remove();
			/* 크기 측정용 임시 축 만들기 종료 ------------------------------------------------- */
			
			/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			margin.top += gettitle.height > 0 ? gettitle.height + 20 : 0;
			margin.top += bar3DLen;
			
			if (getlegend != "" && gThis.legendType == "right") {
				legend.attr("transform", "translate(" + (gThis.width - getlegend.width - margin.right) + ", " + margin.top + ")");
				margin.right += getlegend.width + 10;
			} else if (getlegend != "") {
				legend.attr("transform", "translate(" + ((gThis.width / 2) - (getlegend.width / 2)) + ", " + (gThis.height - margin.bottom - getlegend.height + (0 - getlegend.y)) + ")");
				margin.bottom += getlegend.height + 10;
			}
			
			label.select(".bottomtitle").attr("y", gThis.height - margin.bottom - getbottomtitle.height + (0 - getbottomtitle.y));
			margin.bottom += getbottomtitle.height > 0 ? getbottomtitle.height + 10 : 0;
			
			label.select(".lefttitle").attr("x", - (margin.top + ((gThis.height - margin.top - margin.bottom ) / 2)));
			label.select(".lefttitle").attr("y", margin.left + (0 - getlefttitle.y));
			margin.left += getlefttitle.height > 0 ? getlefttitle.height + 10 : 0;
			margin.left += getleftAxis.width;
			
			if (trendwidth > 0) margin.right += trendwidth;
			
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			label.select(".bottomtitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
			
			var zMax = d3.max(data, function(d, i) { return d3.max(d.values, function(d, i) { return d.zValue; }); });
			var chartWidth = gThis.width - margin.left - margin.right > gThis.height - margin.top - margin.bottom ? gThis.height - margin.top - margin.bottom : gThis.width - margin.left - margin.right;  /* 차트의 넓이, 높이 중에 작은 값 */
			var circleWidth = chartWidth / 4; /* 차트 크기에서 1/4만큼의 circle의 크기를 만듦 */
			var circleR = circleWidth / 2;  /* 원의 반지름 */
			var circleArea = circleR * circleR * Math.PI;  /* 원의 넓이 */		
			var zScale = d3.scaleLinear().range([0, circleArea]).domain([0, zMax]);
			var addWidth = circleR / (gThis.width - margin.left - margin.right);  /* 원의 반지름 만큼 추가 넓이 */
			var addHeight = circleR / (gThis.height - margin.top - margin.bottom);  /* 원의 반지름 만큼 추가 높이 */
			
			
			bottomScale = d3.scaleLinear()
						   .range([margin.left, gThis.width - margin.right])
						   .domain([xmin + (xmin * addWidth), xmax + (xmax * addWidth)]);
			bottomScale.type = "scaleLinear";
			
			axis.append("g").attr("class", "bottomAxis")
				.call(d3.axisBottom(bottomScale).ticks(gThis.xtick))
				.attr("transform", "translate(0," + (gThis.height - margin.bottom) + ")")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("bottom");
			
			bottomAxisLF();
			
			
			leftScale = d3.scaleLinear()
						   .range([gThis.height - margin.bottom, margin.top])
						   .domain([ymin + (ymin * addHeight), ymax + (ymax * addHeight)]);
			leftScale.type = "scaleLinear";
			
			axis.append("g").attr("class", "leftAxis")
				.call(d3.axisLeft(leftScale).ticks(gThis.ytick))
				.attr("transform", "translate(" + margin.left + ", 0)")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("left");
			
			makeChartBG();
			
			create_clipPath(gThis.controlId + "_clipPath", margin.left, margin.top, gThis.width - margin.left - margin.right, gThis.height - margin.top - margin.bottom);
			
			
			
			
			
			
			//차트 가로줄 그리기
			if (true || gThis.grid == 1 || gThis.grid == 3) {
				chart.append("g").attr("class","xLines")
					 .selectAll(".xLine")
					 .data(leftScale.ticks(gThis.ytick))
					 .enter().append("rect")
					 .attr("class","xLine")
					 .attr("x", margin.left)
					 .attr("y", function(d, i) { return leftScale(d); })
					 .attr("width", gThis.width - margin.left - margin.right)
					 .attr("height", 1)
					 .style("fill", "#EEEEEE");
			}
			
			//차트 세로줄 그리기
			if (true || gThis.grid == 2 || gThis.grid == 3) {	
				chart.append("g").attr("class","yLines")
				     .selectAll(".yLine")
				     .data(bottomScale.ticks(gThis.xtick))
				     .enter().append("rect")
				     .attr("class","yLine")
				     .attr("x", function(d, i) { return bottomScale(d); })
				     .attr("y", margin.top)
				     .attr("width", 1)
				     .attr("height", gThis.height - margin.top - margin.bottom)
				     .style("fill", "#EEEEEE");
			}		

//			if (ymin < 0) {
//				if (gThis.chart3d == "true") {
//					chart.append("rect").attr("class", "zero-plane")
//					.attr("width", bottomScale.range()[1] - bottomScale.range()[0])
//					.attr("height", bar3DLen)
//					.attr("transform", function(d, i) { return "translate (" + (bottomScale.range()[0] + bar3DLen) + "," + (leftScale(yStart) - bar3DLen) + ") skewX(-45)"; })
//					.style("fill", "#EEEEEE")
//					.style("opacity", 1);
//					
//				} else {
//					chart.append("rect").attr("class", "zero-plane")
//					.attr("x", bottomScale.range()[0])
//					.attr("y", leftScale(yStart) - 1)
//					.attr("width", bottomScale.range()[1] - bottomScale.range()[0])
//					.attr("height", 3)
//					.style("fill", "#EEEEEE");
//				}
//			}
			
			
			
			var circles = chart.append('g').attr('class', 'circles').attr("clip-path", "url(#" + gThis.controlId + "_clipPath)");
			
			circles.selectAll("circle-group")
			 .data(data).enter()
			 .append("g")
			 .attr("class", "circle-group")
			 .style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
			 .selectAll("circle")
			 .data(function(d, i) { return d.values; }).enter()
			 .append("g")
			 .attr("class", "circle")  
			 .on("mouseover", function(d, i) {
				 
//				 d3.select(this)     
//				   .style("cursor", "pointer")
//				   .append("text")
//				   .attr("class", "text")
//				   .attr("text-anchor", "middle")
//				   .text(function(d, i) { return d.yValue; })
//				   .attr("x", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2)/*bottomScale(d.xValue)*/; })
//				   .attr("y", function(d, i) { return leftScale(d.yValueT) - 10; });
			 })
			 .on("mouseout", function(d, i) {
//				 d3.select(this)
//				   .style("cursor", "none")  
//				   .transition()
//				   .duration(lineDuration)
//				   .selectAll(".text").remove();
			 })
			 .append("circle")
			 .attr("cx", function(d, i) { return bottomScale(d.xValue); })
			 .attr("cy", function(d, i) { return leftScale(d.yValue); })
			 .attr("r", function(d, i) { return gThis.animateFlag == true ? 0 : Math.sqrt(zScale(d.zValue) / Math.PI)  /* 원의 넓이에서 반지름 구하기 */; })
			 .style('opacity', 0.95)
			 .on("mousemove", function(d, i) {
				 d3.select(this).style('opacity', 0.7);
			     tooltip.select('.tooltipText').html("<b>" + jsonData[d.colorIndex].cValue + " : " + d.xValue + ", " + d.yValue + ", " + d.zValue + "</b>");
			     tooltip_posiction();
			 })
			 .on("mouseout", function(d, i) {
				 d3.select(this).style('opacity', 0.95);
			     tooltip_mouseout();
			 });
			
			if (gThis.animateFlag == true) {
				circles.selectAll(".circle-group")
				.selectAll(".circle").select("circle")
				.transition()
				.attr("r", function(d, i) { return Math.sqrt(zScale(d.zValue) / Math.PI)  /* 원의 넓이에서 반지름 구하기 */; })
				.delay(delay)
				.duration(duration);
			}
        }
        
        
        function makeCandlestickChart() {
        	var ymin2 = 0;
        	var ymax2 = d3.max(data, function(d, i) { return d.volume; }) * 1.2;  /* 1.2만큼 여백을 안주면 volume 막대가 딱 달라붙음 */
        	
        	volumeHeight = ymax2 > 0 ? 0.25 : 0;  /* 화면에서 volume 그래프가 차지하는 비율, volume이 없으면 volume 그래프를 그리지 않음 */
        	
			formatChange = function (y0, y1) {
				var f = d3.format("+.2%");
				return f((y1 - y0) / y0);
			};
        	
        	/* 크기 측정용 임시 축 만들기 시작 ------------------------------------------------- */
			bottomScale = d3.scaleBand().domain(data.map(function(d, i) { return d.xValue; }));
			rightScale = d3.scaleLinear().domain([ymin, ymax]);
			rightScale2 = d3.scaleLinear().domain([ymin2, ymax2]);
			
			
			axis.append("g").attr("class", "bottomAxis").call(d3.axisBottom(bottomScale));
			axis.append("g").attr("class", "rightAxis").call(d3.axisRight(rightScale).ticks(gThis.ytick));
			axis.append("g").attr("class", "rightAxis2").call(d3.axisRight(rightScale2).ticks(gThis.ytick));
			
			var getbottomAxis = axis.select(".bottomAxis").node().getBBox();
			var getrightAxis = axis.select(".rightAxis").node().getBBox();
			var getrightAxis2 = axis.select(".rightAxis2").node().getBBox();
			
			//크기 측정용이라서 width가 더 큰 것을 사용 
			getrightAxis = getrightAxis.width > getrightAxis2.width ? getrightAxis : getrightAxis2;
			
			axis.select(".bottomAxis").remove();
			axis.select(".rightAxis").remove();
			axis.select(".rightAxis2").remove();
			/* 크기 측정용 임시 축 만들기 종료 ------------------------------------------------- */
			
			/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			margin.top += gettitle.height > 0 ? gettitle.height + 20 : 0;
			
			label.select(".bottomtitle").attr("y", gThis.height - margin.bottom - getbottomtitle.height + (0 - getbottomtitle.y));
			margin.bottom += getbottomtitle.height > 0 ? getbottomtitle.height + 10 : 0;
			
			label.select(".lefttitle").attr("x", - (margin.top + (((gThis.height - margin.top - margin.bottom) - ((gThis.height - margin.top - margin.bottom) * volumeHeight)) / 2)) );
			label.select(".lefttitle").attr("y", margin.left + (0 - getlefttitle.y));
			margin.left += getlefttitle.height > 0 ? getlefttitle.height + 10 : 0;
			
			if (trendwidth > getrightAxis.width)
				margin.right += trendwidth;
			else
				margin.right += getrightAxis.width;
			
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			label.select(".bottomtitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
			
			bottomScale = d3.scaleBand()
			   .range([margin.left, gThis.width - margin.right])
			   .domain(data.map(function(d, i) { return d.xValue; }))
			   .padding(0.4).paddingOuter(0.2);

			bottomScale.type = "scaleBand";
			
			axis.append("g").attr("class", "bottomAxis")
				.call(d3.axisBottom(bottomScale))
				.attr("transform", "translate(0," + (gThis.height - margin.bottom) + ")")
				.style("font-size", gThis.fontSize + "px");
			
			
			/* bottomAxis에 숫자로 되어있는 값을 label 데이터로 바꾸기 */
			for (var i = 0; i < data.length; i++) {
				/* + 2 하는 이유는 ticks 안에 있는 첫 번째 노드가 domain이라는 클래스로 된 선이 존재해서 */
				axis.select(".bottomAxis").selectAll(".tick").filter(":nth-child(" + (i + 2) + ")").select("text").node().innerHTML = data[i].label;	
			}
			
			/* tick을 어떻게 할지 아직 못정해서 13개 이하면 전부 보이게 하게 14개 이상이면 7개가 보이게 일단 만들어 놓음 */
			if (data.length >= 14) {
				var n = Math.floor(data.length / 7);
				for (var i = data.length - 1; i >= 0; i--) {
					if (i % n > 0) {
						var ticks = axis.select('.bottomAxis').selectAll('.tick');
						ticks.filter(":nth-child(" + (i + 2) + ")").remove();
					}
				}
			}
			
			//findTicks("bottom");
			
			bottomAxisLF();
			
			
			rightScale = d3.scaleLinear()
						   .range([((gThis.height - margin.bottom) - ((gThis.height - margin.top - margin.bottom) * volumeHeight)), margin.top])
						   .domain([ymin, ymax]);
			rightScale.type = "scaleLinear";
			
			axis.append("g").attr("class", "rightAxis")
				.call(d3.axisRight(rightScale).ticks(gThis.ytick))
				.attr("transform", "translate(" + (gThis.width - margin.right) + ", 0)")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("right");
			
			rightScale2 = d3.scaleLinear()
						   .range([(gThis.height - margin.bottom), ((gThis.height - margin.bottom) - ((gThis.height - margin.top - margin.bottom) * volumeHeight))])
						   .domain([ymin2, ymax2]);
			rightScale2.type = "scaleLinear";
			
			axis.append("g").attr("class", "rightAxis2")
				.call(d3.axisRight(rightScale2).ticks(2))
				.attr("transform", "translate(" + (gThis.width - margin.right) + ", 0)")
				.style("font-size", gThis.fontSize + "px");
			
			/* volume 그래프를 안그리면 rightAxis2 안보이게 하기 */
			if (volumeHeight == 0) axis.select(".rightAxis2").style("opacity", 0);
			
			makeChartBG();
			
			
			//차트 가로줄 그리기
			if (true || gThis.grid == 1 || gThis.grid == 3) {
				chart.append("g").attr("class","xLines")
					 .selectAll(".xLine")
					 .data(rightScale.ticks(gThis.ytick))
					 .enter().append("rect")
					 .attr("class","xLine")
					 .attr("x", margin.left)
					 .attr("y", function(d, i) { return rightScale(d); })
					 .attr("width", gThis.width - margin.left - margin.right)
					 .attr("height", 1)
					 .style("fill", "#EEEEEE");
			}
			
			if (true || gThis.grid == 1 || gThis.grid == 3) {
				chart.append("g").attr("class","xLines")
					 .selectAll(".xLine")
					 .data(rightScale2.ticks(2))
					 .enter().append("rect")
					 .attr("class","xLine")
					 .attr("x", margin.left)
					 .attr("y", function(d, i) { return rightScale2(d); })
					 .attr("width", gThis.width - margin.left - margin.right)
					 .attr("height", 1)
					 .style("fill", "#EEEEEE");
			}
			
			//차트 세로줄 그리기
			if (gThis.grid == 2 || gThis.grid == 3) {		
				chart.append("g").attr("class","yLines")
				     .selectAll(".yLine")
				     .data(bottomScale.domain())
				     .enter().append("rect")
				     .attr("class","yLine")
				     .attr("x", function(d, i) { return bottomScale(d) + (bottomScale.bandwidth() / 2) - 0.5; })
				     .attr("y", margin.top)
				     .attr("width", 1)
				     .attr("height", gThis.height - margin.top - margin.bottom)
				     .style("fill", "#EEEEEE");
			}
			
			
			chart.append("rect")
			 .attr("class","borderLine")
			 .attr("x", margin.left)
			 .attr("y", ((gThis.height - margin.bottom) - ((gThis.height - margin.top - margin.bottom) * volumeHeight)))
			 .attr("width", gThis.width - margin.left - margin.right)
			 .attr("height", 1)
			 .style("fill", "#000000");
			
			svg.on("mousemove", function(d, i) { tooltipLine_Candlestick_mousemove("area"); tooltip_Candlestick_mousemove(); })
			   .on("mouseout", function(d, i) { tooltipLine_mouseout(); tooltip_mouseout(); });

			var candlestick = chart.selectAll("candlestick")
								   .data(data).enter()
								   .append("g").attr("class","candlestick")
								   .attr("fill", function(d, i) { return d.open > d.close ? "#E11C27" : d.close > d.open ? "#51AC53" : color(3); })
								   .attr("stroke", function(d, i) { return d.open > d.close ? "#E11C27" : d.close > d.open ? "#51AC53" : color(3); })
								   .on("mouseover", onMouseOver)
								   .on("mousemove", onMouseMove)
								   .on("mouseout", onMouseOut);
			
			
			var high_low_width = 1;
			
			candlestick.append("rect")
					   .attr("x", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2 ) - (high_low_width / 2); })
					   .attr("y", function(d, i) { return rightScale(d.high); })
					   .attr("height", function(d, i) { return rightScale(d.low) - rightScale(d.high); })
					   .attr("width", high_low_width);
			
			
			if (gThis.gallery == 9) {
				//close
				candlestick.append("rect")
						   .attr("x", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2); })
						   .attr("y", function(d, i) { return rightScale(d.close); })
						   .attr("height", high_low_width)
						   .attr("width", bottomScale.bandwidth() / 2);
				
			} else if (gThis.gallery == 16) {
				//open
				candlestick.append("rect")
						   .attr("x", function(d, i) { return bottomScale(d.xValue); })
						   .attr("y", function(d, i) { return rightScale(d.open); })
						   .attr("height", high_low_width)
						   .attr("width", bottomScale.bandwidth() / 2);
				
				//close
				candlestick.append("rect")
						   .attr("x", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2); })
						   .attr("y", function(d, i) { return rightScale(d.close); })
						   .attr("height", high_low_width)
						   .attr("width", bottomScale.bandwidth() / 2);
				
			} else if (gThis.gallery == 17) { 
				candlestick.append("rect")
						   .attr("x", function(d, i) { return bottomScale(d.xValue); })
						   .attr("y", function(d, i) { return rightScale(d.open > d.close ? d.open : d.close); })
						   .attr("height", function(d, i) { return rightScale(d.open > d.close ? d.close : d.open) - rightScale(d.open > d.close ? d.open : d.close); })
						   .attr("width", bottomScale.bandwidth());
				
				candlestick.append("rect")
				   .attr("x", function(d, i) { return bottomScale(d.xValue)  ; })
				   .attr("y", function(d, i) { return rightScale2(d.volume);})
				   .attr("height", function(d, i) { return (gThis.height - margin.bottom) - rightScale2(d.volume); })
				   .attr("width", bottomScale.bandwidth());
			}
			
			function onMouseOver(d, i) {};
			
			function onMouseMove(d, i) {};
			
			function onMouseOut(d, i) {};
        }
        
        
        function makeBarChart() {
        	
        	if ((gThis.stacked == "1" || gThis.stacked == "2")) getStackData();
			
			/* 크기 측정용 임시 축 만들기 시작 ------------------------------------------------- */
			bottomScale = d3.scaleLinear().domain([ymin, ymax]);
			leftScale = d3.scaleBand().domain(data[0].values.map(function(d, i){ return d.xValue; }));
			
			if (gThis.stacked == "2") axis.append("g").attr("class", "bottomAxis").call(d3.axisBottom(bottomScale).ticks(gThis.ytick, "%"));
			else axis.append("g").attr("class", "bottomAxis").call(d3.axisBottom(bottomScale).ticks(gThis.ytick, "%"));
			axis.append("g").attr("class", "leftAxis").call(d3.axisLeft(leftScale).ticks(gThis.ytick));
			
			var getbottomAxis = axis.select(".bottomAxis").node().getBBox();
			var getleftAxis = axis.select(".leftAxis").node().getBBox();
			
			axis.select(".bottomAxis").remove();
			axis.select(".leftAxis").remove();
			/* 크기 측정용 임시 축 만들기 종료 ------------------------------------------------- */
			
			/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			margin.top += gettitle.height > 0 ? gettitle.height + 20 : 0;
			margin.top += bar3DLen;
			
			if (getlegend != "" && gThis.legendType == "right") {
				legend.attr("transform", "translate(" + (gThis.width - getlegend.width - margin.right) + ", " + margin.top + ")");
				margin.right += getlegend.width + 10;
			} else if (getlegend != "") {
				legend.attr("transform", "translate(" + ((gThis.width / 2) - (getlegend.width / 2)) + ", " + (gThis.height - margin.bottom - getlegend.height + (0 - getlegend.y)) + ")");
				margin.bottom += getlegend.height + 10;
			}
			
			label.select(".bottomtitle").attr("y", gThis.height - margin.bottom - getbottomtitle.height + (0 - getbottomtitle.y));
			margin.bottom += getbottomtitle.height > 0 ? getbottomtitle.height + 10 : 0;
			
			label.select(".lefttitle").attr("x", - (margin.top + ((gThis.height - margin.top - margin.bottom ) / 2)));
			label.select(".lefttitle").attr("y", margin.left + (0 - getlefttitle.y));
			margin.left += getlefttitle.height > 0 ? getlefttitle.height + 10 : 0;
			margin.left += getleftAxis.width;
			
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			label.select(".bottomtitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			
			if (trendheight > 0) margin.bottom += trendheight;
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
			
			bottomScale = d3.scaleLinear()
			   .range([margin.left, gThis.width - margin.right])
			   .domain([ymin, ymax]);
						   
			bottomScale.type = "scaleLinear";
			
			/* stack percent의 경우 max 값이 1이기 때문에 100% 보이게 함*/
			if (gThis.stacked == "2") {
				axis.append("g").attr("class", "bottomAxis")
					.call(d3.axisBottom(bottomScale).ticks(gThis.ytick, "%"))
					.attr("transform", "translate(0," + (gThis.height - margin.bottom) + ")")
					.style("font-size", gThis.fontSize + "px");
				
			} else {
				axis.append("g").attr("class", "bottomAxis")
					.call(d3.axisBottom(bottomScale).ticks(gThis.ytick))
					.attr("transform", "translate(0," + (gThis.height - margin.bottom) + ")")
					.style("font-size", gThis.fontSize + "px");
			}
			
			findTicks("bottom");
			
			bottomAxisLF();
			
			
			leftScale = d3.scaleBand()
				.range([gThis.height - margin.bottom, margin.top])
			   .domain(data[0].values.map(function(d, i){ return d.xValue; }))
			   .padding(0.2).paddingOuter(0.1);
			
			leftScale.type = "scaleBand";
			
			
			axis.append("g").attr("class", "leftAxis")
				.call(d3.axisLeft(leftScale))
				.attr("transform", "translate(" + margin.left + ", 0)")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("left");
			
			makeChartBG();
			
			
			//차트 가로줄 그리기
			if (gThis.grid == 1 || gThis.grid == 3) {
				chart.append("g").attr("class","xLines")
					 .selectAll(".xLine")
					 .data(leftScale.domain())
					 .enter().append("rect")
					 .attr("class","xLine")
					 .attr("x", margin.left)
					 .attr("y", function(d, i) { return leftScale(d) + (leftScale.bandwidth() / 2); })
					 .attr("width", gThis.width - margin.left - margin.right)
					 .attr("height", 1)
					 .style("fill", "#EEEEEE");
			}
			
			//차트 세로줄 그리기
			if (true || gThis.grid == 2 || gThis.grid == 3) {
				chart.append("g").attr("class","yLines")
				     .selectAll(".yLine")
				     .data(bottomScale.ticks(gThis.ytick))
				     .enter().append("rect")
				     .attr("class","yLine")
				     .attr("x", function(d, i) { return bottomScale(d); })
				     .attr("y", margin.top)
				     .attr("width", 1)
				     .attr("height", gThis.height - margin.top - margin.bottom)
				     .style("fill", "#EEEEEE");
			}
			

			/* 가로그래프에서 bar3DLen를 그냥 쓰면 값이 너무 커서 반 자름*/
			bar3DLen = bar3DLen / 2;
			
			if (ymin < 0) {
				if (gThis.chart3d == "true") {
					chart.append("rect").attr("class", "zero-plane")
					.attr("width", bar3DLen)
					.attr("height", leftScale.range()[0] - leftScale.range()[1])
					.attr("transform", function(d, i) { return "translate (" + bottomScale(yStart) + "," + leftScale.range()[1] + ") skewY(-45)"; })
					.style("fill", "#EEEEEE")
					.style("opacity", 1);
					
				} else {
					chart.append("rect").attr("class", "zero-plane")
					.attr("x", bottomScale(yStart) - 1)
					.attr("y", leftScale.range()[1])
					.attr("width", 3)
					.attr("height", leftScale.range()[0] - leftScale.range()[1])
					.style("fill", "#EEEEEE");
				}
			}

			

			
				
			
			var rects = chart.append("g").attr("class", "rects");
			
			
			if ((gThis.stacked == "1" || gThis.stacked == "2")) {
				
				if (gThis.chart3d == "true") {
					var rectRight = rects.append("g").attr("class", "rectRight")
			        .selectAll("rects")
					.data(stackData).enter()
					.append("g").attr("class", "rects")
					.attr("fill", function(d, i) { return d3.rgb(color(d.colorIndex)); });
			         
			        rectRight
		        	.selectAll("rect")
		            .data(function(d, i) {
		                d.forEach(function(d1) {
		                    d1.key = d.key;
		                    return d1;
		                });
		                return d;
		            })
		            .enter().append("rect")
		            .attr("width", bar3DLen)
		            .attr("height", leftScale.bandwidth() - bar3DLen)	
					.attr("transform", function(d, i) { return "translate (" + (bottomScale(d[1])) + "," + (leftScale(d.data.xValue) + bar3DLen) + ") skewY(-45)"; })
					.on("mousemove", onMouseMove)
				 	.on("mouseout", onMouseOut);
			        
			        
			        var rectTop = rects.append("g").attr("class", "rectTop")
			        .selectAll("rects")
					.data(stackData).enter()
					.append("g").attr("class", "rects")
					.attr("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; });
			        
			        rectTop
		        	.selectAll("rect")
		            .data(function(d, i) {
		                d.forEach(function(d1) {
		                    d1.key = d.key;
		                    return d1;
		                });
		                return d;
		            })
		            .enter().append("rect")
		            .attr("width", function(d, i) { return bottomScale(d[1]) - bottomScale(d[0]); })
					.attr("height", bar3DLen)
					.attr("transform", function(d, i) { return "translate (" + (bottomScale(d[0]) + bar3DLen) + "," + leftScale(d.data.xValue) + ") skewX(-45)"; })
					.on("mousemove", onMouseMove)
				 	.on("mouseout", onMouseOut);
				}
				
				
		        var rectBody = rects.append("g").attr("class", "rectBody")
		        .selectAll("rects")
				.data(stackData).enter()
				.append("g").attr("class", "rects")
				.attr("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; });
				
		        rectBody.selectAll("rect")
		            .data(function(d, i) {
		                d.forEach(function(d1) {
		                    d1.key = d.key;
		                    return d1;
		                });
		                return d;
		            })
		            .enter().append("rect")
		            .attr("width", function(d, i) { return bottomScale(d[1]) - bottomScale(d[0]); })
		            .attr("x", function(d, i) { return bottomScale(d[0]); })
		            .attr("y", function(d, i) { return leftScale(d.data.xValue) + bar3DLen; })
		            .attr("height", leftScale.bandwidth() - bar3DLen)
				 	.on("mousemove", onMouseMove)
				 	.on("mouseout", onMouseOut);
		        
			} else {
				/*
				if (gThis.chart3d == "true") {
					rects.append("g").attr("class", "rectRight")
					.selectAll("rect")
					 .data(function(d, i){ d.values.map(function(b){ b.dataIndex=i; return b; }); return d.values; })
					 .enter().append("rect")
					 .attr("width", bar3DLen)
					 .attr("height", leftScale.bandwidth() / data.length - bar3DLen)
					 .attr("transform", function(d, i) { return "translate (" + bottomScale(yStart) + "," + (leftScale(d.xValue) + (leftScale.bandwidth() / data.length * d.dataIndex) + bar3DLen) + ") skewY(-45)"; })
					 .style("fill", function(d, i) { return d3.rgb(color(d.colorIndex)).darker(0.5); })
					 .on("mousemove", onMouseMove)
					 .on("mouseout", onMouseOut)
					 .transition()
					 .delay(delay)
					 .duration(duration)
					 .attr("transform", function(d, i) { return "translate (" + bottomScale(d.yValue > yStart ? d.yValue : yStart) + "," + (leftScale(d.xValue) + (leftScale.bandwidth() / data.length * d.dataIndex)  + bar3DLen) + ") skewY(-45)"; });
					
					
					rects.append("g").attr("class", "rectTop")
					.selectAll("rect")
					 .data(function(d, i){ d.values.map(function(b){ b.dataIndex=i; return b; }); return d.values; })
					 .enter().append("rect")
					 .attr("width", 0)
					 .attr("height", bar3DLen)
					 .attr("transform", function(d, i) { return "translate (" + (bottomScale(yStart) + bar3DLen) + "," + (leftScale(d.xValue) + (leftScale.bandwidth() / data.length * d.dataIndex)) + ") skewX(-45)"; })
					 .style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
					 .on("mousemove", onMouseMove)
					 .on("mouseout", onMouseOut)
					 .transition()
					 .delay(delay)
					 .duration(duration)
					 .attr("width", function(d, i) { return d.yValue > yStart ? bottomScale(d.yValue) - bottomScale(yStart) : bottomScale(yStart) - bottomScale(d.yValue); })
					 .attr("transform", function(d, i) { return "translate (" + (bottomScale(d.yValue < yStart ? d.yValue : yStart) + bar3DLen)+ "," + (leftScale(d.xValue) + (leftScale.bandwidth() / data.length * d.dataIndex)) + ")  skewX(-45)"; }); }
				
				
				rects.append("g").attr("class", "rectBody")
				.selectAll("rect")
				.data(function(d, i){ d.values.map(function(b){ b.dataIndex=i; return b; }); return d.values; })
				.enter().append("rect")
				.attr("x", bottomScale(yStart))
				.attr("y", function(d, i) { return leftScale(d.xValue) + (leftScale.bandwidth() / data.length * d.dataIndex) + bar3DLen; })
				.attr("width", 0)
				.attr("height", leftScale.bandwidth() / data.length - bar3DLen)
				.style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
				.on("mousemove", onMouseMove)
				.on("mouseout", onMouseOut)
				.transition()
				.delay(delay)
				.duration(duration)
				.attr("x", function(d, i) { return bottomScale(d.yValue < yStart ? d.yValue : yStart); })
				.attr("width", function(d, i) { return d.yValue > yStart ? bottomScale(d.yValue) - bottomScale(yStart) : bottomScale(yStart) - bottomScale(d.yValue); });
				*/
				
//				for (var i = 0; i < data[0].values.length; i++) {
//				    for (var j = 0; j < data.length; j++) {
				for (var i = 0; i < data[0].values.length; i++) {
				    for (var j = data.length - 1; j >= 0; j--) {
				    	var imsidata = new Array();
				    	imsidata.push(data[j].values[i]);
				      
					    //top
					    rects.append("rect")
					    .data(imsidata)
					    .attr("width", 0)
						.attr("height", bar3DLen)
						.attr("transform", function(d, i) { return "translate (" + (bottomScale(yStart) + bar3DLen) + "," + (leftScale(d.xValue) + (leftScale.bandwidth() / data.length * d.dataIndex)) + ") skewX(-45)"; })
						.style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
						.on("mousemove", onMouseMove)
						.on("mouseout", onMouseOut)
						.transition()
						.delay(delay)
						.duration(duration)
						.attr("width", function(d, i) { return d.yValue > yStart ? bottomScale(d.yValue) - bottomScale(yStart) : bottomScale(yStart) - bottomScale(d.yValue); })
						.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.yValue < yStart ? d.yValue : yStart) + bar3DLen)+ "," + (leftScale(d.xValue) + (leftScale.bandwidth() / data.length * d.dataIndex)) + ")  skewX(-45)"; })
						;
				        
	  					//right 
	  					rects.append("rect")
	  					.data(imsidata)
						.attr("width", bar3DLen)
						.attr("height", leftScale.bandwidth() / data.length - bar3DLen)
						.attr("transform", function(d, i) { return "translate (" + bottomScale(yStart) + "," + (leftScale(d.xValue) + (leftScale.bandwidth() / data.length * d.dataIndex) + bar3DLen) + ") skewY(-45)"; })
						.style("fill", function(d, i) { return d3.rgb(color(d.colorIndex)).darker(0.5); })
						.on("mousemove", onMouseMove)
						.on("mouseout", onMouseOut)
						.transition()
						.delay(delay)
						.duration(duration)
						.attr("transform", function(d, i) { return "translate (" + bottomScale(d.yValue > yStart ? d.yValue : yStart) + "," + (leftScale(d.xValue) + (leftScale.bandwidth() / data.length * d.dataIndex)  + bar3DLen) + ") skewY(-45)"; })
					    ;
	  					
					    //body
					    rects.append("rect")
					    .data(imsidata)
	  					.attr("x", bottomScale(yStart))
//						.attr("y", function(d, i) { return leftScale(d.xValue) + (leftScale.bandwidth() / data.length * d.dataIndex) + bar3DLen; })
	  					.attr("y", function(d, i) { 
	  						return leftScale(d.xValue) + (leftScale.bandwidth() / data.length * d.dataIndex) + bar3DLen; })
						.attr("width", 0)
						.attr("height", leftScale.bandwidth() / data.length - bar3DLen)
						.style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
						.on("mousemove", onMouseMove)
						.on("mouseout", onMouseOut)
						.transition()
						.delay(delay)
						.duration(duration)
						.attr("x", function(d, i) { return bottomScale(d.yValue < yStart ? d.yValue : yStart); })
						.attr("width", function(d, i) { return d.yValue > yStart ? bottomScale(d.yValue) - bottomScale(yStart) : bottomScale(yStart) - bottomScale(d.yValue); })
	  					;
				    }
				}
			}
			
			
		    
		    function onMouseMove(d, i) {
		    	if ((gThis.stacked == "1" || gThis.stacked == "2")) {
					var p = d3.select(this.parentNode.parentNode.parentNode);
					p.select(".rectBody").selectAll(".rects").filter(":nth-child(" + (d.colorIndex + 1) + ")").selectAll("rect").filter(":nth-child(" + (i + 1) + ")").style('opacity', 0.7);
			    	p.select(".rectTop").selectAll(".rects").filter(":nth-child(" + (d.colorIndex + 1) + ")").selectAll("rect").filter(":nth-child(" + (i + 1) + ")").style('opacity', 0.7);
			    	p.select(".rectRight").selectAll(".rects").filter(":nth-child(" + (d.colorIndex + 1) + ")").selectAll("rect").filter(":nth-child(" + (i + 1) + ")").style('opacity', 0.7);
			    	
		    	} else {
		    		var p = d3.select(this.parentNode);
		    		var column3d = 3;  /* column, bar를 3d로 만들면 node가 1개에서 3개가 되므로 */
			    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 1) + ")").style('opacity', 0.7);
			    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 2) + ")").style('opacity', 0.7);
			    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 3) + ")").style('opacity', 0.7);
		    	}
		    	
		        tooltip_mousemove();
		    };
		    
		    function onMouseOut(d, i) {
		    	if ((gThis.stacked == "1" || gThis.stacked == "2")) {
					var p = d3.select(this.parentNode.parentNode.parentNode);
					p.select(".rectBody").selectAll(".rects").filter(":nth-child(" + (d.colorIndex + 1) + ")").selectAll("rect").filter(":nth-child(" + (i + 1) + ")").style('opacity', 1);
			    	p.select(".rectTop").selectAll(".rects").filter(":nth-child(" + (d.colorIndex + 1) + ")").selectAll("rect").filter(":nth-child(" + (i + 1) + ")").style('opacity', 1);
			    	p.select(".rectRight").selectAll(".rects").filter(":nth-child(" + (d.colorIndex + 1) + ")").selectAll("rect").filter(":nth-child(" + (i + 1) + ")").style('opacity', 1);
			    	
		    	} else {
		    		var p = d3.select(this.parentNode);
		    		var column3d = 3;  /* column, bar를 3d로 만들면 node가 1개에서 3개가 되므로 */
			    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 1) + ")").style('opacity', 1);
			    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 2) + ")").style('opacity', 1);
			    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 3) + ")").style('opacity', 1);
		    	}
		    	
		    	tooltip_mouseout();
		    };
        }
        
        
        function makeParetoChart() {
        	
        	/* tick을 만들기 위해 계산 시작 ------------------------------------------------- */
			var max = Math.floor(ymax);
			while (true) {
				var len = (max + "").length;
				
				if ((max / 5) % 5 == 0) {
					ymax = max;
					break;
				}
				
				if (len == 1 || len == 2) {
					max += 1;
				} else {
					max = max + "";
					var a = max.substr(0,2);
					max = ((a * 1) + 1) * Math.pow(10, len - 2);
				}
			}
			
			var tickValue = ymax / gThis.ytick;
			tickValues = [];
			for (var i = 0; i <= gThis.ytick; i++) {
				tickValues[i] = tickValue * i;
			}
			/* tick을 만들기 위해 계산 종료 ------------------------------------------------- */
			
			
			/* 크기 측정용 임시 축 만들기 시작 ------------------------------------------------- */
			bottomScale = d3.scaleBand().domain(data[0].values.map(function(d, i){ return d.xValue; }));
			leftScale = d3.scaleLinear().domain([ymin, ymax]);
			rightScale = d3.scaleLinear().domain([0, 100]);
			
			axis.append("g").attr("class", "bottomAxis").call(d3.axisBottom(bottomScale));
			axis.append("g").attr("class", "leftAxis").call(d3.axisLeft(leftScale).tickValues(tickValues));
			axis.append("g").attr("class", "rightAxis").call(d3.axisLeft(rightScale).ticks(6));
			
			var getbottomAxis = axis.select(".bottomAxis").node().getBBox();
			var getleftAxis = axis.select(".leftAxis").node().getBBox();
			var getrightAxis = axis.select(".rightAxis").node().getBBox();
			
			axis.select(".bottomAxis").remove();
			axis.select(".leftAxis").remove();
			axis.select(".rightAxis").remove();
			/* 크기 측정용 임시 축 만들기 종료 ------------------------------------------------- */
			
			/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			margin.top += gettitle.height > 0 ? gettitle.height + 20 : 0;
			margin.top += bar3DLen;
			
			if (getlegend != "" && gThis.legendType == "right") {
				legend.attr("transform", "translate(" + (gThis.width - getlegend.width - margin.right) + ", " + margin.top + ")");
				margin.right += getlegend.width + 10;
			} else if (getlegend != "") {
				legend.attr("transform", "translate(" + ((gThis.width / 2) - (getlegend.width / 2)) + ", " + (gThis.height - margin.bottom - getlegend.height + (0 - getlegend.y)) + ")");
				margin.bottom += getlegend.height + 10;
			}
			
			margin.right += getrightAxis.width + 10;
			
			label.select(".bottomtitle").attr("y", gThis.height - margin.bottom - getbottomtitle.height + (0 - getbottomtitle.y));
			margin.bottom += getbottomtitle.height > 0 ? getbottomtitle.height + 10 : 0;
			
			label.select(".lefttitle").attr("x", - (margin.top + ((gThis.height - margin.top - margin.bottom ) / 2)));
			label.select(".lefttitle").attr("y", margin.left + (0 - getlefttitle.y));
			margin.left += getlefttitle.height > 0 ? getlefttitle.height + 10 : 0;
			margin.left += getleftAxis.width;
			
			if (trendwidth > 0) margin.right += trendwidth;
			
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			label.select(".bottomtitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
			
			bottomScale = d3.scaleBand()
						   .range([margin.left, gThis.width - margin.right])
						   .domain(data[0].values.map(function(d, i){ return d.xValue; }))
						   .padding(0.4).paddingOuter(0.2);
			
			bottomScale.type = "scaleBand";
			
			axis.append("g").attr("class", "bottomAxis")
				.call(d3.axisBottom(bottomScale))
				.attr("transform", "translate(0," + (gThis.height - margin.bottom) + ")")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("bottom");
			
			bottomAxisLF();
			
			
			leftScale = d3.scaleLinear()
						   .range([gThis.height - margin.bottom, margin.top])
						   .domain([ymin, ymax]);
			leftScale.type = "scaleLinear";
			
			axis.append("g").attr("class", "leftAxis")
				.call(d3.axisLeft(leftScale).tickValues(tickValues))
				.attr("transform", "translate(" + margin.left + ", 0)")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("left");
			
			
			var rightTickValues = [];
			if (gThis.ytick == 5) rightTickValues = [0, 20, 40, 60, 80, 100];
			else if (gThis.ytick == 4) rightTickValues = [0, 25, 50, 75, 100];
			else if (gThis.ytick == 2) rightTickValues = [0, 50, 100];
			else if (gThis.ytick == 1) rightTickValues = [0, 100];
			
			rightScale = d3.scaleLinear()
			   .range([gThis.height - margin.bottom, margin.top])
			   .domain([0, 100]);
			rightScale.type = "scaleLinear";
			
			axis.append("g").attr("class", "rightAxis")
//				.call(d3.axisRight(rightScale).ticks(gThis.ytick).tickFormat(function(d, i) { return d + "%"; }))
				.call(d3.axisRight(rightScale).tickValues(rightTickValues).tickFormat(function(d, i) { return d + "%"; }))
				.attr("transform", "translate(" + (gThis.width - margin.right)  + ", 0)")
				.style("font-size", gThis.fontSize + "px");
			
			
			
			makeChartBG();
			
			
			//차트 가로줄 그리기
			if (true || gThis.grid == 1 || gThis.grid == 3) {
				chart.append("g").attr("class","xLines")
					 .selectAll(".xLine")
					 .data(tickValues)
					 .enter().append("rect")
					 .attr("class","xLine")
					 .attr("x", margin.left)
					 .attr("y", function(d, i) { return leftScale(d); })
					 .attr("width", gThis.width - margin.left - margin.right)
					 .attr("height", 1)
					 .style("fill", "#EEEEEE");
			}
			
			//차트 세로줄 그리기
			if (gThis.grid == 2 || gThis.grid == 3) {		
				chart.append("g").attr("class","yLines")
				     .selectAll(".yLine")
				     .data(bottomScale.domain())
				     .enter().append("rect")
				     .attr("class","yLine")
				     .attr("x", function(d, i) { return bottomScale(d) + (bottomScale.bandwidth() / 2) ; })
				     .attr("y", margin.top)
				     .attr("width", 1)
				     .attr("height", gThis.height - margin.top - margin.bottom)
				     .style("fill", "#EEEEEE");
			}		

			if (ymin < 0) {
				if (gThis.chart3d == "true") {
					chart.append("rect").attr("class", "zero-plane")
					.attr("width", bottomScale.range()[1] - bottomScale.range()[0])
					.attr("height", bar3DLen)
					.attr("transform", function(d, i) { return "translate (" + (bottomScale.range()[0] + bar3DLen) + "," + (leftScale(yStart) - bar3DLen) + ") skewX(-45)"; })
					.style("fill", "#EEEEEE")
					.style("opacity", 1);
					
				} else {
					chart.append("rect").attr("class", "zero-plane")
					.attr("x", bottomScale.range()[0])
					.attr("y", leftScale(yStart) - 1)
					.attr("width", bottomScale.range()[1] - bottomScale.range()[0])
					.attr("height", 3)
					.style("fill", "#EEEEEE");
				}
			}
			
			
			svg.on("mousemove", function(d, i) {
				var offsetX = mouse_offsetX();
				var offsetY = mouse_offsetY();
				var xValue = current_position_bottom_scaleBand(offsetX);
				var d = data[0].values[xValue.index];
				
		        tooltip.select('.tooltipText').html("<b>" + d.xValue + " : " + d.yValue + " (" + (d.yValueT / d.total * 100).toFixed(2) + "%)" + "</b>");
		    	tooltip_posiction();
				tooltipLine_mousemove("area"); 
			})
		   .on("mouseout", function(d, i) { tooltipLine_mouseout(); tooltip_mouseout(); });
			
			
			var rects = chart.append("g").attr("class", "rects");
			
			for (var i = 0; i < data[0].values.length; i++) {
			    for (var j = 0; j < data.length; j++) {
			    	var imsidata = new Array();
			    	imsidata.push(data[j].values[i]);
			      
				    //top
				    rects.append("rect")
				    .data(imsidata)
					.attr("width", bottomScale.bandwidth() / data.length)
					.attr("height", bar3DLen)
					.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + bar3DLen) + "," + (leftScale(yStart) - bar3DLen) + ") skewX(-45)"; })
					.style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
					.on("mousemove", onMouseMove)
					.on("mouseout", onMouseOut)
					.transition()
					.delay(delay)
					.duration(duration)
					.attr("height", bar3DLen)
					.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + bar3DLen) + "," + (leftScale(d.yValue < yStart ? yStart : d.yValue) - bar3DLen) + ") skewX(-45)"; })
					;
			        
  					//right 
  					rects.append("rect")
  					.data(imsidata)
					.attr("width", bar3DLen)
					.attr("height", 0)
					.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + (bottomScale.bandwidth() / data.length)) + "," + leftScale(yStart) + ") skewY(-45)"; })
					.style("fill", function(d, i) { return d3.rgb(color(d.colorIndex)).darker(0.5); })
					.on("mousemove", onMouseMove)
					.on("mouseout", onMouseOut)
					.transition()
					.delay(delay)
					.duration(duration)
					.attr("height", function(d, i) { return d.yValue > yStart ? leftScale(yStart) - leftScale(d.yValue) : leftScale(d.yValue) - leftScale(yStart); })
					.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + (bottomScale.bandwidth() / data.length)) + "," + (leftScale(d.yValue < yStart ? yStart : d.yValue)) + ") skewY(-45)"; })
				    ;
  					
				    //body
				    rects.append("rect")
				    .data(imsidata)
  					.attr("x", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex); })
					.attr("y", leftScale(yStart))
					.attr("width", bottomScale.bandwidth() / data.length)
					.attr("height", 0)
					.style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
					.on("mousemove", onMouseMove)
					.on("mouseout", onMouseOut)
					.transition()
					.delay(delay)
					.duration(duration)
					.attr("y", function(d, i) { return leftScale(d.yValue < yStart ? yStart : d.yValue); })
					.attr("height", function(d, i) { return d.yValue > yStart ? leftScale(yStart) - leftScale(d.yValue) : leftScale(d.yValue) - leftScale(yStart); })
  					;
			    }
			}
			
		    function onMouseMove(d, i) {
		    	var p = d3.select(this.parentNode);
		    	var column3d = 3;  /* column, bar를 3d로 만들면 node가 1개에서 3개가 되므로 */
		    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 1) + ")").style('opacity', 0.7);
		    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 2) + ")").style('opacity', 0.7);
		    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 3) + ")").style('opacity', 0.7);
		    	
		        tooltip_mousemove();
		    };
		    
		    function onMouseOut(d, i) {
		    	var p = d3.select(this.parentNode);
		    	var column3d = 3;  /* column, bar를 3d로 만들면 node가 1개에서 3개가 되므로 */
		    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 1) + ")").style('opacity', 1);
		    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 2) + ")").style('opacity', 1);
		    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 3) + ")").style('opacity', 1);
		    	
		    	tooltip_mouseout();
		    };
			
		
			var line = d3.line()
						 .x(function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2)/*bottomScale(d.xValue)*/; })
						 .y(function(d, i) { return rightScale(Math.floor(d.yValueT / d.total * 100)); })
						 .curve(curveArray[gThis.curveType]);

			var lines = chart.append('g').attr('class', 'lines');

			lines.append('g').attr('class', 'line-group')
				 .selectAll(".path")
				 .data(data).enter()
			     .append('path')
			     .attr('class', 'line')  
			     .attr('d', function(d, i) { return line(d.values); })
			     .style('stroke', "#5D5D5D")
			     .style('stroke-width', lineStroke)
			     .style('opacity', 0.9)
			     .style('fill', 'none')
			     .on("mouseover", function(d, i) {
			    	 lines.selectAll('.line').style('opacity', 1);
			    	 lines.selectAll('.circle').style('opacity', circleOpacityOnLineHover);
			    	 
			    	 lines.selectAll(".line").filter(":nth-child(" + (i + 1) + ")")
			    	   .style('opacity', lineOpacityHover)
			    	   .style("stroke-width", lineStrokeHover); 
			    })
			    .on("mouseout", function(d, i) {
			    	lines.selectAll(".line").style('opacity', 0.9);
			    	lines.selectAll('.circle').style('opacity', circleOpacity);
			    	lines.selectAll(".line").filter(":nth-child(" + (i + 1) + ")").style("stroke-width", lineStroke).style("cursor", "none");
			    });
				

			/* Add circles in the line */
			lines.selectAll("circle-group")
				 .data(data).enter()
				 .append("g")
				 .attr("class", "circle-group")
				 .style("fill", "#5D5D5D")
				 .selectAll("circle")
				 .data(function(d, i) { return d.values; }).enter()
				 .append("g")
				 .attr("class", "circle")  
				 .on("mouseover", function(d, i) { })
				 .on("mouseout", function(d, i) { })
				 .append("circle")
				 .attr("cx", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2)/*bottomScale(d.xValue)*/; })
				 .attr("cy", function(d, i) { return rightScale(Math.floor(d.yValueT / d.total * 100)); })
				 .attr("r", circleRadius)
				 .style('opacity', gThis.animateFlag == true ? 0 : circleOpacity)
				 .style("stroke-width", "1")
				 .style("stroke", "#5D5D5D")
				 .on("mouseover", function(d, i) {
					 d3.select(this)
					   .transition()
					   .duration(lineDuration)
					   .attr("r", circleRadiusHover)
					   .style("fill", "#ffffff");
				 })
				 .on("mouseout", function(d, i) {
					 d3.select(this) 
					   .transition()
					   .duration(lineDuration)
					   .attr("r", circleRadius)
					   .style("fill", "#5D5D5D");  
				 });
			
			if (gThis.animateFlag == true) {
				lines.selectAll(".line-group")
				.selectAll(".line")
				.attr("stroke-dasharray", function(d, i) { totalLength = d3.select(this).node().getTotalLength(); return totalLength + " " + totalLength; })
				.attr("stroke-dashoffset", function(d, i) { return d3.select(this).node().getTotalLength();})
				.transition()
				.delay(delay)
				.duration(duration)
				.ease(d3.easeLinear)
				.attr("stroke-dashoffset", 0);
				
				lines.selectAll(".circle-group")
				.selectAll(".circle").select("circle")
				.transition()
				.delay(delay + (duration))
				.style("opacity", 1);
			}
        }
        
        
        function makeGanttChart() {
        	
        	/* 날짜 형식, 날짜 형식 확인 정규식 */
        	var date_format_Array = [ 
        		["yyyy-MM-dd HH:mm:ss", "^([0-9]{4}-(0[1-9]|1[0-2]|[0-9])-(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["yyyy/MM/dd HH:mm:ss", "^([0-9]{4}/(0[1-9]|1[0-2]|[0-9])/(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["yyyy.MM.dd HH:mm:ss", "^([0-9]{4}.(0[1-9]|1[0-2]|[0-9]).(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["MM-dd-yyyy HH:mm:ss", "^((0[1-9]|1[0-2]|[0-9])-(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])-[0-9]{4}) ((2[0-3]|[01][0-9])|[0-9]:[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["MM/dd/yyyy HH:mm:ss", "^((0[1-9]|1[0-2]|[0-9])/(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])/[0-9]{4}) ((2[0-3]|[01][0-9])|[0-9]:[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["MM.dd.yyyy HH:mm:ss", "^((0[1-9]|1[0-2]|[0-9])\.(0[1-9]|[1-2][0-9]|3[0-1]|[0-9]).[0-9]{4}) ((2[0-3]|[01][0-9])|[0-9]:[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["dd-MM-yyyy HH:mm:ss", "^((0[1-9]|[1-2][0-9]|3[0-1]|[0-9])-(0[1-9]|1[0-2]|[0-9])-[0-9]{4}) ((2[0-3]|[01][0-9])|[0-9]:[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["dd/MM/yyyy HH:mm:ss", "^((0[1-9]|[1-2][0-9]|3[0-1]|[0-9])/(0[1-9]|1[0-2]|[0-9])/[0-9]{4}) ((2[0-3]|[01][0-9])|[0-9]:[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["dd.MM.yyyy HH:mm:ss", "^((0[1-9]|[1-2][0-9]|3[0-1]|[0-9]).(0[1-9]|1[0-2]|[0-9]).[0-9]{4}) ((2[0-3]|[01][0-9])|[0-9]:[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
                ["yyyy-MM-dd HH:mm",    "^([0-9]{4}-(0[1-9]|1[0-2]|[0-9])-(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["yyyy/MM/dd HH:mm",    "^([0-9]{4}/(0[1-9]|1[0-2]|[0-9])/(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["yyyy.MM.dd HH:mm",    "^([0-9]{4}.(0[1-9]|1[0-2]|[0-9]).(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["MM-dd-yyyy HH:mm",    "^((0[1-9]|1[0-2]|[0-9])-(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])-[0-9]{4}) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["MM/dd/yyyy HH:mm",    "^((0[1-9]|1[0-2]|[0-9])/(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])/[0-9]{4}) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["MM.dd.yyyy HH:mm",    "^((0[1-9]|1[0-2]|[0-9]).(0[1-9]|[1-2][0-9]|3[0-1]|[0-9]).[0-9]{4}) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["dd-MM-yyyy HH:mm",    "^((0[1-9]|[1-2][0-9]|3[0-1]|[0-9])-(0[1-9]|1[0-2]|[0-9])-[0-9]{4}) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["dd/MM/yyyy HH:mm",    "^((0[1-9]|[1-2][0-9]|3[0-1]|[0-9])/(0[1-9]|1[0-2]|[0-9])/[0-9]{4}) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["dd.MM.yyyy HH:mm",    "^((0[1-9]|[1-2][0-9]|3[0-1]|[0-9]).(0[1-9]|1[0-2]|[0-9]).[0-9]{4}) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["yyyy-MM-dd",          "[0-9]{4}-(0[1-9]|1[0-2]|[0-9])-(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])"],
                ["yyyy/MM/dd",          "[0-9]{4}/(0[1-9]|1[0-2]|[0-9])/(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])"],
                ["yyyy.MM.dd",          "[0-9]{4}.(0[1-9]|1[0-2]|[0-9]).(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])"],
                ["MM-dd-yyyy",          "(0[1-9]|1[0-2]|[0-9])-(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])-[0-9]{4}"],
                ["MM/dd/yyyy",          "(0[1-9]|1[0-2]|[0-9])/(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])/[0-9]{4}"],
                ["MM.dd.yyyy",          "(0[1-9]|1[0-2]|[0-9]).(0[1-9]|[1-2][0-9]|3[0-1]|[0-9]).[0-9]{4}"],
                ["dd-MM-yyyy",          "(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])-(0[1-9]|1[0-2]|[0-9])-[0-9]{4}"],
                ["dd/MM/yyyy",          "(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])/(0[1-9]|1[0-2]|[0-9])/[0-9]{4}"],
                ["dd.MM.yyyy",          "(0[1-9]|[1-2][0-9]|3[0-1]|[0-9]).(0[1-9]|1[0-2]|[0-9]).[0-9]{4}"],
                ["HH:mm:ss",            "(2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9]"],
                ["HH:mm",               "(2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9]"]
	        ];
        	
        	/* 날짜 형식 */
        	var date_format = "";
        	
        	/* 날짜 형식 확인하기 */
        	for (var i = 0; i < date_format_Array.length; i++) {
        		var checkFlag = true;
        		var pattern = date_format_Array[i][1];
        		var re = new RegExp(pattern);
        		
        		for (var j = 0; j < data.length; j++) {
        			/* 해당 날짜 형식 확인 정규식이 아니면 종료 */
        			if (!re.test(data[j].start) || !re.test(data[j].end)) {
        				checkFlag = false;
        				break;
        			}
        		};
        		
        		/* 날짜 형식 확인 정규식에 맞으면 종료 */
        		if (checkFlag == true) {
        			date_format = date_format_Array[i][0];
        			break;
        		}
        	}
        	
        	var today = new Date().getFullYear() + "/" + (new Date().getMonth() + 1) + "/" + new Date().getDate();  /* 오늘 날짜 : 2019/02/14 */
        	
        	/* 날짜에는 시간 까지 들어가야 하는데 년월일만 입력하면 시간을 더 입력해줌 */
        	if (date_format.indexOf("HH") == -1) {
        		for (var i = 0; i < data.length; i++) {
        			data[i].start_bar_data = data[i].start + " 00:00:00";
        			data[i].end_bar_data = data[i].end + " 23:59:59";
        		}
        		
        	} else if (date_format == "HH:mm:ss" || date_format == "HH:mm") {
        		for (var i = 0; i < data.length; i++) {
        			data[i].start_bar_data = today + " " + data[i].start;
        			data[i].end_bar_data = today + " " + data[i].end;
        		}
        		
        	} else {
        		for (var i = 0; i < data.length; i++) {
	        		data[i].start_bar_data = data[i].start;
	    			data[i].end_bar_data = data[i].end;
        		}
        	}
        	
        	
        	
        	/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			margin.top += gettitle.height > 0 ? gettitle.height + 20 : 0;
			
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
			
			
			var gantt = chart.append("g").attr("class","gantt").style("border", "1px solid black");
			
			/* 세로 스크롤 영역 선언 */
			var vertical_scroll_clipPath = gantt.append("g").attr("class", "vertical_scroll_clipPath")
												.call(d3.drag().on("start", dragstarted)
															   .on("drag", dragged)
															   .on("end", dragended));
			/* 세로 스크롤바 선언 */
			var vertical_scroll = gantt.append("g").attr("class", "vertical_scroll");
			
			/* 카테고리 선언 */
			var categories = gantt.append("g").attr("class", "categories");
			var category_year = categories.append("g").attr("class", "category_year");
			var category_month = categories.append("g").attr("class", "category_month");
			var category_week = categories.append("g").attr("class", "category_week");
			var category_dayOfWeek = categories.append("g").attr("class", "category_dayOfWeek");
			var category_time = categories.append("g").attr("class", "category_time");
			
			/* task 선언 */
			var tasks = vertical_scroll_clipPath.append("g").attr("class", "tasks");
			var task_rects = tasks.append("g").attr("class", "task_rects");
			var task_texts = tasks.append("g").attr("class", "task_texts");
			
			/* x, y 라인 선언 */
			var xLines = vertical_scroll_clipPath.append("g").attr("class", "xLines");
			var yLines = vertical_scroll_clipPath.append("g").attr("class", "yLines");
			
			/* bar 선언 */
			var bars = vertical_scroll_clipPath.append("g").attr("class", "bars");
			
			/* 카테고리에 필요한 데이터 배열 선언 */
			var data_year = [];
			var data_month = [];
			var data_week = [];
			var data_dayOfWeek = [];
			var data_time = [];
			
			/* 최소 날짜, 최대 날짜 구하기 */
			var oneDay = 86400000;  /* Date 끼리 빼면 값이 숫자로 나오는데 이것으로 나누면 며칠인지 계산됨 */
			var minDate = new Date(data[0].end);
			var maxDate = new Date(data[0].start);
			for (var i = 0; i < data.length; i++) {
				if (new Date(minDate) > new Date(data[i].start)) minDate = new Date(data[i].start);
				if (new Date(maxDate) < new Date(data[i].end)) maxDate = new Date(data[i].end);
			}
			
			/* 카테고리 데이터 만들기 */
			if (maxDate.getFullYear() - minDate.getFullYear() >= 3) make_category_data(0);  /* 년 */
			else if (maxDate.getFullYear() - minDate.getFullYear() >= 1) make_category_data(1);  /* 년, 월 (홀수달 2개월 단위) */
			else if (maxDate.getMonth() - minDate.getMonth() >= 3) make_category_data(2);  /* 년, 월*/	
			else if ((maxDate - minDate) / oneDay > 7) make_category_data(3);  /* 월, 주 */
			else if (maxDate.getDate() - minDate.getDate() >= 1) make_category_data(4);  /* 요일 */
			else make_category_data(5);  /* 시간 */
			
			/* 카테고리 정보 만들기 */
			var category_rect_padding = {top: 4, right: 4, bottom: 4, left: 4};
			var category_text_info = text_info("", gThis.fontSize, "bold");
			var category_rect_height = category_rect_padding.top + category_text_info.height + category_rect_padding.bottom;
			var category_text_vertical_center = (category_rect_height / 2) + ((category_text_info.height + (category_text_info.y / 2)) / 2);  /* 카테고리 text 세로 정렬 y축 위치*/
			var category_year_y = margin.top;
			var category_month_y = category_year_y + (data_year.length > 0 ? category_rect_height : 0);
			var category_week_y = category_month_y + (data_month.length > 0 ? category_rect_height : 0);
			var category_dayOfWeek_y = category_week_y + (data_week.length > 0 ? category_rect_height : 0);
			var category_time_y = category_dayOfWeek_y + (data_dayOfWeek.length > 0 ? category_rect_height : 0);
			
			/* task 정보 만들기 */
			var task_y = category_time_y + (data_time.length > 0 ? category_rect_height : 0);
			var task_height = gThis.height - task_y - margin.bottom;
			var task_text_info = text_info("", gThis.fontSize, "");
			var task_text_vertical_center = 0;  /* 카테고리 text 세로 정렬 y축 위치, 아래ㅇ*/
			var task_rect_padding = {top: 4, right: 4, bottom: 4, left: 4};
			var task_rect_height = task_rect_padding.top + task_text_info.height + task_rect_padding.bottom;
			var task_rect_width = 0;
			
			/* 세로 스크롤 정보 만들기 */
			var vertical_scroll_height = gThis.height - task_y - margin.bottom;
			
			/* 중복제거 된 task 데이터 만들기 */
			var data_task = [];
			data.forEach(function(d) {
                if (data_task.indexOf(d.task) == -1) data_task[data_task.length] = d.task;
            });
			
			/* task rect height 계산  */
			if (task_height > task_rect_height * data_task.length) {  /* task_height 안에 rect 높이를 균등하게 맞춤 */
				task_rect_padding_top_bottom = (task_height - (task_rect_height * data_task.length)) / data_task.length / 2;
				task_rect_padding.top += task_rect_padding_top_bottom;
				task_rect_padding.bottom += task_rect_padding_top_bottom;
				task_rect_height = task_rect_padding.top + task_text_info.height + task_rect_padding.bottom;
			}
			
			/* task height 계산  */
			task_height = task_rect_height * data_task.length;
			
			/* task text 세로 정렬 계산  */
			task_text_vertical_center = (task_rect_height / 2) + ((task_text_info.height + (task_text_info.y / 2)) / 2);  /* task text 세로 정렬 y축 위치*/
			
			/* task rect width 계산  */
			var task_text_width = 0;
			for (var i = 0; i < data_task.length; i++ ) {
				var font_info = text_info(data_task[i], gThis.fontSize, "");
				if (font_info.width > task_text_width) task_text_width = font_info.width;
				task_rect_width = task_rect_padding.left + task_text_width + task_rect_padding.right;
			}
			
			/* 세로스크롤에 필요한 clipPath 만들기 */
			create_clipPath(gThis.controlId + "_vertical_scroll_clipPath", margin.left, task_y, gThis.width - margin.left - margin.right, vertical_scroll_height);
			vertical_scroll_clipPath.attr("clip-path", "url(#" + gThis.controlId + "_vertical_scroll_clipPath)");
			
			/* task 만들기 */
			task_rects.selectAll(".task_rect")
			.data(data_task).enter()
			.append("rect").attr("class","task_rect")
			.attr("x", margin.left)
			.attr("y", function(d, i) { return task_y + (task_rect_height * i); })
			.attr("width", task_rect_width)
			.attr("height", task_rect_height)
			.style("fill", "#FFFFFF");
			
			task_texts.selectAll(".task_text")
			.data(data_task).enter()
			.append("text").attr("class","task_text")
			.attr("x", margin.left + task_rect_padding.left)
			.attr("y", function(d, i) { return task_y + (task_rect_height * i) + task_text_vertical_center; })
			.attr("font-size", gThis.fontSize + "px")
			.text(function(d, i) { return d; });
			
			
			/* 세로 스크롤 만들기 */
			if (task_height > vertical_scroll_height) {
				var scroll_width = 11;
				var scroll_bar_height = vertical_scroll_height * (vertical_scroll_height / task_height);
				
				vertical_scroll
				.append("rect").attr("class", "vertical_scroll_background")
				.attr("x", gThis.width - margin.right - scroll_width)
				.attr("y", task_y)
				.attr("width", scroll_width)
				.attr("height", vertical_scroll_height)
				.attr("stroke", "#B2B2B2")
				.attr("stroke-width", 0.5)
				.style("fill", "#F1F1F1")
				.on("mousedown", vertical_scroll_mousedown);
				
				function vertical_scroll_mousedown() {
					if (gThis.vertical_scroll_mousekeypress_flag == false) return;
					
					var scroll_current_y = getTransform(vertical_scroll.select(".vertical_scroll_bar"), 1);  /* 스크롤바의 현재 위치 */
					
					if (d3.mouse(this)[1] - task_y > scroll_current_y)
						scroll_move_y = scroll_current_y + (vertical_scroll_height - scroll_bar_height) * 0.1;
					else 
						scroll_move_y = scroll_current_y + (vertical_scroll_height - scroll_bar_height) * -0.1;
					
					
					if (scroll_move_y < 0) scroll_move_y = 0;  /* 스크롤바 시작 지점보다 작으면 시작지점으로 이동 */
					if (scroll_move_y > vertical_scroll_height - scroll_bar_height) scroll_move_y = vertical_scroll_height - scroll_bar_height;  /* 스크롤바 종료 지점 크면 종료지점으로 이동 */
					
					var scroll_move_rate = scroll_move_y / (vertical_scroll_height - scroll_bar_height);  /* 스크롤바가 이동한 거리에 대한 비율 */
					var tasks_move_y = (task_height - vertical_scroll_height) * scroll_move_rate * -1;  /* 스크롤바가 이동한 비율 만큼에 대한 tasks의 이동거리 */
					
					vertical_scroll.select(".vertical_scroll_bar").attr("transform", "translate(0," + scroll_move_y + ")");  /* 스크롤바 이동 */
					tasks.attr("transform", "translate(0," + tasks_move_y + ")");  /* tasks 이동 */
					bars.attr("transform", "translate(0," + tasks_move_y + ")");  /* bars 이동 */
					xLines.attr("transform", "translate(0," + tasks_move_y + ")");  /* xLines 이동 */
				}
				
				
				vertical_scroll
				.append("rect").attr("class", "vertical_scroll_bar")
				.attr("x", gThis.width - margin.right - scroll_width)
				.attr("y", task_y)
				.attr("width", scroll_width)
				.attr("height", scroll_bar_height)
				.style("fill", "#D1D1D1")
				.on("mouseover", "")
				.on("mousemove", function(d, i) { d3.select(this).style("fill", "#C1C1C1"); })
				.on("mouseout", function(d, i) { d3.select(this).style("fill", "#D1D1D1"); })
				.call(d3.drag().on("start", dragstarted)
							   .on("drag", dragged)
							   .on("end", dragended));
				
				function  dragstarted(d) {
					gThis.mouse_start_y = d3.mouse(this)[1];
				}

				function  dragged(d) {
					var scroll_current_y = getTransform(vertical_scroll.select(".vertical_scroll_bar"), 1);  /* 스크롤바의 현재 위치 */
					var mouse_move_length = gThis.mouse_start_y - d3.mouse(this)[1];  /* 마우스가 이동한 거리 */
					var scroll_move_y = scroll_current_y - mouse_move_length;  /* 스크롤바가 이동할 위치 */
					
					if (scroll_move_y < 0) scroll_move_y = 0;  /* 스크롤바 시작 지점보다 작으면 시작지점으로 이동 */
					if (scroll_move_y > vertical_scroll_height - scroll_bar_height) scroll_move_y = vertical_scroll_height - scroll_bar_height;  /* 스크롤바 종료 지점 크면 종료지점으로 이동 */
					
					var scroll_move_rate = scroll_move_y / (vertical_scroll_height - scroll_bar_height);  /* 스크롤바가 이동한 거리에 대한 비율 */
					var tasks_move_y = (task_height - vertical_scroll_height) * scroll_move_rate * -1;  /* 스크롤바가 이동한 비율 만큼에 대한 tasks의 이동거리 */
					
					vertical_scroll.select(".vertical_scroll_bar").attr("transform", "translate(0," + scroll_move_y + ")");  /* 스크롤바 이동 */
					tasks.attr("transform", "translate(0," + tasks_move_y + ")");  /* tasks 이동 */
					bars.attr("transform", "translate(0," + tasks_move_y + ")");  /* bars 이동 */
					xLines.attr("transform", "translate(0," + tasks_move_y + ")");  /* xLines 이동 */
				}

				function  dragended(d) { }
			}
			
			
			/* timeScale 만들기 */
			var timeScale = d3.scaleTime()
			.domain([minDate, maxDate])
			.range([margin.left + task_rect_width, gThis.width - margin.right - vertical_scroll.node().getBBox().width]);
			
			
			/* 년 만들기 */
			var category_year_rects = category_year.append("g").attr("class", "category_year_rects")
			.selectAll("rect")
			.data(data_year).enter()
			.append("rect")
			.attr("x", function(d, i) { return timeScale(d.start); })
			.attr("y", category_year_y)
			.attr("width", function(d, i) { return timeScale(d.end) - timeScale(d.start); })
			.attr("height", category_rect_height)
			.style("fill", "#F3F3F3");
			
			var category_year_texts = category_year.append("g").attr("class", "category_year_texts")
			.selectAll("text")
			.data(data_year).enter()
			.append("text")
			.attr("x", function(d, i) { return timeScale(d.start) + (timeScale(d.end) - timeScale(d.start)) / 2; })
			.attr("y", category_year_y + category_text_vertical_center)
			.attr("font-size", gThis.fontSize + "px")
			.attr("font-weight", "bold")
			.attr("text-anchor", "middle")
			.text(function(d, i) { return d.label; });
			
			var category_year_ylines = category_month.append("g").attr("class", "category_year_ylines")
			.selectAll("rect")
			.data(data_year).enter()
			.append("rect")
			.attr("x", function(d, i) { return timeScale(d.start); })
			.attr("y", category_year_y)
			.attr("width", 1)
			.attr("height", category_rect_height)
			.style("fill", "#EAEAEA");
			
			
			/* 월 만들기 */
			var category_month_rects = category_month.append("g").attr("class", "category_month_rects")
			.selectAll("rect")
			.data(data_month).enter()
			.append("rect")
			.attr("x", function(d, i) { return timeScale(d.start); })
			.attr("y", category_month_y)
			.attr("width", function(d, i) { return timeScale(d.end) - timeScale(d.start); })
			.attr("height", category_rect_height)
			.style("fill", "#F3F3F3");
			
			var category_month_texts = category_month.append("g").attr("class", "category_month_texts")
			.selectAll("text")
			.data(data_month).enter()
			.append("text")
			.attr("x", function(d, i) { return timeScale(d.start) + (timeScale(d.end) - timeScale(d.start)) / 2; })
			.attr("y", category_month_y + category_text_vertical_center)
			.attr("font-size", gThis.fontSize + "px")
			.attr("font-weight", "bold")
			.attr("text-anchor", "middle")
			.text(function(d, i) { return d.label; });
			
			var category_month_ylines = category_month.append("g").attr("class", "category_month_ylines")
			.selectAll("rect")
			.data(data_month).enter()
			.append("rect")
			.attr("x", function(d, i) { return timeScale(d.start); })
			.attr("y", category_month_y)
			.attr("width", 1)
			.attr("height", category_rect_height)
			.style("fill", "#EAEAEA");
			
			if (data_year.length > 0 && data_month.length > 0) {
				var category_month_xlines = category_month.append("g").attr("class", "category_month_xlines")
				.append("rect")
				.attr("x", timeScale.range()[0])
				.attr("y", category_month_y)
				.attr("width", timeScale.range()[1] - timeScale.range()[0])
				.attr("height", 1)
				.style("fill", "#EAEAEA");
			}
			
			
			/* 주 만들기 */
			var category_week_rects = category_week.append("g").attr("class", "category_week_rects")
			.selectAll("rect")
			.data(data_week).enter()
			.append("rect")
			.attr("x", function(d, i) { return timeScale(d.start); })
			.attr("y", category_week_y)
			.attr("width", function(d, i) { return timeScale(d.end) - timeScale(d.start); })
			.attr("height", category_rect_height)
			.style("fill", "#F3F3F3");
			
			var category_week_texts = category_week.append("g").attr("class", "category_week_texts")
			.selectAll("text")
			.data(data_week).enter()
			.append("text")
			.attr("x", function(d, i) { return timeScale(d.start) + (timeScale(d.end) - timeScale(d.start)) / 2; })
			.attr("y", category_week_y + category_text_vertical_center)
			.attr("font-size", gThis.fontSize + "px")
			.attr("font-weight", "bold")
			.attr("text-anchor", "middle")
			.text(function(d, i) { return d.label; });
			
			var category_week_ylines = category_week.append("g").attr("class", "category_week_ylines")
			.selectAll("rect")
			.data(data_week).enter()
			.append("rect")
			.attr("x", function(d, i) { return timeScale(d.start); })
			.attr("y", category_week_y)
			.attr("width", 1)
			.attr("height", category_rect_height)
			.style("fill", "#EAEAEA");
			
			if (data_month.length > 0 && data_week.length > 0) {
				var category_week_xlines = category_week.append("g").attr("class", "category_week_xlines")
				.append("rect")
				.attr("x", timeScale.range()[0])
				.attr("y", category_week_y)
				.attr("width", timeScale.range()[1] - timeScale.range()[0])
				.attr("height", 0.5)
				.style("fill", "#EAEAEA");
			}
			
			
			/* 요일 만들기 */
			var category_dayOfWeek_rects = category_dayOfWeek.append("g").attr("class", "category_dayOfWeek_rects")
			.selectAll("rect")
			.data(data_dayOfWeek).enter()
			.append("rect")
			.attr("x", function(d, i) { return timeScale(d.start); })
			.attr("y", category_dayOfWeek_y)
			.attr("width", function(d, i) { return timeScale(d.end) - timeScale(d.start); })
			.attr("height", category_rect_height)
			.style("fill", "#F3F3F3");
			
			var category_dayOfWeek_texts = category_dayOfWeek.append("g").attr("class", "category_dayOfWeek_texts")
			.selectAll("text")
			.data(data_dayOfWeek).enter()
			.append("text")
			.attr("x", function(d, i) { return timeScale(d.start) + (timeScale(d.end) - timeScale(d.start)) / 2; })
			.attr("y", category_dayOfWeek_y + category_text_vertical_center)
			.attr("font-size", gThis.fontSize + "px")
			.attr("font-weight", "bold")
			.attr("text-anchor", "middle")
			.text(function(d, i) { return d.label; });
			
			var category_dayOfWeek_ylines = category_dayOfWeek.append("g").attr("class", "category_dayOfWeek_ylines")
			.selectAll("rect")
			.data(data_dayOfWeek).enter()
			.append("rect")
			.attr("x", function(d, i) { return timeScale(d.start); })
			.attr("y", category_dayOfWeek_y)
			.attr("width", 0.5)
			.attr("height", category_rect_height)
			.style("fill", "#EAEAEA");
			
			
			/* 시간 만들기 */
			var category_time_rects = category_time.append("g").attr("class", "category_time_rects")
			.selectAll("rect")
			.data(data_time).enter()
			.append("rect")
			.attr("x", function(d, i) { return timeScale(d.start); })
			.attr("y", category_time_y)
			.attr("width", function(d, i) { return timeScale(d.end) - timeScale(d.start); })
			.attr("height", category_rect_height)
			.style("fill", "#F3F3F3");
			
			var category_time_texts = category_time.append("g").attr("class", "category_time_texts")
			.selectAll("text")
			.data(data_time).enter()
			.append("text")
			.attr("x", function(d, i) { return timeScale(d.start) + (timeScale(d.end) - timeScale(d.start)) / 2; })
			.attr("y", category_time_y + category_text_vertical_center)
			.attr("font-size", gThis.fontSize + "px")
			.attr("font-weight", "bold")
			.attr("text-anchor", "middle")
			.text(function(d, i) { return d.label; });
			
			var category_time_ylines = category_time.append("g").attr("class", "category_time_ylines")
			.selectAll("rect")
			.data(data_time).enter()
			.append("rect")
			.attr("x", function(d, i) { return timeScale(d.start); })
			.attr("y", category_time_y)
			.attr("width", 0.5)
			.attr("height", category_rect_height)
			.style("fill", "#EAEAEA");
			
			
			/* task category 만들기 */
			gantt.append("rect")
			.attr("x", margin.left)
			.attr("y", margin.top)
			.attr("width", task_rect_width)
			.attr("height", categories.node().getBBox().height)
			.style("fill", "#F3F3F3");
			
			gantt.append("text")
			.attr("x", margin.left + task_rect_padding.left)
			.attr("y", margin.top + (categories.node().getBBox().height / 2) + ((task_text_info.height + (task_text_info.y / 2)) / 2))
			.attr("font-size", gThis.fontSize + "px")
			.attr("font-weight", "bold")
			.text("Task");
			
			
			/* bar percent 만큼 색깔 gradient 만들기 */
			var gradient_percent = chart.select("defs")
			.selectAll(".gradient_percent")
			.data(data).enter()
			.append("linearGradient").attr("class", "gradient_percent")
		 	.attr("id", function(d, i) { return gThis.controlId + "_gradient_percent_" + i; })
		    .attr("x1", "0%")
		    .attr("y1", "100%")
		    .attr("x2", "100%")
		    .attr("y2", "100%")
		    .attr("spreadMethod", "pad");

			gradient_percent.append("stop")
			.attr("offset", "0%")
			.attr("stop-color", color(0))
			.attr("stop-opacity", "1");
			
			gradient_percent.insert("stop")
			.attr("offset", function(d, i) {
				var percent;
				if (isNaN(d.percent)) percent = 100;
				else if (d.percent < 0) percent = 0;
				else if (d.percent > 100) percent = 100;
				else percent = d.percent;
				return percent + "%"
			})
			.attr("stop-color", color(0))
			.attr("stop-opacity", "1");
			
			gradient_percent.insert("stop")
			.attr("offset", function(d, i) {
				var percent;
				if (isNaN(d.percent)) percent = 100;
				else if (d.percent < 0) percent = 0;
				else if (d.percent > 100) percent = 100;
				else percent = d.percent;
				return percent + "%"
			})
			.attr("stop-color", "#FD5E61")
			.attr("stop-opacity", "1");
			
			gradient_percent.insert("stop")
			.attr("offset", "100%")
			.attr("stop-color", "#FD5E61")
			.attr("stop-opacity", "1");
			
			
			/* bar 만들기 */
			bars.selectAll(".bar")
			.data(data).enter()
			.append("rect").attr("class","bar")
			.attr("x", function(d, i) { return timeScale(new Date(d.start_bar_data)); })
			.attr("y", function(d, i) { return task_y + (data_task.indexOf(d.task) * task_rect_height) + (task_rect_height * 0.25); })
			.attr("width", function(d, i) { return timeScale(new Date(d.end_bar_data)) - timeScale(new Date(d.start_bar_data)); })
			.attr("height", (task_rect_height * 0.5))
			.attr("rx", 2)
			.attr("ry", 2)
			.style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient_percent_" + i + ")"; })
			.on("mousemove", function(d, i) {
				var percent;
				if (isNaN(d.percent)) percent = "";
				else if (d.percent < 0) percent = "<br>0% complete";
				else if (d.percent > 100) percent = "<br>100% complete";
				else percent = "<br>" + d.percent + "% complete";
				
				tooltip.select('.tooltipText').html(d.task + "<br>" + d.start + " ~ " + d.end + percent);
				tooltip.select('.tooltipText').style("text-align", "left");
				tooltip_posiction();
			})
			.on("mouseout", function(d, i) { tooltip_mouseout(); });
			
			
			/* xLines 만들기 */
			xLines.selectAll("rect")
			.data(data_task).enter()
			.append("rect").attr("class","task_rect")
			.attr("x", margin.left)
			.attr("y", function(d, i) { return task_y + (task_rect_height * i); })
			.attr("width", gThis.width - margin.left - margin.right - vertical_scroll.node().getBBox().width)
			.attr("height", 0.5)
			.style("fill", "#eaeaea");
			
			
			/* yLines 만들기 */
			var data_yLine;
			
			if (data_time.length > 0) data_yLine = data_time;
			else if (data_dayOfWeek.length > 0) data_yLine = data_dayOfWeek;
			else if (data_week.length > 0) data_yLine = data_week;
			else if (data_month.length > 0) data_yLine = data_month;
			else if (data_year.length > 0) data_yLine = data_year;
			
			yLines.selectAll("rect")
			.data(data_yLine).enter()
			.append("rect").attr("class","task_rect")
			.attr("x", function(d, i) { return timeScale(d.start); })
			.attr("y", task_y)
			.attr("width", 0.5)
			.attr("height", gThis.height - task_y - margin.bottom)
			.style("fill", "#EAEAEA");
			
			
			/* 차트 하단 추가 라인 만들기 */
			gantt.append("rect").attr("class","task_rect111")
			.attr("x", margin.left)
			.attr("y", gThis.height - margin.bottom)
			.attr("width", gThis.width - margin.left - margin.right - vertical_scroll.node().getBBox().width)
			.attr("height", 0.5)
			.style("fill", "#EAEAEA");
			
			
			/* GanttChart의 차트 배경색은 고정이고 우측에 세로스크롤이 생겼을 때의 넓이를 계산하기 위해서 직접 만듦 */
			chart.select(".chartBG")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
			.attr("width", gThis.width - margin.left - margin.right - vertical_scroll.node().getBBox().width)
			.attr("height", gThis.height - margin.top - margin.bottom)
			.style("fill", "#FFFFFF");
			
			
			
			
			/* 카테고리 데이터 만들기 */
			/*
			 * type
			 * 0 = 년 : 3년 초과
			 * 1 = 년,월 : 1년 초과 ~ 3년 이하 (홀수달 2개월 단위)
			 * 2 = 년,월 : 3개월 초과 ~ 1년 이하
			 * 3 = 월,주 : 3개월 이하
			 * 4 = 요일 : 1일 초과 ~ 7일 이하
			 * 5 = 시간 : 1일 이하 (3시간 단위)
			 */
			function make_category_data(type) {
				var year_label;
				var year_start;
				var year_end;
				var startYear = minDate.getFullYear();
				var endYear = maxDate.getFullYear();
				
				/* 년 만들기 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ */
				for (var i = 0; i <= endYear - startYear; i++) {
					year_label = startYear + i;
					
					if (i == 0) {  /* 시작 년 */
						year_start = new Date(startYear + i, minDate.getMonth(), 1, 00, 00, 00);  /* 년, 시작 날짜 월, 1일 */
						if (i == endYear - startYear)  /* 마지막 년 */
							year_end = new Date(startYear + i, maxDate.getMonth(), (new Date(startYear + i, maxDate.getMonth() + 1, 0)).getDate(), 23, 59, 59);  /* 년, 마지막 날짜 월, 마지막 날짜 월의 마지막 일자 */
						else  /* 2년 이상 */
							year_end = new Date(startYear + i, 11, 31, 23, 59, 59);  /* 년, 12월, 31일  */
					} else if (i == endYear - startYear) {  /* 마지막 년 */
						year_start = new Date(startYear + i, 0, 1, 00, 00, 00);  /* 년, 1월, 1일 */
						year_end = new Date(startYear + i, maxDate.getMonth(), (new Date(startYear + i, maxDate.getMonth() + 1, 0)).getDate(), 23, 59, 59);  /* 년, 마지막 날짜 월, 마지막 날짜 월의 마지막 일자 */
					} else {
						year_start = new Date(startYear + i, 0, 1, 00, 00, 00);  /* 년, 1월, 1일*/
						year_end = new Date(startYear + i, 11, 31, 23, 59, 59);  /* 년, 12월, 31일 */
					}
					
					data_year[data_year.length] = {label: year_label, start: year_start, end: year_end};
					
					
					if (type >= 1 && type != 5) {
						
						/* 월 만들기 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ */
						var month_label;
						var month_start;
						var month_end;
						var startMonth;
						var endMonth;
						
						if (i == 0) {  /* 시작 년 */
							startMonth = year_start.getMonth();
							if (i == endYear - startYear)
								endMonth = year_end.getMonth();
							else
								endMonth = 11;
						} else if (i == endYear - startYear) {  /* 마지막 년 */
							startMonth = 0;
							endMonth = year_end.getMonth();
						} else {
							startMonth = 0;
							endMonth = 11;
						}
						
						
						for (var j = startMonth; j <= endMonth; j++) {
							if (type == 1) {
								/* 시작월이 짝수이면 강제로 홀수 단위로 만듦 */
								if (j == startMonth && j % 2 == 1) {
									month_label = gThis.data_month_label[j - 1];
									month_start = new Date(startYear + i, j - 1, 1, 00, 00, 00);
									month_end = new Date(startYear + i, j, new Date(startYear + i, j + 1, 0).getDate(), 23, 59, 59);
									
									data_month[data_month.length] = {label: month_label, start: month_start, end: month_end};
								
								/* 2개월 홀수 단위 (1, 3, 5, 7, 9, 11) */
								} else if (j % 2 == 0) {
									month_label = gThis.data_month_label[j];
									month_start = new Date(startYear + i, j, 1, 00, 00, 00);
									month_end = new Date(startYear + i, j + 1, new Date(startYear + i, j + 2, 0).getDate(), 23, 59, 59);
									
									data_month[data_month.length] = {label: month_label, start: month_start, end: month_end};
								}
								
							} else {
								month_label = gThis.data_month_label[j];
								month_start = new Date(startYear + i, j , 1, 00, 00, 00);
								month_end = new Date(startYear + i, j, new Date(startYear + i, j + 1, 0).getDate(), 23, 59, 59);
								
								data_month[data_month.length] = {label: month_label, start: month_start, end: month_end};
							}
						}
						
						
						if (type >= 3 && type != 5) {
						
							/* 주 만들기 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ */
							var week_label;
							var week_start;
							var week_end;
							var currnetWeek;  /* minDate가 포함된 주의 월요일인 날짜, 이 날짜부터 7씩 더하면서 주를 계산함 */
							var startWeek;
							var endWeek;
							
							/* 0:일, 1:월, 2:화, 3:수, 4:목, 5:금, 6:토 */
							var current_startWeek = new Date(minDate).getDay();
							var current_endWeek = new Date(maxDate).getDay();
							
							/* 월요일부터 시작 할 것이므로 일요일을 7로 만듦 */
							if (current_startWeek == 0) current_startWeek = 7;
							if (current_endWeek == 0) current_endWeek = 7;
							
							/* 계산하기 쉽게 하기 위해 월요일을 0으로 만듦 */
							current_startWeek -= 1;
							current_endWeek -= 1;
							
							currnetWeek = new Date(minDate * 1).setDate(minDate.getDate() - current_startWeek);  /* minDate가 포함된 주의 월요일 */
							startWeek = 0;
							endWeek = (new Date(maxDate * 1).setDate(maxDate.getDate() + (6 - current_endWeek)) - new Date(currnetWeek)) / oneDay;  /* maxDate가 포함된 주의 일요일 - minDate가 포함된 주의 월요일 = 차이 일수 */
							
							var week_label_index = 0;
							for (var j = startWeek; j < endWeek; j+=7) {
								week_label = gThis.data_week_label[week_label_index++];
								week_start = new Date(new Date(currnetWeek).setDate(new Date(currnetWeek).getDate() + j));  /* 해당 주의 월요일 */
								week_end = new Date(new Date(currnetWeek).setDate(new Date(currnetWeek).getDate() + j + 6));  /* 해당 주의 일요일 */
								
								week_start = new Date(week_start.getFullYear(), week_start.getMonth(), week_start.getDate(), 00, 00, 00);
								week_end = new Date(week_end.getFullYear(), week_end.getMonth(), week_end.getDate(), 23, 59, 59);
								
								data_week[data_week.length] = {label: week_label, start: week_start, end: week_end};
								
								if (type == 4 && type != 5) {
									/* 요일 만들기 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ */
									var dayOfWeek_label;
									var dayOfWeek_start;
									var dayOfWeek_end;
									var dayOfWeek_index = 1;  /* data_dayOfWeek_label에 일요일이 맨 앞에 있어서 월요일부터 시작하기 위해 1부터 시작함 */
									
									for (var k = 0; k < 7; k++) {
										var d = new Date(new Date(currnetWeek).setDate(new Date(currnetWeek).getDate() + j + k));
										
										if (dayOfWeek_index == 7) dayOfWeek_index = 0;  /* 7이 되면 일요일이 되므로 0으로 변경 */
										dayOfWeek_label = gThis.data_dayOfWeek_label[dayOfWeek_index++];
										dayOfWeek_start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 00, 00, 00);
										dayOfWeek_end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59);
										
										data_dayOfWeek[data_dayOfWeek.length] = {label: dayOfWeek_label, start: dayOfWeek_start, end: dayOfWeek_end};
									}
								}
							}
						}
					}
				}
				
				if (type == 5) {
					/* 시간 만들기 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ */
					var time_label;
					var time_start;
					var time_end;
					
					for (var j = 0; j < gThis.data_time_label.length; j++) {
						time_label = gThis.data_time_label[j].split(",")[2];
						time_start = new Date(today + " " + gThis.data_time_label[j].split(",")[0]);
						time_end = new Date(today + " " + gThis.data_time_label[j].split(",")[1]);
						data_time[data_time.length] = {label: time_label, start: time_start, end: time_end};
					}
				}
				
				
				/* 시작일자 종료일자 맞추기 */
				if (type == 0) {
					minDate = data_year[0].start;
					maxDate = data_year[data_year.length - 1].end;
					
				} else if (type == 1 || type == 2) {
					data_year[0].start = data_month[0].start;
					data_year[data_year.length - 1].end = data_month[data_month.length - 1].end;
					
					minDate = data_month[0].start;
					maxDate = data_month[data_month.length - 1].end;
					
				} else if (type == 3) {
					data_year = [];
					
					data_month[0].start = data_week[0].start;
					data_month[data_month.length - 1].end = data_week[data_week.length - 1].end;
					
					minDate = data_week[0].start;
					maxDate = data_week[data_week.length - 1].end;
					
				} else if (type == 4) {
					data_year = [];
					data_month = [];
					data_week = [];
					
					minDate = data_dayOfWeek[0].start;
					maxDate = data_dayOfWeek[data_dayOfWeek.length - 1].end;
					
				} else if (type == 5) {
					data_year = [];
					data_month = [];
					data_week = [];
					
					minDate = data_time[0].start;
					maxDate = data_time[data_time.length - 1].end;
				}
			}
			
			
			/*
			 * 개요 : 글자의 y, width, height 정보를 리턴
			 * 파라메터 : 글자크기(필수), 글자(선택)
			 * 리턴 : y, width, height
			 */
			function text_info(text, fontSize, fontWeight) {
				if (text == null || text == "") text = "테스트";
				
				var text_label = label.append("text")
									  .attr("y", 0)
									  .attr("font-size", fontSize + "px")
									  .attr("font-weight", fontWeight)
									  .text(text);
				
				var gettext_label = text_label.node().getBBox();
				
				text_label.remove();
				
				var info = {label: text,
						    y: gettext_label.y, 
						    width: gettext_label.width, 
						    height: gettext_label.height}
				
				return info;
			}
        }
		
        
        function makeCandlestick() {
        	/* 크기 측정용 임시 축 만들기 시작 ------------------------------------------------- */
			bottomScale = d3.scaleTime().domain(d3.extent(data, function(d, i) { return d.date; }));
			leftScale = d3.scaleLinear().domain([ymin, ymax]);
			
			axis.append("g").attr("class", "bottomAxis").call(d3.axisBottom(bottomScale));
			axis.append("g").attr("class", "leftAxis").call(d3.axisLeft(leftScale).ticks(gThis.ytick));
			
			var getbottomAxis = axis.select(".bottomAxis").node().getBBox();
			var getleftAxis = axis.select(".leftAxis").node().getBBox();
			
			axis.select(".bottomAxis").remove();
			axis.select(".leftAxis").remove();
			/* 크기 측정용 임시 축 만들기 종료 ------------------------------------------------- */
			
			/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			margin.top += gettitle.height > 0 ? gettitle.height + 20 : 0;
							
			label.select(".bottomtitle").attr("y", gThis.height - margin.bottom - getbottomtitle.height + (0 - getbottomtitle.y));
			margin.bottom += getbottomtitle.height > 0 ? getbottomtitle.height + 10 : 0;
			
			label.select(".lefttitle").attr("x", - (margin.top + ((gThis.height - margin.top - margin.bottom ) / 2)));
			label.select(".lefttitle").attr("y", margin.left + (0 - getlefttitle.y));
			margin.left += getlefttitle.height > 0 ? getlefttitle.height + 10 : 0;
			margin.left += getleftAxis.width;
			
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			label.select(".bottomtitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
			
			/*
			bottomScale = d3.scaleTime()
						   .range([margin.left, gThis.width - margin.right])
						   .domain(d3.extent(data, function(d, i) { return d.date; }));
			*/
			bottomScale = d3.scaleBand()
		    			   .domain(d3.timeDay
		    					   	 .range(data[0].date, +data[data.length - 1].date + 1)
		    					   	 .filter(function(d, i) { return d.getDay() !== 0 && d.getDay() !== 6; }))  /* 토요일 일요일 제외 */
		    			   .range([margin.left, gThis.width - margin.right])
		    			   .padding(0.4).paddingOuter(0.2);
			bottomScale.type = "scaleBand";
			
			/*
			axis.append("g").attr("class", "bottomAxis")
				.call(d3.axisBottom(bottomScale).ticks(gThis.ytick).tickFormat(d3.timeFormat("%-m/%-d")))
				.attr("transform", "translate(0," + (gThis.height - margin.bottom) + ")")
				.style("font-size", gThis.fontSize + "px");
			*/
			
			axis.append("g").attr("class", "bottomAxis")
			.attr("transform", "translate(0," + (gThis.height - margin.bottom) + ")")
			.call(d3.axisBottom(bottomScale)
					.tickValues(d3.timeMonday
								  .every(gThis.width > 720 ? 1 : 2)
								  .range(data[0].date, data[data.length - 1].date))
								  .tickFormat(d3.timeFormat("%-m/%-d")))
					/*.call(g => g.select(".domain").remove())*/;
		
		
			bottomAxisLF();
		
			
			
			leftScale = d3.scaleLinear()
						   .range([gThis.height - margin.bottom, margin.top])
						   .domain([d3.min(data, function (d) {return d.low;}), d3.max(data, function (d) {return d.high;})]);
			leftScale.type = "scaleLinear";
			
			axis.append("g").attr("class", "leftAxis")
				.call(d3.axisLeft(leftScale).ticks(gThis.ytick))
				.attr("transform", "translate(" + margin.left + ", 0)")
				.style("font-size", gThis.fontSize + "px");
			
			
			makeChartBG();
			
			
			//차트 가로줄 그리기
			if (true || gThis.grid == 1 || gThis.grid == 3) {
				chart.append("g").attr("class","xLines")
				     .selectAll(".xLine")
				     .data(leftScale.ticks(gThis.ytick))
				     .enter().append("rect")
				     .attr("class","xLine")
				     .attr("x", margin.left)
				     .attr("y", function(d, i) { return leftScale(d); })
				     .attr("width", gThis.width - margin.left - margin.right)
				     .attr("height", 1)
				     .style("fill", "#EEEEEE");
			}
			
			//차트 세로줄 그리기
			if (gThis.grid == 2 || gThis.grid == 3) {		
				svg.append("g").attr("class","yLines")
				   .selectAll(".yLine")
				   .data(data)
				   .enter().append("rect")
				   .attr("class","yLine")
				   .attr("x", function(d, i) { return bottomScale(d.date); })
				   .attr("y", margin.top)
				   .attr("width", 1)
				   .attr("height", gThis.height - margin.top - margin.bottom)
				   .style("fill", "#EEEEEE");
			}
			

			var candlestick = chart.selectAll("candlestick")
								   .data(data).enter()
								   .append("g").attr("class","candlestick")
								   .attr("fill", function(d, i) { return d.open > d.close ? "#E11C27" : d.close > d.open ? "#51AC53" : color(3); })
								   .attr("stroke", function(d, i) { return d.open > d.close ? "#E11C27" : d.close > d.open ? "#51AC53" : color(3); })
								   .on("mouseover", onMouseOver)
								   .on("mousemove", onMouseMove)
								   .on("mouseout", onMouseOut);
			
			
			
			/* line으로 그리면 굵기가 굵어 질수록 실제 위치를 벗어나서 rect로 바꿈
			candlestick.append("line")
			.attr("y1", d => leftScale(d.low))
			.attr("y2", d => leftScale(d.high));
			
			candlestick.append("line")
			.attr("y1", d => leftScale(d.open))
			.attr("y2", d => leftScale(d.close))
			.attr("stroke-width", bottomScale.bandwidth());

			candlestick.append("rect")
			.attr("x", function(d, i) { return bottomScale(d.date); })
			.attr("y", function(d, i) { return leftScale(d.high); })
			.attr("height", d => leftScale(d.high) - leftScale(d.low))
			.attr("weight", 2);
			*/
			
			candlestick.append("rect")
					   .attr("x", function(d, i) { return bottomScale(d.date); })
					   .attr("y", function(d, i) { return leftScale(d.high); })
					   .attr("height", function(d, i) { return leftScale(d.low) - leftScale(d.high); })
					   .attr("width", 0.5);
			
			candlestick.append("rect")
					   .attr("x", function(d, i) { return bottomScale(d.date) + 0.25 - (bottomScale.bandwidth() / 2 ); })
					   .attr("y", function(d, i) { return leftScale(d.open > d.close ? d.open : d.close); })
					   .attr("height", function(d, i) { return leftScale(d.open > d.close ? d.close : d.open) - leftScale(d.open > d.close ? d.open : d.close); })
					   .attr("width", bottomScale.bandwidth());

			formatDate = d3.timeFormat("%B %-d, %Y");
			formatValue = d3.format(".2f");
			formatChange = function (y0, y1) {
				var f = d3.format("+.2%");
				return f((y1 - y0) / y0);
			};

//			candlestick.append("title")
//			   		   .text(function(d, i) { return formatDate(d.date) +
//			   			   						  "\nOpen: " + formatValue(d.open) +
//			   			   						  "\nClose: " + formatValue(d.close) + " (" + formatChange(d.open, d.close) + ")" +
//			   			   						  "\nLow: " + formatValue(d.low) +
//			   			   						  "\nHigh:" + formatValue(d.high); });
			
			var tooltip = d3.select("body")
				.append('div')
			    .attr('class', 'tooltip')
			    .style("background", "white")
			    .style("box-shadow", "0 0 5px #999999")
			    .style("border-radius", "5px")
			    .style("color", "#333")
			    .style("font-size", gThis.fontSize + "px")
			    .style("left", "130px")
			    .style("padding", "10px")
			    .style("position", "absolute")
			    .style("text-align", "left")
			    .style("top", "95px")
			    .style("z-index", 10)
			    .style("display", "none")
			    .style("opacity", 0);
	
			tooltip.append('div').attr('class', 'tooltipText');
			
			
			function onMouseOver(d, i) {
				
				tooltip.select('.tooltipText').html("<b>" + formatDate(d.date) + 
	   						"<br>Open : " + formatValue(d.open) +
		   					"<br>Close : " + formatValue(d.close) + " (<span style='color:" + (d.open > d.close ? "#E11C27" : d.close > d.open ? "#51AC53" : color(3)) + ";'>" + formatChange(d.open, d.close) + "</span>)" +
		   					"<br>Low &nbsp : " + formatValue(d.low) +
		   					"<br>High &nbsp: " + formatValue(d.high) + "</b>");
				
				
				
				
				tooltip.style('display', 'block');
				tooltip.style('opacity', 1);
			
			};
			
			function onMouseMove(d, i) {
				tooltip.style('top', (mouse_layerY() + 20) + 'px')
					   .style('left', (mouse_layerX() - 25) + 'px');
			};
			
			function onMouseOut(d, i) {
				tooltip.style('display', 'none');
				tooltip.style('opacity', 0);
			};
        }
        
        
        function makeTest01() {
        	/* 크기 측정용 임시 축 만들기 시작 ------------------------------------------------- */
			bottomScale = d3.scaleBand().domain(data[0].values.map(function(d, i){ return d.xValue; }));
			leftScale = d3.scaleLinear().domain([ymin, ymax]);
			
			axis.append("g").attr("class", "bottomAxis").call(d3.axisBottom(bottomScale));
			axis.append("g").attr("class", "leftAxis").call(d3.axisLeft(leftScale).ticks(gThis.ytick));
			
			var getbottomAxis = axis.select(".bottomAxis").node().getBBox();
			var getleftAxis = axis.select(".leftAxis").node().getBBox();
			
			axis.select(".bottomAxis").remove();
			axis.select(".leftAxis").remove();
			/* 크기 측정용 임시 축 만들기 종료 ------------------------------------------------- */
			
			/* 라벨 위치, margin 값 조정 시작 ----------------------------------------------- */
			label.select(".charttitle").attr("y", margin.top + (0 - gettitle.y));
			margin.top += gettitle.height > 0 ? gettitle.height + 20 : 0;
			margin.top += bar3DLen;
			
			if (getlegend != "" && gThis.legendType == "right") {
				legend.attr("transform", "translate(" + (gThis.width - getlegend.width - margin.right) + ", " + margin.top + ")");
				margin.right += getlegend.width + 10;
			} else if (getlegend != "") {
				legend.attr("transform", "translate(" + ((gThis.width / 2) - (getlegend.width / 2)) + ", " + (gThis.height - margin.bottom - getlegend.height + (0 - getlegend.y)) + ")");
				margin.bottom += getlegend.height + 10;
			}
			
			label.select(".bottomtitle").attr("y", gThis.height - margin.bottom - getbottomtitle.height + (0 - getbottomtitle.y));
			margin.bottom += getbottomtitle.height > 0 ? getbottomtitle.height + 10 : 0;
			
			label.select(".lefttitle").attr("x", - (margin.top + ((gThis.height - margin.top - margin.bottom ) / 2)));
			label.select(".lefttitle").attr("y", margin.left + (0 - getlefttitle.y));
			margin.left += getlefttitle.height > 0 ? getlefttitle.height + 10 : 0;
			margin.left += getleftAxis.width;
			
			if (trendwidth > 0) margin.right += trendwidth;
			
			label.select(".charttitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			label.select(".bottomtitle").attr("x", margin.left + ((gThis.width - margin.left - margin.right) / 2));
			/* 라벨 위치, margin 값 조정 종료 ----------------------------------------------- */
			
			
			bottomScale = d3.scaleBand()
						   .range([margin.left, gThis.width - margin.right])
						   .domain(data[0].values.map(function(d, i){ return d.xValue; }))
						   .padding(0.4).paddingOuter(0.2);
			
			bottomScale.type = "scaleBand";
			
			axis.append("g").attr("class", "bottomAxis")
				.call(d3.axisBottom(bottomScale))
				.attr("transform", "translate(0," + (gThis.height - margin.bottom) + ")")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("bottom");
			
			bottomAxisLF();
			
			
			leftScale = d3.scaleLinear()
						   .range([gThis.height - margin.bottom, margin.top])
						   .domain([ymin, ymax]);
			leftScale.type = "scaleLinear";
			
			axis.append("g").attr("class", "leftAxis")
				.call(d3.axisLeft(leftScale).ticks(gThis.ytick))
				.attr("transform", "translate(" + margin.left + ", 0)")
				.style("font-size", gThis.fontSize + "px");
			
			findTicks("left");
			
			makeChartBG();
			
			
			//차트 가로줄 그리기
			if (true || gThis.grid == 1 || gThis.grid == 3) {
				chart.append("g").attr("class","xLines")
					 .selectAll(".xLine")
					 .data(leftScale.ticks(gThis.ytick))
					 .enter().append("rect")
					 .attr("class","xLine")
					 .attr("x", margin.left)
					 .attr("y", function(d, i) { return leftScale(d); })
					 .attr("width", gThis.width - margin.left - margin.right)
					 .attr("height", 1)
					 .style("fill", "#EEEEEE");
			}
			
			//차트 세로줄 그리기
			if (gThis.grid == 2 || gThis.grid == 3) {		
				chart.append("g").attr("class","yLines")
				     .selectAll(".yLine")
				     .data(bottomScale.domain())
				     .enter().append("rect")
				     .attr("class","yLine")
				     .attr("x", function(d, i) { return bottomScale(d) + (bottomScale.bandwidth() / 2) ; })
				     .attr("y", margin.top)
				     .attr("width", 1)
				     .attr("height", gThis.height - margin.top - margin.bottom)
				     .style("fill", "#EEEEEE");
			}		

			if (ymin < 0) {
				if (gThis.chart3d == "true") {
					chart.append("rect").attr("class", "zero-plane")
					.attr("width", bottomScale.range()[1] - bottomScale.range()[0])
					.attr("height", bar3DLen)
					.attr("transform", function(d, i) { return "translate (" + (bottomScale.range()[0] + bar3DLen) + "," + (leftScale(yStart) - bar3DLen) + ") skewX(-45)"; })
					.style("fill", "#EEEEEE")
					.style("opacity", 1);
					
				} else {
					chart.append("rect").attr("class", "zero-plane")
					.attr("x", bottomScale.range()[0])
					.attr("y", leftScale(yStart) - 1)
					.attr("width", bottomScale.range()[1] - bottomScale.range()[0])
					.attr("height", 3)
					.style("fill", "#EEEEEE");
				}
			}
			
			
			var rects = chart.append("g").attr("class", "rects");
			
		    for (var i = 0; i < data[0].values.length; i++) {
			    for (var j = 0; j < data.length; j++) {
			    	var imsidata = new Array();
			    	imsidata.push(data[j].values[i]);
			      
				    //top
				    rects.append("rect")
				    .data(imsidata)
					.attr("width", bottomScale.bandwidth() / data.length)
					.attr("height", bar3DLen)
					.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + bar3DLen) + "," + (leftScale(yStart) - bar3DLen) + ") skewX(-45)"; })
					.style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
					.on("mousemove", onMouseMove)
					.on("mouseout", onMouseOut)
					.transition()
					.delay(delay)
					.duration(duration)
					.attr("height", bar3DLen)
					.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + bar3DLen) + "," + (leftScale(d.yValue < yStart ? yStart : d.yValue) - bar3DLen) + ") skewX(-45)"; })
					;
			        
  					//right 
  					rects.append("rect")
  					.data(imsidata)
					.attr("width", bar3DLen)
					.attr("height", 0)
					.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + (bottomScale.bandwidth() / data.length)) + "," + leftScale(yStart) + ") skewY(-45)"; })
					.style("fill", function(d, i) { return d3.rgb(color(d.colorIndex)).darker(0.5); })
					.on("mousemove", onMouseMove)
					.on("mouseout", onMouseOut)
					.transition()
					.delay(delay)
					.duration(duration)
					.attr("height", function(d, i) { return d.yValue > yStart ? leftScale(yStart) - leftScale(d.yValue) : leftScale(d.yValue) - leftScale(yStart); })
					.attr("transform", function(d, i) { return "translate (" + (bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex) + (bottomScale.bandwidth() / data.length)) + "," + (leftScale(d.yValue < yStart ? yStart : d.yValue)) + ") skewY(-45)"; })
				    ;
  					
				    //body
				    rects.append("rect")
				    .data(imsidata)
  					.attr("x", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / data.length * d.dataIndex); })
					.attr("y", leftScale(yStart))
					.attr("width", bottomScale.bandwidth() / data.length)
					.attr("height", 0)
					.style("fill", function(d, i) { return "url(#" + gThis.controlId + "_gradient" + d.colorIndex + ")"; })
					.on("mousemove", onMouseMove)
					.on("mouseout", onMouseOut)
					.transition()
					.delay(delay)
					.duration(duration)
					.attr("y", function(d, i) { return leftScale(d.yValue < yStart ? yStart : d.yValue); })
					.attr("height", function(d, i) { return d.yValue > yStart ? leftScale(yStart) - leftScale(d.yValue) : leftScale(d.yValue) - leftScale(yStart); })
  					;
			    }
			}
			
		    function onMouseMove(d, i) {
		    	var p = d3.select(this.parentNode);
		    	var column3d = 3;  /* column, bar를 3d로 만들면 node가 1개에서 3개가 되므로 */
		    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 1) + ")").style('opacity', 0.7);
		    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 2) + ")").style('opacity', 0.7);
		    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 3) + ")").style('opacity', 0.7);
		    	
		        tooltip_mousemove();
		    };
		    
		    function onMouseOut(d, i) {
		    	var p = d3.select(this.parentNode);
		    	var column3d = 3;  /* column, bar를 3d로 만들면 node가 1개에서 3개가 되므로 */
		    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 1) + ")").style('opacity', 1);
		    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 2) + ")").style('opacity', 1);
		    	p.selectAll("rect").filter(":nth-child(" + (d.index * data.length * column3d + (d.dataIndex * data.length) + 3) + ")").style('opacity', 1);
		    	
		    	tooltip_mouseout();
		    };
			
			
			svg.on("mousemove", function(d, i) { tooltipLine_mousemove("area"); tooltip_mousemove(); })
			   .on("mouseout", function(d, i) { tooltipLine_mouseout(); tooltip_mouseout(); });
		
			var line = d3.line()
						 .x(function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2)/*bottomScale(d.xValue)*/; })
						 .y(function(d, i) { return leftScale(d.yValueT); })
						 .curve(curveArray[gThis.curveType]);

			var lines = chart.append('g').attr('class', 'lines');

			lines.append('g').attr('class', 'line-group')
				 .selectAll(".path")
				 .data(data).enter()
			     .append('path')
			     .attr('class', 'line')  
			     .attr('d', function(d, i) { return line(d.values); })
			     .style('stroke', function(d, i) { return color(d.colorIndex); })
			     .style('stroke-width', lineStroke)
			     .style('opacity', lineOpacity)
			     .style('fill', 'none')
			     .on("mouseover", function(d, i) {
			    	 lines.selectAll('.line').style('opacity', otherLinesOpacityHover);
			    	 lines.selectAll('.circle').style('opacity', circleOpacityOnLineHover);
			    	 
			    	 lines.selectAll(".line").filter(":nth-child(" + (i + 1) + ")")
			    	   .style('opacity', lineOpacityHover)
			    	   .style("stroke-width", lineStrokeHover)
			    	   .style("cursor", "pointer"); 
			    })
			    .on("mouseout", function(d, i) {
			    	lines.selectAll(".line").style('opacity', lineOpacity);
			    	lines.selectAll('.circle').style('opacity', circleOpacity);
			    	lines.selectAll(".line").filter(":nth-child(" + (i + 1) + ")").style("stroke-width", lineStroke).style("cursor", "none");
			    });
				

			/* Add circles in the line */
			lines.selectAll("circle-group")
				 .data(data).enter()
				 .append("g")
				 .attr("class", "circle-group")
				 .style("fill", "#ffffff")
				 .style("stroke", function(d, i) { return color(d.colorIndex); })
				 .selectAll("circle")
				 .data(function(d, i) { return d.values; }).enter()
				 .append("g")
				 .attr("class", "circle")  
				 .on("mouseover", function(d, i) {
					 d3.select(this)     
					   .style("cursor", "pointer")
					   .append("text")
					   .attr("class", "text")
					   .attr("text-anchor", "middle")
					   .text(function(d, i) { return d.yValue; })
					   .attr("x", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2)/*bottomScale(d.xValue)*/; })
					   .attr("y", function(d, i) { return leftScale(d.yValueT) - 10; });
				 })
				 .on("mouseout", function(d, i) {
					 d3.select(this)
					   .style("cursor", "none")  
					   .transition()
					   .duration(lineDuration)
					   .selectAll(".text").remove();
				 })
				 .append("circle")
				 .attr("cx", function(d, i) { return bottomScale(d.xValue) + (bottomScale.bandwidth() / 2)/*bottomScale(d.xValue)*/; })
				 .attr("cy", function(d, i) { return leftScale(d.yValueT); })
				 .attr("r", circleRadius)
				 .style('opacity', gThis.animateFlag == true ? 0 : circleOpacity)
				 .on("mouseover", function(d, i) {
					 d3.select(this)
					   .transition()
					   .duration(lineDuration)
					   .attr("r", circleRadiusHover);
				 })
				 .on("mouseout", function(d, i) {
					 d3.select(this) 
					   .transition()
					   .duration(lineDuration)
					   .attr("r", circleRadius);  
				 });
			
			if (gThis.animateFlag == true) {
				lines.selectAll(".line-group")
				.selectAll(".line")
				.attr("stroke-dasharray", function(d, i) { totalLength = d3.select(this).node().getTotalLength(); return totalLength + " " + totalLength; })
				.attr("stroke-dashoffset", function(d, i) { return d3.select(this).node().getTotalLength();})
				.transition()
				.delay(delay)
				.duration(duration)
				.ease(d3.easeLinear)
				.attr("stroke-dashoffset", 0);
				
				lines.selectAll(".circle-group")
				.selectAll(".circle").select("circle")
				.transition()
				.delay(delay + (duration))
				.style("opacity", 1);
			}
        }
        
        
        
        
        
        
        function findTicks(position) {
			
			if (position == "left") {
				if (leftScale.type == "scaleLinear") {
					while (true) {
						if (gThis.ytick <= 1) break;
						
						var ticks = axis.select('.leftAxis').selectAll('.tick');
						var ticksLength = ticks._groups[0].length;
						
						if (ticksLength <= 1) break;
						
						var tick1 = ticks.filter(":nth-child(" + (ticksLength) + ")");
						var y1 = getTransform(tick1, 1);
						var height1 = tick1.node().getBBox().height;
						
						var tick2 = ticks.filter(":nth-child(" + (ticksLength + 1) + ")");  /* + 1 하는 이유는 ticks 안에 있는 첫 번째 노드가 domain이라는 클래스로 된 선이 존재해서 */
						var y2 = getTransform(tick2, 1);
						var height2 = tick2.node().getBBox().height;
						
						/* tick끼리 붙으면 ticks에 tick 값을 조정해서 다시 그림 */
						if (y1 <= y2 + height2) {
							if (gThis.gallery == 21) {
								gThis.ytick -= 1;  /* 0, 1, 2, 4, 5 */
								if (gThis.ytick == 3) gThis.ytick -= 1;  /* ytick이 3이면 '0, 33.33, 66.66, 100' 이렇게 값이 애매해 져서 3은 제외 */
								
								tickValue = ymax / gThis.ytick;
								tickValues = [];
								for (var i = 0; i <= gThis.ytick; i++) {
									tickValues[i] = tickValue * i;
								}
								
								axis.select(".leftAxis").call(d3.axisLeft(leftScale).tickValues(tickValues));
								
							} else {
								gThis.ytick -= 2;  /* 0, 1, 3, 5 */
								axis.select(".leftAxis").call(d3.axisLeft(leftScale).ticks(gThis.ytick));
							}
							
						} else {
							break;
						}
					}
					
				} else if (leftScale.type == "scaleBand") {
					while (true) {
						var ticks = axis.select('.leftAxis').selectAll('.tick');
						var ticksLength = ticks._groups[0].length;
						var exitFlag = true;
						
						if (ticksLength <= 2) break;
						
						/* + 1 하는 이유는 ticks 안에 있는 첫 번째 노드가 domain이라는 클래스로 된 선이 존재해서 */
						for (var i = ticksLength + 1; i >= 3; i--) {
							var tick1 = ticks.filter(":nth-child(" + (i - 1) + ")");
							var y1 = getTransform(tick1, 1);
							var height1 = tick1.node().getBBox().height;
							
							var tick2 = ticks.filter(":nth-child(" + (i) + ")");
							var y2 = getTransform(tick2, 1);
							var height2 = tick2.node().getBBox().height;
							
							/* tick끼리 붙으면 붙은 tick 제거 */
							if (y1 <= y2 + height2) {
								exitFlag = false;
								ticks.filter(":nth-child(" + (i - 1) + ")").remove();
								break;
							}
						}
						
						if (exitFlag == true) break;
					}
				}
				
			} else if (position == "right") {
				if (rightScale.type == "scaleLinear") {
					while (true) {
						if (gThis.ytick <= 1) break;
						
						var ticks = axis.select('.rightAxis').selectAll('.tick');
						var ticksLength = ticks._groups[0].length;
						
						if (ticksLength <= 1) break;
						
						var tick1 = ticks.filter(":nth-child(" + (ticksLength) + ")");
						var y1 = getTransform(tick1, 1);
						var height1 = tick1.node().getBBox().height;
						
						var tick2 = ticks.filter(":nth-child(" + (ticksLength + 1) + ")");  /* + 1 하는 이유는 ticks 안에 있는 첫 번째 노드가 domain이라는 클래스로 된 선이 존재해서 */
						var y2 = getTransform(tick2, 1);
						var height2 = tick2.node().getBBox().height;
						
						/* tick끼리 붙으면 ticks에 tick 값을 조정해서 다시 그림 */
						if (y1 <= y2 + height2) {
							if (gThis.gallery == 21) {
								gThis.ytick -= 1;  /* 0, 1, 2, 4, 5 */
								if (gThis.ytick == 3) gThis.ytick -= 1;  /* ytick이 3이면 '0, 33.33, 66.66, 100' 이렇게 값이 애매해 져서 3은 제외 */
								
								tickValue = ymax / gThis.ytick;
								tickValues = [];
								for (var i = 0; i <= gThis.ytick; i++) {
									tickValues[i] = tickValue * i;
								}
								
								axis.select(".rightAxis").call(d3.axisRight(rightScale).tickValues(tickValues));
								
							} else {
								gThis.ytick -= 2;  /* 0, 1, 3, 5 */
								axis.select(".rightAxis").call(d3.axisRight(rightScale).ticks(gThis.ytick));
							}
							
						} else {
							break;
						}
					}
					
				} else if (leftScale.type == "scaleBand") {
					while (true) {
						var ticks = axis.select('.rightAxis').selectAll('.tick');
						var ticksLength = ticks._groups[0].length;
						var exitFlag = true;
						
						if (ticksLength <= 2) break;
						
						/* + 1 하는 이유는 ticks 안에 있는 첫 번째 노드가 domain이라는 클래스로 된 선이 존재해서 */
						for (var i = ticksLength + 1; i >= 3; i--) {
							var tick1 = ticks.filter(":nth-child(" + (i - 1) + ")");
							var y1 = getTransform(tick1, 1);
							var height1 = tick1.node().getBBox().height;
							
							var tick2 = ticks.filter(":nth-child(" + (i) + ")");
							var y2 = getTransform(tick2, 1);
							var height2 = tick2.node().getBBox().height;
							
							/* tick끼리 붙으면 ticks에 tick 값을 조정해서 다시 그림 */
							if (y1 <= y2 + height2) {
								exitFlag = false;
								ticks.filter(":nth-child(" + (i - 1) + ")").remove();
								break;
							}
						}
						
						if (exitFlag == true) break;
					}
				}
			
			} else if (position = "bottom") {
				var spacePexel = 3;  /* tick 끼리 딱 붙으면 이상하니까 여유 px을 줌 */
				
				if (bottomScale.type == "scaleLinear") {
					while (true) {
						if (gThis.xtick <= 1) break;
						
						var ticks = axis.select('.bottomAxis').selectAll('.tick');
						var ticksLength = ticks._groups[0].length;
						
						if (ticksLength <= 1) break;
						
						/* 제일 마지막에서 바로 앞에 tick */
						var tick1 = ticks.filter(":nth-child(" + (ticksLength) + ")");
						var x1 = getTransform(tick1, 0);
						var width1 = tick1.node().getBBox().width;
						
						/* 제일 마지막 tick */
						var tick2 = ticks.filter(":nth-child(" + (ticksLength + 1) + ")");  /* + 1 하는 이유는 ticks 안에 있는 첫 번째 노드가 domain이라는 클래스로 된 선이 존재해서 */
						var x2 = getTransform(tick2, 0);
						var width2 = tick2.node().getBBox().width;
						
						
						/* tick끼리 붙으면 ticks에 tick 값을 조정해서 다시 그림 */
						if (x1 + width1 + spacePexel >= x2) {
							gThis.xtick -= 2;  /* 0, 1, 3, 5 */
							axis.select(".bottomAxis").call(d3.axisBottom(bottomScale).ticks(gThis.xtick));
						} else {
							break;
						}
						
					}
					
				} else if (bottomScale.type == "scaleBand") {
					if (gThis.gallery != 9 && gThis.gallery != 16 && gThis.gallery != 17) return;
					
					while (true) {
						var ticks = axis.select('.bottomAxis').selectAll('.tick');
						var ticksLength = ticks._groups[0].length;
						var exitFlag = true;
						
						if (ticksLength <= 2) break;
						
						/* + 1 하는 이유는 ticks 안에 있는 첫 번째 노드가 domain이라는 클래스로 된 선이 존재해서 */
						for (var i = ticksLength + 1; i >= 3; i--) {
							var tick1 = ticks.filter(":nth-child(" + (i - 1) + ")");
							var x1 = getTransform(tick1, 0);
							var width1 = tick1.node().getBBox().width;
							
							var tick2 = ticks.filter(":nth-child(" + (i) + ")");
							var x2 = getTransform(tick2, 0);
							var width2 = tick2.node().getBBox().width;
							
							/* tick끼리 붙으면 붙은 tick 제거 */
							if (x1 + width1 + spacePexel >= x2) {
								exitFlag = false;
								ticks.filter(":nth-child(" + (i - 1) + ")").remove();
								break;
							}
						}
						
						if (exitFlag == true) break;
					}
				}
			}
        }
        
        
        
        
        
	};
	



/*
	https://developers.google.com/chart/
*/

/*
	1  Line : O
	2  Column : O
	3  Curve Line : O
	4  Scatter : O
	5  Pie : O
	6  Area : O
	7  Combo : O
	8  Step : O
	11 Radea : X
	13 Doughnut : O
	14 Pyramid : X
	15 Bubble : O
	17 Candlestick : O
	19 Curve Area : X
	20 Bar : O
	21 Pareto : O
	22 Gantt : O
*/
	

//	document.write("<script src='https://www.gstatic.com/charts/loader.js'></script>");
	

	
	function googleChart(controlId, controlName, tagObject) {
		if (tagObject != null) {
		    // 상속선언부
		    this.base = ControlBase;              			//부모클래스 지정
		    this.base(controlId, controlName, tagObject);   //부모클래스 생성자호출
		    
		    if (tagObject != undefined){
		        tagObject.setAttribute("tabIndex", "-1");
		        charts[charts.length] = this;
		    }
		    
		    this.charttitle = tagObject.getAttribute("charttitle");
		    this.gallery = (!tagObject.getAttribute("gallery") ? "2" : tagObject.getAttribute("gallery"));
		    this.stacked = tagObject.getAttribute("stacked");     //1: stack, 2: stack percent
		    this.chart3d = tagObject.getAttribute("chart3d");
		    this.backcolor = (!tagObject.getAttribute("backcolor") ? "#FFFFFF" : tagObject.getAttribute("backcolor"));
		    this.fillcolor = (!tagObject.getAttribute("fillcolor") ? "#FFFFFF" : tagObject.getAttribute("fillcolor"));
		    this.bottomtitle = tagObject.getAttribute("bottomtitle"); 
		    this.lefttitle = tagObject.getAttribute("lefttitle");
		    this.seriescode2 = tagObject.getAttribute("seriescode2");
		    this.lefttitle2 = tagObject.getAttribute("lefttitle2");
		    this.data = "";
		    
		} else {
			this.controlId = controlId;
			this.controlName = controlName;
		    this.charttitle;
		    this.gallery;
		    this.stacked;     //1: stack, 2: stack percent
		    this.chart3d;
		    this.backcolor = "#FFFFFF";
			this.fillcolor = "#FFFFFF";
		    this.bottomtitle; 
		    this.lefttitle;
		    this.seriescode2;
		    this.lefttitle2;
		    this.data = "";
		}
		
		this.fontSize = 11;
	};
	
	
	
	googleChart.prototype.show = function() {
		
		var gThis = this;
		gThis.drawChartFlag = false;  /* true : resize함수에서 차트의 크기가 바뀌면 다시 그리기,  false : 차트 안 그리기 */
		
		/* 
		 * gThis.left, gThis.top, gThis.width, gThis.height를 
		 * 차트 만들 때 실제로 사용하지는 않고 resize에 차트 다시 그릴 때
		 * 차트 사이즈가 바뀌는지 확인하는 용도로 사용
		 */
		if (this.tagObject != null) {
			gThis.left = getComputedStyle(gThis.tagObject).left.split("px")[0] * 1;
			gThis.top = getComputedStyle(gThis.tagObject).top.split("px")[0] * 1;
			gThis.width = getComputedStyle(gThis.tagObject).width.split("px")[0] * 1;
			gThis.height = getComputedStyle(gThis.tagObject).height.split("px")[0] * 1;
		} else {
			gThis.left = document.getElementsByName(gThis.controlName)[0].offsetLeft * 1;
			gThis.top = document.getElementsByName(gThis.controlName)[0].offsetTop * 1;
			gThis.width = (document.getElementsByName(gThis.controlName)[0].offsetWidth * 1) - 3;  /* border넓이 뺌 */
			gThis.height = (document.getElementsByName(gThis.controlName)[0].offsetHeight * 1) - 3;  /* border넓이 뺌 */
		}
		
		/* 차트의 크기가 바뀌면 다시 그리기 */
		setInterval(resize, 200);
		
		/* 숫자가 아니면 종료 */
		if (isNaN(gThis.left) || isNaN(gThis.top) || isNaN(gThis.width) || isNaN(gThis.height)) {
			gThis.drawChartFlag = true;
			return;
		}
		
		
		/* 공통옵션 */
		var options = {
				title: gThis.charttitle,
//				vAxis: {title: gThis.lefttitle},
				vAxes: {
						0: { title: gThis.lefttitle },
						1: { title: gThis.lefttitle2 }
				},
				hAxis: {title: gThis.bottomtitle},
				backgroundColor: gThis.backcolor,
				chartArea: {backgroundColor: gThis.fillcolor},
				fontSize: gThis.fontSize,
				isStacked: (gThis.stacked == '1' ? true : (gThis.stacked == '2' ? 'percent' : false)),
				titleTextStyle: {color: 'black', fontName: '', fontSize: (gThis.fontSize + 4), bold: true, italic: false},
//				세부적으로 font설정 하는 방법
//				titleTextStyle: {color: 'black', fontName: '', fontSize: 20, bold: false, italic: false},
//				vAxis: { textStyle: {color: 'black', fontName: '', fontSize: 20, bold: false, italic: false},
//					titleTextStyle: {color: 'black', fontName: '', fontSize: 20, bold: false, italic: false} },
//				hAxis: { textStyle: {color: 'black', fontName: '', fontSize: 20, bold: false, italic: false},
//					titleTextStyle: {color: 'black', fontName: '', fontSize: 20, bold: false, italic: false} },
//				legend: { textStyle: {color: 'black', fontName: '', fontSize: 20, bold: false, italic: false} },
//				tooltip: { textStyle: {color: 'black', fontName: '', fontSize: 20, bold: false, italic: false}},
		};
		
		
		if (gThis.gallery == "1" || gThis.gallery == "3") LineChart();
		else if (gThis.gallery == "2") ColumnChart();
		else if (gThis.gallery == "4") ScatterChart();
		else if (gThis.gallery == "5") PieChart();
		else if (gThis.gallery == "6") AreaChart();
		else if (gThis.gallery == "7") ComboChart();
		else if (gThis.gallery == "8") StepLineChart();
		else if (gThis.gallery == "13") PieChart(true);
		else if (gThis.gallery == "15") BubbleChart();
		else if (gThis.gallery == "17") CandlestickChart();
		else if (gThis.gallery == "20") BarChart();
		else if (gThis.gallery == "21") ParetoChart();
		else if (gThis.gallery == "22") GanttChart();
		
		
		
		
		/* 객체 합치기 */
		function objectMerge(obj1, obj2) {
			for (var p in obj2) {
				try {
					// Property in destination object set; update its value.
					if ( obj2[p].constructor==Object ) {
						obj1[p] = MergeRecursive(obj1[p], obj2[p]);
					} else {
						obj1[p] = obj2[p];
					}
				} catch(e) {
					// Property in destination object not set; create it and set its value.
					obj1[p] = obj2[p];
				}
			}

			return obj1;
		}
		
		
		/* 이벤트 시작 ----------------------------------------------------------------------------------------------------- */
		/* 이벤트 시작 ----------------------------------------------------------------------------------------------------- */
		
		/* 차트의 크기가 바뀌면 다시 그리기 */
		function resize() {
			if (gThis.drawChartFlag == true) {
				var resizeleft = "";
				var resizetop = "";
				var resizewidth = "";
				var resizeheight = "";
				
				if (gThis.tagObject != null) {
					resizeleft = getComputedStyle(gThis.tagObject).left.split("px")[0] * 1;
					resizetop = getComputedStyle(gThis.tagObject).top.split("px")[0] * 1;
					resizewidth = getComputedStyle(gThis.tagObject).width.split("px")[0] * 1;
					resizeheight = getComputedStyle(gThis.tagObject).height.split("px")[0] * 1;
				} else {
					resizeleft = document.getElementsByName(gThis.controlName)[0].offsetLeft * 1;
					resizetop = document.getElementsByName(gThis.controlName)[0].offsetTop * 1;
					resizewidth = (document.getElementsByName(gThis.controlName)[0].offsetWidth * 1) - 3;  /* border넓이 뺌 */
					resizeheight = (document.getElementsByName(gThis.controlName)[0].offsetHeight * 1) - 3;  /* border넓이 뺌 */
				}
				
				/* 현재 값이 NaN이 아니면서 기존 값과 서로 다르면 차트를 다시 만든다.*/
				if (!isNaN(resizeleft) && 
					!isNaN(resizetop) && 
					!isNaN(resizewidth) && 
					!isNaN(resizeheight)) {
					
					if (gThis.left != resizeleft || 
						gThis.top != resizetop || 
						gThis.width != resizewidth || 
						gThis.height != resizeheight)
						
						gThis.show(false);
				}
			}
		}
		
		/* 차트 그린 후 이벤트 */
		function afterDraw(){
			
			/* ParetoChart의 우측 축을 그리다보니 lefttitle이 우측 축에도 생겨서 강제로 지움 */
			if (gThis.gallery == "21" && gThis.lefttitle != null) {
				var textNode = document.getElementById(gThis.controlId).getElementsByTagName('div')[0].getElementsByTagName('div')[0].getElementsByTagName('div')[0].getElementsByTagName('svg')[0].getElementsByTagName('text')
				textNode[textNode.length - 1].remove();
			}
			
			titleAlignCenter();
			
			gThis.drawChartFlag = true;
			
			
			/* title 가운데 정렬 : 구글 차트의 title 위치를 가운데로 하는 옮기는 기능이 없어서 직접 움직임 */
			function titleAlignCenter() {
				if (gThis.charttitle == null || gThis.charttitle.length == 0) return;
				if (gThis.gallery == "22") return;  /* Gantt차트는 차트 제목이 없음 */
					
				var getTitleText = document.getElementById(gThis.controlId).getElementsByTagName('div')[0].getElementsByTagName('div')[0].getElementsByTagName('div')[0].getElementsByTagName('svg')[0].getElementsByTagName('g')[0].getElementsByTagName('text')[0];
				var getTitleRect = document.getElementById(gThis.controlId).getElementsByTagName('div')[0].getElementsByTagName('div')[0].getElementsByTagName('div')[0].getElementsByTagName('svg')[0].getElementsByTagName('g')[0].getElementsByTagName('rect')[0];
				var x = getTitleRect.getAttribute('x') * 1;
				var width = getTitleRect.getAttribute('width') * 1;
				getTitleText.setAttribute('x', x + (width / 2));
				getTitleText.setAttribute('text-anchor', 'middle');
			}
		}
		/* 이벤트 종료 ----------------------------------------------------------------------------------------------------- */
		/* 이벤트 종료 ----------------------------------------------------------------------------------------------------- */
		
		
		
		/* 차트 만들기 시작 -------------------------------------------------------------------------------------------------- */
		/* 차트 만들기 시작 -------------------------------------------------------------------------------------------------- */
		function LineChart() {
			google.charts.load('current', {'packages':['corechart']});
			google.charts.setOnLoadCallback(drawChart);
			
			function drawChart() {
				var jsonData = createData();
				var data = google.visualization.arrayToDataTable(jsonData);
				
				var add_options = {
						legend: {position: ((jsonData[0].length - 1) == 1 ? 'none' : null)},
						curveType: (gThis.gallery == 3 ? 'function' : null),
					};
				options = objectMerge(options, add_options);
				
				var chart = new google.visualization.LineChart(document.getElementById(gThis.controlId));
				google.visualization.events.addListener(chart, 'ready', afterDraw);
				chart.draw(data, options);
			}
		}
		
		
		function ColumnChart() {
			google.charts.load('current', {'packages':['corechart']});
			google.charts.setOnLoadCallback(drawChart);
			
			function drawChart() {
				var jsonData = createData();
				var data = google.visualization.arrayToDataTable(jsonData);
				
				var add_options = {
						legend: {position: ((jsonData[0].length - 1) == 1 ? 'none' : null)},
					};
				options = objectMerge(options, add_options);
				
				var chart = new google.visualization.ColumnChart(document.getElementById(gThis.controlId));
				google.visualization.events.addListener(chart, 'ready', afterDraw);
				chart.draw(data, options);
			}
		}
		
		function ScatterChart() {
			google.charts.load('current', {'packages':['corechart']});
			google.charts.setOnLoadCallback(drawChart);
			
			function drawChart() {
				var jsonData = createScatterData();
				var data = google.visualization.arrayToDataTable(jsonData);
				
				var add_options = {
						legend: {position: ((jsonData[0].length - 1) == 1 ? 'none' : null)},
						/* pointSize: 30, */ /* point는 커지는데 legend에 있는 point는 안 커짐 */
				        series: {
				        	0: { pointShape: 'circle' },
				            1: { pointShape: 'triangle' },
				            2: { pointShape: 'square' },
				            3: { pointShape: 'diamond' },
				            4: { pointShape: 'star' },
				            5: { pointShape: 'polygon' },
				            6: { pointShape: 'circle' },
				            7: { pointShape: 'triangle' },
				            8: { pointShape: 'square' },
				            9: { pointShape: 'diamond' },
				            10: { pointShape: 'star' },
				            11: { pointShape: 'polygon' },
				            12: { pointShape: 'circle' },
				            13: { pointShape: 'triangle' },
				            14: { pointShape: 'square' },
				            15: { pointShape: 'diamond' },
				            16: { pointShape: 'star' },
				            17: { pointShape: 'polygon' },
				            18: { pointShape: 'circle' },
				            19: { pointShape: 'triangle' },
				            20: { pointShape: 'square' },
				            21: { pointShape: 'diamond' },
				            22: { pointShape: 'star' },
				            23: { pointShape: 'polygon' }
				        }  /* 모양이 6개만 있음 : 'circle', 'triangle', 'square', 'diamond', 'star', 'polygon'*/
					};
				options = objectMerge(options, add_options);
				
				var chart = new google.visualization.ScatterChart(document.getElementById(gThis.controlId));
				google.visualization.events.addListener(chart, 'ready', afterDraw);
				chart.draw(data, options);
			}
		}
		
		
		function PieChart(donut) {
			google.charts.load('current', {'packages':['corechart']});
			google.charts.setOnLoadCallback(drawChart);
			
			function drawChart() {
				var jsonData = createData();
				var data = google.visualization.arrayToDataTable(jsonData);
				
				var add_options = {
						legend: {position: 'right'},
						is3D: gThis.chart3d,  /* Pie는 3D 되는데 Donut는 3D 안됨 */
						pieHole: (donut == true ? 0.4 : 1),  /* Donut의 가운데 비율 */
					};
				options = objectMerge(options, add_options);
				
				var chart = new google.visualization.PieChart(document.getElementById(gThis.controlId));
				google.visualization.events.addListener(chart, 'ready', afterDraw);
				chart.draw(data, options);
			}
		}
		
		
		function AreaChart() {
			google.charts.load('current', {'packages':['corechart']});
			google.charts.setOnLoadCallback(drawChart);
			
			function drawChart() {
				var jsonData = createData();
				var data = google.visualization.arrayToDataTable(jsonData);
				
				var add_options = {
						legend: {position: ((jsonData[0].length - 1) == 1 ? 'none' : null)},
					};
				options = objectMerge(options, add_options);
					
				var chart = new google.visualization.AreaChart(document.getElementById(gThis.controlId));
				google.visualization.events.addListener(chart, 'ready', afterDraw);
				chart.draw(data, options);
			}
		}
		
		
		function ComboChart() {
			google.charts.load('current', {'packages':['corechart']});
			google.charts.setOnLoadCallback(drawChart);
			
			function drawChart() {
				var jsonData = createData();
				var data = google.visualization.arrayToDataTable(jsonData);
				var lineIndex = (jsonData[0].length - 2) + "";
				var legend_position = null;
				
				/* null이면 범례가 오른쪽에 나오는데 우측 Y축을 만들면 범례가 오른쪽에 안만들어 지고 상단에 만들어져서 하단으로 만들게 함 */
				var seriescode2 = gThis.seriescode2 == null ? "" : gThis.seriescode2.split(";");
				if (seriescode2.length > 0) {
					for (var i = 0; i < seriescode2.length; i++) {
						if (jsonData[0].indexOf(seriescode2[i]) > -1) {
							legend_position = 'bottom';
						}
					}
				}
				
				var add_options = {
						legend: {position: ((jsonData[0].length - 1) == 1 ? 'none' : legend_position)},
						seriesType: 'bars',
						series: {}, /* series: { 0: {type: 'line'} }, //이 방법으로 하면 line을 만들 index을 변수로 넣어야 하는데 변수를 넣을 수가 없어서 아래에서 다시 넣어 줌 */
					};
				options = objectMerge(options, add_options);
				
				/* Y2축이 있으면 해당 계열을 Line으로 그리기 */
				if (seriescode2.length > 0) {
					for (var i = 0; i < seriescode2.length; i++) {
						if (jsonData[0].indexOf(seriescode2[i]) > -1) {
							options.series[i] = {type :"line", targetAxisIndex : 1};  /* 해당 index의 데이터를 bar에서 line으로 변경 */
						}
					}
					
				/* Y2축이 없으면 마지막 계열만  Line으로 그리기 */
				} else {
					options.series[lineIndex] = {type :"line"};  /* 마지막 데이터를 line으로 변경 */
				}
				
				
				var chart = new google.visualization.ComboChart(document.getElementById(gThis.controlId));
				google.visualization.events.addListener(chart, 'ready', afterDraw);
				chart.draw(data, options);
			}
		}
		
		
		function StepLineChart() {
			google.charts.load('current', {'packages':['corechart']});
			google.charts.setOnLoadCallback(drawChart);
			
			function drawChart() {
				var jsonData = createData();
				var data = google.visualization.arrayToDataTable(jsonData);
				
				var add_options = {
						legend: {position: ((jsonData[0].length - 1) == 1 ? 'none' : null)},
						areaOpacity: 0,  /* 원래는 StepAreaChart인데 LineChart에는 Step모양이 없어서 StepAreaChart에 Area부분을 투명하게 해서 StepLineChart처럼 보이게 하였음 */
					};
				options = objectMerge(options, add_options);
					
				var chart = new google.visualization.SteppedAreaChart(document.getElementById(gThis.controlId));
				google.visualization.events.addListener(chart, 'ready', afterDraw);
				chart.draw(data, options);
			}
		}
		

		function BubbleChart() {
			google.charts.load('current', {'packages':['corechart']});
			google.charts.setOnLoadCallback(drawChart);
			
			function drawChart() {
				var jsonData = createBubbleData();
				var data = google.visualization.arrayToDataTable(jsonData);
				
				var add_options = {
						legend: {position: ((jsonData[0].length - 1) == 1 ? 'none' : null)},
						bubble: {textStyle: {fontSize: 11}},  /* bubble 안에 글자 크기 */
					};
				options = objectMerge(options, add_options);
					
				var chart = new google.visualization.BubbleChart(document.getElementById(gThis.controlId));
				google.visualization.events.addListener(chart, 'ready', afterDraw);
				chart.draw(data, options);
			}
		}
		
		
		function CandlestickChart() {
			google.charts.load('current', {'packages':['corechart']});
			google.charts.setOnLoadCallback(drawChart);
			
			function drawChart() {
				var jsonData = createCandlestickData();
				var data = google.visualization.arrayToDataTable(jsonData, true);
				
				var add_options = {
						legend: {position: 'none'},
				        candlestick: {
				        	fallingColor: { strokeWidth: 0, fill: '#a52714' }, // red
				        	risingColor: { strokeWidth: 0, fill: '#0f9d58' }   // green
				        },
					};
				options = objectMerge(options, add_options);
					
				var chart = new google.visualization.CandlestickChart(document.getElementById(gThis.controlId));
				google.visualization.events.addListener(chart, 'ready', afterDraw);
				chart.draw(data, options);
			}
		}
		
		
		function BarChart() {
			google.charts.load('current', {'packages':['corechart']});
			google.charts.setOnLoadCallback(drawChart);
			
			function drawChart() {
				var jsonData = createData();
				var data = google.visualization.arrayToDataTable(jsonData);
				
				var add_options = {
						legend: {position: ((jsonData[0].length - 1) == 1 ? 'none' : null)},
					};
				options = objectMerge(options, add_options);
					
				var chart = new google.visualization.BarChart(document.getElementById(gThis.controlId));
				google.visualization.events.addListener(chart, 'ready', afterDraw);
				chart.draw(data, options);
			}
		}
		
		
		function ParetoChart() {
			google.charts.load('current', {'packages':['corechart']});
			google.charts.setOnLoadCallback(drawChart);
			
			var dataTitle = [ '', '','' ];  /* left, bottom, right 라벨 그리는 건데 필요 없음, 아예 없으면 에러남 */
			
			function drawChart() {
				var jsonData = createParetoData();
				paretorize();
				var data = google.visualization.arrayToDataTable(jsonData);
				
				var add_options = {
						legend: {position: 'none'},
						seriesType: "bars",
						series: {1: {type: "line", targetAxisIndex: 1 }},
					};
				options = objectMerge(options, add_options);
					
				var chart = new google.visualization.ComboChart(document.getElementById(gThis.controlId));
				google.visualization.events.addListener(chart, 'ready', afterDraw);
				chart.draw(data, options);
				
				
				/* 데이터 정렬 및 가공 */
				function paretorize() {
					// Sort the dataSet array usung column 2
					jsonData.sort( function(a,b) {
						return b[1] - a[1];
					});
	
					// Calculate the total of column 2
					var sum = 0;
					for(row=0; row<jsonData.length; row++) {
						sum += jsonData[row][1];
					}
	
					// Calculate the accumulating percentages
					// and add them into a new column in each row
					var accum = 0;
					for(row=0; row<jsonData.length; row++) {
						jsonData[row].push( accum+100*jsonData[row][1]/sum );
						accum = jsonData[row][2];
					}
						
					// Add the title row at the beginning of dataSet
					// ('unshift' is not supported in IE8 and earlier)
					jsonData.unshift( dataTitle );
				}
			}
		}
		
		
		function GanttChart() {
			google.charts.load('current', {'packages':['gantt']});
			google.charts.setOnLoadCallback(drawChart);
			
			function drawChart() {
				var jsonData = createGanttData();
				var data = new google.visualization.DataTable();
				
			    data.addColumn('string', 'Task ID');
			    data.addColumn('string', 'Task Name');
			    data.addColumn('string', 'Resource');
			    data.addColumn('date', 'Start Date');
			    data.addColumn('date', 'End Date');
			    data.addColumn('number', 'Duration');
			    data.addColumn('number', 'Percent Complete');
			    data.addColumn('string', 'Dependencies');
				
			    data.addRows(jsonData);
			    
			    /* google GanttChart는 세로스크롤 기능이 없고 행의 높이를 자동으로 조절해 주지 않으므로 막대의 높이를 직접 계산해야 함 */
			    var scaleHeight = 43.17;  /* 하단에 있는 기간 표시줄의 높이, 고정크기 */
			    var rectPadding_top_bottom = 16;  /* 행에서 막대를 제외한 높이, 고정크기 */
			    var barHeight = (gThis.height - scaleHeight - (rectPadding_top_bottom * jsonData.length)) / jsonData.length;  /* 막대의 높이 */
			    
			    var add_options = {
			    		gantt: {
			    			barHeight: barHeight,
			    		}
					};
				options = objectMerge(options, add_options);
					
				var chart = new google.visualization.Gantt(document.getElementById(gThis.controlId));
				google.visualization.events.addListener(chart, 'ready', afterDraw);
				chart.draw(data, options);
			}
		}
		/* 차트 만들기 종료 -------------------------------------------------------------------------------------------------- */
		/* 차트 만들기 종료 -------------------------------------------------------------------------------------------------- */
		
		
		
		/* json 데이터 만들기 시작 -------------------------------------------------------------------------------------------- */
		/* json 데이터 만들기 시작 -------------------------------------------------------------------------------------------- */
		function createData() {
			if (gThis.data instanceof Array) return gThis.data;
			
			var data = ['x'];
			var dataArray = gThis.data.split(':');
			var cValueArray = [''];
			var xValueArray = dataArray[0].split(',');
			
			for (var i = dataArray.length - 1; i >= 0 ; i--) {
				if (dataArray[i] == '') dataArray.splice(i, i + 1);
			}
			
			for (var i = xValueArray.length - 1; i >= 0 ; i--) {
				if (xValueArray[i] == '') xValueArray.splice(i, i + 1);
			}
			
			for (var i = 0; i < xValueArray.length; i++) {
				var temp = [];
				temp[temp.length] = xValueArray[i];
				
				for (var j = 1; j < dataArray.length; j++) {
					var yValueArray = dataArray[j].split(',');
					cValueArray[j] = yValueArray[0];
					temp[temp.length] = yValueArray[i + 1] * 1;
				}
				
				data[data.length] = temp;
			}
			data[0] = cValueArray;
			
			return data;
		}
		
		
		function createScatterData() {
			if (gThis.data instanceof Array) return gThis.data;
			
			var data = [];
			var dataArray = gThis.data.split(':');
			var cValueArray = [];
			var xValueArray = dataArray[0].split(',');
			
			for (var i = dataArray.length - 1; i >= 0 ; i--) {
				if (dataArray[i] == '') dataArray.splice(i, i + 1);
			}
			
			for (var i = 0; i < dataArray.length; i++) {
				var tempArray = dataArray[i].split(',');
				if (cValueArray.indexOf(tempArray[0]) == -1) cValueArray[cValueArray.length] = tempArray[0];
			}
			
			var temp = [];
			temp[0] = 'x';
			for (var i = 0; i < cValueArray.length; i++) {
				temp[i + 1] = cValueArray[i];
			}
			data[data.length] = temp;
			
			for (var i = 0; i < dataArray.length; i++) {
				var temp = [];
				var tempArray = dataArray[i].split(',');
				
				temp[0] = tempArray[1] * 1;
				
				for (var j = 0; j < cValueArray.length; j++) {
					if (tempArray[0] == cValueArray[j])
						temp[j + 1] = tempArray[2] * 1;
					else
						temp[j + 1] = null;
				}
				
				data[data.length] = temp;
			}
			
			return data;
		}
		
		
		function createBubbleData() {
			if (gThis.data instanceof Array) return gThis.data;
			
			var data = [['ID','X','Y','C','Z']];
			var dataArray = gThis.data.split(':');
			var cValueArray = [''];
			var xValueArray = dataArray[0].split(',');
			
			for (var i = dataArray.length - 1; i >= 0 ; i--) {
				if (dataArray[i] == '') dataArray.splice(i, i + 1);
			}
			
			for (var i = 0; i < dataArray.length; i++) {
				var temp = [];
				var tempArray = dataArray[i].split(',');
				
				temp[0] = '';  /* 데이터 입력시 bubble안에 글자 넣을 수 있음 */
				temp[1] = tempArray[1] * 1;
				temp[2] = tempArray[2] * 1;
				temp[3] = tempArray[0];
				temp[4] = tempArray[3] * 1;
				
				data[data.length] = temp;
			}
			
			return data;
		}
		
		
		function createCandlestickData() {
			if (gThis.data instanceof Array) return gThis.data;
			
			var data = [];
			var dataArray = gThis.data.split(':');
			var cValueArray = [''];
			var xValueArray = dataArray[0].split(',');
			
			for (var i = dataArray.length - 1; i >= 0 ; i--) {
				if (dataArray[i] == '') dataArray.splice(i, i + 1);
			}
			
			for (var i = 0; i < dataArray.length; i++) {
				var temp = [];
				var tempArray = dataArray[i].split(',');
				
				var value0 = tempArray[0];
				var value1 = tempArray[1] * 1;
				var value2 = tempArray[2] * 1;
				var value3 = tempArray[3] * 1;
				var value4 = tempArray[4] * 1;
				
				/* 음수이면 양수로 변환 */
				value1 = value1 < 0 ? value1 * -1 : value1;
				value2 = value2 < 0 ? value2 * -1 : value2;
				value3 = value3 < 0 ? value3 * -1 : value3;
				value4 = value4 < 0 ? value4 * -1 : value4;
				
				/*
				 * label -> Close -> Low -> High -> Open
				 */
				temp[0] = value0;
				temp[1] = value4;
				temp[2] = value3;
				temp[3] = value2;
				temp[4] = value1;
				
				data[data.length] = temp;
			}
			
			return data;
		}
		
		
		function createParetoData() {
			if (gThis.data instanceof Array) return gThis.data;
			
			var data = [];
			var dataArray = gThis.data.split(':');
			var cValueArray = [''];
			var xValueArray = dataArray[0].split(',');
			
			for (var i = dataArray.length - 1; i >= 0 ; i--) {
				if (dataArray[i] == '') dataArray.splice(i, i + 1);
			}
			
			for (var i = xValueArray.length - 1; i >= 0 ; i--) {
				if (xValueArray[i] == '') xValueArray.splice(i, i + 1);
			}
			
			for (var i = 0; i < xValueArray.length; i++) {
				var temp = [];
				var yValueArray = dataArray[1].split(',');
				var yValue = yValueArray[i + 1] * 1;
				
				/* 음수이면 양수로 변환 */
				yValue = yValue < 0 ? yValue * -1 : yValue;
				
				/* ParetoChart는 계열 한 개만 사용 */
				temp[0] = xValueArray[i];
				temp[1] = yValue;
				
				data[data.length] = temp;
			}
			
			return data;
		}
		
		
		function createGanttData() {
			if (gThis.data instanceof Array) return gThis.data;
			
			var data = [];
			var dataArray = gThis.data.split(':');
			var cValueArray = [''];
			var xValueArray = dataArray[0].split(',');
			
			for (var i = dataArray.length - 1; i >= 0 ; i--) {
				if (dataArray[i] == '') dataArray.splice(i, i + 1);
			}
			
			for (var i = 0; i < dataArray.length; i++) {
				var temp = [];
				var tempArray = dataArray[i].split(',');
				
				var task = tempArray[0];
				var start = tempArray[1];
				var end = tempArray[2];
				var percent = tempArray[3];
				
				
				/* percent는 숫자 0 ~ 100까지만 가능 */
				if (isNaN(percent)) percent = 100;
				else if (percent < 0) percent = 0;
				else if (percent > 100) percent = 100;
				else percent = percent * 1;
				
				/* 퓨전차트나 d3차는는 한개의 행에 2개 이상의 막대를 넣을 수 있는데 구글차트는 빈줄만 늘어나서 중복된 데이터 제거 */
				var overlap = false;
				for (var j = 0; j < data.length; j++) {
					if (task == data[j][0]) {
						overlap = true;
						break;
					}
				}
				if (overlap) continue;
				
				/*
				 *             Column 0    Column 1    Column 2                Column 3    Column 4    Column 5                    Column 6            Column 7
				 * Purpose:    Task ID     Task Name   Resource ID (optional)  Start       End         Duration (in milliseconds)  Percent Complete    Dependencies
				 * Data Type:  string      string      string                  date        date        number                      number              string
				 * Role:       domain      data        data                    data        data        data                        data                data
				 */
				temp[0] = task;
				temp[1] = task;
				temp[2] = null;
				temp[3] = start.replace(/<COLON>/g, ":");
				temp[4] = end.replace(/<COLON>/g, ":");
				temp[5] = null;
				temp[6] = percent;
				temp[7] = null;
				
				data[data.length] = temp;
			}
			
			
			
			var date_format_Array = [ 
        		["yyyy-MM-dd HH:mm:ss", "^([0-9]{4}-(0[1-9]|1[0-2]|[0-9])-(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["yyyy/MM/dd HH:mm:ss", "^([0-9]{4}/(0[1-9]|1[0-2]|[0-9])/(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["yyyy.MM.dd HH:mm:ss", "^([0-9]{4}.(0[1-9]|1[0-2]|[0-9]).(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["MM-dd-yyyy HH:mm:ss", "^((0[1-9]|1[0-2]|[0-9])-(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])-[0-9]{4}) ((2[0-3]|[01][0-9])|[0-9]:[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["MM/dd/yyyy HH:mm:ss", "^((0[1-9]|1[0-2]|[0-9])/(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])/[0-9]{4}) ((2[0-3]|[01][0-9])|[0-9]:[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["MM.dd.yyyy HH:mm:ss", "^((0[1-9]|1[0-2]|[0-9])\.(0[1-9]|[1-2][0-9]|3[0-1]|[0-9]).[0-9]{4}) ((2[0-3]|[01][0-9])|[0-9]:[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["dd-MM-yyyy HH:mm:ss", "^((0[1-9]|[1-2][0-9]|3[0-1]|[0-9])-(0[1-9]|1[0-2]|[0-9])-[0-9]{4}) ((2[0-3]|[01][0-9])|[0-9]:[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["dd/MM/yyyy HH:mm:ss", "^((0[1-9]|[1-2][0-9]|3[0-1]|[0-9])/(0[1-9]|1[0-2]|[0-9])/[0-9]{4}) ((2[0-3]|[01][0-9])|[0-9]:[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
        		["dd.MM.yyyy HH:mm:ss", "^((0[1-9]|[1-2][0-9]|3[0-1]|[0-9]).(0[1-9]|1[0-2]|[0-9]).[0-9]{4}) ((2[0-3]|[01][0-9])|[0-9]:[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9])"],
                ["yyyy-MM-dd HH:mm",    "^([0-9]{4}-(0[1-9]|1[0-2]|[0-9])-(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["yyyy/MM/dd HH:mm",    "^([0-9]{4}/(0[1-9]|1[0-2]|[0-9])/(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["yyyy.MM.dd HH:mm",    "^([0-9]{4}.(0[1-9]|1[0-2]|[0-9]).(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["MM-dd-yyyy HH:mm",    "^((0[1-9]|1[0-2]|[0-9])-(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])-[0-9]{4}) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["MM/dd/yyyy HH:mm",    "^((0[1-9]|1[0-2]|[0-9])/(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])/[0-9]{4}) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["MM.dd.yyyy HH:mm",    "^((0[1-9]|1[0-2]|[0-9]).(0[1-9]|[1-2][0-9]|3[0-1]|[0-9]).[0-9]{4}) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["dd-MM-yyyy HH:mm",    "^((0[1-9]|[1-2][0-9]|3[0-1]|[0-9])-(0[1-9]|1[0-2]|[0-9])-[0-9]{4}) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["dd/MM/yyyy HH:mm",    "^((0[1-9]|[1-2][0-9]|3[0-1]|[0-9])/(0[1-9]|1[0-2]|[0-9])/[0-9]{4}) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["dd.MM.yyyy HH:mm",    "^((0[1-9]|[1-2][0-9]|3[0-1]|[0-9]).(0[1-9]|1[0-2]|[0-9]).[0-9]{4}) ((2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9])"],
                ["yyyy-MM-dd",          "[0-9]{4}-(0[1-9]|1[0-2]|[0-9])-(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])"],
                ["yyyy/MM/dd",          "[0-9]{4}/(0[1-9]|1[0-2]|[0-9])/(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])"],
                ["yyyy.MM.dd",          "[0-9]{4}.(0[1-9]|1[0-2]|[0-9]).(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])"],
                ["MM-dd-yyyy",          "(0[1-9]|1[0-2]|[0-9])-(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])-[0-9]{4}"],
                ["MM/dd/yyyy",          "(0[1-9]|1[0-2]|[0-9])/(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])/[0-9]{4}"],
                ["MM.dd.yyyy",          "(0[1-9]|1[0-2]|[0-9]).(0[1-9]|[1-2][0-9]|3[0-1]|[0-9]).[0-9]{4}"],
                ["dd-MM-yyyy",          "(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])-(0[1-9]|1[0-2]|[0-9])-[0-9]{4}"],
                ["dd/MM/yyyy",          "(0[1-9]|[1-2][0-9]|3[0-1]|[0-9])/(0[1-9]|1[0-2]|[0-9])/[0-9]{4}"],
                ["dd.MM.yyyy",          "(0[1-9]|[1-2][0-9]|3[0-1]|[0-9]).(0[1-9]|1[0-2]|[0-9]).[0-9]{4}"],
                ["HH:mm:ss",            "(2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9]:[0-5][0-9]|[0-9]"],
                ["HH:mm",               "(2[0-3]|[01][0-9]|[0-9]):[0-5][0-9]|[0-9]"]
	        ];
        	
        	/* 날짜 형식 */
        	var date_format = "";
        	
        	/* 날짜 형식 확인하기 */
        	for (var i = 0; i < date_format_Array.length; i++) {
        		var checkFlag = true;
        		var pattern = date_format_Array[i][1];
        		var re = new RegExp(pattern);
        		
        		for (var j = 0; j < data.length; j++) {
        			/* 해당 날짜 형식 확인 정규식이 아니면 종료 */
        			if (!re.test(data[j][3]) || !re.test(data[j][4])) {
        				checkFlag = false;
        				break;
        			}
        		};
        		
        		/* 날짜 형식 확인 정규식에 맞으면 종료 */
        		if (checkFlag == true) {
        			date_format = date_format_Array[i][0];
        			break;
        		}
        	}
        	
        	var today = new Date().getFullYear() + "/" + (new Date().getMonth() + 1) + "/" + new Date().getDate();  /* 오늘 날짜 : 2019/02/14 */
        	
        	/* 날짜에는 시간 까지 들어가야 하는데 년월일만 입력하면 시간을 더 입력해줌 */
        	if (date_format.indexOf("HH") == -1) {
        		for (var i = 0; i < data.length; i++) {
        			data[i][3] = new Date(data[i][3] + " 00:00:00");
        			data[i][4] = new Date(data[i][4] + " 23:59:59");
        		}
        		
        	} else if (date_format == "HH:mm:ss" || date_format == "HH:mm") {
        		for (var i = 0; i < data.length; i++) {
        			data[i][3] = new Date(today + " " + data[i][3]);
        			data[i][4] = new Date(today + " " + data[i][4]);
        		}
        		
        	} else {
        		for (var i = 0; i < data.length; i++) {
	        		data[i][3] = new Date(data[i][3]);
	    			data[i][4] = new Date(data[i][4]);
        		}
        	}
        	
        	
			
			return data;
		}
		/* json 데이터 만들기 종료 -------------------------------------------------------------------------------------------- */
		/* json 데이터 만들기 종료 -------------------------------------------------------------------------------------------- */
	};

/**
 * @class       PioctureBox를 호출하는 클래스
 * @constructor PictureBox Class 생성자 메소드
 * @param       controlId		  해당컨트롤의 ID를 지정한다.
 * @param       controlName   해당 컨트롤의 Name을 지정한다.
 * @param       tagObject		  해당 컨트롤의 태그속성을 설정하는 객체를 지정한다.
 * @return                    반환값 없음, 에러발생시 undefined 를반환함
 * @example     var wControl = controls["PictureBox_1"]
 * 			if(wContorl.errMsg !=null){
 * 		//객체 생성에 실패하였습니다. 에러처리 코드를 입력해주세요.
 *  }
 *  	//후속코드생략..
 */
function PictureBox(controlId, controlName, tagObject){
	// 상속선언부
	this.base = ControlBase;						//부모클래스 지정
	this.base(controlId, controlName, tagObject);	//부모클래스 생성자호출
	
	// 속성 선언부
	this.tagObject = tagObject;
	
	if( tagObject != undefined ){
		tagObject.setAttribute("tabIndex", "-1");
		pictures[pictures.length] = this;
	}
	
	this.busy = false;
};

PictureBox.prototype = new ControlBase(); // 의미없음 코딩 편의기능을 활용하기 위함
/**
 * @description 사진이 위치한 파일명 및 경로를 넘겨줍니다
 * @param       pictureUrl {String} 사진의 주소값을 가져옵니다
 * @param       subdir {String} 사진의 경로값을 가져옵니다.
 * @param       fileName {Sting} 파일명을 가져옵니다.
 * @return      반환값 없음, 에러발생시 undefined를 반환함
 * @example     contorls["PictureBox_1"].setValue(pictureUrl,subdir,fileName);
 */
PictureBox.prototype.setValue = function(pictureUrl, subdir, fileName){
	// functionname : [PictureBox.setPicture]
	
	this.setPicture(pictureUrl, subdir, fileName);
};
/**
 * @description 사진의 경로 및 파일이름을 지정합니다.
 * @param       pictureUrl {String} 사진의 주소값을 가져옵니다.
 * @param       subdir {String} 파일의 경로를 가져옵니다.
 * @param       fileName {String} 파일명을 가져옵니다.
 * @return      반환값 없음. 에러발생시 undefined를 반환한다
 * @example     controls["PictureBox_1"].setPicture("http://image.search.naver.com/search");
 * @example     controls["PictureBox_1"].setPicture("c:\picture","apple.jsp");
 */
PictureBox.prototype.setPicture = function(pictureUrl, subdir, fileName){
	// functionname : [PictureBox.setPicture]
	
	this.clear();
	
	if( (typeof pictureUrl == "string" && pictureUrl.length > 0) 
			&& (typeof subdir == "undefined" || typeof fileName == "undefined")
	){
		if( !(/^http:\/\/.+$/.test(pictureUrl)) ) pictureUrl = getContextPath() + pictureUrl;
		
		this.tagObject.getElementsByTagName("IMG")[0].src = encodeURI(pictureUrl);
	}
	else if( (typeof pictureUrl == "string" && pictureUrl.length <= 0) 
				&& typeof subdir != "undefined" && typeof fileName != "undefined"
	){
		this.loadPicture(subdir, fileName);
	}
};
/**
 * @description 화면에서 불러왔던 사진을 지워줍니다.
 * @return      반환값 없음. 에러발생시 undefined를 반환한다.
 * @example     controls["PictureBox_1"].clear()
 */
PictureBox.prototype.clear = function(){
	// functionname : [PictureBox.clear]
	
	this.tagObject.getElementsByTagName("IMG")[0].src = getContextPath() + "/winnersoft/images/picture/blank.gif";
};
/**
 * @description 지정된 파일을 보여줍니다.
 * @param       svrFileName {String} 화면에 보여줄 파일명 입니다.
 * @param       subDir {String} 파일이 존재하는 경로 입니다.
 * @return      반환값 없음.오류발생시 undefined를 반환한다.
 * @example     controls["PictureBox_1"].loadPicture("apple.jpg","c:\picture");
 */
PictureBox.prototype.loadPicture = function(svrFileName, subDir){
	// functionname : [PictureBox.loadPicture]
	
	var wSvrFileName = (svrFileName.indexOf("/") >= 0) ? svrFileName.substring(svrFileName.lastIndexOf("/") + 1) : svrFileName;
	var wQueryString = "subDir=" + encodeURIComponent(subDir)
						+ "&svrFileName=" + encodeURIComponent(wSvrFileName)
						+ "&lang=" + USER_LANGUAGE
						+ "&tm=" + (new Date()).valueOf(); 
	var pictureControlName = this.controlName;
	this.busy = true;
	
	//showAjaxBox("그림을 가저오는 중입니다", 0);
	
	ajaxCall("POST", "ViewPic.do", wQueryString, this, "textLoadPicture");
	
	return;
};
/**
 * @ 
 * @description 컨트롤의 정보와 메세지를전달 합니다.
 * @param       info {String}	데이터 분석 플래시 입니다.
 * @param       message {String} 오류메세지 입니다.
 * @param       pFlag
 * @example     controls["PictureBox_1"].parseData(info,message,pFlag);
 */
PictureBox.prototype.parseData = function(info, message, pFlag){
	// functionname : [PictureBox.parseData]
	
	this.busy = false;
	
	//hideAjaxBox();
	
	// 오류 메시지 먼저 파악 
	if( info == null ){
		alert(message);
		return;
	}
	
	// 데이터분석 플래시 전달
	
	controls[this.controlName].setPicture(info);
	
	return;
};
/**
 * @class Navigator를 만들어주는 클래스
 * @param controlId
 *            {String} Control의 id를 입니다.
 * @param controlName
 *            {String} Control의 name을 입니다.
 * @param tagObject
 *            {Object} 태그객체 입니다.
 * @example 미결
 */
function Navigator(controlId, controlName, tagObject){
	this.base = ControlBase;						//부모클래스 지정
	this.base(controlId, controlName, tagObject);	//부모클래스 생성자호출
	
	// 아래 디폴트 값을 모두 1로 하는 것에 주의
	this.totalCount = 1;		//전체보여질 데이타 건수
	this.currentPage = 1;		//현재페이지
	this.currentLeftPage = 1;	//현재 좌측 첫번째 페이지
	
	// 폼 로드시 설정되는 속성 : 초기화할 경우 수정되면 안됨
	this.pageSize = 1;			//화면에 보여질 데이타 건수
	this.displayPageCount = 1;	// 화면에 출력할 페이지 수 예) 10이면  1부터 10까지. 5이면 1부터 5까지
	this.lastPage = 1;
	
	this.SHOWNEXTBUTTON = 1;
	this.SHOWNEXTGROUPBUTTON = 2;
	this.SHOWLASTBUTTON = 4;
	
	if( tagObject != undefined ){
		tagObject.setAttribute("tabIndex", "-1");
	}
	
	var leftArrowDiv = this.tagObject.getElementsByTagName("div")[0];
	// l◀ 클릭시 이벤트
	setEventHandler(leftArrowDiv.getElementsByTagName("span")[0], "click", Navigator_LeftEofMove_onclick);
	// ◀◀ 클릭시 이벤트
	setEventHandler(leftArrowDiv.getElementsByTagName("span")[1], "click", Navigator_LeftCountMove_onclick);
	// ◀ 클릭시 이벤트
	setEventHandler(leftArrowDiv.getElementsByTagName("span")[2], "click", Navigator_LeftMove_onclick);
	
	var rightArrowDiv = this.tagObject.getElementsByTagName("div")[2];
	// ▶ 클릭시 이벤트  
	setEventHandler(rightArrowDiv.getElementsByTagName("span")[2], "click", Navigator_RightEofMove_onclick);
	// ▶▶ 클릭시 이벤트 
	setEventHandler(rightArrowDiv.getElementsByTagName("span")[1], "click", Navigator_RightCountMove_onclick);
	// ▶l 클릭시 이벤트   
	setEventHandler(rightArrowDiv.getElementsByTagName("span")[0], "click", Navigator_RightMove_onclick);
};

Navigator.prototype = new ControlBase();

/**
 * @description	미결
 * @param		{Object}	em
 * @return		{void}
 * @example		미결
 */
function searchControl_Navigator(em){
	var pEm = em;
	var image = pEm.getAttribute("image");
	var wReturn = null;
	
//	while( pEm.parentNode && !(pEm.className == "Navigator") )
//		pEm = pEm.parentNode;
//	if( pEm.className == "Navigator" ){ 
//		wReturn = getControlById(pEm.id);
//	}
	
	while(pEm.parentNode && image !== "Navigator"){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}
	
	if( pEm.getAttribute("image") === "Navigator" ){
		wReturn = getControlById(pEm.id);
	}
	else{
		pEm = null;
		pEm = em;
		
		while( pEm.parentNode && !(pEm.className == "Navigator") )
			pEm = pEm.parentNode;
		
		if( pEm.className == "Navigator" ) 
			wReturn = getControlById(pEm.id);
	}
	
	image = null;
	pEm = null;
	
	return wReturn;
};

/**
 * @description	미결
 * @return		{void}
 * @example		미결
 */
Navigator.prototype.initialize = function (){
    // functionname : [Navigator.initialize]
	
    // 아래 디폴트 값을 모두 1로 하는 것에 주의
    this.totalCount = 1; 		//전체보여질 데이타 건수
    this.currentPage = 1; 		//현재페이지
    this.currentLeftPage = 1; 	//현재 좌측 첫번째 페이지
    
    this.lastPage = 1;
    
    this.showPage(1);
    
	return;
};

/**
 * @description	미결
 * @param		{number}	pPageSize
 * @return		{void}
 * @example		미결
 */
Navigator.prototype.setPageSize = function (pPageSize){
    // functionname : [Navigator.setPageSize]
	
	this.pageSize = pPageSize;
	
	return;
};

/**
 * @description	미결
 * @param		{number}	pTotalCount
 * @return		{void}
 * @example		미결
 */
Navigator.prototype.setTotalCount = function (pTotalCount){
    // functionname : [Navigator.setTotalCount]

	this.totalCount = pTotalCount;
	
	return;
};

/**
 * @description	미결
 * @param		{number}	pDisplayPageCount
 * @return		{void}
 * @example		미결
 */
Navigator.prototype.setDisplayPageCount = function (pDisplayPageCount){
    // functionname : [Navigator.setDisplayPageCount]

	this.displayPageCount = pDisplayPageCount;
	
	return;
};

/**
 * @description	미결
 * @param		{number}	pCurrentPage
 * @return		{void}
 * @example		미결
 */
Navigator.prototype.setCurrentPage = function (pCurrentPage){
    // functionname : [Navigator.setCurrentPage]

	this.currentPage = pCurrentPage;
	
	return;
};

/**
 * @description	미결
 * @param		{object}	styleCode
 * @return		{void}
 * @example		미결
 */
Navigator.prototype.setButtonStyle = function (styleCode){
    // functionname : [Navigator.setButtonStyle]
	
	var leftArrowDiv = this.tagObject.getElementsByTagName("div")[0];
	var rightArrowDiv = this.tagObject.getElementsByTagName("div")[2];
	
	//▶ 버튼
	if( (styleCode & this.SHOWNEXTBUTTON) == this.SHOWNEXTBUTTON ){
		leftArrowDiv.getElementsByTagName("span")[2].style.display = "inline-block";
		rightArrowDiv.getElementsByTagName("span")[0].style.display = "inline-block";
	}
	else{
		leftArrowDiv.getElementsByTagName("span")[2].style.display = "none";
		rightArrowDiv.getElementsByTagName("span")[0].style.display = "none";
	}
	//▶| 버튼
	if( (styleCode & this.SHOWNEXTGROUPBUTTON) == this.SHOWNEXTGROUPBUTTON ){
		leftArrowDiv.getElementsByTagName("span")[1].style.display = "inline-block";
		rightArrowDiv.getElementsByTagName("span")[1].style.display = "inline-block";
	}
	else{
		leftArrowDiv.getElementsByTagName("span")[1].style.display = "none";
		rightArrowDiv.getElementsByTagName("span")[1].style.display = "none";
	}
	//▶▶| 버튼
	if( (styleCode & this.SHOWLASTBUTTON) == this.SHOWLASTBUTTON ){
		leftArrowDiv.getElementsByTagName("span")[0].style.display = "inline-block";
		rightArrowDiv.getElementsByTagName("span")[2].style.display = "inline-block";
	}
	else{
		leftArrowDiv.getElementsByTagName("span")[0].style.display = "none";
		rightArrowDiv.getElementsByTagName("span")[2].style.display = "none";
	}

	return;
};

/**
 * @description	미결
 * @return		{number}
 * @example		미결
 */
Navigator.prototype.getPageSize = function (){
    // functionname : [Navigator.getPageSize]

	var wPageSize = this.pageSize;
	
	return wPageSize;
};

/**
 * @description	미결
 * @return		{number}
 * @example		미결
 */
Navigator.prototype.getTotalCount = function (){
    // functionname : [Navigator.getTotalCount]

	var wTotalCount = this.totalCount;
	
	return wTotalCount;
};

/**
 * @description	미결
 * @return		{number}
 * @example		미결
 */
Navigator.prototype.getDisplayPageCount = function (){
    // functionname : [Navigator.getDisplayPageCount]

	var wDisplayPageCount = this.displayPageCount;
	
	return wDisplayPageCount;
};

/**
 * @description	미결
 * @return		{number}
 * @example		미결
 */
Navigator.prototype.getCurrentPage = function (){
    // functionname : [Navigator.getCurrentPage]

	var wCurrentPage = this.currentPage;
	
	return wCurrentPage;
};

// 페이지 번호 변경. : 페이지 번호, 이미지 클릭시 페이지 변경 동작
/**
 * @description	미결
 * @param		{Object}	em
 * @param		{number}	pageNum
 * @return		{boolean}
 * @example		미결
 */
function callPage(em, pageNum){
	var control = searchControl_Navigator(em); //getSrcElement(event)
	var result = false
	
	try{
		if( typeof window[control.controlId + "_onclick"] == "function" ){
			result = window[control.controlId + "_onclick"](pageNum);
			if( typeof(result) == "boolean" && !result ){
				return false;
			}
		}
	} catch(e){}
	  
	return true;
};

// 스마트 그리드 구현을 위하여 연결된 시트에서 스크롤시 동작   
Navigator.prototype.addPage = function(maxRows){
    // functionname : [Navigator.addPage]
	
	var maxPageNum = Math.ceil(maxRows/this.pageSize);
	if (maxPageNum == Math.ceil(this.totalCount/this.pageSize)) return;
	
	var pageNum = maxPageNum + 1;
    var result = false;
    
    try{
        if( typeof window[this.controlId + "_onaddrequest"] == "function" ){
        	result = window[this.controlId + "_onaddrequest"](pageNum);
        	if( typeof(result) == "boolean" && !result ){
				return false;
			}
        }
	} catch(e){}
	  
    return true;
};

Navigator.prototype.showPage = function(toPageNum){
    // functionname : [Navigator.showPage]

	// 전체 페이지 카운트를 구한다
	this.lastPage = Math.ceil(this.totalCount / this.pageSize);

	// 첫번째 페이지의 번호
	this.currentLeftPage = this.displayPageCount * Math.floor((toPageNum - 0.5) / this.displayPageCount) + 1;
	
	// 끝번째 페이지의 번호
	var lastPageNum = this.currentLeftPage + this.displayPageCount - 1;
    if (lastPageNum > this.lastPage) lastPageNum = this.lastPage;
	
    // 테그만들기
    var wHtml = ""; var index = 0;
    for(var pageNum = this.currentLeftPage; pageNum <= lastPageNum; pageNum++){
    	if (pageNum == toPageNum){
    		wHtml += "<span class=\"underline\">" + pageNum + "</span>";
    	} else {
    		wHtml += "<span onclick='callPage(this," + pageNum + ");'>" + pageNum + "</span>";
    	}
    }
    
    this.tagObject.getElementsByTagName("DIV")[1].innerHTML = wHtml;
    this.currentPage = toPageNum;
    
    return;
};

/**
 * @name 			Navigator#LeftEofMove_onclick
 * @event
 * @return			{boolean}
 * @description  	미결
 */
function Navigator_LeftEofMove_onclick(e)
{
    e = window.event || e;
    var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
    var control = searchControl_Navigator(em);
    
    if (control.currentPage == 1) return false;
    
	callPage(em, 1);
	
    return true;
};

/**
 * @name 			Navigator#LeftCountMove_onclick
 * @event
 * @return			{boolean}
 * @description  	미결
 */
function Navigator_LeftCountMove_onclick(e)
{
    e = window.event || e;
    var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
    var control = searchControl_Navigator(em);
    
    if (control.currentLeftPage - control.displayPageCount <= 0) return false;
    
	callPage(em, control.currentLeftPage - control.displayPageCount);
    
    return true;
};

/**
 * @name 			Navigator#LeftMove_onclick
 * @event
 * @return			{boolean}
 * @description  	미결
 */
function Navigator_LeftMove_onclick(e)
{
    e = window.event || e;
    var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
    var control = searchControl_Navigator(em);
    
    if (control.currentPage == 1) return false;
    
	callPage(em, control.currentPage - 1);
    
    return true;
};

/**
 * @name 			Navigator#RightEofMove_onclick
 * @event
 * @return			{boolean}
 * @description  	미결
 */
function Navigator_RightEofMove_onclick(e)
{
    e = window.event || e;
    var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
    var control = searchControl_Navigator(em);
    
     if (control.currentPage == control.lastPage) return false;
    
	callPage(em, control.lastPage);
    
    return true;
};

/**
 * @name 			Navigator#RightCountMove_onclick
 * @event
 * @return			{boolean}
 * @description  	미결
 */
function Navigator_RightCountMove_onclick(e)
{
    e = window.event || e;
    var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
    var control = searchControl_Navigator(em);
    
    if (control.currentLeftPage + control.displayPageCount > control.lastPage ) return false;
    
	callPage(em, control.currentLeftPage + control.displayPageCount);
    
    return true;
};

/**
 * @name 			Navigator#RightMove_onclick
 * @event
 * @return			{boolean}
 * @description  	미결
 */
function Navigator_RightMove_onclick(e)
{
    e = window.event || e;
    var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
    var control = searchControl_Navigator(em);
    
    if (control.currentPage == control.lastPage ) return false;

    callPage(em, control.currentPage + 1);
    
    return true;
};
/**
 * @class Linker 클래스
 * @constructor Linker
 * 
 * @param controlId
 *            {String} 해당 컨트롤의 ID를 지정합니다.
 * @param controlName
 *            {String} 해당 컨트롤의 Name을 지정합니다.
 * @param tagObject
 *            {Object} 해당 컨트롤의 태그 객체를 지정합니다.
 * 
 * @return 객체 생성 성공하면 객체의 errorMsg 필드가 null 입니다.<br>
 *         만약 에러가 발생한다면 errorMsg 필드에 에러메시지를 반환합니다.
 * 
 * @example var wControl = controls["link_1"] = new Linker("link_1", "Link_1",
 *          document.getElementsByName("link_1")[0]); if(wControl.errorMsg !=
 *          null){ //객체 생성 실패하였습니다. 에러처리 코드를 입력해주세요. }
 *  // 후속코드 생략...
 */
function Linker(controlId, controlName, tagObject){
	this.base = ControlBase;						//부모클래스 지정
	this.base(controlId, controlName, tagObject);	//부모클래스 생성자호출
	
	this.caption = "";
	/**
	 * @description 링크 url 주소입니다..<br>
	 *              기본값 : #<br>
	 *              <br>
	 */
	this.url = "#";
	
	this.anchor = document.createElement("a");
	this.anchor.setAttribute("href", this.url);
	this.anchor.setAttribute("target", "_blank");
	
	// 자체 이벤트 선언부 
	this.hasClickEvent = false;	this.fncClickEvent = null;
	this.hasClickEvent = (typeof self[this.controlId + "_onclick"] != "undefined");
	if( this.hasClickEvent )
		this.fncClickEvent = new Function("return function(){ return " + this.controlId + "_onclick(); }")();
	
	//this.tagObject.onclick = linker_Click;
	//this.tagObject.getElementsByTagName("A")[0].onclick = linker_A_Click;
	
	setEventHandler(tagObject.getElementsByTagName("a")[0], "click", linker_A_Click);
	setEventHandler(tagObject, "keydown", linker_KeyDown);
};

Linker.prototype = new ControlBase();

/**
 * @description 링크 컨트롤의 ID를 반환합니다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @param em
 *            {Object} 라벨 컨트롤 객체를 입력합니다.
 * @return 링크 컨트롤의 ID를 반환합니다.<br>
 *         만약 에러가 발생할 경우, false 반환합니다.
 * @example var wControl = searchControl_Linker(
 *          document.getElementsByName("link_1")[0] ); if(wControl == null){ //
 *          링크 컨트롤을 찾는데 실패하였습니다. } if(wControl == false){ //
 *          searchControl_Linker 함수 동작 중 에러가 발생하였습니다. }
 *  // 후속코드 생략...
 */
function searchControl_Linker(em){
	var wReturn = null;
	var pEm = em;
	var image = pEm.getAttribute("image");
	
//	while( pEm.parentNode && !pEm.className.startsWith("Link") ) 
//		pEm = pEm.parentNode;
//	if( pEm.className.startsWith("Link") ) 
//		wReturn = getControlById(pEm.id);
	
	while(pEm.parentNode && image !== "Link"){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}

	if( pEm.getAttribute("image") === "Link" ){
		wReturn = getControlById(pEm.id);
	}
	
	image = null;
	pEm = null;
	
	return wReturn;
};

/* 포커스 주기*/
/**
 * @description 링크 컨트롤에 포커스를 지정합니다.
 * @return 포커스 지정을 성공한다면 true를 반환합니다.<br>
 *         만약 에러가 발생한다면 false를 반환합니다.
 * @example var wControl = searchControl_Linker(
 *          document.getElementsByName("link_1")[0] ); if(wControl == null){ //
 *          링크 컨트롤을 찾는데 실패하였습니다. } if(wControl == false){ //
 *          searchControl_Linker 함수 동작 중 에러가 발생하였습니다. } //링크 컨트롤에 포커스를 지정합니다.
 *          if( wControl.focus() == false ){ //링크 컨트롤에 포커스 지정 실패하였습니다. 에러처리 코드를
 *          입력해주세요. //에러 발생시 focus 메소드는 false 를 반환합니다. //에러에 관한 메세지는
 *          wControl.errorMsg 필드로 확인할 수 있습니다. }
 */
Linker.prototype.focus = function(){
	// functionname : [Linker.focus]
	var wReturn = true;
	
	try{
		this.tagObject.getElementsByTagName("A")[0].focus();
	}
	catch(e){
		wReturn = false;
	}
	
	return wReturn;
};

/**
 * @description 링크 컨트롤의 url 주소를 설정합니다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @param value
 *            {String} url 주소를 입력합니다.
 * @return 주소설정을 성공한다면 true를 반환합니다.<br>
 *         만약 에러가 발생한다면 false를 반환합니다.
 * @example var wControl = controls["link_1"]; //링크 컨트롤의 url
 *          "http://www.winnersoft.co.kr" 주소 를 설정합니다.
 *          if(wControl.setValue("http://www.winnersoft.co.kr") == false){ //링크
 *          컨트롤의 url 주소설정 실패하였습니다. 에러처리 코드를 입력해주세요. //에러 발생시 setValue 메소드는 false
 *          를 반환합니다. //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다. }
 */
Linker.prototype.setValue = function(value){
	this.url = value;
	this.anchor.setAttribute("href", value);
	
	return;
};

/**
 * @description 링크 컨트롤의 표시문자열을 설정합니다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @param value
 *            {String} 표시문자열을 입력합니다.
 * @return 표시문자열 설정을 성공한다면 true를 반환합니다.<br>
 *         만약 에러가 발생한다면 false를 반환합니다.
 * @example var wControl = controls["link_1"]; //링크 컨트롤의 url
 *          "http://www.winnersoft.co.kr" 주소 를 설정합니다.
 *          if(wControl.setValue("http://www.winnersoft.co.kr") == false){ //링크
 *          컨트롤의 url 주소설정 실패하였습니다. 에러처리 코드를 입력해주세요. //에러 발생시 setValue 메소드는 false
 *          를 반환합니다. //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다. } //링크 컨트롤의
 *          표시문자열을 "위너소프트"로 설정합니다.
 *          if(wControl.setCaption("http://www.winnersoft.co.kr") == false){
 *          //링크 컨트롤의 표시문자열 설정 실패하였습니다. 에러처리 코드를 입력해주세요. //에러 발생시 setCaption
 *          메소드는 false 를 반환합니다. //에러에 관한 메세지는 wControl.errorMsg 필드로 확인할 수 있습니다. }
 */
Linker.prototype.setCaption = function(caption){
	this.caption = caption;
	this.tagObject.getElementsByTagName("SPAN")[0].innerText = caption;
	
	return;
};

/**
 * @description 링크 컨트롤을 클릭하는 함수입니다.<br>
 *              만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 * @return 컨트롤을 클릭한다면 true를 반환합니다. 만약 에러가 발생한다면 false를 반환합니다.
 * @example var wControl = controls["link_1"]; //링크 컨트롤을 클릭합니다. if(
 *          wControl.click() == false ){ //링크 컨트롤을 클릭하지 못하였습니다. 에러처리 코드를 입력해주세요.
 *          //에러 발생시 click 메소드는 false 를 반환합니다. //에러에 관한 메세지는 wControl.errorMsg
 *          필드로 확인할 수 있습니다. }
 */
Linker.prototype.click = function(){
	// functionname : [Linker.print]
	
	// 사용자 코딩 추가영역을 호출한다
	if( !this.enabled )
		return false;
	
	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		if( this.hasClickEvent ){
			var result = this.fncClickEvent();
			if( result === false )
				return false;
		}
	}
	
	this.anchor.click();
	
//	//호출 url이 없다면 리턴
//	if( this.url.trim().length == 0 )
//		return;
//	
//	var urlList = this.url.split("?");
//	var paramList = null;
//	
//	if( urlList.length > 1 )
//		paramList = urlList[1].split("&");
//	else
//		paramList = [];
//	
//	var parent = document.getElementsByName("IFrameLayer")[0];
//	var jUploadPrefix = null;
//	var iFrame_DownLoad = null;
//	var action = urlList[0];
//	var paramInfo = null;
//	var params = null;
//	var paramName = null;
//	var paramValue = null;
//	
//	for(var i = 0; i < paramList.length; i++){
//		paramInfo = paramList[i].split("=");
//		
//		paramName = paramInfo[0];
//		paramValue = paramInfo[1];
//		
//		params[i] = new Parameter(paramName, paramValue);
//	}
//
//	jUploadPrefix = timeEncodeString();
//	
//	iFrame_DownLoad = new IFrame_DownLoad(parent, jUploadPrefix + this.controlName, action, params);
//	iFrame_DownLoad.submit();
	
	return true;
};

/**
 * @description	미결
 * @name		Linker#linker_Click
 * @event
 * @returns		{Boolean}
 */
function linker_Click(e){
	// 동작중이면 컴맨드 버튼은 눌려지지 않는다 
	if( jobControler.hasJob() ){
		alert(getText("message_linker_001", "Please Wait for completing current running job."));
		return false;
	}
	
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_Linker(em);
	
	control.click();
	
	stopPropagation(e);
	
	return true;
};

/**
 * @description	미결
 * @name		Linker#linker_A_Click
 * @event
 * @returns		{Boolean}
 */
function linker_A_Click(e){
	// 동작중이면 컴맨드 버튼은 눌려지지 않는다
	if( jobControler.hasJob() ){
		alert(getText("message_linker_001", "Please Wait for completing current running job."));
		return false;
	}
	
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_Linker(em);
	
	control.click();
	
	stopPropagation(e);
	
	return true;
};

/**
 * @description	미결
 * @name		Linker#linker_KeyDown
 * @event
 * @returns		{Boolean}
 */
function linker_KeyDown(e){
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var wKeyCode = e.keyCode;
	var control = searchControl_Linker(em);

	if( wKeyCode == 9 ){
		if( getShiftKeyPressed(e) ){
			stopEvent(e);
			setTimeout("setFocusToFormerControl(\"" + control.controlName + "\")", 0);
			return true;
		}
		else{
			stopEvent(e);
			setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
			return true;
		}
	}
	else if( wKeyCode == 13 ){
		stopEvent(e);
		control.click();
		setTimeout("setFocusToNextControl(\"" + control.controlName + "\")", 0);
		return true;
	}
	
	stopPropagation(e);
	
	return true;
};
/**
 * @class Iframe 컨트롤 클래스
 * @constructor Iframe Control Class 생성자 함수
 * 
 * @param controlId
 *            해당 컨트롤의 ID를 지정합니다.
 * @param controlName
 *            해당 컨트롤의 Name을 지정합니다.
 * @param tagObject
 *            해당 컨트롤의 태그 객체를 지정합니다.
 * @returns
 * @example var wControl = controls["IFrame_1"] if(wContorl.errMsg !=null){ //객체
 *          생성에 실패하였습니다. 에러처리 코드를 입력해주세요. } //후속코드생략..
 */
function IFrame(controlId, controlName, tagObject){
	this.base = ControlBase;						//부모클래스 지정
	this.base(controlId, controlName, tagObject);	//부모클래스 생성자호출
	
	this.action = "";			//파라메터를 제외한 url 주소
	this.parameters = [];
	this.tagObject = tagObject;
	this.iframe = tagObject.getElementsByTagName("iframe")[0];
	this.passEvent = false;		//사용자 이벤트 동작 여부(true:동작안함 / false:동작함)
	
	if( typeof tagObject != "undefined" ){
		tagObject.setAttribute("tabIndex", "-1");
	}
	
	setEventHandler(this.iframe, "load", IFrame_onload);

	//2016-06-21 : 유비레포트 추가
	this.UB_Report = {};
	this.UB_Report["dirPath"] = "";
	this.UB_Report["fileName"] = "";
	this.UB_Report["directPrint"] = false;
	this.UB_Report["dataSets"] = [];
	this.UB_Report["parameters"] = [];
};

IFrame.prototype = new ControlBase();
/**
 * @description 태그객체의 ID가 Iframe인것을 찾습니다.
 * @param em
 *            {Object} ID를 찾을 element 입니다.
 * @return ID를 반환합니다. , 에러발생시 undefined를 반환합니다.
 */
function searchControl_IFrame(em){
	var pEm = em;
	var image = pEm.getAttribute("image");
	var wReturn = null;
	
//	while (pEm.parentNode && !pEm.className.startsWith("IFrame"))
//		pEm = pEm.parentNode;
//	if( pEm.className.startsWith("IFrame") )
//		wReturn = getControlById(pEm.id);
	
	while(pEm.parentNode && image !== "IFrame"){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}
	
	if( pEm.getAttribute("image") === "IFrame" ){
		wReturn = getControlById(pEm.id);
	}
	else{
		pEm = null;
		pEm = em;
		
		while(pEm.parentNode && !pEm.className.startsWith("IFrame"))
			pEm = pEm.parentNode;
		
		if( pEm.className.startsWith("IFrame") )
			wReturn = getControlById(pEm.id);
	}
	
	image = null;
	pEm = null;
	
	return wReturn;
};

/**
 * @description	미결
 * @param		{String}	actionUrl
 * @return		{Void}
 * @example		미결
 */
IFrame.prototype._init = function(actionUrl){
	this.action = "";
	this.parameters = [];
	
	return;
};

/**
 * @description url값을 넘겨줍니다.
 * @param actionUrl
 *            {String} url값을 담고있습니다.
 * @return 반환값없음.
 * @example controls["Iframe_1"].seUrl(url);
 */
IFrame.prototype.setUrl = function(actionUrl){
	this.setValue(actionUrl);
	
	return;
};
/**
 * @description get방식으로넘어온 url을 post 방식으로 넘겨줍니다.
 * @param actionUrl
 *            {String} url값을 갖고있습니다.
 * @returns {Boolean} 이벤트호출 실패시 undefined를 반환하고, 성공시 undefined를 반환합니다.
 * @example contorls["Iframe"].setValue(url);
 */
IFrame.prototype.setValue = function(actionUrl){
	this._init();
	
	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 콜이벤트 호출
		var checkEvent = false;
		try{
			if( eval(this.id + "_oncall") ) checkEvent = true;
		} catch(e){}

		if( checkEvent ){
			var result = eval(this.id + "_oncall();");
			if( typeof(result)=="boolean" && !result ){
				return false;
			}
		}
	}
	
	// url 분해
	var array1 = decodeURI(actionUrl).split("?");
	var array2 = (array1.length > 1 ? array1[1].split("&") : []);
	
	this.action = array1[0];
	for(var i = 0; i < array2.length; i++) {
		var array3 = array2[i].split("=");
		var paramName = array3[0];
		var paramValue = encodeURIComponent(array3[1]);
		
		this.parameters[i] = new Parameter(paramName, paramValue);
	}
	
	this.moveToPage();
	
	return;
};

/**
 * @description 화면에서 받은 값으로 페이지를 이동시킵니다.
 * @returns {Boolean} 호출성공시 true 를 반환합니다.
 * @example controls["IFrame"].callAction();
 */
IFrame.prototype.callAction = function(){
	this._init();
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 화면에서 파라메터 받기
		var checkEvent = false;
		try{
			if( eval(this.id + "_oncall") ) checkEvent = true;
		} catch(e){}
		
		if( checkEvent ){
			var result = eval(this.id + "_oncall();");
			if( typeof(result)=="boolean" && !result ){
				return false;
			}
		}
	}
	
	this.moveToPage();
	
	return;
};

/**
 * @description 화면에서 받은 값으로 페이지를 이동시킵니다.
 * @returns {Boolean} 호출성공시 true 를 반환합니다.
 * @example controls["IFrame"].callAction();
 */
IFrame.prototype.moveToPage = function(){
	if( !(this.clearInfo()) )
		throw "IFRAME CLEAR FAILED";
	
	this.iframe.doc = null;

	if( this.iframe.contentDocument )		this.iframe.doc = this.iframe.contentDocument;			// Firefox, Opera
	else if( this.iframe.contentWindow )	this.iframe.doc = this.iframe.contentWindow.document;	// Internet Explorer
	else if( this.iframe.document )			this.iframe.doc = this.iframe.document;					// Others?
	
	if( this.iframe.doc == null )
		throw "Document not found, append the parent element to the DOM before creating the this.iframe";
	
	this.iframe.doc.open();
	this.iframe.doc.close();
	
	var frm = this.iframe.doc.createElement("form");
	frm.method ="POST" ;
	frm.name   = frm.id = (new Date()).valueOf();
	frm.action = this.action;
	
	this.iframe.doc.body.appendChild(frm);
	
	//151223 김남용 유비리포트 관련 막음
	//frm.enctype="multipart/form-data";
	
	var params = {};
	var paramsCnt = 0;
	var wControl = null;
	var parameter = null;
	var field = null;
	var value = null;

	for(var key in this.parameters){
		parameter = this.parameters[key];
		
		if( typeof parameter == "function" ){
			parameter = null; key = null;
			continue;
		}
		
		if( typeof parameter != "undefined" && parameter instanceof Parameter ){
			field = parameter.fieldName;
			value = parameter.datas[0];
		}
		else{
			field = "params";
			value = parameter;
		}
		
		if( field == "params" ){
			params[key] = (typeof value == "undefined") ? "" : value;
			paramsCnt++;
		}
		else{
			/*wControl = this.iframe.doc.createElement("input");
			wControl.type = "hidden";
			wControl.id   = wControl.name = field;
			wControl.value = value;
			
			frm.appendChild(wControl);*/
			params[key] = (typeof value == "undefined") ? "" : value;
			paramsCnt++;
		}
		
		value = null; field = null;
		parameter = null; key = null;
	}
	
	if( paramsCnt > 0 ){
		wControl = this.iframe.doc.createElement("input");
		wControl.type = "hidden";
		wControl.id = wControl.name = "params";
		wControl.value = encodeURIComponent(JSON.stringify(params));
		
		frm.appendChild(wControl);
	}
	
	wControl = this.iframe.doc.createElement("input");
	wControl.type = "hidden";
	wControl.id = wControl.name = "tm" ;
	wControl.value = (new Date()).valueOf();
	
	frm.appendChild(wControl);
	
	frm.submit();
	
	return;
};

/**
 * @description	미결
 * @returns		{Boolean}
 * @example		미결
 */
IFrame.prototype.clearInfo = function(){
	try{
		//컨트롤 객체 name 속성 복사
		var controlTagName = this.tagObject.getAttribute("name");

		//레이어팝업의 경우 IFrame을 재생성 하지 않음
		if(controlTagName == "layerPopupIframe")
			return true;
		
		//기존 IFrame 정보 복사
		var ifrm_name = this.iframe.getAttribute("name");
		var ifrm_id = this.iframe.getAttribute("id");
		var ifrm_src = this.iframe.getAttribute("src");			//src = (typeof src == "undefined" || typeof src == null) ? "" : src;
		var ifrm_width = this.iframe.getAttribute("width");
		var ifrm_height = this.iframe.getAttribute("height");
		var ifrm_vspace = this.iframe.getAttribute("vspace");
		var ifrm_hspace = this.iframe.getAttribute("hspace");
		var ifrm_marginwidth = this.iframe.getAttribute("marginwidth");
		var ifrm_marginheight = this.iframe.getAttribute("marginheight");
		var ifrm_frameborder = this.iframe.getAttribute("frameborder");
		var ifrm_scrolling = this.iframe.getAttribute("scrolling");
		
		//IFrame 제거
		this.tagObject.innerHTML = "";
		
		//IFrame 생성
		var ifrm = document.createElement("iframe");
		ifrm.setAttribute("name", ifrm_name);
		ifrm.setAttribute("id", ifrm_id);
		ifrm.setAttribute("src", ifrm_src);
		ifrm.setAttribute("width", ifrm_width);
		ifrm.setAttribute("height", ifrm_height);
		ifrm.setAttribute("vspace", ifrm_vspace);
		ifrm.setAttribute("hspace", ifrm_hspace);
		ifrm.setAttribute("marginwidth", ifrm_marginwidth);
		ifrm.setAttribute("marginheight", ifrm_marginheight);
		ifrm.setAttribute("frameborder", ifrm_frameborder);
		ifrm.setAttribute("scrolling", ifrm_scrolling);
		
		//IFrmae 추가
		this.tagObject.appendChild(ifrm);
		
		//컨트롤 속성 초기화
		this.tagObject = document.getElementsByName(controlTagName)[0];
		this.iframe = this.tagObject.getElementsByTagName("iframe")[0];
		
		setEventHandler(this.iframe, "load", IFrame_onload);

		//2016-06-21: 유비레포트 추가
		this.UB_Report = {};
		this.UB_Report["dirPath"] = "";
		this.UB_Report["fileName"] = "";
		this.UB_Report["directPrint"] = false;
		this.UB_Report["dataSets"] = [];
		this.UB_Report["parameters"] = [];
	}
	catch(e){
		return false;
	}
	
	return true;
};

/**
 * @description	미결
 * @returns		{Boolean}
 * @example		미결
 */
function IFrame_onload(){
	var iFrameId = document.getElementsByName(this.id)[0].parentNode.getAttribute("id");

	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 화면에서 파라메터 받기
		var checkEvent = false;
		try{
			//if (eval(this.id + "_onload")) checkEvent = true;
			if( eval(iFrameId + "_onload") ) checkEvent = true;
		} catch(e){}
		
		if( checkEvent ){
			//var result = eval(this.id + "_onload();");
			var result = eval(iFrameId + "_onload();");
			if( typeof(result)=="boolean" && !result )
				return false;
		}
	}
	
	return true;
};

//2016-06-21: 유비레포트 추가
/**
 * @description	미결
 * @param		{Object}	dirPath
 * @return		{Undefined}
 * @example		미결
 */
IFrame.prototype.setJrfFileDir = function( dirPath ){
	this.UB_Report["dirPath"] = dirPath;
};
/**
 * @description	미결
 * @param		{String}	fileName
 * @retur		{Undefined}
 * @example		미결
 */
IFrame.prototype.setJrfFileName = function( fileName ){
	this.UB_Report["fileName"] = fileName;
};
/**
 * @description	미결
 * @param		{Object}	directPrint
 * @return		{Undefined}
 * @example		미결
 */
IFrame.prototype.setJrfDirectPrint = function( directPrint ){
	this.UB_Report["directPrint"] = directPrint;
};
/**
 * @description	미결
 * @param		{Object}	filePrint
 * @return		{Undefined}
 * @example		미결
 */
IFrame.prototype.setJrfFilePrint = function( filePrint ){
	this.UB_Report["filePrint"] = filePrint;
};
/**
 * @description	미결
 * @param		{Object}	fileType
 * @return		{Undefined}
 * @example		미결
 */
IFrame.prototype.setJrfFileType = function( fileType ){
	this.UB_Report["fileType"] = fileType;
};
/**
 * @description	미결
 * @param		{String}	downloadFileName
 * @return		{Undefined}
 * @example		미결
 */
IFrame.prototype.setJrfDownloadFileName = function( downloadFileName ){
	this.UB_Report["downloadFileName"] = downloadFileName;
};
/**
 * @description	미결
 * @param		{String}	argName
 * @param		{Object}	argValue
 * @return		{Undefined}
 * @example		미결
 */
IFrame.prototype.setArgument = function( argName, argValue ){
	var arg = {};
	arg["name"] = argName;
	arg["value"] = argValue;
	
	this.UB_Report["parameters"].push( arg );
};
/**
 * @description	미결
 * @param		{String}	dsName
 * @param		{Object}	dsObject
 * @return		{Undefined}
 * @example		미결
 */
IFrame.prototype.setDataset = function( dsName, dsObject ){
	var arg = {};
	arg["name"] = dsName;
	arg["value"] = (typeof dsObject == "string") ? dataSets[dsObject] : dsObject;
	
	this.UB_Report["dataSets"].push( arg );
};
/**
 * @description	미결
 * @param		{Object}	closeEventFunction
 * @return		{Boolean}
 * @example		미결
 */
IFrame.prototype.retrieve = function( closeEventFunction ){
	var jrf = "";
	var ubdata = "";
	var arg = "";
	var directprint = false;
	var fileprint = false;
	var filetype = "";
	var downloadFileName = "";
	var i = 0;
	
	//레포트 경로 + 파밍명 추가
	jrf = this.UB_Report["dirPath"] + this.UB_Report["fileName"];
	//레포트 출력 구분 추가
	directprint = this.UB_Report["directPrint"];
	fileprint = this.UB_Report["filePrint"];
	filetype = this.UB_Report["fileType"];
	downloadFileName = this.UB_Report["downloadFileName"];
	
	//데이터셋 추가
	for(i = 0; i < this.UB_Report.dataSets.length; i++){
		ubdata += this.UB_Report.dataSets[i].name + "#" + (this.UB_Report.dataSets[i].value).getTabbedStr() +"#";
	}
	
	//파라메터 추가
	for(i = 0; i < this.UB_Report.parameters.length; i++){
		arg += this.UB_Report.parameters[i].name + "#" + this.UB_Report.parameters[i].value + "#";
	}
	
	var ubiReportInfo = JSON.parse(JSON.stringify( UbiReportPrintInfo));
	ubiReportInfo.controlName = this.controlName;
	ubiReportInfo.jrf = jrf;
	ubiReportInfo.directPrint = directprint;
	ubiReportInfo.filePrint = fileprint;
	ubiReportInfo.fileType = filetype;
	ubiReportInfo.downloadFileName = downloadFileName;
	ubiReportInfo.ubdata = ubdata;
	ubiReportInfo.arg = arg;
	ubiReportInfo.closeFunction = closeEventFunction;
	
	UbiReportPrintQueue.push( ubiReportInfo );
	
	_openUbiReport();
	
//	var agent = navigator.userAgent.toLowerCase();
//
//	if (agent.indexOf("chrome") != -1) {
//		//alert("크롬 브라우저입니다.");
//	 	this.setValue( encodeURI("http://"+REPORT_IP+"/FlexFrame/ubireport/ubiviewer_real.jsp?jrf="+jrf+"&ubdata="+ubdata+"&arg="+arg+"&directprint="+directprint+"&fileprint="+fileprint+"&filetype="+filetype) );
//	 } else {
//		//alert("크롬 브라우저가 아니다.");	
//		var ubiForm = document.ubiForm;
//	 	var url = "http://"+REPORT_IP+"/FlexFrame/ubireport/ubiviewer_real.jsp";
//		if(directprint == "true" || fileprint == "true"){
//			window.open("" ,"ubiForm", "toolbar=no,status=no,menubar=no,scrollbars=no,resizable=no,left=1, top=1, width=1, height=1");
//		}else{
//		 	window.open("" ,"ubiForm", "toolbar=no,scrollbars=yes,resizable=yes,top=0,left=0,width=1024,height=768");
//		}	 	 	
//		ubiForm.action =url; 
//	 	ubiForm.method="post";
//		ubiForm.target="ubiForm";
//	 	ubiForm.jrf.value = jrf;
//	 	ubiForm.ubdata.value = encodeURI(ubdata);
//	 	ubiForm.arg.value = encodeURI(arg);
//	 	ubiForm.directprint.value = directprint;
//	 	ubiForm.fileprint.value = fileprint;
//	 	ubiForm.filetype.value = filetype;
//	 	ubiForm.submit();		
//	 }
};

var UbiReportPrintRunStatus = false;
var UbiReportPrintQueue = [];

UbiReportPrintInfo = {
    controlName : null,   		//레포트 컨트롤 명
    jrf : null,           		//레포트 파일명
    directPrint : null,   		//인쇄창 출력 여부
    filePrint : null,     		//파일 출력 여부
    fileType : null,      		//파일 출력 타입
    downloadFileName : null,	//다운로드 파일명
    ubdata : null,        		//데이터셋 데이터
    arg : null,            		//파라메터 데이터
    closeFunction : null			//close 사용자 함수
}

/**
 * @description	미결
 * @returns		{Boolean}
 * @example		미결
 */
function _existUbiReport(){
	return (UbiReportPrintQueue.length > 0) ? true : false;
};

/**
 * @description	미결
 * @returns		{Boolean}
 * @example		미결
 */
function _openUbiReport(){
	if( !(_existUbiReport()) ){
		return false;
	}
	
	if( UbiReportPrintRunStatus ){
		return false;
	}
	
	UbiReportPrintRunStatus = true;
  
	showAjaxBox(getText("message_framebox_001", "레포트를 출력하는 중입니다."), 0);
  
	var ubiReportInfo = UbiReportPrintQueue[0];
	var agent = navigator.userAgent.toLowerCase();
  
	if (agent.indexOf("chrome") != -1) {
		controls["" + ubiReportInfo.controlName].setValue( encodeURI("http://"+REPORT_IP+"/FlexFrame/ubireport/ubiviewer_real.jsp?jrf="+ubiReportInfo.jrf+"&ubdata="+ubiReportInfo.ubdata+"&arg="+ubiReportInfo.arg+"&directprint="+ubiReportInfo.directPrint+"&fileprint="+ubiReportInfo.filePrint+"&filetype="+ubiReportInfo.fileType+"&fileName="+ubiReportInfo.downloadFileName) );
	}
	else {
		var ubiForm = document.ubiForm;
		var url = "http://"+REPORT_IP+"/FlexFrame/ubireport/ubiviewer_real.jsp";
		
		if(ubiReportInfo.directPrint == "true" || ubiReportInfo.filePrint == "true"){
			window.open("" ,"ubiForm", "toolbar=no,status=no,menubar=no,scrollbars=no,resizable=no,left=1, top=1, width=1, height=1");
		}else{
			window.open("" ,"ubiForm", "toolbar=no,scrollbars=yes,resizable=yes,top=0,left=0,width=1024,height=768");
		}
		
		ubiForm.action =url; 
	 	ubiForm.method="post";
		ubiForm.target="ubiForm";
	 	ubiForm.jrf.value = ubiReportInfo.jrf;
	 	ubiForm.ubdata.value = encodeURIComponent(ubiReportInfo.ubdata);
	 	ubiForm.arg.value = encodeURIComponent(ubiReportInfo.arg);
	 	ubiForm.directprint.value = ubiReportInfo.directPrint;
	 	ubiForm.fileprint.value = ubiReportInfo.filePrint;
	 	ubiForm.filetype.value = ubiReportInfo.fileType;
	 	ubiForm.fileName.value = encodeURIComponent(ubiReportInfo.downloadFileName);
	 	ubiForm.submit();
	}
	
	return true;
};

/**
 * @description	미결
 * @returns		{Boolean}
 * @example		미결
 */
function _closeUbiReport(){
	//alert("_closeUbiReport");
	var closeEventFunction = UbiReportPrintQueue[0].closeFunction;
	
	if(UbiReportPrintQueue.length > 0){
		delete UbiReportPrintQueue[0];
		UbiReportPrintQueue = UbiReportPrintQueue.slice(1);
	}
  
	hideAjaxBox();
  
	UbiReportPrintRunStatus = false;
  
	if( _existUbiReport() ){
		setTimeout( function(){ _openUbiReport(); }, 10 );
		return true;
	}
	else{
		UbiReportPrintQueue.clear();
		delete UbiReportPrintQueue;
		UbiReportPrintQueue = [];
	}
	
	if(closeEventFunction != null){
		setTimeout(function(){ closeEventFunction(); }, 10);
	}
  
	return false;
};
/**
 *   @autor   winnersoft korea
 *   @version 5.0
 *   @see     winnersoft.co.kr
 *   
 * @description 
 *     EasyMaker Vertical Data Sheet For Big Data.
 * 
 * @constructor
 * 
 * @param {string} 	 controlId 	 - 콘트롤 고유 아이디 (영문)
 * @param {string} 	 controlName - 콘트롤 명 (사용자 고유 언어)
 * @param {HTMLNode} tagObject   - HTML 본문중의 매칭되는 HTML DOM Node. 
 * @return {Object} - 생성된 EasySheet 개체
 * @exception 널값 예외
 * 
 * 
 */
function FlashPlayer(controlId, controlName, tagObject){
    this.base = ControlBase;      //부모클래스 지정
    this.base(controlId, controlName, tagObject);         //부모클래스 생성자호출
    this.flashPathUrl = getContextPath() + "/pages/groupware/flashes/";
    this.flashUrl = "";
    this.parameters = [];

    if (tagObject != undefined){
        tagObject.setAttribute("tabIndex", "-1");
    }

    this.tagObject = tagObject;
    this.backColor = this.tagObject.style.backgroundColor;
    this.flashObject = null;
};

FlashPlayer.prototype = new ControlBase();

/**
 * @description	미결
 * @param		{Object}	em
 * @return		{String}
 * @example		미결
 */
function searchControl_FlashPlayer(em){
	var pEm = em;
	var image = pEm.getAttribute("image");
	var wReturn = null;
	
//	while (pEm.parentNode && pEm.className != "FlashPlayer") 
//		pEm = pEm.parentNode;
//	if (pEm.className == "FlashPlayer") 
//	    wReturn = getControlById(pEm.id);
	
	while(pEm.parentNode && image !== "FlashPlayer"){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}
	
	if( pEm.getAttribute("image") === "FlashPlayer" ){
		wReturn = getControlById(pEm.id);
	}
	else{
		pEm = null;
		pEm = em;
		
		while(pEm.parentNode && !pEm.className.startsWith("FlashPlayer"))
			pEm = pEm.parentNode;
		
		if( pEm.className.startsWith("FlashPlayer") ) 
			wReturn = getControlById(pEm.id);
	}
	
	image = null;
	pEm = null;
	
	return wReturn;
};
/**
 * @description	미결
 * @param		{object}	actionUrl
 * @return  	{void}
 * @example		미결
 */
FlashPlayer.prototype._init = function(actionUrl){
    this.parameters = [];
	return;
};

/**
 * @description	미결
 * @return  	{void}
 * @example		미결
 */
FlashPlayer.prototype.callMovie = function(){
	this._init();

	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 콜이벤트 호출
		var checkEvent = false;
		try {
	    	if (eval(this.id + "_oncall")) checkEvent = true;
	    } catch(e){}
	    
	    if (checkEvent){
		   var result = eval(this.id + "_oncall();");
	       if (typeof(result)=="boolean" && !result) {
	    	   return false;
	       }
	    }
	}

    var wParams = "";
    for (var wKey in this.parameters){
    	if (this.parameters[wKey] instanceof Function) continue;
    	wParams += (wParams.length == 0 ? "?" : "&");
    	wParams += wKey + "=" + encodeURIComponent(this.parameters[wKey]);
    }
	
    var wHTML = "<object classid='clsid:D27CDB6E-AE6D-11cf-96B8-444553540000'" 
    		        + "  codebase='http://active.macromedia.com/flash2/cabs/swflash.cab#version=4,0,0,0'"
    		        + "  width='100%' height='100%'>"
    		        + " <param name='movie' value='" + this.flashPathUrl + this.flashUrl + wParams + "'>"
    		        + " <param name='quality' value='high'>" 
    		        + " <param name='play' value='false'>" 
    		        + " <param name='wmode' value='transparent'>"
    		        + " <embed play='false' " 
    		        + "        swliveconnect='true' " 
    		        + "        src='" + this.flashPathUrl + this.flashUrl + wParams + "' " 
    		        + "        quality='high' " 
    		        + "        wmode='transparent'"
    		        + "        width='100%' height='100%'" 
    		        + "        type='application/x-shockwave-flash'"  
    	            + "        pluginspage='http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash'> </embed>" 
    	      + "</object>"; 

	
    this.tagObject.innerHTML = wHTML;
	
    if (BrowserDetect.browser == "Explorer"){
        this.flashObject = this.tagObject.getElementsByTagName("OBJECT")[0];
    } else {
        this.flashObject = this.tagObject.getElementsByTagName("EMBED")[0];
    }
    
    this.flashObject.Play();
	
	return;
};
/**
 * @description	미결
 * @return  	{void}
 * @example		미결
 */
FlashPlayer.prototype.stop = function(){
	this.flashObject.StopPlay();
	return;
};
/**
 * @description	미결
 * @return  	{void}
 * @example		미결
 */
FlashPlayer.prototype.play = function(){
	this.flashObject.Play();
	//embed.nativeProperty.anotherNativeMethod();
	return;
};
/**
 * @description	미결
 * @return  	{void}
 * @example		미결
 */
FlashPlayer.prototype.rewind = function(){
	this.flashObject.Rewind();
	return;
};
/**
 * @description	미결
 * @return  	{void}
 * @example		미결
 */
FlashPlayer.prototype.next = function(){
	// 4 is the index of the property for _currentFrame
	// "/" is target
	var currentFrame=this.flashObject.TGetProperty("/", 4);
	var nextFrame=parseInt(currentFrame);
	if (nextFrame>=10)
		nextFrame=0;
	this.flashObject.GotoFrame(nextFrame);		
	return;
};
/**
 * @description	미결
 * @return  	{void}
 * @example		미결
 */
FlashPlayer.prototype.zoomIn = function(){
	this.flashObject.Zoom(90);
	return;
};
/**
 * @description	미결
 * @return  	{void}
 * @example		미결
 */
FlashPlayer.prototype.zoomOut = function(){
	this.flashObject.Zoom(110);
	return;
};
/**
 * @description	미결
 * @param		{object}	variable
 * @param		{object}	value
 * @return  	{void}
 * @example		미결
 */
FlashPlayer.prototype.setValue = function(variable, value){
	this.sendData(variable, value);
	return;
};
/**
 * @description	미결
 * @param		{object}	variable
 * @param		{object}	value
 * @return  	{void}
 * @example		미결
 */
FlashPlayer.prototype.sendData = function(variable, value){
	this.flashObject.SetVariable(variable, value);
	try {this.flashObject.updatePlayer();} catch (e){} //프래시 6.0.65+
	return;
};
/**
 * @description	미결
 * @param		{object}	variable
 * @return  	{object}
 * @example		미결
 */
FlashPlayer.prototype.getValue = function(variable){
	return this.receiveData(variable);
};
/**
 * @description	미결
 * @param		{object}	variable
 * @return  	{object}
 * @example		미결
 */
FlashPlayer.prototype.receiveData = function(variable){
	return this.flashObject.GetVariable(variable);
};
/**
 * @description	미결
 * @return  	{object}
 * @example		미결
 */
FlashPlayer.prototype.isPlaying = function(){
	return this.flashObject.IsPlaying();
};
/**
 * @description	미결
 * @return  	{object}
 * @example		미결
 */
FlashPlayer.prototype.percentLoaded = function(){
	return this.flashObject.PercentLoaded();
};
/**
 * @description	미결
 * @return  	{object}
 * @example		미결
 */
FlashPlayer.prototype.totalFrames = function(){
	return this.flashObject.TotalFrames();
};

/**
 * @name		FlashPlayer#FlashPlayer_OnProgress
 * @event
 * @description 미결
 */
function FlashPlayer_OnProgress(e){
	var e=arguments[0] || window.event;
};
/**
 * @name		FlashPlayer#FlashPlayer_OnReadyStateChange
 * @event
 * @description 미결
 */
function FlashPlayer_OnReadyStateChange(e){
	var e=arguments[0] || window.event;
	
};
/**
 * @name		FlashPlayer#FlashPlayer_DoFSCommand
 * @event
 * @description 미결
 */
function FlashPlayer_DoFSCommand(command, args){
	var e=arguments[0] || window.event;
	
};
/**
 * @description	미결
 * @param		{object}	variable
 * @param		{object}	value
 * @return  	{void}
 * @example		미결
 */
FlashPlayer.prototype.setParameter = function(variable, value){
	this.parameters[variable] = value;
	return;
};
//1.생성자 tagObject.onXXXX = fuinctio onXXXX 만든다 ...
//2.function 에서 이벤트 캐취는 event.사용할값으로 캐취...
//3.eval실시간 컴파일해서 이벤트 체크...후 이벤트 실행...
//상수
var PROGRESSBAR_TORIGHT = 0;
var PROGRESSBAR_TOLEFT = 1;
var PROGRESSBAR_TOTOP = 2;
var PROGRESSBAR_TOBOTTOM = 3;

/**
 * @class ProgressBar 프로그레스바
 * @description ControlBase를 상속받고 해당컨트롤 최소값, 최대값, 증분값, 진행방향 의 기본값을 설정 합니다.
 * @return 반환값 없음
 * @param {string}
 *            controlId 해당 컨트롤의 ID
 * @param {string}
 *            controlName 해당 컨트롤의 Name
 * @param {string}
 *            tagObject 해당 컨트롤의 태그 속성을 설정하는 객체
 * @property {number} PROGRESSBAR_TORIGHT 프로그래스바 진행방향 설정 상수(0 : 오른쪽)
 * @property {number} PROGRESSBAR_TOLEFT 프로그래스바 진행방향 설정 상수(1 : 왼쪽)
 * @property {number} PROGRESSBAR_TOTOP 프로그래스바 진행방향 설정 상수(2 : 위쪽)
 * @property {number} PROGRESSBAR_TOBOTTOM 프로그래스바 진행방향 설정 상수(3 : 아래쪽)
 * @property {number} value 프로그레스바의 채울 값
 * @property {number} direction 프로그레스바의 진행방향
 * @property {number} min 프로그레스바의 최소값
 * @property {number} max 프로그레스바의 최대값
 * @property {number} step 프로그레스바의 증분값
 */
function ProgressBar(controlId, controlName, tagObject){
	this.base = ControlBase;						//부모클래스 지정
	this.base(controlId, controlName, tagObject);	//부모클래스 생성자호출
	this.value		= 0;
	this.style		= "ProgressBar";
	this.tabindex	= 0;
	this.tabstop	= 0;
	
	this.bkcolor	= "#FFFFFF";
	this.barcolor	= "#0000FF";
	
	this.direction = 0;
	if( tagObject.getAttribute("direction") != null ){
		this.direction = parseInt(tagObject.getAttribute("direction"));
	}
	
	this.min = 0;
	if( tagObject.getAttribute("min") != null ){
		var _min = parseInt(tagObject.getAttribute("min"));
		if( !isNaN(_min) )
			this.min = parseInt(tagObject.getAttribute("min"));
	}
	
	this.max = 100;
	if( tagObject.getAttribute("max") != null ){
		var _max = parseInt(tagObject.getAttribute("max"));
		if( !isNaN(_max) )
			this.max = parseInt(tagObject.getAttribute("max"));
	}
	
	this.step = 10;
	if( tagObject.getAttribute("step") != null ){
		var _step = parseInt(tagObject.getAttribute("step"));
		if( !isNaN(_step) )
			this.step = parseInt(tagObject.getAttribute("step"));
	}
	
	if( typeof tagObject != "undefined" ){
		tagObject.setAttribute("tabIndex", "-1");
	}
	
	// 자체 이벤트 선언부 
	this.hasClickEvent = false; this.fncClickEvent = null;
	this.hasClickEvent = (typeof self[this.controlId + "_onclick"] != "undefined");
	if( this.hasChangeEvent )
		this.fncClickEvent = (typeof self[this.controlId + "_onclick"] != "undefined");
	
	this.hasFocusEvent = false; this.fncFocusEvent = null;
	this.hasFocusEvent = (typeof self[this.controlId + "_onfocus"] != "undefined");
	if( this.hasFocusEvent )
		this.fncFocusEvent = new Function("return function(){ return " + this.controlId + "_onfocus(); }")();
	
	this.hasBlurEvent = false; this.fncBlurEvent = null;
	this.hasBlurEvent = (typeof self[this.controlId + "_onfocusout"] != "undefined");
	if( this.hasBlurEvent )
		this.fncBlurEvent = new Function("return function(){ return " + this.controlId + "_onfocusout(); }")();
	
	var childDIV = tagObject;
	setEventHandler(childDIV, "click", ProgressBar_onclick, false);
	setEventHandler(childDIV, "focus", ProgressBar_onfocus, false);
	setEventHandler(childDIV, "blur", ProgressBar_onfonblur, false);
};

ProgressBar.prototype = new ControlBase();

/**
 * @description 엘리먼트 값으로 해당 컨트롤을 찾아서 ID값을 반환합니다.
 * @param       em        해당 태그객체
 * @return      {string}  wReturn 해당 컨트롤의 ID값 반환
 */
function searchControl_ProgressBar(em){
	var pEm = em;
	var image = pEm.getAttribute("image");
	var wReturn = null;
	
//	while (pEm.parentNode && !pEm.className.startsWith("ProgressBar"))
//		pEm = pEm.parentNode;
//	if (pEm.className.startsWith("ProgressBar"))
//		wReturn = getControlById(pEm.id);
	
	while(pEm.parentNode && image !== "ProgressBar"){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}
	
	if( pEm.getAttribute("image") === "ProgressBar" ){
		wReturn = getControlById(pEm.id);
	}
	else{
		pEm = null;
		pEm = em;
		
		while(pEm.parentNode && !pEm.className.startsWith("ProgressBar"))
			pEm = pEm.parentNode;
		
		if( pEm.className.startsWith("ProgressBar") )
			wReturn = getControlById(pEm.id);
	}
	
	image = null;
	pEm = null;
	
	return wReturn;
};

/////////////////// set관련 셋팅 오른쪽 , 왼쪽 , 아래 , 위 ///////////////////
/**
 * @description setDirection 프로그레스바의 스텝 증분값 진행 방향 설정 후 setValue 함수를 실행합니다.(오른쪽,
 *              왼쪽, 아래, 위)
 * @param       {number} pDirection 바의 증분값 진행 방향
 * @return      반환값 없음
 */
ProgressBar.prototype.setDirection = function(pDirection){
	this.direction = pDirection;
	this.setValue(this.value);
	
	return;
};

/**
 * @description 프로그레스바의 스텝 최소값을 설정합니다.
 * @param       {number}  pMin 스텝 최소값
 * @return      반환값 없음
 */
ProgressBar.prototype.setMin = function(pMin){
	this.min = pMin;
	
	return;
};

/**
 * @description 프로그레스바의 스텝 최대값을 설정합니다.
 * @param       {number} pMax 스텝 최대값
 * @return      반환값 없음
 */
ProgressBar.prototype.setMax = function(pMax){
	this.max = pMax;
	
	return;
};

/**
 * 
 * @description 프로그레스바에 설정된 값을 넣습니다.<br>
 *              Max값 이상이면 오류메시지 출력후 false를 리턴합니다.<br>
 *              onchange 이벤트를 실행
 * @param       {number} pValue
 * @return      반환값 없음
 */
ProgressBar.prototype.setValue = function(pValue){
	if( pValue > this.max ){
		alert(getText("message_progressbar_001", "프로그래스바의 값이 {0}를 초과할수 없습니다.", [this.max]));
		return false;
	}
	
	if(this.value != pValue){
		var checkEvent = false;
		try {
			if (eval(this.controlId + "_onchange")) checkEvent = true;
		} catch(err){}
		
		if (checkEvent){
			var result = eval(this.controlId + "_onchange(this.value, pValue);");
			if( typeof(result)=="boolean" && !result )
				return false;
		}
	}
	
	this.value = pValue;
	
	var pro = (pValue - this.min) / (this.max - this.min);
	
	var width = getComputedStyleSize(this.tagObject).width;
	if( width.endsWith('px') ) width = width.substring(0, width.length - 2);
	var parentWidth = width;
	
	var height = getComputedStyleSize(this.tagObject).height;
	if( height.endsWith('px') ) height = height.substring(0, height.length - 2);
	var parentHeight = height;
	
	var left = 0;
	var top = 0;
	
	// 초기값은 value값
	if( this.direction == PROGRESSBAR_TORIGHT ){
		width = pro * parseInt(width);
		//this.tagObject.getElementsByTagName("DIV")[0].style.width = width+'px';
		//this.tagObject.getElementsByTagName("DIV")[0].style.left  = '1px';
		this.tagObject.getElementsByTagName("DIV")[0].style.width	= Math.round(((parentWidth - (parentWidth - width)) / parentWidth) * 100) + '%';
		this.tagObject.getElementsByTagName("DIV")[0].style.left	= '0px';
	}
	else if( this.direction == PROGRESSBAR_TOLEFT ){
		width = pro * parseInt(width);
		left = parentWidth - width;
		//this.tagObject.getElementsByTagName("DIV")[0].style.width = width+'px';
		//this.tagObject.getElementsByTagName("DIV")[0].style.left  = (left-1)+'px';
		this.tagObject.getElementsByTagName("DIV")[0].style.width	= Math.round(((parentWidth - (parentWidth - width)) / parentWidth) * 100) + '%';
		this.tagObject.getElementsByTagName("DIV")[0].style.left	= (left - 1) + '%';
	}
	else if( this.direction == PROGRESSBAR_TOTOP ){
		height = pro * parseInt(height);
		top = parentHeight - height;
		//this.tagObject.getElementsByTagName("DIV")[0].style.height= height + 'px';
		//this.tagObject.getElementsByTagName("DIV")[0].style.top	= (top - 1) + 'px';
		this.tagObject.getElementsByTagName("DIV")[0].style.height	= height + 'px';
		this.tagObject.getElementsByTagName("DIV")[0].style.top		= top + 'px';
	}
	else if( this.direction == PROGRESSBAR_TOBOTTOM ){
		height = pro * parseInt(height);
		//this.tagObject.getElementsByTagName("DIV")[0].style.top = '1px';      
		this.tagObject.getElementsByTagName("DIV")[0].style.top		= '0px';
		this.tagObject.getElementsByTagName("DIV")[0].style.height	= height + 'px';
	}
	
	return;
};

ProgressBar.prototype.setTabStop = function(pTabStop){
	return;
};

ProgressBar.prototype.setStep = function(pStep){
	return;
};

ProgressBar.prototype.setTabIndex = function(pTabIndex){
	return;
};

ProgressBar.prototype.setStyle = function(pStyle){
	return;
};

/**
 * @description 채우기색을 설정합니다.
 * @param       {string} pBackColor
 * @return      반환값 없음
 */
ProgressBar.prototype.setBackColor = function(pBackColor){
	this.bkcolor = pBackColor;
	getComputedStyleSize(this.tagObject).background = pBackColor;
	return;
};

ProgressBar.prototype.setForeColor= function(pForeColor){
	this.barcolor = pForeColor;
	this.tagObject.getElementsByTagName("DIV")[0].style.background = pForeColor; 
	return;
};

/////////////////// get관련 셋팅 ///////////////////
ProgressBar.prototype.getDirection = function(){
	return this.direction;
};

ProgressBar.prototype.getMin = function(){
	return this.min;
};

ProgressBar.prototype.getMax = function(){
	return this.max;
};

ProgressBar.prototype.getValue = function(){
	return this.value;
};

ProgressBar.prototype.getTabStop = function(){
	return this.tabstop;
};

ProgressBar.prototype.getStep = function(){
	return this.step;
};

ProgressBar.prototype.getBackColor = function(){
    return this.bkcolor ;
};

ProgressBar.prototype.getForeColor = function(){
    return this.barcolor;
};

ProgressBar.prototype.getStyle = function(){
	return this.style;
};

ProgressBar.prototype.getTabIndex = function(){
	return this.tabindex;
};

/**
 * @description setValue 메소드를 호출하여 프로그레스바를 다시 실행합니다.
 * @return      반환값 없음
 */
ProgressBar.prototype.redraw = function(){
	return this.setValue(this.value);
};

/**
 * @description 컨트롤의 위치와 크기를 다시 설정합니다.
 * @param       {number} pLeft 컨트롤 좌측위치
 * @param       {number} pTop 컨트롤 상단위치
 * @param       {number} pWidth 컨트롤 가로길이
 * @param       {number} pHeight 컨트롤 세로길이
 * @return      반환값 없음
 */
ProgressBar.prototype.moveWindow = function(pLeft, pTop, pWidth, pHeight){    
	this.height = pHeight;
	getComputedStyleSize(this.tagObject).height = (pHeight + 2) + 'px';
	this.tagObject.getElementsByTagName("DIV")[0].style.height = pHeight + 'px';
	
	this.width = pWidth;
	getComputedStyleSize(this.tagObject).width = pWidth+2;
	this.tagObject.getElementsByTagName("DIV")[0].style.width = pWidth + 'px';
	
	this.left = pLeft;
	getComputedStyleSize(this.tagObject).left = pLeft + 'px';
	
	this.top = pTop;
	getComputedStyleSize(this.tagObject).top = pTop;
	
	return true;
};

ProgressBar.prototype.focus= function(){
    /*외각선을 진하게*/
    return;
};
ProgressBar.prototype.blur= function(){
    /*외각선을 원상복귀*/
    return;
};

ProgressBar.prototype.steplt= function(){
    this.value += this.step;
    this.setValue(this.value);
    return true;
};

//이벤트 onclick()
/**
 * @name        ProgressBar#ProgressBar_onclick
 * @event
 * @description 프로그레스바 클릭시 발생하는 이벤트 입니다.
 */
function ProgressBar_onclick(e){
	var evt = window.event || e;
	
	// passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		// 사용자 코딩 추가영역을 호출한다
		if( this.hasClickEvent ){
			var result = this.fncClickEvent(evt.button);
			if( result === false )
				return false;
		}
	}
	
	return true;
};

//이벤트 onfocus()
/**
 * @name        ProgressBar#ProgressBar_onfocus
 * @event
 * @description 프로그레스바 가 포커스를 얻었을때 발생하는 이벤트 입니다.
 */
function ProgressBar_onfocus(e){
	var evt = window.event || e;
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		if( this.hasFocusEvent ){
			var result = this.fncFocusEvent();
			if( result === false )
				return false;
		}
	}
	
	return true;
};

//이벤트 onkillfocus()
/**
 * @name        ProgressBar#ProgressBar_onfonblur
 * @event
 * @description 포커스가 프로그레스바에서 다른 컨트롤로 이동 했을때 발생하는 이벤트 입니다.
 */
function ProgressBar_onfonblur(e){
	var evt = window.event || e;
	
	//passEvent 가 true 라면 사용자 이벤트를 호출하지 않는다
	if( !this.passEvent ){
		if( this.hasBlurEvent ){
			var result = this.fncBlurEvent();
			if( result === false )
				return false;
		}
	}
	
	return true;
};var UPDOWN_DIRECTION = {
	UPDOWN_NS : 1
	, UPDOWN_UD : 1
	, UPDOWN_WE : 2
	, UPDOWN_LR : 2
};

/**
 * @class UpDown를 만들어주는 클래스
 * @param {String} controlId Control의 id를 입니다.
 * @param {String} controlName Control의 name을 입니다.
 * @param {Object} tagObject 태그객체 입니다.
 * @example 미결
 */
function UpDown(controlId, controlName, tagObject){
	this.base = ControlBase;						//부모클래스 지정
	this.base(controlId, controlName, tagObject);	//부모클래스 생성자호출
	
	//상수
	
	//속성
	this.direction = UPDOWN_DIRECTION.UPDOWN_UD;	/* UPDOWN_NS:수직 / UPDOWN_WE:수평 */
	this.min = -99999999;
	this.max = 99999999;
	this.step = 1;
	this.linkControlId = "";
	
	if( typeof tagObject != "undefined" ){
		tagObject.setAttribute("tabIndex", "-1");
		
		if( tagObject.getAttribute("min") != null )
			this.min = parseInt(tagObject.getAttribute("min"));
		
		if( tagObject.getAttribute("max") != null )
			this.max = parseInt(tagObject.getAttribute("max"));
		
		if( tagObject.getAttribute("step") != null )
			this.step = parseInt(tagObject.getAttribute("step"));
		
		if( tagObject.getAttribute("linkedcontrolid") != null )
			this.linkControlId = tagObject.getAttribute("linkedcontrolid");
		
		this.moveWindow();
		
		var childClass = ["DirectArrow_Up", "DirectArrow_Down", "DirectArrow_Left", "DirectArrow_Right"];
		var childDiv = null;
		var i = 0;
		
		for(i = 0; i < childClass.length; i++){
			childDiv = this.tagObject.getElementsByClassName(childClass[i])[0];
			
			if( typeof childDiv != "undefined" ){
				setEventHandler(childDiv, "mousedown", upDown_MouseDown);
				setEventHandler(childDiv, "mouseup", upDown_MouseUp);
				setEventHandler(childDiv, "mouseout", upDown_MouseOut);
			}
			
			childDiv = null;
		}
		
		childDiv = null;
		childClass = null;
	}
	
//	// 자체 이벤트 선언부 
//	this.hasMouseDownEvent = false; this.fncMouseDownEvent = null;
//	this.hasMouseDownEvent = (typeof self[this.controlId + "_onmousedown"] != "undefined");
//	if( this.hasMouseDownEvent ){
//		this.fncMouseDownEvent = new Function("return function(){ return " + this.controlId + "_onmousedown(); }")();
//	}
//	
//	this.hasMouseUpEvent = false; this.fncMouseUpEvent = null;
//	this.hasMouseUpEvent = (typeof self[this.controlId + "_onmouseup"] != "undefined");
//	if( this.hasMouseUpEvent ){
//		this.fncMouseUpEvent = new Function("return function(){ return " + this.controlId + "_onmouseup(); }")();
//	}
//	
//	this.hasMouseOutEvent = false; this.fncMouseOutEvent = null;
//	this.hasMouseOutEvent = (typeof self[this.controlId + "_onmouseout"] != "undefined");
//	if( this.hasMouseOutEvent ){
//		this.fncMouseOutEvent = new Function("return function(){ return " + this.controlId + "_onmouseout(); }")();
//	}
};

UpDown.prototype = new ControlBase();

/**
 * @description	미결
 * @param		{Object}	em
 * @return		{String}
 * @example		미결
 */
function searchControl_UpDown(em){
	var pEm = em;
	var image = pEm.getAttribute("image");
	var wReturn = null;
	
//	while(pEm.parentNode && !pEm.className.startsWith("UpDown")) 
//		pEm = pEm.parentNode;
//	if( pEm.className.startsWith("UpDown") )
//		wReturn = getControlById(pEm.id);
	
	while(pEm.parentNode && image !== "UpDown"){
		pEm = pEm.parentNode;
		image = pEm.getAttribute("image");
	}

	if( pEm.getAttribute("image") === "UpDown" ){
		wReturn = getControlById(pEm.id);
	}
	else{
		pEm = null;
		pEm = em;
		
		while(pEm.parentNode && !pEm.className.startsWith("UpDown"))
			pEm = pEm.parentNode;
		
		if( pEm.className.startsWith("UpDown") )
			wReturn = getControlById(pEm.id);
	}

	image = null;
	pEm = null;
	
	return wReturn;
};

/**
 * @description	미결
 * @param		{number}	pStep
 * @return		{void}
 * @example		미결
 */
UpDown.prototype.setStep = function(pStep){
	// functionname : [UpDown.setStep]
	
	this.step = pStep;
};

/**
 * @description	미결
 * @param		{number}	pMax
 * @return		{void}
 * @example		미결
 */
UpDown.prototype.setMax = function(pMax){
	// functionname : [UpDown.setMax]
	
	this.max = pMax;
};

/**
 * @description	미결
 * @param		{number}	pMin
 * @return		{void}
 * @example		미결
 */
UpDown.prototype.setMin = function(pMin){
	// functionname : [UpDown.setMin]
	
	this.min = pMin; 
};

UpDown.prototype.setDirection = function(pDirection){
	// functionname : [UpDown.setDirection]
	
	this.direction = pDirection;
	this.redrawButton(pDirection);
};

/**
 * @description	미결
 * @param		{object}	pLinkControlId
 * @return		{void}
 * @example		미결
 */
UpDown.prototype.setLinkControlId = function(pLinkControlId){
	// functionname : [UpDown.setLinkControlId]
	
	this.linkControlId = pLinkControlId;
};

/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
UpDown.prototype.getStep = function(){
	// functionname : [UpDown.getStep]
	
	return this.step;
};

/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
UpDown.prototype.getMax = function(){
	// functionname : [UpDown.getMax]
	
	return this.max;
};

/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
UpDown.prototype.getMin = function(){
	// functionname : [UpDown.getMin]
	
	return this.max;
};

UpDown.prototype.getDirection = function(){
	// functionname : [UpDown.getDirection]
	
	return this.direction;
};

/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
UpDown.prototype.getLinkControlId = function(){
	// functionname : [UpDown.getLinkControlId]
	
	return this.linkControlId;
};

/**
 * @description	미결
 * @param		{object}	pLeft
 * @param		{object}	pTop
 * @param		{object}	pWidth
 * @param		{object}	pHeight
 * @return		{void}
 * @example		미결
 */
UpDown.prototype.moveWindow = function(pLeft, pTop, pWidth, pHeight){
	// functionname : [UpDown.moveWindow]
	
	if( this.tagObject != null && typeof this.tagObject != "undefined" ){
		//입력된 파라메터가 없는 경우
		if( this.linkControlId != null && typeof this.linkControlId == "string" ){
			var linkedControl = document.getElementById(this.linkControlId);
			var linkedControlStyle = null;
			var linkedControlTop = 0;
			var linkedControlLeft = 0;
			var linkedControlWidth = 0;
			var linkedControlHeight = 0;
			
			if( linkedControl != null ){
				linkedControlStyle = getComputedStyle(linkedControl);
				
				linkedControlTop = linkedControlStyle.top;
				linkedControlTop = (typeof linkedControlTop == "undefined") ? 0 : 1 * (("" + linkedControlTop).replace("px", ""));
				linkedControlLeft = linkedControlStyle.left;
				linkedControlLeft = (typeof linkedControlLeft == "undefined") ? 0 : 1 * (("" + linkedControlLeft).replace("px", ""));
				//linkedControlWidth = linkedControlStyle.width;
				linkedControlWidth = linkedControl.offsetWidth;
				linkedControlWidth = (typeof linkedControlLeft == "undefined") ? 0 : 1 * (("" + linkedControlWidth).replace("px", ""));
				//linkedControlHeight = linkedControlStyle.height;
				linkedControlHeight = linkedControl.offsetHeight;
				linkedControlHeight = (typeof linkedControlHeight == "undefined") ? 0 : 1 * (("" + linkedControlHeight).replace("px", ""));
				
				this.tagObject.style.top = linkedControlTop + "px";
				this.tagObject.style.left = (linkedControlLeft + linkedControlWidth) + "px";
				this.tagObject.style.height = linkedControlHeight + "px";
			}
			
			/**
			 * 2019-04-11 jaeik Chrome,Safari,Opera브라우저 이면서 
			 * 상하: 높이/2가 소수점이면 높이 재설정
			 * 좌우: 너비/2가 소수점이면 너비 재설정
			 */
			if (BrowserDetect.browser == "Chrome" || BrowserDetect.browser == "Safari" || BrowserDetect.browser == "Opera") {
				var num_check = /^[0-9]*$/;
				if (this.tagObject.getElementsByClassName("DirectArrow_Up")[0] != null) {
						var arrowHeight = this.tagObject.offsetHeight / 2;
						if (!num_check.test(arrowHeight)) {
								this.tagObject.getElementsByClassName("DirectArrow_Down")[0].style.height = parseInt(arrowHeight) + "px";
						}
				} else {
						var arrowWidth = this.tagObject.offsetWidth / 2;
						if (!num_check.test(arrowWidth))
							this.tagObject.getElementsByClassName("DirectArrow_Right")[0].style.width = parseInt(arrowWidth) + "px";
				}
			}
			
			//메모리 초기화
			linkedControlStyle = null;
			linkedControl = null;
		}
		//입력된 파라메터가 있는 경우
		else{
			//Left
			if( pLeft != null && typeof pLeft != "undefined" ){
				if( /^\d+$/.test(pLeft) )
					this.tagObject.style.left = pLeft + "px";
				else if( (/^\d+px$/.test(pLeft)) || (/^\d+%$/.test(pLeft)) )
					this.tagObject.style.left = pLeft;
			}
			//Top
			if( pTop != null && typeof pTop != "undefined" ){
				if( /^\d+$/.test(pTop) )
					this.tagObject.style.top = pTop + "px";
				else if( (/^\d+px$/.test(pTop)) || (/^\d+%$/.test(pTop)) )
					this.tagObject.style.top = pTop;
			}
			//Width
			if( pWidth != null && typeof pWidth != "undefined" ){
				if( /^\d+$/.test(pWidth) )
					this.tagObject.style.width = pWidth + "px";
				else if( (/^\d+px$/.test(pWidth)) || (/^\d+%$/.test(pWidth)) )
					this.tagObject.style.width = pWidth;
			}
			//Height
			if( pHeight != null && typeof pHeight != "undefined" ){
				if( /^\d+$/.test(pHeight) )
					this.tagObject.style.height = pHeight + "px";
				else if( (/^\d+px$/.test(pHeight)) || (/^\d+%$/.test(pHeight)) )
					this.tagObject.style.height = pHeight;
			}
		}
	}
	
	return;
};

/**
 * @description	미결
 * @param		{object}	pOrientation
 * @return		{void}
 * @example		미결
 */
UpDown.prototype.redrawButton = function(pDirection){
	// functionname : [UpDown.redrawButton]
	
	// 방향 : 동서/좌우
	if( pDirection == UPDOWN_DIRECTION.UPDOWN_WE || pDirection == UPDOWN_DIRECTION.UPDOWN_LR ){
		var upDiv = this.tagObject.getElementsByClassName("DirectArrow_Up")[0];
		if( upDiv != null || typeof upDiv != "undefined" ){
			upDiv.setAttribute("class", "DirectArrow_Left");
			upDiv.getElementsByTagName("div")[0].innerText = "&#xe86e";
		}
		
		var downDiv = this.tagObject.getElementsByClassName("DirectArrow_Down")[0];
		if( downDiv != null || typeof downDiv != "undefined" ){
			downDiv.setAttribute("class", "DirectArrow_Right");
			downDiv.getElementsByTagName("div")[0].innerText = "&#xe86f";
		}
		
		//메모리 해제
		downDiv = null;
		upDiv = null;
	}
	// 방향 : 남북/위아래
	else{
		var leftDiv = this.tagObject.getElementsByClassName("DirectArrow_Left")[0];
		leftDiv.setAttribute("class", "DirectArrow_Up");
		leftDiv.getElementsByTagName("div")[0].innerText = "&#xe86d";
		
		var rightDiv = this.tagObject.getElementsByClassName("DirectArrow_Right")[0];
		rightDiv.setAttribute("class", "DirectArrow_Down");
		rightDiv.getElementsByTagName("div")[0].innerText = "&#xe86c";
		
		//메모리 해제
		leftDiv = null;
		rightDiv = null;
	}
	
	// 버튼 이동
	if( this.linkControlId != null && typeof this.linkControlId == "string" ){
		this.moveWindow();
	}
	
	return;
};

/**
 * @description	미결
 * @return		{void}
 * @example		미결
 */
UpDown.prototype.up = function(){
	// functionname : [UpDown.up]
	
	var linkedControl = null;
	var linkedControlName = null;
	var value = null;
	
	if( this.linkControlId != null && typeof this.linkControlId == "string" ){
		linkedControl = document.getElementById(this.linkControlId);
		if (linkedControl != null) {
				linkedControlName = linkedControl.getAttribute("ctlname");
		
				if( linkedControlName != null && typeof linkedControlName == "string" && linkedControlName.length > 0 ){
					value = parseInt(controls[linkedControlName].value*1);
					
					if( !isNaN(value) ){
						value = value + parseInt(this.step);
						value = (this.max > value) ? value : this.max;
						
						controls[linkedControlName].setValue(value);
					}
				}
		}
		
		value = null;
		linkedControlName = null;
		linkedControl = null;
	}
	
	return;
};

/**
 * @description	미결
 * @return		{void}
 * @example		미결
 */
UpDown.prototype.down = function(){
	// functionname : [UpDown.down]
	
	var linkedControl = null;
	var linkedControlName = null;
	var value = null;
	
	if( this.linkControlId != null && typeof this.linkControlId == "string" ){
		linkedControl = document.getElementById(this.linkControlId);
		if (linkedControl != null) {
				linkedControlName = linkedControl.getAttribute("ctlname");
		
				if( linkedControlName != null && typeof linkedControlName == "string" && linkedControlName.length > 0 ){
					value = parseInt(controls[linkedControlName].value);
					
					if( !isNaN(value) ){
						value = value - parseInt(this.step);
						value = (this.min < value) ? value : this.min;
						
						controls[linkedControlName].setValue(value);
					}
				}
		}
		
		value = null;
		linkedControlName = null;
		linkedControl = null;
	}
	
	return;
};

/**
 * @description	미결
 * @return		{undefined}
 * @example		미결
 */
UpDown.prototype.setfocus = function(){
	// functionname : [UpDown.setfocus]
	
	this.tagObject.focus();
};

function upDownChangeLinkedControl(){
	if( !self._updownMouseDown )
		return false;
	
	var className = self._updownDirection;
	
	//증가(방향 : 위, 오른쪽)
	if( typeof className == "string" && (className.indexOf("DirectArrow_Up") >= 0 || className.indexOf("DirectArrow_Right") >= 0) ){
		self._updownControl.up();
	}
	//감소(방향 : 아래, 왼쪽)
	else if( typeof className == "string" && (className.indexOf("DirectArrow_Down") >= 0 || className.indexOf("DirectArrow_Left") >= 0) ){
		self._updownControl.down();
	}
};

function upDown_MouseDown(e){
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var pEm = em;
	var control = searchControl_UpDown(em);
	
	//방향 체크
	while(pEm.parentNode && !pEm.className.startsWith("DirectArrow_")) 
		pEm = pEm.parentNode;
	
	self._updownMouseDown = true;
	self._updownControl = control;
	self._updownDirection = pEm.getAttribute("class");
	self._updownMouseDownTimer = setInterval(upDownChangeLinkedControl, 100);
	
	//메모리 초기화
	control = null;
	pEm = null;
	em = null;
	
	return true;
};

function upDown_MouseUp(e){
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_UpDown(em);
	
	if( typeof self._updownControl != "undefined" && control.id == self._updownControl.id ){
		self._updownMouseDown = false;
		clearInterval(self._updownMouseDownTimer);
		delete self._updownControl;
		delete self._updownDirection;
		delete self._updownMouseDownTimer;
	}
	
	//메모리 초기화
	control = null;
	em = null;
	
	return true;
};

function upDown_MouseOut(e){
	e = window.event || e;
	
	var em = (navigator.userAgent.indexOf('Firefox') >= 0 ? e.target : e.srcElement);
	var control = searchControl_UpDown(em);
	
	if( typeof self._updownControl != "undefined" && control.id == self._updownControl.id ){
		self._updownMouseDown = false;
		clearInterval(self._updownMouseDownTimer);
		delete self._updownControl;
		delete self._updownDirection;
		delete self._updownMouseDownTimer;
	}
	
	//메모리 초기화
	control = null;
	em = null;
	
	return true;
};function Movie(controlId, controlName, tagObject){
    // 상속선언부
    this.base = ControlBase;              //부모클래스 지정
    this.base(controlId, controlName, tagObject);    //부모클래스 생성자호출

    // 속성 선언부
    this.value = "";
    this.tagObject = tagObject;
    this.muted = "";	//음소거
    this.poster = "";	//로드되지 않고 있을 대 처음에 표시될 이미지의 URL
    this.autoplay = "";	//반복 재생
    this.preload = "";	//none, metadta, auto
};

Movie.prototype = new ControlBase(); // 의미없음 코딩 편의기능을 활용하기 위함

Movie.prototype.setValue = function(value){
	// functionname : [Movie.setValue]
	
	this.value = value;
	
	this.tagObject.setAttribute("src", value);
};

Movie.prototype.clear = function(){
	// functionname : [PictureBox.clear]
	                   
	this.tagObject.setAttribute("src", "");
};
/**
 * 
 * jsonObject ={id:"aaa", datasettype="DataSet",
 *              colinfos:[{id:"code", size:"256", type:"STRING"}, {id:"name", size:"256", type:"STRING"}],
 *              records:[{code:1, name:"코드"}, {code:2, name:"명"}] }
 */

//DataSet객체가 들어가는 전역변수
var dataSets = [];

/**
 * @class	DataSet
 * @constructor DataSet
 * @description	미결
 * @param	{object}	jsonObject
 */
function DataSet(jsonObject) // constructor
{
	this.id= ""; 
	this.dataSetType= "DataSet";   // Pivot

	this.colInfos = [];
	this.records = [];
	this.buffer = [];           // Filtered 포함 버퍼
	this.OriginBuffer = [];     // 원본 버퍼
	this.Row = 0;                // Dataset에서 현재 선택된 Record의 Index
	this._colCount = 0;
	// 시작 Index 값은 0 입니다.
	// Dataset의 Record가 없을 경우에는 -1 입니다.

	this.FireEvent = true;		// 이벤트를 일으킬 것인지 여부
	this.UpdateControl= true;  // Dataset의 Record에 Update, Delete가 발생한 경우, 변경전 Record 값을 Orgin Buffer에 저장할지 여부

	this.FilterExpr = "";		// Dataset에 기본적으로 Filter되어야 할 Expression
	this.FilterFunction = null;
	this._GroupKey= "";         // Dataset의 GroupKey
	this._jsonGroupKey = [];      // 사용예 "A:B,C,D" 인 경우   [["A","B"],"C","D"]
	this._needGroupKey = [];      // 사용예 2레벨을 출력 않는 경우  [true, false, true]
	this._strSortColList = "";    // 그루핑시 예외 소팅키 "ColumnID, ColumnID" 형식, 또는 "ColumID:(D 또는 A), ..."   D:Descending, A: Ascending
	                              // 소팅키를 정하면 그룹키에 해당하는 키편집을 할 수 없다 (셀서식을 편집 불가능하게 설정해야 한다 )

	this._DataObject= null;   
	this._PivotKey= "";         // Logical Dataset에 PivotTable을 구성하기 위한 PivotColumn
	this._jsonPivotKey = [];      // 사용예 "A:B,C,D" 인 경우   [["A","B"],"C","D"]
	this._needPivotKey = [];      // 사용예 2레벨을 출력 않는 경우  [true, false, true]
	
	this._pivotIndex= 0;        // Pivot Dataset에서 현재 선택된 PivotColumn의 Index
	this._PivotIndexCount= 0;   // Pivot Dataset의 Pivot된 갯수
	this._ReverseSubsum= false; // Dataset의 GroupKey에 의한 SubSum을 역순으로 처리할지 지정하는 Property 
	
	this._arrPivotKeys = [];     // 피벗 키 결과 배열 
	this._arrGroupKeys = [];     // 그룹 키 결과 배열 
	this._arrDatas     = [];     // 피벗 셀 데이터 배열
	this._arrFooterSums= [];     // 푸터집계용 정보
	this._arrItemColIds = [];    // 칼럼아이디 목록
	this._sumMethods   = [];     // 칼럼아이디별 Sum 메서트
	this._sheetName    = "";     // 피벗을 표시할 시트 명
	this._rowCount_NonGroup = 0;

	// 합계열 추가정보 
	this.arrMoreSumInfos = [];    // 주가 합계열 정보 -형식: [{headerText:"XXX", colId:"XXX", sumMethod:"XXX", columnInfo:{AUI그리드의 포멧 }}, ...]  
	                              // -사용예: [{headerText:"전년합계", colId:"D1", sumMethod:"SUM"},{headerText:"전년평균", colId:"D1", sumMethod:"AVG"}]
    this.arrMoreColumnDatas = []; // 추가합계가 채워진 결과 배열 - arrMoreSumInfos의 숫자와 맞아야 함 

	this.dataBinds = [];     	// 데이터 링크된 콘트롤들 
	this.innerBinds = [];    	// 채우기 링크된 그리드들 
	
	this.__actionStack = [];     // 이벤트 호출 스택 기록용 
	this.id = jsonObject.id;
	this.inBlocking = false;
	this.instantUpdateControl = true;	//데이터셋 데이터 변경시 컨트롤에 즉시 반영 여부
	
//	this.mappingRecordInfos = null;
	
	// events ------------------------------------------------------------------------------------	
	makeEventHandler(this, "CanColumnChange", "obj", "nRow", "strColumnID", "varOldValue", "varNewValue");
	makeEventHandler(this, "CanRowPosChange", "obj", "nOldRow", "nRow");
	makeEventHandler(this, "ColumnChanged", "obj", "nRow", "strColumnID", "varOldValue", "varNewValue");
	makeEventHandler(this, "Error",         "obj", "nErrorCode", "strErrorMsg");
	makeEventHandler(this, "LoadCompleted", "obj", "nErrorCode", "strErrorMsg", "nReason");
	makeEventHandler(this, "RowDeleted",    "obj", "nRow", "nCount");
	makeEventHandler(this, "RowDeleting",   "obj", "nRow", "nCount");
	makeEventHandler(this, "RowInserted",   "obj", "nRow", "nCount");
	makeEventHandler(this, "RowPosChanged", "obj", "nOldRow", "nRow");

	// jsonObject로 부터 초기화 
	this.dataSetType = jsonObject.datasettype;
	this.FilterExpr = jsonObject.filterexpr;
	if (this.FilterExpr.length > 0){
		this.FilterFunction = new Function("return function (nRowNum) { return " + this._UpdateFormulaNF(this.FilterExpr) + "; }")();;
	}
	this._GroupKey= jsonObject.groupkey;
	this._PivotKey= jsonObject.pivotkey;
	
	for (var i = 0; i < jsonObject.colinfos.length; i++){
		var object = jsonObject.colinfos[i];

		var colInfo = new MiColInfo();
		colInfo.id = object["id"];
		if (object["size"] != undefined) colInfo.size = object["size"];
		if (object["type"] != undefined) colInfo.type = object["type"];
		if (object["summ"] != undefined) colInfo.sumMethod = object["summ"].toUpperCase();
		colInfo.index = i;

		this.colInfos[colInfo.id] = colInfo;
		this._colCount++;
	}

	for (var i = 0; i < jsonObject.records.length; i++){
		var object = jsonObject.records[i];

		var record = new MiRecord(this.colInfos);
		record._orignalIndex = i;

		for (var key in object){
			if( typeof(object[key]) == "function" ) continue;
			
			var key0 = (key.toUpperCase() == "ID$" ? key.substring(0, key.length -1) : key);
			
			for (var wKey in this.colInfos){
				if( typeof(this.colInfos[wKey]) == "function" ) continue;
				
				if (wKey.toUpperCase() == key0.toUpperCase()){
					if (this.colInfos[wKey].type == "Smallint"  || this.colInfos[wKey].type == "Integer"  || this.colInfos[wKey].type == "Int"){ 
						record.values[wKey]  = parseInt("" + object[key]);
					} else if (this.colInfos[wKey].type == "Float" || this.colInfos[wKey].type == "Money" || this.colInfos[wKey].type == "Decimal" || this.colInfos[wKey].type == "Currency"){  
						record.values[wKey]  = parseFloat("" + object[key]);
					} else {
						record.values[wKey] = object[key];
					}
					break;
				}
			}
		}
		this.records[i] = record;
		this.buffer[i] = record;
	}
};

//child Objects
/**
*     @description	미결
*     @param	{string}	id
*     @param	{number}	size
*     @param	{string}	type
*     @param	{object}	sumMethod
*     @return	{undefined}
*     @example	미결
*/
function MiColInfo(id, size, type, sumMethod){
	this.id =   (id == undefined ? 0 : id); 
	this.size = (size == undefined ? 256 : size); 
	this.type = (type == undefined ? "Char" : type); //   Smallint, Integer, Money, Float, Char : "STRING", "INT", "DECIMAL", "DATE", "BLOB", "URL", "LONGTEXT", "CHAR", "CURRENCY"
	this.sumMethod = (sumMethod == undefined ? "" : sumMethod.toUpperCase());  // "SUM", "AVG", "MIN", "COUNT", "MAX", "TEXT:소계"
	this._sumText = "";    // sumMethod의 뒷부분을 반복적으로 파싱 하지 않기 위한 임시필드, 그룹핑 단계에서 미리 분해 한다. 텍스트인 경우
	this._sumFormula = "";     // sumMethod의 뒷부분을 반복적으로 파싱 하지 않기 위한 임시필드, 그룹핑 단계에서 미리 분해 한다. 산식인 경우
	this._sumField = "";   // sumMethod의 뒷부분을 반복적으로 파싱 하지 않기 위한 임시필드, 그룹핑 단계에서 미리 분해 한다. 필드인 경우

	this._isGroupKeyField = false;
	this.index = 0;
	
	// 미리 컴파일된 _sumFormula 사용법 
	// 예: self[this.id + "_" + colId + "_sumFunction"](nRow);
	// 예: dslist_YM__sumFunction(nRow);

};

/**
 * @description	미결
 * @return  {string}
 * @example	미결
 */
MiColInfo.prototype.defaultValue = function(){
	var value;

	if (this.type == "Char"){ 
		value = "";
	} else if (this.type == "Smallint" || this.type == "Integer" || this.type == "Int"){ 
		value = 0;
	} else if (this.type == "Float" || this.type == "Decimal"){ 
		value = 0;
	} else if (this.type == "Money" || this.type == "Currency"){ 
		value = 0;
	} else if (this.type == "Date"){ // yyyyMMddhhmmss
		var date = new Date();
		value = date.getFullYear().toString() + 
		pad2(date.getMonth() + 1) + 
		pad2( date.getDate()) + 
		pad2( date.getHours()) + 
		pad2( date.getMinutes()) + 
		pad2( date.getSeconds()); 

	} else if (this.type == "Url"){ 
		value = "";
	} else if (this.type == "Blob"){ 
		value = "";
	} else { 
		value = "";
	} 	

	return value;
};

/**
*     @description	미결
*     @param	{object}	colInfos
*     @return	{undefined}
*     @example	미결
*/
function MiRecord(colInfos){
	// 'Insert', 'Update', 'Delete', 'Logical', 'Normal' 중 하나의 값
	// 존재하지 않는 Record에 대한 RowType은 "Normal" 입니다.
	this._id = Math.floor(Math.random() * 10000000000) + 1; // 고유 식별코드로 내부에서 객체가 같은 것인지 비교 할때 사용됨
	this._$uid =""; // AUIGrid 줄객체의 고유 번호로 줄찾을때 사용한다 
	this.RowType = "Normal";  
	this._filterd = false;
	this._selected = false;
	this._orignalIndex = 0;   // 최초데이터에만 들어가는 인덱스 정보이다. 
	this._jsonGroupKeyValue = []; // 사용예 "A:B,C,D" 인 경우   [["AA","BB"],"CC","DD"]
	this._jsonPivotKeyValue = []; // 사용예 "A:B,C,D" 인 경우   [["AA","BB"],"CC","DD"]
	this.values = [];

	var i = 0;
	for (var key in colInfos){
		if( typeof(colInfos[key]) == "function" ) continue;
		this.values[key] = colInfos[key].defaultValue();
	}
	
	// 그루핑 레코드인 경우 
	this._RowLevel= 0;          // Dataset의 현재 선택된 Record의 Level 값,  RowType이 Logical이 아닌 경우에는 RowLevel 값은 0
	this.rangeStart = 0;
	this.rangeCount = 0;
	this.caption = "";
	
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
MiRecord.prototype.clear = function(){
	for(var key in this.values) {
		if( typeof(this.values[key]) != "function" ) delete this.values[key];
	}
	this.caption = "";

	return;
};

/**
 * @description	미결
 * @return  {string}
 * @example	미결
 */
MiRecord.prototype.clone = function(){
	var toRecord   = new MiRecord(this.colInfos);
	toRecord._id = this._id;

	for (var key in this.values){
		if( typeof(this.values[key]) == "function" ) continue;
		toRecord.values[key] = this.values[key];
	}

	return toRecord;
	// 주의: 서용 후, RowType을 상황에 맞게 추가로 프로그램으로 조정해 주어야 한다
};

/**
 * @description	미결
 * @param	{string}	formula
 * @return  {string}
 * @example	미결
 */
DataSet.prototype._UpdateFormula = function(formula){
	if (formula.trim().length == 0) return formula;
	
	var i = 0;
	var keyArray = []; 
	for (var key in this.colInfos){
		if( typeof(this.colInfos[key]) == "function" ) continue;
		keyArray[i++] = key;
	}	
	keyArray.sort(function(a,b){return a.length - b.length});

    formula = formula.replace(new RegExp("ROWLEVEL", "ig") , "#999999#");

	for (i = keyArray.length-1; i >= 0; i--){
		var colId = keyArray[i];
		formula = formula.replace(new RegExp(colId, "g") , "#" + i + "#");
		//formula = formula.replace(colId, "#" + i + "#");
	}
	
	formula = formula.replace(/currow/gi, this.id + ".Row");
	formula = formula.replace(/=/g, "==");
	formula = formula.replace(/====/g, "==");
	formula = formula.replace(/<>/g, "!=");
	///* 2016-03-25 수정 (차중훈) : 필터 산식에서 연산자 중 >= 와 <= 가 >==, <== 로 변환되는 부분 수정
	formula = formula.replace(/>==/g, ">=");
	formula = formula.replace(/<==/g, "<=");
	//*/ 2016-03-25 수정 (차중훈)
	
	for (i = 0; i < keyArray.length; i++){
		var colId = keyArray[i];
		formula = formula.replace(new RegExp( "#" + i + "#", "g"), this.id + ".getColumn(nRowNum, \"" + colId +"\")");
		//formula = formula.replace("#" + i + "#", this.id + ".getColumn(nRowNum, \"" + colId +"\")");
	}
	formula = formula.replace(new RegExp( "#999999#", "g"), "rowLevel");
	
	keyArray.clear();

	return formula;
};

/**
 * @description	미결
 * @param	{string}	formula
 * @return  {string}
 * @example	미결
 */
DataSet.prototype._UpdateFormulaNF = function(formula){
	if (formula.trim().length == 0) return formula;
	
	var i = 0;
	var keyArray = []; 
	for (var key in this.colInfos){
		if( typeof(this.colInfos[key]) == "function" ) continue;
		keyArray[i++] = key;
	}	
	keyArray.sort(function(a,b){return a.length - b.length});

    formula = formula.replace(new RegExp("ROWLEVEL", "ig") , "#999999#");

	for (i = keyArray.length-1; i >= 0; i--){
		var colId = keyArray[i];
		formula = formula.replace(new RegExp(colId, "g") , "#" + i + "#");
		//formula = formula.replace(colId, "#" + i + "#");
		///* 2016-03-25 수정 (차중훈) : 산식의 데이터 셋 컬럼ID를 #1#, #2#, ... 문자열 전체 변환 수정
		//formula = eval("formula.replace(/" + colId + "/g, \"#\" + i + \"#\")");
		//*/ 2016-03-25 수정 (차중훈)
	}
	
	formula = formula.replace(/currow/gi, this.id + ".Row");
	formula = formula.replace(/=/g, "==");
	formula = formula.replace(/====/g, "==");
	formula = formula.replace(/<>/g, "!=");
	///* 2016-03-25 수정 (차중훈) : 필터 산식에서 연산자 중 >= 와 <= 가 >==, <== 로 변환되는 부분 수정
	formula = formula.replace(/>==/g, ">=");
	formula = formula.replace(/<==/g, "<=");
	//*/ 2016-03-25 수정 (차중훈)
	
	for (i = 0; i < keyArray.length; i++){
		var colId = keyArray[i];
		formula = formula.replace(new RegExp( "#" + i + "#", "g"), this.id + ".getColumnNF(nRowNum, \"" + colId +"\")");
		//formula = formula.replace("#" + i + "#", this.id + ".getColumnNF(nRowNum, \"" + colId +"\")");
		///* 2016-03-25 수정 (차중훈) : 산식의 #1#, #2#, ... 문자열 전체 변환 수정
		//formula = eval("formula.replace(/#" + i + "#/g, this.id + \".getColumnNF(nRowNum, \\\"\" + colId +\"\\\")\")");
		//*/ 2016-03-25 수정 (차중훈)
	}

	formula = formula.replace(new RegExp( "#999999#", "g"), "rowLevel");	

	keyArray.clear();

	return formula;
};


/**
 * @description	미결
 * @param	{string}	statement
 * @return  {boolean}
 * @example	미결
 */
DataSet.prototype._IsColumnName = function(statement){
	for (var key in this.colInfos){
		if( typeof(this.colInfos[key]) == "function" ) continue;
		if (statement == key){
			return true;
		}
	}	
	return false;
};
/**
 * @description	미결
 * @param	{string}	colId
 * @param	{string}	strValue
 * @return  {string}
 * @example	미결
 */
DataSet.prototype._getRawValue = function(colId, strValue){
	var colInfo = this.colInfos[colId];

	var value;
	if (colInfo.type == "Smallint"  || colInfo.type == "Integer"  || colInfo.type == "Int"){ 
		value = (strValue == null || strValue == undefined || strValue.length == 0 ? 0 : parseInt(strValue));
	} else if (colInfo.type == "Float" || colInfo.type == "Money" || colInfo.type == "Decimal" || colInfo.type == "Currency"){  
		value = (strValue == null || strValue == undefined || strValue.length == 0 ? 0.0 : parseFloat(strValue));
	} else {
		if( typeof strValue == "undefined" || strValue == null ){
			value = "";
		} else{
			value = (((strValue + "").replace(/<BR>/gi, "\n")).replace(/<BR2>/gi, "\r")).replace(/<BS>/gi, "\\");
		}
	}
	return value;
};
/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
DataSet.prototype._remakeRecords = function(){
	// records 재구성 
	while(this.records.length > 0) {
		this.records.pop();
	}
	nRow = 0;
	for (var nRowNF = 0; nRowNF < this.buffer.length; nRowNF++){
		if (!this.buffer[nRowNF]._filterd){
			this.records[nRow++] = this.buffer[nRowNF];
		}
	}
	return;
};

//이벤트의 루핑을 막기 위한 장치   -----------------------------------------------------------------------
/**
 * @description	미결
 * @param	{string}	strAction
 * @return  {undefined}
 * @example	미결
 */
DataSet.prototype.__pushActionStack = function(strAction){
	this.__actionStack.push(strAction);
};
/**
 * @description	미결
 * @return  {string}
 * @example	미결
 */
DataSet.prototype.__lastAction = function(){
	if (this.__actionStack.length == 0) return "";
	
	return this.__actionStack[this.__actionStack.length - 1];
};
/**
 * @description	미결
 * @return  {undefined}
 * @example	미결
 */
DataSet.prototype.__popActionStack = function(){
	this.__actionStack.pop();
};

//Bind 정보 객체와 함수  -----------------------------------------------------------------------------
/**
*     @description	미결
*     @param	{string}	datasetId
*     @param	{string}	colId
*     @param	{string}	controlType
*     @param	{string}	controlName
*     @param	{number}	colIndex
*     @return	{undefined}
*     @example	미결
*/
function BindInfo(datasetId, colId, controlType, controlName, colIndex){
	this.datasetId = datasetId;     // STR_MASTER
	this.colId = colId;             // STRNM
	
	this.controlType = controlType; // "ComboBox", "TextBox", ...
	this.controlName = controlName; // Sheet_1, ed_strnm
	this.colIndex = (colIndex == undefined ? 0 : colIndex);		// 
	
	this.colId_value = "";          // STRCD 추가정보로 별도설정한다
	this.disabled = false;
	
	// 멀티라인 에서만 사용
    this.sheetRowNum = 1;
    this.sheetColNum = this.colIndex;
};


/**
 * @description	미결
 * @param	{string}	strDataset
 * @return  {undefined}
 * @example	미결
 */
ControlBase.prototype.setBindDataset = function(strDataset){
    this.bindDataset = strDataset;
}; 
if (typeof AUIDataSheet == "function")
    AUIDataSheet.prototype.setBindDataset = function(strDataset){ this.bindDataset = strDataset; };
if (typeof AUIDataSheetM == "function")
    AUIDataSheetM.prototype.setBindDataset = function(strDataset){ this.bindDataset = strDataset; };
if (typeof EasySheet == "function")
	EasySheet.prototype.setBindDataset = function(strDataset){ this.bindDataset = strDataset; };


/**
 * 콘트롤에서 관련된 데이터셋을 갱신한다 
 * 
 * setColumn(strColId)
 * setColumn(strColId, strColId_value)
 * setColumn(strColId, nColIndex)
 * 
 * @param  strColId        데이터의 값, 콤보, 리스트에서는 텍스트값과 연계된 데이터 칼럼명 
 * @param  strColId_value  콤보, 리스트에서 코드값과 연계된 데이터 칼럼명 
 * @param  nColIndex       시트에서의 칼럼번호  
 * @return                 없음
*/
ControlBase.prototype.setColumn = function(strColId, strColId_value){
	if (this.bindDataset.length == 0) {
		alert(getText("message_dataset_001", "bindDataSet 속성을 먼저 설정해야 합니다."));
		return ;
	}
	var nColIndex = (typeof strColId_value === "number" ? strColId_value : null);
	
	if (nColIndex == null){
		// 콘트롤에 속하는 dataBinds 에 해당 데이터 셋이 있눈지 확인한다. 
		// 없으면 세로운 바인드 정보를 만들어 추가한다.
		if (this.bindDataset in this.dataBinds){
			this.dataBinds[this.bindDataset].colId = strColId;
		} else {
			this.dataBinds[this.bindDataset] = new BindInfo(this.bindDataset, strColId, this.image, this.controlName);
		}
		if (strColId_value != undefined){
			this.dataBinds[this.bindDataset].colId_value = strColId_value;
		}
		
		// 데이터셋에 속하는 dataBinds 에 해당 데이터 셋이 있눈지 확인한다. 
		// 없으면 세로운 바인드 정보를 만들어 추가한다.
		if (this.controlName in dataSets[this.bindDataset].dataBinds){
			dataSets[this.bindDataset].dataBinds[this.controlName].colId = strColId;
		} else {
			dataSets[this.bindDataset].dataBinds[this.controlName] = new BindInfo(this.bindDataset, strColId, this.image, this.controlName);
		}
		if (strColId_value != undefined){
			dataSets[this.bindDataset].dataBinds[this.controlName].colId_value = strColId_value;
		}
		
	} else {
		if (this.bindDataset in this.dataBinds){
			this.dataBinds[this.bindDataset + "_" + nColIndex].colId = strColId;
		} else {
			this.dataBinds[this.bindDataset + "_" + nColIndex] = new BindInfo(this.bindDataset, strColId, this.image, this.controlName, nColIndex);
		}
		if (this.name in dataSets[this.bindDataset].dataBinds){
			dataSets[this.bindDataset].dataBinds[this.name + "_" + nColIndex].colId = strColId;
		} else {
			dataSets[this.bindDataset].dataBinds[this.name + "_" + nColIndex] = new BindInfo(this.bindDataset, strColId, this.image, this.controlName, nColIndex);
		}
	}
	
	

	dataSets[this.bindDataset].updateControlList();
}; 

/**
 * @description	미결
 * @param	{string}	strDataset
 * @return  {undefined}
 * @example	미결
 */
ControlBase.prototype.setInnerDataset = function(strDataset){
	this.innerDataset = strDataset;
}; 

/**
 * 콘트롤에서 관련된 데이터셋을 갱신한다 
 * 
 * setDataColumn(strColId)
 * setDataColumn(strColId, nColIndex)
 * 
 * @param  strColId        데이터의 값, 콤보, 리스트에서는 텍스트값과 연계된 데이터 칼럼명 
 * @param  nColIndex       시트에서의 칼럼번호  
 * @return                 없음
*/
ControlBase.prototype.setDataColumn = function(strColId, nColIndex){
	if (nColIndex == undefined){
		if (this.name in dataSets[this.innerDataset].innerBinds){
			dataSets[this.innerDataset].innerBinds[this.name].colId = strColId;
		} else {
			dataSets[this.innerDataset].innerBinds[this.name] = new BindInfo(this.innerDataset, strColId, this.image, this.name);
		}
	} else {
		if (this.name in dataSets[this.innerDataset].innerBinds){
			dataSets[this.innerDataset].innerBinds[this.name + "_" + nColIndex].colId = strColId;
		} else {
			dataSets[this.innerDataset].innerBinds[this.name + "_" + nColIndex] = new BindInfo(this.innerDataset, strColId, this.image, this.name, nColIndex);
		}
		
	}
	dataSets[this.innerDataset].updateControlList();

}; 
/**
 * @description	미결
 * @param	{string}	strColId
 * @param	{number}	nColIndex
 * @return  {undefined}
 * @example	미결
 */
ControlBase.prototype.setCodeColumn = function(strColId, nColIndex){
	if (nColIndex == undefined){
		if (this.name in dataSets[this.innerDataset].innerBinds){
			dataSets[this.innerDataset].innerBinds[this.name].colId_value = strColId;
		} else {
			dataSets[this.innerDataset].innerBinds[this.name] = new BindInfo(this.innerDataset, "", this.image, this.name);
			dataSets[this.innerDataset].innerBinds[this.name].colId_value = strColId;
		}
		
	} else {
		if (this.name in dataSets[this.innerDataset].innerBinds){
			dataSets[this.innerDataset].innerBinds[this.name + "_" + nColIndex].colId_value = strColId;
		} else {
			dataSets[this.innerDataset].innerBinds[this.name + "_" + nColIndex] = new BindInfo(this.innerDataset, "", this.image, this.name, nColIndex);
			dataSets[this.innerDataset].innerBinds[this.name + "_" + nColIndex].colId_value = strColId;
		}
		
	}
	dataSets[this.innerDataset].updateControlList();
}; 

/**
 * @description	미결
 * @return  {string}
 * @example	미결
 */
ControlBase.prototype.getBindDataset = function(){return this.bindDataset};

/**
 * @description	미결
 * @param	{number}	nColIndex
 * @return  {string}
 * @example	미결
 */
ControlBase.prototype.getColumn = function(nColIndex){
	if (nColIndex != undefined){
		return this.dataBinds[this.bindDataset + "_" + nColIndex].colId;
	}
	return this.dataBinds[this.bindDataset].colId;
};

/**
 * @description	미결
 * @return  {string}
 * @example	미결
 */
ControlBase.prototype.getInnerDataset = function(){return this.innerDataset;};

/**
 * @description	미결
 * @param	{string}	nColIndex
 * @return  {string}
 * @example	미결
 */
ControlBase.prototype.getCodeColumn = function(nColIndex){
	if (nColIndex != undefined){
		return dataSets[this.innerDataset].innerBinds[this.name + "_" + nColIndex].colId;
	}
	return dataSets[this.innerDataset].innerBinds[this.name].colId;
};

/**
 * @description	미결
 * @param	{string}	nColIndex
 * @return  {string}
 * @example	미결
 */
ControlBase.prototype.getDataColumn = function(nColIndex){
	if (nColIndex != undefined){
		return dataSets[this.innerDataset].innerBinds[this.name + "_" + nColIndex].colId_value;
	}
	return dataSets[this.innerDataset].innerBinds[this.name].colId_value;
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
DataSet.prototype.setBlocking = function(){
	var needBlocking = (this.getRowCount() == 0);
	if (this.inBlocking == needBlocking) return;
	
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlType == "Sheet" || bindInfo.controlType == "lstSheet") continue;
		
		var control = controls[bindInfo.controlName];
		if (needBlocking){
			if (control.enabled){
				control.setEnabled(false);
				bindInfo.disabled = "true";
			}			
		} else {
			if (bindInfo.disabled =="true"){   // 데이터 셋이 Disable 시킨 경우만...
				control.setEnabled(true);
				bindInfo.disabled = "false";
			}
		}
	}
	
	this.inBlocking = needBlocking;
	
	return;
};

/**
 * @description	미결
 * @param	{string}	rowId
 * @return  {object}
 * @example	미결
 */
DataSet.prototype.isAvailableRowId = function(rowId){
    if (rowId == undefined){
    	//alert("'isAvailableRowNum(\"줄ID\")'의 형태로 사용하세요.");
    	if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_005", "'isAvailableRowNum(\"줄ID\")'의 형태로 사용하세요."));
    	if(typeof console != "undefined" && typeof console.trace == "function")	console.trace();
    	return false;
    }
    
    var deleted = true;
	for (var nRow=0; nRow < this.records.length; nRow++){
		if (this.records[nRow]._$uid == rowId){
			deleted = false; 
			break;
		}
	}
    return !deleted;
};
/**
*     @description	미결
*     @param	{object}	control
*     @param	{string}	rowId
*     @return	{boolean}
*     @example	미결
*/
function _Common_isAvailableRowId(control, rowId){
    if (rowId == undefined){
    	//alert(getText("message_dataset_005", "'isAvailableRowNum(\"줄ID\")'의 형태로 사용하세요."));
    	if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_005", "'isAvailableRowNum(\"줄ID\")'의 형태로 사용하세요."));
    	if(typeof console != "undefined" && typeof console.trace == "function")	console.trace();
    	return false;
    }
    
    var deleted = true;
    
    if( (typeof AUIDataSheet == "function" && control instanceof AUIDataSheet)
    	|| (typeof AUIDataSheetM == "function" && control instanceof AUIDataSheetM)
    ){
    	var nRowToCheck = -1;
    	
    	for (var nRow=0; nRow <control.maxRows; nRow++){  //nRow는 AUI 그리드의 줄번호 0부터 시작
    		if (rowId == AUIGrid.getItemByRowIndex(control.AUIcontrolId, nRow)._$uid) {
    			deleted = false; 
    			nRowToCheck = nRow;
    			break;
    		}
    	}
    	
    	if (control.softRemoveRowMode && !deleted){
    		if (control.isDeletedRow(nRowToCheck + 1)) deleted = true; 
    	}
    }
    else if( typeof EasySheet == "function" && control instanceof EasySheet ){
    	var datas = control.getData(); var data = null;
		var nMaxRow = control.maxRows; var nRow = 0;
		
		for(nRow=0; nRow < nMaxRow; nRow++, data = null){
			data = datas[nRow];
			
			if( rowId === data.__STATE__.rowId ) {
				deleted = false;
				data = null;
				break;
			}
		}
		
		datas.clear();
		datas = null;
    }
	
    return !deleted;
};

if (typeof AUIDataSheet == "function")
    AUIDataSheet.prototype.isAvailableRowId = function(rowId){ return _Common_isAvailableRowId(this, rowId);};
if (typeof AUIDataSheetM == "function")
	AUIDataSheetM.prototype.isAvailableRowId = function(rowId){ return _Common_isAvailableRowId(this, rowId);};

if( typeof EasySheet == "function" ){
	EasySheet.prototype.isAvailableRowId = function(rowId){ return _Common_isAvailableRowId(this, rowId);};
}

    /**
     * @description	미결
     * @param	{string}	uid
     * @return  {string}
     * @example	미결
     */
DataSet.prototype.getIndexOf_$uid = function(uid){
    	var nRowToGet = -1;
    	for (var nRow=0; nRow < this.records.length; nRow++){
    		if (this.records[nRow]._$uid == uid){
    			nRowToGet = nRow;
    			break;
    		}
    	}
    	return nRowToGet;
};
/**
 * @description	미결
 * @param	{string}	uid
 * @return  {string}
 * @example	미결
 */
DataSet.prototype.rowTypeOf_$uid = function(uid){
	var nRow = this.getIndexOf_$uid(uid);
	return (nRow < 0 ? "" : this.records[nRow].RowType);
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
DataSet.prototype.updateControlList = function(){
	// 연결된 피벗이 있는 경우 피벗을 갱신한다
	this.updatePivot();
	
	if (this._GroupKey.length > 0){
		return;
	}

	// 시트에서 줄 CLEAR 상태면 다시시트를 갱신하지 않음
	if (this.__lastAction() == "SHEET_CLEARED_ROW") return; 
	// 데이터 셋에서 줄 CLEAR 상태로 바꿈
	this.__pushActionStack("DATASET_REFRESHED_ROW");
	
	// 콘트롤 리스트 채우기
	for (var key in this.innerBinds){
		if( typeof(this.innerBinds[key]) == "function" ) continue;
		var bindInfo = this.innerBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if( bindInfo.controlType == "ComboBox" || bindInfo.controlType == "List1" ){
			var ctl = controls[bindInfo.controlName];
			ctl.clear();
			
			var recordLength = this.records.length;
			var optList = [];
			var optObj = null;
			for (var nRow=0; nRow < recordLength; nRow++){
				var record = this.records[nRow];
				
//				var text = ""; var value = "";
//				if (bindInfo.colId.trim().length != 0){
//					text = record.values[bindInfo.colId];
//				}
//				if (bindInfo.colId_value.trim().length != 0){
//					value = record.values[bindInfo.colId_value];
//				}
//				ctl.addItem(text, value, false);
				optObj = {"text" : "", "value" : ""};
				if (bindInfo.colId.trim().length != 0){
					optObj.text = record.values[bindInfo.colId];
				}
				if (bindInfo.colId_value.trim().length != 0){
					optObj.value = record.values[bindInfo.colId_value];
				}
				optList[nRow] = optObj;
				
				optObj = null;
			}
			
			ctl._updateLists( optList );
			
			optObj = null;
			while(optList.length > 0){
				optObj = optList.pop();
				optObj = null;
			}
			optList = null;
			
			ctl.passEvent = true;
			ctl.setValueToDefault();
			ctl.passEvent = false;
		}
		if (bindInfo.controlType == "OptionButton") {
			// 사상이 다르므로 보류 
		}
	}
	//if (this.getRowCount() == 0) return ;

	// 시트값 수정
	var tmpBinds = [];
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet") continue;
		tmpBinds[bindInfo.controlName] = bindInfo.controlType;
	}
	
	for (var controlName in tmpBinds){
		if( typeof(tmpBinds[controlName]) == "function" ) continue;
		
		var sht = controls[controlName];
		var data = [];
		
		var tmBinds2 = []; var i = 0;
		for (var key in sht.dataBinds){
			var bindInfo = sht.dataBinds[key];
			if( typeof(bindInfo) == "function" ) continue;
			if (bindInfo.datasetId != this.id) continue;
			
			tmBinds2[i++] = bindInfo;
			
		}
		
		if( (typeof AUIDataSheet == "function" && sht instanceof AUIDataSheet)
			|| (typeof AUIDataSheetM == "function" && sht instanceof AUIDataSheetM)
		){
			if (typeof AUIDataSheetM == "function" && sht instanceof AUIDataSheetM){
				var ndx = 0;
				for (var nRow=0; nRow < this.records.length; nRow++){
					var record = this.records[nRow];
					for (var sheetRowNum = 1; sheetRowNum <= sht.rowsPerDataRow; sheetRowNum++){
						var subData = eval(sht.multilineHelper.defaultLayoutValue[sheetRowNum-1]);
						
						subData["f1"] = nRow + 1;   // 1부터 시작
						for (var j =0; j < tmBinds2.length; j++){
							var bindInfo = tmBinds2[j];
							if (bindInfo.sheetRowNum == sheetRowNum){
								subData["f" + bindInfo.sheetColNum] = record.values[bindInfo.colId];
							}
						}
						data[ndx++] = subData;
					}
				}
			} else {
				for (var nRow=0; nRow < this.records.length; nRow++){
					var record = this.records[nRow];
					var subData = JSON.parse( JSON.stringify(sht.defaultLayoutValue_JSON) );
					for (var j =0; j < tmBinds2.length; j++){
						var bindInfo = tmBinds2[j];
						subData["f" + bindInfo.colIndex] = record.values[bindInfo.colId];
					}
					data[nRow] = subData;
				}
			}
			
//			sht.clear();
			AUIGrid.forceEditingComplete(sht.AUIcontrolId, null, false);
			AUIGrid.setGridData(sht.AUIcontrolId, []);
			sht.currentRow = 1;
			sht.currentCol = 0;
			sht.maxRows = data.length;
			sht.setData(data, false);
			
			if (typeof AUIDataSheetM == "function" && sht instanceof AUIDataSheetM){
				if (!sht.isHiddenColumn(1)) sht.setFixedColumnCount(1);
			}
			
			if ((typeof AUIDataSheet == "function" && sht instanceof AUIDataSheet) ||
					(typeof AUIDataSheetM == "function" && sht instanceof AUIDataSheetM)){
				for (var nRow=0; nRow < this.records.length; nRow++){ //nRow는 AUI 그리드의 줄번호 0부터 시작
					this.records[nRow]._$uid = AUIGrid.getItemByRowIndex(sht.AUIcontrolId, nRow * sht.rowsPerDataRow)._$uid;
				}
			}
			
			AUIGrid.update(sht.AUIcontrolId);
		}
		else if( typeof EasySheet == "function" && sht instanceof EasySheet ){
			var columnInfoList = sht.columns;
			var columnInfo = null;
			var fields = [];
			var defaultRow = {};
			var colCount = 0;
			var i = 0;
			
			for(i = 0, colCount = sht.maxCols; i < colCount; i++){
				columnInfo = columnInfoList[i];
				defaultRow[columnInfo.colId] = (typeof columnInfo.defaultValue == "function") ? columnInfo.defaultValue() : columnInfo.defaultValue;
				fields[i] = {field: columnInfo.colId};
			}
			
			var record = null;
			var subData = null;
			var j = 0;
			
			for(i = 0, colCount = tmBinds2.length, recordCount = this.records.length; i < recordCount; i++){
				record = this.records[i];
				subData = JSON.parse(JSON.stringify(defaultRow));
				
				for(j = 0; j < colCount; j++, bindInfo = null){
					var bindInfo = tmBinds2[j];
					subData[columnInfoList[bindInfo.colIndex].colId] = record.values[bindInfo.colId];
				}
				
				subData["__STATE__"] =	{"updateGu" : (record.RowType == "Insert" ? "I" : 
														(record.RowType == "Update" ? "U" : 
														(record.RowType == "Delete" ? "D" : 
														(record.RowType == "Normal" ? "N" : "X"
										))))};
				
				data[i] = subData;
				
				subData = null; record = null;
			}
			
			sht.completeEditing();
			sht.maxRows = data.length;
			sht.setData({fieldList: fields, recordList: data, rowCount: sht.maxRows}, false);
			
			for(i = 0, recordCount = this.records.length; i < recordCount; i++){
				this.records[i]._$uid = sht.rows(i).rowId;
			}
			
			sht.refreshColumns();
		}
	}
	
	tmpBinds.clear();
	
	// 데이터 리스트값 수정
	tmpBinds = [];
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;

		if (bindInfo.controlType != "List1") continue;
		var ctl = controls[bindInfo.controlName];
		if (ctl.listSaveType != LISTBOX_SAVE_MULTI) continue;
		if (ctl.listType != LISTBOX_TYPE_DATASELECT) continue;
		
		tmpBinds[bindInfo.controlName] = bindInfo.controlType;
		
		
	}
	
	for (var controlName in tmpBinds){
		if( typeof(tmpBinds[controlName]) == "function" ) continue;
		
		var ctl = controls[controlName];
		ctl.clear(false);
		
		for (var key in ctl.dataBinds){
			var bindInfo = ctl.dataBinds[key];
			if( typeof(bindInfo) == "function" ) continue;
			if (bindInfo.datasetId != this.id) continue;
			
			for (var nRow=0; nRow < this.records.length; nRow++){
				var record = this.records[nRow];
				
				var text = ""; var value = "";
				if (bindInfo.colId.trim().length != 0){
					text = record.values[bindInfo.colId];
				}
				if (bindInfo.colId_value.trim().length != 0){
					value = record.values[bindInfo.colId_value];
				}
				ctl.addItem(text, value, false);
			}
		}
	}
	
	// 데이터 셋에서 줄 CLEAR 상태로 지움
	this.__popActionStack();
	
	return;
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
DataSet.prototype.updatePivot = function(){
    for (var key in dataSets){
		var dataset = dataSets[key];
		if( typeof(dataset) == "function" ) continue;
		
		if (dataset._DataObject != null && dataset._DataObject.records.length > 0){
			if (dataset._DataObject === this) dataset._refreshPivot();
		}
    }
    return;
};

/**
*     @description	미결
*     @param	{object}	control
*     @param	{object}	arrJsonObject
*     @return	{number}
*     @example	미결
*/
function _Common_UpdateDatasetList(control, arrJsonObjects){ 
	
	if (control.dataBinds == null || getAssociativeArrayLength(control.dataBinds) == 0) return;
	
	var dataset = null;
	
	var tmpBinds = [];
	for (var key in control.dataBinds){
		var bindInfo = control.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		
		if (bindInfo.controlName == control.controlName) {
			if (dataset == null) {
				dataset = dataSets[bindInfo.datasetId];
			}
			tmpBinds["f" + bindInfo.colIndex] = bindInfo.colId;			
		}
	}
	
	// 논리 레코드 메모
	var logicalIds = []; var ndx = 0;
    for (var nRowNF = 0; nRowNF < dataset.buffer.length; nRowNF++){
    	if (dataset.buffer[nRowNF].RowType == "Logical"){
    		logicalIds[ndx++] = dataset.buffer[nRowNF]._$uid;
    	}
    }
	
	// 기존 정보 클리어
	while(dataset.records.length > 0) {
		dataset.records.pop();
	}
	if (dataset.buffer.length > 0){
		for(var i = dataset.buffer.length - 1; i >= 0 ; i--) {
			dataset.buffer[i].clear();
			dataset.buffer.pop();
		}
	}
	if (dataset.OriginBuffer.length > 0){
		for(var i = dataset.OriginBuffer.length - 1; i >= 0 ; i--) {
			dataset.OriginBuffer[i].clear();
			dataset.OriginBuffer.pop();
		}
	}
    
	var nRowNF = 0; var cnt = 0;
	if (typeof arrJsonObjects == "undefined"){
		arrJsonObjects = AUIGrid.getGridData(control.AUIcontrolId);
	}
	for (var i=0; i < arrJsonObjects.length; i++){
		var jsonObject = arrJsonObjects[i];
		
		var uid = jsonObject._$uid;
		
		// 논리 레코드 제외 
		if (logicalIds.indexOf(uid) >= 0) continue;
		
		// 삭제된 레코드 제외 
		if (AUIGrid.isRemovedById(control.AUIcontrolId, uid)) continue;

		var record = new MiRecord(dataset.colInfos);
		record._orignalIndex = nRowNF;

		record._$uid = uid;
		dataset.buffer[nRowNF]  = record;
		dataset.records[nRowNF] = record;

		for (var key in tmpBinds){
			var colId = tmpBinds[key];  // key: f1, f2, ...
			if( typeof(tmpBinds[key]) == "function" ) continue;
			
			if(key in jsonObject){
				record.values[colId] =  jsonObject[key];	
			}
		}
		
		nRowNF++; cnt++;
	}
	
	tmpBinds.clear();
	
	// Row Position의 값은 0 이 됩니다.
	dataset.Row = 0; 

	dataset.filter(dataset.FilterExpr);

	// 그룹정보 갱신 
	if (dataset._GroupKey.length > 0){
		dataset._ResetGroup();
	}
	
	// 그룹레코드의 uid 세팅
    for (var nRow = 0; nRow < dataset.records.length; nRow++){ //nRow는 데이타셋의 줄번호 0부터 시작
    	if (dataset.records[nRow].RowType == "Logical"){
    		var uid = (AUIGrid.getItemByRowIndex(control.AUIcontrolId, nRow * control.rowsPerDataRow))._$uid;
    		dataset.records[nRow]._$uid = uid;
    	}
    }

    // Sort Method를 수행하면 OnLoadCompleted Event가 발생합니다. 
	// OnLoadCompleted Event의 nReason 값은 0 입니다.
	var nErrorCode = [];
	var strErrorMsg = [];
	if (dataset.hasLoadCompletedEvent) {
		dataset.fncLoadCompletedEvent(dataset, nErrorCode, strErrorMsg, 0);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
			return 0;
		}            
	} 
	
	// 그룹정보 갱신 
	if (dataset._GroupKey.length > 0){
		dataset._refreshGroupCation(true);
	}
	
	return cnt;
};

if (typeof AUIDataSheet == "function"){
    AUIDataSheet.prototype._UpdateDatasetList = function(arrJsonObjects){ 
		return _Common_UpdateDatasetList(this, arrJsonObjects);
    };
}
if (typeof AUIDataSheetM == "function"){
    AUIDataSheetM.prototype._UpdateDatasetList = function(arrJsonObjects){ 
		return _Common_UpdateDatasetList(this, arrJsonObjects);
    };
}

if( typeof EasySheet == "function" ){
	EasySheet.prototype._UpdateDatasetList = function(arrJsonObjects){ 
		if( this.dataBinds == null || getAssociativeArrayLength(this.dataBinds) == 0 )
			return;
		
		var columns = this.columns;
		var dataset = null;
		var tmpBinds = [];
		for(var key in this.dataBinds){
			var bindInfo = this.dataBinds[key];
			if( typeof(bindInfo) == "function" ) continue;
			if( bindInfo.controlName == this.controlName ){
				if( dataset == null )
					dataset = dataSets[bindInfo.datasetId];
				
//				tmpBinds["f" + bindInfo.colIndex] = bindInfo.colId;
				tmpBinds[columns[bindInfo.colIndex].colId] = bindInfo.colId;
			}
		}
		
		//메모리 해제
		columns = null;
		
		// 논리 레코드 메모
		var logicalIds = [];
		var ndx = 0;
		for(var nRowNF = 0; nRowNF < dataset.buffer.length; nRowNF++){
			if( dataset.buffer[nRowNF].RowType == "Logical" )
				logicalIds[ndx++] = dataset.buffer[nRowNF]._$uid;
		}
		
		// 기존 정보 클리어
		while(dataset.records.length > 0){
			dataset.records.pop();
		}
		if( dataset.buffer.length > 0 ){
			for(var i = dataset.buffer.length - 1; i >= 0 ; i--) {
				dataset.buffer[i].clear();
				dataset.buffer.pop();
			}
		}
		if( dataset.OriginBuffer.length > 0 ){
			for(var i = dataset.OriginBuffer.length - 1; i >= 0 ; i--) {
				dataset.OriginBuffer[i].clear();
				dataset.OriginBuffer.pop();
			}
		}
		
		var updateItems = {"I":"Insert", "U":"Update", "D":"Delete"};
		var nRowNF = 0;
		var cnt = 0;
		if( typeof arrJsonObjects == "undefined" ){
			arrJsonObjects = this.getData();
		}
		for(var i=0; i < arrJsonObjects.length; i++){
			var jsonObject = arrJsonObjects[i];
			var uid = jsonObject.__STATE__.rowId;
			var updateGu = jsonObject.__STATE__.updateGu;
			var rowType = updateItems[updateGu];
			
			// 논리 레코드 제외 
			if (logicalIds.indexOf(uid) >= 0) continue;
			
			var record = new MiRecord(dataset.colInfos);
			record._orignalIndex = nRowNF;
			
			record._$uid = uid;
			if( typeof rowType != "undefined" ) record.rowType = rowType;
			dataset.buffer[nRowNF]  = record;
			dataset.records[nRowNF] = record;
			
			for (var key in tmpBinds){
				var colId = tmpBinds[key];  // key: f1, f2, ...
				
				if( typeof(tmpBinds[key]) == "function" ) continue;
				
				if(key in jsonObject){
					record.values[colId] =  jsonObject[key];	
				}
			}
			
			nRowNF++; cnt++;
		}
		
		updateItems = null;
		
		tmpBinds.clear();
		
		// Row Position의 값은 0 이 됩니다.
		dataset.Row = 0; 

		dataset.filter(dataset.FilterExpr);
		
		// 그룹정보 갱신 
		if (dataset._GroupKey.length > 0){
			dataset._ResetGroup();
		}
		
		// 그룹레코드의 uid 세팅
		for (var nRow = 0; nRow < dataset.records.length; nRow++){ //nRow는 데이타셋의 줄번호 0부터 시작
			if (dataset.records[nRow].RowType == "Logical"){
//				var uid = (AUIGrid.getItemByRowIndex(control.AUIcontrolId, nRow * control.rowsPerDataRow))._$uid;
				var uid = this.rows(nRow).rowId;
				dataset.records[nRow]._$uid = uid;
			}
		}
		
		// Sort Method를 수행하면 OnLoadCompleted Event가 발생합니다. 
		// OnLoadCompleted Event의 nReason 값은 0 입니다.
		var nErrorCode = [];
		var strErrorMsg = [];
		if (dataset.hasLoadCompletedEvent) {
			dataset.fncLoadCompletedEvent(dataset, nErrorCode, strErrorMsg, 0);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
			if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
				alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
				return 0;
			}            
		} 
		
		// 그룹정보 갱신 
		if (dataset._GroupKey.length > 0){
			dataset._refreshGroupCation(true);
		}
		
		return cnt;
	};
}

if (typeof ListBoxW == "function"){
	ListBoxW.prototype._UpdateDatasetList = function(arrJsonObjects){ 
		if (this.listSaveType == LISTBOX_SAVE_MULTI  && 
				this.listType == LISTBOX_TYPE_DATASELECT){
			return _ListBox_UpdateDatasetList(this, arrJsonObjects);
		} else {
			return _Common_UpdateDatasetList(this, arrJsonObjects);
		}
	}
}

/**
*     @description	미결
*     @param	{object}	control
*     @return	{object}
*     @example	미결
*/
function _ListBox_UpdateDatasetList(control){ 
	
	if (control.dataBinds == null || getAssociativeArrayLength(control.dataBinds) == 0) return;
	
	var dataset = dataSets[this.bindDataset];
	
	// 기존 정보 클리어
	while(dataset.records.length > 0) {
		dataset.records.pop();
	}
	if (dataset.buffer.length > 0){
		for(var i = dataset.buffer.length - 1; i >= 0 ; i--) {
			dataset.buffer[i].clear();
			dataset.buffer.pop();
		}
	}
	if (dataset.OriginBuffer.length > 0){
		for(var i = dataset.OriginBuffer.length - 1; i >= 0 ; i--) {
			dataset.OriginBuffer[i].clear();
			dataset.OriginBuffer.pop();
		}
	}
	
	// 리스트값 -> 데이터셋
	var nRowNF = 0;
	for (var i=0; i < control.options.length; i++){
		var item = control.options.items[i];
		
		nRowNF = i;
		
		var record = new MiRecord(dataset.colInfos);
		record._orignalIndex = nRowNF;

		dataset.buffer[nRowNF]  = record;
		dataset.records[nRowNF] = record;
		
		for (var key in control.dataBinds){
			var bindInfo = control.dataBinds[key];
			if( typeof(bindInfo) == "function" ) continue;
			
			if (bindInfo.colId.trim().length != 0){
				record.values[bindInfo.colId] =  item.text;	
			}
			if (bindInfo.colId_value.trim().length != 0){
				record.values[bindInfo.colId_value] =  item.value;	
			}
		}
	}
	
	// Row Position의 값은 0 이 됩니다.
	dataset.Row = 0; 

    // Sort Method를 수행하면 OnLoadCompleted Event가 발생합니다. 
	// OnLoadCompleted Event의 nReason 값은 0 입니다.
	var nErrorCode = [];
	var strErrorMsg = [];
	if (dataset.hasLoadCompletedEvent) {
		dataset.fncLoadCompletedEvent(dataset, nErrorCode, strErrorMsg, 0);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
			return 0;
		}            
	} 
	
	return cnt;
};

/**
 * @description	미결
 * @param	{string}	colId
 * @param	{number}	nRow
 * @return  {void}
 * @example	미결
 */
DataSet.prototype.updateControlValue = function(colId, nRow){
	if (this.getRowCount() == 0) return ;
	
	nRow = (nRow == undefined ? this.Row : nRow);

	// 시트값 수정	
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof bindInfo == "function" ){ bindInfo = null; key = null; continue; }
		if( bindInfo.colId == null ){ bindInfo = null; key = null; continue; }
		if( bindInfo.colId != colId ){ bindInfo = null; key = null; continue; }
		if( bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet" ){ bindInfo = null; key = null; continue; }
		
		var record = this.records[nRow];
		var sht = controls[bindInfo.controlName];
		//sht.setValue(sht.getLookingRowNum(nRow + 1), bindInfo.colIndex, record.values[bindInfo.colId])
		sht.setValue(sht.getLookingRowNum(record._$uid), bindInfo.colIndex, record.values[bindInfo.colId], false);
		//메모리 해제
		sht = null; record = null; bindInfo = null; key = null;
	}
	
	// 데이터 리스트값 수정
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;

		if (bindInfo.controlType != "List1") continue;
		var ctl = controls[bindInfo.controlName];
		if (ctl.listSaveType != LISTBOX_SAVE_MULTI) continue;
		if (ctl.listType != LISTBOX_TYPE_DATASELECT) continue;
		
		if (bindInfo.colId != colId &&  bindInfo.colId_value != colId) continue;
		
		var record = this.records[nRow];
		
		if (bindInfo.colId.trim().length != 0){
			var text = record.values[bindInfo.colId];
			ctl.setText(text, false);
		}
		if (bindInfo.colId_value.trim().length != 0){
			var value = record.values[bindInfo.colId_value];
			ctl.setValue(value, false);
		}
	}
	
	// 콤보 리스트 채우기값 수정 
	for (var key in this.innerBinds){
		var bindInfo = this.innerBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlType == "ComboBox" || bindInfo.controlType == "List1") {
			var record = this.records[nRow];
			var wOption = null;
			
			if (this.listSaveType == LISTBOX_SAVE_MULTI  && 
					this.listType == LISTBOX_TYPE_DATASELECT){
				wOption =  controls[bindInfo.controlName].tagObject.options.items[nRow];
			} else {
				wOption =  controls[bindInfo.controlName].tagObject.options[nRow];
			}
			
			if (bindInfo.colId == colId) {
			    wOption.text = record.values[colId];
			} else if (bindInfo.colId_value == colId) {
			    wOption.value = record.values[colId];
			}
		}
		if (bindInfo.controlType == "OptionButton") {
			// 사상이 다르므로 보류 
		}
	}

	// 콘트롤 값 수정
	if (this.Row != nRow) return; // 현재 포커스된 줄번호가 아니면 콘트롤을 갱신할 수 없다(무한루프 위험)
	
	var record = this.records[nRow];
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;

		if (bindInfo.colId != colId && bindInfo.colId_value != colId) continue;
		
		var ctl = controls[bindInfo.controlName];
		ctl.passEvent = true;
		if (bindInfo.controlType == "ComboBox" || bindInfo.controlType == "List1") {
			if ((ctl.listSaveType == LISTBOX_SAVE_MULTI  && ctl.listType == LISTBOX_TYPE_DATASELECT)) continue;
			
			if (bindInfo.colId.length > 0 && bindInfo.colId == colId){
				ctl.setText(record.values[bindInfo.colId]);
			} else {
				ctl.setValue(record.values[bindInfo.colId_value]);
			}
		} else if (bindInfo.controlType == "TextBox" || 
				   bindInfo.controlType == "CheckBox" || 
				   bindInfo.controlType == "Link" || 
				   bindInfo.controlType == "IFrame" || 
				   bindInfo.controlType == "ProgressBar1") {
			ctl.setValue(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "OptionBox") {
			//ctl.setValue(ctl.matchUpValue == record.values[bindInfo.colId] ? 1 : 0);
			controls[ctl.optionGroupName + ""].setValue(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "Label" ) {
			ctl.setCaption(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "PictureBox" ) {
			ctl.setPicture(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "WebEdit" ) {
			ctl.setHTML(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "FlashPlayer" ) {
			ctl.flashUrl = record.values[bindInfo.colId]; 
			ctl.callMovie();
		} else if (bindInfo.controlType == "Sheet" ) {
		} else if (bindInfo.controlType == "lstSheet" ) {
		} else {
			ctl.setValue(record.values[bindInfo.colId]);
		}
		ctl.passEvent = false;
	}
	
    return;
};

/**
 * 콘트롤값 변경시 Dataset에 Column값을 갱신하는 Method
 *
 * _UpdateDataset()
 * _UpdateDataset(nRow, nCol);
 * 
 * @param  nRow  시트인 경우 줄번호 (콘트롤의 경우는 생략) : 1부터 시작된다
 * @param  nCol  시트인 경우 칼럼번호 (콘트롤의 경우는 생략): 1부터 시작된다
 * 
 * @return            (boolean) 성공여부
 */

function _Common_UpdateDataset(control, nRow, nCol){
	var wReturn = true;
	var key = null; var bindInfo = null;
	var ctl = null; var controlType = null;
	var dataset = null; var record = null;
	
	for(key in control.dataBinds){
		bindInfo = control.dataBinds[key];
		if( typeof(bindInfo) == "function" ){ bindInfo = null; key = null; continue; }
		ctl = controls[bindInfo.controlName];
		controlType = bindInfo.controlType;

        dataset = dataSets[bindInfo.datasetId];
        if( dataset.getRowCount() == 0 ){ dataset = null; controlType = null; ctl = null; bindInfo = null; key = null; continue; }
		record = dataset.records[dataset.Row];
		
		if( controlType == "ComboBox" || controlType == "List1" ){
			if( (ctl.listSaveType == LISTBOX_SAVE_MULTI  && ctl.listType == LISTBOX_TYPE_DATASELECT) ){
				record = null; dataset = null; controlType = null; ctl = null; bindInfo = null; key = null;
				continue;
			}
			if( bindInfo.colId.length > 0 ){
				wReturn = dataset.setColumn(dataset.Row, bindInfo.colId, ctl.text);
			} 
			if( bindInfo.colId_value.length > 0 ){
				wReturn = dataset.setColumn(dataset.Row, bindInfo.colId_value, ctl.value);
			}
		} else if( controlType == "TextBox" || 
				   controlType == "CheckBox" || 
				   controlType == "Link" || 
				   controlType == "IFrame" || 
				   controlType == "ProgressBar1" ||
				   controlType == "Label" ){
			wReturn = dataset.setColumn(dataset.Row, bindInfo.colId, ctl.value);
		} else if( controlType == "OptionBox" ){
			wReturn = dataset.setColumn(dataset.Row, bindInfo.colId, controls[ctl.optionGroupName].getValue());
		} else if( controlType == "PictureBox" ){
			wReturn = dataset.setColumn(dataset.Row, bindInfo.colId, ctl.tagObject.getElementsByTagName("IMG")[0].src);
		} else if( controlType == "WebEdit" ){
			wReturn = dataset.setColumn(dataset.Row, bindInfo.colId, ctl.value);
		} else if( controlType == "FlashPlayer" ){
			wReturn = dataset.setColumn(dataset.Row, bindInfo.colId, ctl.flashUrl);
		} else if( controlType == "Sheet" ){
		} else if( controlType == "lstSheet" ){
		} else {
			wReturn = dataset.setColumn(dataset.Row, bindInfo.colId, ctl.value);
		}
		
		record = null; dataset = null;
		controlType = null; ctl = null; bindInfo = null; key = null;
		
		if( !wReturn ) break;
	}
	
	var sht = null;
	var nRowTo = -1;
	
	// 시트값 수정	
	if( (typeof AUIDataSheet == "function" && control instanceof AUIDataSheet)
		|| (typeof AUIDataSheetM == "function" && control instanceof AUIDataSheetM)
	){
		for(key in control.dataBinds){
			bindInfo = control.dataBinds[key];
			if( typeof bindInfo == "function" ){ bindInfo = null; key = null; continue; }
			if( bindInfo.colId == null ){ bindInfo = null; key = null; continue; }
			if( bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet" ){ bindInfo = null; key = null; continue; }
			if( bindInfo.colIndex != nCol ){ bindInfo = null; key = null; continue; }
			
			dataset = dataSets[bindInfo.datasetId];
			sht = controls[bindInfo.controlName];
			nRowTo = -1;
			
			if( typeof nRow == "string" )
				nRowTo = dataset.getIndexOf_$uid(nRow);
			else
				nRowTo = dataset.getIndexOf_$uid(AUIGrid.getItemByRowIndex(sht.AUIcontrolId, (nRow - 1) * sht.rowsPerDataRow)._$uid);
			
			wReturn = dataset.setColumn(nRowTo, bindInfo.colId, sht.getValue(sht.getLookingRowNum(nRow), nCol));
			
			sht = null; dataset = null; bindInfo = null; key = null;
		}
	}
	else if( typeof EasySheet == "function" && control instanceof EasySheet ){
		for(key in control.dataBinds){
			bindInfo = control.dataBinds[key];
			if( typeof bindInfo == "function" ){ bindInfo = null; key = null; continue; }
			if( bindInfo.colId == null ){ bindInfo = null; key = null; continue; }
			if( bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet" ){ bindInfo = null; key = null; continue; }
			if( bindInfo.colIndex != nCol ){ bindInfo = null; key = null; continue; }
			
			dataset = dataSets[bindInfo.datasetId];
			sht = controls[bindInfo.controlName];
			nRowTo = -1;
			
			if( typeof nRow == "string" )
				nRowTo = dataset.getIndexOf_$uid(nRow);
			else
				nRowTo = dataset.getIndexOf_$uid(sht.rows(nRow).rowId);
			
			wReturn = dataset.setColumn(nRowTo, bindInfo.colId, sht.getValue(sht.getLookingRowNum(nRow), nCol));
			
			sht = null; dataset = null; bindInfo = null; key = null;
		}
	}
	
	// 데이터 리스트값 수정
	if( typeof ListBoxW == "function" && control instanceof ListBoxW ){
		for(key in control.dataBinds){
			bindInfo = control.dataBinds[key];
			if( typeof bindInfo == "function" ){ bindInfo = null; key = null; continue; }
			if( bindInfo.controlType != "List1" ){ bindInfo = null; key = null; continue; }
			if( control.listSaveType != LISTBOX_SAVE_MULTI ){ bindInfo = null; key = null; continue; }
			if( control.listType != LISTBOX_TYPE_DATASELECT ){ bindInfo = null; key = null; continue; }
			
			dataset = dataSets[bindInfo.datasetId];
			record = dataset.records[nRow - 1];
			
			if( bindInfo.colId.trim().length != 0 ){
				record.values[bindInfo.colId] = ctl.options.items[nRow - 1].text;	
			}
			if( bindInfo.colId_value.trim().length != 0 ){
				record.values[bindInfo.colId_value] = ctl.options.items[nRow - 1].value;	
			}
			
			record = null; dataset = null; bindInfo = null; key = null;
		}
	}
	
	return wReturn;
};

/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{number}	nCol
 * @return  {object}
 * @example	미결
 */
ControlBase.prototype._UpdateDataset      = function(nRow, nCol){ return _Common_UpdateDataset(this, nRow, nCol);}; 
if (typeof AUIDataSheet == "function")
    AUIDataSheet.prototype._UpdateDataset = function(nRow, nCol){ return _Common_UpdateDataset(this, nRow, nCol);};
if (typeof AUIDataSheetM == "function")
    AUIDataSheetM.prototype._UpdateDataset = function(nRow, nCol){ return _Common_UpdateDataset(this, nRow, nCol);};
    
if( typeof EasySheet == "function" ){
	EasySheet.prototype._UpdateDataset = function(nRow, nCol){ return _Common_UpdateDataset(this, nRow, nCol);};
}
    
/**
 *     @description	미결
 *     @param	{object}	control
 *     @param	{number}	nRow
 *     @param	{number}	nCol
 *     @param	{string}	oldValue
 *     @param	{string}	newValue
 *     @return	{boolean}
 *     @example	미결
 */
function _Common_UpdateCheckDataset(control, nRow, nCol, oldValue, newValue){ 
	for (var key in control.dataBinds){
		
		var bindInfo = control.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		var ctl = controls[bindInfo.controlName];

        var dataset = dataSets[bindInfo.datasetId];
        if(dataset.getRowCount() == 0) continue;
		var record = dataset.records[dataset.Row];
		
		if (bindInfo.controlType == "Sheet" ) {
		} else if (bindInfo.controlType == "lstSheet" ) {
		} else if (bindInfo.controlType == "ComboBox" || bindInfo.controlType == "List1") {
			if (bindInfo.colId.length > 0){
				return dataset.checkCanColumnChange(dataset.Row, bindInfo.colId, oldValue, newValue)
			} 
			if (bindInfo.colId_value.length > 0){
				return dataset.checkCanColumnChange(dataset.Row, bindInfo.colId_value, oldValue, newValue)
			}
		} else {
			return dataset.checkCanColumnChange(dataset.Row, bindInfo.colId, oldValue, newValue)
		}
	}
	
	// 시트값 수정	
	if ((typeof AUIDataSheet == "function" && control instanceof AUIDataSheet) || 
		(typeof AUIDataSheetM == "function" && control instanceof AUIDataSheetM)){
		for (var key in control.dataBinds){
			var bindInfo = control.dataBinds[key];
			if( typeof(bindInfo) == "function" ) continue;

			if (bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet")  continue;
			if (bindInfo.colIndex != nCol) continue;
			
			var dataset = dataSets[bindInfo.datasetId];
			var sht = control;
			
			var nRowTo =  -1;
			if (typeof nRow == "string"){
				nRowTo = dataset.getIndexOf_$uid(nRow);
			}
			else {
				nRowTo = dataset.getIndexOf_$uid(AUIGrid.getItemByRowIndex(sht.AUIcontrolId, (nRow - 1) * sht.rowsPerDataRow)._$uid);
			}
			
			return dataset.checkCanColumnChange(nRowTo, bindInfo.colId, oldValue, newValue);
		}
	}
	else if( typeof EasySheet == "function" && control instanceof EasySheet ){
		var key = null;
		var bindInfo = null;
		var dataset = null;
		var colId = null;
		var nRowTo = -1;
		var result = null;
		
		for(key in control.dataBinds){
			bindInfo = control.dataBinds[key];
			
			if( typeof bindInfo == "function" ) continue;
			if( bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet" ) continue;
			if( bindInfo.colIndex != nCol ) continue;
			
			colId = bindInfo.colId;
			nRowTo = -1;
			dataset = dataSets[bindInfo.datasetId];
			
			if( typeof nRow == "string" )
				nRowTo = dataset.getIndexOf_$uid(nRow);
			else
				nRowTo = dataset.getIndexOf_$uid(control.rows(nRow).rowId);
			
			result = dataset.checkCanColumnChange(nRowTo, colId, oldValue, newValue);
			
			dataset = null;
			colId = null;
			bindInfo = null;
			key = null;
			
			return result;
		}
	}
	
	return true;
	
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{number}	nCol
 * @param	{string}	oldValue
 * @param	{string}	newValue
 * @return  {object}
 * @example	미결
 */
ControlBase.prototype._UpdateCheckDataset      = function(nRow, nCol, oldValue, newValue){ return _Common_UpdateCheckDataset(this, nRow, nCol, oldValue, newValue);}; 
if (typeof AUIDataSheet == "function")
    AUIDataSheet.prototype._UpdateCheckDataset = function(nRow, nCol, oldValue, newValue){ return _Common_UpdateCheckDataset(this, nRow, nCol, oldValue, newValue);};
if (typeof AUIDataSheetM == "function")
    AUIDataSheetM.prototype._UpdateCheckDataset = function(nRow, nCol, oldValue, newValue){ return _Common_UpdateCheckDataset(this, nRow, nCol, oldValue, newValue);};

if( typeof EasySheet == "function" ){
	EasySheet.prototype._UpdateCheckDataset = function(nRow, nCol, oldValue, newValue){ return _Common_UpdateCheckDataset(this, nRow, nCol, oldValue, newValue);};
}
    
    
// 사용방법  ...updateControlRowData(레코드번호) 또는 ...updateControlRowData(레코드)
/**
 * @description	미결
 * @param	{number}	varRow
 * @return  {void}
 * @example	미결
 */
DataSet.prototype.updateControlRowData = function(varRow){
	if (this.getRowCount() == 0) return ;
	if (varRow == undefined){ varRow = this.Row;} 

	var nRow = 0, shtRowId = "";  // nRow: 0부터 시작 
	if (typeof(varRow) != "number" ){
		record = varRow;
		shtRowId = record._$uid;
		nRow = this.getIndexOf_$uid(shtRowId);
	} else {
		nRow = varRow;
		record = this.records[nRow];
	}
	
	// 시트값 수정	
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof bindInfo == "function" ){ bindInfo = null; key = null; continue; }
		if( bindInfo.colId == null ){ bindInfo = null; key = null; continue; }
		if( bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet" ){ bindInfo = null; key = null; continue; }
		
		var sht = controls[bindInfo.controlName];
		var value = record.values[bindInfo.colId];
		if ( typeof value != "undefined" && value != null ){
			if (shtRowId.length > 0){
//				sht.setValue(sht.getLookingRowNum(shtRowId), bindInfo.colIndex, record.values[bindInfo.colId], false);
				sht.setValue(sht.getLookingRowNum(shtRowId), bindInfo.colIndex, value, false);
			} else {
				nRow = nRow + (typeof EasySheet != "undefined" && sht instanceof EasySheet ? sht.startRowColNum : 1);
//				sht.setValue(sht.getLookingRowNum(nRow), bindInfo.colIndex, record.values[bindInfo.colId], false);
				sht.setValue(sht.getLookingRowNum(nRow), bindInfo.colIndex, value, false);
			}
		}
		//메모리 해제
		value = null; sht = null; bindInfo = null; key = null;
	}
	
	// 데이터 리스트값 수정
	var record = this.records[nRow];
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;

		if (bindInfo.controlType != "List1") continue;
		var ctl = controls[bindInfo.controlName];
		if (ctl.listSaveType != LISTBOX_SAVE_MULTI) continue;
		if (ctl.listType != LISTBOX_TYPE_DATASELECT) continue;
		
		if (bindInfo.colId.trim().length != 0){
			var text = record.values[bindInfo.colId];
			ctl.setText(text, false);
		}
		if (bindInfo.colId_value.trim().length != 0){
			var value = record.values[bindInfo.colId_value];
			ctl.setValue(value, false);
		}
	}
	
	// 콘트롤 값 수정
	if (this.Row != nRow) return; // 현재 포커스된 줄번호가 아니면 콘트롤을 갱신할 수 없다(무한루프 위험)
	
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		
		var record = this.records[nRow];
		var ctl = controls[bindInfo.controlName];
		ctl.passEvent = true;
		if (bindInfo.controlType == "ComboBox" || bindInfo.controlType == "List1") {
			if ((ctl.listSaveType == LISTBOX_SAVE_MULTI  && ctl.listType == LISTBOX_TYPE_DATASELECT)) continue;
			if (bindInfo.colId.length > 0){
				ctl.setText(record.values[bindInfo.colId]);
			} else {
				ctl.setValue(record.values[bindInfo.colId_value]);
			}
		} else if (bindInfo.controlType == "TextBox" || 
				   bindInfo.controlType == "CheckBox" || 
				   bindInfo.controlType == "Link" || 
				   bindInfo.controlType == "IFrame" || 
				   bindInfo.controlType == "ProgressBar1") {
			ctl.setValue(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "OptionBox") {
			//ctl.setValue(ctl.matchUpValue == record.values[bindInfo.colId] ? 1 : 0);
			controls[ctl.optionGroupName + ""].setValue(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "Label" ) {
			ctl.setCaption(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "PictureBox" ) {
			ctl.setPicture(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "WebEdit" ) {
			ctl.setHTML(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "FlashPlayer" ) {
			ctl.flashUrl = record.values[bindInfo.colId]; 
			ctl.callMovie();
		} else if (bindInfo.controlType == "Sheet" ) {
		} else if (bindInfo.controlType == "lstSheet" ) {
		} else {
			ctl.setValue(record.values[bindInfo.colId]);
		}
		ctl.passEvent = false;
	}
	
    return;
};

/**
 * @description	미결
 * @param	{number}	varRow
 * @param	{number}	moveRowPos
 * @return  {void}
 * @example	미결
 */
DataSet.prototype.updateControlRowPosition = function(varRow, moveRowPos){
	if (this.getRowCount() == 0) return ;
	if (varRow == undefined) varRow = this.Row;
	
	var nRow = 0, shtRowId = "";
	if (typeof(varRow) != "number" ){
		record = varRow;
		shtRowId = record._$uid;
	} else {
		nRow = varRow;
		record = this.records[nRow];
		shtRowId = record._$uid;
	}
		
	// 데이터 리스트내 위치 수정
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;

		if (bindInfo.controlType != "List1") continue;
		var ctl = controls[bindInfo.controlName];
		if (ctl.listSaveType != LISTBOX_SAVE_MULTI) continue;
		if (ctl.listType != LISTBOX_TYPE_DATASELECT) continue;
		
		if (nRow == 0) {
			for (var i =0; i < this.records.length; i++){
				if (this.records[i] == record){
					nRow = i;
					break;
				}
			}
		}
		
		ctl.selectItem(nRow, false);
	}
	
	var tmpBinds = [];
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet") continue;
		tmpBinds[bindInfo.controlName] = bindInfo.controlType;
	}
	
	for (var controlName in tmpBinds){
		if( typeof(tmpBinds[controlName]) == "function" ) continue;
		
		var sht = controls[controlName];
		if( typeof(sht) == "function" ) continue;
		
		sht.setCurrentRow(sht.getLookingRowNum(shtRowId));
		if( moveRowPos ){
			if( (typeof AUIDataSheet == "function" && control instanceof AUIDataSheet)
				|| (typeof AUIDataSheetM == "function" && control instanceof AUIDataSheetM)
			){
				sht.setProperty("rowPosition", sht.currentRow);
			}
			else if( typeof EasySheet == "function" && control instanceof EasySheet ){
				sht.moveToRow(sht.currentRow);
			}
		}
	}	
	
    for (var key in this.dataBinds){
        var bindInfo = this.dataBinds[key]
        if (typeof bindInfo == "function") continue;
		if (bindInfo.controlType == "Sheet" || bindInfo.controlType == "lstSheet") continue;
        this.updateControlValue(bindInfo.colId);
    }	
	
	tmpBinds.clear();

	return;
};

// 시트와 데이터 셋에 동시 적용
/**
*     @description	미결
*     @param	{object}	control
*     @param	{number}	nRow
*     @return	{void}
*     @example	미결
*/
function _Common_UpdateDatasetRowPos(control, nRow){ 
	var tmpBinds = [];
	for (var key in control.dataBinds){
		var bindInfo = control.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlName != control.controlName) continue;
		tmpBinds[bindInfo.datasetId] = bindInfo.controlType;
	}
	
	for (var datasetId in tmpBinds){
	    var bindInfo = tmpBinds[datasetId];
		if( typeof(bindInfo) == "function" ) continue;
		
		var dataset = dataSets[datasetId];
		
		if( (typeof AUIDataSheet == "function" && control instanceof AUIDataSheet)
			|| (typeof AUIDataSheetM == "function" && control instanceof AUIDataSheetM)
		){
			var nRowTo =  -1;
			if (typeof nRow == "string"){
				nRowTo = dataset.getIndexOf_$uid(nRow);
			}
			else {
				nRowTo = dataset.getIndexOf_$uid(AUIGrid.getItemByRowIndex(control.AUIcontrolId, (nRow - 1) * control.rowsPerDataRow)._$uid);
			}
			dataset.setRowPos(nRowTo);
		}
		
		if( typeof EasySheet == "function" && control instanceof EasySheet ){
			var nRowTo =  -1;
			if( typeof nRow == "string" ){
				nRowTo = dataset.getIndexOf_$uid(nRow);
			}
			else{
				nRowTo = dataset.getIndexOf_$uid(control.rows(nRow).rowId);
			}
			dataset.setRowPos(nRowTo);
		}
		
		if (typeof ListBoxW == "function" && control instanceof ListBoxW){
			dataset.setRowPos(nRow);
		}
	}	
	
	tmpBinds.clear();
	
    return;
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @return  {object}
 * @example	미결
 */
ControlBase.prototype._UpdateDatasetRowPos      = function(nRow){ return _Common_UpdateDatasetRowPos(this, nRow);}; 
if (typeof AUIDataSheet == "function")
    AUIDataSheet.prototype._UpdateDatasetRowPos = function(nRow){ return _Common_UpdateDatasetRowPos(this, nRow);};
if (typeof AUIDataSheetM == "function"){
	AUIDataSheetM.prototype._UpdateDatasetRowPos = function(nRow){ return _Common_UpdateDatasetRowPos(this, nRow);};
}

if( typeof EasySheet == "function" ){
	EasySheet.prototype._UpdateDatasetRowPos = function(nRow){ return _Common_UpdateDatasetRowPos(this, nRow);};
}

/**
 * @description	미결
 * @param	{string}	record
 * @param	{number}	nRow
 * @return  {void}
 * @example	미결
 */    
DataSet.prototype.updateControlAddRow = function(record, nRow){  // nRow 가 없으면 마지막에 추가한다
	if (this.getRowCount() == 0) return ;

	// 시트에서 줄추가 상태면 다시시트를 갱신하지 않음
	if (this.__lastAction() == "SHEET_ADDED_ROW") return; 
	// 데이터 셋에서 줄추가상태로 바꿈
	this.__pushActionStack("DATASET_ADDED_ROW");          
	
	//if (nRow == undefined) nRow = this.getLastRow();
	
	//시트 행 추가
	var tmpBinds = [];
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet") continue;
		tmpBinds[bindInfo.controlName] = bindInfo.controlType;
	}
	
	for (var controlName in tmpBinds){
		if( typeof(tmpBinds[controlName]) == "function" ) continue;
		
		var sht = controls[controlName];
		if( typeof(sht) == "function" ) continue;
		
		var shtRowNum = 0;
		
//		if (nRow == undefined) {
//			shtRowNum = sht.addRow(null, null, false);
//		}else {
//			// sheet.addRow는 선택한 줄 뒤로 줄이 추가되는 함수이다, nRow는 Grid의 줄번호이다
//			// 첫줄에 추가하려면 0 을 주면 된다, 이해를 돕기위해 코딩을 압축하지 않음
//			var nSheetRow = nRow + 1;
//			var nRowNumToAppend = nSheetRow - 1;
//			shtRowNum = sht.addRow(sht.getLookingRowNum(nRowNumToAppend), null, false);
//		}
//		if ((typeof AUIDataSheet == "function" && sht instanceof AUIDataSheet) ||
//			(typeof AUIDataSheetM == "function" && sht instanceof AUIDataSheetM)){
//			record._$uid = AUIGrid.getItemByRowIndex(sht.AUIcontrolId, (shtRowNum - 1) * sht.rowsPerDataRow)._$uid; // AUI는 번호가 하나 작다
//			
//			// 추가된 데이터에 관련 시트데이터 수정
//			this.updateControlRowData(record); // this.updateControlRowData(nToRow);
//		}
		
		if( (typeof AUIDataSheet == "function" && sht instanceof AUIDataSheet)
			|| (typeof AUIDataSheetM == "function" && sht instanceof AUIDataSheetM)
		){
			if( nRow == undefined ){
				shtRowNum = sht.addRow(null, null, false);
			}
			else{
				// sheet.addRow는 선택한 줄 뒤로 줄이 추가되는 함수이다, nRow는 Grid의 줄번호이다
				// 첫줄에 추가하려면 0 을 주면 된다, 이해를 돕기위해 코딩을 압축하지 않음
				var nSheetRow = nRow + 1;
				var nRowNumToAppend = nSheetRow - 1;
				shtRowNum = sht.addRow(sht.getLookingRowNum(nRowNumToAppend), null, false);
			}
			
			record._$uid = AUIGrid.getItemByRowIndex(sht.AUIcontrolId, (shtRowNum - 1) * sht.rowsPerDataRow)._$uid; // AUI는 번호가 하나 작다
			
			// 추가된 데이터에 관련 시트데이터 수정
			this.updateControlRowData(record); // this.updateControlRowData(nToRow);
		}
		else if( typeof EasySheet == "function" && sht instanceof EasySheet ){
			shtRowNum = sht.addRow(nRow, null, false);
			record._$uid = sht.rows(shtRowNum).rowId;
			// 추가된 데이터에 관련 시트데이터 수정
			this.updateControlRowData(record); // this.updateControlRowData(nToRow);
		}
	}
	tmpBinds.clear();
	
	
	// 데이터 리스트에 행추가
	// 마지막 줄에만 추가가 가능하다
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;

		if (bindInfo.controlType != "List1") continue;
		var ctl = controls[bindInfo.controlName];
		if (ctl.listSaveType != LISTBOX_SAVE_MULTI) continue;
		if (ctl.listType != LISTBOX_TYPE_DATASELECT) continue;
		
		if (nRow == undefined) {
			var text = ""; var value = "";
			if (bindInfo.colId.trim().length != 0){
				text = record.values[bindInfo.colId];
			}
			if (bindInfo.colId_value.trim().length != 0){
				value = record.values[bindInfo.colId_value];
			}
			ctl.addItem(text, value, false);
		} else {
			if (typeof console != "undefined"){
				if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_019", "데이터 리스트는 마지막에 추가만 가능합니다"));
				if(typeof console != "undefined" && typeof console.trace == "function")	console.trace();
			}
		}
	}
	
	///*2016-03-23 수정 (차중훈) : 콤보박스, 리스트에 항목 추가
	//콤보, 리스트 항목 추가
	tmpBinds = [];
	for (var key in this.innerBinds){
		var bindInfo = this.innerBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlType != "ComboBox" && bindInfo.controlType != "List1") continue;
		tmpBinds[bindInfo.controlName] = bindInfo.controlType;
	}
	for (var controlName in tmpBinds){
		if( typeof(tmpBinds[controlName]) == "function" ) continue;
		
		var ctl = controls[controlName];
		if( typeof(ctl) == "function" ) continue;
		
		if (nRow == undefined) {
			ctl.addItem("", "");
		}else {
			ctl.insertItem("", "", nRow);
		}
	}
	tmpBinds.clear();
	//*/2016-03-23 수정 (차중훈)
	
	//현재 행의 데이터를 갱신
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		
		var record = this.records[this.Row];
		var ctl = controls[bindInfo.controlName];
		ctl.passEvent = true;
		if (bindInfo.controlType == "ComboBox" || bindInfo.controlType == "List1") {
			if ((ctl.listSaveType == LISTBOX_SAVE_MULTI  && ctl.listType == LISTBOX_TYPE_DATASELECT)) continue;
			if (bindInfo.colId.length > 0){
				ctl.setText(record.values[bindInfo.colId]);
			} else {
				ctl.setValue(record.values[bindInfo.colId_value]);
			}
		} else if (bindInfo.controlType == "TextBox" || 
				   bindInfo.controlType == "CheckBox" || 
				   bindInfo.controlType == "Link" || 
				   bindInfo.controlType == "IFrame" || 
				   bindInfo.controlType == "ProgressBar1") {
			ctl.setValue(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "OptionBox") {
			//ctl.setValue(ctl.matchUpValue == record.values[bindInfo.colId] ? 1 : 0);
			controls[ctl.optionGroupName + ""].setValue(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "Label" ) {
			ctl.setCaption(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "PictureBox" ) {
			ctl.setPicture(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "WebEdit" ) {
			ctl.setHTML(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "FlashPlayer" ) {
			ctl.flashUrl = record.values[bindInfo.colId]; 
			ctl.callMovie();
		} else if (bindInfo.controlType == "Sheet" ) {
		} else if (bindInfo.controlType == "lstSheet" ) {
		} else {
			ctl.setValue(record.values[bindInfo.colId]);
		}
		ctl.passEvent = false;
	}
	
	// 데이터 셋에서 줄추가 상태 지움
	this.__popActionStack();
	
    return;
};

// 시트와 데이텃셋 공용
/**
*     @description	미결
*     @param	{object}	control
*     @param	{number}	nRow
*     @return	{void}
*     @example	미결
*/
function _Common_UpdateDatasetAddRow(control, nRow){ //nRow는 시트의 불번호로 1부터 시작된다
	var tmpBinds = [];
	for (var key in control.dataBinds){
		var bindInfo = control.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlName != control.controlName) continue;
		tmpBinds[bindInfo.datasetId] = bindInfo.controlType;
	}
	
	for (var datasetId in tmpBinds){
	    var dataset = dataSets[datasetId];
		if( typeof(dataset) == "function" ) continue;
		
		// 데이터 셋에서 줄추가 상태면 다시 데이터셋을 갱신하지 않음
		if (dataset.__lastAction() == "DATASET_ADDED_ROW") continue; 
		// 시트에서 줄추가 상태로 바꿈
		dataset.__pushActionStack("SHEET_ADDED_ROW");          
		
		var nDatesetRow = 0;
		
		if ((typeof AUIDataSheet == "function" && control instanceof AUIDataSheet) || 
			(typeof AUIDataSheetM == "function" && control instanceof AUIDataSheetM)){
			var delRows = AUIGrid.getSelectedItems(control.AUIcontrolId);
			var delRowLen  = delRows.length;
			
			if (nRow == undefined || nRow == control.maxRows - delRowLen) {
				nDatesetRow = dataset.addRow();
			}else {
				nDatesetRow = dataset.insertRow(nRow - 1);
			}
			var record = dataset.records[nDatesetRow];
			// record._$uid =  AUIGrid.getItemByRowIndex(control.AUIcontrolId, nRow)._$uid;  ???
			record._$uid =  AUIGrid.getItemByRowIndex(control.AUIcontrolId, (nRow - 1) * control.rowsPerDataRow)._$uid;
			dataset.updateControlRowData(record);
		}
		
		if( typeof EasySheet == "function" && control instanceof EasySheet ){
			var record = null;
			if( nRow == undefined || nRow == control.maxRows ){
				nDatesetRow = dataset.addRow();
			}
			else{
				nDatesetRow = dataset.insertRow(nRow);
			}
			record = dataset.records[nDatesetRow];
			record._$uid =  control.rows(nRow - control.startRowColNum).rowId;
			dataset.updateControlRowData(record);
		}
		
		if (typeof ListBoxW == "function"){
			if (control instanceof ListBoxW){
				
				if (nRow == undefined || nRow == control.maxRows) {
					nDatesetRow = dataset.addRow();
				}else {
					nDatesetRow = dataset.insertRow(nRow - 1);
				}
				var record = dataset.records[nDatesetRow];
				dataset.updateControlRowData(record);
			}
		}
		
		// 시트에서 줄추가 상태 지움
		dataset.__popActionStack();
	}
	
	tmpBinds.clear();

	
	
    return;
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @return  {void}
 * @example	미결
 */
ControlBase.prototype._UpdateDatasetAddRow      = function(nRow){ _Common_UpdateDatasetAddRow(this, nRow); return;}; 
if (typeof AUIDataSheet == "function")
    AUIDataSheet.prototype._UpdateDatasetAddRow = function(nRow){ _Common_UpdateDatasetAddRow(this, nRow); return;};
if (typeof AUIDataSheetM == "function")
    AUIDataSheetM.prototype._UpdateDatasetAddRow = function(nRow){ _Common_UpdateDatasetAddRow(this, nRow); return;};
    
if( typeof EasySheet == "function" ){
	EasySheet.prototype._UpdateDatasetAddRow = function(nRow){ _Common_UpdateDatasetAddRow(this, nRow); return;};
}
    
    /**
    * @description	미결
    * @param	{number}	varRow
    * @return 	{void}
    * @example	미결
    */
DataSet.prototype.updateControlDelRow = function(varRow){
	// 시트에서 줄삭제 상태면 다시시트를 갱신하지 않음
	if (this.__lastAction() == "SHEET_DELETED_ROW") return; 
	// 데이터 셋에서 줄삭제 상태로 바꿈
	this.__pushActionStack("DATASET_DELETED_ROW");   
	
	if (varRow == undefined) varRow = this.getLastRow();
	
	var nRow = 0, shtRowId = "";
	if (typeof(varRow) != "number" ){
		record = varRow;
		shtRowId = record._$uid;
	} else {
		nRow = varRow;
		record = this.records[nRow];
		shtRowId = record._$uid;
	}       
	
	//시트 행 삭제
	var tmpBinds = [];
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet") continue;
		///*2016-03-24 수정 (차중훈) : 시트에 행이 없는 경우 tmpBinds에 추가하지 않음(아래 for문에서 시트 행삭제 하지 않음)
		if (controls[bindInfo.controlName].maxRows <= 0) continue;
		//*/2016-03-24 수정 (차중훈)
		tmpBinds[bindInfo.controlName] = bindInfo.controlType;
	}
	
	for (var controlName in tmpBinds){
		if( typeof(tmpBinds[controlName]) == "function" ) continue;
		
		var sht = controls[controlName];
		if( typeof(sht) == "function" ) continue;
		
		if (sht.isAvailableRowId(shtRowId)){
			if( (typeof AUIDataSheet == "function" && sht instanceof AUIDataSheet)
				|| (typeof AUIDataSheetM == "function" && sht instanceof AUIDataSheetM)
			){
				sht.delRowByUid(shtRowId);
			}
			else if( typeof EasySheet == "function" && sht instanceof EasySheet ){
				var rowIndex = sht.dataSet.getInexByRowId(shtRowId);
				sht.delRow(rowIndex + sht.startRowColNum, null, false);
			}
		}
	}
	tmpBinds.clear();
	
	// 데이터 리스트에 행 삭제
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;

		if (bindInfo.controlType != "List1") continue;
		var ctl = controls[bindInfo.controlName];
		if (ctl.listSaveType != LISTBOX_SAVE_MULTI) continue;
		if (ctl.listType != LISTBOX_TYPE_DATASELECT) continue;
		
		ctl.removeItem(record.values[bindInfo.colId], false);
	}
	
	///*2016-03-24 수정 (차중훈) : 콤보박스, 리스트에 항목 삭제
	//콤보, 리스트 항목 삭제
	tmpBinds = [];
	for (var key in this.innerBinds){
		var bindInfo = this.innerBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlType != "ComboBox" && bindInfo.controlType != "List1") continue;
		tmpBinds[bindInfo.controlName] = bindInfo.controlType;
	}
	for (var controlName in tmpBinds){
		if( typeof(tmpBinds[controlName]) == "function" ) continue;
		
		var ctl = controls[controlName];
		if( typeof(ctl) == "function" ) continue;
		
		this.updateControlList();
	}
	tmpBinds.clear();
	//*/2016-03-23 수정 (차중훈)
	
	// 데이터 셋에서 줄삭제 상태 지움
	this.__popActionStack();
	
    return;
};

// 시트와 데이터리스트 공통함수 [varRow는 1부터 시작 ]
/**
*     @description	미결
*     @param	{object}	control
*     @param	{number}	varRow
*     @return	{string}
*     @example	미결
*/
function _Common_UpdateDatasetDelRow(control, varRow){ 
	if (varRow == undefined)  return;
    
	var nRow = 0; var uid = "";
	if (typeof varRow == "number"){
		nRow= varRow;
		if( (typeof AUIDataSheet == "function" && control instanceof AUIDataSheet)
			|| (typeof AUIDataSheetM == "function" && control instanceof AUIDataSheetM)
		){
			uid = AUIGrid.getItemByRowIndex(control.AUIcontrolId, (nRow - 1)  * control.rowsPerDataRow)._$uid;
		}
		else if( typeof EasySheet == "function" && control instanceof EasySheet ){
			uid = control.rows(nRow - control.startRowColNum).rowId;
		}
	} else {
		uid = varRow;
	}
	
	var tmpBinds = [];
	for (var key in control.dataBinds){
		var bindInfo = control.dataBinds[key];
		if( typeof(control.dataBinds[key]) == "function" ) continue;
		if (bindInfo.controlName != control.controlName) continue;
		tmpBinds[bindInfo.datasetId] = bindInfo.controlType;
	}
	
	for (var datasetId in tmpBinds){
	    var dataset = dataSets[datasetId];
		if( typeof(dataset) == "function" ) continue;
		
		// 데이터 셋에서 줄삭제  상태면 다시 데이터셋을 갱신하지 않음
		if (dataset.__lastAction() == "DATASET_DELETED_ROW") continue; 
		// 시트에서 줄추가 상태로 바꿈
		dataset.__pushActionStack("SHEET_DELETED_ROW");
		         
		if ((typeof AUIDataSheet == "function" && control instanceof AUIDataSheet) || 
			(typeof AUIDataSheetM == "function" && control instanceof AUIDataSheetM)){
			if (dataset.isAvailableRowId(uid)){
				var nRowToDel = dataset.getIndexOf_$uid(uid);
				dataset.deleteRow(nRowToDel);
			}
		}
		else if( typeof EasySheet == "function" && control instanceof EasySheet ){
//			var rowIndex = control.dataSet.getInexByRowId(uid);
//			control.delRow(rowIndex + control.startRowColNum, null, false);
			
			if( dataset.isAvailableRowId(uid) ){
				var nRowToDel = dataset.getIndexOf_$uid(uid);
				dataset.deleteRow(nRowToDel);
			}
		}
		
		if (typeof ListBoxW == "function" && control instanceof ListBoxW){ 
			dataset.deleteRow(nRow - 1);
		}

		// 데이터 셋에서 줄추가 상태 지움
		dataset.__popActionStack();
	}
	
	tmpBinds.clear();

    return;
};
/**
 * @description	미결
 * @param	{number}	varRow
 * @return  {void}
 * @example	미결
 */
ControlBase.prototype._UpdateDatasetDelRow = function(varRow){ _Common_UpdateDatasetDelRow(this, varRow); return;}; 
if (typeof AUIDataSheet == "function")
    AUIDataSheet.prototype._UpdateDatasetDelRow = function(varRow){ _Common_UpdateDatasetDelRow(this, varRow); return;};
if (typeof AUIDataSheetM == "function")
    AUIDataSheetM.prototype._UpdateDatasetDelRow = function(varRow){ _Common_UpdateDatasetDelRow(this, varRow); return;};

if( typeof EasySheet == "function" ){
	EasySheet.prototype._UpdateDatasetDelRow = function(varRow){ _Common_UpdateDatasetDelRow(this, varRow); return;};
}
    
// 데이터 리스트는 기능제외 [이동을 지원하지 않음]
    /**
     *     @description	미결
     *     @param	{object}	control
     *     @param	{number}	cRow
     *     @return	{void}
     *     @example	미결
     */
function _Common_UpdateDatasetUpRow(control, nRow){ 
	var tmpBinds = [];
	for (var key in control.dataBinds){
		var bindInfo = control.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlName != control.controlName) continue;
		tmpBinds[bindInfo.datasetId] = bindInfo.controlType;
	}
	
	for (var datasetId in tmpBinds){
	    var dataset = dataSets[datasetId];
		if( typeof(dataset) == "function" ) continue;
		
		var datasetRow = nRow - 1;
		if (datasetRow == 0) continue;

		var record = dataset.records[datasetRow];
	    dataset.records[datasetRow] = dataset.records[datasetRow - 1];
	    dataset.records[datasetRow - 1] = record;
	    
	    dataset.Row = datasetRow - 1;
	}
	
	tmpBinds.clear();
    return;
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @return  {void}
 * @example	미결
 */
ControlBase.prototype._UpdateDatasetUpRow      = function(nRow){ _Common_UpdateDatasetUpRow(this, nRow); return;}; 
if (typeof AUIDataSheet == "function")
    AUIDataSheet.prototype._UpdateDatasetUpRow = function(nRow){ _Common_UpdateDatasetUpRow(this, nRow); return;};
if (typeof AUIDataSheetM == "function")
    AUIDataSheetM.prototype._UpdateDatasetUpRow = function(nRow){ _Common_UpdateDatasetUpRow(this, nRow); return;};

if( typeof EasySheet == "function" ){
	EasySheet.prototype._UpdateDatasetUpRow = function(nRow){ _Common_UpdateDatasetUpRow(this, nRow); return;};
}

/**
 *     @description	미결
 *     @param	{object}	control
 *     @param	{number}	nRow
 *     @return	{void}
 *     @example	미결
 */     
function _Common_UpdateDatasetDownRow(control, nRow){ 
	var tmpBinds = [];
	for (var key in control.dataBinds){
		var bindInfo = control.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlName != control.controlName) continue;
		tmpBinds[bindInfo.datasetId] = bindInfo.controlType;
	}
	
	for (var datasetId in tmpBinds){
	    var dataset = dataSets[datasetId];
		if( typeof(dataset) == "function" ) continue;

		var datasetRow = nRow - 1;
		if (datasetRow == dataset.records.length -1) continue;
		
	    var record = dataset.records[datasetRow];
	    dataset.records[datasetRow] = dataset.records[datasetRow + 1];
	    dataset.records[datasetRow + 1] = record;
	    
	    dataset.Row = datasetRow + 1;
	}

	tmpBinds.clear();
    return;
};

/**
 * @description	미결
 * @param	{number}	nRow
 * @return  {void}
 * @example	미결
 */
ControlBase.prototype._UpdateDatasetDownRow = function(nRow){ _Common_UpdateDatasetDownRow(this, nRow); return;}; 
if (typeof AUIDataSheet == "function")
    AUIDataSheet.prototype._UpdateDatasetDownRow = function(nRow){ _Common_UpdateDatasetDownRow(this, nRow); return;};
if (typeof AUIDataSheetM == "function")
    AUIDataSheetM.prototype._UpdateDatasetDownRow = function(nRow){ _Common_UpdateDatasetDownRow(this, nRow); return;};

if( typeof EasySheet == "function" ){
	EasySheet.prototype._UpdateDatasetDownRow = function(nRow){ _Common_UpdateDatasetDownRow(this, nRow); return;};
}
        
// 시트와 데이터리스트 공용        
    /**
     *     @description	미결
     *     @param	{object}	control
     *     @return	{void}
     *     @example	미결
     */
function _Common_UpdateDatasetClear(control){ 

	var tmpBinds = [];
	for (var key in control.dataBinds){
		var bindInfo = control.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlName != control.controlName) continue;
		tmpBinds[bindInfo.datasetId] = bindInfo.controlType;
	}
	
	for (var datasetId in tmpBinds){
		if( typeof(tmpBinds[datasetId]) == "function" ) continue;
		var dataSet = dataSets[datasetId];
		
		// 데이터 셋에서 줄 클리어  상태면 다시 데이터셋을 갱신하지 않음
		if (dataSet.__lastAction() == "DATASET_REFRESHED_ROW") continue; 
		// 시트에서 줄 클리어  상태로 바꿈
		dataSet.__pushActionStack("SHEET_CLEARED_ROW");    
		
		dataSet.clearData();

	    // 시트에서 줄 클리어  상태로 지움
	    dataSet.__popActionStack();
	}
	
	tmpBinds.clear();
	
    return;
};
/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
ControlBase.prototype._UpdateDatasetClear = function(){ _Common_UpdateDatasetClear(this); return;}; 
if (typeof AUIDataSheet == "function")
    AUIDataSheet.prototype._UpdateDatasetClear = function(){ _Common_UpdateDatasetClear(this); return;};
if (typeof AUIDataSheetM == "function")
    AUIDataSheetM.prototype._UpdateDatasetClear = function(){ _Common_UpdateDatasetClear(this); return;};
    
if( typeof EasySheet == "function" ){
	EasySheet.prototype._UpdateDatasetClear = function(){ _Common_UpdateDatasetClear(this); return;};
}


/**
 *     @description	미결
 *     @param	{object}	control
 *     @param	{number}	rowIndex
 *     @param	{number}	columnIndex
 *     @param	{string}	value
 *     @param	{string}	oldValue
 *     @return	{void}
 *     @example	미결
 */
function _Common_updatePivotCell(control, rowIndex, columnIndex, value, oldValue){
	
	// 1. 연결데이터 셋을 찾는다 
	var datsSetName = "";
	for (var key in control.dataBinds){
		var bindInfo = control.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		
		var dataset = dataSets[bindInfo.datasetId];
		
		dataset.updatePivotCell(rowIndex - 1, columnIndex - 1, value, oldValue);
		break;
	}

	return;
};    
    
if (typeof AUIDataSheet == "function")
    AUIDataSheet.prototype.updatePivotCell = function(rowIndex, columnIndex, value, oldValue){ return _Common_updatePivotCell(this, rowIndex, columnIndex, value, oldValue);};
if (typeof AUIDataSheetM == "function")
    AUIDataSheetM.prototype.updatePivotCell = function(rowIndex, columnIndex, value, oldValue){ return _Common_updatePivotCell(this, rowIndex, columnIndex, value, oldValue);};

   
/**
 * 그리드 채우기에 필요한 목록을 컨트롤에서 빼간다
 *
  * @return             추출된 배열값
 */
ControlBase.prototype.getListArray = function(){
	if (!this instanceof ComboBox && !this instanceof ListBox) {
		return [];
	}
	
	var returnArray = [];
    var wOptions =  this.tagObject.options;
    
//    for (var i = 0; i < wOptions.length; i++){
//    	returnArray[i] = wOptions[i].text;
//    }
    
    ///*2016-03-22 수정 (차중훈) : 콤보박스에 들어갈 목록은 {value(속값), text(겉값)}으로 구성된 객체 배열이 반환되야 한다.
    var item = null;
    returnArray.push({value : "", text : ""});
    for (var i = 0; i < wOptions.length; i++){
		//콤보박스에 채울 항목 생성
    	item = new Object();
    	item.value = wOptions[i].value;
    	item.text = wOptions[i].text;
		//생성한 항목 리스트에 추가
    	returnArray.push(item);
		//항목 초기화
    	delete item;
    	item = null;
    }
    //*/2016-03-22 수정 (차중훈)    
	
    return returnArray;

}; 

/**
 * 그리드 채우기에 필요한 목록을 데이터셋에서 빼간다
 *
 * @param  textColId   겉값(텍스트) 연결 칼럼아이디
 * @param  codeColId   속값(코드값) 연결 칼럼아이디
 * @return             추출된 배열값
 */
DataSet.prototype.getListArray = function(textColId, codeColId){
	var returnArray = [];
	var i = 0;
	
//	for(var nRow = this.records.length - 1; nRow >= 0 ; nRow--) {
//		var record = this.records[nRow];
//		if (!record._filterd){
//			returnArray[i++] = this.records[nRow].values[textColId];
//		}
//    }
	
	///*2016-03-22 수정 (차중훈) : 콤보박스에 들어갈 목록은 {value(속값), text(겉값)}으로 구성된 객체 배열이 반환되야 한다.
	var item = null;
	returnArray.push({value : "", text : ""});
	for(var nRow = 0; nRow < this.records.length; nRow++) {
		var record = this.records[nRow];
		//콤보박스에 채울 항목 생성
		item = new Object();
		item.value = this.records[nRow].values[codeColId];
		item.text = this.records[nRow].values[textColId];
		//생성한 항목 리스트에 추가
		returnArray.push(item);
		//항목 초기화
		delete item;
		item = null;
    }
	//*/2016-03-22 수정 (차중훈)
	
    return returnArray;
}; 

//Sort 정보 객체와 함수  -----------------------------------------------------------------------------
var xyZ_$_SortKeys = []
function SortKey(strKey, bAscending){this.strKey = strKey; this.bAscending = bAscending};

//객체 속성  -----------------------------------------------------------------------------
/**
 * @description	미결
 * @return  {string}
 * @example	미결
 */
DataSet.prototype.getID = function(){ return this.id; };
/**
 * @description	미결
 * @return  {string}
 * @example	미결
 */
DataSet.prototype.ID = function(){ return this.id; };
/**
 * @description	미결
 * @return  {string}
 * @example	미결
 */
DataSet.prototype.getType = function(){ return "Dataset"; };
/**
 * @description	미결
 * @param	{string}	nColIdx
 * @return  {string}
 * @example	미결
 */
DataSet.prototype.getColID = function(nColIdx){ 
	var wReturn = ""; 
	var i = 0;
	for (var key in this.colInfos){
		var colInfo = this.colInfos[key];
		if( typeof(colInfo) == "function" ) continue;
		if (nColIdx == i++){
			wReturn = colInfo.id;
			break;
		}
	}

	return wReturn;
};
/**
 * @description	미결
 * @param	{string}	strColID
 * @return  {string}
 * @example	미결
 */
DataSet.prototype.getColIndex = function(strColID){ 
	var wReturn = 0; 
	var i = 0;
	for (var key in this.colInfos){
		if( typeof(this.colInfos[key]) == "function" ) continue;
		var colInfo = this.colInfos[key];
		if (colInfo.id == strColID){
			wReturn = i;
			break;
		}
		i++;
	}

	return wReturn;
};
/**
 * @description	미결
 * @param	{string}	strColID
 * @return  {object}
 * @example	미결
 */
DataSet.prototype.getColSize = function(strColID){ 
	return this.colInfos[strColID].size;
};
/**
 * @description	미결
 * @param	{string}	strColID
 * @return  {object}
 * @example	미결
 */
DataSet.prototype.getColType = function(strColID){ 
	return this.colInfos[strColID].type;
};

//Dataset의 Const Column 갯수와 Column들의 갯수의 합계
/**
 * @description	미결
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.getColCount = function(){
	return this._colCount;
};
/**
 * @description	미결
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.ColCount = function(){ 
	return this.getColCount();
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{string}	ncludeFiltered
 * @return  {boolean}
 * @example	미결
 */
DataSet.prototype.isRightRow = function(nRow, includeFiltered){ 
	if (includeFiltered == undefined) includeFiltered = false;
	
	var rowNum = -1; 
	if (typeof(nRow) == 'number'){
		rowNum = nRow;
	} else if (/^\d+$/.test(nRow)){
		rowNum = parseInt(nRow);
	} else {
		//alert(getText("message_dataset_006", "\"{0}\"({1})는 정상적인 줄번호가 아닙니다.", [nRow, this.id]));
		if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_006", "\"{0}\"({1})는 정상적인 줄번호가 아닙니다.", [nRow, this.id]));
		if(typeof console != "undefined" && typeof console.trace == "function")	console.trace();
		return false;
	}

	var arrRecods = (includeFiltered ? this.buffer : this.records );
	if (rowNum < 0 || arrRecods.length == 0) {
		//alert(getText("message_dataset_006", "\"{0}\"({1})는 정상적인 줄번호가 아닙니다.", [nRow, this.id]));
		if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_006", "\"{0}\"({1})는 정상적인 줄번호가 아닙니다.", [nRow, this.id]));
		if(typeof console != "undefined" && typeof console.trace == "function")	console.trace();
		return false;
	}
	
	if (rowNum >= arrRecods.length) {
		//alert(getText("message_dataset_007", "\"{0}\"은 최대 줄수{1}을 초과할 수 없습니다.\n 정상적인 줄번호가 아닙니다.", [rowNum, (arrRecods.length - 1)]));
		if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_007", "\"{0}\"은 최대 줄수{1}을 초과할 수 없습니다.\n 정상적인 줄번호가 아닙니다.", [rowNum, (arrRecods.length - 1)]));
		if(typeof console != "undefined" && typeof console.trace == "function")	console.trace();
		return false;
	}
	return true;
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @return  {boolean}
 * @example	미결
 */
DataSet.prototype.isRightRowOrg = function(nRow){ 

	var rowNum = -1; 
	if (typeof(nRow) == 'number'){
		rowNum = nRow;
	} else if (/^\d+$/.test(nRow)){
		rowNum = parseInt(nRow);
	} else {
		//alert(getText("message_dataset_006", "\"{0}\"({1})는 정상적인 줄번호가 아닙니다.", [nRow, this.id]));
		if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_006", "\"{0}\"({1})는 정상적인 줄번호가 아닙니다.", [nRow, this.id]));
		if(typeof console != "undefined" && typeof console.trace == "function") console.trace();
		return false;
	}

	if (rowNum < 0 || this.OriginBuffer.length == 0) {
		//alert(getText("message_dataset_006", "\"{0}\"({1})는 정상적인 줄번호가 아닙니다.", [nRow, this.id]));
		if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_006", "\"{0}\"({1})는 정상적인 줄번호가 아닙니다.", [nRow, this.id]));
		if(typeof console != "undefined" && typeof console.trace == "function") console.trace();
		return false;
	}
	if (rowNum >= this.OriginBuffer.length) {
		//alert(getText("message_dataset_007", "\"{0}\"은 최대 줄수{1}을 초과할 수 없습니다.\n 정상적인 줄번호가 아닙니다.", [rowNum, (this.OriginBuffer.length - 1)]));
		if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_007", "\"{0}\"은 최대 줄수{1}을 초과할 수 없습니다.\n 정상적인 줄번호가 아닙니다.", [rowNum, (this.OriginBuffer.length - 1)]));
		if(typeof console != "undefined" && typeof console.trace == "function") console.trace();
		return false;
	}
	return true;
};
/**
 * @description	미결
 * @param	{string}	colId
 * @param	{string}	alertErrMsg
 * @return  {boolean}
 * @example	미결
 */
DataSet.prototype.isRightColId = function(colId, alertErrMsg){ 
	try {
		if (colId == null  || colId == undefined || (colId + "").length == 0){
			//if(!alertErrMsg) alert(getText("message_dataset_008", "잘못된 COLID({0}) 입니다", [this.id]));
			if(!alertErrMsg) if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_008", "잘못된 COLID({0}) 입니다", [this.id]));
			if(typeof console != "undefined" && typeof console.trace == "function") console.trace();
			return false;
		}
		if (this.colInfos[colId] == null || this.colInfos[colId] == undefined) {
			//if(!alertErrMsg) alert(getText("message_dataset_009", "COLID \"{0}\"({1})가 존재하지 않습니다.", [colId, this.id]));
			if(!alertErrMsg) if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_009", "COLID \"{0}\"({1})가 존재하지 않습니다.", [colId, this.id]));
			if(typeof console != "undefined" && typeof console.trace == "function") console.trace();
			return false;
		}
	} catch(e) {
		//if(!alertErrMsg) alert(getText("message_dataset_010", "COLID: \"{0}\"\n{1}", [colId, e.description]));
		if(!alertErrMsg) if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_010", "COLID: \"{0}\"\n{1}", [colId, e.description]));
		if(typeof console != "undefined" && typeof console.trace == "function") console.trace();
		return false;
	}

	return true;
};

//RowType을 강제로 변경하는 Method 입니다. 
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{string}	strRowType
 * @return  {boolean}
 * @example	미결
 */
DataSet.prototype.setRowType = function(nRow, strRowType){ 
	//Dataset의 UpdateControl Property 값이 False일 때만 작동합니다.
	if (this.UpdateControl) return false;
	if (!this.isRightRow(nRow)) return false;

	var rowNum = parseInt(nRow + "", 10); 
	this.records[rowNum].RowType = strRowType;

	return true;
};

/**
 * @description	미결
 * @param	{number}	nRow
 * @return  {string}
 * @example	미결
 */
DataSet.prototype.getRowType = function(nRow){ 
	if (!this.isRightRow(nRow)) return "Normal";

	var rowNum = parseInt(nRow + "", 10); 
	return this.records[rowNum].RowType;
};

/**
 * @description	미결
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.getCount = function(){
	return this.getRowCount();
};
/**
 * @description	미결
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.rowCount = function(){
	return this.getRowCount();
};

//Filter된 레코드를 포함한 Dataset에서 전체 Record 갯수
/**
 * @description	미결
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.getTotalRowCount = function(){ 
	return this.buffer.length;
};
/**
 * @description	미결
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.getRowCountNF = function(){ 
	return this.buffer.length;
};
/**
 * @description	미결
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.rowCountNF = function(){ 
	return this.buffer.length;
};


//Dataset의 Record 갯수를 얻어오는 Property 로 삭제된 레코드는 제외된다 
/**
 * @description	미결
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.getRowCount = function(){
	return this.records.length;
};
/**
 * @description	미결
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.getRowPos = function(){ return this.Row; };
/**
 * @description	미결
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.getRowPosition = function(){ return this.Row; };
/**
 * @description	미결
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.getCurrow = function(){ return this.Row; };

/**
 * @description	미결
 * @param	{number}	rowPos
 * @param	{number}	moveToRowPos
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.setRowPos = function(rowPos, moveToRowPos){
	if (rowPos < 0) return -1;
	if (this.Row == rowPos) return rowPos;
	if (rowPos >= this.records.length) return -1;
		
	var nOldRow = this.Row;
	var nRow = rowPos;

	// Dataset의 FireEvent Property값이 False인 경우에는 Event가 발생하지 않습니다.
	if (this.FireEvent){
		// Dataset의 RowPos Property를 변경시키면 Dataset의 CanRowPosChange Event가 발생합니다.    	
		if (this.hasCanRowPosChangeEvent) {
			var wResult = this.fncCanRowPosChangeEvent(this, nOldRow, nRow);  
			// CanRowPosChange Event에서 false값을 return하면 addRow()가 수행되지 않으며 return 값은 -1입니다.
			if (typeof(wResult)=="boolean" && !wResult) {
				// CanRowPosChange Event의 Return값을 False로 주면 RowPosition을 변경하지 않습니다.
				return;          
			} 
		}
	}

	// 한줄 추가 
	this.Row = rowPos;
	this.records[rowPos]._selected = true;
	
	// 연결콘트롤 포커스 이동 
	if( this.instantUpdateControl ) this.updateControlRowPosition(nRow, moveToRowPos);

	// ??? 미결 : 연결콘트롤 포컷스 이동
	// Grid에 사용할 경우는 
	// Dataset의 CanRowPosChange Event ->Grid의 OnCellPosChanged Event -> Dataset의 OnRowPosChanged Event가 순서대로 발생합니다.

	// RowPostion을 변경하고 OnRowPosChanged Event가 발생합니다. 
	if (this.FireEvent){
		if (this.hasRowPosChangedEvent) {
			this.fncRowPosChangedEvent(this, nOldRow, nRow);
		}
	}	
	return this.Row;
};

/**
 * Filter된 Dataset의 해당 Record Index가 Filter 되지 않은 Dataset에서 몇번째 Record Index인지 얻어오는 Method  
 *
 * @param  nRow  Filter 되어 있는 Dataset의 Record Index.
 * @return      (Integer) Filter 되지 않은 Dataset의 Record Index.
 */
DataSet.prototype.getRowIndexNF = function(nRow){ 
    if (nRowNF >= this.records.length){
    	//alert(getText("message_dataset_011", "줄번호 {0}는 전체줄수 {1}범위내이여야 합니다", [nRow, (this.records.length)]));
    	if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_011", "줄번호 {0}는 전체줄수 {1}범위내이여야 합니다", [nRow, (this.records.length)]));
    	if(typeof console != "undefined" && typeof console.trace == "function") console.trace();
    	return -1;
    }
	nRow = parseInt(nRow + "", 10); 
    
	var id = this.records[nRow]._id;
	for (var nRowNF = 0; nRowNF <= this.buffer.length; nRowNF++){
		if (this.buffer[nRowNF]._id == id){ return nRowNF; }
	}

	return -1;
};
/**
 * @description	미결
 * @param	{number}	nRowNF
 * @return  {object}
 * @example	미결
 */
DataSet.prototype.getRecordRowNF = function(nRowNF){ 
	
    if (nRowNF >= this.buffer.length){
    	//alert(getText("message_dataset_012", "필터되지 않은  레코드중 줄번호 {0}는 전체줄수 {1}범위내이여야 합니다", [nRowNF, this.buffer.length]));
    	if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_012", "필터되지 않은  레코드중 줄번호 {0}는 전체줄수 {1}범위내이여야 합니다", [nRowNF, this.buffer.length]));
    	if(typeof console != "undefined" && typeof console.trace == "function") console.trace();
    	return -1;
    }
	nRowNF = parseInt(nRowNF + "", 10); 
	
//	if( this.mappingRecordInfos == null ) this.mappingRecordInfos = [];
//	if( this.mappingRecordInfos.length != this.buffer.length ){
//		console.log("nRowNF = " + nRowNF + " / this.mappingRecordInfos.length = " + this.mappingRecordInfos.length + " / this.buffer.length = " + this.buffer.length);
//		while(this.mappingRecordInfos instanceof Array && this.mappingRecordInfos.length > 0) {
//			this.mappingRecordInfos.pop();
//		}
//		var nRow = 0;
//		for (var i = 0; i < this.buffer.length; i++){
//			if (!this.buffer[i]._filterd){
//				this.mappingRecordInfos[nRow] = {id : this.buffer[i]._id, index : nRow};
//				nRow++;
//			}
//		}
//		this.mappingRecordInfos.sort( function(info1, info2){
//			if( info1.id > info2.id )		return 1;
//			else if( info1.id < info2.id )	return -1;
//			else							return 0;
//			return 0;
//		});
//	}
//	return binaryRecordSearch(this.mappingRecordInfos, id, 0, this.mappingRecordInfos.length - 1);
    
	var id = this.buffer[nRowNF]._id;
	for (var nRow = 0; nRow <= this.records.length; nRow++){
		if (this.records[nRow]._id == id){ return nRow; }
	}

	return -1;
};

//function binaryRecordSearch(mappingRecordInfos, recordId, start, end){
//	if( start > end ) { return -1; } //does not exist
//	
//	var middle = Math.floor((start + end) / 2);
//	var mappingRecordInfo = mappingRecordInfos[middle];
//	
//	if( mappingRecordInfo.id == recordId ){
//		return mappingRecordInfo.index;
//	}
//	else if( mappingRecordInfo.id < recordId /*&& mappingRecordInfos.slice(middle + 1, end).length > 1*/ ){
//		return binaryRecordSearch(mappingRecordInfos, recordId, middle + 1, end);
//	}
//	else if( mappingRecordInfo.id > recordId /*&& mappingRecordInfos.slice(start, middle - 1).length > 1*/ ){
//		return binaryRecordSearch(mappingRecordInfos, recordId, start, middle - 1);
//	}
//	
//	return -1;
//}


/**
 * Dataset에 존재하는 마지막 Record의 Index를 얻어오는 Property 
 * Dataset에 Record가 없으면 -1.(시작 Record의 Index는 0)
 * 단 Filter 또는 삭제된 Record는 제외하고 현재 Display되고 있는 데이타 중 마지막 Record의 Index입니다.
 *
 * @return      (Integer) Record의 Index
 */
DataSet.prototype.getLastRow = function(){
	return this.records.length - 1;    
};

//Dataset의 현재 Record의 다음 Record Index를 얻어오는 Property 
/**
 * @description	미결
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.getNextRow = function(){
	// Dataset의 Record가 없으면 값은 -1 입니다.
	if (this.records.length == 0) return -1;

	// Dataset이 마지막 Record를 가리키고 있을 때는 NextRow는 CurRow와 같습니다.
	if (this.Row == this.getLastRow()) return this.Row;

	return this.Row + 1;
};
/**
 * @description	미결
 * @return  {object}
 * @example	미결
 */
DataSet.prototype.getPrevRow = function(){
	// Dataset의 Record가 없으면 값은 0입니다.
	if (this.records.length == 0) return 0;

	// Dataset이 처음 Record를 가리키고 있을 때는 PrevRow는 CurRow
	if (this.Row == 0) return this.Row;

	return this.Row - 1;
};

/**
 * Dataset에 Column을 추가하는 Method
 *
 * @param  strColID   Dataset에 추가할 Column ID
 * @param  strColType Dataset에 추가할 Column Type. Smallint, Integer, Money, Float, Char, [String, Int, Decimal, Currency, Date, Char, Url, Blob] 중 택일 [Default Value = String] 
 * @param  nColSize   Dataset에 추가할 Column의 크기 지정[Default Value = 256]
 * @return            추가된 Column의 Index
 */
DataSet.prototype.addColumn = function(strColID, strColType, nColSize){ 
	var index = 0; 

	// ColInfo 추가
	var colInfo = new MiColInfo();
	colInfo.id = strColID;
	if (nColSize != undefined) colInfo.size = nColSize;
	if (strColType != undefined) colInfo.type = strColType;

	this._colCount++;
	this.colInfos[colInfo.id] = colInfo;
	colInfo.index = this._colCount - 1; 

	// record 칼럼 추가
	for (var i = 0; i < this.buffer.length; i++){
		record = this.buffer[i];
		record.values[strColID] = colInfo.defaultValue();
	}	
	for (var i = 0; i < this.OriginBuffer.length; i++){
		record = this.OriginBuffer[i];
		record.values[strColID] = colInfo.defaultValue();
	}	

	// OnLoadCompleted Event가 발생, OnLoadCompleted Event의 nReason 값은 1
	var nErrorCode = [];
	var strErrorMsg = [];
	if (this.hasLoadCompletedEvent) {
		this.fncLoadCompletedEvent(this, nErrorCode, strErrorMsg, 1);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			//alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
			if(typeof console != "undefined" && typeof console.log == "function")	console.log("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
			if(typeof console != "undefined" && typeof console.trace == "function") console.trace();
			return -1;
		}            
	} 

	return index;
};


/**
 * Dataset의 마지막에 새로운 레코드를 추가하는 Method<br/>
 * addRow Method로 추가된 레코드는 <br/>
 * Grid의 Edit Mode에서 값을 변경할 경우 Orgin Buffer로 옮겨가지 않으며 RowType도 변경되지 않습니다.
 * 
 * @return      Dataset에 새로 추가된 레코드의 Index. Row의 시작 Index값은 0
 */
DataSet.prototype.addRow = function(){ 
	var wReturn = 0; 

	// Dataset의 Column이 존재하지 않을 때는 Error가 발생합니다.
	if (this._colCount == 0){
		//alert(getText("message_dataset_013", "칼럼정보가 없습니다"));
		if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_013", "칼럼정보가 없습니다"));
		if(typeof console != "undefined" && typeof console.trace == "function") console.trace();
		return -1;
	}

	var nOldRow = this.Row;
	var nRow = this.records.length;

	// addRow Method가 호출되면 다음과 같은 순서로 Event를 발생합니다.
	// CanRowPosChange Event ->OnRowInserted Event -> OnRowPosChanged Event 순서대로 발생합니다.
	// Grid의 BindDataset으로 사용할 경우에는 
	// Dataset의 CanRowPosChange Event ->Dataset의 OnRowInserted Event 
	// -> Grid의 OnCellPosChanged Event -> Dataset의 OnRowPosChanged Event 순서대로 발생합니다.

	// Dataset의 FireEvent Property값이 False인 경우에는 Event가 발생하지 않습니다.
	if (this.FireEvent){
		if (this.hasCanRowPosChangeEvent) {
			var wResult = this.fncCanRowPosChangeEvent(this, nOldRow, nRow);  
			// CanRowPosChange Event에서 false값을 return하면 addRow()가 수행되지 않으며 return 값은 -1입니다.
			if (typeof(wResult)=="boolean" && !wResult) {
				return -1;
			}            
		} 
	}

	// 한줄 추가 
	var record = new MiRecord(this.colInfos);
	this.records[nRow] = record;
	
	var nRowNF = this.buffer.length;
	this.buffer[nRowNF] = record;
	record._orignalIndex = nRowNF;
	
	// 구루핑이 필요할 경우 크룹키값 복사
	if (nRow > 0 && this._GroupKey.length > 0){
		this._copyGroupKeyValues(this.records[nRow - 1], record);
		// 새로운 키값을 부여한다 
		record._jsonGroupKeyValue = this._makeGroupKey(record);
	}
	
	
	this.Row = nRow;

	// UpdateControl Property가 True인 경우에는 추가된 레코드의 RowType은 "Insert"가 됩니다.
	// UpdateControl Property가 False인 경우에는 추가된 레코드의 RowType은 "normal"이 됩니다.
	if (this.UpdateControl){
		record.RowType = "Insert";   // 안하면 디폴트가  "Normal"
	}
	
	if (this.FireEvent){
		if (this.hasRowInsertedEvent) {
			var wResult = this.fncRowInsertedEvent(this, nRow, 1);
			if (typeof(wResult)=="boolean" && !wResult) {
				return -1;
			}            
		} 
	}
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();
	
	// 연결된 콘트롤 줄추가
	if( this.instantUpdateControl ) this.updateControlAddRow(record);

	if (this.FireEvent){
		if (this.hasRowPosChangedEvent) {
			this.fncRowPosChangedEvent(this, nOldRow, nRow);
		}
	}
	
	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
		this._InsertToGroup(nRow);
	  this._refreshGroupCation(true);
	}
	
	//추가된 레코드의 index를 리턴
	wReturn = nRow;

	return wReturn;
};
/**
 * @description	미결
 * @return  {object}
 * @example	미결
 */
DataSet.prototype.appendRow = function(){ return this.addRow(); };

/**
 * Dataset의 지정한 레코드 Index에 레코드를 삽입하는 Method <br/>
 * addRow Method로 추가된 레코드는 <br/>
 * Grid의 Edit Mode에서 값을 변경할 경우 Orgin Buffer로 옮겨가지 않으며 RowType도 변경되지 않습니다.
 * 
 * @param  nRow   레코드를 삽입할 Index(String, Integer)
 * @return        삽입된 레코드의 Index. Row의 시작 Index값은 0
 */
DataSet.prototype.insertRow = function(nRow){ 
	var wReturn = 0; 

	// Dataset의 Column이 존재하지 않을 때는 Error가 발생합니다.
	if (this._colCount == 0){
		//alert(getText("message_dataset_013", "칼럼정보가 없습니다"));
		if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_013", "칼럼정보가 없습니다"));
		if(typeof console != "undefined" && typeof console.trace == "function") console.trace();
		return -1;
	}
	
	// 비데이터 셋인 경우 
	if (this.rowCount() == 0){
		if (nRow > 0) {
			//alert(getText("message_dataset_014", "줄번호 {0}는 정상적인 줄번호가 아닙니다.\n 현재상태에서는 줄번호 0만 가능합니다.", [nRow]));
			if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_014", "줄번호 {0}는 정상적인 줄번호가 아닙니다.\n 현재상태에서는 줄번호 0만 가능합니다.", [nRow]));
			if(typeof console != "undefined" && typeof console.trace == "function") console.trace();
			return false;
		} else {
			return this.addRow();
		}
	} else if (this.rowCount() == nRow){
		return this.addRow();
	} else {
		if (!this.isRightRow(nRow)) return false;
	}

	var nOldRow = this.Row;
	nRow = parseInt(nRow + "", 10);         // records에서의 인덱스
	var nRowNF = (this.rowCount() == 0 ? nRow : this.getRowIndexNF(nRow)) ;  // buffer에서의 인덱스

	// insertRow Method가 호출되면 다음과 같은 순서로 Event를 발생합니다.
	// CanRowPosChange Event ->OnRowInserted Event -> OnRowPosChanged Event 순서대로 발생합니다.
	// Dataset의 FireEvent Property값이 False인 경우에는 Event가 발생하지 않습니다.
	if (this.FireEvent){
		if (this.hasCanRowPosChangeEvent) {
			var wResult = this.fncCanRowPosChangeEvent(this, nOldRow, nRow);  
			// CanRowPosChange Event에서 false값을 return하면 addRow()가 수행되지 않으며 return 값은 -1입니다.
			if (typeof(wResult)=="boolean" && !wResult) {
				return -1;
			}            
		} 
	}

	// 한줄 추가 
	var record = new MiRecord(this.colInfos);
	record._orignalIndex=this.buffer.length;
	
	if (this.rowCount() == 0){
		this.buffer[nRow] = nRowNF;  
		this.records[nRow] = record;
	} else {
		this.buffer.splice(nRowNF, 0, record);
		this.records.splice(nRow, 0, record);

    	// rangeStart 한줄씩 뒤로 미루기
    	this._updateRangeStartsAfter(nRow, 1);
	}

	// 구루핑이 필요할 경우 크룹키값 복사
	if (nRow > 0 && this._GroupKey.length > 0){
		this._copyGroupKeyValues(this.records[nRow - 1], record);
		// 새로운 키값을 부여한다 
		record._jsonGroupKeyValue = this._makeGroupKey(record);
	}

	this.Row = nRow;
	
	if (this.FireEvent){
		if (this.hasRowInsertedEvent) {
			var wResult = this.fncRowInsertedEvent(this, nRow, 1);
			if (typeof(wResult)=="boolean" && !wResult) {
				return -1;
			}            
		} 
	}

	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();

	// 연결된 콘트롤 줄추가
	if( this.instantUpdateControl ) this.updateControlAddRow(record, nRow);

	// UpdateControl Property가 True인 경우에는 추가된 레코드의 RowType은 "Insert"가 됩니다.
	// UpdateControl Property가 False인 경우에는 추가된 레코드의 RowType은 "normal"이 됩니다.
	if (this.UpdateControl){
		record.RowType = "Insert";   // 안하면 디폴트가  "Normal"
	}
	
	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
		this._InsertToGroup(nRow);
	  this._refreshGroupCation(true);
	}


	if (this.FireEvent){
		if (this.hasRowPosChangedEvent) {
			this.fncRowPosChangedEvent(this, nOldRow, nRow);
		}
	}
	
	wReturn = nRow;
	
	return wReturn;
};

/**
 * @description	미결
 * @param	{number}	nRow
 * @return  {void}
 * @example	미결
 */
DataSet.prototype._deleteOneRecord = function(nRow){
    if (!this.isRightRow(nRow)) return; 
    nRow = parseInt(nRow + "", 10); 
    var nRowNF = this.getRowIndexNF(nRow);
    var movedToOrigin = false;
    

	var record = this.records[nRow];
	
	if (this.UpdateControl){
		// UpdateControl Property가 True인 경우에는 
		if (record.RowType == "Normal" || record.RowType == "Update"){
			// Dataset의 레코드를 삭제되며, 삭제된 Data는 Orgin Buffer로 옮겨가며 레코드의 RowType은 "delete"가 됩니다.
			// 데이터가 있으면 플래그만 바꾼다 
			var foundInOrigin = false;
			for (var i = 0; i < this.OriginBuffer.length; i++){
				var recordORG = this.OriginBuffer[i];
				if (recordORG._id == record._id){
					recordORG.RowType = "Delete";
					foundInOrigin = true;
					break;
				}
			}
			if (!foundInOrigin){
				record.RowType = "Delete";
				this.OriginBuffer[this.OriginBuffer.length] = record;
				movedToOrigin = true;
			}
		} else if (record.RowType == "Insert"){
			// insertRow Method, addRow Method를 통해 추가된 레코드는 삭제되어도 Orgin Buffer로 옮겨가지 않고 삭제됨
		} else {
			//Logical 레코드는 삭제되어도 Orgin Buffer로 옮겨가지 않음.
		}
		
	} else {
		// UpdateControl Property가 False인 경우에는 원본 레코드까지 삭제합니다.  
		for (var i = 0; i < this.OriginBuffer.length; i++){
			var recordORG = this.OriginBuffer[i];
			if (recordORG._id == record._id){
				// 레코드의 내용물은 records에서도 참고하고 있으므로 건들면 안되고 배열에서만 뺸다
				this.OriginBuffer.splice(i, 1);
				break;
			}
		}
	}

	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
	    // 레벨별 줄번호를 찾아낸다
	    var arrGroupRows = this._FindGroupRows(nRow);
	    this._DeleteFromGroup(arrGroupRows, record, nRow);
	}
	
	this.buffer.splice(nRowNF, 1);
	this.records.splice(nRow, 1);
	
	// rangeStart 한줄씩 앞으로 당기기
    this._updateRangeStartsAfter(nRow, -1);
	
	// 메모리 최종해제
	if (!movedToOrigin){
		record.clear(); record = null;
	}
	
	return;
};

/**
 * 지정한 레코드 Index에 해당하는 Record를 삭제하는 Method <br/>
 * UpdateControl Property값에 따라 원본 Record가 보존되어 있어 복구가 가능<br/><br/>
 *
 * @param  nRow  삭제할 Record의 Index  [Default Value = 현재줄] 
 * @return       (Integer)성공하면 0, 실패하면 음수를 Return
 */
DataSet.prototype.deleteRow = function(nRow){ 
	var wReturn = 0; 
	if (nRow == undefined){ nRow = this.Row; }

	var record = this.records[nRow];
	
	// appendDataset Method가 수행되면 Dataset은 OnRowDeleting  Event ->OnRowDeleted Event -> OnRowPosChanged Event가 순서대로 발생합니다.
	// Grid의 BindDataset을 사용할 경우에는 OnRowDeleting  Event ->OnRowDeleted Event -> Grid의 OnCellPosChanged ->OnRowPosChanged Event가 순서대로 발생합니다.
	if (this.FireEvent){
		if (this.hasRowDeletingEvent) {
			var wResult = this.fncRowDeletingEvent(this, nRow, 1);  // "obj", "nRow", "nCount"
			if (typeof(wResult)=="boolean" && !wResult) {
				return -1;
			}            
		} 
	}

	this._deleteOneRecord(nRow);
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();
	
	// 연결된 시트의 줄삭제 
	if( this.instantUpdateControl ) this.updateControlDelRow(record);
	

	// DataSet의 Row가 마지막 Row를 가르킬때 deleteRow를 수행하면, 
	// Row의 값은 1이 줄어 새로운 마지막 Row를 가르키게 됩니다.
	var nOldRow = this.Row;
	var nRow = (nOldRow == this.records.length ? this.records.length - 1: nOldRow);  
	if (this.records.length == 0){
		this.Row = 0;
	} else if (nOldRow == this.records.length){
		this.Row = this.records.length - 1;
	} else {
		this.Row = nOldRow;
	}
	if( this.instantUpdateControl ) this.updateControlRowData(this.records[this.Row]);
	
	this.Row = nRow;  

	if (this.FireEvent){
		if (this.hasRowDeletedEvent) {
			var wResult = this.fncRowDeletedEvent(this, 0, nRow, 1);
			if (typeof(wResult)=="boolean" && !wResult) {
				return -1;
			}            
		} 
		//2016-04-18 수정(차중훈) : RowPosChanged 이벤트 함수가 있으며 레코드가 1개 이상 존재하는 경우에만 RowPosChanged 이벤트 함수가 동작된다.
		if (this.hasRowPosChangedEvent && this.records.length > 0) {
			this.fncRowPosChangedEvent(this, nOldRow, nRow);
		}
	}


	return wReturn;
};

/**
 * 지정한 레코드 Index에 해당하는 Record를 삭제하는 Method <br/>
 * UpdateControl Property값에 따라 원본 Record가 보존되어 있어 복구가 가능<br/><br/>
 * SetColumn(nRow,nColIdx,varVal);<br/>
 * SetColumn(nRow,nColIdx,varVal,nPivotIndex);<br/>
 * SetColumn(nRow,strColID,varVal);<br/>
 * SetColumn(nRow,strColID,varVal,nPivotIndex);<br/>
 *
 * @param  nRow           변경할 Record Index.시작 Index는 0 입니다.
 * @param  nColIdx        변경할 Column Index. 
 * @param  strColID       변경할 Column ID.
 * @param  varVal         변경할 값.
 * @param  nPivotIndex    변경할 PivotCol의 Index. [Defualt Value = -1]
 * @return                (Boolean)성공 여부.
 */
DataSet.prototype.setColumn = function(nRow, varCol, varVal, nPivotIndex){ 
	if (this.dataSetType == "Pivot"){
		this._setPivotColumn(nRow, varCol, varVal, nPivotIndex);
		return;
	}

	if (!this.isRightRow(nRow)) return false;
	nRow = parseInt(nRow + "", 10); 

	// GroupKey Property를 사용하는 경우, Logical Record는 SetColumn Method로 값을 변경할수 없습니다.
	// 이 때는 Return 값은 False 입니다.
	if (this.records[nRow].RowType == "Logical"){
		//alert("집계데이터는 는 SetColumn Method로 값을 변경할수 없습니다");
		return false;
	}

	var strColID = (typeof(varCol) == 'number' ? this.getColID(varCol)  : varCol);
	if (!this.isRightColId(strColID)) return false;

	var oldFilterd = this.records[nRow]._filterd;
	var oldValue = this.records[nRow].values[strColID];
	// 같은 값으로 변경하면 Dataset의 Event가 발생하지 않습니다.
	if (oldValue + "" == varVal + "") {
		return true;
	} 

	// SetColumn Method가 호출되면 
	// CanColumnChange Event ->OnColumnChanged Event가 발생합니다.
	if (this.FireEvent){
		if (this.hasCanColumnChangeEvent) {
			var wResult = this.fncCanColumnChangeEvent(this, nRow, strColID, oldValue, varVal);
			// CanColumnChange Event에서 false를 return하면 OnColumnChanged Event는 발생하지 않습니다.
			// 이때 SetColumn Method의 Return값은 False 입니다.
			if (typeof(wResult)=="boolean" && !wResult) {
				return false;
			}            
		}     
	}

	var record = this.records[nRow];
	var value = this._getRawValue(strColID, varVal);

	if (this.UpdateControl){
		if (record.RowType == "Normal"){   
			record.RowType = "Update";
			
			var newRecord = record.clone();

			this.OriginBuffer[this.OriginBuffer.length] = newRecord;
			newRecord._orignalIndex = record._orignalIndex;
		}
		else if(record.RowType == "Update"){
			for(var i = 0; i < this.OriginBuffer.length; i++){
				if(record._id == this.OriginBuffer[i]._id){
					var isDiff = false;
					for(var _colId in record.values){
					    if(strColID == _colId){
					        isDiff = (value != this.OriginBuffer[i].values[_colId]);
							break;
					    }
						else if(record.values[_colId] != this.OriginBuffer[i].values[_colId]){
							isDiff = true;
							break;
						}
					}
					if( !isDiff ){
						delete this.OriginBuffer[i];
						this.OriginBuffer = this.OriginBuffer.slice(0, i).concat( this.OriginBuffer.slice(i + 1, this.OriginBuffer.length) );
						record.RowType = "Normal";
					}
					
					break;						
				}
			}
		}
	}

	record.values[strColID] = value;
	
	//  연결된 시트에서 빼는 동작 필요 
	if( this.instantUpdateControl ) this.updateControlValue(strColID, nRow);
	
	// 2016-05-12(차중훈) 수정
	/*
	if (this.FilterExpr.length > 0){
		var formula = this._UpdateFormulaNF(this.FilterExpr);
//		if (eval(formula.replace("nRowNum", nRow)) == false){
		if(eval(formula.replace(/nRowNum/g, nRow)) == false){
			this.records[nRow]._filterd = true;
			this.records.splice(nRow, 1);

	    	// rangeStart 한줄씩 앞으로 당기기
    	    this._updateRangeStartsAfter(nRow, -1);

		}
	}
	*/

	if (this.FireEvent){
		if (this.hasColumnChangedEvent) {
			var wResult = this.fncColumnChangedEvent(this, nRow, strColID, oldValue, varVal);
			// Event에서 false를 return하면 OnColumnChanged Event는 발생하지 않습니다.
			// 이때 SetColumn Method의 Return값은 False 입니다.
			if (typeof(wResult)=="boolean" && !wResult) {
				return false;
			}            
		}     
	}
	
	// 그룹정보 갱신  (변경전 필터링 되지 않은 상태였다면 그룹변경을 호출한다, 
	// 호출된 함수에서 필터링 되어 있다면 신규 데이터 갱신은 생략한다.
	if (!oldFilterd && this._GroupKey.length > 0){
		var colInfo = this.colInfos[strColID];

		var calcResult = null;
		var sumMethod  = colInfo.sumMethod;
		var sumFormula = colInfo._sumFormula;
		var sumField   = colInfo._sumField;
		var sumText    = colInfo._sumText;
		
		if (sumFormula.length > 0){
			calcResult = self[this.id + "_" + strColID + "_sumFunction"](nRow);
		} else if (sumField.length > 0){
			calcResult = record.values[sumField];
		} else if (sumText.length > 0){
			calcResult = sumText;
		} else {
			calcResult = varVal;
		}
		
		this._UpdateColumnValueToGroup(nRow, strColID, oldValue, calcResult);  
	}

	return true;
};

/**
 * Filter된 레코드를 포함한 Dataset에서 지정된 레코드 Index와 Column ID에 해당하는 값을 변경하는 Method<br/>
 * 
 * setColumnNF(nRow,nColIdx,varVal);<br/>
 * setColumnNF(nRow,nColIdx,varVal,nPivotIndex);<br/>
 * setColumnNF(nRow,strColID,varVal);<br/>
 * setColumnNF(nRow,strColID,varVal,nPivotIndex);<br/>
 *
 * @param  nRowNF         변경할 Record Index.시작 Index는 0 입니다.
 * @param  nColIdx        변경할 Column Index. 
 * @param  strColID       변경할 Column ID.
 * @param  varVal         변경할 값.
 * @param  nPivotIndex    변경할 PivotCol의 Index. [Defualt Value = -1]
 * @return                (Boolean)성공 여부.
 */
DataSet.prototype.setColumnNF = function(nRowNF, varCol, varVal, nPivotIndex){ 
	if (this.dataSetType == "Pivot"){
		this._setPivotColumnNF(nRowNF, varCol, varVal, nPivotIndex);
		return;
	}
	
	if (!this.isRightRow(nRowNF, true)) return false;
	
	nRowNF = parseInt(nRowNF + "", 10); 
	var nRow = this.getRecordRowNF(nRowNF);

	var strColID = (typeof(varCol) == 'number' ? this.getColID(varCol)  : varCol);
	if (!this.isRightColId(strColID)) return false;

	var oldFilterd = this.records[nRow]._filterd;
	var oldValue = this.buffer[nRowNF].values[strColID];
	// 같은 값으로 변경하면 Dataset의 Event가 발생하지 않습니다.
	if (oldValue + "" == varVal + "") {
		return true;
	}
	
	if (this.records[nRow].RowType == "Logical"){
		alert(getText("message_dataset_003", "집계데이터는 는 SetColumn Method로 값을 변경할수 없습니다"));
		return false;
	}

	// ??? Const Column과 Column 모두에 적용됩니다.

	// ??? GroupKey Property를 사용하는 경우, Logical Record는 SetColumn Method로 값을 변경할수 없습니다.
	// ??? 이 때는 Return 값은 False 입니다.

	// SetColumn Method가 호출되면 
	// CanColumnChange Event ->OnColumnChanged Event가 발생합니다.
	if (this.FireEvent){
		if (this.hasCanColumnChangeEvent) {
			if (nRow >= 0) {
				var wResult = this.fncCanColumnChangeEvent(this, nRowNF, strColID, oldValue, varVal);
				// CanColumnChange Event에서 false를 return하면 OnColumnChanged Event는 발생하지 않습니다.
				// 이때 SetColumn Method의 Return값은 False 입니다.
				if (typeof(wResult)=="boolean" && !wResult) {
					return false;
				}            
			}
			
		}     
	}

	var record = this.buffer[nRowNF];
	
	if (this.UpdateControl){
		if (record.RowType == "Normal"){   
			record.RowType = "Update";
			
			var newRecord = record.clone();
			
			this.OriginBuffer[this.OriginBuffer.length] = newRecord;
			newRecord._orignalIndex = record._orignalIndex;
		}
	}

	record.values[strColID] = this._getRawValue(strColID, varVal);
	
	//  연결된 시트에서 빼는 동작 필요 
	if (nRow >= 0) {
		if( this.instantUpdateControl ) this.updateControlValue(strColID, nRow);
	}

	if (this.FireEvent){
		if (this.hasColumnChangedEvent) {
			if (nRow >= 0) {
				var wResult = this.fncColumnChangedEvent(this, nRow, strColID, oldValue, varVal);
				// Event에서 false를 return하면 OnColumnChanged Event는 발생하지 않습니다.
				// 이때 SetColumn Method의 Return값은 False 입니다.
				if (typeof(wResult)=="boolean" && !wResult) {
					return false;
				}            
			}
		}     
	}
	
	// 그룹정보 갱신  (변경전 필터링 되지 않은 상태였다면 그룹변경을 호출한다, 
	// 호출된 함수에서 필터링 되어 있다면 신규 데이터 갱신은 생략한다.
	if (nRow >= 0 && !oldFilterd && this._GroupKey.length > 0){
		this._UpdateColumnValueToGroup(nRow, strColID, oldValue, varVal);  
	}

	return true;
};

/**
 * Dataset에서 변경하려는 값이 이상없는 지 체크로직을 호출하는 이벤트 <br/>
 * checkCanColumnChange(nRow, strColID, oldValue, varVal);<br/>
 *
 * @param  nRow           변경할 Record Index.시작 Index는 0 입니다.
 * @param  strColID       변경할 Column ID.
 * @param  oldValue       변경전 값
 * @param  varVal         변경후 값
 * @return                (Variant)지정한 레코드 위치와 Column ID에 해당하는 값. 해당하는 값이 없을 경우에는 Null을 Return 합니다.
 */
DataSet.prototype.checkCanColumnChange = function(nRow, strColID, oldValue, varVal){ 
	if (!this.hasCanColumnChangeEvent) return true;
	
	if (nRow >= 0) {
		var wResult = this.fncCanColumnChangeEvent(this, nRow, strColID, oldValue, varVal);
		// CanColumnChange Event에서 false를 return하면 OnColumnChanged Event는 발생하지 않습니다.
		// 이때 SetColumn Method의 Return값은 False 입니다.
		if (typeof(wResult)=="boolean" && !wResult) {
			return false;
		}            
	}
	return true;
};



/**
 * Dataset에서 지정한 Record Index와 Column ID에 해당하는 값을 가지고 오는 Method <br/>
 * GetColumn(nRow,nColIdx);<br/>
 * GetColumn(nRow,nColIdx,nPivotIndex);<br/>
 * GetColumn(nRow,strColID);<br/>
 * GetColumn(nRow,strColID,nPivotIndex);<br/>
 *
 * @param  nRow           변경할 Record Index.시작 Index는 0 입니다.
 * @param  nColIdx        변경할 Column Index. 
 * @param  strColID       변경할 Column ID.
 * @param  nPivotIndex    변경할 PivotCol의 Index. [Defualt Value = -1]
 * @return                (Variant)지정한 레코드 위치와 Column ID에 해당하는 값. 해당하는 값이 없을 경우에는 Null을 Return 합니다.
 */
DataSet.prototype.getColumn = function(nRow, varCol, nPivotIndex){ 
	if (this.dataSetType == "Pivot"){
		return this._getPivotColumn(nRow, varCol, nPivotIndex);
	}

	if (!this.isRightRow(nRow)) return null;
	nRow = parseInt(nRow + "", 10); 

	var strColID = (typeof(varCol) == 'number' ? this.getColID(varCol)  : varCol);
	if (!this.isRightColId(strColID)) return null;

	return this._getRawValue( strColID, this.records[nRow].values[strColID] );
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{number}	varCol
 * @param	{number}	nPivotIndex
 * @return  {string}
 * @example	미결
 */
DataSet.prototype.getColumnNF = function(nRow, varCol, nPivotIndex){ 
	if (this.dataSetType === "Pivot"){
		if (typeof nPivotIndex != "undefined"){
			return this._getPivotColumnNF(nRow, varCol, nPivotIndex);
		}
	}

	if (!this.isRightRow(nRow, true)) return null;
	var nRowNF = parseInt(nRow + "", 10); 

	var strColID = (typeof(varCol) == 'number' ? this.getColID(varCol)  : varCol);
	if (!this.isRightColId(strColID)) return null;

	return this.buffer[nRowNF].values[strColID];
};


//현재줄의 칼럼값
/**
 * @description	미결
 * @param	{number}	varCol
 * @param	{number}	nPivotIndex
 * @return  {string}
 * @example	미결
 */
DataSet.prototype.getCurrentColumn = function(varCol, nPivotIndex){ 
	if (this.dataSetType == "Pivot"){
		return this._getPivotCurrentColumn(varCol, nPivotIndex);
	}
	
	var nRow = this.Row;

	var strColID = (typeof(varCol) == 'number' ? this.getColID(varCol)  : varCol);
	if (!this.isRightColId(strColID)) return false;

	return this.records[nRow].values[strColID];
};

/**
 * 저장후에 초기화: Update, Delete, Insert 등의 일련 과정을 거친 변화된 Dataset의 상태를 Normal 상태로 만드는 Method
 *
 * @return            없음
 */
DataSet.prototype.applyChange = function(){ 
	// 원본데이터 처리 
	for (var nRow = this.OriginBuffer.length - 1; nRow >= 0; nRow--){
		this.OriginBuffer[nRow].clear();
		this.OriginBuffer.pop();
	} 
	
	// ???  필터링 데이터 처리

	// 레코드셋 처리
	for (var nRow = this.buffer.length - 1; nRow >= 0; nRow--){
		this.buffer[nRow].RowType = "Normal";
		this.buffer[nRow]._orignalIndex = nRow;
	}	

	// 변수값 초기화
	//this.Row = -1;
	// 2016-05-03 :  레코드가 있다면 Row는 0으로 초기화 / setRowPos 함수 호출하여 RowPosChange 이벤트도 발생
	if(this.buffer.length > 0){
		this.setRowPos(this.Row);
	}
	
	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
		this._ResetGroup();
	}
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();
	
	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ) this.updateControlList();
	
	if (this._GroupKey.length > 0){
	    this._refreshGroupCation(true);
	}

	return;

};

/**
 * Update, Delete, Insert 등의 일련 과정을 거친 변화된 Dataset 을 이전상태로 초기화
 */
/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
DataSet.prototype.reset = function(){ 
	
	// UpdateControl Property가 True인 경우에만 변경된 내용이 Orgin Buffer에 저장되므로 Reset이 가능
	if (!this.UpdateControl){
		alert(getText("message_dataset_004", "UpdateControl 값이 True인 경우에만 리셋이 가능합니다."));
		return;
	}
	
	// 임시 버퍼로 원하는 데이터만 옮긴다.
	var tmpBuffer = []; var tmpRow = 0; 
	for (var nRowORG = 0; nRowORG < this.OriginBuffer.length; nRowORG++){
		this.OriginBuffer[nRowORG].RowType = "Normal";
		tmpBuffer[tmpRow++] = this.OriginBuffer[nRowORG];
	}
	for (var nRowNF = 0; nRowNF < this.buffer.length; nRowNF++){
		if (this.buffer[nRowNF].RowType == "Normal"){
			tmpBuffer[tmpRow++] = this.buffer[nRowNF];
		}
	}
	
	// 메모리를 정리한다
	while (this.records.length > 0) {
		this.records.pop();
	}
	for(var i = this.buffer.length - 1; i >= 0 ; i--) {
		if (this.buffer[i].RowType != "Normal"){
			this.buffer[i].clear();
		}
		this.buffer.pop();
	}
	for(var i = this.OriginBuffer.length - 1; i >= 0 ; i--) {
		this.OriginBuffer.pop();
	}
	
	// 소트한다
	tmpBuffer.sort(function(record1, record2){return record1._orignalIndex - record2._orignalIndex});
	
	// 다시 정상적으로 붓는다
	for (var nRowNF = 0; nRowNF < tmpBuffer.length; nRowNF++){
		var record = tmpBuffer[nRowNF];
		record._orignalIndex = nRowNF;
		record.RowType = "Normal";
		record._filterd = false;
		
		this.records[nRowNF] = record;
		this.buffer[nRowNF] = record;
	}
	
	// 임시 메모리를 정리한다
	while (tmpBuffer.length > 0) {
		tmpBuffer.pop();
	}
	
	this.FilterExpr = "";
    this.FilterFunction = null;
	
	// Row Position의 값은 변경되지 않습니다. 
	// (단, Reset에 의해 존재하지 않게 되는 Row에 위치하고 있는 경우에는 마지막 Row로 RowPosition이 변경됩니다.)
	if (this.Row >= this.records.length){
		this.Row = this.records.length - 1;
	}
	
	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
		this._ResetGroup();
	}
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();

	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ) this.updateControlList();
	
	//2016-04-25(차중훈) 추가 : 연결된 컨트롤 값 업데이트
	if(this.Row >= 0){
		if( this.instantUpdateControl ) this.updateControlRowData(this.records[this.Row]);
	}

	if (this._GroupKey.length > 0){
	    this._refreshGroupCation(true);
	}

	// Reset Method를 수행하면 OnLoadCompleted Event가 발생합니다. 
	// OnLoadCompleted Event의 nReason 값은 9 입니다.
	if (this.hasLoadCompletedEvent) {
		var nErrorCode = [];
		var strErrorMsg = [];
		this.fncLoadCompletedEvent(this, nErrorCode, strErrorMsg, 9);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
		}            
	} 
	
	return;
};


/**
 * Dataset의 Column 정보와 Record를 모두 삭제하는 Method 입니다. 
 *
 * @return         Integer 삭제된 Record Count
 */
DataSet.prototype.clear = function(){ 
	var wReturn = this.clearData(); 

	for(var key in this.colInfos ) {
		delete this.colInfos[key];
	}
	this._colCount = 0;
	
	this.FilterExpr = "";
    this.FilterFunction = null;
	
	// 연결된 시트나 콤보를 리프래시함 
    if( this.instantUpdateControl ) this.updateControlList();

	return wReturn;
};

/**
 * Dataset의 Column 정보를 제외한 모든 Record를 삭제하는 Method 입니다.
 * 최초 Loading 된 Data도 전부 삭제되므로 복구할 수 없습니다.
 * @return         Integer 삭제된 Record Count
 */
DataSet.prototype.clearData = function(){ 
	var wReturn = 0;

	while(this.records.length > 0) {
		this.records.pop();
	}
	if (this.buffer.length > 0){
		for(var i = this.buffer.length - 1; i >= 0 ; i--) {
			this.buffer[i].clear();
			this.buffer.pop();
			wReturn++;
		}
	}
	if (this.OriginBuffer.length > 0){
		for(var i = this.OriginBuffer.length - 1; i >= 0 ; i--) {
			this.OriginBuffer[i].clear();
			this.OriginBuffer.pop();
		}
	}
	
	this.Row= -1; 
//	if(this.mappingRecordInfos instanceof Array) this.mappingRecordInfos.clear();
//	this.mappingRecordInfos = null;

	// clear Method가 완료되고 나면 OnLoadCompleted Event가 발생합니다. 
	// OnLoadCompleted Event의 nReason 값은 30 입니다.
	var nErrorCode = [];
	var strErrorMsg = [];
	if (this.hasLoadCompletedEvent) {
		this.fncLoadCompletedEvent(this, nErrorCode, strErrorMsg, 30);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
		}            
	} 
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();

	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ) this.updateControlList();
	if( this.instantUpdateControl ) this._clearControlData();

	return wReturn;
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
DataSet.prototype._clearControlData = function(){
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		
		var ctl = controls[bindInfo.controlName];
		ctl.passEvent = true;
		if (bindInfo.controlType == "ComboBox" || bindInfo.controlType == "List1") {
			if ((ctl.listSaveType == LISTBOX_SAVE_MULTI  && ctl.listType == LISTBOX_TYPE_DATASELECT)) continue;
			ctl.setValue(ctl.defaultValue);
		} else if (bindInfo.controlType == "TextBox" || 
				   bindInfo.controlType == "CheckBox" || 
				   bindInfo.controlType == "Link" || 
				   bindInfo.controlType == "IFrame" || 
				   bindInfo.controlType == "ProgressBar1") {
			ctl.setValue(ctl.defaultValue);
		} else if (bindInfo.controlType == "OptionBox") {
			ctl.setValue(ctl.matchUpValue == "" ? 1 : 0);
		} else if (bindInfo.controlType == "Label" ) {
			ctl.setCaption("");
		} else if (bindInfo.controlType == "PictureBox" ) {
			ctl.setPicture("");
		} else if (bindInfo.controlType == "WebEdit" ) {
			ctl.setHTML("");
		} else if (bindInfo.controlType == "FlashPlayer" ) {
			ctl.flashUrl = ctl.flashUrl; 
			ctl.callMovie();
		} else if (bindInfo.controlType == "Sheet" ) {
		} else if (bindInfo.controlType == "lstSheet" ) {
		} else {
			ctl.setValue("");
		}
		ctl.passEvent = false;
	}
	
	return ;
};

/**
 * Dataset의 모든 레코드를 삭제하는 Method 입니다.
 * UpdateControl Property 값에 따라 원본 레코드가 보존되어 있어 복구가 가능합니다.
 * @return         Integer 삭제된 Record Count
 */
DataSet.prototype.deleteAll = function(){ 
	var wReturn = 0; 

	//deleteAll Method가 호출되면 OnRowDeleting Event -> OnLoadCompleted Event가 발생합니다.
	if (this.FireEvent){
		if (this.hasRowDeletingEvent) {
			var wResult = this.fncRowDeletingEvent(this, nRow, 1);  // "obj", "nRow", "nCount"
			if (typeof(wResult)=="boolean" && !wResult) {
				return -1;
			}            
		} 
	}

	// Row 위치는 -1 이 됩니다. (Row 위치를 얻는 Method나 Property 경우에 -1 값을 갖습니다.)
	this.Row = -1; 

	for(var nRow = this.records.length - 1; nRow >= 0 ; nRow--) {
		this._deleteOneRecord(nRow);
	}
	
	// 그룹정보 갱신 
	this._ResetGroup();
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();
	
	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ) this.updateControlList();

	//이때 OnLoadCompleted Event의 nReason 값은 8 입니다.
	var nErrorCode = [];
	var strErrorMsg = [];
	if (this.hasLoadCompletedEvent) {
		this.fncLoadCompletedEvent(this, nErrorCode, strErrorMsg, 8);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
			return -1;
		}            
	} 

	return wReturn;
};

/**
 * Dataset이 Update(Delete, Insert, Update)되었는지 여부를 알려주는 Method 입니다.
 * UpdateControl Property 값에 따라 원본 레코드가 보존되어 있어 복구가 가능합니다.
 * 
 * @return         Boolean Dataset의 Update 여부
 */
DataSet.prototype.getUpdate = function(){ 
	for(var nRow= 0; nRow < this.buffer.length; nRow++) {
		if (this.buffer[nRow].RowType != "Normal"){ return true; }
	}
	for(var nRow= 0; nRow < this.OriginBuffer.length; nRow++) {
		if (this.OriginBuffer[nRow].RowType != "Normal"){ return true; }
	}
	return false;
};

/**
 * Orgin Buffer에 저장되어 있는 Record들 중 Record Index와 Column ID에 해당되는 값을 가지고 오는 Method 
 *   Orgin Buffer의 레코드들은 변경된 순서대로 저장됩니다.
 *   nRow는 Orgin Buffer의 레코드들의 Index 이며, 삭제시킨 레코드 번호가 아닙니다.
 *   GetOrgBuffCount Method를 호출한 후, Orgin Buffer에 저장된 레코드가 있을 경우에만 호출합니다.
 *   
 *   GetOrgBuffColumn(nRow,nColIdx);
 *   GetOrgBuffColumn(nRow,strColID);
 *   
 * @param  nRow           변경할 Record Index.시작 Index는 0 입니다.
 * @param  nColIdx        변경할 Column Index. 
 * @param  strColID       변경할 Column ID.
 * @return                Variant 지정한 Record Index와 Column ID에 해당하는 값. 해당하는 값이 없을 경우에는 Null을 Return 합니다
 */
DataSet.prototype.getOrgBuffColumn = function(nRow, varCol){ 
	if (!this.isRightRowOrg(nRow)) return null; 
	nRow = parseInt(nRow + "", 10); 

	var strColID = (typeof(varCol) == 'number' ? this.getColID(varCol)  : varCol);
	if (!this.isRightColId(strColID)) return null;

	// ??? Const Column과 Column을 모두 포함합니다. 

	return this.OriginBuffer[nRow].values[strColID];
	// 미결
	// GroupKey Property를 사용하는 경우, Logical 레코드는 삭제되어도 Orgin Buffer에 저장되지 않습니다.
	// 그러므로 GetOrgBuffColumn을 통해서 접근 할 수 없습니다.
};

/**
 * 지정된 Record Index와 Column ID의 변경전 Column 값을 가지고 오는 Method
 *   
 *   GetOrgColumn(nRow,nColIdx);
 *   GetOrgColumn(nRow,strColID);

 *   
 * @param  nRow           변경할 Record Index.시작 Index는 0 입니다.
 * @param  nColIdx        변경할 Column Index. 
 * @param  strColID       변경할 Column ID.
 * @return                Variant 지정한 Record Index와 Column ID에 해당하는 값. 해당하는 값이 없을 경우에는 Null을 Return 합니다
 */
DataSet.prototype.getOrgColumn = function(nRow, varCol){
	//레코드 인덱스 체크
	nRow = parseInt(nRow + "", 10);
	if( !this.isRightRow(nRow) ){
		return null;
	}
	
	//컬럼 인덱스, 아이디 체크
	var strColID = (typeof varCol == 'number') ? this.getColID(varCol) : varCol;
	if( !this.isRightColId(strColID) ){
		strColID = null;
		return undefined;
	}
	
	var record = this.records[nRow];
	var recordId = record._id;
	var orgRecord = null;
	var columnValue = null;
	var orgBufferCount = this.OriginBuffer.length;
	var i = 0;
	
	//일치하는 레코드가 없는 경우 현재 레코드의 값을 리턴
	columnValue = record.values[strColID];
	
	//값이 변경되어 OriginBuffer에 레코드가 존재하는지 체크하여 레코드가 존재한다면 컬럼 값을 리턴
	for(i = 0; i < orgBufferCount; i++, orgRecord = null){
		orgRecord = this.OriginBuffer[i];
		
		//레코드 ID가 일치하는 레코드가 있는 경우
		if( orgRecord._id == recordId ){
			columnValue = orgRecord.values[strColID];
			break;
		}
	}
	
	//메모리 해제
	orgRecord = null; record = null;
	recordId = null; strColID = null;

	return columnValue;
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{number}	varCol
 * @return  {void}
 * @example	미결
 */
DataSet.prototype.getOrgColumnNF = function(nRow, varCol){ 
	if (!this.isRightRow(nRow)) return null; 
	var nRowNF = parseInt(nRow + "", 10); 

	var strColID = (typeof(varCol) == 'number' ? this.getColID(varCol)  : varCol);
	if (!this.isRightColId(strColID)) return null;

	var record = this.buffer[nRowNF];
	for (var i = 0; i < this.OriginBuffer.length; i++){
		var orgRecord = this.OriginBuffer[i];
		if (orgRecord._id == record._id){
			return orgRecord.values[varCol];
		}
	}

	return null;
};

/**
 * Dataset에서 지정한 Column ID의 Column 값과 입력된 Value의 값이 일치하는 첫번째 레코드 Index를 얻어오는 Method 
 *   
 *   FindRow(strColID,strVal);
 *   FindRow(strColID,strVal,nStart);
 *   FindRow(strColID,strVal,nStart,nEnd);
 *   
 * @param  strColID       검색할 Dataset의 Column ID.
 * @param  strVal         검색할 Dataset의 Column Value.
 * @param  nStart      검색할 시작 레코드 Index, 시작 Index값은 0, nStart가 0보다 작으면, 전체를 검색 [Default Value = 0]
 * @param  nEnd        검색할 마지막 레코드 Index + 1, 지정된 값보다 1 작은 레코드까지 검색, nEnd가 0보다 작으면 nStart에서 끝까지 검색 [Default Value = -1]
 * @return                Integer Dataset의 Column ID와 Column Value에 해당하는 레코드 Index. 해당하는 값이 없을 경우에는 -1을 Return 합니다
 */
DataSet.prototype.findRow = function(strColID, strVal, nStart, nEnd){ 
	if (!this.isRightColId(strColID)) return -1;

	if (nStart == undefined) {
		nStart = 0;
	} else if (nStart < 0) {
		nStart = 0;
		nEnd = this.records.length
	}
	if (nEnd == undefined) {
		nEnd = this.records.length;
	} else if (nEnd < 0) {
		nEnd = this.records.length;
	}

	for (var nRow = nStart; nRow < nEnd; nRow++){
		if (this.records[nRow].values[strColID] + "" == strVal){
			if (this.records[nRow].RowType != "Logical"){
				return nRow;
			}
		}
	}	

	return -1;
};



/**
 * Dataset에서 Column ID의 Column값 중 입력된 Value의 값을 포함하는 첫번째 레코드 Index를 얻어오는 Method입니다.
 * Column 값중 앞부분이 문자열 입력된 Value의 값과 일치해야 합니다.  "LIKE%"와 같은 기능입니다.
 *   
 *   findRowAs(strColID,strVal);
 *   findRowAs(strColID,strVal,nStart);
 *    findRowAs(strColID,strVal,nStart,nEnd);
 *   
 * @param  strColID       검색할 Dataset의 Column ID.
 * @param  strVal         검색할 Dataset의 Column Value.
 * @param  nStart      검색할 시작 레코드 Index, 시작 Index값은 0, nStart가 0보다 작으면, 전체를 검색 [Default Value = 0]
 * @param  nEnd        검색할 마지막 레코드 Index + 1, 지정된 값보다 1 작은 레코드까지 검색, nEnd가 0보다 작으면 nStart에서 끝까지 검색 [Default Value = -1]
 * @return                Integer Dataset의 Column ID와 Column Value에 해당하는 레코드 Index. 해당하는 값이 없을 경우에는 -1을 Return 합니다
 */
DataSet.prototype.findRowAs = function(strColID, strVal, nStart, nEnd){ 
	if (!this.isRightColId(strColID)) return -1;
	
	strVal = (strVal.replace(/^%/, "")).replace(/%$/, "");

	if (nStart == undefined) {
		nStart = 0;
	} else if (nStart < 0) {
		nStart = 0;
		nEnd = this.records.length
	}
	if (nEnd == undefined) {
		nEnd = this.records.length;
	} else if (nEnd < 0) {
		nEnd = this.records.length;
	}

	for (var nRow = nStart; nRow < nEnd; nRow++){
		if (("" + this.records[nRow].values[strColID]).indexOf(strVal) >= 0){
			if (this.records[nRow].RowType != "Logical"){
				return nRow;
			}
		}
	}	

	return -1;
};
/**
 * @description	미결
 * @param	{string}	strColID
 * @param	{number}	strVal
 * @param	{number}	nStart
 * @param	{number}	nEnd
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.findRowNF = function(strColID, strVal, nStart, nEnd){ 
	if (!this.isRightColId(strColID)) return -1;

	if (nStart == undefined) {
		nStart = 0;
	} else if (nStart < 0) {
		nStart = 0;
		nEnd = this.buffer.length
	}
	if (nEnd == undefined) {
		nEnd = this.buffer.length;
	} else if (nEnd < 0) {
		nEnd = this.buffer.length;
	}

	for (var nRowNF = nStart; nRowNF < nEnd; nRowNF++){
		if (this.buffer[nRowNF].values[strColID] + "" == strVal){
			return nRowNF;
		}
	}	

	return -1;
};

/**
 * @description	미결
 * @param	{string}	strColID
 * @param	{string}	strVal
 * @param	{number}	nStart
 * @param	{number}	nEnd	
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.findRowNFAs = function(strColID, strVal, nStart, nEnd){ 
	if (!this.isRightColId(strColID)) return -1;

	if (nStart == undefined) {
		nStart = 0;
	} else if (nStart < 0) {
		nStart = 0;
		nEnd = this.records.length
	}
	if (nEnd == undefined) {
		nEnd = this.records.length;
	} else if (nEnd < 0) {
		nEnd = this.records.length;
	}

	var regex= new RegExp(RegExp.escape("" + strVal));

	for (var nRowNF = nStart; nRowNF < nEnd; nRowNF++){
		if (("" + this.buffer[nRowNF].values[strColID]).search(regex) >= 0){
			return nRowNF;
		}
	}	

	return -1;
};


/**
 * Logical Record를 제외한 유효한 Dataset의 Record 갯수를 얻어오는 Method 
 * SubSum Record가 없을 경우에는 Count Property, RowCount Property, GetRowCount Method, RowCount Method와 같습니다.
 * 단 Filter 또는 삭제된 레코드는 제외합니다.
 * 
 * SearchRow(strCmpExpr);
 * SearchRow(strCmpExpr,nStart);
 * SearchRow(strCmpExpr,nStart,nEnd);
 *   
 * @param  strCmpExpr     검색할 조건식.
 * @param  nStart      검색하고자 하는 시작 Record Index. [Default Value = 0]
 * @param  nEnd        검색하고자 하는 마지막 Record Index. [Default Value = -1]
 * @return                조건식에 맞는 첫번째 Record Index., 조건식을 만족하는 Record가 없을 경우에는 -1 을 Return

 */
DataSet.prototype.searchRow = function(strCmpExpr, nStart, nEnd){ 
	// 변수명을 바꾼다 
	var formula = this._UpdateFormula(strCmpExpr);
	var funcSearch = new Function("return function (nRowNum) { return " + formula + "; }")();
	
	for (var nRow = 0; nRow < this.records.length; nRow++){
//		if (eval(formula.replace("nRowNum", nRow))){
//		if( eval(formula.replace(/nRowNum/g, nRow)) ){
		if( funcSearch(nRow) ){
			return nRow;
		}
	}

	return -1;
};
// 주의 strCmpExpr내부에서도 NF함수를 써야함 , nRowNF 대입가능
/**
 * @description	미결
 * @param	{string}	strCmpExpr
 * @param	{number}	nStart
 * @param	{number}	nEnd
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.searchRowNF = function(strCmpExpr, nStart, nEnd){ 
	// 변수명을 바꾼다 
	var formula = this._UpdateFormulaNF(strCmpExpr);
	var funcSearch = new Function("return function (nRowNum) { return " + formula + "; }")();
	
	for (var nRowNF = 0; nRowNF < this.buffer.length; nRowNF++){
//		if (eval(formula.replace("nRowNum", nRowNF))){
//		if( eval(formula.replace(/nRowNum/g, nRowNF)) ){
		if( funcSearch(nRowNF)){
			return nRowNF;
		}
	}

	return -1;
};

/**
 * Dataset의 내용을 지정한 Dataset에서 복사하는 Method 입니다.
 * 
 * Copy(objDataset);
 * Copy(strDataset);
 *   
 * @param  objDataset     복사할 Datset Object
 * @param  strDataset     복사할 Dataset ID
 * @return                복사된 Record 갯수. 복사할 Dataset이 존재하지 않으면 Null을 Return 합니다.
 */
DataSet.prototype.copy = function(varDataset){ 
	if(varDataset == undefined || varDataset == null) return 0;
	var objDataset = null;
	if (typeof(varDataset) == "string" ){
		objDataset = dataSets[varDataset];
	}else{
		objDataset = varDataset;
	}
	
	this.clear();

	for (var key in objDataset.colInfos){
		if( typeof(objDataset.colInfos[key]) == "function" ) continue;
		var colInfo = objDataset.colInfos[key];
		var newColInfo = new MiColInfo(colInfo.id, colInfo.size, colInfo.type);
		
		this._colCount++;
		this.colInfos[key] = newColInfo;
//		newColInfo.index = this._colCount - 1;
		newColInfo.index = colInfo.index;
	}

	var cnt = 0;
	for (var nRow=0; nRow < objDataset.records.length; nRow++){
		var fromRecord = objDataset.records[nRow];
		var toRecord = new MiRecord(this.colInfos);
		
		// toRecord의 디폴트 상태가 된다 : RowType = "Normal",_filterd = false, _selected = false;
		// 예외 추가 : RowType = "Logical" 인 경우 레코드의  RowType은 같이 복사된다.
		if(fromRecord.RowType == "Logical"){
			toRecord.RowType = "Logical";
		}

		for (var key in fromRecord.values){
			if( typeof(fromRecord.values[key]) == "function" ) continue;
			toRecord.values[key] = fromRecord.values[key];
		}
		
		this.records[nRow] = toRecord;

		toRecord._orignalIndex = this.buffer.length;
		this.buffer[this.buffer.length] = toRecord;
		
		cnt++;
	}

	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
		this._ResetGroup();
	}
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();

	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ) this.updateControlList();
	
	if (this._GroupKey.length > 0){
	    this._refreshGroupCation(true);
	}

	return (cnt == 0 ? null : cnt);
};

/**
 * 지정한 Dataset의 Record의 지정한 Column의 값으로 Dataset의 지정한 Record의 지정한 Column의 값을 변경하는 Method
 * 
 * CopyColumn(nToRow,nToCol,strDataset,nFromRow,nFromCol);
 * CopyColumn(nToRow,strToCol,strDataset,nFromRow,strFromCol);
 * CopyColumn(nToRow,nToCol,objDataset,nFromRow,nFromCol);
 * CopyColumn(nToRow,strToCol,objDataset,nFromRow,strFromCol);
 *   
 * @param  objDataset     복사할 Datset Object
 * @param  strDataset     복사할 Dataset ID
 * @return                복사된 Record 갯수. 복사할 Dataset이 존재하지 않으면 Null을 Return 합니다.
 */
DataSet.prototype.copyColumn = function(nToRow, varToCol, varDataset, nFromRow, varFromCol){ 
	if(varDataset == undefined || varDataset == null) return 0;
	var objDataset = null;
	if (typeof(varDataset) == "string" ){
		objDataset = dataSets[varDataset];
	}else{
		objDataset = varDataset;
	}
	
	var strToCol = (typeof(varToCol) == 'number' ? this.getColID(varToCol) : varToCol);
	var strFromCol = (typeof(varFromCol) == 'number' ? objDataset.getColID(varFromCol) : varFromCol);
	
	if (!this.isRightColId(strToCol)) return null;
	if (!objDataset.isRightColId(strFromCol)) return null;

	if (!this.isRightRow(nToRow)) return null; 
	if (!objDataset.isRightRow(nFromRow)) return null; 

	var nToRow = parseInt(nToRow + "", 10); 
	var nFromRow = parseInt(nFromRow + "", 10); 

	this.setColumn(nToRow, strToCol, objDataset.getColumn(nFromRow, strFromCol));

	return 1;
};

/**
 * 지정한 Dataset에서 지정한 Record 전체를 복사해 DataSet의 지정한 Record를 변경하는 Method
 * Column 명이 서로 다를경우, 복사할 Column이 저장될 Column을 지정할 수 있습니다.
 * 
 *  CopyRow(nToRow,strDataset,nFromRow,strColInfo);
 *  CopyRow(nToRow,objDataset,nFromRow,strColInfo);
 *   
 * @param  nToRow         Target Dataset의 복사되어 변경 될 Row Index.
 * @param  strDataset     Source Dataset의 id를 문자열로 입력
 * @param  nFromRow       Source Dataset의 복사 할 Record Index.
 * @param  strColInfo     복사할 조건.[생략 가능] 생략시에는 같은 필드명의 값을 복사합니다. ToColumnID=FromColumnID,ToColumnID1=FromColumnID1 형식으로 입력합니다.
 * @return                없음
 */
DataSet.prototype.copyRow = function(nToRow, varDataset, nFromRow, strColInfo){ 
	if(varDataset == undefined || varDataset == null) return 0;
	var objDataset = null;
	if (typeof(varDataset) == "string" ){
		objDataset = dataSets[varDataset];
	}else{
		objDataset = varDataset;
	}

	if (!this.isRightRow(nToRow)) return null; 
	if (!objDataset.isRightRow(nFromRow)) return null; 

	nToRow = parseInt(nToRow + "", 10); 
	nFromRow = parseInt(nFromRow + "", 10); 

	// 옮기기 조건 분석
	var matchs = [];
	if (strColInfo != undefined){
		strColInfo = strColInfo.replace(/==/g, "=");
		var wArr = strColInfo.split(",");
		for (var i = 0; i < wArr.length; i++){
			var wArr1 = wArr[i].split("=");
			var toColumnID = wArr1[0].trim();
			var fromColumnID = wArr1[1].trim();

			matchs[fromColumnID] = toColumnID;
		}
	}
	else{
		for(var colId in objDataset.colInfos){
			if (typeof this.colInfos[colId] != "function" && this.colInfos[colId] != null && this.colInfos[colId] != undefined) {				
				matchs[colId] = colId;
			}
		}
	}

	var cnt = 0;

	var fromRecord = objDataset.records[nFromRow];
	var toRecord = this.records[nToRow];
	var orgRecord = toRecord.clone();


	for (var key in toRecord.values){
		if( typeof(toRecord[key]) == "function" ) continue;
		var toColumnID = key;
		var fromColumnID = key;

		if (typeof matchs[fromColumnID] != "function" && matchs[fromColumnID] != null && matchs[fromColumnID] != undefined){
			toColumnID = matchs[fromColumnID];
			toRecord.values[toColumnID] = fromRecord.values[fromColumnID];
		}
	}
	
	if (this.UpdateControl){
		// UpdateControl Property가 True인 경우에는 변경된 레코드의 RowType은 "update"가 됩니다.
		// 그리고 Orgin Buffer에 변경된 레코드가 추가됩니다.
		if (toRecord.RowType == "Normal"){
			this.OriginBuffer[this.OriginBuffer.length] = orgRecord;
			orgRecord._orignalIndex = toRecord._orignalIndex;
			toRecord.RowType = "Update";
		}
	}
	else {
		// UpdateControl Property가 False인 경우에는 추가된 레코드의 RowType은 "normal"이 됩니다.
	}
	
	if (this.FilterExpr.length > 0){
//		var formula = this._UpdateFormulaNF(this.FilterExpr);
//		if (eval(formula.replace("nRowNum", nToRow)) == false){
//		if(eval(formula.replace(/nRowNum/g, nToRow)) == false){
		if(this.FilterFunction(nToRow) == false){
			this.records[nToRow]._filterd = true;
			this.records.splice(nToRow, 1);
			
	    	// rangeStart 한줄씩 앞으로 당기기
	        this._updateRangeStartsAfter(nToRow, -1);
		}
	}
	
	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
		this._RefreshGroupByOneRecord(nToRow);
	}

	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();
	
	// 관련 시트데이터 수정
	if( this.instantUpdateControl ) this.updateControlRowData(this.records[nToRow]); // this.updateControlRowData(nToRow);
	

	return;
};

/**
 * 지정한 Dataset에서 지정한 Record 전체를 복사해 DataSet의 지정한 Record를 변경하는 Method
 * Column 명이 서로 다를경우, 복사할 Column이 저장될 Column을 지정할 수 있습니다.
 * 
 *  CopyToRow(nFromRow,strDataset,nToRow,strColInfo);
 *  CopyToRow(nFromRow,objDataset,nToRow,strColInfo);
 *   
 * @param  nToRow         Source Dataset의 복사되어 변경 될 Row Index.
 * @param  strDataset     Target Dataset의 id를 문자열로 입력
 * @param  nFromRow       Target Dataset의 복사 할 Record Index.
 * @param  strColInfo     복사할 조건.[생략 가능] 생략시에는 같은 필드명의 값을 복사합니다. ToColumnID=FromColumnID,ToColumnID1=FromColumnID1 형식으로 입력합니다.
 * @return                없음
 */
DataSet.prototype.copyToRow = function(nFromRow, varDataset, nToRow, strColInfo){ 
	if(varDataset == undefined || varDataset == null) return 0;
	var objDataset = null;
	if (typeof(varDataset) == "string" ){
		objDataset = dataSets[varDataset];
	}else{
		objDataset = varDataset;
	}

	if (!this.isRightRow(nToRow)) return null; 
	if (!objDataset.isRightRow(nFromRow)) return null; 

	nToRow = parseInt(nToRow + "", 10); 
	nFromRow = parseInt(nFromRow + "", 10); 

	// 옮기기 조건 분석
	strColInfo = strColInfo.replace(/==/g, "=");
	var matchs = [];
	if (strColInfo != undefined){
		var wArr = strColInfo.split(",");
		for (var i = 0; i < wArr.length; i++){
			var wArr1 = wArr[i].split("=");
			var toColumnID = wArr1[0];
			var fromColumnID = wArr1[1];

			matchs[fromColumnID] = toColumnID;
		}

	}

	var cnt = 0;

	var toRecord = objDataset.records[nFromRow];
	var fromRecord = this.records[nToRow];
	var orgRecord = toRecord.clone();

	for (var key in fromRecord.values){
		if( typeof(fromRecord.values[key]) == "function" ) continue;
		var toColumnID = key;
		var fromColumnID = key;

		if (matchs[fromColumnID] != null && matchs[fromColumnID] != undefined){
			toColumnID = matchs[fromColumnID];
			toRecord.values[toColumnID] = fromRecord.values[fromColumnID];
		}
	}
	matchs.clear();
	
	if (objDataset.UpdateControl){
		// UpdateControl Property가 True인 경우에는 변경된 레코드의 RowType은 "update"가 됩니다.
		// 그리고 Orgin Buffer에 변경된 레코드가 추가됩니다.
		if (toRecord.RowType == "Normal"){
			objDataset.OriginBuffer[this.OriginBuffer.length] = orgRecord;
			orgRecord._orignalIndex = toRecord._orignalIndex;
		}
		toRecord.RowType = "Update";
		
	} else {
		// UpdateControl Property가 False인 경우에는 추가된 레코드의 RowType은 "normal"이 됩니다.
	}
	
	if (objDataset.FilterExpr.length > 0){
//		var formula = objDataset._UpdateFormulaNF(objDataset.FilterExpr);
//		if (eval(formula.replace("nRowNum", nToRow)) == false){
//		if(eval(formula.replace(/nRowNum/g, nToRow)) == false){
		if(this.FilterFunction(nToRow) == false){
			objDataset.records[nToRow]._filterd = true;
			objDataset.records.splice(nToRow, 1);
			
	    	// rangeStart 한줄씩 앞으로 당기기
			objDataset._updateRangeStartsAfter(nToRow, -1);
			
		}
	}

	// 그룹정보 갱신 
	if (objDataset._GroupKey.length > 0){
		objDataset._RefreshGroupByOneRecord(nToRow);
	}
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	objDataset.setBlocking();
	
	// 관련 시트데이터 수정
	objDataset.updateControlRowData(objDataset.records[nToRow]); // objDataset.updateControlRowData(nToRow);
	
	
	return;
};

/**
 * 지정한 Dataset을 기존 Dataset에 추가하는 Method 입니다.
 * 기존 Dataset의 마지막 레코드 다음에 추가됩니다.
 * 
 *  Append(strDatasetID);
 *  Append(objDataset);
  *  
 * @param  strDatasetID  Append 할 Dataset ID.
 * @param  objDataset    Append 할 Dataset Object
 * 
 * @return               없음
 */
DataSet.prototype.appendDataset = function(varDataset, arrStrColIds){ 
	if(varDataset == undefined || varDataset == null) return 0;
	var objDataset = null;
	if (typeof(varDataset) == "string" ){
		objDataset = dataSets[varDataset];
	}
	else{
		objDataset = varDataset;
	}
	
	var columnFixed = (typeof arrStrColIds != "undefined");

	// 기존 Dataset의 Column 정보가 없을 경우에는 추가할 Dataset으로 Column정보를 만듭니다.
	// 기존 Dataset의 Column 정보가 있을 경우에는 마지막 레코드 뒤에 추가할 Dataset의 레코드만 더합니다. 
	// 그러므로 추가할 Dataset과 기존의 Dataset의 Column 정보는 일치해야 합니다. 
	// 일치하지 않을 경우에는 Column ID에 상관없이 순차적으로 추가하므로 원하지 않은 결과를 얻을 수 있습니다.
	if (columnFixed){
		for (var i = 0; i < arrStrColIds.length; i++){
			var key = arrStrColIds[i];
			if (this.colInfos[key] == null || this.colInfos[key] == undefined){
				alert(getText("message_dataset_015", "칼럼 {0}.{1}는 받는 데이터 셋 {2}쪽에서 없는 칼럼입니다", [objDataset.id, key, this.id]));
				return;
			}
		}
	}
	else {
		for (var key in objDataset.colInfos){
			var fromColInfo = objDataset.colInfos[key];
			if( typeof(fromColInfo) == "function" ) continue;
			if (this.colInfos[key] == null || this.colInfos[key] == undefined){
				alert(getText("message_dataset_015", "칼럼 {0}.{1}는 받는 데이터 셋 {2}쪽에서 없는 칼럼입니다", [objDataset.id, key, this.id]));
				return;
			}
		}
	}
	
	var fromRecord = objDataset.records[nFromRow];
	var toRecord = this.records[nToRow];
	
	for (var nFromRow = 0; nFromRow < objDataset.records.length; nFromRow++){
		var fromRecord = objDataset.records[nFromRow];

		var toRecord = new MiRecord();
		var nToRow = this.records.length;
		this.records[nToRow] = toRecord;
		
		toRecord._orignalIndex = this.buffer.length;
		this.buffer[this.buffer.length] = toRecord;
		
        if (columnFixed){
    		for (var i = 0; i < arrStrColIds.length; i++){
    			var key = arrStrColIds[i];
    			toRecord.values[key] = fromRecord.values[key];
    		}
        }
        else {
    		for (var key in fromRecord.values){
    			if( typeof(fromRecord.values[key]) == "function" ) continue;
    			toRecord.values[key] = fromRecord.values[key];
    		}
        }
		
		toRecord.RowType = "Insert";
		
		// 필터가 있는 경우 필터적용
		if (this.FilterExpr.length > 0){
//			var formula = this._UpdateFormulaNF(this.FilterExpr);
//			if (eval(formula.replace("nRowNum", nToRow)) == false){
//			if(eval(formula.replace(/nRowNum/g, nToRow)) == false){
			if(this.FilterFunction(nToRow) == false){
				this.records[nToRow]._filterd = true;
				this.records.splice(nToRow, 1);
			}
		}
	}
	
	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
		this._ResetGroup();
	}
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();

	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ) this.updateControlList();
	
	if (this._GroupKey.length > 0){
	    this._refreshGroupCation(true);
	}

	// AppendDataset Method가 완료되고 나면 OnLoadCompleted Event가 발생합니다. 
	// 이때 OnLoadCompleted Event의 nReason 값은 4 입니다.
	var nErrorCode = [];
	var strErrorMsg = [];
	if (this.hasLoadCompletedEvent) {
		this.fncLoadCompletedEvent(this, nErrorCode, strErrorMsg, 4);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
			return ;
		}            
	} 
	
	return;
};

//*** 산식처리 ***   *** 산식처리 ***   *** 산식처리 ***   *** 산식처리 ***   *** 산식처리 ***   *** 산식처리 *** 
/**
 * @description	미결
 * @param	{string}	includeFiltered
 * @param	{string}	strCmpExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotCol
 * @param	{number}	bCountNull
 * @return  {number}
 * @example	미결
 */
DataSet.prototype._Count = function(includeFiltered, strCmpExpr, nStart, nCnt, nPivotCol, bCountNull){ 

	// 변수명을 바꾼다 
	var compFormula = (includeFiltered ? this._UpdateFormulaNF(strCmpExpr) : this._UpdateFormula(strCmpExpr));
	var funcCompare = new Function("return function (nRowNum) { return " + compFormula + "; }")();

	var recordList = (includeFiltered ? this.buffer : this.records);
	var cnt = 0;
	for (var nRow = nStart; nRow < nStart + nCnt; nRow++){
		if (recordList[nRow].RowType != "Logical"){
			if (compFormula.length == 0 || funcCompare(nRow)){ cnt++; }
		}
	}	

	return cnt;

	// 미결
	// PivotDataset에서 strCoIDl의 Column이 PivotKey나 GroupKey에 의해 지정된 Column이 아닐경우
	// (col,nPivotIndex,Start,Count) 의 형태로 입력 Argument가 인식됩니다.
	// PivotKey나 GroupKey에 의해 지정된 Column 이거나, PivotDataset이 아닐경우
	// 기존의 (Start,Count)의 형태로 처리됩니다.
};

/**
 * Logical Record를 제외한 유효한 Dataset의 Record 갯수를 얻어오는 Method 
 * SubSum Record가 없을 경우에는 Count Property, RowCount Property, GetRowCount Method, RowCount Method와 같습니다.
 * 단 Filter 또는 삭제된 레코드는 제외합니다.
 * 
 * Count();
 * Count(nStart);
 * Count(nStart, nCnt);
 * Count(nStart, nCnt, nPivotIndex);
 * Count(strCol,nPivotIndex);                   // ???
 * Count(strCol,nPivotIndex,nStart);         // ???
 * Count(strCol,nPivotIndex,nStart,nCnt);    // ???
 *   
 * @param  nStart      Dataset의 갯수를 가져올 기준 Index. [Default Value = 0]
 * @param  nCnt           얻고자 하는 Record 갯수 [Default Value = -1]
 * @param  strColID       검색할 Dataset의 Column ID.[Default Value = RowCount]
 * @param  nPivotIndex    값을 구할 PivotCol의 Index. [Defualt Value = -1]
 * @return                Integer Dataset의 레코드 개수, SubSum Record를 포함한 갯수
 */
DataSet.prototype.count = function(nStart, nCnt, nPivotIndex){ 

	if (nStart == undefined) { nStart = 0; }
	if (nCnt == undefined) { nCnt = this.records.length; }
	if (nPivotIndex == undefined) { nPivotIndex = -1; }

	var includeFiltered = false;
	var strCmpExpr = "";
	var bCountNull = false;

	return this._Count(includeFiltered, strCmpExpr, nStart, nCnt, nPivotIndex, bCountNull);
};

/**
 * Filter된 데이타를 포함한 Dataset에서 Logical Record를 제외한 유효한 Record 갯수를 얻어오는 Method 입니다. 
 * 
 * CountNF();
 * CountNF(nStart);
 * CountNF(nStart, nCnt);
 * CountNF(nStart, nCnt, nPivotIndex);
 * CountNF(strCol,nPivotIndex);						// ???
 * CountNF(strCol,nPivotIndex,nStart);           // ???
 * CountNF(strCol,nPivotIndex,nStart,nCnt);      // ???

 *   
 * @param  nStart      Dataset의 갯수를 가져올 기준 Index. [Default Value = 0]
 * @param  nCnt           얻고자 하는 Record 갯수 [Default Value = -1]
 * @param  nPivotIndex    값을 구할 PivotCol의 Index. [Defualt Value = -1]
 * @param  strCol         검색할 Dataset의 Column ID.[Default Value = RowCount]
 * @return                Integer Dataset의 레코드 개수, SubSum Record를 포함한 갯수
 */
DataSet.prototype.countNF = function(nStart, nCnt, nPivotIndex){ 
	var wReturn = 0; 
	if (nStart == undefined) { nStart = 0; }
	if (nCnt == undefined) { nCnt = this.buffer.length; }
	if (nPivotIndex == undefined) { nPivotIndex = -1; }

	var includeFiltered = true;
	var strCmpExpr = "";
	var bCountNull = false;

	return this._Count(includeFiltered, strCmpExpr, nStart, nCnt, nPivotIndex, bCountNull);

};
/**
 * @description	미결
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotIndex
 * @return  {object}
 * @example	미결
 */
DataSet.prototype.totalCount = function(nStart, nCnt, nPivotIndex){ 

	if (nStart == undefined) { nStart = 0; }
	if (nCnt == undefined) { nCnt = this.buffer.length; }
	if (nPivotIndex == undefined) { nPivotIndex = -1; }

	return this.countNF(nStart, nCnt, nPivotIndex);
};

/**
 * 해당 범위안에서 조건식에 맞는 Record의 갯수를 구하는 Method  
 * 단 Filter 또는 삭제된 레코드는 제외합니다.
 * 
 * CaseCount(strCmpExpr);
 * CaseCount(strCmpExpr,nStart);
 * CaseCount(strCmpExpr,nStart,nCnt);
 * CaseCount(strCmpExpr,nStart,nCnt,nPivotCol);            // ???
 * CaseCount(strCmpExpr,nStart,nCnt,nPivotCol,bCountNull); // ???
 *   
 * @param  strCmpExpr     갯수를 구할 Record를 추출하기 위한 조건문.
 * @param  nStart         Dataset의 갯수를 가져올 기준 Index. [Default Value = 0]
 * @param  nCnt           얻고자 하는 Record 갯수 [Default Value = -1]
 * @param  nPivotCol      값을 구할 PivotCol의 Index. [Defualt Value = -1]
 * @param  bCountNull     PivotTable상에 존재하지 않는 레코드를 계산에 포함할지 지정.[Defualt Value = false]
 * @return                Integer Dataset의 레코드 개수, SubSum Record를 포함한 갯수
 */
DataSet.prototype.caseCount = function(strCmpExpr, nStart, nCnt, nPivotCol, bCountNull){ 
	if (nStart == undefined) { nStart = 0; }
	if (nCnt == undefined) { nCnt = this.records.length; }
	if (nPivotCol == undefined) { nPivotCol = -1; }
	if (bCountNull == undefined) { bCountNull = false; }


	var includeFiltered = false;
	var bCountNull = false;

	return this._Count(includeFiltered, strCmpExpr, nStart, nCnt, nPivotCol, bCountNull);
};
/**
 * Filter된 데이타를 포함한 Dataset의 해당 범위안에서 조건식에 맞는 Record의 갯수를 구하는 Method 입니다.
 * 
 * CaseCountNF(strCmpExpr);
 * CaseCountNF(strCmpExpr,nStart);
 * CaseCountNF(strCmpExpr,nStart,nCnt);
 * CaseCountNF(strCmpExpr,nStart,nCnt,nPivotCol);
 * CaseCountNF(strCmpExpr,nStart,nCnt,nPivotCol,bCountNull);
 *   
 * @param  strCmpExpr     갯수를 구할 Record를 추출하기 위한 조건문.
 * @param  nStart         Dataset의 갯수를 가져올 기준 Index. [Default Value = 0]
 * @param  nCnt           얻고자 하는 Record 갯수 [Default Value = -1]
 * @param  nPivotCol      값을 구할 PivotCol의 Index. [Defualt Value = -1]
 * @param  bCountNull     PivotTable상에 존재하지 않는 레코드를 계산에 포함할지 지정.[Defualt Value = false]
 * @return                Integer Dataset의 레코드 개수, SubSum Record를 포함한 갯수
 */
DataSet.prototype.caseCountNF = function(strCmpExpr,nStart,nCnt,nPivotCol,bCountNull){ 
	if (nStart == undefined) { nStart = 0; }
	if (nCnt == undefined) { nCnt = this.buffer.length; }
	if (nPivotCol == undefined) { nPivotCol = -1; }
	if (bCountNull == undefined) { bCountNull = false; }

	var includeFiltered = true;
	var bCountNull = false;

	return this._Count(includeFiltered, strCmpExpr, nStart, nCnt, nPivotCol, bCountNull);

};
/**
 * @description	미결
 * @param	{string}	strCmpExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotCol
 * @param	{number}	bCountNull
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.totalCaseCount = function(strCmpExpr,nStart, nCnt, nPivotCol, bCountNull){ 
	if (nStart == undefined) { nStart = 0; }
	if (nCnt == undefined) { nCnt = this.buffer.length; }
	if (nPivotCol == undefined) { nPivotCol = -1; }
	if (bCountNull == undefined) { bCountNull = false; }

	return this.caseCountNF(strCmpExpr,nStart, nCnt, nPivotCol, bCountNull);
};

/**
 * @description	미결
 * @param	{string}	includeFiltered
 * @param	{string}	strCmpExpr
 * @param	{string}	strValExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotCol
 * @return  {string}
 * @example	미결
 */
DataSet.prototype._Max = function(includeFiltered, strCmpExpr, strValExpr, nStart, nCnt, nPivotCol){
	// 첫째 인수가 칼럼인지 산식인지 판단
	var isFormula = !this._IsColumnName(strValExpr);
	var compFormula = (includeFiltered ? this._UpdateFormulaNF(strCmpExpr) : this._UpdateFormula(strCmpExpr));
	var funcCompare = new Function("return function (nRowNum) { return " + compFormula + "; }")();


	var arrRecods = (includeFiltered ? this.buffer : this.records );

	var maxValue;

	// 변수명을 바꾼다 
	if (!isFormula){
		var strColID = strValExpr;

		for (var nRow = nStart; nRow < nStart + nCnt; nRow++){
			var record = arrRecods[nRow];
			if (record.RowType != "Logical"){
				if (compFormula.length == 0 || funcCompare(nRow)){
					if (maxValue == undefined){
						maxValue = record.values[strColID];
					} else {
						maxValue = (record.values[strColID] > maxValue ? record.values[strColID] : maxValue);
					}
				}
			}
		}

	} else {
		var formula = (includeFiltered ? this._UpdateFormulaNF(strValExpr) : this._UpdateFormula(strValExpr));
		var func = new Function("return function (nRowNum) { return " + formula + "; }")();
		
		for (var nRow = nStart; nRow < nStart + nCnt; nRow++){
			var record = arrRecods[nRow];
			if (record.RowType != "Logical"){
				if (compFormula.length ==0 || funcCompare(nRow)){
					var val = func(nRow);
					if (maxValue == undefined){
						maxValue = val;
					} else {
						maxValue = (val > maxValue ? val : maxValue);
					}
				}
			}
		}
	}

	return maxValue;
};

/**
 * 지정한 Dataset에서 지정한 Record 전체를 복사해 DataSet의 지정한 Record를 변경하는 Method
 * Column 명이 서로 다를경우, 복사할 Column이 저장될 Column을 지정할 수 있습니다.
 * 
 *  Max(strColID);
 *  Max(strColID,nStart);
 *  Max(strColID,nStart,nCnt,nPivotIndex);
 *  Max(strExpr);
 *  Max(strExpr,nStart);
 *  Max(strExpr,nStart,nCnt,nPivotIndex);
 *  Max(strColID,nPivotIndex);              // ???
 *  Max(strColID,nPivotIndex,nStart);       // ???
 *  Max(strColID,nPivotIndex,nStart,nCnt);  // ???
 *   
 * @param  strColID       최대값을 구할 Column ID
 * @param  strExpr        Record 별로 수행될 수식.
 * @param  nStart         최대값을 구하고자 하는 시작 Record Index. 시작 Index 0 입니다. [Default Value = 0]
 * @param  nPivotIndex    최대값을 구할 PivotCol의 Index. [Defualt Value = -1]
 * @param  nCnt           최대값을 구할 Record 갯수. [Defualt Value = RowCount]
 * @return                (Variant)구해진 최대값
 */
DataSet.prototype.max = function(strExpr, nStart, nCnt, nPivotIndex){ 
	var maxValue;
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.records.length;}
	if (nPivotIndex == undefined) {nPivotIndex = -1;}

	var includeFiltered = false;
	var strCmpExpr = "";

	return this._Max(includeFiltered, strCmpExpr, strExpr, nStart, nCnt, nPivotIndex);
};
/**
 * @description	미결
 * @param	{string}	strExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotIndex
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.maxNF = function(strExpr, nStart, nCnt, nPivotIndex){ 
	var maxValue;
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotIndex == undefined) {nPivotIndex = -1;}

	var includeFiltered = true;
	var strCmpExpr = "";

	return this._Max(includeFiltered, strCmpExpr, strExpr, nStart, nCnt, nPivotIndex);

};
/**
 * @description	미결
 * @param	{string}	strExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotIndex
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.totalMax = function(strExpr, nStart, nCnt, nPivotIndex){ 
	var maxValue;
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.records.length;}
	if (nPivotIndex == undefined) {nPivotIndex = -1;}

	return this.maxNF(strExpr, nStart, nCnt, nPivotIndex);
};

/**
 * 지정한 Dataset에서 지정한 Record 전체를 복사해 DataSet의 지정한 Record를 변경하는 Method
 * Column 명이 서로 다를경우, 복사할 Column이 저장될 Column을 지정할 수 있습니다.
 * 
 *  CaseMax(strCmpExpr,strValExpr);
 *  CaseMax(strCmpExpr,strValExpr,nStart);
 *  CaseMax(strCmpExpr,strValExpr,nStart,nCnt);
 *  CaseMax(strCmpExpr,strValExpr,nStart,nCnt,nPivotCol);
 *  CaseMax(strCmpExpr,strValExpr,nStart,nCnt,nPivotCol,bCountNull);
 *   
 * @param  strCmpExpr     최대값을 구할 Record를 추출하기 위한 조건문.
 * @param  strColID       최대값을 구할 Column ID
 * @param  strExpr        Record 별로 수행될 수식.
 * @param  nStart         최대값을 구하고자 하는 시작 Record Index. 시작 Index 0 입니다. [Default Value = 0]
 * @param  nPivotIndex    최대값을 구할 PivotCol의 Index. [Defualt Value = -1]
 * @param  nCnt           최대값을 구할 Record 갯수. [Defualt Value = RowCount]
 * @return                (Variant)구해진 최대값
 */
DataSet.prototype.caseMax = function(strCmpExpr, strValExpr, nStart, nCnt, nPivotCol){
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.records.length;}
	if (nPivotCol == undefined) {nPivotCol = -1;}


	var includeFiltered = false;
	return this._Max(includeFiltered, strCmpExpr, strValExpr, nStart, nCnt, nPivotCol);
};

/**
 * @description	미결
 * @param	{string}	strCmpExpr
 * @param	{string}	strValExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotCol
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.caseMaxNF = function(strCmpExpr,strValExpr,nStart,nCnt,nPivotCol){
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotCol == undefined) {nPivotCol = -1;}

	var includeFiltered = true;
	return this._Max(includeFiltered, strCmpExpr, strValExpr, nStart, nCnt, nPivotCol);
};

/**
 * @description	미결
 * @param	{string}	strCmpExpr
 * @param	{string}	strValExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotCol
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.totalCaseMax = function(strCmpExpr, strValExpr, nStart, nCnt, nPivotCol){
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotCol == undefined) {nPivotCol = -1;}

	return this.caseMaxNF(strCmpExpr, strValExpr, nStart, nCnt, nPivotCol);
};

/**
 * @description	미결
 * @param	{string}	strCmpExpr
 * @param	{string}	strValExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotCol
 * @return  {string}
 * @example	미결
 */
DataSet.prototype._Min = function(includeFiltered, strCmpExpr, strValExpr, nStart, nCnt, nPivotCol){
	// 첫째 인수가 칼럼인지 산식인지 판단
	var isFormula = !this._IsColumnName(strValExpr);
	var compFormula = (includeFiltered ? this._UpdateFormulaNF(strCmpExpr) : this._UpdateFormula(strCmpExpr));
	var funcCompare = new Function("return function (nRowNum) { return " + compFormula + "; }")();

	var arrRecods = (includeFiltered ? this.buffer : this.records );
	var minValue;

	// 변수명을 바꾼다 
	if (!isFormula){
		var strColID = strValExpr;

		for (var nRow = nStart; nRow < nStart + nCnt; nRow++){
			var record = arrRecods[nRow];
			if (record.RowType != "Logical"){
				if (compFormula.length ==0 || funcCompare(nRow)){
					if (minValue == undefined){
						minValue = record.values[strColID];
					} else {
						minValue = (record.values[strColID] < minValue ? record.values[strColID] : minValue);
					}
				}
			}
		}

	} else {
		var formula = (includeFiltered ? this._UpdateFormulaNF(strValExpr) : this._UpdateFormula(strValExpr));
		var func = new Function("return function (nRowNum) { return " + formula + "; }")();

		for (var nRow = nStart; nRow < nStart + nCnt; nRow++){
			var record = arrRecods[nRow];
			if (record.RowType != "Logical"){
				if (compFormula.length ==0 || funcCompare(nRow)){
					var val = func(nRow);
					if (minValue == undefined){
						minValue = val;
					} else {
						minValue = (val < minValue ? val : minValue);
					}
				}
			}
		}
	}

	return minValue;
};
/**
 * @description	미결
 * @param	{string}	strExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotIndex
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.min = function(strExpr, nStart, nCnt, nPivotIndex){ 
	var minValue;
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.records.length;}
	if (nPivotIndex == undefined) {nPivotIndex = -1;}

	var includeFiltered = false;
	var strCmpExpr = "";

	return this._Min(includeFiltered, strCmpExpr, strExpr, nStart, nCnt, nPivotIndex);
};
/**
 * @description	미결
 * @param	{string}	strExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotIndex
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.minNF = function(strExpr, nStart, nCnt, nPivotIndex){ 
	var minValue;
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotIndex == undefined) {nPivotIndex = -1;}

	var includeFiltered = true;
	var strCmpExpr = "";

	return this._Min(includeFiltered, strCmpExpr, strExpr, nStart, nCnt, nPivotIndex);

};
/**
 * @description	미결
 * @param	{string}	strExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotIndex
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.totalMin = function(strExpr, nStart, nCnt, nPivotIndex){ 
	var minValue;
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotIndex == undefined) {nPivotIndex = -1;}

	return this.minNF(strExpr, nStart, nCnt, nPivotIndex);
};
/**
 * @description	미결
 * @param	{string}	strCmpExpr
 * @param	{string}	strValExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotCol
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.caseMin = function(strCmpExpr, strValExpr, nStart, nCnt, nPivotCol){
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.records.length;}
	if (nPivotCol == undefined) {nPivotCol = -1;}


	var includeFiltered = false;
	return this._Min(includeFiltered, strCmpExpr, strValExpr, nStart, nCnt, nPivotCol);
};

/**
 * @description	미결
 * @param	{string}	strCmpExpr
 * @param	{string}	strValExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotCol
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.caseMinNF = function(strCmpExpr,strValExpr,nStart,nCnt,nPivotCol){
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotCol == undefined) {nPivotCol = -1;}

	var includeFiltered = true;
	return this._Min(includeFiltered, strCmpExpr, strValExpr, nStart, nCnt, nPivotCol);
};

/**
 * @description	미결
 * @param	{string}	strCmpExpr
 * @param	{string}	strValExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotCol
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.totalCaseMin = function(strCmpExpr, strValExpr, nStart, nCnt, nPivotCol){
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotCol == undefined) {nPivotCol = -1;}

	return this.caseMinNF(strCmpExpr, strValExpr, nStart, nCnt, nPivotCol);
};

/**
 * @description	미결
 * @param	{string}	includeFiltered
 * @param	{string}	strValExpr
 * @param	{number}	nStart
 * @param	{number}	nCnt
 * @param	{number}	nPivotCol
 * @return  {number}
 * @example	미결
 */
DataSet.prototype._Sum = function(includeFiltered, strCmpExpr, strValExpr, nStart, nCnt, nPivotCol){
	// 첫째 인수가 칼럼인지 산식인지 판단
	var compFormula = (includeFiltered ? this._UpdateFormulaNF(strCmpExpr) : this._UpdateFormula(strCmpExpr));
	var funcCompare = new Function("return function (nRowNum) { return " + compFormula + "; }")();
	
	var isFormula = !this._IsColumnName(strValExpr);

	var arrRecods = (includeFiltered ? this.buffer : this.records );
	var sumValue  = 0.0;

	// 변수명을 바꾼다 
	if (!isFormula){
		var strColID = strValExpr;
		var dataType = this.colInfos[strColID].type.toUpperCase();
		// 20160317 김민우 Dataset의 type을 Char로 설정해서 sum의 결과 0으로 나오기 때문에 sum을 동작시킬 타입 중 Char형 추가
		if ("SMALLINT,INTEGER,MONEY,FLOAT,INT,DECIMAL,CURRENCY, CHAR".indexOf(dataType) <0) {
			return 0.0;
		}

		for (var nRow = nStart; nRow < nStart + nCnt; nRow++){
			var record = arrRecods[nRow];
			if (record.RowType != "Logical"){
				if (compFormula.length == 0 || funcCompare(nRow)){
					if (sumValue == undefined){
						sumValue = record.values[strColID];
					} else {
						//sumValue += record.values[strColID];
						//20160317 김민우 수정
						sumValue += record.values[strColID] * 1;
					}
				}
			}
		}

	} else {
		var formula = (includeFiltered ? this._UpdateFormulaNF(strValExpr) : this._UpdateFormula(strValExpr));
		var func = new Function("return function (nRowNum) { return " + formula + "; }")();
		
		for (var nRow = nStart; nRow < nStart + nCnt; nRow++){
			var record = arrRecods[nRow];
			if (record.RowType != "Logical"){
				if (compFormula.length == 0 || funcCompare(nRow)){
					var val = func(nRow);
					if (sumValue == undefined){
						sumValue = val;
					} else {
						sumValue += val;
					}
				}
			}
		}
	}

	return sumValue;
};

/**
 * 해당 범위안에서 조건에 맞는 Record를 추출한 후, 계산식을 적용해 Record들의 합계를 구하는 Method 입니다.
 * 
 *  Sum(strColID);
 *  Sum(strColID,nStart);
 *  Sum(strColID,nStart,nCnt);
 *  Sum(strColID,nStart,nCnt,nPivotIndex);
 *  Sum(strExpr);
 *  Sum(strExpr,nStart);
 *  Sum(strExpr,nStart,nCnt);
 *  Sum(strExpr,nStart,nCnt,nPivotIndex);
 *  Sum(strColID,nPivotIndex);
 *  Sum(strColID,nPivotIndex,nStart);
 *  Sum(strColID,nPivotIndex,nStart,nCnt);
 *   
 * @param  strColID       최대값을 구할 Column ID
 * @param  strExpr        Record 별로 수행될 수식.
 * @param  nStart         최대값을 구하고자 하는 시작 Record Index. 시작 Index 0 입니다. [Default Value = 0]
 * @param  nPivotIndex    최대값을 구할 PivotCol의 Index. [Defualt Value = -1]
 * @param  nCnt           최대값을 구할 Record 갯수. [Defualt Value = RowCount]
 * @return                (Decimal)조건에 맞는 Column의 값들의 합계.
 */
DataSet.prototype.sum = function(strExpr, nStart, nCnt, nPivotIndex){ 
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.records.length;}
	if (nPivotIndex == undefined) {nPivotIndex = -1;}

	var includeFiltered = false;
	var strCmpExpr = "";
	return this._Sum(includeFiltered, strCmpExpr, strExpr, nStart, nCnt, nPivotIndex);
};
DataSet.prototype.sumNF = function(strExpr, nStart, nCnt, nPivotIndex){ 
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotIndex == undefined) {nPivotIndex = -1;}

	var includeFiltered = true;
	var strCmpExpr = "";
	return this._Sum(includeFiltered, strCmpExpr, strExpr, nStart, nCnt, nPivotIndex);
};

DataSet.prototype.totalSum = function(strExpr, nStart, nCnt, nPivotCol){ 
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotCol == undefined) {nPivotCol = -1;}

	return this.sumNF(strExpr, nStart, nCnt, nPivotCol);
};
DataSet.prototype.caseSum = function(strCmpExpr, strValExpr, nStart, nCnt, nPivotCol, bCountNull){ 
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.records.length;}
	if (nPivotCol == undefined) {nPivotCol = -1;}
	if (bCountNull == undefined) {bCountNull = false;}

	var includeFiltered = false;

	return this._Sum(includeFiltered, strCmpExpr, strValExpr, nStart, nCnt, nPivotCol);

};
DataSet.prototype.caseSumNF = function(strCmpExpr, strValExpr, nStart, nCnt, nPivotCol, bCountNull){ 
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotCol == undefined) {nPivotCol = -1;}
	if (bCountNull == undefined) {bCountNull = false;}

	var includeFiltered = true;

	return this._Sum(includeFiltered, strCmpExpr, strValExpr, nStart, nCnt, nPivotCol);
};
DataSet.prototype.totalCaseSum = function(strCmpExpr, strValExpr, nStart, nCnt, nPivotCol, bCountNull){ 
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotCol == undefined) {nPivotCol = -1;}

	return this.caseSumNF(strCmpExpr, strValExpr, nStart, nCnt, nPivotCol, bCountNull);
};


DataSet.prototype._Avg = function(includeFiltered, strCmpExpr, strValExpr, nStart, nCnt, nPivotCol){
	// 첫째 인수가 칼럼인지 산식인지 판단
	var compFormula = (includeFiltered ? this._UpdateFormulaNF(strCmpExpr) : this._UpdateFormula(strCmpExpr));
	var funcCompare = new Function("return function (nRowNum) { return " + compFormula + "; }")();
	var isFormula = !this._IsColumnName(strValExpr);

	var arrRecods = (includeFiltered ? this.buffer : this.records );
	var sumValue  = 0.0;var cnt = 0;

	// 변수명을 바꾼다 
	if (!isFormula){
		var strColID = strValExpr;
		var dataType = this.colInfos[strColID].type.toUpperCase();
		if ("SMALLINT,INTEGER,MONEY,FLOAT,INT,DECIMAL,CURRENCY".indexOf(dataType) <0) {
			return 0.0;
		}

		for (var nRow = nStart; nRow < nStart + nCnt; nRow++){
			var record = arrRecods[nRow];
			if (record.RowType != "Logical"){
				if (compFormula.length == 0 || funcCompare(nRow)){
					cnt++;
					if (sumValue == undefined){
						sumValue = record.values[strColID];
					} else {
						sumValue += record.values[strColID];
					}
				}
			}
		}

	} else {
		var formula = (includeFiltered ? this._UpdateFormulaNF(strValExpr) : this._UpdateFormula(strValExpr));
		var func = new Function("return function (nRowNum) { return " + formula + "; }")();
		for (var nRow = nStart; nRow < nStart + nCnt; nRow++){
			var record = arrRecods[nRow];
			if (record.RowType != "Logical"){
				if (compFormula.length == 0 || funcCompare(nRow)){
					cnt++;
					var val = func(nRow);
					if (sumValue == undefined){
						sumValue = val;
					} else {
						sumValue += val;
					}
				}
			}
		}
	}

	return sumValue / cnt;
};

/**
 * Dataset에서 요청한 Record 범위에 대해 Column ID의 값에 대한 평균값이나 Record 별 수식 수행 결과에 대한 평균값을 구하는 Method
 * 
 *  Avg(strColID);
 *  Avg(strColID,nStart);
 *  Avg(strColID,nStart,nCnt);
 *  Avg(strColID,nStart,nCnt,nPivotIndex);
 *  Avg(strExpr);
 *  Avg(strExpr,nStart);
 *  Avg(strExpr,nStart,nCnt);
 *  Avg(strExpr,nStart,nCnt,nPivotIndex);
 *  Avg(strColID,nPivotIndex);
 *  Avg(strColID,nPivotIndex,nStart);
 *  Avg(strColID,nPivotIndex,nStart,nCnt);

 *   
 * @param  strColID       최대값을 구할 Column ID
 * @param  strExpr        Record 별로 수행될 수식.
 * @param  nStart         최대값을 구하고자 하는 시작 Record Index. 시작 Index 0 입니다. [Default Value = 0]
 * @param  nPivotIndex    최대값을 구할 PivotCol의 Index. [Defualt Value = -1]
 * @param  nCnt           최대값을 구할 Record 갯수. [Defualt Value = RowCount]
 * @return                (Decimal)조건에 맞는 Column의 값들의 합계.
 */
DataSet.prototype.avg = function(strExpr, nStart, nCnt, nPivotCol){ 
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.records.length;}
	if (nPivotCol == undefined) {nPivotCol = -1;}

	var includeFiltered = false;
	var strCmpExpr = "";

	return this._Avg(includeFiltered, strCmpExpr, strExpr, nStart, nCnt, nPivotCol);

};
DataSet.prototype.avgNF = function(strExpr, nStart, nCnt, nPivotIndex){ 
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotIndex == undefined) {nPivotIndex = -1;}

	var includeFiltered = true;
	var strCmpExpr = "";

	return this._Avg(includeFiltered, strCmpExpr, strExpr, nStart, nCnt, nPivotIndex);
};

DataSet.prototype.totalAvg = function(strExpr, nStart, nCnt, nPivotIndex){ 
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotIndex == undefined) {nPivotIndex = -1;}


	return this.avgNF(strExpr, nStart, nCnt, nPivotIndex);
};
DataSet.prototype.caseAvg = function(strCmpExpr, strValExpr, nStart, nCnt, nPivotCol, bCountNull){ 
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.records.length;}
	if (nPivotCol == undefined) {nPivotCol = -1;}
	if (bCountNull == undefined) {bCountNull = false;}

	var includeFiltered = false;
	return this._Avg(includeFiltered, strCmpExpr, strValExpr, nStart, nCnt, nPivotCol);
};
DataSet.prototype.caseAvgNF = function(strCmpExpr, strValExpr, nStart, nCnt, nPivotCol, bCountNull){ 
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotCol == undefined) {nPivotCol = -1;}
	if (bCountNull == undefined) {bCountNull = false;}

	var includeFiltered = true;
	return this._Avg(includeFiltered, strCmpExpr, strValExpr, nStart, nCnt, nPivotCol);
};
DataSet.prototype.totalCaseAvg = function(strCmpExpr, strValExpr, nStart, nCnt, nPivotCol, bCountNull){ 
	if (nStart == undefined) {nStart = 0;}
	if (nCnt == undefined) {nCnt = this.buffer.length;}
	if (nPivotCol == undefined) {nPivotCol = -1;}

	return this.caseAvgNF(strCmpExpr, strValExpr, nStart, nCnt, nPivotCol, bCountNull);
};

//-------------------------  ( Select 관련부) -------------------------------------

/**
 * 특정 레코드가 Select 상태가 되도록 설정하는 Method 입니다.
 * Grid에서 Select된 상태를 확인하려면 MultiSelect Property가 True로 설정되어 있어야 합니다.
 * 단, CurRow Property값은 변경되지 않습니다
 * (CurRow Property와 유사 Method나 Property의 값도 변경되지 않습니다.)
 * 
 *  SelectRow(nRow);
 *  SelectRow(nRow,bCheck);
 *   
 * @param  nRow       선택할 레코드 Index
 * @param  bCheck     선택 여부.[Default Value = True]
 * @return            (Boolean)SelectRow Method를 수행하기 전에 상태
 */
DataSet.prototype.selectRow= function(nRow, bCheck){
	if (bCheck == undefined) bCheck = true;
	var wReturn = 0; 
	
	this.records[nRow]._selected = bCheck;
	
	// SelectRow Method가 완료되고 나면 OnColumnChanged Event가 발생합니다.
	// OnColumnChanged Event의 nRow 값만 의미가 있습니다.
	// 상태가 변경되지 않으면 Event가 발생하지 않습니다.
	if (this.FireEvent){
		if (this.hasColumnChangedEvent) {
			var wResult = this.fncColumnChangedEvent(this, nRow, "", "", null);
			// Event에서 false를 return하면 OnColumnChanged Event는 발생하지 않습니다.
			// 이때 SetColumn Method의 Return값은 False 입니다.
			if (typeof(wResult)=="boolean" && !wResult) {
				return false;
			}            
		}     
	}
	
	return wReturn;
};

/**
 * SelectRow Method를 통해서 선택된 Record나 Grid의 MultiSelect Property가  True로 설정되어 있을 때
 * 다중 선택된 Record를 삭제하는 Method 입니다.
 * 
 *  DeleteSelected();
 *  
 * @return            (Integer)삭제된 Record 갯수.
 */
DataSet.prototype.deleteSelected = function(){ 
	var deletedCnt = 0;
	for (var nRow=this.records.length - 1; nRow >= 0;  nRow--){
		if (this.records[nRow]._selected){
			this._deleteOneRecord(nRow);
			deletedCnt++;
		}
	}
	
	if (deletedCnt == 0){
		return 0;
	}

	// 그룹정보 갱신 
	this._ResetGroup();
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();

	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ) this.updateControlList();

    // DeleteSelected Method를 수행하면 OnLoadCompleted Event가 발생합니다. 
	// OnLoadCompleted Event의 nReason값은 8 입니다.
	// Row Position의 값은 변경되지 않습니다. 
	var nErrorCode = [];
	var strErrorMsg = [];
	if (this.hasLoadCompletedEvent) {
		this.fncLoadCompletedEvent(this, nErrorCode, strErrorMsg, 8);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
			return -1;
		}            
	} 

	return deletedCnt;
};

/**
 * SelectRow Method를 통해서 선택된 Record나 Grid의 MultiSelect Property가  True로 설정되어 있을 때
 * 다중 선택된 Record를 삭제하는 Method 입니다.
 * 
 *  getSelect(nRow);
 *  
 * @param  nRow       선택할 레코드 Index
 * @return            (Boolean)특정 레코드가 선택되었는지의 여부 
 */
DataSet.prototype.getSelect = function(nRow){ 
	return (nRow < this.records.length ? this.records[nRow]._selected : false);
};

//-------------------------  ( Filter 관련부) -------------------------------------

/**
 * Dataset에서 조건식에 해당하는 Record만 선택하여 출력하는 Method 입니다.
 * 
 *  Filter(strFilterExpr);
 *  
 * @param  strFilterExpr  수행할 조건식
 * @return                없음
 */
DataSet.prototype.filter = function(strFilterExpr){ 
	if (strFilterExpr.length == 0) return;
	
	this.FilterExpr = strFilterExpr;
 	this.FilterFunction = new Function("return function (nRowNum) { return " + this._UpdateFormulaNF(this.FilterExpr) + "; }")();;
	
	// Filter Method를 수행하면 OnLoadCompleted Event가 발생합니다. 
	// OnLoadCompleted Event의 nReason 값은 6 입니다.
	var nErrorCode = [];
	var strErrorMsg = [];
	if (this.hasLoadCompletedEvent) {
		this.fncLoadCompletedEvent(this, nErrorCode, strErrorMsg, 6);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			alert(strErrorMsg);
			return -1;
		}            
	} 
	
	// Row Position의 값은 0으로 변경됩니다.
	this.Row = 0;
	
	// Filter Method가 호출되면 Dataset을 UnFilter 상태로 만든 후에 Filter를 수행합니다.
	for (var nRow = 0; nRow < this.buffer.length; nRow++){
		if (this.buffer[nRow]._filterd){
			this.buffer[nRow]._filterd = false;
		}
	}

	// Dataset이 포함하고 Record 별로 조건식을 수행해서 TRUE인 경우의 Record만 걸러냅니다.
	// 조건식에서는 Dataset의 Property는 변수처럼 취급됩니다. 
//	var formula = this._UpdateFormulaNF(strFilterExpr);
	for (var nRow = 0; nRow < this.buffer.length; nRow++){
//		if (eval(formula.replace("nRowNum", nRow)) == false){
		///* 2016-03-25 수정 (차중훈) : filter 산식 nRowNum 문자열 전체 변환 수정
//		if (eval(formula.replace(/nRowNum/g, nRow)) == false){
		if (this.FilterFunction(nRow) == false){
			this.buffer[nRow]._filterd = true;
		}
		//*/ 2016-03-25 수정 (차중훈)
	}
	
	// records 재구성 
	this._remakeRecords();

	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
		this._ResetGroup();
	}
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();
	
	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ) this.updateControlList();

	if (this._GroupKey.length > 0){
	    this._refreshGroupCation(true);
	}

	return;
};

/**
 * Filter Method로 Filtering된 Dataset을 원상태로 되돌리는 Method 입니다.
 * 
 *  UnFilter();
 *  
 * @return                (Integer)Filtering으로 보이지 않았던 Record 갯수.
 */
DataSet.prototype.unFilter = function(){ 
	// UnFilter  Method를 호출하기 전에 Filter 되지 않았다면 OnLoadCompleted Event가 발생하지 않습니다.
	// 물론 Row Position의 값도 변경되지 않습니다.
	if (this.FilterExpr.length == 0) return;
	
	// UnFilter Method를 수행하면 OnLoadCompleted Event가 발생합니다. 
	// OnLoadCompleted Event의 nReason 값은 6 입니다.
	var nErrorCode = [];
	var strErrorMsg = [];
	if (this.hasLoadCompletedEvent) {
		this.fncLoadCompletedEvent(this, nErrorCode, strErrorMsg, 6);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
			return -1;
		}            
	} 

	// Row Position의 값은 0 으로 변경됩니다.
	this.Row = 0;
	// 2016-05-12(차중훈) 추가 : 필터 산식 해제합니다.
	this.FilterExpr = "";
    this.FilterFunction = null;

	var cnt = 0;
	for (var nRowNF = 0; nRowNF < this.buffer.length; nRowNF++){
		if (this.buffer[nRowNF]._filterd){
			this.buffer[nRowNF]._filterd = false;
			cnt++;
		}
	}
	
	// records 재구성 
	this._remakeRecords();

	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();

	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
		this._ResetGroup();
	}

	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ) this.updateControlList();
	
	if (this._GroupKey.length > 0){
	    this._refreshGroupCation(true);
	}

	return cnt;
};


/**
 * Dataset의 Record들을 내림차순이나 오름차순으로 정렬하는 Method 입니다.
 * Column ID 자체에 공백문자가 사용 가능하기 때문에 strColList의 Column ID는 공백 없이 입력해야 합니다.
 * 
 *  Sort(strColList);
 *  Sort(strColList,bAscending);
 *  Sort(strColList,bAscending,bBigNull);
 *  Sort(strColList,bAscending,bBigNull,bGroupKey);
 *  
 * @param  strColList  정렬하고자하는 Dataset의 Column List. "ColumnID, ColumnID" 형식, 
 *                     Column ID별 정렬방법방법이 다를 경우 "ColumID:(D 또는 A), ..."   D:Descending, A: Ascending
 * @param  bAscending  오름차순인지 내림차순인지 여부 True:오름차순, Default Value = True
 * @param  bBigNull    NULL값을 값이 있는경우보다 크게 적용할지 여부 True면 NULL값이 값이 있는경우보다 큰것으로 적용[Default Value = False
 * @param  bGroupKey   GroupKey Property가 설정되어 있는 경우 Sort후 다시 Groupping할지 여부
 * @return            (Integer)성공이면 0, 실패하면 -1을 Return 
 */
DataSet.prototype.sort = function(strColList, bAscending, bBigNull, bGroupKey){ 
	if (bAscending == undefined) bAscending = true;
	if (bBigNull == undefined) bBigNull = false;
	if (bGroupKey == undefined) bGroupKey = false;
	
	if (strColList.trim().length==0){
		//alert(getText("message_dataset_016", "소트의 기준이 된는 칼럼 정보가 없습니다."));
		if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_016", "소트의 기준이 된는 칼럼 정보가 없습니다."));
		return -1;
	}
	
	// 그룹정보 갱신 
	if (this._GroupKey.length > 0 && this._strSortColList.length == 0){
		//alert(getText("message_dataset_017", "그룹핑이 된 경우에는 정렬동작을 호출할 수  없습니다."));
		if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_017", "그룹핑이 된 경우에는 정렬동작을 호출할 수  없습니다."));
		return -1;
	}
	
	// sort key 대입
	while (xyZ_$_SortKeys.length > 0) { xyZ_$_SortKeys.pop(); }
	var wArr = strColList.split(",");
	for (var i=0; i < wArr.length; i++){
		if (wArr[i].indexOf(":")>=0){
			var wArr1 = wArr[i].split(":");
			var strKey = wArr1[0].trim();
			var bAscendingGu = (wArr1[1].trim().toUpperCase() == "TRUE");
			xyZ_$_SortKeys[i] = new SortKey(strKey, bAscendingGu);
		} else {
			var strKey = wArr[i].trim();
			xyZ_$_SortKeys[i] = new SortKey(strKey, bAscending);
		}
	}

	this.buffer.sort(function(record1, record2){
				for (var i = 0; i < xyZ_$_SortKeys.length; i++){
					var sortKey = xyZ_$_SortKeys[i];
					var strKey = sortKey.strKey;
					if (sortKey.bAscending){
						if (record1.values[strKey] > record2.values[strKey]){
							return 1;
						} else if (record1.values[strKey] < record2.values[strKey]){
							return -1;
						} else {
							// 같은면 다음키 비교
						}
						
					} else {
						if (record1.values[strKey] < record2.values[strKey]){
							return 1;
						} else if (record1.values[strKey] > record2.values[strKey]){
							return -1;
						} else {
							// 같은면 다음키 비교
						}
					}
				}
				
				return 0;
	});

	this.records.sort(function(record1, record2){
		for (var i = 0; i < xyZ_$_SortKeys.length; i++){
			var sortKey = xyZ_$_SortKeys[i];
			var strKey = sortKey.strKey;
			if (sortKey.bAscending){
				if (record1.values[strKey] > record2.values[strKey]){
					return 1;
				} else if (record1.values[strKey] < record2.values[strKey]){
					return -1;
				} else {
					// 같은면 다음키 비교
				}
				
			} else {
				if (record1.values[strKey] < record2.values[strKey]){
					return 1;
				} else if (record1.values[strKey] > record2.values[strKey]){
					return -1;
				} else {
					// 같은면 다음키 비교
				}
			}	
		}
		
		return 0;
	});

	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ) this.updateControlList();
	
	
    // Sort Method를 수행하면 OnLoadCompleted Event가 발생합니다. 
	// OnLoadCompleted Event의 nReason 값은 5 입니다.
	var nErrorCode = [];
	var strErrorMsg = [];
	if (this.hasLoadCompletedEvent) {
		this.fncLoadCompletedEvent(this, nErrorCode, strErrorMsg, 5);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
			return -1;
		}            
	} 
	
	// Row Position의 값은 0 이 됩니다.
	this.Row = 0;
	return 0;
};

/**
 * Dataset을 구성하는 Const Column, Column, Record들이 표현된 XML을 지정하는 Property.
 * 
 *  Dataset.Contents [=ContentsXML];
 *  
 * @param  ContentsXML  정Dataset의 구성요소들이 표현된 XML. 
 */
DataSet.prototype.setContents = function(contents){
	this.loadXml(contents, true, false);
	return;
};

/**
 * Dataset을 구성하는 Const Column, Column, Record들이 표현된 XML을 지정하는 Property.
 * 참고: http://codingnuri.com/javascript-tutorial/xml-dom-overview.html
 *  LoadXml(xmlData);
 *  LoadXml(xmlData,bClear);
 *  LoadXml(xmlData,bClear,bBinary);
 *  
 * @param  xmlData    오름차순인지 내림차순인지 여부 True:오름차순, Default Value = True
 * @param  bClear     NULL값을 값이 있는경우보다 크게 적용할지 여부 True면 NULL값이 값이 있는경우보다 큰것으로 적용[Default Value = False
 * @param  bBinary    GroupKey Property가 설정되어 있는 경우 Sort후 다시 Groupping할지 여부
 * @return            (Integer)Load한 Record 갯수 
 */
DataSet.prototype.loadXml = function(xmlData, bClear, bBinary){ 
	if (bClear == undefined) bClear = true;
	if (bBinary == undefined) bBinary = false;  // 미결 

	
	var xmlDoc;
	if (window.DOMParser)
	{
	  parser=new DOMParser();
	  xmlDoc=parser.parseFromString(xmlData, "text/xml");
	}
	else // 인터넷 익스플로러
	{
	  xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
	  xmlDoc.async=false;
	  xmlDoc.loadXML(xmlData); 
	} 	
	
	// 기존 정보 클리어
	if (bClear){
		this.clear();
	}
	
	// Column 정보 대입 (ConstColumn 정의) 
	
	
	// colinfo 정보 대입
	var contentsNode = xmlDoc.getElementsByTagName('Contents')[0];
	
	var colInfoNodeList = contentsNode.getElementsByTagName('colinfo');
	for (var i = 0; i < colInfoNodeList.length; i++){
		var colInfoNode = colInfoNodeList[i];
		if (colInfoNode.nodeType != 1) continue;  //Element
		var id = colInfoNode.getAttribute('id');
		var size = (colInfoNode.hasAttribute('size') ? parseInt(colInfoNode.getAttribute('size')) : 256);
		var type = (colInfoNode.hasAttribute('type') ? colInfoNode.getAttribute('type') : "Char");
		
		var colInfo =  new MiColInfo(id, size, type);;

		this._colCount++;
		this.colInfos[id] = colInfo;
		colInfo.index = this._colCount - 1;
	}

	var cnt = 0;
	var recordNodeList = contentsNode.getElementsByTagName('record');
	for (var nRowNF = 0; nRowNF < recordNodeList.length; nRowNF++){
		var recordNode = recordNodeList[nRowNF];
		if (recordNode.nodeType != 1) continue;  //Element
		var record = new MiRecord(this.colInfos);
		record._orignalIndex = nRowNF;

		var colNodeList = recordNode.childNodes;
		for (var i = 0; i < colNodeList.length; i++){
			var colNode = colNodeList[i];
			if (colNode.nodeType != 1) continue;  //Element
			
			var id = colNode.nodeName;
			var value;
			for (var j=0; j < colNode.childNodes.length; j++){
				if (colNode.childNodes[j].nodeType == 3){    // Text
					value = colNode.childNodes[j].nodeValue;
					break;
				}
			}
			
			record.values[id] =  this._getRawValue(id, value);
		}
		
		this.buffer[nRowNF]  = record;
		this.records[nRowNF] = record;
		cnt++;
	}
	
	// Row Position의 값은 0 이 됩니다.
	this.Row = 0;

	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
		this._ResetGroup();
	}
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();

	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ) this.updateControlList();
	
	if (this._GroupKey.length > 0){
	    this._refreshGroupCation(true);
	}

    // Sort Method를 수행하면 OnLoadCompleted Event가 발생합니다. 
	// OnLoadCompleted Event의 nReason 값은 0 입니다.
	var nErrorCode = [];
	var strErrorMsg = [];
	if (this.hasLoadCompletedEvent) {
		this.fncLoadCompletedEvent(this, nErrorCode, strErrorMsg, 0);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
			return 0;
		}            
	} 
	
	return cnt;
};


/**
 *	loadJson, appendJson, updateByJson 함수에서 시트를 제외한 나머지 컨트롤을 채울 때 사용하는 내부함수
 */
/**
 * @description	미결
 * @param	{string}	varRow
 * @return  {undefined}
 * @example	미결
 */
DataSet.prototype._updateControlSets = function(varRow){
	if (this.getRowCount() == 0) return ;
	if (varRow == undefined) varRow = this.Row;
	
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlType == "Sheet" || bindInfo.controlType == "lstSheet") continue;
		
		var record = this.records[varRow];
		var ctl = controls[bindInfo.controlName];
		ctl.passEvent = true;
		if (bindInfo.controlType == "ComboBox" || bindInfo.controlType == "List1") {
			if ((ctl.listSaveType == LISTBOX_SAVE_MULTI  && ctl.listType == LISTBOX_TYPE_DATASELECT)) continue;
			if (bindInfo.colId.length > 0){
				ctl.setText(record.values[bindInfo.colId]);
			} else {
				ctl.setValue(record.values[bindInfo.colId_value]);
			}
		} else if (bindInfo.controlType == "TextBox" || 
				   bindInfo.controlType == "CheckBox" || 
				   bindInfo.controlType == "Link" || 
				   bindInfo.controlType == "IFrame" || 
				   bindInfo.controlType == "ProgressBar1") {
			ctl.setValue(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "OptionBox") {
			//ctl.setValue(ctl.matchUpValue == record.values[bindInfo.colId] ? 1 : 0);
			controls[ctl.optionGroupName + ""].setValue(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "Label" ) {
			ctl.setCaption(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "PictureBox" ) {
			ctl.setPicture(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "WebEdit" ) {
			ctl.setHTML(record.values[bindInfo.colId]);
		} else if (bindInfo.controlType == "FlashPlayer" ) {
			ctl.flashUrl = record.values[bindInfo.colId]; 
			ctl.callMovie();
		} else if (bindInfo.controlType == "Sheet" ) {
		} else if (bindInfo.controlType == "lstSheet" ) {
		} else {
			ctl.setValue(record.values[bindInfo.colId]);
		}
		ctl.passEvent = false;
	}
};

/**
 * Dataset을 구성하는 Const Column, Column, Record들이 표현된 loadJson을 지정하는 Property.
 * 
  {
      "rowCount":10,
      "outDsList":"SEL1",
      "fieldList":[“DEPT_NM”, ” DEPT_NO”, ” NO”, ” NM”],
      "recordList":
          [
            {"DEPT_NM":"망원현대점","DEPT_NO":"202767","NO":"335512","NM":"2.5RT천정형"},
            {"DEPT_NM":"망원현대점","DEPT_NO":"202767","NO":"335512","NM":"2.5RT천정형"}
          ]
  }
 * 
 *  LoadJson(xmlData);
 *  
 * @param  jsonObject  오름차순인지 내림차순인지 여부 True:오름차순, Default Value = True
 * @return             (Integer)Load한 Record 갯수 
 */
DataSet.prototype.loadJson = function(jsonObject){ 
	// 기존 정보 클리어
	//this.clearData();
	
	while(this.records.length > 0) {
		this.records.pop();
	}
	if (this.buffer.length > 0){
		for(var i = this.buffer.length - 1; i >= 0 ; i--) {
			this.buffer[i].clear();
			this.buffer.pop();
		}
	}
	if (this.OriginBuffer.length > 0){
		for(var i = this.OriginBuffer.length - 1; i >= 0 ; i--) {
			this.OriginBuffer[i].clear();
			this.OriginBuffer.pop();
		}
	}
	this.Row= -1; 
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();
	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ) this.updateControlList();
	if( this.instantUpdateControl ) this._clearControlData();
	// 기존 정보 클리어
	
	this.appendJson(jsonObject);
	
	if( this.instantUpdateControl ) this.updateControlRowData(0);
	
	return;
};

/**
 * Dataset을 구성하는 Const Column, Column, Record들이 표현된 loadJson을 지정하는 Property.
 * 
  {
      "rowCount":10,
      "outDsList":"SEL1",
      "fieldList":[“DEPT_NM”, ” DEPT_NO”, ” NO”, ” NM”],
      "recordList":
          [
            {"DEPT_NM":"망원현대점","DEPT_NO":"202767","NO":"335512","NM":"2.5RT천정형"},
            {"DEPT_NM":"망원현대점","DEPT_NO":"202767","NO":"335512","NM":"2.5RT천정형"}
          ]
  }
 * 
 *  appendJson(xmlData);
 *  
 * @param  jsonObject  오름차순인지 내림차순인지 여부 True:오름차순, Default Value = True
 * @return             (Integer)Load한 Record 갯수 
 */
DataSet.prototype.appendJson = function(jsonObject){ 
	
	var startRow = this.buffer.length;
	var startRowNF = this.records.length;
	var ndx = 0;
	// 줄수
	var cnt = 0;

	// 데이터 대입
	var recordList = jsonObject.recordList;
	var nRow = startRow;
	var nRowNF = startRowNF;
	
	for (var ndx = 0; ndx < recordList.length; ndx++){
		var JsonData = recordList[ndx];
		
		var record = new MiRecord(this.colInfos);
		record._orignalIndex = nRowNF;
		
		for (var key in JsonData){
			if( typeof(JsonData[key]) == "function" ) continue;
			var key0 = (key.toUpperCase() == "ID$" ? key.substring(0, key.length -1) : key);
			
			for (var wKey in this.colInfos){
				if( typeof(this.colInfos[wKey]) == "function" ) continue;
				
				if (wKey.toUpperCase() == key0.toUpperCase()){
				    record.values[wKey] =  this._getRawValue(wKey, JsonData[key]);	
				}
			}
		}
		
		this.buffer[nRowNF++]  = record;
		this.records[nRow++] = record;
		cnt++;
	}
	
	//CanRowPosChange 이벤트 로직 호출 / Row : -1 -> 0
	if (this.FireEvent){
		if (this.hasCanRowPosChangeEvent && cnt > 0) {
			var wResult = this.fncCanRowPosChangeEvent(this, -1, 0);  
			if (typeof(wResult)=="boolean" && !wResult) {
				return;
			}
		}
	}
	
	// Row Position의 값은 0 이 됩니다.
	this.Row = 0;

	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
		this._ResetGroup();
	}
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();

	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ) this.updateControlList();

	if (this._GroupKey.length > 0){
	    this._refreshGroupCation(true);
	}

    // Sort Method를 수행하면 OnLoadCompleted Event가 발생합니다. 
	// OnLoadCompleted Event의 nReason 값은 0 입니다.
	var nErrorCode = [];
	var strErrorMsg = [];
	if (this.hasLoadCompletedEvent) {
		this.fncLoadCompletedEvent(this, nErrorCode, strErrorMsg, 0);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
			return 0;
		}            
	} 
	
	if (jsonObject.pageSize == 0 && cnt != jsonObject.rowCount){
		alert(getText("message_dataset_018", "줄수가 {0}이어야 하는데 실제 데이터 수는 {1}입니다", [jsonObject.rowCount, cnt]));
	}
	
	//RowPosChange 이벤트 로직 호출 / Row : -1 -> 0
	if (this.FireEvent){
		if (this.hasRowPosChangedEvent && cnt > 0) {
			this.fncRowPosChangedEvent(this, -1, this.Row);
		}
	}
	
	return cnt;
};

/**
 * @description	미결
 * @param	{string}	jsonObject
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.updateByJson = function(jsonObject){ 

	// 데이터 대입
	var recordList = jsonObject.recordList;
	if (recordList.length == 0) return;
	if (this.records.length == 0) return;
	if (this.Row < 0) return;
	
	// 해당줄 찾기
	var nRow = this.Row;
	var nRowNF = this.getRowIndexNF(nRow);
	
	var JsonData = recordList[0];
	
	var record = new MiRecord(this.colInfos);
	record._orignalIndex = nRowNF;
	
	for (var key in JsonData){
		if( typeof(JsonData[key]) == "function" ) continue;
		var key0 = (key.toUpperCase() == "ID$" ? key.substring(0, key.length -1) : key);
		
		for (var wKey in this.colInfos){
			if( typeof(this.colInfos[wKey]) == "function" ) continue;
			
			if (wKey.toUpperCase() == key0.toUpperCase()){
				record.values[wKey] =  this._getRawValue(wKey, JsonData[key]);	
			}
		}
	}
	
	this.buffer[nRowNF]  = record;
	this.records[nRow] = record;

	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
		this._ResetGroup();
	}
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();

	// 관련 시트데이터 수정
	if( this.instantUpdateControl ) this.updateControlRowData(this.records[nRow]); // this.updateControlRowData(nToRow);

	// 연결된 시트나 콤보를 리프래시함  (updateControlRowData 로 수정)
	// this.updateControlList();

    // Sort Method를 수행하면 OnLoadCompleted Event가 발생합니다. 
	// OnLoadCompleted Event의 nReason 값은 0 입니다.
	var nErrorCode = [];
	var strErrorMsg = [];
	if (this.hasLoadCompletedEvent) {
		this.fncLoadCompletedEvent(this, nErrorCode, strErrorMsg, 0);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
			return 0;
		}            
	} 
	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
		if( this.instantUpdateControl ) this._refreshGroupCation(true);
	}
	
	//RowPosChange 이벤트 로직 호출 / Row : -1 -> this.Row
	if (this.FireEvent){
		if (this.hasRowPosChangedEvent) {
			this.fncRowPosChangedEvent(this, -1, this.Row);
		}
	}
	
	return cnt;
};

/**/
/**
 * @description	미결
 * @param	{string}	jsonObject
 * @return  {void}
 * @example	미결
 */
DataSet.prototype.loadJsonQry = function(jsonObject){ 
	// 기존 정보 클리어
	//this.clearData();
	while(this.records.length > 0) {
		this.records.pop();
	}
	if (this.buffer.length > 0){
		for(var i = this.buffer.length - 1; i >= 0 ; i--) {
			this.buffer[i].clear();
			this.buffer.pop();
		}
	}
	if (this.OriginBuffer.length > 0){
		for(var i = this.OriginBuffer.length - 1; i >= 0 ; i--) {
			this.OriginBuffer[i].clear();
			this.OriginBuffer.pop();
		}
	}
	this.Row= -1; 
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();
	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ) this.updateControlList();
	if( this.instantUpdateControl ) this._clearControlData();
	// 기존 정보 클리어
	
	this.appendJsonQry(jsonObject);
	
	if( this.instantUpdateControl ) this.updateControlRowData(0);
	
	return;
};

/**
 * @description	미결
 * @param	{string}	jsonObject
 * @return  {number}
 * @example	미결
 */
DataSet.prototype.appendJsonQry = function(jsonObject){ 
	
	var startRow = this.buffer.length;
	var startRowNF = this.records.length;
	var ndx = 0;
	// 줄수
	var cnt = 0;

	// 데이터 대입
//	var recordList = jsonObject.recordList;
	var recordList = (typeof jsonObject.recordList != "undefined") ? jsonObject.recordList : jsonObject;
	var nRow = startRow;
	var nRowNF = startRowNF;
	
	for (var ndx = 0; ndx < recordList.length; ndx++){
		var JsonData = recordList[ndx];
		
		var rowObject = JSON.parse(JSON.stringify(JsonData));
		if( typeof rowObject.__STATE__ == "undefined" ){
			rowObject.__STATE__ = null;
			delete rowObject.__STATE__;
		}
		
		var record = new MiRecord(this.colInfos);
		record._orignalIndex = nRowNF;
		if( typeof JsonData.__STATE__ != "undefined" )
			record._$uid = JsonData.__STATE__.rowId;
		record.values = rowObject;
		
		this.buffer[nRowNF++]  = record;
		this.records[nRow++] = record;
		cnt++;
	}
	
	//CanRowPosChange 이벤트 로직 호출 / Row : -1 -> 0
	if (this.FireEvent){
		if (this.hasCanRowPosChangeEvent && cnt > 0) {
			var wResult = this.fncCanRowPosChangeEvent(this, -1, 0);  
			if (typeof(wResult)=="boolean" && !wResult) {
				return;
			}
		}
	}
	
	// Row Position의 값은 0 이 됩니다.
	this.Row = 0;

	// 그룹정보 갱신 
	if (this._GroupKey.length > 0){
		this._ResetGroup();
	}
	
	// 데이터유뮤에 따른 콘트롤 블록킹
	this.setBlocking();

	// 연결된 시트나 콤보를 리프래시함 
	if( this.instantUpdateControl ){
		if (this._GroupKey.length <= 0){
			this.updateControlList();			
		}
	}

	if (this._GroupKey.length > 0){
		if( this.instantUpdateControl ) this._refreshGroupCation(true);
	}

    // Sort Method를 수행하면 OnLoadCompleted Event가 발생합니다. 
	// OnLoadCompleted Event의 nReason 값은 0 입니다.
	var nErrorCode = [];
	var strErrorMsg = [];
	if (this.hasLoadCompletedEvent) {
		this.fncLoadCompletedEvent(this, nErrorCode, strErrorMsg, 0);  //  "obj", "nErrorCode", "strErrorMsg", "nReason"
		if (nErrorCode.length > 0 && nErrorCode[0] > 0) {
			alert("ErrCode: " + nErrorCode[0] + "\n" + (strErrorMsg > 0 ? getText("message_dataset_002", "내용: {0}", [strErrorMsg[0]]) : ""));
			return 0;
		}            
	} 
	
	if (jsonObject.pageSize == 0 && cnt != jsonObject.rowCount){
		alert(getText("message_dataset_018", "줄수가 {0}이어야 하는데 실제 데이터 수는 {1}입니다", [jsonObject.rowCount, cnt]));
	}
	
	//RowPosChange 이벤트 로직 호출 / Row : -1 -> 0
	if (this.FireEvent){
		if (this.hasRowPosChangedEvent && cnt > 0) {
			this.fncRowPosChangedEvent(this, -1, this.Row);
		}
	}
	
	return cnt;
};

/**/

/**/
/**
 * @description	미결
 * @param	{string}	selectedOption
 * @return  {string}
 * @example	미결
 */
DataSet.prototype.getJsonStrBatch = function( selectedOption ){
	if( typeof selectedOption == "undefined" ) selectedOption = "N";
	
	var optionMatchs = {"N": 0, "U": 1, "A": 2};
	var flagMatchs	 = {"Insert": "I", "Update": "U", "Delete": "D", "Normal" : "N"};
	
	var sendOption = optionMatchs[selectedOption];
	var str = "";
	var recordstr = "";
	var val = "";
	
	var i = 0;
	var record = null;
	var key = "";
	
	//sendOption : 1(수정), 2(전체)인 경우에 OriginBuffer의 삭제된(Delete) 레코드를 전송
	if(sendOption > 0){
		for (i = 0; i < this.OriginBuffer.length; i++){
			record = this.OriginBuffer[i];
			
			if (record.RowType == 'Logical') continue;
			if (record.RowType != 'Delete') continue;
			
			recordstr = "";
			str += (("" + str).length > 0 ? ", {" : "{");

			for(key in record.values){
				val = record.values[key];
				
				if( typeof val == "function" ) continue;
				if( typeof val == "object" ) continue;
				if( typeof val == "string" ) val = val.replace(/\n/g, "\\n");
				
				recordstr += (("" + recordstr).length > 0 ? ", " : "") + ("\"" + key + "\": ") + ("\"" + ((val == null || typeof val == "undefined") ? this._getRawValue(key, val) : val) + "\"");
			}
			
			recordstr += ", \"IUDFlag\": \"" + flagMatchs[record.RowType] + "\"";
			
			str += recordstr;
			str += "}";
		}
	}
	//sendOption : 0(기본), 2(전체)인 경우에 records의 일반(Normal) 레코드를 전송하고 1(수정), 2(전체)인 경우에 records의 수정된(Update) 레코드를 전송
	for (i = 0; i < this.records.length; i++){
		record = this.records[i];
		
		if (record.RowType == 'Logical') continue;
		if (sendOption == 1 && record.RowType == 'Normal') continue;
		
		recordstr = "";
		str += (("" + str).length > 0 ? ", {" : "{");
		
		for(key in record.values){
			val = record.values[key];
			
			if( typeof val == "function" ) continue;
			if( typeof val == "object" ) continue;
			if( typeof val == "string" ) val = val.replace(/\n/g, "\\n");
			
			recordstr += (("" + recordstr).length > 0 ? ", " : "") + ("\"" + key + "\": ") + ("\"" + ((val == null || typeof val == "undefined") ? this._getRawValue(key, val) : val) + "\"");
		}
		
		recordstr += ", \"IUDFlag\": \"" + ((sendOption > 0) ? flagMatchs[record.RowType] : "N") + "\"";
		
		str += recordstr;
		str += "}";
	}
	
	str = "[" + str + "]";
	
	return str;
//	return encodeURIComponent( str );
};
/**/

/**/
/**
 * @description	미결
 * @param	{string}	selectedOption
 * @return  {string}
 * @example	미결
 */
//DataSet.prototype.getJsonData = function(){
//	var jsonDataStr = null;
//	var controlName = null;
//	var control = null;
//	var mappingInfo = null;
//	var columns = null;		var column = null;		var columnCount = 0;
//	var records = null;		var record = null;		var recordCount = 0;
//	var dataRows = null;	var dataRow = null;
//	var colId = null;		var value = null;
//	var i = 0, j = 0;
//	
//	for(controlName in controls){
//		control = controls[controlName];
//		
//		//함수인 경우 처리 안함
//		if( typeof control == "function" ){
//			controlName = null; control = null; continue;
//		}
//		//연결된 데이터셋 속성이 없는 경우에도 처리 안함
//		if( typeof control.linkedDataset == "undefined" ){
//			controlName = null; control = null; continue;
//		}
//		//연결된 데이터셋이 자신(데이터셋)과 다르면 처리 안함
//		if( control.linkedDataset !== this ){
//			controlName = null; control = null; continue;
//		}
//		
//		mappingInfo = {};
//		dataRows = [];
//		
//		//데이터셋-시트 컬럼 매핑 정보 생성
//		columns = control.columns;
//		columnCount = columns.length;
//		for(i = 0; i < columnCount; i++, column = null){
//			column = columns[i];
//			//컬럼의 linkedColumn 속성이 있는 경우에만 매핑정보를 생성
//			if( typeof column.linkedColumn == "string" && column.linkedColumn.trim().length > 0 )
//				mappingInfo[column.colId] = column.linkedColumn;
//		}
//		columns = null;
//		
//		//삭제 레코드 생성
//		records = control.dataSet.deletedData;
//		recordCount = records.length;
//		for(i = 0; i < recordCount; i++, j++, record = null, dataRow = null){
//			record = records[i];
//			dataRow = dataRows[j] = {};
//			
//			for(colId in mappingInfo){
//				value = record[colId];
//				dataRow[mappingInfo[colId]] = ("" + value).replace(/\n/g, "\\n");
//				value = null; colId = null;
//			}
//			
//			dataRow["IUDFlag"] = (record.__STATE__.updateGu == "E") ? "D" : record.__STATE__.updateGu;
//		}
//		records = null;
//		//삭제 외 레코드 생성
//		records = control.dataSet.data;
//		recordCount = records.length;
//		for(i = 0; i < recordCount; i++, j++, record = null, dataRow = null){
//			record = records[i];
//			dataRow = dataRows[j] = {};
//			
//			for(colId in mappingInfo){
//				value = record[colId];
//				dataRow[mappingInfo[colId]] = ("" + value).replace(/\n/g, "\\n");
//				value = null; colId = null;
//			}
//			
//			dataRow["IUDFlag"] = (record.__STATE__.updateGu == "X") ? "N" : record.__STATE__.updateGu;
//		}
//		records = null;
//		
//		//JSON 데이터 문자열로 변환
//		jsonDataStr = JSON.stringify(dataRows);
//		
//		//메모리 해제
//		dataRows.clear(); dataRows = null;
//		mappingInfo = null;
//		control = null;
//		controlName = null;
//	}
//	
//	if (jsonDataStr == null) {
//		jsonDataStr = this.getJsonStrBatch("A");
//	}
//	
//	return jsonDataStr;
//};

DataSet.prototype.getJsonData = function(){
	return this.getJsonStrBatch("A");
};
/**/

/**
 * Dataset의 내용을 XML 형식으로 저장해서 문자열로 얻어내는 Method
 * 참고: http://codingnuri.com/javascript-tutorial/xml-dom-overview.html
 *  SaveXML();
 *  SaveXML(strID);
 *  SaveXML(strID,strSaveType);
 *  SaveXML(strID,strSaveType,bHeader);
 *  SaveXML(strID,strSaveType,bHeader,codepage);

 *  
 * @param  strID    저장할때 사용할 Dataset ID. ID가 없거나 생략하면 현재 Dataset의 ID.[Default Value = ""]
 * @return          (String)Dataset의 내용을 변환한 문자열 
 */
DataSet.prototype.saveXML = function(strID){ 
	if (strID == undefined) strID = this.id;
	
	var xmlDoc;
	var text = "<dataset id='" + strID + "'></dataset>";
	
	if (window.DOMParser)
	{
		parser=new DOMParser();
		xmlDoc=parser.parseFromString(text,"text/xml");
	}
	else // 인터넷 익스플로러
	{
		xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
		xmlDoc.async=false;
		xmlDoc.loadXML(text); 
	} 	
	var datasetNode = xmlDoc.getElementsByTagName('dataset')[0];

	var contentNode = xmlDoc.createElement('Contents');
	datasetNode.appendChild(contentNode);

	for (var key in this.colInfos){
		var colInfo = this.colInfos[key];
		if( typeof(colInfo) == "function" ) continue;
		
		var colinfoNode = xmlDoc.createElement('colinfo');
		contentNode.appendChild(colinfoNode);
		
		var attNode = xmlDoc.createAttribute('id');
		attNode.nodeValue = colInfo.id;
		colinfoNode.setAttributeNode(attNode);
		
		attNode = xmlDoc.createAttribute('size');
		attNode.nodeValue = colInfo.size;
		colinfoNode.setAttributeNode(attNode);
		
		
		attNode = xmlDoc.createAttribute('type');
		attNode.nodeValue = colInfo.type;
		colinfoNode.setAttributeNode(attNode);
	}
	
	for (var i = 0; i < this.records.length; i++){
		var record = this.records[i];
		var recordNode = xmlDoc.createElement('record');
		contentNode.appendChild(recordNode);
		
		for (var key in record.values){
			if( typeof(record.values[key]) == "function" ) continue;
			var dataNode = xmlDoc.createElement(key);
			recordNode.appendChild(dataNode);
			
			var textNode = xmlDoc.createTextNode(record.values[key]);
			dataNode.appendChild(textNode);
		}
	}
	
	// 미결   파일로 저장 부분
	
	var wReturn = (new XMLSerializer()).serializeToString(xmlDoc);
	
	return wReturn;
};

/**
 * Dataset의 내용을 JSON STRING 형식으로 저장해서 문자열로 얻어내는 Method
 * 
       [
			{
				"VARCHAR_TMP1":"20151212",
				"VARCHAR_TMP2":"20151212",
				"flagwizware":"N"
			}
       ]
 * 
 *  saveJson();
 *  
 * @return          (String)Dataset의 내용을 변환한 문자열 
 */
DataSet.prototype.getJsonStr = function( selectedOption ){
	if (selectedOption == undefined) selectedOption = 0 ;
	
	var flagMatchs = {'Insert': 'I', 'Update': 'U', 'Delete': 'D', 'Normal' : 'N'};  
	
	var text = "";
	var str = "";
	var value = "";
	
	//selectedOption : 1(수정) 또는 2(전체) 인 경우에만 OriginBuffer 의 삭제된(Delete) 레코드를 전송
	if(selectedOption > 0){
		for (var i = 0; i < this.OriginBuffer.length; i++){
			var record = this.OriginBuffer[i];
			if (record.RowType == 'Logical') continue; 
			if (record.RowType != 'Delete') continue; 
			
			//if (i > 0 || this.records.length > 0 ){text += "			     ,\n";}
			if (text.length > 0){text += "			     ,\n";}
			text += "			    {\n";
			str = ""; value = "";
			for (var key in record.values){
				if( typeof(record.values[key]) == "function" ) continue;
				if (str.length > 0){str += ",\n";}
				value = record.values[key];
				value = value.replace(/\\/g, "\\\\").replace(/\\/g, "<BS>");
				text += "			        \"" + key + "\": \"" + encodeURIComponent( (value == undefined || value == null) ? this._getRawValue(value) : value ) + "\",\n";
			}
			text += "			        \"flagwizware\": \"" + flagMatchs[record.RowType] + "\"\n";
			text += "			    }\n";
		}		
		
		text += str;
	}
	
	for (var i = 0; i < this.records.length; i++){
		var record = this.records[i];
		if (record.RowType == 'Logical') continue; 
		if (selectedOption == 1 && record.RowType == 'Normal') continue; 
		
		if (text.length > 0){text += "			     ,\n";}
		text += "			    {\n";
		str = ""; value = "";
		for (var key in record.values){
			if( typeof(record.values[key]) == "function" ) continue;
			if (str.length > 0){str += ",\n";}
			value = record.values[key];
			value = value.replace(/\\/g, "\\\\").replace(/\\/g, "<BS>").replace(/\"/g, "\\\"");
			text += "			        \"" + key + "\": \"" + encodeURIComponent( (value == undefined || value == null) ? this._getRawValue(value) : value ) + "\",\n";
		}
		//
		if(selectedOption > 0){		text += "			        \"flagwizware\": \"" + flagMatchs[record.RowType] + "\"\n";		}
		else{						text += "			        \"flagwizware\": \"N\"\n";										}
		text += "			    }\n";
	}
//	//selectedOption : 1(수정) 또는 2(전체) 인 경우에만 OriginBuffer 의 삭제된(Delete) 레코드를 전송
//	if(selectedOption > 0){
//		for (var i = 0; i < this.OriginBuffer.length; i++){
//			var record = this.OriginBuffer[i];
//			if (record.RowType == 'Logical') continue; 
//			if (record.RowType != 'Delete') continue; 
//			
//			//if (i > 0 || this.records.length > 0 ){text += "			     ,\n";}
//			if (text.length > 0){text += "			     ,\n";}
//			text += "			    {\n";
//			str = ""; value = "";
//			for (var key in record.values){
//				if( typeof(record.values[key]) == "function" ) continue;
//				if (str.length > 0){str += ",\n";}
//				value = record.values[key];
//				value = value.replace(/\\/g, "\\\\").replace(/\\/g, "<BS>");
//				text += "			        \"" + key + "\": \"" + encodeURIComponent( (value == undefined || value == null) ? this._getRawValue(value) : value ) + "\",\n";
//			}
//			text += "			        \"flagwizware\": \"" + flagMatchs[record.RowType] + "\"\n";
//			text += "			    }\n";
//		}		
//		
//		text += str;
//	}
	
	return text;
};

/**
 * Dataset의 내용을 탭으로 구분된 STRING 형식으로 저장해서 문자열로 얻어내는 Method
 * 첫줄은 필드 명 다음줄부턴 데이터
      ACCT_YMD^t ACCT_NO^t VEND_NM^t AMT^t AMT_ITEM^t VEND_CD^t BIZMAN_NO^t^n
      1^t 2^t^t 3^t 5^t 6^t^n
      4^t 5^t^t 2^t 5^t 8^t^n
      9^t 2^t^t 1^t 5^t 6^t^n
 
 *  getTabbedStr();
 *  
 * @return          (String)Dataset의 내용을 변환한 문자열 
 */
DataSet.prototype.getTabbedStr = function(){ 
	
	var text = "";
	var arrKeys = []; var keyIndex = 0;
	for (var key in this.colInfos){
		if(typeof this.colInfos[key] == "function") continue;
//	    text += key + "^t";
//	    arrKeys[keyIndex++] = key;
		arrKeys[this.colInfos[key].index] = key;
	}
//	text += "^n/\"";
	text += "\\\"";
	
	for (var i = 0; i < this.records.length; i++){
		var record = this.records[i];
		if (record.RowType == 'Logical') continue; 
		
		for (var keyIndex=0; keyIndex < arrKeys.length; keyIndex++){
		    var key = arrKeys[keyIndex];
		    text += (record.values[key] + "^t");
		}
		
	    //text += key + "^n";
		text += "^n";
	}
	text += "\\\"";
	
	text = ((text + "").replace(/&/gi, "＆")).replace(/\?/gi, "？");
	text = ((text.replace(/\\\"/g, "<$DBLQ$>")).replace(/\"/g, "\\\"")).replace(/<\$DBLQ\$>/g, "\\\"");
	
	return text;
};


//*** Group ****         *** Group ****         *** Group ****         *** Group ****         *** Group ****         *** Group ****        
DataSet.prototype.getRowLevel = function(nRow){	
	nRow = (nRow == undefined ? this.Row : nRow);
	return this.records[nRow]._RowLevel;
};
DataSet.prototype.getRangeStart = function(nRow){	
	nRow = (nRow == undefined ? this.Row : nRow);
	return this.records[nRow].rangeStart;
};
DataSet.prototype.getRangeCount = function(nRow){	
	nRow = (nRow == undefined ? this.Row : nRow);
	return this.records[nRow].rangeCount;
};


DataSet.prototype.getGroupKey = function(){ return this._GroupKey;};

/**
 * @description	미결
 * @param	{string}	groupKey
 * @return  {void}
 * @example	미결
 */
DataSet.prototype.setGroupKey = function(groupKey){
	this._GroupKey = groupKey;
	
	
	// 그룹키 레코드를 만든다 
	this._ResetGroup();
	
	if( this.instantUpdateControl ) this.updateControlList();
	
	if (this._GroupKey.length > 0){
	    this._refreshGroupCation(true);
	}

	// this._refreshPivot();
	return;
};

/**
 * 그룹키에 의존하지 않고 강제로 소팅할 경우에 사용한다 
 * Column ID 자체에 공백문자가 사용 가능하기 때문에 strColList의 Column ID는 공백 없이 입력해야 합니다.
 * 
 *  setSortColListOfGrouping(strSortColList);
 *  
 * @param  strSortColList  정렬하고자하는 Dataset의 Column List. "ColumnID, ColumnID" 형식, 
 *                         Column ID별 정렬방법방법이 다를 경우 "ColumID:(D 또는 A), ..."   D:Descending, A: Ascending
 */
 DataSet.prototype.setSortColListOfGrouping = function(strSortColList){
	this._strSortColList = strSortColList;
	return;
};


// 로지컬 데이터를 다시 만든다 
 /**
  * @description	미결
  * @return  {void}
  * @example	미결
  */
DataSet.prototype._ResetGroup = function(){
	if(this._GroupKey.length == 0) return;
	// STEP 1: 사전작업
	// 1-1: _jsonGroupKey가 생성되지 않았으면 생성한다.
	this._jsonGroupKey.clear();
	
	var levelKeyArr = this._GroupKey.split(",");
	for (var i=0; i < levelKeyArr.length; i++){
		var levelKey = levelKeyArr[i];
		if (levelKey.length == 0) continue;
		
		if (levelKey.indexOf(":") >= 0){
			this._jsonGroupKey[i] = levelKey.split(":");
		} else {
			this._jsonGroupKey[i] = levelKey;
		}
	}
	
	for (var key in this.colInfos){
		if( typeof(this.colInfos[key]) == "function" ) continue;
		this.colInfos[key]._isGroupKeyField = false;
	}
	for (var i=0; i < this._jsonGroupKey.length;i++){
		var varKeyName = this._jsonGroupKey[i];
		if (varKeyName instanceof Array) {
			for (var j=0; j < varKeyName.length;j++){
				var colId = varKeyName[j];
				this.colInfos[colId]._isGroupKeyField = true;
			}
			
		} else {
			var colId = this._jsonGroupKey[i];
			this.colInfos[colId]._isGroupKeyField = true;
		}
	}
	
	// 1-2: 그룹키 집계기준을 메모한다
	for (var key in this.colInfos) {
		var colInfo = this.colInfos[key];
		if( typeof(colInfo) == "function" ) continue;
		
		var colId = key;
		var sumMethod = colInfo.sumMethod;
		
		var posOfColon = sumMethod.indexOf(":");
		if (posOfColon < 0) continue;
		
		// _sumFormula를 미리 만들었거나 없는 경우가 아니면 sumMethod를 둘로 분리한다
		colInfo.sumMethod   = sumMethod.substring(0,posOfColon);
		colInfo._sumFormula = "";
		colInfo._sumField = "";
		colInfo._sumText = "";


		var sumFormula = sumMethod.substring(posOfColon + 1).trim();
		
		if (sumFormula == colId) { 
			// 칼럼 아이디와 같으면 디폴트 상태 
		
		} else if (typeof this.colInfos[sumFormula] != "undefined") { 
			// 칼럼 아이디중의 하나인 경우 	
			colInfo._sumField = sumFormula;
			
		} else if (sumFormula.indexOf("=") == 0) {
			// "=" 로 시작하면 산식임
			sumFormula = sumFormula.substring(sumFormula.indexOf("=") + 1);
			colInfo._sumFormula = sumFormula;
			self[this.id + "_" + colId + "_sumFunction"] = new Function("return " + "function (nRowNum, rowLevel) { return " + this._UpdateFormula(sumFormula) + "; }")();
		} else {
			// 나머지는 "text:캡션"인 경우임
			colInfo._sumText = sumFormula;
		}
		
	}
	
	for (var i=0; i < this._jsonGroupKey.length;i++){
		var varKey = this._jsonGroupKey[i];

		// 디폴트로 colId, sumMethod를 채윤다
		var colId = (varKey instanceof Array ? varKey[0] : varKey);
		var sumMethod = this.colInfos[colId].sumMethod;

		// 배열인 경우 하위키 루핑 돌며 sumMethod를 찾는다, gk위키중 맨 마지막의 sumMethod를 활용한다.
		if (varKey instanceof Array){
			// 하위키중 하나라도 sumMethod가 있으면 그메서드를 적용하고 
	        // 하위키 모두 있으면 나중에 나온것을 적용한다.
			for (var nSubIndex = 0; nSubIndex < varKey.length; nSubIndex++){
				var colId1 = varKey[nSubIndex];
				if (colId1 == "") continue;
				
				if (this.colInfos[colId1].sumMethod.trim().length != 0){
					colId = colId1;
					sumMethod = this.colInfos[colId1].sumMethod;
				}
			}
		}

		// sumMethod 필드가 비었으면 집계내지 않는다.
		var nGroupNdx = i + 1; 
		this._needGroupKey[nGroupNdx] = (sumMethod.length != 0);
	}

	// 1-3. 먼저 Logical rowType을 가진 데이터를 전부 지운다.
	//      그룹키가 없어도 있다 없어 지는 경우가 있으므로 두어야 한다 
	for (var nRowNF = this.buffer.length - 1; nRowNF >= 0; nRowNF--){
		var record = this.buffer[nRowNF];
		if (record.RowType == "Logical"){
			record.clear(); record = null;
			this.buffer.splice(nRowNF, 1);
			
		} else {
			record._jsonGroupKeyValue = this._makeGroupKey(record);
		}
	}
	
	// 1-4 beffer 배열로 records 배열 재구성 
	// 그룹키가 없으면 아래 로직들은 돌릴 필요가 없다.
	if (this._GroupKey.length == 0){
		// records 재구성 
		this._remakeRecords();
		return;
	}
	
	// 1-5 데이터 없는 경우  
	// 데이터가 없는 상태이면 아래 작업을 할 필요가 없다.
	if (this.records.length == 0){
		// records 재구성 
		return;
	}
	
	// STEP 2. 데이터 소팅
    if (this._strSortColList.length == 0){
		// 2-1 그룹키를 기준으로 소팅 
		this.buffer.sort(function(record1, record2){
//			return compareGroupKey(record1._jsonGroupKeyValue, record2._jsonGroupKeyValue);
			return compareRecordGroupKeyByGroupKey(record1._jsonGroupKeyValue, record2._jsonGroupKeyValue);	
		});	
    } else {
    	this.sort(this._strSortColList);
    }

	// 2-1 소팅된 버퍼데이터 배열로 records 재구성 
//	this._remakeRecords();
	var _makeGroupRecordSample = null;
	for(var nRowNF = 0; nRowNF < this.buffer.length; nRowNF++){
		if (!this.buffer[nRowNF]._filterd){
			_makeGroupRecordSample = this.buffer[nRowNF];
			break;
		}
	}

	// STEP 3. 레벨별 데이터 소계 채우기 
	// 3-1.  루핑하면서 끝 그룹키이 바뀌면 1레벨합계  다음은 2레벨합계, ...
	var levelCount = this._jsonGroupKey.length;
	
	// 3-1-1.  레벨별 그룹데이터를 만들고 첫데이터를 기준으로키값을 세팅한다
	var groupRecords = [null];
    for(var nGroupLevel = 1; nGroupLevel <= levelCount; nGroupLevel++){
    	// 그룹합을 만들지 않는 레벨은 스킵한다
    	if (!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;
    	
    	var groupRecord = groupRecords[nGroupLevel] = this._makeGroupRecord();
    	groupRecord._RowLevel = nGroupLevel;
    	
//    	var record = _makeSampleGroupRecord;
		groupRecord.rangeStart = 0;
		groupRecord._jsonGroupKeyValue = this._makeGroupLevelKey(_makeGroupRecordSample._jsonGroupKeyValue, nGroupLevel); 
		// 키값을 그룹레코드에 복사
		for (var key in this.colInfos){
			var colInfo = this.colInfos[key];
			if( typeof(colInfo) == "function" ) continue;
			if (colInfo._isGroupKeyField){
				groupRecord.values[key] = _makeGroupRecordSample.values[key];
			}
		}
    }
    
    // 3-1-2.  데이터를 처음부터 끝까지 돌리면서 레벨 정보를 집계한다
    var groupBuffer = [];
    var _recordGroupKey = [];
    
    for(var nRowNF = 0; nRowNF < this.buffer.length; nRowNF++){
		var record = this.buffer[nRowNF];
		if (record._filterd) continue;
		
	    for(var nGroupLevel = 1; nGroupLevel <= levelCount; nGroupLevel++){
	    	// 그룹합을 만들지 않는 레벨은 스킵한다
	       	if( !this._needGroupKey[levelCount - nGroupLevel + 1] ) continue;
	    	
	    	// 그룹레코드 생성
	    	var groupRecord = groupRecords[nGroupLevel];
	    	
	    	// 필터링 안된 첫데이터가 아니면서, 키가 바뀌었으면
	    	var keyChanged = ( this._checkIfGroupLevelKeyChanged(record, groupRecord._jsonGroupKeyValue, nGroupLevel) ); 

	    	// 키가 변경되었으면 논리레코드를 추가하고 새로운 레코드를 만든다 
    		if (keyChanged){
    			groupBuffer.push(groupRecord);
    			
    			// 레코드 초기화 
    			groupRecord = groupRecords[nGroupLevel] = this._makeGroupRecord();
    			groupRecord._RowLevel = nGroupLevel;
	    		
	    		groupRecord._jsonGroupKeyValue = this._makeGroupLevelKey(record._jsonGroupKeyValue, nGroupLevel); 
	    		// 키값을 그룹레코드에 복사
	    		for (var key in this.colInfos){
	    			var colInfo = this.colInfos[key];
					if( typeof(colInfo) == "function" ) continue;
					if (colInfo._isGroupKeyField){
						groupRecord.values[key] = record.values[key];
					}
	    		}
    		}
	    } // 그룹 레벨별 루프 종료 
	    
	} // this.buffer 루프 종료 
		
    // 3-1-3.  마지막에 남은 집계레코드를 표에 추가한다.
    for (var nGroupLevel=1; nGroupLevel <= levelCount; nGroupLevel++ ){
    	// 그룹합을 만들지 않는 레벨은 스킵한다
       	if (!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;

    	groupBuffer.push(groupRecords[nGroupLevel]);
    }
    
    // 3-1-4 buffer에 그룹핑 레코드 추가 후, buffer & groupBuffer sorting
    this.buffer = this.buffer.concat(groupBuffer);
    
    /*
    if (this._strSortColList.length == 0){
		this.buffer.sort(function(record1, record2){
//			return compareGroupKey(record1._jsonGroupKeyValue, record2._jsonGroupKeyValue);
			return compareRecordGroupKeyByRecord(record1, record2);
		});
    } else {
    	this.sort(this._strSortColList);
    }
     */
    this.buffer.sort(function(record1, record2){
    	return compareRecordGroupKeyByRecord(record1, record2);
    });
    
    groupBuffer.sort(function(record1, record2){
		return compareRecordGroupKeyByGroupKey(record1._jsonGroupKeyValue, record2._jsonGroupKeyValue);
	});
    
    // 3-1-5 소팅된 버퍼데이터 배열로 records 재구성 
    this._remakeRecords();
    
    // 3-1-6 그룹 레코드에 집계 메소드에 따른 값 및 rangeCount 계산
    var _recordGroupKey = null;
    var record = null;
    var _groupRecord = null;
    var rowIndex = -1;
    
    for(var nRowNF = 0; nRowNF < this.buffer.length; nRowNF++){
		record = this.buffer[nRowNF];
		if(record._filterd) continue;
		if (record.RowType == "Logical") continue;
		
		_recordGroupKey = null;
		
		for(var nGroupLevel=1; nGroupLevel <= levelCount; nGroupLevel++){
	    	// 그룹합을 만들지 않는 레벨은 스킵한다
	       	if(!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;
	       	
	       	_recordGroupKey = this._makeGroupLevelKey(record._jsonGroupKeyValue, nGroupLevel);
	       	rowIndex = binaryRecordGroupSearch(groupBuffer, _recordGroupKey, 0, groupBuffer.length);
	       	_groupRecord = groupBuffer[rowIndex];
	       	
	       	var _value 		= null;
	       	var _calcResult = null;
			var _sumMethod  = null;
			var _sumFormula = null;
			var _sumField   = null;
			var _sumText    = null;
	       	
	       	for(var colId in this.colInfos){
	       		var colInfo = this.colInfos[colId];
				if( typeof(colInfo) == "function" ) continue;
				if( colInfo._isGroupKeyField )		continue;
    			if( colInfo.sumMethod.length == 0 )	continue;
    			
    			_value		= _groupRecord.values[colId];
    			_sumMethod  = colInfo.sumMethod;
    			_sumFormula = colInfo._sumFormula;
    			_sumField   = colInfo._sumField;
    			_sumText    = colInfo._sumText;
    			
    			if( _sumFormula.length > 0 )	_calcResult = self[this.id + "_" + colId + "_sumFunction"](nRowNF, _groupRecord._RowLevel);
    			else if( _sumField.length > 0 )	_calcResult = record.values[sumField];
    			else if( _sumText.length > 0 )	_calcResult = _sumText;
    			else							_calcResult = record.values[colId];
    			
    			if( _sumMethod == "TEXT" )		_value = _calcResult;
    			else if( _sumMethod == "SUM" ) 	_value += _calcResult; 
    			else if( _sumMethod == "AVG" )	_value += _calcResult; 
    			else if( _sumMethod == "MAX" )	_value = (_value > _calcResult ? _value : _calcResult);
    			else if( _sumMethod == "MIN" )	_value = (_value < _calcResult ? _value : _calcResult);
    			else if( _sumMethod == "COUNT" ) _value += 1;
     			
    			_groupRecord.values[colId] = _value;
	       	}
	       	
	       	_groupRecord.rangeCount++;
		}
    }
    
    // 컬럼의 집계 함수가 AVG인 경우 AVG인 컬럼만 찾음
    var avgMethodColIDList = [];
    for(var colId in this.colInfos){
    	var colInfo = this.colInfos[colId];
    	if( typeof(colInfo) == "function" )	continue;
    	if( colInfo.sumMethod.length == 0 )	continue;
    	if( colInfo.sumMethod != "AVG" )	continue;
    	
    	avgMethodColIDList.push( colId );
    }
    // 컬럼의 집계 함수가 AVG인 열만 그룹 레코드의 평균 값을 구함
    if(avgMethodColIDList.length > 0){
    	for(var nRowNF = 0; nRowNF < groupBuffer.length; nRowNF++){
    		var _groupRecord = groupBuffer[nRowNF];
    		for(var c = 0; c < avgMethodColIDList.length; c++){
    			_groupRecord.values[avgMethodColIDList[c]] = _groupRecord.values[avgMethodColIDList[c]] / _groupRecord.rangeCount;
    		}
    	}
    }
    
    // 3-1-7 레코드의 rangeStart를 구함
    var groupLevelKeys = [];
    for(var nGroupLevel=1; nGroupLevel <= levelCount; nGroupLevel++){
    	groupLevelKeys[nGroupLevel] = null;
    }
    // 데이터셋의 records를 돌며 그룹 레코드의 그룹 레벨별 그룹키가 변할 경우 rangeStart를 기록한다 
    for(var nRow = 0, groupKeyStr = ""; nRow < this.records.length; nRow++){
    	record = this.records[nRow];
    	if (record.RowType == "Logical") continue;
		
		_recordGroupKey = null;
		
		for(var nGroupLevel=1; nGroupLevel <= levelCount; nGroupLevel++){
	       	if(!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;
	       	
	       	_recordGroupKey = this._makeGroupLevelKey(record._jsonGroupKeyValue, nGroupLevel);
	       	groupKeyStr = JSON.stringify(_recordGroupKey);
	       		       	
	       	if( groupLevelKeys[nGroupLevel] != groupKeyStr ){
	       		groupLevelKeys[nGroupLevel] = groupKeyStr;
	       		groupBuffer[binaryRecordGroupSearch(groupBuffer, _recordGroupKey, 0, groupBuffer.length)].rangeStart = nRow;
	       	}
	    }
    }
    
    if (this._strSortColList.length > 0){
    	this.sort(this._strSortColList);
    }
    
    // 3-1-8 메모리 초기화
    while(avgMethodColIDList.length > 0)	avgMethodColIDList.pop();	avgMethodColIDList = null;
    while(groupBuffer.length > 0)			groupBuffer.pop();			groupBuffer = null;
    
    // 4-1 연결된 시트의 소팅을 막음  (동작안함 ?)
//    var tmpBinds = [];
//	for (var key in this.dataBinds){
//		var bindInfo = this.dataBinds[key];
//		if( typeof(bindInfo) == "function" ) continue;
//		if (bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet") {
//			continue;
//		}
//		if (bindInfo.controlName in tmpBinds) {
//			continue;
//		}
//		AUIGrid.setProperty(controls[bindInfo.controlName].AUIcontrolId, "enableSorting" , false);
//		AUIGrid.refresh(controls[bindInfo.controlName].AUIcontrolId);
//		tmpBinds[bindInfo.controlName] = bindInfo.controlType;
//	}
//	tmpBinds.clear();
    
	return;
};

/**
*     @description	미결
*     @param	{object}	groupBuffer
*     @param	{object}	grouKey
*     @param	{number}	start
*     @param	{number}	end
*     @return	{object}
*     @example	미결
*/
function binaryRecordGroupSearch(groupBuffer, groupKey, start, end){
	if( start > end ) return -1; //does not exist
	
	var middle = Math.floor((start + end) / 2);
	var groupKey1 = groupBuffer[middle]._jsonGroupKeyValue;
	
	var result = compareRecordGroupKeyByGroupKey(groupKey1 , groupKey);
	if( result > 0 ){ 
		return binaryRecordGroupSearch(groupBuffer, groupKey, start, middle - 1); 
	}
	if( result < 0 ){ 
		return binaryRecordGroupSearch(groupBuffer, groupKey, middle + 1, end); 
	}
	
	return middle; //found!
};

/**
*     @description	미결
*     @param	{object}	groupKey1
*     @param	{object}	groupKey2
*     @return	{boolean}
*     @example	미결
*/
function compareRecordGroupKeyByGroupKey(groupKey1, groupKey2){
	var key1 = null;		var key2 = null;
	var subKey1 = null;		var subKey2 = null;
	
	for(var i = 0; i < groupKey1.length; i++){
		key1 = groupKey1[i];
		key2 = groupKey2[i];
		
		if (key1 instanceof Array) {
			for(var j = 0; j < key1.length; j++){
				subKey1 = key1[j];
				subKey2 = key2[j];
				
				if( subKey1 != null && subKey2 == null )		return -1;
				else if( subKey1 == null && subKey2 != null )	return 1;
				else if( subKey1 > subKey2 )					return 1;
				else if( subKey1 < subKey2 )					return -1;
			}
		}
		else{
			if( key1 != null && key2 == null )		return -1;
			else if( key1 == null && key2 != null )	return 1;
			else if( key1 > key2 )					return 1;
			else if( key1 < key2 )					return -1;
		}
	}
	
	if( groupKey1.length < groupKey2.length )		return -1;
	
	return 0;
};

/**
*     @description	미결
*     @param	{object}	record1
*     @param	{object}	record2
*     @return	{boolean}
*     @example	미결
*/
function compareRecordGroupKeyByRecord(record1, record2){
	var groupKey1 = null;	var groupKey2 = null;
	var key1 = null;		var key2 = null;
	var subKey1 = null;		var subKey2 = null;
	
	groupKey1 = record1._jsonGroupKeyValue;
	groupKey2 = record2._jsonGroupKeyValue;
	
	for(var i = 0; i < groupKey1.length; i++){
		key1 = groupKey1[i];
		key2 = groupKey2[i];
		
		if (key1 instanceof Array) {
			for(var j = 0; j < key1.length; j++){
				subKey1 = key1[j];
				subKey2 = key2[j];
				
				if( subKey1 != null && subKey2 == null )		return -1;
				else if( subKey1 == null && subKey2 != null )	return 1;
				else if( subKey1 > subKey2 )					return 1;
				else if( subKey1 < subKey2 )					return -1;
			}
		}
		else{
			if( key1 != null && key2 == null )		return -1;
			else if( key1 == null && key2 != null )	return 1;
			else if( key1 > key2 )					return 1;
			else if( key1 < key2 )					return -1;
		}
	}
	
	if( groupKey1.length < groupKey2.length )		return -1;
	
	if(record1.RowType == "Logical" && record2.RowType != "Logical") return 1;
	if(record1.RowType != "Logical" && record2.RowType == "Logical") return -1;
	
	return 0;
};

/**
 * @description	미결
 * @param	{string}	nRow
 * @return  {void}
 * @example	미결
 */
DataSet.prototype._RefreshGroupByOneRecord = function(nRow){
	// 전제: 해당 레코드가 records 에서 빠진 상태를 가정한다
	var record = this.records[nRow];
	
	var arrGroupRows = this._FindGroupRows(nRow);
	
	var levelCount = this._jsonGroupKey.length;
    for (var nGroupLevel=1; nGroupLevel <= levelCount; nGroupLevel++ ){
    	// 그룹합을 만들지 않는 레벨은 스킵한다
    	if (!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;

    	var nGroupRow = arrGroupRows[nGroupLevel];
    	
    	for (var key in this.colInfos){
    		if( typeof(this.colInfos[key]) == "function" ) continue;
    		var sumMethod = this.colInfos[key].sumMethod;
    		if (sumMethod.length == 0) continue;

    		if (sumMethod == "COUNT"){
    			// 변화없음
    		} else {
    			var colId = this.colInfos[key].id;
    			this._UpdateGroupSum(colId, nGroupRow, null, nRow);
    		}
    	}
    }

	// 관련 시트데이터 수정
    if( this.instantUpdateControl ) this.updateControlRowData(record); // this.updateControlRowData(nRow);

	return;
};

// 칼럼값의 변경시 처리 
// 값을 이미 수정하고 그룹키가  아직 안 바뀌었다는 전제 
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{string}	colId
 * @param	{string}	varFromValue
 * @param	{string}	varToValue
 * @return  {void}
 * @example	미결
 */
DataSet.prototype._UpdateColumnValueToGroup = function(nRow, colId, varFromValue, varToValue){
	
	var record = this.records[nRow];
	var sumMethod = this.colInfos[colId].sumMethod;

	// 병경된 칼럼이 그룹키 항목이 아니고 집계가 필요한 필드이면 
	// 합계를 갱신하고 빠져 나간다
	var isKeyColumn = this._isKeyColumn(colId);

	// 레벨별 줄번호를 찾아낸다
	var arrGroupRows = this._FindGroupRows(nRow);
	
	if (!isKeyColumn){
		if (sumMethod.length == 0) return;
		
		// 레벨별로 루핑돌면서 집계값을 갱신한다
		var levelCount = this._jsonGroupKey.length;
	    for (var nGroupLevel=1; nGroupLevel <= levelCount; nGroupLevel++ ){
	    	// 그룹합을 만들지 않는 레벨은 스킵한다
	    	if (!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;

	    	var nGroupRow = arrGroupRows[nGroupLevel];
	    	var groupRecord = this.records[nGroupRow];
	    	
	    	if (sumMethod == "SUM"){
	    		groupRecord.values[colId] += varToValue - varFromValue;
	    		// 연결콘트롤 갱신
	    		if( this.instantUpdateControl ) this.updateControlValue(colId, nGroupRow);
	    	} else if (sumMethod == "COUNT"){
	    	} else {
	    		this._UpdateGroupSum(colId, nGroupRow, null, nRow);
	    	}
	    }
	    return;
	}
	
	// 그룹키이면  먼저 레코드를 이동한다
	
	
	// 먼저 그룹들의 집계에서 뺀다 
	//   이때 하나도 없으면 그룹을 제거 한다  
    this._DeleteFromGroup(arrGroupRows, record, nRow);
    
	//    이동할 위치로 레코드를 옮긴다.
	//       - 삭제
	var nRowNF = this.getRowIndexNF(nRow);
	this.buffer.splice(nRowNF, 1);
	this.records.splice(nRow, 1);
	
	// rangeStart 한줄씩 앞으로 당기기
    this._updateRangeStartsAfter(nRow, -1);

    
	// 연결된 시트의 줄삭제 
    if( this.instantUpdateControl ) this.updateControlDelRow(record);

	// 새로운 키값을 부여한다 
	record._jsonGroupKeyValue = this._makeGroupKey(record);

	
	//  이동할 위치를 찾는다
	lastGroupSearchIndex = -1;
	var searchedRow = binaryGroupSearch(this.records, record, 0, this.records.length - 1); 
	// 못 찾았으면  searchedRow = -1 이고 lastGroupSearchIndex 값에 가장 근사치 값이 들어간다.
	var rowFrom = (searchedRow != -1 ? searchedRow : (lastGroupSearchIndex != -1 ? lastGroupSearchIndex : this.records.length));
	var rowTo = this.records.length;
	for (var nRow1 = rowFrom; nRow1 < this.records.length; nRow1++){
		var record1 = this.records[nRow1];
		if ((record1.RowType == "Logical" && compareGroupKey(record1._jsonGroupKeyValue , record._jsonGroupKeyValue) == 0) ||
			(record1.RowType != "Logical" && compareGroupKey(record1._jsonGroupKeyValue , record._jsonGroupKeyValue) > 0)) { 
			rowTo = nRow1; 
			break;
		}
	}
	
	//       - 추가
	if (rowTo == this.records.length){
		this.records.push(record);
		this.buffer.push(record);
		
	} else {
		var rowToNF = this.getRowIndexNF(rowTo); 
		this.buffer.splice(rowToNF, 0, record);
		this.records.splice(rowTo, 0, record);
		
    	// rangeStart 한줄씩 뒤로 미루기
    	this._updateRangeStartsAfter(rowTo, 1);
	}
	

	// 연결된 콘트롤 줄추가 
	if( this.instantUpdateControl ) this.updateControlAddRow(record, rowTo);
	
	// 새로운 그룹에 추가한다 
	// 이때 기존 그룹이 없으면 추가한다  (필터링 된 상태로 변경되었다면, 새로운 그룹은 갱신할 필요가 없다)
	if (!record._filterd){
		this._InsertToGroup(rowTo);
	    this._refreshGroupCation(true);
	}
	
	return;
};

/**
 * @description	미결
 * @param	{number}	arrGroupRows
 * @param	{object}	record
 * @param	{number}	nRow
 * @return  {object}
 * @example	미결
 */
DataSet.prototype._DeleteFromGroup = function(arrGroupRows, record, nRow){
	// 전제: 해당 레코드가 records 에서 아직 삭제되지 않은 상태를 가정한다
	
	var levelCount = this._jsonGroupKey.length;
	var lastGroupRow = this.records.length;
    for (var nGroupLevel=levelCount; nGroupLevel >= 1; nGroupLevel-- ){
    	// 그룹합을 만들지 않는 레벨은 스킵한다
    	if (!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;
    	
    	var nGroupRow = arrGroupRows[nGroupLevel];
    	if (nGroupRow < 0) continue;
    	
    	lastGroupRow = nGroupRow; // 최종 그룹핑줄번호를 기억해서 이후 그루핑 정보에서  하나씩 당긴다
    	var groupRecord = this.records[nGroupRow];
    	
    	// 데이터가 한건도 없게되면 해당 소계를 삭제한다
    	if (groupRecord.rangeCount == 1){
    		this.buffer.splice(this.getRowIndexNF(nGroupRow), 1);
    		this.records.splice(nGroupRow, 1);
    		
	    	// rangeStart 한줄씩 앞으로 당기기
    	    this._updateRangeStartsAfter(nGroupRow, -1);
    	    

    		// 연결된 시트의 줄삭제 
    		this.updateControlDelRow(groupRecord);
    		
    	} else {
    		for (var key in this.colInfos){
    			var colInfo = this.colInfos[key];
    			if( typeof(colInfo) == "function" ) continue;
    			if (colInfo._isGroupKeyField) continue;
    			
    			var colId = key;
    			var sumMethod = colInfo.sumMethod;
    			if (sumMethod.length == 0) continue;

    			
    			var calcResult = null;
    			var sumMethod  = colInfo.sumMethod;
    			var sumFormula = colInfo._sumFormula;
    			var sumField   = colInfo._sumField;
    			var sumText    = colInfo._sumText;
    			
    			if (sumFormula.length > 0){
    				var rowLevel = groupRecord._RowLevel;
    				calcResult = self[this.id + "_" + colId + "_sumFunction"](nRow, rowLevel);
    			} else if (sumField.length > 0){
    				calcResult = record.values[sumField];
    			} else if (sumText.length > 0){
    				calcResult = sumText;
    			} else {
    				calcResult = record.values[colId];
    			}
    			
    			if (sumMethod == "SUM"){
    				groupRecord.values[colId] -= calcResult;
    			} else if (sumMethod == "COUNT"){
    				groupRecord.values[colId]--;
    			} else {
    				this._UpdateGroupSum(colId, nGroupRow, record, nRow); // 세번째 인수는 삭제할 레코드를 합계에서 제외하기 위해서
    			}
    		}
    		// 관련 시트데이터 수정
    		this.updateControlRowData(groupRecord); // this.updateControlRowData(nGroupRow);

    		groupRecord.rangeCount--;
    	}
    }
    
    // 이후의 데이터의  rangeStart 속성 정리 
/*
    for (var nRow1 = lastGroupRow; nRow1 < this.records.length; nRow1++){
    	var record1 = this.records[nRow1];
    	if (record1.RowType != "Logical") continue;
    	if (record1.rangeStart >= nGroupRow) {
    		record1.rangeStart--;
    	}
    }
*/	
	return record;
};

/**
 * @description	미결
 * @param	{string}	nNewNum
 * @return  {object}
 * @example	미결
 */
DataSet.prototype._InsertToGroup = function(nNewNum){
	// 전제: 해당 레코드가 records의 새로운 위치에 추가된 상태를 가정한다
	var record = this.records[nNewNum];
	
	var arrGroupRows = this._FindGroupRows(nNewNum);
	
	var levelCount = this._jsonGroupKey.length;
	var lastGroupRow = this.records.length;
    for (var nGroupLevel = 1 ; nGroupLevel <= levelCount; nGroupLevel++ ){
    	// 그룹합을 만들지 않는 레벨은 스킵한다
    	if (!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;

    	var nGroupRow = arrGroupRows[nGroupLevel];
    	lastGroupRow = nGroupRow; // 최종 그룹핑줄번호를 기억해서 이후 그루핑 정보에서  하나씩 밀친다다
    	if (nGroupRow == -1){
    		// 집계레코드가 없으면 추가
    		nGroupRow = this._findGroupInsertRowPosition(nNewNum, record._jsonGroupKeyValue);
    		var nGroupRowNF = (nGroupRow < this.records.length ? this.getRowIndexNF(nGroupRow) : this.buffer.length);//;
    		
    		for (var tmpRowNum = nGroupRowNF; tmpRowNum < this.buffer.length;  tmpRowNum++){
    			if (this.buffer[tmpRowNum].RowType == "Logical" && this.buffer[tmpRowNum]._RowLevel < nGroupLevel){
    				nGroupRowNF++; nGroupRow++;
    			} else {
    				break;
    			}
    		}
    		
	    	var groupRecord = this._makeGroupRecord();
	    	//groupRecord._RowLevel = levelCount - nGroupLevel + 1;
	    	groupRecord._RowLevel = nGroupLevel;
	    	groupRecord.rangeStart = nNewNum;
	    	groupRecord.rangeCount = 0;
			// 키값을 그룹레코드에 복사
			for (var key in this.colInfos){
				var colInfo = this.colInfos[key];
				if( typeof(colInfo) == "function" ) continue;
				if (colInfo._isGroupKeyField){
					groupRecord.values[key] = record.values[key];
				}
			}
			groupRecord._jsonGroupKeyValue = this._makeGroupLevelKey(record._jsonGroupKeyValue, nGroupLevel); 

	    	
			this.buffer.splice(nGroupRowNF, 0, groupRecord);
	    	this.records.splice(nGroupRow, 0, groupRecord);
	    	
	    	// rangeStart 한줄씩 뒤로 미루기
	    	this._updateRangeStartsAfter(nGroupRow, 1);
	    	
    		for (var key in this.colInfos){
    			var colInfo = this.colInfos[key]
    			if( typeof(colInfo) == "function" ) continue;
				if (colInfo._isGroupKeyField)       continue;
    			if (colInfo.sumMethod.length == 0)  continue;

    			var colId = key;
    			var sumMethod = colInfo.sumMethod;
    			
    			var calcResult = null;
    			var sumMethod  = colInfo.sumMethod;
    			var sumFormula = colInfo._sumFormula;
    			var sumField   = colInfo._sumField;
    			var sumText    = colInfo._sumText;
    			
    			if (sumFormula.length > 0){
    				var rowLevel = groupRecord._RowLevel;
    				calcResult = self[this.id + "_" + colId + "_sumFunction"](nNewNum, rowLevel);
    			} else if (sumField.length > 0){
    				calcResult = record.values[sumField];
    			} else if (sumText.length > 0){
    				calcResult = sumText;
    			} else {
    				calcResult = record.values[colId];
    			}
    			
    			var value = groupRecord.values[key];
    			
    			if (sumMethod == "TEXT"){
    				value = calcResult;
    			} else if (colInfo.sumMethod == "SUM"){ 
    				value += calcResult; 
    			} else if (colInfo.sumMethod == "AVG"){ 
    				value += calcResult; 
    			} else if (colInfo.sumMethod == "MAX"){
    				value = (value > calcResult ? value : calcResult);
    			} else if (colInfo.sumMethod == "MIN"){
    				value = (value < calcResult ? value : calcResult);
    			} else if (colInfo.sumMethod == "COUNT"){
    				value = 1;
    			}

				groupRecord.values[colId] = value;
    		}
    		

    		// 연결된 콘트롤 줄추가
    		this.updateControlAddRow(groupRecord, nGroupRow);
    		
    	} else {
    		// 집계레코드가 있으면 합계값 갱신
    		var groupRecord = this.records[nGroupRow];
    		for (var key in this.colInfos){
    			var colInfo = this.colInfos[key];
    			if( typeof(colInfo) == "function" ) continue;
				if (colInfo._isGroupKeyField)       continue;
    			if (colInfo.sumMethod.length == 0)  continue;
    			
    			var colId = key;
    			var sumMethod = colInfo.sumMethod;

    			var calcResult = null;
    			var sumMethod  = colInfo.sumMethod;
    			var sumFormula = colInfo._sumFormula;
    			var sumField   = colInfo._sumField;
    			var sumText    = colInfo._sumText;
    			
    			if (sumFormula.length > 0){
    				var rowLevel = groupRecord._RowLevel;
    				calcResult = self[this.id + "_" + colId + "_sumFunction"](nNewNum, rowLevel);
    			} else if (sumField.length > 0){
    				calcResult = record.values[sumField];
    			} else if (sumText.length > 0){
    				calcResult = sumText;
    			} else {
    				calcResult = record.values[colId];
    			}
    			
    			if (colInfo.sumMethod == "SUM"){ 
    				groupRecord.values[colId] += calcResult;
    			} else if (colInfo.sumMethod == "COUNT"){
    				groupRecord.values[colId]++;
    			} else {
    				this._UpdateGroupSum(colId, nGroupRow, null, nNewNum);
    			}
    		}
    		
    		// 관련 시트데이터 수정
    		this.updateControlRowData(groupRecord); // this.updateControlRowData(nGroupRow);
    	}
    	groupRecord.rangeCount++;
    	
    }
/*    
    // 이후의 데이터의  rangeStart 속성 정리 
    for (var nRow1 = lastGroupRow + 1; nRow1 < this.records.length; nRow1++){
    	var record1 = this.records[nRow1];
    	if (record1.RowType != "Logical") continue;
    	if (record1.rangeStart > nGroupRow) record1.rangeStart++;
    }
*/	
	return record;
};


// 변경된 키를 기준으로 리프래시한다 
// 세번째 인수는 제외할 레코드이다(삭제할 게 있는경우에만)
/**
 * @description	미결
 * @param	colId
 * @param	nGroupRow
 * @param	RecordToDel
 * @param	nRow
 * @return  {undefined}
 * @example	미결
 */
DataSet.prototype._UpdateGroupSum = function(colId, nGroupRow, RecordToDel, nRow){
	var colInfo = this.colInfos[colId];
	
	if (colInfo.sumMethod.length == 0)    return;
	if (colInfo._isGroupKeyField)         return;
	
    // 줄추가, 삭제시 항상 대중소계레코드를 동시에 만드므로 여기서는 논리데이터를 추가할 필요는 없다.
    var groupRecord = this.records[nGroupRow];
    
    groupRecord.values[colId] = 0;
    var value = 0; var cnt = 0;
    var rangeCount = groupRecord.rangeCount;
    for (var nRow = groupRecord.rangeStart; nRow < this.records.length ; nRow++){
    	if (cnt >= rangeCount) break;
    	
    	var record0 = this.records[nRow];
    	if (record0._filterd) continue;
    	if (record0.RowType == "Logical") continue;
    	if (RecordToDel != undefined && RecordToDel != null && RecordToDel._id == record0._id) {
    		rangeCount--; //삭제할 레코드가 있으므로 하나 줄여서 루핑을 한번 덜돌게 한다
    		continue;
    	}
    	
		var calcResult = null;
		var sumMethod  = colInfo.sumMethod;
		var sumFormula = colInfo._sumFormula;
		var sumField   = colInfo._sumField;
		var sumText    = colInfo._sumText;

		if (sumFormula.length > 0){
			var rowLevel = groupRecord._RowLevel;
			calcResult = self[this.id + "_" + colId + "_sumFunction"](nRow, rowLevel);
		} else if (sumField.length > 0){
			calcResult = record0.values[sumField];
		} else if (sumText.length > 0){
			calcResult = sumText;
		} else {
			calcResult = record0.values[colId];
		}

		if (sumMethod == "TEXT"){
			value = calcResult;
		} else if (colInfo.sumMethod == "SUM"){ 
			value += calcResult;
		} else if (colInfo.sumMethod == "AVG"){ 
			value += calcResult; 
		} else if (colInfo.sumMethod == "MAX"){
			value = (value > calcResult ? value : calcResult);
		} else if (colInfo.sumMethod == "MIN"){
			value = (value < calcResult ? value : calcResult);
		} else if (colInfo.sumMethod == "COUNT"){
			value += 1;
		}
    	
    	cnt++;
    	
    }
    if (sumMethod == "AVG") {
    	value = value / cnt;
    }

    groupRecord.values[colId] = value;
    
    // 연결콘트롤 갱신 
    this.updateControlValue(colId, nGroupRow);
    
};



// 데이터의 그룹키를 주면 레벨별 줄번호를 리턴한다 없으면 -1이다 리턴 예: [null, -1, 12,13,14]
/**
 * @description	미결
 * @param	{number}	nRow
 * @return  {number}
 * @example	미결
 */
DataSet.prototype._FindGroupRows = function(nRow){
    var record = this.records[nRow];
    var groupRowNums = [null];
    
    var nLastRow = nRow;
    
	var levelCount = this._jsonGroupKey.length;
    for (var nGroupLevel=1; nGroupLevel <= levelCount; nGroupLevel++ ){
    	// 그룹합을 만들지 않는 레벨은 스킵한다
    	if (!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;
    	
    	// 레벨별 그룹 키를 구한다.
    	var jsonGroupKeyValue = [];
    	
    	for (var i = 0; i < record._jsonGroupKeyValue.length; i++){
    		
    		// 그룹레벨별 키 범위내의 데이터 복사 
    		var varKey = record._jsonGroupKeyValue[i];
    		
    		if (varKey instanceof Array) {
    			var varSubKey = [];
    			for (var j=0; j < varKey.length; j++) {
    				varSubKey[j] = varKey[j];
    			}
    			jsonGroupKeyValue[i] = varSubKey;
    		} else{
    			jsonGroupKeyValue[i] = varKey;
    		}
    		
    		// 결국은 i 가 levelCount - nGroupLevel 보다 크면 null;
    		if (i > levelCount - nGroupLevel) {
    			jsonGroupKeyValue[i] = null;
    			continue;
    		}
    	}
    	
    	// 
    	groupRowNums[nGroupLevel] = -1;
    	for (var nRow1 = nLastRow + 1; nRow1 < this.records.length; nRow1++){
    		var record1 = this.records[nRow1];
    		if (record1.RowType != "Logical") continue;
    		var rslt = compareGroupKey(record1._jsonGroupKeyValue, jsonGroupKeyValue);
    		if (rslt == 0){
    			groupRowNums[nGroupLevel] = nRow1;
    			nLastRow = nRow1;
    			break;
    		}
    	}
    }
	
	return groupRowNums;
};

// 그룹합을 넣을 위치를 찾아주는 함수, 못찾으면 마지막 레코드 번호 + 1 리턴
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{string}	jsonGroupKeyValue
 * @return  {number}
 * @example	미결
 */
DataSet.prototype._findGroupInsertRowPosition = function(nRow, jsonGroupKeyValue){
	for (var nRow1 = nRow + 1; nRow1 < this.records.length; nRow1++){
		var record1 = this.records[nRow1];
		// ??? if (record1.RowType != "Logical") continue;

		var jsonGroupKeyValue1 = record1._jsonGroupKeyValue;
		for (var i = 0; i < jsonGroupKeyValue.length && jsonGroupKeyValue[i] != null; i++){
			var varKey1 = jsonGroupKeyValue1[i];
			var varKey2 = jsonGroupKeyValue[i];
			if (varKey1 instanceof Array) {
				for (var j=0; j < varKey1.length ;j++) {
					if (varKey1[j] != varKey2[j]) return nRow1;
				}
			} else{
				if (varKey1 != varKey2) return nRow1;
			}
		}
	}
	return this.records.length;
	
};

//최종적인 정살적인 데이터 줄을 찾아주는 메서드로 산식에서 참조할 줄번호를 도출하기 위해 사용한다
/**
 * @description	미결
 * @param	{number}	nRow
 * @return  {number}
 * @example	미결
 */
DataSet.prototype._findLastNormalRowPosition = function(nRow){
	for (var nRow1 = nRow; nRow1 >= 0; nRow1--){
		if (this.records[nRow1].RowType != "Logical") return nRow1;
	}
	return -1;
};

// 줄추가시 포커스된 줄의 그룹키에 해당하는 값은 미리 채워줘야 중간에 들어갈 수 있다.
/**
 * @description	미결
 * @param	{object}	recordFrom
 * @param	{object}	recordTo
 * @return  {undefined}
 * @example	미결
 */
DataSet.prototype._copyGroupKeyValues = function(recordFrom, recordTo){
	for (var i=0; i < this._jsonGroupKey.length;i++){
		var varKeyName = this._jsonGroupKey[i];
		if (varKeyName instanceof Array) {
			for (var j=0; j < varKeyName.length;j++){
				var colId = varKeyName[j];
				recordTo.values[colId] = recordFrom.values[colId]
			}
			
		} else {
			var colId =this._jsonGroupKey[i];
			recordTo.values[colId] = recordFrom.values[colId]
		}
	}
};

/**
 * @description	미결
 * @param	{string}	record
 * @return  {object}
 * @example	미결
 */
DataSet.prototype._makeGroupKey = function(record){
	if (this._GroupKey.length == 0) return [];

	// _jsonGroupKey가 생성되지 않았으면 생성한다.
	if (this._jsonGroupKey.length == 0){
		var levelKeyArr = this._GroupKey.split(",");
		for (var i=0; i < levelKeyArr.length; i++){
			var levelKey = levelKeyArr[i];
			if (levelKey.indexOf(":") >= 0){
				this._jsonGroupKey[i] = levelKey.split(":");
			} else {
				this._jsonGroupKey[i] = levelKey;
			}
		}
	}
	
	var returnJson = [];
	for (var i=0; i < this._jsonGroupKey.length; i++){
		var levelKey = this._jsonGroupKey[i];
		if (levelKey instanceof Array) {
			var itemKeys = levelKey;
			var itemKeyValues = [];
			for (j = 0; j < itemKeys.length; j++){
				var itemKey = itemKeys[j];
				itemKeyValues[j] = record.values[itemKey];
			}
			returnJson[i] = itemKeyValues;
			
		} else {
			returnJson[i] = record.values[levelKey];
		}
	}
	
	return returnJson;
};

/**
 * @description	미결
 * @param	{string}	jsonGroupKeyValue
 * @param	{number}	nGroupLevel
 * @return  {object}
 * @example	미결
 */
DataSet.prototype._makeGroupLevelKey = function(jsonGroupKeyValue, nGroupLevel){
	var groupLevelKey = [];
	var levelCount = this._jsonGroupKey.length;
	for (var i = 0; i < jsonGroupKeyValue.length; i++){
		// 레벨이 1이면 다 (levelCount 3가정)  levelCount - nRowLevel = 3 - 1 = 2 => i > 2 인건 없다.
		// 레벨이 2이면 끛에 하나는 null;        levelCount - nRowLevel = 3 - 2 = 1 => i > 1 인건 하나 
		// 레벨이 3이면 끝에 두개가 null;        levelCount - nRowLevel = 3 - 3 = 0 => i > 0 인건 두개 
		// 결국은 i 가 levelCount - nRowLevel 보다 크면 null;
		if (i > levelCount - nGroupLevel) {
			groupLevelKey[i] = null;
			continue;
		}
		
		// 그룹레벨별 키 범위내의 데이터 복사 
		var varKey = jsonGroupKeyValue[i];
		
		if (varKey instanceof Array) {
			var varSubKey = [];
			for (var j=0; j < varKey.length; j++) {
				varSubKey[j] = varKey[j];
			}
			groupLevelKey[i] = varSubKey;
		} else{
			groupLevelKey[i] = varKey;
		}
	}
	return groupLevelKey;
};

/**
 * @description	미결
 * @return  {string}
 * @example	미결
 */
DataSet.prototype._makeGroupRecord = function(){

	var groupRecord = new MiRecord(this.colInfos);
	groupRecord.RowType = "Logical";
	groupRecord.tmpCount = 0;  // 평균을 내기위한 임시 필드 다쓰고 지운다 
    return groupRecord;
};

/*
 * 첫번쨰인수가 레코드 또는 배열이다
 * */
/**
 * @description	미결
 * @param	{string}	varObject
 * @param	{string}	jsonGtoupKeyValue
 * @param	{number}	nGroupLevel
 * @return  {boolean}
 * @example	미결
 */
DataSet.prototype._checkIfGroupLevelKeyChanged = function(varObject, jsonGroupKeyValue, nGroupLevel){
	var keyChanged = false;
	
	var jsonKeyValue = [];
	var record = null;
	
	if (varObject instanceof Array){
		jsonKeyValue = varObject;
		
	} else if (varObject instanceof MiRecord){
		record = varObject;
		jsonKeyValue = record._jsonGroupKeyValue;
	} 
	
	for (var i = 0; i <= jsonGroupKeyValue.length - nGroupLevel; i++){
		// 그룹레벨별 키 범위내의 데이터 복사 
		var varKey1 = jsonKeyValue[i];
		var varKey2 = jsonGroupKeyValue[i]
		
		if (varKey1 instanceof Array) {
			for (var j=0; j < varKey1.length; j++) {
				if (varKey1[j] != varKey2[j]){
					keyChanged = true; break;
				}
			}
			} else{
			if (varKey1 != varKey2){
				keyChanged = true;
			}
		}
		if (keyChanged) break;
	} 
	
	return keyChanged;
};

/**
 * @description	미결
 * @param	{string}	colId
 * @return  {boolean}
 * @example	미결
 */
DataSet.prototype._isKeyColumn = function(colId){
	
	for (var i = 0; i < this._jsonGroupKey.length; i++){
		var varKey = this._jsonGroupKey[i];
		
		if (varKey instanceof Array) {
			for (var j=0; j < varKey.length; j++) {
				if (varKey[j] == colId) return true;
			}
		} else{
			if (varKey == colId) return true;
		}
	} 
	
	return false;
	
};

/**
 * 그룹핑된 논리데이터의 시작값을 하나씩 미루거나 당긴다.
 * 
 * @param nRow           추가를 시작할 위치
 * @param addCount       추가할 줄수
 */
DataSet.prototype._updateRangeStartsAfter = function(nRow, addCount) {
	if (this._GroupKey.length == 0) return;

	// 이후의 데이터의  rangeStart 속성 정리 
	for (var nRow1 = nRow; nRow1 < this.records.length; nRow1++){
		var record1 = this.records[nRow1];
		if (record1.RowType != "Logical") continue;
		if (record1.rangeStart > nRow) {
			record1.rangeStart += addCount;
		}
	}
};

/*
function findIndex(values, target) {
  return binarySearch(values, target, 0, values.length - 1);
};
*/
var lastGroupSearchIndex = -1;

/**
*     @description	미결
*     @param	{object}	records
*     @param	{object}	record
*     @param	{number}	start
*     @param	{number}	end
*     @return	{object}
*     @example	미결
*/
function binaryGroupSearch(records, record, start, end) {
	lastGroupSearchIndex = (end >= 0 &&  start > end ? end : start);
  
  if (start > end) { return -1; } //does not exist
  
  var middle = Math.floor((start + end) / 2);
  var record1 = records[middle];
  
  var compareResult = compareGroupKey(record1._jsonGroupKeyValue , record._jsonGroupKeyValue);
  if (compareResult > 0) { 
	  return binaryGroupSearch(records, record, start, middle-1); 
  }
  if (compareResult < 0) { 
	  return binaryGroupSearch(records, record, middle+1, end); 
  }
  return middle; //found!
};

/**
*     @description	미결
*     @param	{string}	jsonGroupKeyValue1
*     @param	{string}	jsonGroupKeyValue2
*     @return	{boolean}
*     @example	미결
*/
function compareGroupKey(jsonGroupKeyValue1, jsonGroupKeyValue2){
	for (var i = 0; i < jsonGroupKeyValue1.length; i++){
		var varKey1 = jsonGroupKeyValue1[i];
		var varKey2 = jsonGroupKeyValue2[i];
		
		if (varKey1 instanceof Array) {
			for (var j=0; j < varKey1.length ;j++) {
				var varSubKey1 = varKey1[j];
				var varSubKey2 = varKey2[j];
				if (varSubKey1 != null && varSubKey2 == null){
					return 1;
				} else if (varSubKey1 == null && varSubKey2 != null){
					return -1;
				} else  if (varSubKey1 > varSubKey2){
					return 1;
				} else if (varSubKey1 < varSubKey2){
					return -1;
				}
			}
		} else{
			if (varKey1 != null && varKey2 == null){
				return 1;
			} else if (varKey1 == null && varKey2 != null){
				return -1;
			} else  if (varKey1 > varKey2){
				return 1;
			} else if (varKey1 < varKey2){
				return -1;
			}
		}
	}
	// 마지막으로 jsonGroupKeyValue1까지는 같은데 jsonGroupKeyValue2가 뒤에 배열값이 더있는 경우
	// jsonGroupKeyValue2가 크다
	if (jsonGroupKeyValue1.length < jsonGroupKeyValue2.length){
		return -1;
	}
	
	return 0;
};

/**
 * @description	미결
 * @param	{string}	bUpdateGrid
 * @return  {void}
 * @example	미결
 */
DataSet.prototype._refreshGroupCation = function(bUpdateGrid){
	var captions=[];
	
	// step1 -----------------------------------------------------------
	// level별 캡션을 메모한다. 
	var levelLength = this._jsonGroupKey.length;
	var colIndexsOfGroupKey = [];
	
	for (var nGroupNdx=0; nGroupNdx < this._jsonGroupKey.length; nGroupNdx++){

    	var varKey = this._jsonGroupKey[levelLength - nGroupNdx - 1];
    	
		if (varKey instanceof Array){
			for (var nGroupNdxSub = 0; nGroupNdxSub < varKey.length; nGroupNdxSub++){
				var colId = varKey[nGroupNdxSub];
				if (colId == "") continue;
				
				colIndexsOfGroupKey[colId] = 0;
			}
			
		} else {
			var colId = varKey;
			if (colId == "") continue;
			
			colIndexsOfGroupKey[colId] = 0;
		}
	}
	
	// step2 -----------------------------------------------------------
	// record 별로 루핑을 돌면서 켑션을 기억한다
	for (var nRow=0; nRow < this.records.length; nRow++){
		var record = this.records[nRow];
		if (record._RowLevel <= 0) continue;
		
		var colId = "";
		var nGroupNdx  = record._RowLevel - 1;
    	var varKey = this._jsonGroupKey[levelLength - nGroupNdx - 1];
		if (varKey instanceof Array){
			// 하위키중 하나라도 sumMethod가 있으면 그메서드를 적용하고 
	        // 하위키 모두 있으면 나중에 나온것을 적용한다.
			for (var nGroupNdxSub = 0; nGroupNdxSub < varKey.length; nGroupNdxSub++){
				var colId0 = varKey[nGroupNdxSub];
				if (colId0 == "") continue;
				
    			if (this.colInfos[colId0].sumMethod == "TEXT") colId = colId0;
			}
			
		} else {
			if (varKey.length == 0) continue;
			if (this.colInfos[varKey].sumMethod == "TEXT") colId = varKey;
		}
		
		if (colId.length == 0) {
			record.caption = "";
			continue;
		}
		
		
		var colInfo = this.colInfos[colId];
		var sumMethod  = colInfo.sumMethod;
		var sumFormula = colInfo._sumFormula;
		var sumField   = colInfo._sumField;
		var sumText    = colInfo._sumText;
		
		var nDataRow = this._findLastNormalRowPosition(nRow);
		var recordOfData = this.records[nDataRow];
		
		var calcResult = null;
		if (sumFormula.length > 0){
			var rowLevel = record._RowLevel;
			calcResult = self[this.id + "_" + colId + "_sumFunction"](nDataRow, rowLevel);
		} else if (sumField.length > 0){
			calcResult = recordOfData.values[sumField];
		} else if (sumText.length > 0){
			calcResult = sumText;
		} else {
			calcResult = recordOfData.values[colId];
		}
		
		record.caption = calcResult;
	}
	
	
	// step3 -----------------------------------------------------------
	// 연결된 시트의 캡션을 갱신한다.
	var tmpBinds = [];

	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		
		if (bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet") continue;
		tmpBinds[bindInfo.controlName] = bindInfo.controlType;
		
		if (bindInfo.colId in colIndexsOfGroupKey){
			colIndexsOfGroupKey[bindInfo.colId] = bindInfo.colIndex;
		}
	}
	
	for (var controlName in tmpBinds){
		if( typeof(tmpBinds[controlName]) == "function" ) continue;
		if (bUpdateGrid == undefined || bUpdateGrid == false) continue;
		
		var sht = controls[controlName];
		var bindColumns = [];
		
		for (var bindkey in sht.dataBinds){
			var bindinfo = sht.dataBinds[bindkey];
			
			if( typeof bindinfo == "function" ) continue;
			if( bindinfo.datasetId != this.id ) continue;
			
			bindColumns.push( bindinfo );
		}
		
		var shtData = [];
		var rowData = null;
		var record = null;
		
		var levelofCol = 0;
		var levelofRow = 0;
		var groupLevelLength = this._jsonGroupKey.length;
		var groupKey = null;
		var groupCaption = "";
		
		if( (typeof AUIDataSheet == "function" && sht instanceof AUIDataSheet)
			|| (typeof AUIDataSheetM == "function" && sht instanceof AUIDataSheetM)
		){
			var columnInfoList = AUIGrid.getColumnInfoList(sht.AUIcontrolId);
			
			if (typeof AUIDataSheetM == "function" && sht instanceof AUIDataSheetM){
				
			}
			else{
				for(var i = 0; i < this.records.length; i++){
					record = this.records[i];
					rowData = JSON.parse( JSON.stringify(sht.defaultLayoutValue_JSON) );
					
					var dataField = null;
					var colId = null;
					var colIndex = 0;
					var value = "";
					
					for(var j = 0; j < bindColumns.length; j++){
						colId = "" + bindColumns[j].colId;
						
						if( colId == null || typeof colId == "undefined" ) continue;
						
						dataField = "f" + bindColumns[j].colIndex;
						colIndex = bindColumns[j].colIndex - 1;
						value = record.values[colId];
						
						if( record.RowType == "Logical" && colId in colIndexsOfGroupKey ){
							//그룹키 필드인 경우
							for(var groupKeyIdx = 0, levelofCol = 0, levelofRow = 0; groupKeyIdx < groupLevelLength; groupKeyIdx++){
								groupKey = this._jsonGroupKey[groupKeyIdx];
								if( groupKey instanceof Array ){
									for(var arrayGroupKeyIdx = 0; arrayGroupKeyIdx < groupKey.length; arrayGroupKeyIdx++){
										if( colId == "" + groupKey[arrayGroupKeyIdx] ){
											levelofCol = levelLength - groupKeyIdx;
											break;
										}
									}
								}
								else{
									if( colId == "" + groupKey ){
										levelofCol = levelLength - groupKeyIdx;
										break;
									}
								}
							}
							
							if( levelofCol > record._RowLevel ){
								groupCaption = "";
							}
							else{
								groupCaption = (levelofCol == record._RowLevel ? record.caption : "");
								levelofRow = record._RowLevel;
							}
							
							if(levelofRow > 0){
								rowData[dataField] = groupCaption;
							}
							else if( typeof this.formatString != "undefined" && this.dataType == "date" ){
								rowData[dataField] = maskDateFormat(columnInfoList[colIndex].formatString, value);
							}
							else{
								rowData[dataField] = value;
							}
						}
						else{
							//그룹키 필드가 아닌 경우
							rowData[dataField] = value;
						}
					}
					
					shtData[i] = rowData;
				}
			}
			
			sht.maxRows = shtData.length;
			AUIGrid.setGridData(sht.AUIcontrolId, shtData);
			
			if( typeof AUIDataSheetM == "function" && sht instanceof AUIDataSheetM ){
				if( !sht.isHiddenColumn(1) ) sht.setFixedColumnCount(1);
			}
			
			var gridData = AUIGrid.getGridData(sht.AUIcontrolId);
			if( (typeof AUIDataSheet == "function" && sht instanceof AUIDataSheet)
				|| (typeof AUIDataSheetM == "function" && sht instanceof AUIDataSheetM)
			){
				for(var nRow=0; nRow < this.records.length; nRow++){ //nRow는 AUI 그리드의 줄번호 0부터 시작
					this.records[nRow]._$uid = gridData[nRow * sht.rowsPerDataRow]._$uid;
				}
			}
			gridData = null;
			
			AUIGrid.update(sht.AUIcontrolId);
		}
		else if( typeof EasySheet == "function" && sht instanceof EasySheet ){
			var columnInfoList = sht.columns;
			var columnInfo = null;
			var fields = [];
			
			var defaultRow = {};
			var colCount = sht.maxCols;
			var recordCount = 0;
			var i = 0; var j = 0;
			
			for(i = 0; i < colCount; i++, columnInfo = null){
				columnInfo = columnInfoList[i];
				defaultRow[columnInfo.colId] = (typeof columnInfo.defaultValue == "function") ? columnInfo.defaultValue() : columnInfo.defaultValue;
				
				fields[i] = {field: columnInfo.colId};
			}
			
			for(i = 0, colCount = bindColumns.length, recordCount = this.records.length; i < recordCount; i++, record = null){
				record = this.records[i];
				rowData = JSON.parse(JSON.stringify(defaultRow));
				
				var columnId = null;
				var columnIndex = 0;
				var dsColId = null;
				var value = "";
				
				for(j = 0; j < colCount; j++){
					dsColId = "" + bindColumns[j].colId;
					if( dsColId == null || typeof dsColId == "undefined" ) continue;
					
					colIndex = bindColumns[j].colIndex - 1;
					if( colIndex < 0 ) continue;
					
					columnId = columnInfoList[colIndex].colId;
					value = record.values[dsColId];
					
					if( record.RowType == "Logical" && colId in colIndexsOfGroupKey ){
						//그룹키 필드인 경우
						for(var groupKeyIdx = 0, levelofCol = 0, levelofRow = 0; groupKeyIdx < groupLevelLength; groupKeyIdx++){
							groupKey = this._jsonGroupKey[groupKeyIdx];
							if( groupKey instanceof Array ){
								for(var arrayGroupKeyIdx = 0; arrayGroupKeyIdx < groupKey.length; arrayGroupKeyIdx++){
									if( colId == "" + groupKey[arrayGroupKeyIdx] ){
										levelofCol = levelLength - groupKeyIdx;
										break;
									}
								}
							}
							else{
								if( colId == "" + groupKey ){
									levelofCol = levelLength - groupKeyIdx;
									break;
								}
							}
						}
						
						if( levelofCol > record._RowLevel ){
							groupCaption = "";
						}
						else{
							groupCaption = (levelofCol == record._RowLevel ? record.caption : "");
							levelofRow = record._RowLevel;
						}
						
						if(levelofRow > 0){
							rowData[columnId] = groupCaption;
						}
						else if( typeof this.formatString != "undefined" && this.dataType == "date" ){
							rowData[columnId] = maskDateFormat(columnInfoList[colIndex].dateFormat, value);
						}
						else{
							rowData[columnId] = value;
						}
					}
					else{
						//그룹키 필드가 아닌 경우
						rowData[columnId] = value;
					}
				}
				
				shtData[i] = rowData;
			}
			
			sht.maxRows = shtData.length;
			sht.setData({fieldList: fields, recordList: shtData, rowCount: sht.maxRows}, false);
			
			for(i = 0, recordCount = this.records.length; i < recordCount; i++){
				this.records[i]._$uid = sht.rows(i).rowId;
			}
			
			sht.refreshColumns();
		}
	}
	
	tmpBinds.clear();
	
	return;
};

/**
*     @description	미결
*     @param	{string}	sheetName
*     @param	{string}	uid
*     @param	{object}	jsonObject
*     @return	{string}
*     @example	미결
*/
function getSumText(sheetName, uid, jsonObject){
	
	var control = controls[sheetName];
	
	var tmpBinds = []; colIds = [];
	for (var key in control.dataBinds){
		var bindInfo = control.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		
		if (bindInfo.controlName != control.controlName) continue;
		tmpBinds[bindInfo.datasetId] = bindInfo.controlType;
		colIds[bindInfo.colIndex - 1] = bindInfo.colId;

    }
	
	for (var datasetId in tmpBinds){
		if( typeof(tmpBinds[datasetId]) == "function" ) continue;
		var dataSet = dataSets[datasetId];
		
		var nRow = dataSet.getIndexOf_$uid(uid);
		if (nRow == -1) continue;
		
		// 키필드가 아니면 빠진다
		var colId = colIds[jsonObject.colNdx];
		if (colId == undefined)  return;
		if (!dataSet.colInfos[colId]._isGroupKeyField) return;
		
		var record = dataSet.records[nRow];
		if (record.RowType != "Logical") continue;
		
		// 레코드가 레벨 2이고 첫칸 이상이면 0 / 레벨 1이고 두번째  칸 이상이면 
		var levelofCol = 0;
		var levelLength = dataSet._jsonGroupKey.length;
		
		for (var nGroupNdx=0; nGroupNdx < levelLength; nGroupNdx++){
			var varKey = dataSet._jsonGroupKey[nGroupNdx];
			if (varKey instanceof Array){
				for (var nGroupNdxSub = 0; nGroupNdxSub < varKey.length; nGroupNdxSub++){
					if (colId == varKey[nGroupNdxSub]){
						levelofCol = levelLength - nGroupNdx;
						break;
					}
				}
			} else {
				if (colId == varKey){
					levelofCol = levelLength - nGroupNdx;
					break;
				}
			}
		}
		
		if (levelofCol > record._RowLevel){
			// 통과
			return;
		}
		jsonObject.caption = (levelofCol == record._RowLevel ? record.caption : "");
		jsonObject.rowLevel = record._RowLevel;
		
		break;
		
	}
	
	return;

};

//사용함수 
function pad2(n) { return n < 10 ? '0' + n : n };

//*** Pivot ****         *** Pivot ****         *** Pivot ****         *** Pivot ****         *** Pivot ****         *** Pivot ****        
//Pivot에서 참조하는 데이터셋 이름

/**
 * Dataset이 Bind할 DataSet Object를 리턴하는 Proeprty 입니다.
 * 
 * @param addCount       추가할 줄수
 * @return               (DataSet) Binde된 DataSet
 */
DataSet.prototype.getDataObject = function(){ return this._DataObject;};

/**
 * Dataset이 Bind할 DataSet Object를 지정하는 Proeprty 입니다.
 * 
 * @param dataObject     (DataSet) Bind할 DataSet Object
 */
DataSet.prototype.setDataObject = function(dataObject){
	this._DataObject = dataObject;

	if (dataObject.records.length == 0) return;
	this._refreshPivot();
	return;
};

/**
 * Pivot Dataset이 Bind된 시트를 초기화
 * 
 * @param dataObject     (DataSet) Bind할 DataSet Object
 */
DataSet.prototype.initPivotSheet = function(){
	var sheetName = "";
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet") continue;
		
		sheetName = bindInfo.controlName;
		controls[sheetName].pivotBound = true;
		var AUIcontrolId = controls[sheetName].AUIcontrolId;
		var gridData = [];
	    AUIGrid.setGridData(AUIcontrolId, gridData);
	    
	    //   헤더 숨기기 
	    for (var i= 0; i< AUIGrid.getColumnInfoList(AUIcontrolId).length;i++){
	    	var dataField = AUIGrid.getDataFieldByColumnIndex(AUIcontrolId, i);
	    	AUIGrid.hideColumnByDataField(AUIcontrolId, dataField);
	    }
	}
	return;
};

/**
 * @description	미결
 * @return  {void}
 * @example	미결
 */
DataSet.prototype._refreshPivot = function(){
	// STEP0 -----------------------------------------------------------------
	// 바인드된 시트객체를 를 찾고 데이터 필드를 메모한다

	// _jsonPivotKey가 생성되지 않았으면 생성한다.
	this._jsonPivotKey.clear();
	var levelKeyArr = this._PivotKey.split(",");
	for (var i=0; i < levelKeyArr.length; i++){
		var levelKey = levelKeyArr[i];
		if (levelKey.indexOf(":") >= 0){
			this._jsonPivotKey[i] = levelKey.split(":");
		} else {
			this._jsonPivotKey[i] = levelKey;
		}
	}

	this._jsonGroupKey.clear();
	levelKeyArr = this._GroupKey.split(",");
	for (var i=0; i < levelKeyArr.length; i++){
		var levelKey = levelKeyArr[i];
		if (levelKey.length == 0) continue;
		
		if (levelKey.indexOf(":") >= 0){
			this._jsonGroupKey[i] = levelKey.split(":");
		} else {
			this._jsonGroupKey[i] = levelKey;
		}
	}

	// 피벗키 길이 
	var pivotKeyLength = this._jsonPivotKey.length;
	var groupKeyLength = this._jsonGroupKey.length;

	var sheetName = "";
	var arrItemColIds = []; 
	var arrItemLayouts = []; 
	for (var key in this.dataBinds){
		var bindInfo = this.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		if (bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet") continue;
		
		sheetName = bindInfo.controlName;
		arrItemColIds[ bindInfo.colIndex - 1 ] =  bindInfo.colId;
		// 피벗집계키가 세개라면 피벗키의 길이(pivotKeyLength)는 3이고 마지막 집계키의 레벨도 3(1부터 시작되므로)
		// 시트의 데이터 헤더 레벨은 그 한단 아래로 " + 1" 해주어야 한다.
		var maxLevel = pivotKeyLength;
		if (bindInfo.colIndex <= groupKeyLength){
			arrItemLayouts[ bindInfo.colId ] = getColumnObjectFromSheet(sheetName, 1, 0, bindInfo.colIndex) ; 
		} else {
			arrItemLayouts[ bindInfo.colId ] = getColumnObjectFromSheet(sheetName, maxLevel + 1, groupKeyLength, bindInfo.colIndex - groupKeyLength) ; 
		}
		
	}
	if (sheetName == "") return; // 연결된 시트가 없으면 빠진다.
	
	var arrFormulaOfLevel =[];
    for (var nPivotLevel = 1; nPivotLevel <= pivotKeyLength; nPivotLevel++ ){
    	var formula = getColumnObjectFromSheet(sheetName, nPivotLevel, groupKeyLength, 1).headerText;
    	if (formula.trim().length == 0){
    		arrFormulaOfLevel[nPivotLevel] = "";
    		continue;
    	} 
    	if (typeof this._DataObject.colInfos[formula] != "undefined"){
    		arrFormulaOfLevel[nPivotLevel] = formula;
    		continue;
    	}
    	
    	arrFormulaOfLevel[nPivotLevel] = "formula:" + formula;
    }
    
    // 피벗키, 그룹키  생략정보 미리 파악
    for (var nPivotLevel = 1; nPivotLevel <= pivotKeyLength; nPivotLevel++ ){
    	var wKey = this._jsonPivotKey[nPivotLevel - 1];
    	if (wKey instanceof Array){
    		this._needPivotKey[nPivotLevel] = false;
    		
       		for (var nSubLevel = 0; nSubLevel < wKey.length; nSubLevel++ ){
		    	var colId =  wKey[nSubLevel];
		    	var sumMethod = this._DataObject.colInfos[colId].sumMethod;
		    	if (sumMethod.trim().length != 0){
		    		this._needPivotKey[nPivotLevel] = true;
		    		break;
		    	}
       		}
    		
    	} else {
        	var colId = wKey;
        	var sumMethod = this._DataObject.colInfos[colId].sumMethod;
        	this._needPivotKey[nPivotLevel] = (sumMethod.trim().length != 0);
    	}
    	
    }

    for (var nGroupLevel = 1; nGroupLevel <= groupKeyLength; nGroupLevel++ ){
    	var wKey = this._jsonGroupKey[nGroupLevel - 1];
    	
    	if (wKey instanceof Array){
    		this._needGroupKey[nGroupLevel] = false;
    		for (var nSubLevel = 0; nSubLevel < wKey.length; nSubLevel++ ){
    		    	var colId =  wKey[nSubLevel];
    		    	var sumMethod = this._DataObject.colInfos[colId].sumMethod;
    		    	if (sumMethod.trim().length != 0){
    		    		this._needGroupKey[nGroupLevel] = true;
    		    		break;
    		    	}
    		}
    		
    	} else {
        	var colId = wKey;
        	var sumMethod = this._DataObject.colInfos[colId].sumMethod;
        	this._needGroupKey[nGroupLevel] = (sumMethod.trim().length != 0);
    	}
    }
	
	// STEP1 -----------------------------------------------------------------
	// Pivot 키를 만들고 
	// 그룹키가 없어도 있다 없어 지는 경우가 있으므로 두어야 한다 
	var arrPivotKeys = []; ndx = 0;
	var arrPivotCaptions = []; // 캡션이 들어가는 난
	
	for (var nRowNF = 0; nRowNF < this._DataObject.buffer.length; nRowNF++){
		var record = this._DataObject.buffer[nRowNF];
		if (record.RowType == "Logical") continue;
		
		arrPivotCaptions[ndx] = this._makePivotCaption(record, arrFormulaOfLevel, nRowNF);
		
		record._jsonPivotKeyValue = this._makePivotKey(record);
		arrPivotKeys[ndx] = this._clonePivotKey(record._jsonPivotKeyValue);
		arrPivotKeys[ndx].ndx = ndx; // <-- 소팅후 arrPivotCaptions을 순서를 같게 만드는 작업을 위해서 기록
		
		ndx++;
	}
	
	var arrGroupCaptions = []; // 그룹의 상단 캡션이 들어가는 난
	for (var i=0; i < groupKeyLength; i++){
		var colId = arrItemColIds[i];
		arrGroupCaptions[i] = arrItemLayouts[ colId ].headerText;
	}
	
	// GroupKey를 만들고 
	var arrGroupKeys = []; ndx = 0;
	for (var nRowNF = 0; nRowNF < this._DataObject.buffer.length; nRowNF++){
		var record = this._DataObject.buffer[nRowNF];
		if (record.RowType == "Logical") continue;
		
		record._jsonGroupKeyValue = this._makeGroupKey(record);
		arrGroupKeys[ndx] = this._clonePivotKey(record._jsonGroupKeyValue);
		
		
		var arrLabel = new Array(groupKeyLength);
		for (var i=0; i < groupKeyLength; i++){
			var colId = arrItemColIds[i];
			arrLabel[i] = record.values[colId];
		}
		arrGroupKeys[ndx].arrLabel = arrLabel;
		
		ndx++;
	}
	
	// STEP2 -----------------------------------------------------------------
	// pivot Key Sort
	arrPivotKeys.sort(function(arrKey1, arrKey2){return compareGroupKey(arrKey1, arrKey2);});
	
	// group Key Sort
	arrGroupKeys.sort(function(arrKey1, arrKey2){return compareGroupKey(arrKey1, arrKey2);});
	
	// STEP3 -----------------------------------------------------------------
    // pivot 키 중복 제거
	var belowKey = [];
	for (var i = arrPivotKeys.length - 1; i >= 0; i--){
		if (belowKey.length != 0){
			if (compareGroupKey(arrPivotKeys[i], belowKey) == 0){
				arrPivotKeys.splice(i, 1);
				continue;
			}
		}
		belowKey = arrPivotKeys[i];
	}
	
	// group 키 중복 제거
	belowKey = [];
	for (var i = arrGroupKeys.length - 1; i >= 0; i--){
		if (belowKey.length != 0){
			if (compareGroupKey(arrGroupKeys[i], belowKey) == 0){
				arrGroupKeys.splice(i, 1);
				continue;
			}
		}
		belowKey = arrGroupKeys[i];
	}
	delete belowKey;
	this._rowCount_NonGroup = arrGroupKeys.length;

	// arrPivotCaptions 순서 맞추기 
	var tmpArrPivotCaptions = [];
	for (var i = 0; i < arrPivotKeys.length; i++){
		var ndx = arrPivotKeys[i].ndx;
		tmpArrPivotCaptions[i] = arrPivotCaptions[ndx];
		delete arrPivotKeys[i].ndx;
	}
	
	for (var i = arrPivotCaptions.length - 1; i >= 0; i--){
		arrPivotCaptions.pop();
	}

	// ndx재부여
	for (var i = 0; i < arrPivotKeys.length; i++){
		arrPivotKeys[i].ndx = i;
	}
	
	arrPivotCaptions = tmpArrPivotCaptions;
	tmpArrPivotCaptions = null;
	
	// STEP4 -----------------------------------------------------------------
	// pivot 집계키 만들기
	var pivotItemKey= [];
    var pivotLevelKeys= [null];
    var pivotLevelKey = [];
    
	var pivotItemCaption= [];
    var pivotLevelCaptions= [null];
    var pivotLevelCaption = [];
	var levelCount = this._jsonPivotKey.length;
    
    // 데이터를 처음부터 끝까지 돌리면서 레벨 정보를 집계한다
    // 사용변수    
    //           arrPivotKeys: 피벗키 목록, pivotItemKey: 피벗 목록중의 작업대상 하나,    
    //           arrPivotCaptions: 피벗 캡션 목록, pivotItemCaption: 피벗 캡션 목록중 하나의 피벗 캡션    
    //           pivotLevelKeys:  단계별 여러 집계데이터의 피벗 키 , pivotLevelKey: 집계데이터내의  하나의 피벗키
    //           pivotLevelCaptions:  단계별 여러 집계데이터의 피벗 캡션 , pivotLevelCaption: 집계데이터내의  하나의 캡션
    for (var nRow = 0; nRow < arrPivotKeys.length; nRow++){
    	pivotItemKey = arrPivotKeys[nRow];
    	pivotItemCaption = arrPivotCaptions[nRow];
    	
    	if (nRow == 0){
    		// 레벨별 그룹데이터를 만들고 첫데이터를 기준으로키값을 세팅한다
    	    for (var nPivotLevel = 1; nPivotLevel <= levelCount; nPivotLevel++ ){
    	    	if (!this._needPivotKey[nPivotLevel]) continue;
    	    	pivotLevelKeys[nPivotLevel] = this._makePivotLevelKey(pivotItemKey, nPivotLevel);
    	    	pivotLevelCaptions[nPivotLevel] = this._makePivotLevelCaption(pivotItemCaption, nPivotLevel); 
    	    }
    	    continue;
    	}

	    for (var nPivotLevel = levelCount;  nPivotLevel >= 1; nPivotLevel-- ){
	    	if (!this._needPivotKey[nPivotLevel]) continue;
	    	
	    	pivotLevelKey = pivotLevelKeys[nPivotLevel];
	    	pivotLevelCaption = pivotLevelCaptions[nPivotLevel];
	    	
	    	// 필터링 안된 첫데이터가 아니면서, 키가 바뀌었으면
	    	var keyChanged = (nRow > 0 && _checkIfPivotLevelKeyChanged(pivotItemKey, pivotLevelKey, nPivotLevel));

	    	// 키가 변경되었으면 논리레코드를 추가하고 새로운 레코드를 만든다 
    		if (keyChanged){
    			// 레코드 추가 
    			arrPivotKeys.splice(nRow, 0, pivotLevelKey);
    			arrPivotCaptions.splice(nRow, 0, pivotLevelCaption);
 
    			nRow++;
    			
    			// 레코드 초기화 
     	    	pivotLevelKeys[nPivotLevel] = this._makePivotLevelKey(pivotItemKey, nPivotLevel);
     	    	pivotLevelCaptions[nPivotLevel] = this._makePivotLevelCaption(pivotItemCaption, nPivotLevel);
    		}
	    } // 그룹 레벨별 루프 종료 
	    
	}
		
    for (var  nPivotLevel = levelCount;  nPivotLevel >= 1;nPivotLevel-- ){
    	if (!this._needPivotKey[nPivotLevel]) continue;

    	arrPivotKeys.push(pivotLevelKeys[nPivotLevel]);
    	arrPivotCaptions.push(pivotLevelCaptions[nPivotLevel]);
    }
	
	// 그룹별 데이터 채우기 
    var groupLevelKeys= [null];
    var groupItemKey= [];
    var groupLevelKey = []
	levelCount = this._jsonGroupKey.length;
    
    // 데이터를 처음부터 끝까지 돌리면서 레벨 정보를 집계한다
    for (var nRow = 0; nRow < arrGroupKeys.length; nRow++){
    	groupItemKey = arrGroupKeys[nRow];
    	
    	if (nRow == 0){
    		// 레벨별 그룹데이터를 만들고 첫데이터를 기준으로키값을 세팅한다
    	    for (var nGroupLevel = 1; nGroupLevel <= levelCount; nGroupLevel++ ){
    	    	if (!this._needGroupKey[nGroupLevel]) continue;
    	    	groupLevelKeys[nGroupLevel] = this._makePivotLevelKey(groupItemKey, nGroupLevel);
    	    }
    	    continue;
    	}

	    for (var nGroupLevel = levelCount;  nGroupLevel >= 1; nGroupLevel-- ){
	    	if (!this._needGroupKey[nGroupLevel]) continue;

	    	groupLevelKey = groupLevelKeys[nGroupLevel];
	    	
	    	// 필터링 안된 첫데이터가 아니면서, 키가 바뀌었으면
	    	var keyChanged = (nRow > 0 && _checkIfPivotLevelKeyChanged(groupItemKey, groupLevelKey, nGroupLevel));

	    	// 키가 변경되었으면 논리레코드를 추가하고 새로운 레코드를 만든다 
    		if (keyChanged){
    			// 레코드 추가 
    			arrGroupKeys.splice(nRow, 0, groupLevelKey);
 
    			nRow++;
    			
    			// 레코드 초기화 
     	    	groupLevelKeys[nGroupLevel] = this._makePivotLevelKey(groupItemKey, nGroupLevel);
    		}
	    } // 그룹 레벨별 루프 종료 
	    
	}
		
    for (var nGroupLevel = levelCount; nGroupLevel >= 1; nGroupLevel-- ){
    	if (!this._needGroupKey[ nGroupLevel]) continue;
    	
    	arrGroupKeys.push(groupLevelKeys[nGroupLevel]);
    }
    
	// STEP5-0 -----------------------------------------------------------------
    // 헤더의 자식 카운트수 집계  
	for (var pivotNdx=0; pivotNdx < arrPivotKeys.length; pivotNdx++){
		if (arrPivotKeys[pivotNdx][pivotKeyLength - 1] == null) continue;
		
		var arrPivotKey = this._clonePivotKey(arrPivotKeys[pivotNdx]);
	    for (var ndx = pivotKeyLength - 1; ndx >= 0; ndx--){
			arrPivotKey[ndx] = null;
	    	if (!this._needPivotKey[ndx + 1]) continue;

	    	var colIndex = binaryPivotSearch(arrPivotKeys, arrPivotKey, 0, arrPivotKeys.length - 1);
			if (colIndex == -1){
				if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_020", "Pivot 위치를 찾지 못했습니다."));
				continue;
			}
			if (typeof arrPivotKeys[colIndex].cnt == "undefined"){
				arrPivotKeys[colIndex].cnt = 1;
			} else {
				arrPivotKeys[colIndex].cnt += 1;
			}
	    }
	}
	for (var groupNdx=0; groupNdx < arrGroupKeys.length; groupNdx++){
		if (arrGroupKeys[groupNdx][groupKeyLength - 1] == null) continue;
		
		var arrGroupKey = this._clonePivotKey(arrGroupKeys[groupNdx]);
	    for (var ndx = groupKeyLength - 1; ndx >= 0; ndx--){
			arrGroupKey[ndx] = null;
			
	    	if (!this._needGroupKey[ndx + 1]) continue;
			
			var rowIndex = binaryPivotSearch(arrGroupKeys, arrGroupKey, 0, arrGroupKeys.length - 1);
			if (rowIndex == -1){
				if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_021", "Group 위치를 찾지 못했습니다."));
				continue;
			}
			if (typeof arrGroupKeys[rowIndex].cnt == "undefined"){
				arrGroupKeys[rowIndex].cnt = 1;
			} else {
				arrGroupKeys[rowIndex].cnt += 1;
			}
	    }
	}

	// STEP5 -----------------------------------------------------------------
    // Pivot 데이터에 데이 칼럼명 추가
    // 피봇키가 아닌항목까지를 키에 추가한다  
    var arrResultPivotKeys = [];
    var arrResultPivotCaptions = [];
    var ndx = 0;
	for (var i = 0; i < arrPivotKeys.length; i++){
		for (var j=groupKeyLength; j < arrItemColIds.length; j++){
			var tmpArrKey = this._clonePivotKey(arrPivotKeys[i]);
			var tmpArrCaption = this._clonePivotKey(arrPivotCaptions[i]);
			
			var colId = arrItemColIds[j];
			tmpArrKey[pivotKeyLength] = arrItemColIds[j]; // 데이터 한칸 더추가
			tmpArrCaption[pivotKeyLength] = arrItemLayouts[ colId ].headerText; // 데이터 한칸 더추가
			
			arrResultPivotKeys[ndx] = tmpArrKey;
			arrResultPivotCaptions[ndx] = tmpArrCaption;
			
			if (typeof arrPivotKeys[i].ndx != "undefined") {
				arrResultPivotKeys[ndx].ndx = arrPivotKeys[i].ndx;
			}
			if (typeof arrPivotKeys[i].cnt != "undefined") {
				arrResultPivotKeys[ndx].cnt = arrPivotKeys[i].cnt;
			}
			ndx++;
		}
	}
	
	// 배열
	for (var i = arrPivotKeys.length - 1; i >= 0; i--){
		arrPivotKeys.pop();
		arrPivotCaptions.pop();
	}

	arrPivotKeys = arrResultPivotKeys;
	arrResultPivotKeys = null;
	arrPivotCaptions = arrResultPivotCaptions;
	arrResultPivotCaptions = null;
    
	
	// footer 레코드 생성 
	var arrFooterSums = new Array(arrPivotKeys.length);
	for (var i = 0; i < arrPivotKeys.length; i++){
		arrFooterSums[i] = {sum: 0, max: null, min: null, count: 0};
	}
    this._arrFooterSums = arrFooterSums;
	
	// STEP6 -----------------------------------------------------------------
    // 데이터 들어갈 배열 선언 
    var maxRows = arrGroupKeys.length;
    var maxCols = arrPivotKeys.length;
    var arrDatas = [];
    for (var nRow=0; nRow < maxRows; nRow++){
    	arrDatas[nRow] = new Array(maxCols);
    }
	
	// 다음 동작을 위하여 메모 
	this._arrPivotKeys = arrPivotKeys;
	this._arrGroupKeys = arrGroupKeys;
	this._arrDatas     = arrDatas;
	this._arrItemColIds = arrItemColIds;
	this._sheetName    = sheetName;
	
	// colId가 알파벳순이 아니므로 바이너리 서치를 또하나의 서칭어래이 만들고 
	// 월래 칼럽인덱스를 기록한다 
	var arrPivotKeysForSearch = [];
	for (var i = 0; i < arrPivotKeys.length; i++){
		arrPivotKeysForSearch[i] = arrPivotKeys[i];
		arrPivotKeysForSearch[i].seq = i;
	}
	arrPivotKeysForSearch.sort(function(arrKey1, arrKey2){return comparePivotKey(arrKey1, arrKey2);});
	this._arrPivotKeysForSearch = arrPivotKeysForSearch;
	
    // 데이터 넣기
	for (var nRowNF = 0; nRowNF < this._DataObject.buffer.length; nRowNF++){
		var record = this._DataObject.buffer[nRowNF];
		if (record.RowType == "Logical") continue;
		
		for (var i = groupKeyLength; i < arrItemColIds.length; i++){
			var colId = arrItemColIds[i];
			var sumMethod = this._DataObject.colInfos[colId].sumMethod;
			var value = record.values[colId];
			
			
			// 피벗 셀 갱신
			var arrPivotKey = this._clonePivotKey(record._jsonPivotKeyValue);
			var arrGroupKey = this._clonePivotKey(record._jsonGroupKeyValue);
			
			var jsonResult = setPivotCell(arrDatas, value, arrGroupKey, arrPivotKey, arrPivotKeys, arrGroupKeys, colId, pivotKeyLength, null, arrPivotKeysForSearch);
			// 반환형 jsonResult = {row: n, col: n, value: n}
			
			
			// 집계값 갱신 
			this._updatePivotSum(colId, sumMethod, value, arrPivotKey, arrGroupKey);
			
			// footer값 갱신 
			// jsonResult = {row: n, col: n, value: n}  // arrFooterSums[i] = {sum: 0, max: null, min: null, count: 0};
			var footerSum = arrFooterSums[jsonResult.col]; 
			footerSum.sum += value;
			footerSum.max = (footerSum.max == null ? value : (footerSum.max > value ? footerSum.max : value));
			footerSum.min = (footerSum.min == null ? value : (footerSum.max < value ? footerSum.max : value));
			footerSum.count++;
			footerSum.sumMethod = sumMethod;
		}
		
	}

    // 별도의 열추가 시작  ===================
    if (this.arrMoreSumInfos.length > 0){    // 형식: [{headerText:"XXX", colId:"XXX", sumMethod:"XXX"}, ...]
    	this.arrMoreColumnDatas.clear();
    	for (var moreNdx = 0; moreNdx < this.arrMoreSumInfos.length; moreNdx++){
    		var moreSumInfo = this.arrMoreSumInfos[moreNdx];
 	        this.arrMoreColumnDatas[moreNdx] = this.addivotColumnToLast(moreSumInfo.colId, moreSumInfo.sumMethod, moreSumInfo);   		
    	}
    }
    // 별도의 열 추가 종료 ===================


	// 시트를 그린다
	this.setPivotToSheet(arrPivotCaptions, arrGroupCaptions, arrItemLayouts);
	return;
};

// 리턴값 [{row:줄번호, col:칼럼번호, value:변경값}, ... ]
/**
 * @description	미결
 * @param	{string}	colId
 * @param	{string}	sumMethod
 * @param	{string}	value
 * @param	{string}	arrPivotKey_p
 * @param	{string}	arrGroupKey_p
 * @return  {object}
 * @example	미결
 */
DataSet.prototype._updatePivotSum = function(colId, sumMethod, value, arrPivotKey_p, arrGroupKey_p) {
	var arrPivotKeysForSearch = this._arrPivotKeysForSearch;
	var arrCellsToUpdate = [];
	var ndx = 0;
	
	var arrPivotKeys = this._arrPivotKeys;
	var arrGroupKeys = this._arrGroupKeys;
	var arrDatas     = this._arrDatas;
	var arrFooterSums = this._arrFooterSums;
	
	var pivotKeyLength = this._jsonPivotKey.length;
	var groupKeyLength = this._jsonGroupKey.length;

	// 피벗합계 갱신
	arrPivotKey = this._clonePivotKey(arrPivotKey_p);
	arrGroupKey = this._clonePivotKey(arrGroupKey_p);
	for (var pivotNdx = pivotKeyLength - 1; pivotNdx >= 0; pivotNdx--){
		arrPivotKey[pivotNdx] = null;
		
		if (!this._needPivotKey[pivotNdx + 1]) continue;
		var jsonResult = setPivotCell(arrDatas, value, arrGroupKey, arrPivotKey, arrPivotKeys, arrGroupKeys, colId, pivotKeyLength, sumMethod, arrPivotKeysForSearch);
		arrCellsToUpdate[ndx++] = jsonResult;

		// footer값 갱신 
		// jsonResult = {row: n, col: n, value: n}  // arrFooterSums[i] = {sum: 0, max: null, min: null, count: 0};
		var footerSum = arrFooterSums[jsonResult.col]; 
		footerSum.sum += value;
		footerSum.max = (footerSum.max == null ? value : (footerSum.max > value ? footerSum.max : value));
		footerSum.min = (footerSum.min == null ? value : (footerSum.max < value ? footerSum.max : value));
		footerSum.count++;
		footerSum.sumMethod = sumMethod;
	
	}
	
	// 그룹피벗합계갱신
	arrPivotKey = this._clonePivotKey(arrPivotKey_p);
	arrGroupKey = this._clonePivotKey(arrGroupKey_p);
	for (var groupNdx = groupKeyLength - 1; groupNdx >= 0; groupNdx--){
		arrGroupKey[groupNdx] = null;

		if (!this._needGroupKey[groupNdx + 1]) continue;
		arrCellsToUpdate[ndx++] = setPivotCell(arrDatas, value, arrGroupKey, arrPivotKey, arrPivotKeys, arrGroupKeys, colId, pivotKeyLength, sumMethod, arrPivotKeysForSearch);
	}
	
	// 그룹&피벗 합계갱신 
	arrPivotKey = this._clonePivotKey(arrPivotKey_p);
	arrGroupKey = this._clonePivotKey(arrGroupKey_p);
	for (var groupNdx = groupKeyLength - 1; groupNdx >= 0; groupNdx--){
		arrGroupKey[groupNdx] = null;

		if (!this._needGroupKey[groupNdx + 1]) continue;

		arrPivotKey = this._clonePivotKey(arrPivotKey_p);
	    for (var pivotNdx = pivotKeyLength - 1; pivotNdx >= 0; pivotNdx--){
			arrPivotKey[pivotNdx] = null;

			if (!this._needPivotKey[pivotNdx + 1]) continue;
			arrCellsToUpdate[ndx++] = setPivotCell(arrDatas, value, arrGroupKey, arrPivotKey, arrPivotKeys, arrGroupKeys, colId, pivotKeyLength, sumMethod, arrPivotKeysForSearch);
	    }
	}
	
	return arrCellsToUpdate; 
};

/**
 * @description	미결
 * @param	{string}	arrPivotCaptions
 * @param	{string}	arrGroupCaptions
 * @param	{string}	arrItemLayouts
 * @return  {boolean}
 * @example	미결
 */
DataSet.prototype.setPivotToSheet = function(arrPivotCaptions, arrGroupCaptions, arrItemLayouts){
	var arrPivotKeys = this._arrPivotKeys;
	var arrGroupKeys = this._arrGroupKeys;
	var arrDatas     = this._arrDatas;
	var sheetName    = this._sheetName;
	
	var jsonPivotKey = this._jsonPivotKey;
	var jsonGroupKey = this._jsonGroupKey;

	
	var sumMethods = [];
	for (var key in this._DataObject.colInfos){
		if (typeof this._DataObject.colInfos[key] == "function") continue;
		sumMethods[key] = this._DataObject.colInfos[key].sumMethod;
	}
	this._sumMethods = sumMethods;

	// STEP 1: 그룹항목의 좌상단 헤더 만들기
	var columnLayout = [];
	for (var i = 0; i < jsonGroupKey.length; i++){
		var varKey = jsonGroupKey[i];
		var strGroupKey = (varKey instanceof Array ? varKey.join("_") : varKey);
		
		var columnInfo = {
				dataField : strGroupKey,
				headerText : arrGroupCaptions[i],
				width : 140,
				cellMerge : true
			};
		
		var ItemLayout = arrItemLayouts[varKey];
		while(typeof ItemLayout != "undefined" && typeof ItemLayout.children != "undefined"){ ItemLayout = ItemLayout.children[0]; }
		for (var key in ItemLayout){
			if (key != "labelFunction" && key != "styleFunction" && typeof ItemLayout[key] == "function") continue;
			var lKey = key.toLowerCase();
			if (lKey == "children" || lKey == "headertext" || lKey == "cellmerge" || lKey == "datafield") continue;
			
			columnInfo[key] = ItemLayout[key];
		}
		
		//2016-07-06 : 그룹항목은 수정되면 안되므로 editable 속성을 false로 수정함
		columnInfo.editable = false;
		
		if (i > 0) columnInfo.mergePolicy = "restrict";
		columnLayout.push(columnInfo);
	}
	
	// STEP 2: 피벗 항목의 상단 헤더 만들기
	var pivotLevelKeys= [];
	var columnInfoOfLevels = [];
	
	var levelCount = jsonPivotKey.length;

    for (var i=0; i < arrPivotKeys.length; i++){
    	var arrPivotKey = arrPivotKeys[i];
    	var arrPivotCaption = arrPivotCaptions[i];
    	
		for (var nPivotLevel = 1; nPivotLevel <= levelCount + 1; nPivotLevel++ ){

	    	pivotLevelKey = pivotLevelKeys[nPivotLevel];
	    	
	    	if (i == 0 || nPivotLevel == levelCount + 1 || _checkIfPivotLevelKeyChanged(arrPivotKey, pivotLevelKey, nPivotLevel + 1)){
	    		var columnInfo = {
	    				headerText : arrPivotCaption[nPivotLevel - 1],
	    				cellMerge : false
	    			};
	    		
	    		if (nPivotLevel == levelCount + 1){
					var colId = arrPivotKey[nPivotLevel - 1];
	    			columnInfo.dataField = colId + "_" + i;
	    			
	    			var ItemLayout = arrItemLayouts[colId];
	    			while(typeof ItemLayout != "undefined" && typeof ItemLayout.children != "undefined"){ ItemLayout = ItemLayout.children[0]; }
	    			for (var key in ItemLayout){
	    				if (key != "labelFunction" && key != "styleFunction" && typeof ItemLayout[key] == "function") continue;
	    				var lKey = key.toLowerCase();
	    				if (lKey == "children" || lKey == "headertext" || lKey == "cellmerge" || lKey == "datafield") continue;
	    				
	    				columnInfo[key] = ItemLayout[key];
	    			}
	    			
	    			// 합계셀은 편집이 안되게 한다 
	    			if (arrPivotKey.length > 1 && arrPivotKey[arrPivotKey.length - 2]  == null){
	    				columnInfo["editable"] = false;
	    			}
	    		} else {
	    			columnInfo.children = [];
	    		}
	    		
	    		if (nPivotLevel == 1){
	    			columnLayout.push(columnInfo);

	    		} else {
	    			columnInfoOfLevels[nPivotLevel - 1].children.push(columnInfo);
	    		}
	    		columnInfoOfLevels[nPivotLevel] = columnInfo;
	    		
	    		// 레벨별 키 기억
	    		pivotLevelKeys[nPivotLevel] = arrPivotKey;
	    	}
	    } // 그룹 레벨별 루프 종료 
    }

    // 별도의 열추가 시작  ===================
    if (this.arrMoreSumInfos.length > 0){    // 형식: [{headerText:"XXX", colId:"XXX", sumMethod:"XXX"}, ...]
    	for (var moreNdx = 0; moreNdx < this.arrMoreSumInfos.length; moreNdx++){
    		var moreSumInfo = this.arrMoreSumInfos[moreNdx];

	    	// 사용자가 부여한 파라메터 항목 
	    	var dataField = moreSumInfo.colId + "_" + moreSumInfo.sumMethod;
			var columnInfo = {headerText: moreSumInfo.headerText, dataField: dataField,
			                                            editable: false, cellMerge : false}; // 디폴트값 부여 [편집 불가능 하게 조치 ]
	        var addedColumnInfo =moreSumInfo.columnInfo; 
	        for (var key in addedColumnInfo){
				columnInfo[key] = addedColumnInfo[key];
			}
			columnLayout.push(columnInfo);	
    	}
    }
    // 별도의 열 추가 종료 ===================
	
    // 헤더정리
    for (var i = 0; i < columnLayout.length; i++){
    	arrangAUIChildren(columnLayout[i]);
    }
    
    var sht = controls[sheetName];
	//var auiGridProps = {};
    var auiGridProps = sht.auiGridProps;
    
	// 셀 병합 실행
	auiGridProps.enableCellMerge = true;

	auiGridProps.enableSorting = false;
	
	// singleRow 선택모드
//	auiGridProps.selectionMode = "singleCell";
	
	// 고정Row 카운트 지정
	auiGridProps.fixedRowCount = 0;

	// 고정칼럼 카운트 지정
	auiGridProps.fixedColumnCount = arrGroupKeys[0].length;
	
	//시트 편집 가능
	//auiGridProps.editable = true;
	
	// 줄번호 숨김 
	auiGridProps.showRowNumColumn = false;
	
	// 푸터설정
	if (sht.showFooter) {
		auiGridProps.showFooter = true;
		auiGridProps.footerHeight = 30;
	}
	
	// 실제로 #grid_wrap 에 그리드 생성
	var AUIcontrolId = sht.AUIcontrolId;
	document.getElementById(AUIcontrolId).innerHTML = "";
	
	myGridID = AUIGrid.create(AUIcontrolId, columnLayout, auiGridProps);
	if (sht.showFooter) {
		this.setPivotFooter(arrItemLayouts);
	}
	
	// 시트의 열 너비 정비 : Pivot 동작시 시트 열 밀림 현상이 생김에 따라 열 너비 정비를 해야함.(열 너비는 각 열 너비를 올림하여 대입)
	var colInfos = AUIGrid.getColumnInfoList(AUIcontrolId);
	var width = 0;
	for(var i = 0; i < colInfos.length; i++){
		width = Math.ceil(colInfos[i].width * 0.1) * 10;
		sht.defaultColumnSize[i] = (!isNaN(width) ? width : null);
	}
	AUIGrid.setColumnSizeList(AUIcontrolId, sht.defaultColumnSize);
	
	AUIGrid.setGridData(AUIcontrolId, []);
	
	var dataSetId = this.id;
	
	// 이벤트 부여
	AUIGrid.bind(myGridID, "cellEditEnd", function( event ) {
		sht.updatePivotCell(event.rowIndex + 1, event.columnIndex + 1, event.value, event.oldValue);
	});
	
	AUIGrid.bind(myGridID, "cellClick", function( event ) {
		var dataset = dataSets[dataSetId];
//		if (event.columnIndex < dataset._arrGroupKeys[0].length){
//			return;
//		}
		
		var _colNum_ = event.columnIndex - dataset._arrGroupKeys[0].length;
		var aSheet = controls[sheetName];
		var rtnJson = null;
		var colId = null;
		var colIndex = null;
		var rowNum = event.rowIndex + 1;
		var colNum = event.columnIndex + 1;
		
		aSheet._clicked_row_id = event.item._$uid;
		
		if(_colNum_ < 0){
			colId = (("" + dataset._GroupKey).split(","))[event.columnIndex];
			colIndex = _colNum_;
		}
		else{
			rtnJson = dataset._pivotColumnOfColNum(_colNum_);
			colId = rtnJson.colId;
			colIndex = rtnJson.colIndex;			
		}
		
		aSheet.setCurrentRow(rowNum);
		aSheet.setCurrentCol(colNum);

		// 사용자 코딩 추가영역을 호출한다
		if (aSheet.hasClickEvent) {
			var wResult = aSheet.fncClickEvent(rowNum, colNum, colId, colIndex);
			if (typeof(wResult)=="boolean" && !wResult) {
				return false;
			}            
		}
	});
	
	AUIGrid.bind(myGridID, "cellDoubleClick", function( event ) {
		var dataset = dataSets[dataSetId];
//		if (event.columnIndex < dataset._arrGroupKeys[0].length){
//			return;
//		}
		
		var _colNum_ = event.columnIndex - dataset._arrGroupKeys[0].length;
		var aSheet = controls[sheetName];
		var rtnJson = null;
		var colId = null;
		var colIndex = null;
		var rowNum = event.rowIndex + 1;
		var colNum = event.columnIndex + 1;
		
		aSheet._clicked_row_id = event.item._$uid;
		
		if(_colNum_ < 0){
			colId = (("" + dataset._GroupKey).split(","))[event.columnIndex];
			colIndex = _colNum_;
		}
		else{
			rtnJson = dataset._pivotColumnOfColNum(_colNum_);
			colId = rtnJson.colId;
			colIndex = rtnJson.colIndex;			
		}
		
		aSheet.setCurrentRow(rowNum);
		aSheet.setCurrentCol(colNum);

		// 사용자 코딩 추가영역을 호출한다
		if (aSheet.hasClickEvent) {
			var wResult = aSheet.fncDblClickEvent(rowNum, colNum, colId, colIndex);
			if (typeof(wResult)=="boolean" && !wResult) {
				return false;
			}            
		}
	});
	
	var gridData = [];
    for (var i = 0; i < arrDatas.length; i++){
    	var arrGroupKeyLabel = arrGroupKeys[i].arrLabel;

    	// 텍스트 대치
		for (var nGroupLevel = 0; nGroupLevel < arrGroupKeyLabel.length; nGroupLevel++ ){
			if (arrGroupKeyLabel[nGroupLevel] == null){
				var varKey = jsonGroupKey[nGroupLevel];
				// 디폴트로 colId를 채윤다
				var colId = (varKey instanceof Array ? varKey[0] : varKey);

				// 배열인 경우 하위키 루핑 돌며 sumMethod를 찾는다, gk위키중 맨 마지막의 sumMethod를 활용한다.
				if (varKey instanceof Array){
					// 하위키중 하나라도 sumMethod가 있으면 그메서드를 적용하고 
					// 하위키 모두 있으면 나중에 나온것을 적용한다.
					for (var nSubIndex = 0; nSubIndex < varKey.length; nSubIndex++){
						var colId1 = varKey[nSubIndex];
						if (colId1 == "") continue;
						
						if (sumMethods[colId1].trim().length != 0){
							colId = colId1;
						}
					}
				}				
				
				if (sumMethods[colId].substring(0,5) == "TEXT:"){
					var sumString = sumMethods[colId].substring(5);
					for (var nGroupLevel1 = nGroupLevel; nGroupLevel1 <= levelCount - 1; nGroupLevel1++ ){
						if (nGroupLevel1 == 0){
							arrGroupKeyLabel[nGroupLevel1] = sumString;
						} else if (arrGroupKeyLabel[nGroupLevel1 - 1] == sumString || 
								   arrGroupKeyLabel[nGroupLevel1 - 1].endsWith(" " + sumString)){
							arrGroupKeyLabel[nGroupLevel1] = "";
						} else if (arrGroupKeyLabel[nGroupLevel1 - 1] == ""){
							arrGroupKeyLabel[nGroupLevel1] = "";
						} else {
							arrGroupKeyLabel[nGroupLevel1] = arrGroupKeyLabel[nGroupLevel1 - 1] + " " + sumString;
						}
					}
				}
				break;
			}
		}
    	
    	var data = gridData[i] = {};
    	for (var j = 0; j < arrGroupKeys.length; j++){
    		var arrGroupKey = jsonGroupKey[j];
    		for (var k=0; k < jsonGroupKey.length;k++){
    			var varKey = jsonGroupKey[k];
    			var strGroupKey = (varKey instanceof Array ? varKey.join("_") : varKey);
    			data[strGroupKey] = arrGroupKeyLabel[k];
    		}
    	}
    	
    	var levelCount = arrPivotKeys[0].length;
    	arrData = arrDatas[i];
        for (var j=0; j < arrPivotKeys.length; j++){
        	if (arrData[j] == undefined) continue;

        	var arrPivotKey = arrPivotKeys[j][levelCount - 1] + "_" + j;
    		data[arrPivotKey] = arrData[j];
        }
    	
    }

    // 별도의 열추가 시작  ===================
    if (this.arrMoreSumInfos.length > 0){ 
    	for (var moreNdx = 0; moreNdx < this.arrMoreSumInfos.length; moreNdx++){
     		var moreSumInfo = this.arrMoreSumInfos[moreNdx];

     		var dataField = moreSumInfo.colId + "_" + moreSumInfo.sumMethod;
 	        var arrData = this.arrMoreColumnDatas[moreNdx];
 	        for (var nRow=0; nRow < arrData.length; nRow++){
 	        	gridData[nRow][dataField] = arrData[nRow];
 	        }
    	}
    }
    // 별도의 열 추가 종료 ===================
	
    AUIGrid.setGridData(AUIcontrolId, gridData);
    sht.maxRows = gridData.length;
    sht.maxCols = colInfos.length;


    // 별도의 열추가 시작  ===================
    if (this.arrMoreSumInfos.length > 0){ 
 	    // 푸터 처리부 
        var arrFooter = AUIGrid.getFooterLayout(AUIcontrolId);
		if  (arrFooter != null){
			for (var moreNdx = 0; moreNdx < this.arrMoreSumInfos.length; moreNdx++){
//	      		var moreSumInfo = this.arrMoreColumnDatas[moreNdx];
				var moreSumInfo = this.arrMoreSumInfos[moreNdx];
	      		var dataField = moreSumInfo.colId + "_" + moreSumInfo.sumMethod;

				var footerInfo = {};
		        var addedColumnInfo = moreSumInfo.columnInfo; 
		        for (var key in addedColumnInfo){
					footerInfo[key] = addedColumnInfo[key];
			    }

		        footerInfo.positionField = dataField;
		 		footerInfo.labelText = moreSumInfo.footerAmt;  // <--- 값 

		        arrFooter.push(footerInfo);
		        AUIGrid.setFooter(AUIcontrolId, arrFooter);
	    	}
		}   	
    }
    // 별도의 열 추가 종료 ===================
};

/**
 * @description	미결
 * @param	{string}	colId
 * @param	{string}	summingMethod
 * @param	{string}	moreSumInfo
 * @return  {object}
 * @example	미결
 */
DataSet.prototype.addivotColumnToLast = function(colId, summingMethod, moreSumInfo){
	var arrGroupKeys = this._arrGroupKeys;
	var data = new Array(arrGroupKeys.length);
	var data_cnt = new Array(arrGroupKeys.length);
	var data_sum = new Array(arrGroupKeys.length);

    // footerData
    var footer_cnt = 0;
    var footer_sum = 0;
    var footer_amt = 0;
   
	// 피벗키별로 데이터 집계 
	for (var nRowNF = 0; nRowNF < this._DataObject.buffer.length; nRowNF++){
		// 단위 데이터 처리 
		var record = this._DataObject.buffer[nRowNF];
		if (record.RowType == "Logical") continue;

        var arrGroupKey = this._clonePivotKey(record._jsonGroupKeyValue);
		var value = record.values[colId];

		var rowIndex = binaryPivotSearch(arrGroupKeys, arrGroupKey, 0, arrGroupKeys.length - 1);
		if (typeof data[rowIndex] == "undefined"){
			data[rowIndex] = (summingMethod == "COUNT" ? 1 : value);

    		data_cnt[rowIndex] = 1;
    		data_sum[rowIndex] = value;

		} else {
		    data_sum[rowIndex] = data_sum[rowIndex] + value;
		    data_cnt[rowIndex] = data_cnt[rowIndex] + 1;

		    var cellValue = data[rowIndex];

	    	if (summingMethod == "SUM") data[rowIndex] = data_sum[rowIndex]; 
	    	if (summingMethod == "AVG") data[rowIndex] = data_sum[rowIndex] / data_cnt[rowIndex]; 
	    	if (summingMethod == "MIN") data[rowIndex] = (cellValue > value ? value : cellValue);
	    	if (summingMethod == "MAX") data[rowIndex] = (cellValue < value ? value : cellValue);
	    	if (summingMethod == "COUNT") data[rowIndex] = data_cnt[rowIndex];
		}

		// 그룹합 집계 처리 부분 
		for (var groupNdx = arrGroupKey.length - 1; groupNdx >= 0; groupNdx--){
			if (!this._needGroupKey[groupNdx + 1]) continue;

			arrGroupKey[groupNdx] = null;

			// 여기서 부터 위코드와 똑 같이 반복되는 부분  ================
			var rowIndex = binaryPivotSearch(arrGroupKeys, arrGroupKey, 0, arrGroupKeys.length - 1);
			if (typeof data[rowIndex] == "undefined"){
				data[rowIndex] = (summingMethod == "COUNT" ? 1 : value);

	    		data_cnt[rowIndex] = 1;
	    		data_sum[rowIndex] = value;

			} else {
			    data_sum[rowIndex] += value;
			    data_cnt[rowIndex]++;

			    var cellValue = data[rowIndex];

		    	if (summingMethod == "SUM") data[rowIndex] = data_sum[rowIndex]; 
		    	if (summingMethod == "AVG") data[rowIndex] = data_sum[rowIndex] / data_cnt[rowIndex]; 
		    	if (summingMethod == "MIN") data[rowIndex] = (cellValue > value ? value : cellValue);
		    	if (summingMethod == "MAX") data[rowIndex] = (cellValue < value ? value : cellValue);
		    	if (summingMethod == "COUNT") data[rowIndex] = data_cnt[rowIndex];
			}
			// 여기  까지 위코드와 똑 같이 반복되는 부분  ================
		}

		// footer Data 
	    footer_sum += value;
	    footer_cnt++;

    	if (summingMethod == "SUM") footer_amt = footer_sum; 
    	if (summingMethod == "AVG") footer_amt = footer_sum / footer_cnt; 
    	if (summingMethod == "MIN") footer_amt = (footer_amt > value ? value : footer_amt);
    	if (summingMethod == "MAX") footer_amt = (footer_amt < value ? value : footer_amt);
    	if (summingMethod == "COUNT") footer_amt = footer_cnt;
	}

	moreSumInfo.footerAmt = footer_amt;

	data_cnt.clear(); delete data_cnt;
	data_sum.clear(); delete data_sum;

	return data;
};

/**
 * @description	미결
 * @param	{string}	arrItemLayouts
 * @return  {undefined}
 * @example	미결
 */
DataSet.prototype.setPivotFooter = function(arrItemLayouts){
	var sht = controls[this._sheetName];
	if (!sht.showFooter) return;
	
	var arrPivotKeys = this._arrPivotKeys;
	var arrGroupKeys = this._arrGroupKeys;
	var jsonGroupKey = this._jsonGroupKey;
	var arrFooterSums = this._arrFooterSums;
    
    var footerObject = [];
	
	for (var i = 0; i < jsonGroupKey.length; i++){
		var footerInfo = footerObject[footerObject.length] = {};
		var ItemLayout = sht.footerObject[i];
		for (var key in ItemLayout){
			if (key != "labelFunction" && key != "styleFunction" && typeof ItemLayout[key] == "function") continue;
			if (key == "positionField" || key == "dataField" ) continue;
			footerInfo[key] = ItemLayout[key];
		}		
		
		var varKey = jsonGroupKey[i];
 		var strGroupKey = (varKey instanceof Array ? varKey.join("_") : varKey);
 		footerInfo.positionField = strGroupKey;
 		footerInfo = null;
	}
	
	
	var levelCount_pivot = arrPivotKeys[0].length;
	var levelCount_group = jsonGroupKey.length;
	var countOfDataColId = sht.footerObject.length - levelCount_group;
	
	var wColNum = jsonGroupKey.length;
    for (var i=0; i < arrPivotKeys.length; i++){
    	var jsonFooterSum = arrFooterSums[i];
    	
    	var colNumRef = levelCount_group + (i % countOfDataColId);
    	
		var footerInfo = footerObject[footerObject.length] = {};
		var ItemLayout = sht.footerObject[colNumRef];
		for (var key in ItemLayout){
			if (key != "styleFunction" && typeof ItemLayout[key] == "function") continue;
			if (key == "positionField" || key == "dataField" ) continue;
			footerInfo[key] = ItemLayout[key];
		}		
    	
    	var wValue = (jsonFooterSum.sumMethod == "SUM" ? jsonFooterSum.sum : 
    			      jsonFooterSum.sumMethod == "AVG" ? jsonFooterSum.sum / this._rowCount_NonGroup :
    				  jsonFooterSum.sumMethod == "MIN" ? jsonFooterSum.min :
    				  jsonFooterSum.sumMethod == "COUNT" ? jsonFooterSum.count :
    				  jsonFooterSum.sumMethod == "MAX" ? jsonFooterSum.max : 0);
    	
    	var colId = arrPivotKeys[i][levelCount_pivot - 1];
    	var strPivotKey = arrPivotKeys[i][levelCount_pivot - 1] + "_" + i;
 		footerInfo.positionField = strPivotKey;
 		footerInfo.labelText = wValue;
 		footerInfo.style = "AUIGrid_Align_right";
 		footerInfo.formatString = "#,##0";
 		
 		ItemLayout = arrItemLayouts[colId];
 		
 		for (var key in ItemLayout){
 			if (key != "labelFunction" && typeof ItemLayout[key] == "function") continue;
 			var lKey = key.toLowerCase();
 			if (lKey == "prefix") {
 				footerInfo.prefix = ItemLayout.prefix;
 			} else if (lKey == "postfix") {
 				footerInfo.postfix = ItemLayout.postfix;
 			} else if (lKey == "formatstring") {
 				footerInfo.formatString = ItemLayout.formatString;
// 			} else if (lKey == "labelfunction") {
// 				footerInfo.labelFunction = ItemLayout.labelFunction;
 			} 
 		}
    }

    AUIGrid.setFooter(sht.AUIcontrolId, footerObject);
	
};

/**
*     @description	미결
*     @param	{string}	columnInfo
*     @return	{string}
*     @example	미결
*/
function arrangAUIChildren(columnInfo){
	// children 없거나 갯수가 하나가 아니면 리턴하고 빠진다
	if (typeof columnInfo.children == "undefined") return;
	for (var i = 0; i < columnInfo.children.length; i++){
		var childColumnInfo = columnInfo.children[i];
		arrangAUIChildren(childColumnInfo);
	}
	if (columnInfo.children.length > 1)  return;
	
	var childColumnInfo = columnInfo.children[0];

	if (typeof childColumnInfo.children != "undefined"){
		// 자식이 children 이 있고 갯수가 하나이면 
		// 캡션이 같으면 조정된 자식 columnInfo를 받는다.
		// Copy하면 children 까지 같이 생기므로 의식할 필요 없다 .
		if (columnInfo.headerText === childColumnInfo.headerText){
			for (var key in childColumnInfo){
				if (key != "labelFunction" && key != "styleFunction" && typeof childColumnInfo[key] == "function") continue;
				if (key.toLowerCase() == "headertext") continue;
				
				columnInfo[key] = childColumnInfo[key];
			}
		}
	}
	
	
	
	// 자식이 children이 없는데 캡션이 없으면 
	// 나한테 복사한다
	childColumnInfo = columnInfo.children[0];
	if (typeof childColumnInfo.children == "undefined"){
		if (childColumnInfo.headerText.trim().length == 0 || columnInfo.headerText === childColumnInfo.headerText) {
			for (var key in childColumnInfo){
				if (key != "labelFunction" && key != "styleFunction" && typeof childColumnInfo[key] == "function") continue;
				if (key.toLowerCase() == "headertext") continue;
				
				columnInfo[key] = childColumnInfo[key];
			}
			delete columnInfo.children; 
		}
	} 
	
    return;
};

// 시트이므로 colIndex는 1부터 시작된다. level은 1부터 시작된다
/**
*     @description	미결
*     @param	{string}	sheetName
*     @param	{number}	level
*     @param	{number}	colIndex_start
*     @param	{number}	colIndex
*     @return	{object}
*     @example	미결
*/
function getColumnObjectFromSheet(sheetName, level, colIndex_start, colIndex){
	var sht = controls[sheetName];
	var columnObj = "";
	if (level == 1){
		columnObj = sht.columnLayout[colIndex_start + colIndex - 1];
	} else if (level == 2){
		columnObj = sht.columnLayout[colIndex_start].children[colIndex - 1];
	} else if (level == 3){
		columnObj = sht.columnLayout[colIndex_start].children[0].children[colIndex - 1];
	} else if (level == 4){
		columnObj = sht.columnLayout[colIndex_start].children[0].children[0].children[colIndex - 1];
	} else if (level == 5){
		columnObj = sht.columnLayout[colIndex_start].children[0].children[0].children[0].children[colIndex - 1];
	} else if (level == 6){
		columnObj = sht.columnLayout[colIndex_start].children[0].children[0].children[0].children[0].children[colIndex - 1];
	} else if (level == 7){
		columnObj = sht.columnLayout[colIndex_start].children[0].children[0].children[0].children[0].children[0].children[colIndex - 1];
	} else if (level == 8){
		columnObj = sht.columnLayout[colIndex_start].children[0].children[0].children[0].children[0].children[0].children[0].children[colIndex - 1];
	} else if (level == 9){
		columnObj = sht.columnLayout[colIndex_start].children[0].children[0].children[0].children[0].children[0].children[0].children[0].children[colIndex - 1];
	} else if (level == 10){
		columnObj = sht.columnLayout[colIndex_start].children[0].children[0].children[0].children[0].children[0].children[0].children[0].children[0].children[colIndex - 1];
	} 
	return columnObj;
};

//리턴값 : {row:줄번호, col:칼럼번호, value:변경값} arrPivotKeysForSearch: arrPivotKeys를 검색용으로 소팅한 것 
function setPivotCell(arrDatas, value, arrGroupKey, arrPivotKey, arrPivotKeys, arrGroupKeys, colId, pivotKeyLength, sumMethod, arrPivotKeysForSearch) {
	
	// 셀위치 찾기
	arrPivotKey[pivotKeyLength] = colId; // 임시로 칼럼명을 키로 추가
    
	var rowIndex = binaryPivotSearch(arrGroupKeys, arrGroupKey, 0, arrGroupKeys.length - 1);
	if (rowIndex == -1){
		if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_021", "Group 위치를 찾지 못했습니다."));
		return null;
	} 
	
	var colIndex = -1;
	var colSearchIndex = binaryPivotSearch(arrPivotKeysForSearch, arrPivotKey, 0, arrPivotKeys.length - 1);
	if (colSearchIndex >= 0){
		colIndex = arrPivotKeysForSearch[colSearchIndex].seq;
	}
	
	if (colIndex == -1){
		if(typeof console != "undefined" && typeof console.log == "function")	console.log(getText("message_dataset_020", "Pivot 위치를 찾지 못했습니다."));
		return null;
	}
	arrPivotKey.pop(); // 임시칼럼키 삭제

	// 집계처리 
	var cellValue; var cnt = 0;
	if (sumMethod == "AVG"){
		// count 처리  [1번 레벨이 null 이면 집계데이터]
		var needPivotSum =  (arrPivotKey[pivotKeyLength - 1] == null);  
		var needGroupSum =  (arrGroupKey[arrGroupKey.length - 1] == null);
		
		if (needPivotSum && needGroupSum){
			cnt = arrPivotKeys[colIndex].cnt *  arrGroupKeys[rowIndex].cnt;
		} else if (needPivotSum){
			cnt = arrPivotKeys[colIndex].cnt;
		} else if (needGroupSum){
			cnt = arrGroupKeys[rowIndex].cnt;
		} 
		
		// Sum 처리
		if (typeof arrDatas[rowIndex][colIndex] == "undefined"){
			arrDatas[rowIndex][colIndex] = 0.0; // sum 속성을 붙이기 위해서 0 데이터를 만든다.
			cellValue = 0.0;
		} else if (typeof arrDatas[rowIndex][colIndex].sum == "undefined"){
			cellValue = 0.0;
		} else {
			cellValue = arrDatas[rowIndex][colIndex].sum;
		}
	} else {
		cellValue = arrDatas[rowIndex][colIndex];
	}
	
	if (sumMethod == undefined || sumMethod == null){
		cellValue = value;
	} else if (typeof arrDatas[rowIndex][colIndex] == "undefined"){
		if (sumMethod == "COUNT"){
			cellValue = 1;
		} else {
			cellValue = value;
		}
	} else {
		if (sumMethod == "SUM"){
			cellValue += value;
		} else if (sumMethod == "MAX"){
			cellValue = (cellValue > value ? cellValue : value);
		} else if (sumMethod == "MIN"){
			cellValue = (cellValue < value ? cellValue : value);
		} else if (sumMethod == "AVG"){
			cellValue += value;
		} else if (sumMethod == "COUNT"){
			cellValue += 1;
		}
	}
	
	if (sumMethod == "AVG"){
		arrDatas[rowIndex][colIndex].sum = cellValue;
		arrDatas[rowIndex][colIndex] = cellValue / cnt;
	} else {
		arrDatas[rowIndex][colIndex] = cellValue;
	}
	
	return {row: rowIndex, col: colIndex, value: arrDatas[rowIndex][colIndex]};
	
};

/**
*     @description	미결
*     @param	{object}	arrays
*     @param	{object}	array
*     @param	{number}	start
*     @param	{number}	end
*     @return	{boolean}
*     @example	미결
*/
function binaryPivotSearch(arrays, array, start, end) {
  if (start > end) { return -1; } //does not exist
  
  var middle = Math.floor((start + end) / 2);
  var array1 = arrays[middle];
  
  var compareResult = comparePivotKey(array1 , array);
  if (compareResult > 0) { 
	  return binaryPivotSearch(arrays, array, start, middle-1); 
  }
  if (compareResult < 0) { 
	  return binaryPivotSearch(arrays, array, middle+1, end); 
  }
  return middle; //found!
};

// null을 Max로 간주하는 비교 
/**
*     @description	미결
*     @param	{string}	jsonGroupKeyValue1
*     @param	{string}	jsonGroupKeyValue2
*     @return	{object}
*     @example	미결
*/
function comparePivotKey(jsonGroupKeyValue1, jsonGroupKeyValue2){
	for (var i = 0; i < jsonGroupKeyValue1.length; i++){
		var varKey1 = jsonGroupKeyValue1[i];
		var varKey2 = jsonGroupKeyValue2[i];
		
		if (varKey1 != null && varKey2 == null){
			return -1;
		} else if (varKey1 == null && varKey2 != null){
			return 1;
		} else if (varKey1 instanceof Array) {
			for (var j=0; j < varKey1.length ;j++) {
				var varSubKey1 = varKey1[j];
				var varSubKey2 = varKey2[j];
				if (varSubKey1 != null && varSubKey2 == null){
					return -1;
				} else if (varSubKey1 == null && varSubKey2 != null){
					return 1;
				} else  if (varSubKey1 > varSubKey2){
					return 1;
				} else if (varSubKey1 < varSubKey2){
					return -1;
				} 
			}
		} else{
			if (varKey1 > varKey2){
				return 1;
			} else if (varKey1 < varKey2){
				return -1;
			} 
		}
	}
	// 마지막으로 jsonGroupKeyValue1까지는 같은데 jsonGroupKeyValue2가 뒤에 배열값이 더있는 경우
	// jsonGroupKeyValue2가 크다
	if (jsonGroupKeyValue1.length < jsonGroupKeyValue2.length){
		return -1;
	}
	
	return 0;
};

/**
 * @description	미결
 * @param	{string}	record
 * @param	{number}	arrFormulaOfLevel
 * @param	{number}	nRowNF
 * @return  {string}
 * @example	미결
 */
DataSet.prototype._makePivotCaption = function(record, arrFormulaOfLevel, nRowNF){
	if (this._PivotKey.length == 0) return [];

	var returnJson = [];
	for (var nLevel=0; nLevel < this._jsonPivotKey.length; nLevel++){
		var levelKey = this._jsonPivotKey[nLevel];

		var formula = arrFormulaOfLevel[nLevel + 1];
		if (formula == ""){                                // 없으면 칼럼값
			if (levelKey instanceof Array){
				var vaule_ = "";
				for (var nSubLevel=0; nSubLevel <levelKey.length; levelKey++){
					var subKey = levelKey[nSubLevel];
					vaule_ += (nSubLevel > 0 ? " " : "") + record.values(subKey);
				}
				returnJson[nLevel] = vaule_;
			} else {
				returnJson[nLevel] = record.values[levelKey];
			}
		} else if (formula.substring(0, 8) != "formula:"){ // 필드명으로 찾아 값채움
			returnJson[nLevel] = record.values[formula];
		} else {
			formula = this._UpdateFormulaNF(formula);
			returnJson[nLevel] = eval(formula.replace("nRowNum", nRowNF));
		}
	}
	
	return returnJson;
};

/**
 * @description	미결
 * @param	{string}	record
 * @return  {string}
 * @example	미결
 */
DataSet.prototype._makePivotKey = function(record){
	if (this._PivotKey.length == 0) return [];

	var returnJson = [];
	for (var i=0; i < this._jsonPivotKey.length; i++){
		var levelKey = this._jsonPivotKey[i];
		if (levelKey instanceof Array) {
			var itemKeys = levelKey;
			var itemKeyValues = [];
			for (j = 0; j < itemKeys.length; j++){
				var itemKey = itemKeys[j];
				itemKeyValues[j] = record.values[itemKey];
			}
			returnJson[i] = itemKeyValues;
			
		} else {
			returnJson[i] = record.values[levelKey];
		}
	}
	
	return returnJson;
};

/**
 * @description	미결
 * @param	{string}	pivotKey
 * @return  {string}
 * @example	미결
 */
DataSet.prototype._clonePivotKey = function(pivotKey){ 
	var rtnPivotKey = [];
	for (var i=0; i < pivotKey.length;i++){
		
		var varKey = pivotKey[i];
		if (varKey instanceof Array) {
			rtnPivotKey[i] = [];
			for (var j=0; j < varKey.length;j++){
				var subKey = varKey[j];
				rtnPivotKey[i][j] = subKey;
			}
			
		} else {
			rtnPivotKey[i] = varKey;
		}
	}
	
	return rtnPivotKey;
};


/**
 * @description	미결
 * @param	{string}	jsonPivotKeyValue
 * @param	{number}	nRowLevel
 * @return  {object}
 * @example	미결
 */
DataSet.prototype._makePivotLevelKey = function(jsonPivotKeyValue, nRowLevel){
	var pivotLevelKey = [];
	var levelCount = jsonPivotKeyValue.length;
	
	for (var i = 0; i < jsonPivotKeyValue.length; i++){
		// 레벨이 1이면 다 
		if (i >= nRowLevel - 1) {
			pivotLevelKey[i] = null;
			continue;
		}
		
		// 그룹레벨별 키 범위내의 데이터 복사 
		var varKey = jsonPivotKeyValue[i];
		
		if (varKey instanceof Array) {
			var varSubKey = [];
			for (var j=0; j < varKey.length; j++) {
				varSubKey[j] = varKey[j];
			}
			pivotLevelKey[i] = varSubKey;
		} else{
			pivotLevelKey[i] = varKey;
		}
	}

	if (typeof jsonPivotKeyValue.arrLabel != "undefined"){
		pivotLevelKey.arrLabel = new Array(levelCount);
		for (var i = 0; i < jsonPivotKeyValue.length; i++){
			if (i >= nRowLevel - 1) {
				pivotLevelKey.arrLabel[i] = null;
				continue;
			}
			pivotLevelKey.arrLabel[i] = jsonPivotKeyValue.arrLabel[i];
		}
	}

	
	return pivotLevelKey;
};

/**
 * @description	미결
 * @param	{string}	jsonPivotCaption
 * @param	{number}	nRowLevel
 * @return  {string}
 * @example	미결
 */
DataSet.prototype._makePivotLevelCaption = function(jsonPivotCaption, nRowLevel){
	var pivotLevelCaption = [];
	var levelCount = jsonPivotCaption.length;
	for (var i = 0; i < jsonPivotCaption.length; i++){
		
		// 그룹레벨별 키 범위내의 원본 데이터 복사 
		pivotLevelCaption[i] = "";
		// 레벨이 1이면 다 

		if (i == nRowLevel - 1) {
			// 디폴트로 colId, sumMethod를 채윤다
			var varKey = this._jsonPivotKey[i];
			var colId = (varKey instanceof Array ? varKey[0] : varKey);
			var sumMethod = this._DataObject.colInfos[colId].sumMethod;

			// 배열인 경우 하위키 루핑 돌며 sumMethod를 찾는다, gk위키중 맨 마지막의 sumMethod를 활용한다.
			if (varKey instanceof Array){
				// 하위키중 하나라도 sumMethod가 있으면 그메서드를 적용하고 
		        // 하위키 모두 있으면 나중에 나온것을 적용한다.
				for (var nSubIndex = 0; nSubIndex < varKey.length; nSubIndex++){
					var colId1 = varKey[nSubIndex];
					if (colId1 == "") continue;
					
					if (this._DataObject.colInfos[colId1].sumMethod.trim().length != 0){
						colId = colId1;
						sumMethod = this._DataObject.colInfos[colId1].sumMethod;
					}
				}
			}
			
			//var colId = this._jsonPivotKey[i];
			//var sumMethod = this._DataObject.colInfos[colId].sumMethod;
			
			if (sumMethod.substring(0,5) == "TEXT:"){
				var sumString = sumMethod.substring(5);
				
				for (var nPivotLevel1 = i; nPivotLevel1 < levelCount; nPivotLevel1++ ){
					if (nPivotLevel1 > 0 && pivotLevelCaption[nPivotLevel1 - 1] != sumString){
						pivotLevelCaption[nPivotLevel1] = pivotLevelCaption[nPivotLevel1 - 1] + " " + sumString;
					} else {
						pivotLevelCaption[nPivotLevel1] = sumString;
					}
				}
				break;
			}
			
		} else {
			pivotLevelCaption[i] = jsonPivotCaption[i];
		}
		
	}
	return pivotLevelCaption;
};


/*
 * 첫번쨰인수가 레코드 또는 배열이다
 * */
/**
*     @description	미결
*     @param	{string}	jsonKeyValue
*     @param	{string}	jsonPivotKeyValue
*     @param	{number}	nRowLevel
*     @return	{boolean}
*     @example	미결
*/
function _checkIfPivotLevelKeyChanged(jsonKeyValue, jsonPivotKeyValue, nRowLevel){
	var keyChanged = false;
	
	for (var i = 0; i < nRowLevel - 1; i++){
		
		// 그룹레벨별 키 범위내의 데이터 복사 
		var varKey1 = jsonKeyValue[i];
		var varKey2 = jsonPivotKeyValue[i]
		
		if (varKey1 instanceof Array) {
			for (var j=0; j < varKey1.length; j++) {
				if (varKey1[j] != varKey2[j]){
					keyChanged = true; break;
				}
			}
			} else{
			if (varKey1 != varKey2){
				keyChanged = true;
			}
		}
		if (keyChanged) break;
	} 
	
	return keyChanged;
};

/**
 * Dataset에 PivotTable을 구성하기 위한 PivotColumn을 지정하는 Property
 * @return               (String) 피벗키를 나타내는 문자열
 * */
DataSet.prototype.getPivotKey = function(){ return this._PivotKey;};

/**
 * Dataset에 PivotTable을 구성하기 위한 PivotColumn을 지정하는 Property
 * @param pivotKey     (String) 피벗키를 나타내는 문자열
 * */
DataSet.prototype.setPivotKey = function(pivotKey){
	this._PivotKey = pivotKey;
	
	var levelKeyArr = this._PivotKey.split(",");
	for (var i=0; i < levelKeyArr.length; i++){
		var levelKey = levelKeyArr[i];
		if (levelKey.indexOf(":") >= 0){
			this._jsonPivotKey[i] = levelKey.split(":");
		} else {
			this._jsonPivotKey[i] = levelKey;
		}
	}
	
	
	// PivotKey가 변경되면 PivotTable이 재구성되며, OnLoadComplete Reason=70 (Pivot)이 발생됩니다.
	this._refreshPivot();
	
	
	return;
};

// rowIndex, columnIndex는 "0" 부터 시작된다 
// 시트에  해당셀은 이미 수정되었다는 전제 
/**
 * @description	미결
 * @param	{number}	rowIndex
 * @param	{number}	columnIdex
 * @param	{string}	value
 * @param	{string}	oldValue
 * @return  {void}
 * @example	미결
 */
DataSet.prototype.updatePivotCell = function(rowIndex, columnIndex, value, oldValue){
	var arrPivotKeys = this._arrPivotKeys;
	var arrGroupKeys = this._arrGroupKeys;
	var sumMethods   = this._sumMethods;
	
	var jsonPivotKey = this._jsonPivotKey;
	var jsonGroupKey = this._jsonGroupKey;
	
	var pivotKeyLength = this._jsonPivotKey.length;
	var groupKeyLength = this._jsonGroupKey.length;
	
	// 이벤트 처리 
	if (this.FireEvent){
		if (this.hasColumnChangedEvent) {
			var rtnJson = this._pivotColumnOfColNum(columnIndex - groupKeyLength);
			var wResult = this.fncColumnChangedEvent(this, rowIndex + 1, rtnJson.colId, oldValue, value, rtnJson.colIndex);
			if (typeof(wResult)=="boolean" && !wResult) {
				return false;
			}            
		}     
	}

	// 1. 칼럼번호로 피벗키를 찾는다 , 앞부분에 그룹키가 채워져 있으니 감안해 준다.
	var arrPivotKey = arrPivotKeys[columnIndex - groupKeyLength];
	var colId = arrPivotKey[pivotKeyLength]; // 추가된 마지막 레벨이 칼럼ID가 들어가 있다. 
	var sumMethod = sumMethods[colId];
		
	// 2. 줄번호로   그룹키를 찾는다 
	var arrGroupKey = arrGroupKeys[rowIndex];
	
	// 3. 합계 업데이트 
	var arrCellsToUpdate = this._updatePivotSum(colId, sumMethod, value - oldValue, arrPivotKey, arrGroupKey);
	var AUIcontrolId = controls[this._sheetName].AUIcontrolId;
	for (var i = 0; i < arrCellsToUpdate.length; i++){
		var cellToUpdate = arrCellsToUpdate[i];
		
		var item = {};    
		item[colId + "_" + (cellToUpdate.col)] = cellToUpdate.value;
		
		try {
			AUIGrid.updateRow(AUIcontrolId, item, cellToUpdate.row);
		} catch(e){
			try {
				AUIGrid.updateRow(AUIcontrolId, item, cellToUpdate.row);
			} catch(e){
				if(typeof console != "undefined" && typeof console.log == "function")	console.log(e);
			}
		}	
	}
	
	// 3. 그룹키 + 피봇키로 원본데이터셋에서 레코드를 찾는다 
	var arrRecordKey = [];
	for (var nLevel=0; nLevel < this._jsonPivotKey.length; nLevel++){
		var fieldId = ""; var value_ = null;
		var levelKey = this._jsonPivotKey[nLevel];
		
		if (levelKey instanceof Array) {
			for (var nSubLevel=0; nSubLevel < levelKey.length; nSubLevel++){
				fieldId = levelKey[nSubLevel];				
				value_ = arrPivotKey[nLevel][nSubLevel];
				arrRecordKey[fieldId] = value_;
			}
		} else {
			fieldId = levelKey;
			value_ = arrPivotKey[nLevel];
		    arrRecordKey[fieldId] = value_;
		}
	}
	
	for (var nLevel=0; nLevel < this._jsonGroupKey.length; nLevel++){
		var fieldId = ""; var value_ = null;
		var levelKey = this._jsonGroupKey[nLevel];
		if (levelKey instanceof Array) {
			for (var nSubLevel=0; nSubLevel < levelKey.length; nSubLevel++){
				fieldId = levelKey[nSubLevel];				
				value_ = arrGroupKey[nLevel][nSubLevel];
				arrRecordKey[fieldId] = value_;
			}
		} else {
			fieldId = levelKey;
			value_ = arrGroupKey[nLevel];
		    arrRecordKey[fieldId] = value_;
		}
	}

	var found = false;
	for (var nRow = 0; nRow < this._DataObject.records.length; nRow++){
		var record = this._DataObject.records[nRow];
		
		found = true;
		for (var key in arrRecordKey){
			if (typeof arrRecordKey[key] == "function") continue;
			if (arrRecordKey[key] != record.values[key]){
				found = false;
				break;
			}
		}
		if (found){
			//record.values[colId] = value;
			//record.RowType = "Update";
			this._DataObject.setColumn(nRow, colId, value);
			break;
		}
	}
	
	// 발견되지 않으면 레코드 추가
	if (!found){
		var record = new MiRecord(this._DataObject.colInfos);
		var newIndex = this._DataObject.records.length;
		record._orignalIndex = newIndex;
		
		this._DataObject.records[newIndex] = record;
		for (var key in arrRecordKey){
			if (typeof arrRecordKey[key] == "function") continue;
			record.values[key] = this._DataObject._getRawValue(key, arrRecordKey[key]);
		}
		//record.values[colId] = value;
		record.RowType = "Insert";
		this._DataObject.setColumn(nRow, colId, value);
	}
	
	return;
};


// colId, colIndex로 열번호를 찾는다, RowHead 갯수는 포함이니 사용할 때 그냥 쓴다.
/**
 * @description	미결
 * @param	{string}	colId
 * @param	{number}	colIndex
 * @return  {number}
 * @example	미결
 */
DataSet.prototype._colNumOfPivotColumn = function(colId, colIndex){ 
	var colNum = -1;
	if (this._arrPivotKeys.length == 0) return colNum;
	
	var arrPivotKeys = this._arrPivotKeys;
	var arrGroupKeys = this._arrGroupKeys;
	var lastLevel = arrPivotKeys[0].length - 1;
	var groupKeyCount = arrGroupKeys[0].length;
	
	for (var i = 0; i < arrPivotKeys.length; i++){
		var arrPivotKey = arrPivotKeys[i];
		if (typeof arrPivotKey.ndx == "undefined") continue;
		if (arrPivotKey.ndx != colIndex) continue;
		if (arrPivotKey[lastLevel] != colId) continue;
		
		colNum = i;
		break;
	}
	
	return (colNum < 0 ? -1 : colNum + groupKeyCount);
};

//열번호로 colId, colIndex를 찾는다 , colNum에는 RowHead 갯수는 포함안됨. 0부터 시작 
/**
 * @description	미결
 * @param	{number}	colNum
 * @return  {string}
 * @example	미결
 */
DataSet.prototype._pivotColumnOfColNum = function(colNum){ 
	var rtnJson = {colId:"", colIndex:-1};
	
	if (this._arrPivotKeys.length == 0) return rtnJson;
	
	var arrPivotKey = this._arrPivotKeys[colNum];
	var lastLevel = this._arrPivotKeys[0].length - 1;
	
	rtnJson.colId = arrPivotKey[lastLevel]; 
	rtnJson.colIndex = arrPivotKey.ndx;
	
	return rtnJson;
};

/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{number}	varCol
 * @param	{string}	varVal
 * @param	{number}	nPivotIndex
 * @return  {undefined}
 * @example	미결
 */
DataSet.prototype._SetPivotColumn = function(nRow, varCol, varVal, nPivotIndex){
	var strColID = (typeof(varCol) == 'number' ? this._arrItemColIds(varCol)  : varCol);
	var colNum = this._colNumOfPivotColumn(strColID, nPivotIndex);

	if (colNum < 0) return;
	
	var AUIcontrolId = controls[this._sheetName].AUIcontrolId;
	var dataField = AUIGrid.getDataFieldByColumnIndex(AUIcontrolId, colNum);
	
	var item = {};    
	item[dataField] = varVal;
	
	try {
		AUIGrid.updateRow(AUIcontrolId, item, nRow);
	} catch(e){
		try {
			AUIGrid.updateRow(AUIcontrolId, item, nRow);
		} catch(e){
			if(typeof console != "undefined" && typeof console.log == "function")	console.log(e);
		}
	}	

};
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{number}	varCol
 * @param	{number}	nPivotIndex
 * @return  {object}
 * @example	미결
 */
DataSet.prototype._GetPivotColumn = function(nRow, varCol, nPivotIndex){
	var strColID = (typeof(varCol) == 'number' ? this._arrItemColIds(varCol)  : varCol);
	 
	if (this._isPivotColumn(strColID)){
		return this._getPivotPivotColumn(nRow, varCol, nPivotIndex);
	} else if (this._isGroupColumn(strColID)){
		return this._getPivotGroupColumn(nRow, varCol);
	}
	
	var colNum = this._colNumOfPivotColumn(strColID, nPivotIndex);

	if (colNum < 0) return;
	
	var AUIcontrolId = controls[this._sheetName].AUIcontrolId;
	var dataField = AUIGrid.getDataFieldByColumnIndex(AUIcontrolId, colNum);
	
	return AUIGrid.getItemByRowIndex(AUIcontrolId, nRow)[dataField];
};

/**
 * @description	미결
 * @param	{number}	varCol
 * @param	{number}	nPivotIndex
 * @return  {object}
 * @example	미결
 */
DataSet.prototype._getPivotCurrentColumn = function(varCol, nPivotIndex){
	var strColID = (typeof(varCol) == 'number' ? this._arrItemColIds(varCol)  : varCol);
	var colNum = this._colNumOfPivotColumn(strColID, nPivotIndex);

	if (colNum < 0) return;
	
	var AUIcontrolId = controls[this._sheetName].AUIcontrolId;
	var dataField = AUIGrid.getDataFieldByColumnIndex(AUIcontrolId, colNum);

	var nRow =  AUIGrid.getSelectedIndex(AUIcontrolId)[0];
	return AUIGrid.getItemByRowIndex(AUIcontrolId, nRow)[dataField];
};

/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{string}	strColId	
 * @return  {string}
 * @example	미결
 */
DataSet.prototype._GetPivotGroupColumn = function(nRow, strColId){

	for (var i=0; i < this._jsonGroupKey.length;i++){
		var varKeyName = this._jsonGroupKey[i];
		if (varKeyName instanceof Array) {
			for (var j=0; j < varKeyName.length;j++){
				var colId = varKeyName[j];
				if (strColId === colId){
					return this._arrGroupKeys[nRow][i][j];
				}
			}
			
		} else {
			var colId = this._jsonGroupKey[i];
			if (strColId === colId){
				return this._arrGroupKeys[nRow][i];
			}
		}
	}
	return null;
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{string}	strColId
 * @param	{number}	sPivotIndex
 * @return  {string}
 * @example	미결
 */
DataSet.prototype._GetPivotPivotColumn = function(nRow, strColId, nPivotIndex){
	var groupKeyCount = this._arrGroupKeys[0].length;
	
	var lastIndex  = this._arrItemColIds.length -1;
	var strColID = this._arrItemColIds[lastIndex];
	var colNum = this._colNumOfPivotColumn(strColID, nPivotIndex) - groupKeyCount;

	if (colNum < 0) return;	
	
	for (var i=0; i < this._jsonPivotKey.length;i++){
		var varKeyName = this._jsonPivotKey[i];
		if (varKeyName instanceof Array) {
			for (var j=0; j < varKeyName.length;j++){
				var colId = varKeyName[j];
				if (strColId === colId){
					return this._arrPivotKeys[colNum][i][j];
				}
			}
			
		} else {
			var colId = this._jsonPivotKey[i];
			if (strColId === colId){
				return this._arrPivotKeys[colNum][i];
			}
		}
	}
	
	return null;
};

/**
 * @description	미결
 * @param	{string}	strColId
 * @return  {boolean}
 * @example	미결
 */
DataSet.prototype._isPivotColumn = function(strColId){
	for (var i=0; i < this._jsonPivotKey.length;i++){
		var varKeyName = this._jsonPivotKey[i];
		if (varKeyName instanceof Array) {
			for (var j=0; j < varKeyName.length;j++){
				var colId = varKeyName[j];
				if (strColId === colId){
					return true;
				}
			}
			
		} else {
			var colId = this._jsonPivotKey[i];
			if (strColId === colId){
				return true;
			}
		}
	}
	return false;
};
/**
 * @description	미결
 * @param	{string}	strColId
 * @return  {boolean}
 * @example	미결
 */
DataSet.prototype._isGroupColumn = function(strColId){
	for (var i=0; i < this._jsonGroupKey.length;i++){
		var varKeyName = this._jsonGroupKey[i];
		if (varKeyName instanceof Array) {
			for (var j=0; j < varKeyName.length;j++){
				var colId = varKeyName[j];
				if (strColId === colId){
					return true;
				}
			}
			
		} else {
			var colId = this._jsonGroupKey[i];
			if (strColId === colId){
				return true;
			}
		}
	}
	return false;
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{number}	varCol
 * @param	{string}	varVal
 * @param	{number}	nPivotIndex
 * @return  {undefined}
 * @example	미결
 */
DataSet.prototype._setPivotColumn = function(nRow, varCol, varVal, nPivotIndex){
	this._SetPivotColumn(nRow, varCol, varVal, nPivotIndex);
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{number}	varCol
 * @param	{string}	varVal
 * @param	{number}	nPivotIndex
 * @return  {undefined}
 * @example	미결
 */
DataSet.prototype._setPivotColumnNF = function(nRow, varCol, varVal, nPivotIndex){
	this._SetPivotColumn(nRow, varCol, varVal, nPivotIndex);
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{number}	varCol
 * @param	{number}	nPivotIndex
 * @return  {object}
 * @example	미결
 */
DataSet.prototype._getPivotColumn = function(nRow, nColIdx, nPivotIndex){
	return this._GetPivotColumn(nRow, nColIdx, nPivotIndex);
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{number}	varCol
 * @param	{number}	nPivotIndex
 * @return  {object}
 * @example	미결
 */
DataSet.prototype._getPivotColumnNF = function(nRow, nColIdx, nPivotIndex){
	return this._GetPivotColumn(nRow, nColIdx, nPivotIndex);
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{string}	strColId
 * @return  {object}
 * @example	미결
 */
DataSet.prototype._getPivotGroupColumn = function(nRow, strColId){
	return this._GetPivotGroupColumn(nRow, strColId);
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{string}	strColId
 * @return  {object}
 * @example	미결
 */
DataSet.prototype._getPivotGroupColumnNF = function(nRow, strColId){
	return this._GetPivotGroupColumn(nRow, strColId);
};
/**
 * @description	미결
 * @param	{number}	nRow
 * @param	{string}	strColId
 * @param	{number}	nPivotIndex
 * @return  {object}
 * @example	미결
 */
DataSet.prototype._getPivotPivotColumn = function(nRow, strColId, nPivotIndex){
	return this._GetPivotPivotColumn(nRow, strColId, nPivotIndex);
};
/**
 * Pivot Dataset의 Pivot된 갯수를 얻어오는 Property<br/>
 * pivotCount는 pivotTable의 Col 갯수를 return 합니다. pivotindex의 최대값+1 에 해당됩니다.<br/>
 * 각 pivotRow단위의 유효한 pivot column 갯수를 구하기 위해서는 pivotCount() 메소드를 사용합니다.<br/>
 * @return               (int) Pivot된 갯수
 * */
DataSet.prototype.getPivotIndexCount = function(){ return this._PivotIndexCount;};

/* 사용안한부분 
 // 설정으로만 동작하게 하고 사람이 조작 못하게 한다
DataSet.prototype.getReverseSubsum = function(){ return this._ReverseSubsum;};
DataSet.prototype.setReverseSubsum = function(reverseSubsum){
	this._ReverseSubsum = reverseSubsum;
	this._refreshPivot();
	return;
};

*/

/*
 * 	2016-04-19 추가(차중훈)
 */
/**
*     @description	미결
*     @param	{object}	control
*     @param	{number}	rowNum
*     @return	{number}
*     @example	미결
*/
function _common_convertToDsRowNum(control, rowNum){
	//시트에 연결된 데이터셋이 없는 경우
	if (control.dataBinds == null || getAssociativeArrayLength(control.dataBinds) == 0) return -1;
	//시트의 행번호가 1보다 작은 경우
	if(isNaN(rowNum) || rowNum > control.maxRows || rowNum < 1) return -1;
	
	//시트와 연결된 데이터셋을 찾는다.
	var dataset = null;
	for (var key in control.dataBinds){
		var bindInfo = control.dataBinds[key];
		if( typeof(bindInfo) == "function" ) continue;
		
		if (bindInfo.controlName == control.controlName) {
			if (dataset == null) {
				dataset = dataSets[bindInfo.datasetId];
				break;
			}	
		}
	}
	
	//시트에 연결된 데이터셋을 찾지 못한 경우
	if (dataset == null) return -1;

	//시트 행의 _$uid를 찾는다. 행의 _$uid와 데이터셋의 레코드의 _$uid로 연결된 행을 비교한다.
	var row_uid = null;
	var list = dataset.records;
	
	if( (typeof AUIDataSheet == "function" || control instanceof AUIDataSheet)
		|| (typeof AUIDataSheetM == "function" || control instanceof AUIDataSheetM)
	){
		row_uid = AUIGrid.getItemByRowIndex(control.AUIcontrolId, rowNum - 1)._$uid;
	}
	else if( typeof EasySheet == "function" || control instanceof EasySheet ){
		row_uid = control.rows(rowNum - controls.startRowColNum).rowId;
	}

	//데이터셋 레코드의 _$uid와 시트 행의 _$uid가 같은 레코드 번호를 찾는다.
	var recordNum = -1;
	for(var nRow = 0; nRow < list.length; nRow++){
		if(list[nRow]._$uid == row_uid){
			recordNum = nRow;
			break;
		}
	}
	
	//레코드 행번호 리턴한다. 레코드를 못 찾을 경우 -1을 리턴한다.
	return recordNum;
};

if (typeof AUIDataSheet == "function")
    AUIDataSheet.prototype.convertToDsRowNum = function(rowNum){ return _common_convertToDsRowNum(this, rowNum);};
if (typeof AUIDataSheetM == "function")
    AUIDataSheetM.prototype.convertToDsRowNum = function(rowNum){ return _common_convertToDsRowNum(this, rowNum);};

if( typeof EasySheet == "function" ){
	EasySheet.prototype.convertToDsRowNum = function(rowNum){ return _common_convertToDsRowNum(this, rowNum);};
}

/*
 *	2016-06-16 추가(차중훈)
 *
 *	DataSet.setInstantUpdateControl 함수
 */
    /**
     * @description	미결
     * @param	{boolean}	instantUpdateControl
     * @return  {boolean}
     * @example	미결
     */
DataSet.prototype.setInstantUpdateControl = function( instantUpdateControl ){
	//파라메터는 true 또는 false 로만 변경 가능(예외처리) : false 리턴
	if(typeof instantUpdateControl != "boolean") return false;
	
	//instantUpdateControl 속성 변경
	this.instantUpdateControl = instantUpdateControl;
	
	//변경된 instantUpdateControl 속성 값이 true 인 경우 데이터셋의 데이터를 컨트롤에 반영
	if( this.instantUpdateControl ){
		var sheet = "";
		for (var key in this.dataBinds){
			var bindInfo = this.dataBinds[key];
			if( typeof(bindInfo) == "function" ) continue;
			if (bindInfo.controlType != "Sheet" && bindInfo.controlType != "lstSheet") continue;
			sheet = controls[bindInfo.controlName];
			break;
		}
		
		var enableCellMerge = false;
		if( (typeof AUIDataSheet == "function" && sheet instanceof AUIDataSheet)
			|| (typeof AUIDataSheetM == "function" && sheet instanceof AUIDataSheetM)
		){
			enableCellMerge = (typeof AUIGrid != "undefined") ? AUIGrid.getProp(sheet.AUIcontrolId, "enableCellMerge") : false;
			if( enableCellMerge ) AUIGrid.setCellMerge(sheet.AUIcontrolId, false);
		}
		
//		if (this._GroupKey.length <= 0){
//			this.updateControlList();
//		}
		this.updateControlList();
		
		//데이터셋의 그룹키가 존재하는 경우
		if (this._GroupKey.length > 0){
		    this._refreshGroupCation(true);
		}
		//데이터셋의 데이터가 존재하는 경우
		if(this.getRowCount() > 0 && this.Row >= 0){
			//데이터셋의 데이터가 존재하고 데이터셋의 Row가 0 이상인(레코드를 가리키는) 경우
			this.updateControlRowPosition( this.Row );
		}
		else{
			this._clearControlData();
		}
		
		if( (typeof AUIDataSheet == "function" && sheet instanceof AUIDataSheet)
			|| (typeof AUIDataSheetM == "function" && sheet instanceof AUIDataSheetM)
		){
			if( enableCellMerge ) AUIGrid.setCellMerge(sheet.AUIcontrolId, enableCellMerge);
		}
	}
	
	//instantUpdateControl 속성 변경 및 데이터 반영이 완료되면 true 리턴
	return true;
};
/*
 *	2016-06-16 추가(차중훈)
 */

/*
 * 	2016-04-19 추가(차중훈)
 */
//	2016-05-23 : GDS_VALUE 추가
//var gds_value_object = {	
//		id:"GDS_VALUE", 
//		datasettype:"Dataset",
//		filterexpr:"",
//		groupkey:"",
//		pivotkey:"",
//		colinfos:[
//		        {id:"ReqVariable", size:"256", type:"Char", summ: ""},
//		        {id:"ReqVariableValue", size:"256", type:"Char", summ: ""}
//		],
//		records:[
//	         	{id:"dataset;gds_value;data1",	reqvariable:"USER_ID",		reqvariablevalue:USER_USERID},
//	         	{id:"dataset;gds_value;data2",	reqvariable:"PART",			reqvariablevalue:""},					//??
//	         	{id:"dataset;gds_value;data3",	reqvariable:"USER_NAME",	reqvariablevalue:USER_PERSONALNAME},
//	         	{id:"dataset;gds_value;data4",	reqvariable:"EMAIL",		reqvariablevalue:USER_EMAIL},
//	         	{id:"dataset;gds_value;data5",	reqvariable:"DEPT_CD",		reqvariablevalue:USER_PART},
//				{id:"dataset;gds_value;data6",	reqvariable:"DEPT_NM",		reqvariablevalue:USER_PART_NM},
//				{id:"dataset;gds_value;data7",	reqvariable:"EMAIL_PWD",	reqvariablevalue:""},
//				{id:"dataset;gds_value;data8",	reqvariable:"PWD",			reqvariablevalue:""},
//				{id:"dataset;gds_value;data9",	reqvariable:"WEB_ADMIN_YN",	reqvariablevalue:USER_WEB_ADMIN_YN},
//				{id:"dataset;gds_value;data10",	reqvariable:"EXTENAL_FLAG",	reqvariablevalue:USER_EXTENAL_FLAG},
//				{id:"dataset;gds_value;data11",	reqvariable:"SINGLE_PWD",	reqvariablevalue:USER_SINGLE_PWD},
//				{id:"dataset;gds_value;data12",	reqvariable:"RESIDENT_NO",	reqvariablevalue:USER_RESIDENT_NO},
//				{id:"dataset;gds_value;data13",	reqvariable:"DEPT_NM",		reqvariablevalue:USER_PART_NM},
//				{id:"dataset;gds_value;data14",	reqvariable:"PART",			reqvariablevalue:USER_PART},
//				{id:"dataset;gds_value;data15",	reqvariable:"IP",			reqvariablevalue:USER_IPADDR},
//				{id:"dataset;gds_value;data16",	reqvariable:"EMP_LEVEL",	reqvariablevalue:USER_EMP_LEVEL},
//				{id:"dataset;gds_value;data17",	reqvariable:"VEND_CD",		reqvariablevalue:""},					//??
//	         	{id:"dataset;gds_value;data18",	reqvariable:"USERID",		reqvariablevalue:USER_USERID},				
//				{id:"dataset;gds_value;data19",	reqvariable:"IPADDR",		reqvariablevalue:USER_IP}
//		] 
//};
//var GDS_VALUE = new DataSet(gds_value_object);
//dataSets["GDS_VALUE"]  = GDS_VALUE;
//// 2016-06-03 : PB 전달용 G 데이터셋 추가
//var _g_value_object = {	
//		id:"G", 
//        datasettype:"Dataset",
//        filterexpr:"",
//        groupkey:"",
//        pivotkey:"",
//        colinfos:[
//           			{id:"USERID", size:"256", type:"Char", summ: ""},
//           			{id:"IPADDR", size:"256", type:"Char", summ: ""}
//                 ],
//        records:[
//                   {id:"dataset;g;data1",ipaddr:USER_IP,userid:USER_USERID}
//                ] 
//       };
//var _G = new DataSet(_g_value_object);
//dataSets["_G"]  = _G;


if( typeof EasySheet != "undefined" ){
	EasySheet.prototype.getLookingRowNum = function(varRow){
		if( typeof varRow == "undefined" ){
			alert(getText("message_AUIDataSheet_020", "getAvailableRowNum(줄번호) 또는 getAvailableRowNum(\"줄ID\")의 형태로 사용하세요."));
			return -1;
		}
		
		var rowNum = -1;
		
		if( typeof varRow == "string" ){
			var result = this.dataSet.getData();
			
			if( result.result ){
				var datas = result.resultData;
				var state = null;
				var maxRow = datas.length;
				var i = 0;
				
				for(i = 0; i < maxRow; i++, state = null){
					state = datas[i].__STATE__;
					
					if( typeof state == "undefined" ) continue;
					
					if( state.rowId == varRow ){
						rowNum = i;
						state = null;
						break;
					}
				}
				
				datas.clear();
				datas = null;
			}
			
			result.resultData = null;
			result = null;
		}
		else if( typeof varRow == "number" ){
			rowNum = varRow;
		}
		
		return rowNum;
	}
}

DataSet.prototype.refresh = function(){
	this.setBlocking();
	
	if( this.FilterExpr.length > 0 )
		this.filter(this.FilterExpr);
	
	if( this.getGroupKey().length > 0 )
		this._ResetGroup();
	
	this.Row = 0;
	this.updateControlList();
	
	if( this.getGroupKey().length > 0 )
		this._refreshGroupCation(true);
	
	var key = null;
	var bindInfo = null;
	
	for(key in this.dataBinds){
		bindInfo = this.dataBinds[key];
		
		if( typeof bindInfo == "function" ){
			bindInfo = null; key = null;
			continue;
		}
		
		this.updateControlValue(bindInfo.colId);
		
		bindInfo = null; key = null;
	}
};/**
 * @class WebEditor를 만들어주는 클래스
 * @param controlId
 *            {String} Control의 id를 입니다.
 * @param controlName
 *            {String} Control의 name을 입니다.
 * @param tagObject
 *            {Object} 태그객체 입니다.
 * @example 미결
 */  
function WebEditor(controlId, controlName, tagObject){
    this.base = ControlBase;      //부모클래스 지정
    this.base(controlId, controlName, tagObject);         //부모클래스 생성자호출
//    this.value = tagObject.innerHTML.replaceWord("<BR/>", "\r\n");
    this.value = "";
};

WebEditor.prototype = new ControlBase();

/*
function searchControl_Label(em){
	var pEm = em;
	var wReturn = null;
	
	while (pEm.parentNode && !pEm.className.startsWith("Label")) 
		pEm = pEm.parentNode;
	if (pEm.className.startsWith("Label")) 
	    wReturn = getControlById(pEm.id);
	
	return wReturn;
};
*//*
 *   이클립스에서 리포트가 제대로 나오게 하기 위해서는 하단의 서버를 더블클릭한 후 
 *   "Server Options"의 "Serve modules without publishing"에 체크해 주어야 한다
 * */

/**                                                                                         
 *       @class          Report 클래스                                                     
 *       @constructor    Report                                           
 *                                                                                           
 *       @param          controlId     {String}      해당 컨트롤의 ID를 지정합니다.                              
 *       @param          controlName   {String}      해당 컨트롤의 Name을 지정합니다.                            
 *       @param          tagObject     {Object}      해당 컨트롤의 태그 객체를 지정합니다.
 *                                                                                           
 *       @return         객체 생성 성공하면 객체의 errorMsg 필드가 null 입니다.<br>만약 에러가 발생한다면 errorMsg 필드에 에러메시지를 반환합니다.
 *
 *       @example        var wReport = new Report();
 *        if( wReport.errorMsg != null ){
 *           //객체 생성 실패하였습니다. 에러처리 코드를 입력해주세요.
 *        }
 *       wReport.reportId = "2002";             //레포트 ID는 2002 입니다.
 *       wReport.reportName = "거래명세서";     //레포트명은 거래명세서입니다.
 *       wReport.reportType = "hpt";            //
 *       wReport.directPrint = "false";         //출력할 프린터 설정을 하지 않았습니다.
 *       wReport.filePrint = "false";           //파일출력 설정을 하지 않았습니다.
 */
function Report(){
	/**
	 *   @description    레포트 ID 입니다.<br>기본값 : 없음.<br><br>
	 */
	this.reportId = "";   // ex: "1176" 
	/**
	 *   @description    레포트명 입니다.<br>기본값 : 없음.<br><br>
	 */
	this.reportName = ""; // ex: "급여처리"
	/**
	 *   @description    레포트 형식입니다.<br>기본값 : 없음.<br><br>
	 */
	this.reportType = "";
	/**
	 *   @description    레포트를 출력할 프린터를 가리킵니다.<br>기본값 : 없음.<br><br>
	 */
	this.directPrint = "";
	/**
	 *   @description    레포트를 출력할 파일을 가리킵니다.<br>기본값 : 없음.<br><br>
	 */
	this.filePrint = "";
	/**
	 *   @description    레포트로 보낼 파라메터 배열입니다.<br>기본값 : 없음.<br><br>
	 */
	this.parameters = [];
    reports[reports.length] = this;
	/**
	 * @description	미결
	 */
    this.busy = false;
    /**
	 *   @description    레포트를 출력할 Target(=IFrame콘트롤명) 입니다.<br>기본값 : 없음.<br><br>
	 */
	this.reportTarget = "";
};

/**
 *       @description    레포트에 파라메터를 설정한다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *       @param          fieldName       {String}                            파라메터 배열의 키 값을 입력합니다.
 *       @param          dataValue       {Number, String, Boolean, Object}   해당 파라메터의 값을 입력합니다.
 *       @return         파라메터 설정을 성공한다면 true를 반환합니다.<br>만약 에러가 발생하였다면 false를 반환합니다.
 *       @example        var wReport = new Report();
 *        if( wReport.errorMsg != null ){
 *           //객체 생성 실패하였습니다. 에러처리 코드를 입력해주세요.
 *        }
 *       wReport.reportId = "2002";
 *       wReport.reportName = "거래명세서";
 *       wReport.reportType = "hpt";
 *       wReport.directPrint = "false";
 *       wReport.filePrint = "false";
 *        
 *        //출고일자 파라메터에 TextBox_2 컨트롤의 값을 저장합니다.
 *        if( wReport.setParameter("출고일자", controls["TextBox_2"].value) == false ){
 *              //파라메터값 저장 실패하였습니다. 에러처리 코드를 입력해주세요.
 *        }
 */
Report.prototype.setParameter = function(fieldName, dataValue){
	// functionname : [Report.setParameter]

    this.parameters[fieldName] = dataValue;
    return;
};

/**
 *       @description    레포트를 실행, 화면에 출력합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
 *       @return         레포트 실행을 성공한다면 true를 반환합니다.<br>만약 에러가 발생하였다면 false를 반환합니다.
 *       @example        var wReport = new Report();
 *        if( wReport.errorMsg != null ){
 *           //객체 생성 실패하였습니다. 에러처리 코드를 입력해주세요.
 *        }
 *       wReport.reportId = "2002";
 *       wReport.reportName = "거래명세서";
 *       wReport.reportType = "hpt";
 *       wReport.directPrint = "false";
 *       wReport.filePrint = "false";
 *
 *        //출고일자 파라메터에 TextBox_2 컨트롤의 값을 저장합니다.
 *        if( wReport.setParameter("출고일자", controls["TextBox_2"].value) == false ){
 *              //파라메터값 저장 실패하였습니다. 에러처리 코드를 입력해주세요.
 *        }
 *
 *        //레포트를 실행합니다.
 *        if( wReport.excute() == false ){
 *               //레포트 실행 실패하였습니다. 에러처리 코드를 입력해주세요.
 *        }
 */
Report.prototype.execute = function(){
	// functionname : [Report.execute]

    var reportId = this.reportId;
    
    var paramString = "";
    for (var key in this.parameters){
		if (typeof(this.parameters[key])=="function") continue;
    	paramString += this.parameters[key] + ";";
    }
    
    var wQueryString = "cogu=" + (USER_COGU == undefined || USER_COGU == "" ? 0 : USER_COGU)
    				 + "&personalid=" + (USER_PERSONALID == undefined || USER_PERSONALID == "" ? 0 : USER_PERSONALID) 
                     + "&reportid=" + encodeURIComponent(reportId)
                     + "&parameters=" + encodeURIComponent(paramString)
                     + "&lang=" + USER_LANGUAGE
	                 + "&tm=" + (new Date()).valueOf();
    
    this.busy = true;
    ajaxCall("POST", "ViewReport.do", wQueryString, this, "textGetReport", 30);
    
//    var win = window.open("", "", "width=1024px, height=768px, toolbar=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no");
//    win.document.write('<style type="text/css">body{margin:0;padding:0;}</style>');
//    win.document.write('<iframe src="ViewReport.do?'+wQueryString+'" width="100%" height="100%"></iframe>');
//    win.document.write('<object data="ViewReport.do?'+wQueryString+'" type="application/pdf" width="100%" height="100%"></object>');
//    win.document.write('<embed src="ViewReport.do?'+wQueryString+'" type="application/pdf" width="100%" height="100%"></embed>');
//    win.document.write('<form action="ViewReport.do?'+wQueryString+'" method="POST" name="frm1"></form>');
//    win.document.frm1.submit();
    
    return;
};

/**
*     @description    서버로부터 리포트 데이터가 전송되면 데이터를 받아 팝업창으로 출력합니다.<br>만약 메소드가 동작 중 에러가 발생하였다면 에러메세지는 객체의 errorMsg 필드에서 확인할 수 있습니다.
*     @param          info        {Object}    서버로부터 받은 리포트 결과입니다.    
*     @param          message     {String}    서버로부터 받은 오류메세지입니다.
*     @param          pFlag       {??}        ??   
*     @return         레포트 출력을 성공한다면 true를 반환합니다.<br>만약 에러가 발생하였다면 false를 반환합니다.
*/
Report.prototype.parseData = function(info, message, pFlag){
	// functionname : [Report.parseData]
	this.busy = false;  
	
//	reports.splice(reports.indexOf(this.reportId),1);
//	
//	if (reports.length == 0) {
//		hideAjaxBox();
//	}
	
	// 오류 메시지 먼저 파악 
	if (info == null){
		callEvent("report" + this.reportId + "_Failed", message);
		return;
	}
	
	try {
//		var send = new Object();  
//        send.reportInfo = info;
//        var sFeatures = "dialogHeight=768px;dialogWidth=1024px;scroll=no;status=no;help=no;center=yes;resizable=yes";
//        self.showModalDialog(getContextPath() + "/pages/groupware/report/ViewReport.jsp", send, sFeatures);
		
//		var win = window.open("data:application/pdf;base64,"+escape(info), "_blank", "width=1024px, height=768px, toolbar=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no");
//		win.document.write('<object id="pdf" border="0" width="100%" height="100%" type="application/pdf" data="'+escape(info)+'" standby="Loading pdf..."></object>');
//		win.document.write('<embed id="pdf" src="'+escape(info)+'" width="100%" height="100%" type="application/pdf" /></object>');
//		var wndw = window.open("https://get.adobe.com/kr/reader/", "_blank", "width=1024px, height=768px, toolbar=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no");
//		var wndw = window.open(info, "_blank", "width=1024px, height=768px, toolbar=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no");
//		if (!wndw) throw "팝업이 차단 되었습니다. 레포트를 실행하시려면 팝업을 허용해 주세요. \n ※팝업차단허용방법: 브라우저 상단 메뉴바에서 [도구]-[팝업차단]-[팝업차단설정] 에서 허용할 웹사이트 주소란에 주소를 추가해 주시고 레포트를 실행해 주세요.";
//		alert(info);
//		var win = window.open("about:blank", "_blank", "width=1024px, height=768px, toolbar=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no");
//		var win = window.open("/FlexFrame/index.jsp", "_blank", "width=1024px, height=768px, toolbar=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no");
		
		if (typeof this.reportTarget == "string" && this.reportTarget.trim() != "" && controls[this.reportTarget] != undefined) {
			controls[this.reportTarget].iframe.src = "ViewReportLoad.do?fileName="+encodeURI(encodeURIComponent(info));
		} else {
			if (BrowserDetect.browser == "Explorer") {
				var win = window.open("ViewReportLoad.do?fileName="+encodeURI(encodeURIComponent(info)), "_blank", "width=1024px, height=768px, toolbar=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no");
			} else {
				var win = window.open("about:blank", "_blank", "width=1024px, height=768px, toolbar=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no");
				if (!win) throw getText("message_report_001", "팝업이 차단 되었습니다. 레포트를 실행하시려면 팝업을 허용해 주세요. \n ※팝업차단허용방법: 브라우저 상단 메뉴바에서 [도구]-[팝업차단]-[팝업차단설정] 에서 허용할 웹사이트 주소란에 주소를 추가해 주시고 레포트를 실행해 주세요.");
				setTimeout(function (){
				win.document.write('<html><head><title>'+info.split("|")[2]+'</title><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><style type="text/css">body{margin:0;padding:0;height:100%;}</style></head>');
				win.document.write('<body><iframe src="ViewReportLoad.do?fileName='+encodeURI(encodeURIComponent(info))+'" width="100%" height="100%" marginheight="0" marginwidth="0" border="0" frameborder="0" scrolling="no"></iframe></body></html>');
				}, 100);
			}
		}
		
//		win.document.write('<iframe src="/FlexFrame/test/20171109134217730.pdf" width="100%" height="100%" marginheight="0" marginwidth="0" border="0" frameborder="0" scrolling="no"></iframe>');
//		win.document.write('<object data="ViewReportDownload.do?fileName='+info+'" type="application/pdf" width="100%" height="100%"></object>');
//		win.document.write('<embed src="ViewReportDownload.do?fileName='+info+'" type="application/pdf" width="100%" height="100%"></embed>');
		
        callEvent("report" + this.reportId + "_Completed");
	} catch(e){
	    alert(e);
	}
	
	return;
};

/**
 * @description	미결
 * @return 		{void}
 * @example		미결
 */
Report.prototype.executeMerge = function() {
	// functionname : [Report.executeMerge]
	if (reports.length == 0) return;
		
	var reportId = "";
	var paramString = "";
	
	for (var i = 0; i < reports.length; i++) {
		reportId += reports[i].reportId + "|";
		for (var key in reports[i].parameters){
			if (typeof(reports[i].parameters[key])=="function") continue;
	    	paramString += reports[i].parameters[key] + ";";
	    }
		paramString += "|";
	}
	
	var wQueryString = "cogu=" + USER_COGU + "&personalid=" + USER_PERSONALID 
				     + "&reportid=" + encodeURIComponent(reportId)
				     + "&parameters=" + encodeURIComponent(paramString)
				     + "&lang=" + USER_LANGUAGE
				     + "&tm=" + (new Date()).valueOf();
	this.busy = true;
	ajaxCall("POST", "ViewReport.do", wQueryString, this, "textGetReport", 30);
	
	return;
};//체크조건, 시트 셀타입 상수
	var CHECKNAME = [
	                 getText("message_checkMemory_001", "없음"), 
	                 getText("message_checkMemory_002", "산식체크"), 
	                 getText("message_checkMemory_003", "년도"), 
	                 getText("message_checkMemory_004", "년월"), 
	                 getText("message_checkMemory_005", "년월일"), 
	                 getText("message_checkMemory_006", "주민등록번호"), 
	                 getText("message_checkMemory_007", "사업자등록번호"), 
	                 getText("message_checkMemory_008", "우편번호"), 
	                 "", 
	                 getText("message_checkMemory_009", "금액"), 
	                 getText("message_checkMemory_010", "숫자"), 
	                 getText("message_checkMemory_011", "한글"), 
	                 getText("message_checkMemory_012", "영문/숫자"), 
	                 getText("message_checkMemory_013", "바코드"), 
	                 getText("message_checkMemory_014", "패스워드")];
	var CELLTYPE = ["CELLTYPE_DATE", "CELLTYPE_EDIT", "", "CELLTYPE_INTEGER", "CELLTYPE_PIC", "CELLTYPE_STATICTEXT", "CELLTYPE_TIME", "CELLTYPE_BUTTON", "CELLTYPE_COMBOBOX", "CELLTYPE_PICTURE", "CELLTYPE_CHECKBOX", "CELLTYPE_OWNERDRAWN", "CELLTYPE_CURRENCY", "CELLTYPE_NUMBER", "CELLTYPE_PERCENT"];
		
	//메모리 상태 정보를 저장하는 객체
	/**
     * @description	미결
     * @property optionButton checkMemory.js 안에서 미작성
     * @example	미결
     */
	function memoryInfos(){
		//this.formInfo;
		this.parameter = [];
		this.textBox = [];
		this.checkBox = [];
		this.comboBox = [];
		this.listBox = [];
		this.optionButton = [];
		this.tabBox = [];
		this.sheet = [];
		this.object = [];
	};

	//파라메터 정보를 저장하는 객체(생성자)
	/**
     * @description	미결
     * @param	{objects}	paramKey
     * @return  {undefined}
     * @example	미결
     */
	function _Parameter(paramKey){
		var value = parameters[paramKey];
		var _value = "";
		
		if(typeof value == "undefined") value = "";
		if(typeof DataSet == "function" && dataSets[value.id] instanceof DataSet){
			value = value.id;
		}
		
		for(var i = 0; i < ("" + value).length; i = i + 50){
			_value += value.substring(i, i + 50) + ( ("" + value).length > 50 ? "<br>" : "" );
		}
			
		this.name = paramKey;			//파라메터 명
		this.value = _value;			//파라메터 값
		this.type = typeof(value);		//파라메터 타입
	};

	//텍스트박스 정보를 저장하는 객체(생성자)
	/**
     * @description	미결
     * @param	{object}	wControl
     * @return  {undefined}
     * @example	미결
     */
	function _TextBox(wControl){
		this.controlName = wControl.controlName;
		this.value = wControl.value;
		//속성
		this.defaultValue = (wControl.defaultValue != "") ? getText("message_checkMemory_015", "디폴트 값 : {0}<br>", [wControl.defaultValue]) : "";
		this.dispFormat = (wControl.dispFormat != "") ? getText("message_checkMemory_016", "표시형식 : {0}<br>", [wControl.dispFormat]) : "";
		this.multiLine = (wControl.multiLine) ? getText("message_checkMemory_017", "여러줄허용 : 허용<br>") : "";
		this.enabled = (wControl.enabled != "") ? "" : getText("message_checkMemory_018", "동작가능 : 비활성화<br>");
		this.visible = (wControl.visible != "") ? "" : getText("message_checkMemory_019", "보이기 : 숨김<br>");
		this.checkType = (wControl.checkType > 0) ? getText("message_checkMemory_020", "체크조건 : {0}<br>", [CHECKNAME[wControl.checkType]]) : "";
	};

	//콤보박스 정보를 저장하는 객체(생성자)
	/**
     * @description	미결
     * @param	{object}	wControl
     * @return  {undefined}
     * @example	미결
     */
	function _ComboBox(wControl){
		this.controlName = wControl.controlName;
		this.outValue = [];
		this.inValue = [];
		this.selectValue = wControl.value;
		//속성
		this.defaultValue = (wControl.defaultValue * 1 != -1) ? getText("message_checkMemory_015", "디폴트 값 : {0}<br>", [wControl.defaultValue]) : "";
		this.enabled = (wControl.enabled) ? "" : getText("message_checkMemory_018", "동작가능 : 비활성화<br>");
		this.visible = (wControl.visible) ? "" : getText("message_checkMemory_019", "보이기 : 숨김<br>");
		this.checkType = (wControl.checkType > 0) ? getText("message_checkMemory_020", "체크조건 : {0}<br>", [CHECKNAME[wControl.checkType]]) : "";
		//겉값&속값  채우기
		var wOptions = wControl.tagObject.options;
		for(var i = 0; i < wOptions.length; i++){
			this.outValue[i] = wOptions[i].text;
			this.inValue[i] = wOptions[i].value;
		}
	};

	//리스트박스 정보를 저장하는 객체(생성자)
	/**
     * @description	미결
     * @param	{object}	wControl
     * @return  {undefined}
     * @example	미결
     */
	function _ListBox(wControl){	
		this.controlName = wControl.controlName;
		this.outValue = [];
		this.inValue = [];
		this.selectValue = wControl.value;
		//속성
		this.defaultValue = (wControl.defaultValue != "") ? getText("message_checkMemory_015", "디폴트 값 : {0}<br>", [wControl.defaultValue]) : "";
		this.enabled = (wControl.enabled) ? "" : getText("message_checkMemory_018", "동작가능 : 비활성화<br>");
		this.visible = (wControl.visible) ? "" : getText("message_checkMemory_019", "보이기 : 숨김<br>");
		this.checkType = (wControl.checkType > 0) ? getText("message_checkMemory_020", "체크조건 : {0}<br>", [CHECKNAME[wControl.checkType]]) : "";
		//겉값&속값 채우기
		var wOptions = wControl.tagObject.options;
		for(var i = 0; i < wOptions.length; i++){
			this.outValue[i] = wOptions[i].text;
			this.inValue[i] = wOptions[i].value;
		}
	};

	//체크박스 정보를 저장하는 객체(생성자)
	/**
     * @description	미결
     * @param	{object}	wControl
     * @return  {undefined}
     * @example	미결
     */
	function _CheckBox(wControl){
		this.controlName = wControl.controlName;
		//this.value = wControl.value;
		//this.defaultValue = wControl.defaultValue;
		this.value = (wControl.value == 1) ? "선택" : "";
		//속성
		this.defaultValue = (wControl.defaultValue == 1) ? getText("message_checkMemory_021", "디폴트 값 : 선택") : "";
		this.enabled = (wControl.enabled) ? "" : getText("message_checkMemory_018", "동작가능 : 비활성화<br>");
		this.visible = (wControl.visible) ? "" : getText("message_checkMemory_019", "보이기 : 숨김<br>");
		this.checkType > 0 ? getText("message_checkMemory_020", "체크조건 : {0}<br>", [CHECKNAME[wControl.checkType]]) : "";
	};

	//옵션버튼 정보를 저장하는 객체(생성자)
	/**
     * @description	미결
     * @param	{object}	wControl
     * @return  {undefined}
     * @example	미결
     */
	function _OptionButton(wControl){
		
	}

	//탭박스 정보를 저장하는 객체(생성자)
	/**
     * @description	미결
     * @param	{object}	wControl
     * @return  {undefined}
     * @example	미결
     */
	function _TabBox(wControl){
		this.controlName = wControl.controlName;
		this.tabCells = [];
		this.selectTab = (wControl.CurrentTab * 1) - 1;
		//속성
		this.tabCount = wControl.tabcount;
		this.defaultValue = (wControl.defaultValue != "") ? getText("message_checkMemory_015", "디폴트 값 : {0}<br>", [wControl.defaultValue]) : "";
		this.enabled = (wControl.enabled) ? "" : getText("message_checkMemory_018", "동작가능 : 비활성화<br>");
		this.visible = (wControl.visible) ? "" : getText("message_checkMemory_019", "보이기 : 숨김<br>");	
	};
	
	//
	/**
     * @description	미결
     * @return  {undefined}
     * @example	미결
     */
	function _Header(){
		this.name = "";
		this.type = "";
		this.defaultValue = "";
		this.defaultDisplayFormat = "";
		this.defaultFomula = "";
		this.defaultLockMode = false;
		this.hidden = false;
	};
	
	//
	/**
     * @description	미결
     * @return  {undefined}
     * @example	미결
     */
	function _Cell(){
		this.value = "";
		this.cellType = "";
		this.lockMode = false;
		this.hidden = false;
	};
	
	//
	/**
     * @description	미결
     * @return  {undefined}
     * @example	미결
     */
	function _RowData(){
		this.data = [];
	};
	
	//시트 정보를 저장하는 객체(생성자)
	/**
     * @description	미결
     * @param	{object}	wControl
     * @return  {undefined}
     * @example	미결
     */
	function _DataSheet(wControl){
		this.controlName = wControl.controlName;
		//테이블 속성
		this.enabled = (wControl.enabled) ? getText("message_checkMemory_022", "활성화") : getText("message_checkMemory_023", "비활성화");
		this.visible = (wControl.visible) ? getText("message_checkMemory_025", "보임") : getText("message_checkMemory_026", "숨김");
		this.sheetType = (wControl.sheetType == SHEETTYPE_DATASHEET) ? getText("message_checkMemory_027", "데이터 시트(입력용)") : getText("message_checkMemory_028", "리스트 시트(조회용)");
		this.linkedObjects = wControl.linkedObjects;
		this.frozenCols = wControl.frozenCols;
		this.frozenRows = wControl.frozenRows;
		//시트 프로퍼티 속성
		this.header = [];
		this.headCnt = wControl.columns.length - 1;
		//시트 데이터 속성
		this.rowData = [];
		this.rowCnt = wControl.rows.length - 1;
		//시트 프로퍼티 채우기
		var propertyTitle = wControl.colHeadTable.rows[0].innerHTML.replace(RegExp(/\s/img), "").replace(RegExp(/[\w<>=":;&]/ig), "").replace(RegExp(/\/$/ig), "").replace(RegExp(/^\//ig), "").split("/");
		for(var i = 1; i < wControl.columns.length; i++){
			var column = wControl.columns[i];
			this.header[i - 1] = new _Header();
			this.header[i - 1].name = propertyTitle[i - 1];
			this.header[i - 1].type = CELLTYPE[column.defaultCellType];
			this.header[i - 1].defaultValue = column.defaultValue;
			this.header[i - 1].defaultDisplayFormat = column.defaultDisplayFormat;
			this.header[i - 1].defaultFormula = column.defaultFormula;
			this.header[i - 1].defaultLockMode = column.defaultLockMode;
			this.header[i - 1].hidden = column.hidden;
		}
		//시트  데이터 채우기
		for(var i = 1; i < wControl.rows.length; i++){
			var row = wControl.rows[i];
			this.rowData[i - 1] = new _RowData();
			for(var j = 1; j < row.cells.length; j++){
				var cell = row.cells[j];
				this.rowData[i - 1].data[j - 1] = new _Cell();
				switch(cell.celltype){
				case CELLTYPE_COMBOBOX	:
					this.rowData[i - 1].data[j - 1].value = cell.value + " / " + cell.value1;
					break;
				case CELLTYPE_CHECKBOX	:
					this.rowData[i - 1].data[j - 1].value = cell.value * 1;
					//this.rowData[i - 1].data[j - 1].value = (cell.value * 1 == 1) ? "선택" : "";
					break;
				case CELLTYPE_BUTTON 	:
					//this.rowData[i - 1].data[j - 1].value = cell.buttonImage1.src;
					this.rowData[i - 1].data[j - 1].value = "<img src=\"" + cell.buttonImage1.src + "\">";
					break;
				case CELLTYPE_PICTURE	:
					this.rowData[i - 1].data[j - 1].value = cell.value;
					break;
				default					:
					this.rowData[i - 1].data[j - 1].value = cell.value;
					break;
				}
				this.rowData[i - 1].data[j - 1].cellType = cell.celltype;
				this.rowData[i - 1].data[j - 1].lockMode = cell.lockMode;
				this.rowData[i - 1].data[j - 1].hidden = cell.hidden;
			}
		}
	};
	
	//
	/**
     * @description	미결
     * @return  {undefined}
     * @example	미결
     */
	function _property(){
		this.name = "";
		this.fieldID = "";
		this.propertyGu = "";
		this.dataType = "";
		this.isKey = false;
		this.isSeqKey = false;
		this.formula = "";
		this.defaultValue = "";
		this.permitNull = fasle;
		this.seqClear = false;
		this.linkedList = false;
		this.linkedSheet = false;
	};
	
	//
	/**
     * @description	미결
     * @return  {undefined}
     * @example	미결
     */
	function _record(){
		this.value = [];
		this.skipGu = "";
		this.updateGu = "";
	};
	
	//객체(오브젝트) 정보를 저장하는 객체(생성자)
	/**
     * @description	미결
     * @param	{object}	wObject
     * @return  {undefined}
     * @example	미결
     */
	function _Object(wObject){
		this.objectName = wObject.name;
		this.tableID = wObject.wObject.tableID;
		this.objectType = wObjectType.objectType;
		this.skipFormula = wObjectType.skipFormula;
		this.properties = [];
		this.recordset = [];
		//객체 프로퍼티 정보 채우기
		for(var i = 1; i < wObject.propertyCount; i++){
			var property = wObject.propertyInfos[i];
			this.properties[i - 1] = new _property();
			this.properties[i - 1].name = property.name;
			this.properties[i - 1].fieldID = property.fieledID;
			this.properties[i - 1].propertyGu = property.propertyGu;
			this.properties[i - 1].dataType = property.dataTypeName;
			this.properties[i - 1].isKey = property.isKey;
			this.properties[i - 1].isSeqKey = property.isSeqKey;
			this.properties[i - 1].formula = property.formula;
			this.properties[i - 1].defaultValue = property.defaultValue;
			this.properties[i - 1].permitNull = property.permitNull;
			this.properties[i - 1].seqClear = property.seqClear;
			this.properties[i - 1].linkedList = property.linkedToListControl;
			this.properties[i - 1].linkedSheet = property.sheetLinked;
		}
		//객체 레코드셋 데이터 채우기
		for(var i = 1; i < wObject.recordset.length; i++){
			var record = wObject.recordset[i];
			this.recordset[i - 1] = new _record();
			for(var j = 1; j < wObject.propertyCount; j++){
				var propertyName = this.properties[j - 1].name;
				this.recordset[i - 1].value[j - 1] = record.properties[propertyName].value;
			}
			this.updateGu = record.updateGu;
			this.skipGu = record.skipGu;
		}
	};

	//메모리 상태를 보여준다
	/**
     * @description	미결
     * @param	{object}	e
     * @return  {undefined}
     * @example	미결
     */
	function checkMemory(e){
		
		    e = e || event;
		    var em = getSrcElement(e);
		    
			if (!getCtrlPressed(e)){   
			   		return true;
		    } 
		    
			var memInfo = new memoryInfos();
			
			// 팝업창 헤더
			// 팝업창의 html, body 태그를 연다.
			var pageContent = "<HTML>"
							+ "<HEAD>"
							+ "<TITLE>" + getText("message_checkMemory_029", "콘트롤 데이터") + "</TITLE>"
							+ "<link rel=\"stylesheet\" type=\"text/css\" href=\"" + getContextPath() + "/css/EasyClient.css\"/>"
							+ "<style type=\"text/css\">"
							+ ".DataSheet table {table-layout:auto}"
							+ "</style>"
							+ "</HEAD>"
				            + "<body scroll=\"auto\" resizable=\"no\">";
			
			//아코디언 메뉴 동작을 위한 스크립트 코딩
			pageContent += "<script type=\"text/javascript\">";
			pageContent += 	"function showDisplay(divName){"
						+ 	"var tagObject = document.getElementsByName(divName)[0];"
						+ 	"if( tagObject.style.display == \"none\" ){tagObject.style.display = \"block\";}"
						+ 	"else{tagObject.style.display = \"none\";}"
						+ 	"return ;}";
			//이벤트 버블링을 막기 위한 스크립트 코딩
			pageContent += 	"function stopPropagation(event){"
			    		+ 	"if (event.stopPropagation){ event.stopPropagation(); }"
			    		+ 	"else { window.event.cancelBubble = true; }"
			    		+ 	"};";
			pageContent += "</script>";
			
			// 파라메터
			// 파라메터를 '파라메터명'('파라메터타입'/'파라메터속성')'과 '파라메터 값'을 테이블로 보여준다.	
			for(var key in parameters){	
				if( key == "" ) continue;
				var param = parameters[key]
				if( typeof(param) == "function" ) continue;
				
				memInfo.parameter[key] = new _Parameter(key);
			}
			
			//파라메터 출력
			pageContent += "<div id=\"label_param\" name=\"label_param\" align=\"center\" onclick=showDisplay(\"tab_param\") style=\"background-color: #ccccff; width: 100%; padding: 12px; border: 1px solid #ffffff;\"> " + getText("message_checkMemory_030", "파라메터(Parameter)") + " </div>"
						+ "<div id =\"tab_param\" name=\"tab_param\" tabname=\"" + getText("message_checkMemory_031", "파라메터") + "\" style=\"display :none\"><br>"
						+ "<div class=\"DataSheet\" style=\"width: 100%; border: 1px solid #ccccff; padding: 10px\">"
						+ "<table style=\"width: 100%;\">"
						+ "<tr> <td class=\"lColHead\" width=\"20%\" align=\"center\" > " + getText("message_checkMemory_032", "파라메터 명") + " </td>"
						+ "<td class=\"lColHead\" width=\"60%\" align=\"center\" > " + getText("message_checkMemory_033", "파라메터 값") + " </td>"
						+ "<td class=\"lColHead\" width=\"20%\" align=\"center\" > " + getText("message_checkMemory_034", "파라메터 타입") + " </td> </tr>";
				
			for(var key in memInfo.parameter){
				var param = memInfo.parameter[key];
				
				if( typeof(param) == "function" ) continue;
				
				pageContent +="<tr>" 
							+ "<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + param.name + "</td>"
							+ "<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + param.value + "</td>"
							+ "<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + param.type + "</td>"
							+ "</tr>";
			}
			
			pageContent += "</table>"
						+ "</div><br></div>";
			//
			
			// 콘트롤
			// 콘트롤을 종류별로 ROWSPAN하여 카테고리를 만들어 테이블로 보여준다.
			// 콘트롤은 '콘트롤 종류(타입)', '콘트롤명', '콘트롤 값', '콘트롤 속성'을 보여준다.
			//  1. 텍스트 박스는 콘트롤의 값을 보여준다.
			//  2. 체크박스는 선택된 컨트롤에만 '선택'으로 표기한다.
			//  3. 콤보박스는 현재 선택된 아이템의 겉값과 속값을 보여준다. 
			//  4. 옵션버튼은 그룹별로 보여주며 갑은 선택된 컨트롤에만 '선택'으로 표기한다.
			//  5. 탭은 현재 선택된 탭 명을 보여준다.
			//  6. 시트는 헤더에는 '필드명'('필드타입')을 보여주고 바디에 현재 필드의 데이터를 보여준다. (시트는 다른 콘트롤과 다르게 독립적인 테이블로 보여준다.)
			//  7. 라벨, 프레임, 그리드 등 위에서 제외된 콘트롤은 보여주지 않는다.
			
			//각 컨트롤별  카운트용 변수
			var textboxCnt = 0;
			var comboboxCnt = 0;
			var listboxCnt = 0;
			var checkboxCnt = 0;
			var optionbuttonCtrl = [];	var optionbuttonCnt = 0;
			var tabboxCtrl = [];		var tabboxCnt = 0;
			var sheetCnt = 0;
			//var tblHeadLength = 0;
			
			//각 컨트롤 보여줄 데이터 세팅
			for (var key in controls){
				var wControl = controls[key];
				//
				if (typeof(wControl) == "function" ) continue;
				//텍스트박스 컨트롤만 세팅
				try{
					if ( wControl instanceof TextBox ){
						memInfo.textBox[wControl.controlName] = new _TextBox(wControl);
						textboxCnt++;
					}
				}
				catch(e){}
				//콤보박스 컨트롤만 세팅
				try{
					if ( wControl instanceof ComboBox ){					
						memInfo.comboBox[wControl.controlName] = new _ComboBox(wControl);
						comboboxCnt++;
					}
				}
				catch(e){}
				//리스트박스 컨트롤만 세팅
				try{
					if ( wControl instanceof ListBox){
						memInfo.listBox[wControl.controlName] = new _ListBox(wControl);
						listboxCnt++;
					}
				}
				catch(e){}
				//체크박스 컨트롤만 세팅
				try{
					if ( wControl instanceof CheckBox){
						memInfo.checkBox[wControl.controlName] = new _CheckBox(wControl);
						checkboxCnt++;
					}
				}
				catch(e){}
				//옵션버튼 컨트롤만 세팅
				try{
					if ( wControl instanceof OptionButton && wControl.value != undefined ){
						optionbuttonCtrl[optionbuttonCnt]= [
						                                    wControl.optionGroupName,
						                                    wControl.controlName,
						                                    (wControl.value == 1) ? getText("message_checkMemory_035", "선택") : "",
						                                    (getText("message_checkMemory_036", "디폴트 값 : ") + wControl.matchUpValue)
						                                    ];
						optionbuttonCnt++;
					}
				}
				catch(e){}
				//탭박스 컨트롤만 세팅
				try{
					if ( wControl instanceof TabBox ){
						var tabData = [];
						var tabTitle = wControl.tagObject.rows[0];
						for(var i = 0; i < wControl.tabcount; i++){
							tabData[i] = [
							              tabTitle.cells[i].title, 
							              tabTitle.cells[i].tabnum, 
							              ( tabTitle.cells[i].tabnum == ((wControl.CurrentTab * 1) - 1) ) ? getText("message_checkMemory_024", " --- (선택) ") : ""];
						}
						
						tabboxCtrl[tabboxCnt] = [
						                         wControl.controlName,
						                         tabData,
						                         [ (getText("message_checkMemory_037", "탭 갯수 : ") + wControl.tabcount + "<br>"),
						                           (wControl.defaultValue != "" ? getText("message_checkMemory_036", "디폴트 값 : ") + wControl.defaultValue + "<br>" : ""),
						                           (wControl.enabled ? "" : getText("message_checkMemory_018", "동작가능 : 비활성화<br>")),
						                           (wControl.visible ? "" : getText("message_checkMemory_019", "보이기 : 숨김<br>"))
						                          ]
						                         ];
						
						tabboxCnt++;
					}
				}
				catch(e){}
				//시트 컨트롤만 세팅
				try{
					if ( control.controlId.toLowerCase().indexOf("sheet_") >= 0 && control.controlId.toLowerCase().indexOf("listsheet_") < 0 ){
						memInfo.sheet[wControl.controlName] = new _DataSheet(wControl);
						sheetCnt++;
					}
				}
				catch(e){}
			}
			
			//var optionbuttonTmp = optionbuttonCtrl.sort();
			
			//옵션버튼 컨트롤의 그룹명과 그룹당 카운트를 세팅(저장)할 배열
			var optionbuttonGroupName = [];		var optionbuttonGroupCnt = [];
			var optionbuttonInfo = "";
			var flag = true;
			
			//옵션버튼을 그룹별로 출력학기 위해 옵션그룹명과 그룹당 카운트를 세팅.
			for (var i = 0, j = 0; i < optionbuttonCnt; i++){
				optionbuttonInfo = optionbuttonCtrl[i];
				flag = true;
				//옵션그룹명이 새로운 것이 있나 체크 / 같은 옵션그룹이면 카운트 증가
				for(var k = 0; k < optionbuttonGroupName.length; k++){
					if(optionbuttonGroupName[k] == optionbuttonInfo[0]){
						optionbuttonGroupCnt[k] += 1;
						flag = false;
					}
				}
				//새로운 옵션그룹이 있다면 옵션그룹명 배열에 추가, 옵션그룹 카운트 1 저장(새로 찾은 옵션그룹)
				if(flag){
					optionbuttonGroupName[j] = optionbuttonInfo[0];
					optionbuttonGroupCnt[j] = 1;
					j++;
				}
			}
			
			//콘트롤 테이블 생성(시트 제외)
			pageContent += "<div id=\"label_control\" name=\"label_control\" align=\"center\" onclick=showDisplay(\"tab_control\") style=\"background-color: #ccccff; width: 100%; padding: 12px; border: 1px solid #ffffff;\"> " + getText("message_checkMemory_038", "컨트롤(Control)") + " </div>";
			pageContent += "<div id=\"tab_control\" name=\"tab_control\" tabname=\"" + getText("message_checkMemory_039", "컨트롤") + "\" style=\"display :none\"><br>"
						+ "<div class=\"DataSheet\" style=\"width: 100%; border: 1px solid #ccccff; padding: 10px\">"
						+ "<table style=\"width:100%\">"
						+ "<tr> <td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_040", "콘트롤 종류") + " </td>"
						+ "<td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_041", "콘트롤 명") + " </td>"
						+ "<td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_042", "콘트롤 값(겉값/속값)") + " </td>"
						+ "<td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_043", "콘트롤 속성 ") + "</td> </tr>";
			
			//텍스트박스 정보 출력
			var isFirstRow = true;
			for(var key in memInfo.textBox){
				var textbox = memInfo.textBox[key];
				if(typeof(textbox) == "function") continue;

				var textattr = textbox.defaultValue + textbox.dispFormat + textbox.multiLine + textbox.enabled + textbox.visible + textbox.checkType;
				
				pageContent += 	"<tr>";
				//첫행에서 rowspan을 한다.
				if( isFirstRow ){
					pageContent += "<td align=\"center\" style=\"background-color: rgb(255,255,255);\" rowspan=" + textboxCnt + "> TextBox </td>";
					isFirstRow = false;
				}
				pageContent += 	"<td style=\"background-color: rgb(255,255,255); padding-left: 10px\"> " + textbox.controlName + " </td>"
							+ 	"<td style=\"background-color: rgb(255,255,255); padding-left: 10px\"> " + textbox.value + " </td>"
							+ 	"<td style=\"background-color: rgb(255,255,255); padding-left: 10px\"> " + textattr + " </td>"
							+ 	"</tr>";
			}
			
			//콤보박스 정보 출력
			isFirstRow = true;
			for(var key in memInfo.comboBox){
				var combobox = memInfo.comboBox[key];
				
				if(typeof(combobox) == "function") continue;
				
				//콤보데이터와 속성을 출력할 문자열을 만든다.
				var combodata = "";
				var comboattr = combobox.defaultValue + combobox.enabled + combobox.visible + combobox.checkType;
				for(var j = 0, indata = "", outdata = ""; j < combobox.inValue.length; j++, indata = "", outdata = ""){
					indata = combobox.inValue[j];	outdata = combobox.outValue[j];
					if(combobox.selectValue == indata){
						combodata += "<font color=\"red\"> " + outdata + " / " + indata + getText("message_checkMemory_024", " --- (선택) ") + "</font><br>";
					}
					else{
						combodata += outdata + " / " + indata + "<br>";
					}
				}
				
				pageContent += 	"<tr>";
				//첫행에서 rowspan을 한다.
				if( isFirstRow ){
					pageContent += "<td align=\"center\" style=\"background-color: rgb(255,255,255);\" rowspan=" + comboboxCnt + "> ComboBox </td>";
					isFirstRow = false;
				}
				pageContent += 	"<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + combobox.controlName + "</td>"
							+ 	"<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + combodata + "</td>"
							+ 	"<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + comboattr + "</td>"
							+ 	"</tr>";
			}
			
			//리스트박스 정보 출력
			isFirstRow = true;
			for(var key in memInfo.listBox){
				var listbox = memInfo.listBox[key];
				
				if( typeof(listbox) == "function" ) continue;
				
				var listdata = "";
				var listattr = listbox.defaultValue + listbox.enabled + listbox.visible + listbox.checkType;
				for(var j = 0, outdata = "", indata = ""; j < listbox.inValue.length; j++, outdata = "", indata = ""){
					outdata = listbox.outValue[j];	indata = listbox.inValue[j];
					if(listbox.selectValue == indata){
						listdata += "<font color=\"red\"> " + outdata + " / " + indata + getText("message_checkMemory_024", " --- (선택) ") + "</font><br>";
					}
					else{
						listdata += outdata + " / " + indata + "<br>";
					}
				}
				
				pageContent += 	"<tr>";
				//첫행에서 rowspan을 한다.
				if( isFirstRow ){
					pageContent += "<td align=\"center\" style=\"background-color: rgb(255,255,255);\" rowspan=" + listboxCnt + "> ListBox </td>";
					isFirstRow = false;
				}
				pageContent += 	"<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + listbox.controlName + "</td>"
							+ 	"<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + listdata + "</td>"
							+ 	"<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + listattr + "</td>"
							+ 	"</tr>";
			}
			
			//체크박스 정보 출력
			isFirstRow = true;
			for(var key in memInfo.checkBox){
				var checkBox = memInfo.checkBox[key];
				
				if( typeof(checkBox) == "function" ) continue;
				
				var checkattr = checkBox.defaultValue + checkBox.enabled + checkBox.visible + checkBox.checkType;
				
				pageContent += 	"<tr>";
				//첫행에서 rowspan을 한다.
				if( isFirstRow ){
					pageContent += "<td align=\"center\" style=\"background-color: rgb(255,255,255);\" rowspan=" + checkboxCnt + "> CheckBox </td>";
					isFirstRow = false;
				}
				pageContent += 	"<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + checkBox.controlName + "</td>"
							+ 	"<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + checkBox.value + "</td>"
							+ 	"<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + checkattr + "</td>"
							+ 	"</tr>";
			}
			
			//옵션버튼 정보 출력
			for(i = 0; i < optionbuttonGroupName.length; i++){
				var groupName = optionbuttonGroupName[i];
				var isFirstRow = 0;
				
				for(j = 0; j < optionbuttonCtrl.length; j++){
					var optionInfo = optionbuttonCtrl[j];
					
					if( "" + groupName != "" + optionInfo[0] ){
						continue;
					}
					
					pageContent += "<tr>";
					
					if(isFirstRow == 0){
						pageContent += "<td align=\"center\" style=\"background-color: rgb(255,255,255);\" rowspan=" + optionbuttonGroupCnt[i] + "> OptionButton_" + groupName + " </td>";
						isFirstRow++;
					}
					
					pageContent += "<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + optionInfo[1] + "</td>"
								+ "<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + optionInfo[2] + "</td>"
								+ "<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + "" + "</td>"
								+ "</tr>";
				}
			}
			//탭박스 정보 출력
			for(var i = 0; i < tabboxCnt; i++){
				var tabboxInfo = tabboxCtrl[i];
				var tabData = tabboxInfo[1];		var tabAttr = tabboxInfo[2];
				var tabTitle = "";					var tabAttribute = "";
				pageContent += "<tr>";
				
				if(i == 0){
					pageContent += "<td align=\"center\" style=\"background-color: rgb(255,255,255);\" rowspan=" + tabboxCnt + "> TabBox </td>";
				}
				
				pageContent += "<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + tabboxInfo[0] + "</td>";
				
				for(var j = 0 ; j < tabData.length; j++){
					var title = tabData[j];
					for(var k = 0; k < title.length; k++){
						tabTitle += (title[2] == "" ? "" : "<font color=\"red\">") + title[k] + (k == 0 ? " / " : (k == 1 ? "" : "<br>")) +(title[2] == "" ? "" : "</font>");
					}
				}
				pageContent += "<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + tabTitle + "</td>";
				
				for( var j = 0; j < tabAttr.length; j++){
					tabAttribute += tabAttr[j];
				}
				pageContent += "<td style=\"background-color: rgb(255,255,255); padding-left: 10px\">" + tabAttribute + "</td>"
							+ "</tr>";
			}
			
			pageContent += "</table>"
						+ "</div><br></div>";
			
			//시트
			pageContent += "<div id=\"label_object\" name=\"label_object\" align=\"center\" onclick=showDisplay(\"tab_sheet\") style=\"background-color: #ccccff; width: 100%; padding: 12px; border: 1px solid #ffffff;\"> " + getText("message_checkMemory_044", "시트 (Sheet)") + " </div>";
			pageContent += "<div id=\"tab_sheet\" name=\"tab_sheet\" tabname=\"" + getText("message_checkMemory_045", "시트") + "\" style=\"display :none\"><br>";
			
			for(var key in memInfo.sheet){
				var sheet = memInfo.sheet[key];
				
				if( typeof(sheet) == "function" ) continue;
				
				pageContent +=	"<div style=\"width: 100%; border: 1px solid #ccccff; \">"
							+ 	"<font size=\"4\"> <b> <p> &lt " + sheet.controlName + " &gt </p> </b> </font>";
		
				//시트 속성
				//시트속성은 동작가능, 보이기, 시트타입, 연결된 객체, 고정열 수, 고정행 수를 보여준다.
				pageContent += 	"<h4 onclick=showDisplay(\""+ sheet.controlName +"_tblInfo\")> " + getText("message_checkMemory_046", "1. 시트 속성") + " </h4>"
							+ 	"<div class=\"DataSheet\" id=\"" + sheet.controlName + "_tblInfo\" name=\"" + sheet.controlName + "_tblInfo\" tabname=\"" + getText("message_checkMemory_047", "시트속성") + "\" style=\"display :none; width: 100%\">"
							+ 		"<table style=\"width: 100%; cellpadding=\"2\"; cellspacing=\"1\"\">"
							+ 			"<tr>"
							+				"<td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_048", "속성 명") + " </td>"
							+ 				"<td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_049", "속성 값") + " </td>"
							+			"</tr>"
							+ 			"<tr>"
							+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_050", "동작가능") + " </td>"
							+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + sheet.enabled +" </td>"
							+			"</tr>"
							+			"<tr>"
							+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_051", "보이기") + " </td>"
							+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + sheet.visible +" </td>"
							+			"</tr>"
							+ 			"<tr>"
							+				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_052", "시트 타입") + " </td>"
							+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + sheet.sheetType +" </td>"
							+			"</tr>"
							+ 			"<tr>"
							+				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_053", "연결된 객체") + " </td>"
							+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + sheet.linkedObjects +" </td>"
							+			"</tr>"
							+ 			"<tr>"
							+				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_054", "고정 열/행") + " </td>"
							+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + sheet.frozenCols + " / " + sheet.frozenRows + " </td>"
							+			"</tr>"
							+ 		"</table>"
							+ 	"</div>";
				
				//컬럼 속성
				pageContent += 	"<h4 onclick=showDisplay(\""+ sheet.controlName +"_colInfo\")> " + getText("message_checkMemory_055", "2. 컬럼 속성") + " </h4>"
							+ 	"<div class=\"DataSheet\" id=\"" + sheet.controlName + "_colInfo\" name=\"" + sheet.controlName + "_colInfo\" tabname=\"" + getText("message_checkMemory_047", "시트속성") + "\" style=\"display :none; width: 100%\">"
							+		"<table style=\"width:100%\">";
				for(var i = 0; i < sheet.headCnt; i++){
					var column = sheet.header[i];
					pageContent +=		"<tr>"
								+			"<td style=\"border-top-style:solid; border-width:1px; border-color:#CCC; text-align:center; background-color:#f6f6f6;\">" + column.name + "</td>"
								+			"<td style=\"width:700px; border-top-style:solid; border-width:1px; border-color:#CCC\">"
								+				"<table style=\"width:700px\">"
								+					"<tr> <td style=\"witdth:50%; border-color:white\"> " + getText("message_checkMemory_056", "컬럼 타입 : ") + column.type + " </td> <td style=\"witdth:50%; border-color:white\"> " + getText("message_checkMemory_036", "디폴트 값 : ") + column.defaultValue + "</td> </tr>"
								+					"<tr> <td style=\"witdth:50%; border-color:white\"> " + getText("message_checkMemory_057", "잠금 상태 : ") + column.defaultLockMode + " </td> <td style=\"witdth:50%; border-color:white\"> " + getText("message_checkMemory_059", "표시 형식 : ") + column.defaultDisplayFormat + "</td> </tr>"
								+					"<tr> <td style=\"witdth:50%; border-color:white\"> " + getText("message_checkMemory_059", "숨김 상태 : ") + column.hidden + " </td> <td style=\"witdth:50%; border-color:white\"> " + getText("message_checkMemory_060", "디폴트 산식 : ") + column.defaultFormula + "</td> </tr>"
								+				"</table>"
								+			"</td>"
								+		"</tr>"
				}
				pageContent += 		"</table>"
							+	"</div>";
				
				//시트 데이터
				pageContent += 	"<h4 onclick=showDisplay(\""+ sheet.controlName +"_sheetData\")> " + getText("message_checkMemory_061", "3. 시트 데이터") + " </h4>"
							+ 	"<div class=\"DataSheet\" id=\"" + sheet.controlName + "_sheetData\" name=\"" + sheet.controlName + "_sheetData\" tabname=\"" + getText("message_checkMemory_062", "시트데이터") + "\" style=\"display :none; width: 100%;overflow-x: scroll;\">"
							+		"<table style=\"width:100%\">"
							+			"<tr>";
				for(var i = 0; i < sheet.headCnt; i++){
					var title = sheet.header[i];
					pageContent +=			"<td class=\"lColHead\">"
								+ 				title.name + "<br>" + (title.defaultLockMode ? "<font color=\"blue\">(Lock Mode)</font>" : (title.hidden ? "<font color=\"red\">(Hidden)</font>" : ""))
								+ 			"</td>";
				}
				pageContent += 			"</tr>";
				for(var i = 0; i < sheet.rowCnt; i++){
					var row = sheet.rowData[i];
					pageContent +=		"<tr>";
					for(var j = 0; j < row.data.length; j++){
						pageContent +=		"<td>"
									+			row.data[j].value
									+		"</td>";
					}
					pageContent +=		"</tr>";
				}
				pageContent += 		"</table>"
							+	"</div>";
				
				pageContent += 	"</div><br>";
			}
			
			// AUISHeet 반영 
			for (var key in controls){
				var wControl = controls[key];
				//
				if (typeof AUIGrid == "undefined") continue;
				if (typeof(wControl) == "function" ) continue;
				if (typeof AUIDataSheet != "function") continue;
				if (!(wControl instanceof AUIDataSheet)) continue;
				
				sheet = wControl;
				
				pageContent +=	"<div style=\"width: 100%; border: 1px solid #ccccff; \">"
							+ 	"<font size=\"4\"> <b> <p> &lt " + sheet.controlName + " &gt </p> </b> </font>";
				
				//시트 속성
				//시트속성은 동작가능, 보이기, 시트타입, 연결된 객체, 고정열 수, 고정행 수를 보여준다.
				pageContent += 	"<h4 onclick=showDisplay(\""+ sheet.controlName +"_tblInfo\")> " + getText("message_checkMemory_046", "1. 시트 속성") + " </h4>"
							+ 	"<div class=\"DataSheet\" id=\"" + sheet.controlName + "_tblInfo\" name=\"" + sheet.controlName + "_tblInfo\" tabname=\"" + getText("message_checkMemory_047", "시트속성") + "\" style=\"display :none; width: 100%\">"
							+ 		"<table style=\"width: 100%; cellpadding=\"2\"; cellspacing=\"1\"\">"
							+ 			"<tr>"
							+				"<td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_048", "속성 명") + " </td>"
							+ 				"<td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_049", "속성 값") + " </td>"
							+			"</tr>"
							+ 			"<tr>"
							+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_050", "동작가능") + " </td>"
							+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + sheet.enabled +" </td>"
							+			"</tr>"
							+			"<tr>"
							+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_051", "보이기") + " </td>"
							+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + sheet.visible +" </td>"
							+			"</tr>"
							+ 			"<tr>"
							+				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_052", "시트 타입") + " </td>"
							+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + sheet.sheetType +" </td>"
							+			"</tr>"
							+ 			"<tr>"
							+				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_053", "연결된 객체") + " </td>"
							+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + sheet.linkedObjects +" </td>"
							+			"</tr>"
							+ 			"<tr>"
							+				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_054", "고정 열/행") + " </td>"
							+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + sheet.frozenCols + " / " + sheet.frozenRows + " </td>"
							+			"</tr>"
							+ 		"</table>"
							+ 	"</div>";

				//컬럼 속성
				pageContent += 	"<h4 onclick=showDisplay(\""+ sheet.controlName +"_colInfo\")> " + getText("message_checkMemory_055", "2. 컬럼 속성") + " </h4>"
							+ 	"<div class=\"DataSheet\" id=\"" + sheet.controlName + "_colInfo\" name=\"" + sheet.controlName + "_colInfo\" tabname=\"" + getText("message_checkMemory_047", "시트속성") + "\" style=\"display :none; width: 100%\">"
							+		"<table style=\"width:100%\">";
							
				var columnLayoutList = (typeof AUIGrid.getColumnInfoList == "function" ? 
								            AUIGrid.getColumnInfoList(sheet.AUIcontrolId) :
								            AUIGrid.getColumnLayout(sheet.AUIcontrolId));

				var dataFieldList = [];
				//for(var key in sheet.columnLayout){
				for(var k = 0; k < columnLayoutList.length; k++){
				    //if (typeof(wControl) == "function" ) continue;
				    var columnLayout = columnLayoutList[k];
				    
					pageContent +=		"<tr>"
								+			"<td style=\"border-top-style:solid; border-width:1px; border-color:#CCC; text-align:center; background-color:#f6f6f6;\">" + columnLayout.headerText + "</td>"
								+			"<td style=\"width:700px; border-top-style:solid; border-width:1px; border-color:#CCC\">"
								+				"<table style=\"width:700px\">"
								+					"<tr> <td style=\"witdth:50%; border-color:white\"> " + getText("message_checkMemory_056", "컬럼 타입 : ") + columnLayout.dataType + " </td> <td style=\"witdth:50%; border-color:white\"> " + getText("message_checkMemory_063", "정렬 형식 : ") + columnLayout.style + "</td> </tr>"
								+					"<tr> <td style=\"witdth:50%; border-color:white\"> " + getText("message_checkMemory_064", "잠금 해제 : ") + columnLayout.editable + " </td> <td style=\"witdth:50%; border-color:white\"> " + getText("message_checkMemory_059", "표시 형식 : ") + columnLayout.formatString + "</td> </tr>"
								+				"</table>"
								+			"</td>"
								+		"</tr>"
				}
				pageContent += 		"</table>"
							+	"</div>";
				
				
				//시트 데이터
				pageContent += 	"<h4 onclick=showDisplay(\""+ sheet.controlName +"_sheetData\")> " + getText("message_checkMemory_061", "3. 시트 데이터") + " </h4>"
							+ 	"<div class=\"DataSheet\" id=\"" + sheet.controlName + "_sheetData\" name=\"" + sheet.controlName + "_sheetData\" tabname=\"" + getText("message_checkMemory_062", "시트데이터") + "\" style=\"display :none; width: 100%;overflow-x: scroll;\">"
							+		"<table style=\"width:100%\">"
							+			"<tr>";

				for(var k = 0; k < columnLayoutList.length; k++){
				    var columnLayout = columnLayoutList[k];
				    dataFieldList.push(columnLayout.dataField + "");
					pageContent +=			"<td class=\"lColHead\">"
								+ 				columnLayout.headerText 
								+ 			"</td>";
				}
				pageContent += 			"</tr>";
				
				
				var sheetData = AUIGrid.getGridData(sheet.AUIcontrolId);
				
				for (var i=0; i < sheetData.length; i++){
				    var jsonRowData = sheetData[i];
				    
    				pageContent +=		"<tr>";
    				for(var j = 0; j < dataFieldList.length; j++){
    					pageContent +=		"<td>" + jsonRowData[dataFieldList[j] + ""] + "</td>";
    				}
    				pageContent +=		"</tr>";
				}
				
				pageContent += 		"</table>"
							+	"</div>";
				
				pageContent += 	"</div><br>";

           }
			
			
			pageContent += "</div></div>";	//시트 메뉴 전체
			
			//오브젝트
			//테이블의 컬럼에는 프로퍼티명과 속성을 보여준다.
			//테이블의 필드에는 오브젝트의 데이터를 보여준다.
			var objectNames = [];		var objectCnt = 0;
			
			try{
				for(var key in objects){
					if( objects[key] instanceof DataObject){
						objectNames[objectCnt] = key;
						objectCnt++;
					}
				}
			}
			catch(e){}
			
			pageContent += "<div id=\"label_object\" name=\"label_object\" align=\"center\" onclick=showDisplay(\"tab_object\") style=\"background-color: #ccccff; width: 100%; padding: 12px; border: 1px solid #ffffff;\"> " + getText("message_checkMemory_065", "객체(Object)") + " </div>";
			pageContent += "<div id=\"tab_object\" name=\"tab_object\" tabname=\"" + getText("message_checkMemory_066", "객체") + "\" style=\"display :none\"><br>";
			
			for(var i = 0; i < objectCnt; i++){
				var objectInfo = objects[objectNames[i]];
				
				pageContent +="<div style=\"width: 100%; border: 1px solid #ccccff; padding: 10px\">"
							+ "<font size=\"4\"> <b> <p> &lt " + objectInfo.name + " &gt </p> </b> </font>";
				
				//오브젝트 공통속성
				pageContent += "<h4 onclick=showDisplay(\"object_common_" + objectInfo.tableID + "\")> " + getText("message_checkMemory_067", "1. 공통속성") + " </h4>";
				pageContent += "<div class=\"DataSheet\" id=\"object_common_" + objectInfo.tableID + "\" name=\"object_common_" + objectInfo.tableID + "\" tabname=\"" + getText("message_checkMemory_068", "오브젝트공통") + "\" style=\"display :none\">";
				pageContent += "<table style=\"width:100%\"><tr>"
							+ "<td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_048", "속성 명") + " </td>"
							+ "<td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_049", "속성 값") + " </td></tr><tr>"
							+ "<td align=\"center\" style=\"background-color: rgb(255,255,255); font-size:9pt\"> " + getText("message_checkMemory_069", "테이블 ID") + " </td>"
							+ "<td align=\"center\" style=\"background-color: rgb(255,255,255); font-size:9pt\">" + objectInfo.tableID + "</td></tr><tr>"
							+ "<td align=\"center\" style=\"background-color: rgb(255,255,255); font-size:9pt\"> " + getText("message_checkMemory_070", "객체 타입") + " </td>"
							+ "<td align=\"center\" style=\"background-color: rgb(255,255,255); font-size:9pt\">" + objectInfo.objectType + "</td></tr><tr>"
							+ "<td align=\"center\" style=\"background-color: rgb(255,255,255); font-size:9pt\"> " + getText("message_checkMemory_071", "Skip 조건") + " </td>"
							+ "<td align=\"center\" style=\"background-color: rgb(255,255,255); font-size:9pt\">" + objectInfo.skipFormula + "</td></tr>"
							+ "</table><br>"
							+ "</div>";
				//오브젝트 프로퍼티 속성
				//오브젝트 각 프로터피의 속성을 출력한다.
				pageContent += "<h4 onclick=showDisplay(\"object_property_attr_" + objectInfo.tableID + "\")> " + getText("message_checkMemory_072", "2. 프로퍼티 속성") + " </h4>";
				pageContent += "<div class=\"DataSheet\" id=\"object_property_attr_" + objectInfo.tableID + "\" name=\"object_property_attr_" + objectInfo.tableID + "\" tabname=\"" + getText("message_checkMemory_073", "오브젝트프로퍼티속성") + "\" style=\"display :none\">";
				pageContent += "<table bgcolor=\"#804040\" border=\"0\" style=\"width: 100%; cellpadding=\"2\"; cellspacing=\"1\"\">"
							+ "<tr><td class=\"lColHead\" align=\"center\" style=\"width: 200px\"> " + getText("message_checkMemory_074", "프로퍼티 명") + " </td>"
							+ "<td class=\"lColHead\" align=\"center\" style=\"width: 600px\"> " + getText("message_checkMemory_075", "프로퍼티 속성") + " </td></tr>";
				for(var j = 1; j <= objectInfo.propertyCount; j++){
					var propertyInfo = objectInfo.propertyInfos[j];
					pageContent += "<tr>"
								+ "<td align=\"center\" style=\"background-color: rgb(255,255,255); font-size:9pt padding-left: 10px\">"
								+ propertyInfo.name + (propertyInfo.isKey ? "<font color=\"red\">(PK)</font>" : "") + "</td>"
								+ "<td width=\"450px\" align=\"center\" style=\"background-color: rgb(255,255,255); font-size:9pt padding-left: 10px\">"
								+ "<table align=\"left\" border=\"0\" style=\"FONT-SIZE: 9pt; cellspacing=\"0\"\">"
								+ "<tr><td width=\"15%\" style=\"border-color:white\"> " + getText("message_checkMemory_076", "필드 ID : ") + propertyInfo.fieldId + "</td>" + "<td width=\"15%\" style=\"border-color:white\"> " + getText("message_checkMemory_077", "프로퍼티 구분 : ") + propertyInfo.propertyGu + "</td></tr>"
								+ "<tr><td width=\"15%\" style=\"border-color:white\"> " + getText("message_checkMemory_078", "데이터 타입 : ") + propertyInfo.dataTypeName + "</td>" + "<td width=\"15%\" style=\"border-color:white\"> " + getText("message_checkMemory_079", "키 필드 : ") + (propertyInfo.isKey ? getText("message_checkMemory_080", "키 필드") : getText("message_checkMemory_081", "키 필드 아님")) + "</td></tr>"
								+ "<tr><td width=\"15%\" style=\"border-color:white\"> " + getText("message_checkMemory_082", "산식 : ") + propertyInfo.formula + "</td>" + "<td width=\"15%\" style=\"border-color:white\"> " + getText("message_checkMemory_083", "시퀀스 키 필드 : ") + (propertyInfo.isSeqKey ? getText("message_checkMemory_084", "시퀀스 키 필드") : getText("message_checkMemory_085", "시퀀스 키 필드 아님")) + "</td></tr>"
								+ "<tr><td width=\"15%\" style=\"border-color:white\"> " + getText("message_checkMemory_036", "디폴트 값 : ") + propertyInfo.defaultValue + "</td>" + "<td width=\"15%\" style=\"border-color:white\"> " + getText("message_checkMemory_086", "널(Null) 허용: ") + (propertyInfo.permitNull ? getText("message_checkMemory_087", "허용") : getText("message_checkMemory_088", "허용안함")) + "</td></tr>"
								+ "<tr><td width=\"15%\" style=\"border-color:white\"> " + getText("message_checkMemory_089", "시트 연결 : ") + (propertyInfo.sheetLinked ? getText("message_checkMemory_090", "연결됨") : getText("message_checkMemory_091", "연결안됨")) + "</td>" + "<td width=\"15%\" style=\"border-color:white\"> " + getText("message_checkMemory_092", "리스트(콤보) 연결 : ") + (propertyInfo.listLinked ? getText("message_checkMemory_090", "연결됨") : getText("message_checkMemory_091", "연결안됨")) + "</td></tr>"
								+ "</table>"
								+ "</td>"
								+ "</tr>";
				}
				pageContent += "</table><br>"
							+ "</div>";
				//오브젝트 데이터
				//오브젝트 데이터 컬럼명을 출력한다.
				var fieldName = [];
				var tableHeight = 35 + (19 * objectInfo.recordset.length);
				pageContent += "<h4 onclick=showDisplay(\"object_data_" + objectInfo.tableID + "\")> " + getText("message_checkMemory_093", "3. 프로퍼티 데이터") + " </h4>";
				pageContent += "<div class=\"DataSheet\" id=\"object_data_" + objectInfo.tableID + "\" name=\"object_data_" + objectInfo.tableID + "\" tabname=\"" + getText("message_checkMemory_094", "오브젝트데이터") + "\" style=\"display :none; width: 100%; OVERFLOW-X: auto; OVERFLOW-Y: visible\">";
				
				//테이블의 길이를 구한다. 테이블 한 셀의 크기는 100 이다.
				var tableWidth = 100 * (objectInfo.propertyCount * 1);
				
				pageContent += "<table style=\"width: " + tableWidth + "px\"><tr>";
				for(var j = 1; j <= objectInfo.propertyCount; j++){
					var propertyInfo = objectInfo.propertyInfos[j];
					pageContent	+= "<td class=\"lColHead\" align=\"center\" >"
								+ propertyInfo.name
								+ (propertyInfo.isKey ? "<font color=\"red\">(PK)</font>" : (propertyInfo.isSeqKey ? "<font color=\"blue\"> (SEQ) </font>" : "")) + "<br>"
								+ propertyInfo.id
								+ "</td>";
					fieldName[j] = propertyInfo.fieldId;
				}
				pageContent	+= "<td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_095", "업데이트 구분") + " <br> updateGu </td></tr>";
				//오브젝트 데이터를 출력한다.
				for(var j = 1; j < objectInfo.recordset.length; j++){
					var record = objectInfo.recordset[j];
					pageContent += "<tr>";
					for(var k = 1; k <= objectInfo.propertyCount; k++){
						var property = record.properties[fieldName[k]];
						pageContent	+= "<td align=\"center\" style=\"background-color: rgb(255,255,255); font-size:9pt; padding-left: 10px\">" + property.value + "</td>";
					}
					pageContent	+= "<td align=\"center\" style=\"background-color: rgb(255,255,255); font-size:9pt; padding-left: 10px\">" + record.updateGu + "</td></tr>";
				}
				pageContent += "</table>"
							+ "</div>"		//오브젝트 데이터 출력 div
							+ "</div>";		//오브젝트 출력 div(객체, 테이블 1개당)
			}
			
			pageContent += "</div>";	//객체 탭 div

			//데이터 셋
			if(dataSets instanceof Array){
				pageContent += "<div id=\"label_object\" name=\"label_object\" align=\"center\" onclick=showDisplay(\"tab_dataset\") style=\"background-color: #ccccff; width: 100%; padding: 12px; border: 1px solid #ffffff;\"> " + getText("message_checkMemory_096", "데이터셋 (DataSet)") + "</div>";
				pageContent += "<div id=\"tab_dataset\" name=\"tab_dataset\" tabname=\"" + getText("message_checkMemory_097", "데이터셋") + "\" style=\"display :none\"><br>";
	
				for (var key in dataSets){
					var dataSet = dataSets[key];
					//
					if (typeof(dataSet) == "function" ) continue;
					
					pageContent +=	"<div style=\"width: 100%; border: 1px solid #ccccff; \">"
								+ 	"<font size=\"4\"> <b> <p> &lt " + dataSet.id + " &gt </p> </b> </font>";
					
					//데이터셋 속성
					pageContent += 	"<h4 onclick=showDisplay(\""+ dataSet.id +"_tblInfo\")> " + getText("message_checkMemory_098", "1. 데이터셋 속성") + " </h4>"
								+ 	"<div class=\"DataSheet\" id=\"" + dataSet.id + "_tblInfo\" name=\"" + dataSet.id + "_tblInfo\" tabname=\"" + getText("message_checkMemory_099", "데이터셋 속성") + "\" style=\"display :none; width: 100%\">"
								+ 		"<table style=\"width: 100%; cellpadding=\"2\"; cellspacing=\"1\"\">"
								+ 			"<tr>"
								+				"<td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_048", "속성 명") + " </td>"
								+ 				"<td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_049", "속성 값") + " </td>"
								+				"<td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_048", "속성 명") + " </td>"
								+ 				"<td class=\"lColHead\" align=\"center\" > " + getText("message_checkMemory_049", "속성 값") + " </td>"
								+			"</tr>"
								+ 			"<tr>"
								+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_100", "데이터셋 타입") + " </td>"
								+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + dataSet.dataSetType +" </td>"
								+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_101", "이벤트 수행") + " </td>"
								+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + dataSet.FireEvent +" </td>"
								+			"</tr>"
								+			"<tr>"
								+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_102", "콘트롤 갱신") + " </td>"
								+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + dataSet.UpdateControl +" </td>"
								+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> FilterExpr </td>"
								+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + dataSet.FilterExpr +" </td>"
								+			"</tr>"
								+ 			"<tr>"
								+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_103", "그룹 키") + " </td>"
								+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + dataSet._GroupKey +" </td>"
								+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_104", "피봇 키") + " </td>"
								+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + dataSet._PivotKey +" </td>"
								+			"</tr>"
								+ 			"<tr>"
								+				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_105", "연결된 데이터셋") + " </td>"
								+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + dataSet._DataObject +" </td>"
								+				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + getText("message_checkMemory_106", "현재 줄 번호") + " </td>"
								+ 				"<td align=\"center\" style=\"background-color: #ffffff; font-size:9pt; padding-left: 10px\"> " + dataSet.Row + " </td>"
								+			"</tr>"
								+ 		"</table>"
								+ 	"</div>";
	
					//컬럼 속성
					pageContent += 	"<h4 onclick=showDisplay(\""+ dataSet.id +"_colInfo\")> " + getText("message_checkMemory_055", "2. 컬럼 속성") + " </h4>"
								+ 	"<div class=\"DataSheet\" id=\"" + dataSet.id + "_colInfo\" name=\"" + dataSet.id + "_colInfo\" tabname=\"" + getText("message_checkMemory_047", "시트속성") + "\" style=\"display :none; width: 100%\">"
								+		"<table style=\"width:100%\">";
								
					for(var key in dataSet.colInfos){
						var colInfo = dataSet.colInfos[key];
					    if (typeof(colInfo) == "function" ) continue;
					    
						pageContent +=		"<tr>"
									+			"<td style=\"border-top-style:solid; border-width:1px; border-color:#CCC; text-align:center; background-color:#f6f6f6;\">" + colInfo.id + "</td>"
									+			"<td style=\"width:700px; border-top-style:solid; border-width:1px; border-color:#CCC\">"
									+				"<table style=\"width:700px\">"
									+					"<tr> <td style=\"witdth:50%; border-color:white\"> " + getText("message_checkMemory_107", "컬럼 명 : ") + colInfo.id + " </td> <td style=\"witdth:50%; border-color:white\"> " + getText("message_checkMemory_063", "정렬 형식 : ") + colInfo.type + "</td> </tr>"
									+					"<tr> <td style=\"witdth:50%; border-color:white\"> " + getText("message_checkMemory_108", "칼럼 크기 : ") + colInfo.size + " </td> <td style=\"witdth:50%; border-color:white\"> " + getText("message_checkMemory_109", "집계 방법 : ") + colInfo.sumMethod + "</td> </tr>"
									+				"</table>"
									+			"</td>"
									+		"</tr>"
					}
					pageContent += 		"</table>"
								+	"</div>";
					
					
					//데이터셋 데이터
					pageContent += 	"<h4 onclick=showDisplay(\""+ dataSet.id +"_sheetData\")> " + getText("message_checkMemory_110", "3. 표시 데이터") + " </h4>"
								+ 	"<div class=\"DataSheet\" id=\"" + dataSet.id + "_sheetData\" name=\"" + dataSet.id + "_sheetData\" tabname=\"" + getText("message_checkMemory_111", "데이터셋 데이터") + "\" style=\"display :none; width: 100%;overflow-x: scroll;\">"
								+		"<table style=\"width:100%\">"
								+			"<tr>";
	
					for(var key in dataSet.colInfos){
						var colInfo = dataSet.colInfos[key];
					    if (typeof(colInfo) == "function" ) continue;
						pageContent +=			"<td class=\"lColHead\">" + colInfo.id +"</td>";
					}
					
					pageContent +=			"<td class=\"lColHead\">[RowType]</td>";
					pageContent +=			"<td class=\"lColHead\">[filterd]</td>";
					pageContent +=			"<td class=\"lColHead\">[selected]</td>";
					pageContent +=			"<td class=\"lColHead\">[RowLevel]</td>";
					pageContent +=			"<td class=\"lColHead\">[rangeStart]</td>";
					pageContent +=			"<td class=\"lColHead\">[rangeCount]</td>";
					pageContent +=			"<td class=\"lColHead\">[sheetRowID]</td>";
					pageContent += 			"</tr>";
					
					
					for (var i=0; i < dataSet.records.length; i++){
					    var record = dataSet.records[i];
					    
	    				pageContent +=		"<tr>";
	    				for(var key in dataSet.colInfos){
	    				    if (typeof(dataSet.colInfos[key]) == "function" ) continue;
	    					pageContent +=		"<td>" + record.values[key] + "</td>";
	    				}
	    				pageContent +=		"<td>" + record.RowType + "</td>";
	    				pageContent +=		"<td>" + record._filterd + "</td>";
	    				pageContent +=		"<td>" + record._selected + "</td>";
	    				pageContent +=		"<td>" + record._RowLevel + "</td>";
	    				pageContent +=		"<td>" + record.rangeStart + "</td>";
	    				pageContent +=		"<td>" + record.rangeCount + "</td>";
	    				pageContent +=		"<td>" + record._$uid + "</td>";
	    				pageContent +=		"</tr>";
					}
					
					pageContent += 		"</table>"
								+	"</div>";
					
					//시트 데이터
					pageContent += 	"<h4 onclick=showDisplay(\""+ dataSet.id +"_sheetDataAll\")> " + getText("message_checkMemory_112", "4. 전체 데이터") + " </h4>"
								+ 	"<div class=\"DataSheet\" id=\"" + dataSet.id + "_sheetDataAll\" name=\"" + dataSet.id + "_sheetDataAll\" tabname=\"" + getText("message_checkMemory_111", "데이터셋 데이터") + "\" style=\"display :none; width: 100%;overflow-x: scroll;\">"
								+		"<table style=\"width:100%\">"
								+			"<tr>";
	
					for(var key in dataSet.colInfos){
						var colInfo = dataSet.colInfos[key];
					    if (typeof(colInfo) == "function" ) continue;
						pageContent +=			"<td class=\"lColHead\">" + colInfo.id +"</td>";
					}
					
					pageContent +=			"<td class=\"lColHead\">[RowType]</td>";
					pageContent +=			"<td class=\"lColHead\">[filterd]</td>";
					pageContent +=			"<td class=\"lColHead\">[selected]</td>";
					pageContent += 			"</tr>";
					
					
					for (var i=0; i < dataSet.buffer.length; i++){
					    var record = dataSet.buffer[i];
					    
	    				pageContent +=		"<tr>";
	    				for(var key in dataSet.colInfos){
	    				    if (typeof(dataSet.colInfos[key]) == "function" ) continue;
	    					pageContent +=		"<td>" + record.values[key] + "</td>";
	    				}
	    				pageContent +=		"<td>" + record.RowType + "</td>";
	    				pageContent +=		"<td>" + record._filterd + "</td>";
	    				pageContent +=		"<td>" + record._selected + "</td>";
	    				pageContent +=		"</tr>";
					}
					
					pageContent += 		"</table>"
								+	"</div>";
	
	
					//원본 데이터
					pageContent += 	"<h4 onclick=showDisplay(\""+ dataSet.id +"_sheetDataOrg\")> " + getText("message_checkMemory_113", "5. 원본 데이터") + " </h4>"
								+ 	"<div class=\"DataSheet\" id=\"" + dataSet.id + "_sheetDataOrg\" name=\"" + dataSet.id + "_sheetDataOrg\" tabname=\"" + getText("message_checkMemory_111", "데이터셋 데이터") + "\" style=\"display :none; width: 100%;overflow-x: scroll;\">"
								+		"<table style=\"width:100%\">"
								+			"<tr>";
	
					for(var key in dataSet.colInfos){
						var colInfo = dataSet.colInfos[key];
					    if (typeof(colInfo) == "function" ) continue;
						pageContent +=			"<td class=\"lColHead\">" + colInfo.id +"</td>";
					}
					
					pageContent +=			"<td class=\"lColHead\">[RowType]</td>";
					pageContent += 			"</tr>";
					
					
					for (var i=0; i < dataSet.OriginBuffer.length; i++){
					    var record = dataSet.OriginBuffer[i];
					    
	    				pageContent +=		"<tr>";
	    				for(var key in dataSet.colInfos){
	    				    if (typeof(dataSet.colInfos[key]) == "function" ) continue;
	    					pageContent +=		"<td>" + record.values[key] + "</td>";
	    				}
	    				pageContent +=		"<td>" + record.RowType + "</td>";
	    				pageContent +=		"</tr>";
					}
					
					pageContent += 		"</table>"
								+	"</div>";
	
	
					pageContent += 	"</div><br>";
	
				}
			}
			
			
			//팝업창 풋터
			//팝업창의 body, html 태그를 닫는다.
			pageContent += "</body></html>";

			//팝업창 호출 및 데이터 입력
			//팝업창을 열고 만든 html 태그를 입력한다.
			var OpenWin;
		    OpenWin=window.open(" ","open1", "width=850px, height=700px, scrollbars=1");
		    OpenWin.document.open();
		    OpenWin.document.write(pageContent);
		    OpenWin.document.close();
		};
	    
	    // [ctrl] + [m]
	    setEventHandler(document, "dblclick", checkMemory);
/**
 * 프로세스 빌더 저장시 필요한 객체
 * 저장 콘트롤 정보만 가지고 있다가 저장할때 데이터 생성
 */

var CONSOLE_LOG_NONE = 0;
var CONSOLE_LOG_ERROR = 1;
var CONSOLE_LOG_SENDDATA = 2;
var CONSOLE_LOG_SUCCESS = 4;

var DEBUG_INFO_PB = 32;

/*
 * 
 * OUTPUT_CONSOLE_SETTING : PB 로그 출력 여부
 * 
 * <Setting Value>
 * 	CONSOLE_LOG_NONE : 출력안함
 * 	CONSOLE_LOG_ERROR : ERROR 출력
 * 	CONSOLE_LOG_SENDDATA : SEND DATA 출력 
 * 	CONSOLE_LOG_SUCCESS : SUCCESS 출력
 * 
 * <Example>
 * 	1. Error 만 출력 : CONSOLE_LOG_ERROR
 *  2. Error와 SUCCESS 만 출력 : CONSOLE_LOG_ERROR + CONSOLE_LOG_SUCCESS
 *  3. 모두 출력 : CONSOLE_LOG_ERROR + CONSOLE_LOG_SENDDATA + CONSOLE_LOG_SUCCESS
 *  
 */
var OUTPUT_CONSOLE_SETTING = CONSOLE_LOG_ERROR + DEBUG_INFO_PB;

/**
 * @class		builder
 * @constructor	
 * @description	미결
 * @param		{String}	builder
 * @return		{void}
 * @example		미결
 */
function processBuilder(builder) {
	// 속성 선언 네임외의 속성은 builder에 넣어서 씀
	this.builder = builder;
	
	this.id = ""; 			// "getif;pb.일괄발주관리.상품별입수_원가조회" ;
	this.name = "";		// "PB.PB.일괄발주관리.상품별입수_원가조회" ;
	this.system = "";		// "ProcessBuilder" ;
	this.sysid = "";		// "PATHFINDER" ;
	this.menuid = "";		// "1007001008041" ;
	
	this.menuname = "";	// "일괄발주관리" ;
	this.eventid = "";		// "CentGoodsLastList" ;
	this.eventname = "";	// "상품별입수_원가조회" ;
	this.classid = "";		// "DTBATBALJUMGMT" ;
	this.async = true;
	 
	this.tempId = Math.floor(Math.random() * 10000000000) + 1; // 고유 식별코드
	this.tempDataSets_Send = [];
	this.tempDataSets_Recv = [];
	 
	this.srvId = "";
	 
	this.successEvent = false; this.fncSuccessEvent = null; // 성공
	this.failEvent = false; this.fncFailEvent = null; // 실패
	
	// 이벤트 선언
	try {
		if (eval("interface_ProcessBuilder_PATHFINDER_" + builder.id + "_OnSuccess")) this.successEvent = true;
	} catch(e){}
	if (this.successEvent){
		eval("this.fncSuccessEvent = function(srvId, ErrorCode, ErrorMsg, hasCallBack){ return interface_ProcessBuilder_PATHFINDER_" + builder.id + "_OnSuccess(srvId, ErrorCode, ErrorMsg, hasCallBack);}");
	}
	
	try {
		if (eval("interface_ProcessBuilder_PATHFINDER_" + builder.id + "_OnFailure")) this.failEvent = true;
	} catch(e){}
	if (this.failEvent){
		eval("this.fncFailEvent = function(message, hasCallBack){ return interface_ProcessBuilder_PATHFINDER_" + builder.id + "_OnFailure(message, hasCallBack);}");
	}
	
	return;
};

var xpbs = [];   // 임시작업목록 tempId가 키임.
var pbxhr = [];

/**
 * @description 미결
 * @returns 	{String}
 * @example		미결
 */
processBuilder.prototype._clone = function(){
	
	 var xpb = new processBuilder(this.builder);
	 
	 xpb.id = this.id; 					// "getif;pb.일괄발주관리.상품별입수_원가조회" ;
	 xpb.name = this.name;				// "PB.PB.일괄발주관리.상품별입수_원가조회" ;
	 xpb.system = this.system;			// "ProcessBuilder" ;
	 xpb.sysid = this.sysid;			// "PATHFINDER" ;
	 xpb.menuid = this.menuid;			// "1007001008041" ;
	 
	 xpb.menuname = this.menuname;		// "일괄발주관리" ;
	 xpb.eventid = this.eventid;		// "CentGoodsLastList" ;
	 xpb.eventname = this.eventname;	// "상품별입수_원가조회" ;
	 xpb.classid = this.classid;		// "DTBATBALJUMGMT" ;
	 xpb.async = this.async;

	return xpb;
};

//프로세스빌더 데이터 보낼 데이터 세팅
/**
 * @description	미결
 * @return		{String}
 * @example		미결
 */
processBuilder.prototype.sendData = function() {
	var jsonData = "[";
	
	var builderSend = this.builder.send;
	var groupLen = builderSend.group.length - 1;
	
	// 데이터셋 임의 변경시 처리
	
	// 그룹별로 데이터 생성
	for(var groupNum=0; groupNum<groupLen; groupNum++){
		
		var groupName = builderSend.group[groupNum].trim()
		var dataSet = this.builder.send[builderSend.group[groupNum].trim()];
		
		if(typeof dataSet == "undefined") continue;
		
		var sendtype = (dataSet.sendtype) ? dataSet.sendtype : 0;
		var formulaData = dataSet.formula;
		var controlData = dataSet.control;
		var dataLen = controlData.length - 1;
		var sheet = controls[dataSet.sheet];
		
		if ((typeof(dataSet.datasetName) != "undefined" && dataSet.datasetName.length > 0) || (typeof(this.tempDataSets_Send) != "undefined" && this.tempDataSets_Send.length > 0)){
			// 데이터셋 임시교체가 있는 경우  {group: "AAA", datasetName: "BBB"}; 
			var datasetName = dataSet.datasetName;
			if (this.tempDataSets_Send.length > 0){
				for (var i = 0; i < this.tempDataSets_Send.length; i++){
					if (this.tempDataSets_Send[i].group == groupName){
						datasetName = this.tempDataSets_Send[i].datasetName;
						break;
					}
				}
				//this.tempDataSets_Send.clear();
			}
			var dataset_Mi = dataSets[datasetName];
			
			//group명이 일치하지 않는 경우 SEND-DATASET을 만들지 않는다.
			if(typeof dataset_Mi == "undefined" && dataset_Mi == undefined) continue;
			
			// 데이터셋 정보가 있는 경우 
			jsonData += '{"inDsList":"' + groupName +'", "recordList":[';
			jsonData += dataset_Mi.getJsonStr( sendtype );
			jsonData += ']},'
		}
		else {
			// 데이터셋 정보가 없는 경우 
			jsonData += '{"inDsList":"' + groupName +'", "recordList":[';
			
			var maxRows = 1;
			// 시트 데이터가 있을때 maxRows 값 조정
			if(sheet){
				maxRows = sheet.maxRows;
			}
			
			// 시트 최대 줄수만큼 데이터를 만든다.
			for(var rowNum=1; rowNum<=maxRows; rowNum++){
				// 1. 전체전송 : 모든 데이터를 전송한다.(sendtype : 0)
				// 2. 수정분전송 : 시트 데이터 중 수정된 데이터만 전송한다. / 그 외 컨트롤만으로 전송할 경우 데이터를 전부 전송한다.(sendtype : 1)
				// if( (/*전체전송 조건(sendtype : 0)*/) || (/*수정분전송이고 시트데이터를 전송하고 시트의 각 행의 수정구분이 N이 아닌 경우(I, U, D인 경우)*/) ){
				if( (sendtype * 1 == 0) || (sendtype * 1 == 1 && !sheet) || (sendtype * 1 == 1 && sheet && sheet.getIUDNFlag(rowNum) + "" != "N") ){
					jsonData += '{';
					for(var wRow=0; wRow<dataLen; wRow++){
						//jsonData += '"' + formulaData[wRow] + '":"' + (((formulaData[wRow]+ "").toUpperCase() == "IUDFLAG") ? (sheet? sheet.getIUDNFlag(rowNum): "U") : eval(controlData[wRow])) + '",';
						jsonData += '"' + formulaData[wRow] + '":"' + (((formulaData[wRow]+ "").toUpperCase() == "IUDFLAG") ? (sheet? sheet.getIUDNFlag(rowNum): "U") : eval("encodeURIComponent(" + controlData[wRow] + ")")) + '",';
					}
					// 플래그 삽입 (시트가 아닌 한줄데이터일때는 플래그 "U"를 넣어준다.
					jsonData += '"flagwizware":"' + (sheet? sheet.getIUDNFlag(rowNum): "U") + '"},';
				}
			}
			jsonData += ']},'
		}
	}
	
	jsonData += ']';
	
	this.tempDataSets_Send.clear();
	
	return jsonData;
};


// 프로세스 빌더 받을 데이터 처리 (시트 데이터는 recordList 따로 받음)
/**
 * @description	미결
 * @param		{String}	data
 * @return		{String}
 * @example		미결
 */
processBuilder.prototype.receiveData = function(data){
	var receiveDataList = []; // 리턴할 시트 데이터
	
	var builderReceive = this.builder.receive;
	
	var sheetData = []; //시트의 이름별로 데이터를 문자열로 저장
	var sheetDefaultData = []; // 시트의 디폴트 데이터 저장
	var sheetNameArray = []; // 시트이름을 배열로 저장
	var updateMode =  "clear" // 업데이트모드 (clear, update)
	var sheetNameNum = 0; // 시트 이름 체크할때 쓰는 변수
	
	// 데이터셋별로 루핑하여 시트데이터는 만들어서 그룹(데이터셋),시트명으로 저장 나머지 콘트롤들은 바로 데이터를 채워준다.
	for(var rNum=0; rNum<data.length; rNum++){
		var groupName = data[rNum].outDsList; // 그룹이름
		var dataSet = builderReceive[groupName]; // 데이터셋(그룹)
		
		if(dataSet == undefined || dataSet == null) continue;
		
		if ((typeof(dataSet.datasetName) != "undefined" && dataSet.datasetName.length > 0) || (typeof(this.tempDataSets_Recv) != "undefined" && this.tempDataSets_Recv.length > 0)){
			// 데이터셋 임시교체가 있는 경우  {group: "AAA", datasetName: "BBB"}; 
			var datasetName = dataSet.datasetName;
			
			var receiveGroup = this.builder.receive[groupName];
			var clearMode  = receiveGroup["clearMode"];
			var updateMode = receiveGroup["updateMode"];
			var searchMode = receiveGroup["searchMode"];
			var searchupdateMode = receiveGroup["searchupdateMode"];
			
			if (this.tempDataSets_Recv.length > 0){
				for (var i=0; i < this.tempDataSets_Recv.length; i++){
					if (this.tempDataSets_Recv[i].group == groupName){
						datasetName = this.tempDataSets_Recv[i].datasetName;
						
						var dataset_Mi = dataSets[datasetName];
						//데이터셋이 없는 경우 
						if(typeof dataset_Mi == "undefined") continue;
						//- 기존데이터클리어: 기존데이터 전체를 날린다.
						if (clearMode){
							dataset_Mi.loadJson(data[rNum]);
						} else	if (updateMode == "update"){ //- 현재항목수정    : 기존데이터클리어== false일 때 선택가능, 줄추가할 것인지 현재줄에 Overwrite할 것인지.
							dataset_Mi.updateByJson(data[rNum]);
						} else if (updateMode == "clear"){
							dataset_Mi.appendJson(data[rNum]);
						}
						//- searchfill      : 소트된 필드에서 찾아할 것인지 
						//- 줄추가          : searchfill 일때 추가선택 가능, 없는데이터의 줄추가
						// break;
					}
				}
				//this.tempDataSets_Recv.clear();
			}
			else{
				var dataset_Mi = dataSets[datasetName];
				//- 기존데이터클리어: 기존데이터 전체를 날린다.
				if (clearMode){
					dataset_Mi.loadJson(data[rNum]);
				} else	if (updateMode == "update"){ //- 현재항목수정    : 기존데이터클리어== false일 때 선택가능, 줄추가할 것인지 현재줄에 Overwrite할 것인지.
					dataset_Mi.updateByJson(data[rNum]);
				} else if (updateMode == "clear"){
					dataset_Mi.appendJson(data[rNum]);
				}
			}
		}
		else {			
			var recordset = data[rNum].recordList;
			var formulaData = dataSet.formula; // 각 매칭되는 콘트롤에 입력될 값
			var controlData = dataSet.control; // 값을 입력받을 콘트롤 집합
			updateMode = dataSet.updateMode;
			var dataLen = controlData.length - 1; // 적용한 프로세스빌더 데이터 길이
			var dataSetSheetName = [];
			var dataSetSheetNum = 0;
			
			// 시트 콘트롤이 있는지 체크 하고 시트데이터 배열에 넣을 문자데이터의 첫번째값을 세팅
			for(var i=0; i<dataLen; i++){
				if(/.+\.\d+$/.test(controlData[i])) {
					var controlName = controlData[i].indexOf(".") < 0 ? controlData[i] : controlData[i].substr(0, controlData[i].indexOf("."));
					if(!sheetData[controlName]){
						sheetData[controlName] = [];
						sheetDefaultData[controlName] = controls[controlName].defaultLayoutValue;
						sheetNameArray[sheetNameNum] = controlName; // 시트 이름을 배열로 순서대로 저장
						dataSetSheetName[dataSetSheetNum] = controlName; // 시트 이름을 배열로 순서대로 저장
						sheetNameNum++; // 시트 이름 배열용 변수
						dataSetSheetNum++; // 시트 이름 배열용 변수
					}
				}
			}
			
			// 시트 콘트롤 이름 배열 중복제거
			sheetNameArray = sheetNameArray.reduce(function(a,b){if(a.indexOf(b)<0)a.push(b);return a;},[]);
			dataSetSheetName = dataSetSheetName.reduce(function(a,b){if(a.indexOf(b)<0)a.push(b);return a;},[]);
			
			// 넘겨받은 레코드 row 값만큼 루핑을 돌며 데이터 세팅 및 시트데이터 생성
			for(var wRow=0; wRow<recordset.length; wRow++){
				// 시트에 디폴트값 미리 생성
				for(var s=0; s<dataSetSheetName.length; s++){
					sheetData[dataSetSheetName[s]].push(eval(sheetDefaultData[dataSetSheetName[s]]));
				}
				
				// 시트데이터 만들기 및 기타 콘트롤 값 세팅
				for(var i=0; i<dataLen; i++){
					var control = controlData[i];
					var controlName = control.indexOf(".") < 0 ? control : control.substr(0, control.indexOf("."));
					
					// 시트 일때
					if(/.+\.\d+$/.test(controlData[i])){
						var SheetNum = control.substr(control.indexOf(".")+1, control.length);
						sheetData[controlName][wRow]["f"+SheetNum] = eval( "(\"\" + (" + formulaData[i] + ")).replace(/\"/g, \"\\\"\").replace(/'/g, \"'\").replace(/<BR>/gi,\"\\n\").replace(/<BR2>/gi,\"\\r\").replace(/<BS>/gi, \"\\\\\")" );
					}
					// 프레임
					else if(control.indexOf("setVisible")>=0){
						eval(control + formulaData[i] + ".replace(/[\"']/g, \"\\\\'\")" + ") == 1)");
					}
					// 나머지 콘트롤
					else{
						eval( control + " (" + formulaData[i] + " + \"\")" + ".replace(/\"/g, \"\\\"\").replace(/'/g, \"'\").replace(/<BR>/gi,\"\\n\").replace(/<BR2>/gi,\"\\r\").replace(/<BS>/gi, \"\\\\\")" + " )" );
					}
				}
			}
		}
	}
	
	this.tempDataSets_Recv.clear();
	
	receiveDataList["sheetData"] = sheetData;
	receiveDataList["sheetName"] = sheetNameArray;
	receiveDataList["updateMode"] = updateMode;
	
	return receiveDataList;
};

// 프로세스빌더 호출
/**
 * @description	미결
 * @param		{String}	pAsync
 * @return		{void}
 * @example		미결
 */
processBuilder.prototype.open = function(pAsync){ 
	if (pAsync == undefined) pAsync = this.async;
	
	var ajaxBoxVisible = false;
	try{
		// 실행조건 체크
		if(this.builder.exeCondition.length > 0 && !eval(this.builder.exeCondition)) return;
		
		var callBuilder = this;
		//showAjaxBox("요청 데이터 처리중...", 0, NEED_NOT_COUNT_UP);
		showAjaxBox("요청 데이터 처리중...", 0, NEED_COUNT_UP);
		ajaxBoxVisible = true;
		
		// 파라메터 세팅
//		var serverURL = "172.32.10.44/MINISTOP4/";
		var serverURL = USER_JBOSSIP + "/MINISTOP4/";	/*서버*/
//		var serverURL = "4.254.1.31:8080/sht_webapp/";	/*조민재 과장님*/
//		var serverURL = "4.254.1.38/MINISTOP4/";		/*기충현 대리님*/
//		var serverURL = "4.254.1.43/MINISTOP4/";		/*조세운 대리님*/
//		var serverURL = "4.254.1.22/MINISTOP4/";		/*김신혜 씨*/
//		var serverURL = "4.254.1.33/MINISTOP4/";		/*김남용 과장님*/
//		var serverURL = "4.254.1.62/MINISTOP4/";		/*한국민 씨*/
//		var serverURL = "4.254.1.60/MINISTOP4/";		/*김일주 씨*/
//		var serverURL = "4.254.1.59/MINISTOP4/";		/*이인우 씨*/
//		var serverURL = "localhost/MINISTOP4/";
//		var serverURL = "localhost/sht_webapp/";
		if (pAsync) {
			serverURL = "http://" + serverURL;
		} else {
			serverURL = "http://" + self.location.host + "/FlexFrame/relay?url=" + serverURL;
		}
		
	    var wQueryString = eval('({"paramwizware":' + this.sendData() + '})');
	    
	    if((OUTPUT_CONSOLE_SETTING & CONSOLE_LOG_SENDDATA) && typeof console != "undefined") console.log("SEND DATA : paramwizware=" + decodeURIComponent(JSON.stringify(wQueryString)));
	    
	    //DEBUG INFO//
	    if((OUTPUT_CONSOLE_SETTING & DEBUG_INFO_PB) && typeof console != "undefined"){
	    	console.log("PB_DEBUG_URL : " + serverURL + this.builder.id + ".do" + (pAsync ? "?" : "&"));
	    	console.log("PB_DEBUG_DATA : paramwizware=" + JSON.stringify(wQueryString));
	    }
	    
		$.ajax({
			type : "POST",
			url : serverURL + this.builder.id + ".do" + (pAsync ? "?" : "&"),
			dataType: "jsonp",
			data: "paramwizware="+JSON.stringify(wQueryString) + "&callback=?",
			async: pAsync, // false 일땐 동기방식으로 요청 ( cross-domain 에서는 지원하지 않는다)
			beforeSend : function(jqXHR){
				pbxhr.push( jqXHR );
			},
			complete : function(jqXHR) {
				hideAjaxBox(NEED_NOT_COUNT_UP);
				callBuilder = null;
				
				for(var i = 0; i < pbxhr.length; i++){
					if(pbxhr[i] == jqXHR){
						pbxhr.slice(0, i).concat(pbxhr.slice(i + 1));
						break;
					}
				}
			},
			success : function(returnObject) {
				if((OUTPUT_CONSOLE_SETTING & CONSOLE_LOG_SUCCESS) && typeof console != "undefined") console.log("SUCCESS : " + JSON.stringify(returnObject) );
				
				// 서버데이터
				var processObject = returnObject.paramwizware;				
				
				// 에러 코드가 넘어 왔을때
				if(processObject.Code < 0) {
					//hideAjaxBox(NEED_NOT_COUNT_UP);
					hideAjaxBox(NEED_COUNT_UP);
					alert(getText("message_processBuilder_001", "에러 메세지가 있습니다.{0}", [processObject.Msg]));
					return;
				}
				
				// 레코드 데이터
				var recordset = processObject.recordset;
				// 데이터 세팅
				var receiveData = callBuilder.receiveData(recordset);
	
				// 시트에 들어갈 데이터가 있는지 파악
				var sheetData = receiveData["sheetData"];
			    var sheetName = receiveData["sheetName"];
			    var updateMode = receiveData["updateMode"];
				if(sheetName != undefined && sheetName.length > 0){
				    for(sheetNum=0; sheetNum<sheetName.length; sheetNum++){
				    	var aSheet = controls[sheetName[sheetNum]];
				    	var data = sheetData[sheetName[sheetNum]];
				    	if(updateMode == "update"){
				    		aSheet.setAppendData(data);
				    	}else{ // clear
				    		aSheet.clear();
				    		aSheet.setData(data);
				    	}
				    	//AUI Sheet 인 경우 NO-DATA 메세지를 출력한다/NO-DATA 메세지를 따로 설정하려면 SUCCESS 이벤트에서 해당 시트의 showNoDataMessage(true, "출력할 메세지"); 를 사용한다.
				    	if(aSheet instanceof AUIDataSheet) aSheet.showNoDataMessage(true);
				    }
				}
				
				// 이벤트
				if(callBuilder.successEvent) callBuilder.fncSuccessEvent(callBuilder.srvId, processObject.Code, processObject.Msg, callBuilder.hasCallBack);
				
				delete xpbs[callBuilder.tempId];
				//hideAjaxBox(NEED_NOT_COUNT_UP);
				hideAjaxBox(NEED_COUNT_UP);
				
			},
			error : function(request,status,error) {
				// 이벤트
				if("" + status != "abort"){
					//var message = "status : " + status + "\n" + "request : " + JSON.stringify(request) +"\n" + error;		/*테스트 시 동작 에러를 확인하려면 이 코드의 주석을 풀어주세요.*/
					var message = "관리자에게 문의해주십시오.";																		/*운영 적용시 이 코드의 주석을 풀고 위 코드를 주석 처리해주세요*/
					if((OUTPUT_CONSOLE_SETTING & CONSOLE_LOG_ERROR) && typeof console != "undefined") console.log("ERROR : " + message);
					
					if(callBuilder.failEvent) {
						callBuilder.fncFailEvent(message, callBuilder.hasCallBack);
						alert(message);
					}
				}
				
				delete xpbs[callBuilder.tempId];
				//hideAjaxBox(NEED_NOT_COUNT_UP);
				hideAjaxBox(NEED_COUNT_UP);
			}
		});
		
	}catch(e){
		//if (ajaxBoxVisible)	hideAjaxBox(NEED_NOT_COUNT_UP);
		if (ajaxBoxVisible)	hideAjaxBox(NEED_COUNT_UP);
		
		//alert(getText("message_processBuilder_002", "데이터 생성중 에러가 발생하였습니다. \n{0}", [e]));	/*테스트 시 동작 에러를 확인하려면 이 코드의 주석을 풀어주세요.*/
		alert(getText("message_processBuilder_003", "관리자에게 문의해주십시오."));					/*운영 적용시 이 코드의 주석을 풀고 위 코드를 주석 처리해주세요*/
	}
    
    return;
};

// gfn_SyncCall("searchGoodsnm","MINISTOP?SYSID=PATHFINDER&MENUID=1007001008041&EVENTID=CentGoodsLastList","S=ds_DtGoodsInput","ds_goods=SEL3","",""); 
/**
 * @description	미결
 * @param		{String}	async
 * @param		{String}	srvId
 * @param		{String}	url
 * @param		{String}	inDsList
 * @param		{String}	outDsList
 * @param		{String}	arg
 * @param		{boolean}	CallBackFunc
 * @return		{undefined}
 * @example		미결
 */
function _InterfaceCall(async, srvId, url, inDsList, outDsList, arg, CallBackFunc){
	var sysid = "";
	var menuid = "";
	var eventid = "";
	var xPb = null;
	
	if (url.indexOf("?") >= 0) url = url.substring(url.indexOf("?") + 1);
	var wArr = url.split("&");
	for (var i = 0; i < wArr.length;i++){
		var str = wArr[i];
		if (str.indexOf("=") < 0) continue;
		
		var wArr1 = str.split("=");
		if (wArr1[0] == "SYSID"){
			sysid = wArr1[1];
		} else if (wArr1[0] == "MENUID"){
			menuid = wArr1[1];
		} else if (wArr1[0] == "EVENTID"){
			eventid = wArr1[1];
		} 
	}
	
	for (var key in objects){
		var pb = objects[key];
		if (typeof pb == "function") continue;
		if ( !(pb instanceof processBuilder)) continue;

		if (sysid == pb.sysid && menuid == pb.menuid && eventid == pb.eventid){
			xPb = pb._clone();
			break;
		}
	}
	
	// 함수를 벗어나도 메모리에서 사라지지 않게 하기 위하여 전역배열에 추가
	xpbs[xPb.tempId] = xPb;
	
	//srvId 지정
	xPb.srvId = srvId;
	
	// inDsList 분석 
	if (inDsList != undefined && inDsList.length != 0){
		var ndx = 0;
		var wArr = inDsList.split(" ");
		for (var i=0; i< wArr.length; i++){
			if (wArr[i].indexOf("=") < 0) continue;
			var wArr1 = wArr[i].split("=");
			//IN-DATASET 정보
			var group = wArr1[0];
			var dataset = ((wArr1[1] + "").indexOf(":") < 0) ? wArr1[1] : wArr1[1].split(":")[0];
			//Send Type : 전체전송[또는 아무것도 안 붙인 경우/기본](:N/0), 수정분전송(:U/1), 전체전송(:A/2)
			var sendtype = ((wArr1[1] + "").toUpperCase().indexOf(":U") < 0) ? (((wArr1[1] + "").toUpperCase().indexOf(":A") < 0) ? 0 : 2) : 1;
			//IN-DATASET 설정
			xPb.builder.send[wArr1[0]].sendtype = sendtype;
			xPb.tempDataSets_Send[ndx++] = {group: group, datasetName: dataset}; 
		}
		
		if(typeof _G != "undefined" && typeof DataSet == "function" && _G instanceof DataSet ){
			if(typeof xPb.builder.send["G"] == "undefined"){
				var gdx = xPb.builder.send.group.length;
				gdx = (gdx > 0 && (xPb.builder.send.group[gdx - 1]).trim() == "") ? gdx - 1 : gdx;
				xPb.builder.send.group[gdx] = "G";
				xPb.builder.send["G"] = {};
				xPb.builder.send["G"].sendtype = 0;
				xPb.builder.send["G"].control = [];
				xPb.builder.send["G"].formula = "";
				xPb.builder.send["G"].datasetName = "_G";
				xPb.tempDataSets_Send[ndx++] = {group: "G", datasetName: "_G"};
				xPb.builder.send.group[gdx + 1] = "";
			}
		}
	}
	
	// outDsList 분석 
	if (outDsList != undefined && outDsList.length != 0){
		var ndx = 0;// xPb.tempDataSets_Recv.length;
		var wArr = outDsList.split(" ");
		for (var i=0; i< wArr.length; i++){
			if (wArr[i].indexOf("=") < 0) continue;
			var wArr1 = wArr[i].split("=");
			xPb.tempDataSets_Recv[ndx++] = {group: wArr1[1], datasetName: wArr1[0]}; 
		}
	}
	
	// callBack 함수 유무
	xPb.hasCallBack = ( (CallBackFunc + "").length != 0 ) ? true : false;
	
	xPb.open(async);

};

//예: gfn_SyncCall("searchGoodsnm","MINISTOP?SYSID=PATHFINDER&MENUID=1007001008041&EVENTID=CentGoodsLastList","S=ds_DtGoodsInput","ds_goods=SEL3","",""); 
//예: gfn_SyncCall("searchGoodsnm","MINISTOP?SYSID=PATHFINDER&MENUID=1007001008041&EVENTID=CentGoodsLastList","S=ds_DtGoodsInput S1=DS_AAA","ds_goods1=SEL3 DS_ZZZZZ=sel1","",""); 
/**
 * @description	미결
 * @param		{boolean}	srvId
 * @param		{boolean}	url
 * @param		{boolean}	inDsList
 * @param		{boolean}	outDsList
 * @param		{boolean}	arg
 * @param		{boolean}	CallBackFunc
 * @return		{undefined}
 * @example		미결
 */
function gfn_SyncCall(srvId, url, inDsList, outDsList, arg, CallBackFunc)
{
	_InterfaceCall(false, srvId, url, inDsList, outDsList, arg, CallBackFunc);
};

function gfn_AsyncCall(srvId,url,inDsList,outDsList,arg,CallBackFunc)
{
	_InterfaceCall(true, srvId, url, inDsList, outDsList, arg, CallBackFunc);
};
/**
 * @description	미결
 * @return		{undefined}
 * @example		미결
 */
function allAbortPBCall(){
	for(var i = 0; i < pbxhr.length; i++){
		pbxhr[i].abort();
		pbxhr[i] = null;
	}
	
	pbxhr.clear();
	pbxhr = null;
	delete pbxhr;
	
	pbxhr = [];
};
/**
 * SWFUpload: http://www.swfupload.org, http://swfupload.googlecode.com
 *
 * mmSWFUpload 1.0: Flash upload dialog - http://profandesign.se/swfupload/,  http://www.vinterwebb.se/
 *
 * SWFUpload is (c) 2006-2007 Lars Huring, Olov Nilz?n and Mammon Media and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * SWFUpload 2 is (c) 2007-2008 Jake Roberts and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 */


/* ******************* */
/* Constructor & Init  */
/* ******************* */
var SWFUpload;

if (SWFUpload == undefined) {
	SWFUpload = function (settings) {
		this.initSWFUpload(settings);
	};
}

SWFUpload.prototype.initSWFUpload = function (settings) {
	try {
		this.customSettings = {};	// A container where developers can place their own settings associated with this instance.
		this.settings = settings;
		this.eventQueue = [];
		this.movieName = "SWFUpload_" + SWFUpload.movieCount++;
		this.movieElement = null;


		// Setup global control tracking
		SWFUpload.instances[this.movieName] = this;

		// Load the settings.  Load the Flash movie.
		this.initSettings();
		this.loadFlash();
		this.displayDebugInfo();
	} catch (ex) {
		delete SWFUpload.instances[this.movieName];
		throw ex;
	}
};

/* *************** */
/* Static Members  */
/* *************** */
SWFUpload.instances = {};
SWFUpload.movieCount = 0;
SWFUpload.version = "2.2.0 2009-03-25";
SWFUpload.QUEUE_ERROR = {
	QUEUE_LIMIT_EXCEEDED	  		: -100,
	FILE_EXCEEDS_SIZE_LIMIT  		: -110,
	ZERO_BYTE_FILE			  		: -120,
	INVALID_FILETYPE		  		: -130
};
SWFUpload.UPLOAD_ERROR = {
	HTTP_ERROR				  		: -200,
	MISSING_UPLOAD_URL	      		: -210,
	IO_ERROR				  		: -220,
	SECURITY_ERROR			  		: -230,
	UPLOAD_LIMIT_EXCEEDED	  		: -240,
	UPLOAD_FAILED			  		: -250,
	SPECIFIED_FILE_ID_NOT_FOUND		: -260,
	FILE_VALIDATION_FAILED	  		: -270,
	FILE_CANCELLED			  		: -280,
	UPLOAD_STOPPED					: -290
};
SWFUpload.FILE_STATUS = {
	QUEUED		 : -1,
	IN_PROGRESS	 : -2,
	ERROR		 : -3,
	COMPLETE	 : -4,
	CANCELLED	 : -5
};
SWFUpload.BUTTON_ACTION = {
	SELECT_FILE  : -100,
	SELECT_FILES : -110,
	START_UPLOAD : -120
};
SWFUpload.CURSOR = {
	ARROW : -1,
	HAND : -2
};
SWFUpload.WINDOW_MODE = {
	WINDOW : "window",
	TRANSPARENT : "transparent",
	OPAQUE : "opaque"
};

// Private: takes a URL, determines if it is relative and converts to an absolute URL
// using the current site. Only processes the URL if it can, otherwise returns the URL untouched
SWFUpload.completeURL = function(url) {
	if (typeof(url) !== "string" || url.match(/^https?:\/\//i) || url.match(/^\//)) {
		return url;
	}
	
	var currentURL = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port : "");
	
	var indexSlash = window.location.pathname.lastIndexOf("/");
	if (indexSlash <= 0) {
		path = "/";
	} else {
		path = window.location.pathname.substr(0, indexSlash) + "/";
	}
	
	return /*currentURL +*/ path + url;
	
};


/* ******************** */
/* Instance Members  */
/* ******************** */

// Private: initSettings ensures that all the
// settings are set, getting a default value if one was not assigned.
SWFUpload.prototype.initSettings = function () {
	this.ensureDefault = function (settingName, defaultValue) {
		this.settings[settingName] = (this.settings[settingName] == undefined) ? defaultValue : this.settings[settingName];
	};
	
	// Upload backend settings
	this.ensureDefault("upload_url", "");
	this.ensureDefault("preserve_relative_urls", false);
	this.ensureDefault("file_post_name", "Filedata");
	this.ensureDefault("post_params", {});
	this.ensureDefault("use_query_string", false);
	this.ensureDefault("requeue_on_error", false);
	this.ensureDefault("http_success", []);
	this.ensureDefault("assume_success_timeout", 0);
	
	// File Settings
	this.ensureDefault("file_types", "*.*");
	this.ensureDefault("file_types_description", "All Files");
	this.ensureDefault("file_size_limit", 0);	// Default zero means "unlimited"
	this.ensureDefault("file_upload_limit", 0);
	this.ensureDefault("file_queue_limit", 0);

	// Flash Settings
	this.ensureDefault("flash_url", "swfupload.swf");
	this.ensureDefault("prevent_swf_caching", true);
	
	// Button Settings
	this.ensureDefault("button_image_url", "");
	this.ensureDefault("button_width", 1);
	this.ensureDefault("button_height", 1);
	this.ensureDefault("button_text", "");
	this.ensureDefault("button_text_style", "color: #000000; font-size: 16pt;");
	this.ensureDefault("button_text_top_padding", 0);
	this.ensureDefault("button_text_left_padding", 0);
	this.ensureDefault("button_action", SWFUpload.BUTTON_ACTION.SELECT_FILES);
	this.ensureDefault("button_disabled", false);
	this.ensureDefault("button_placeholder_id", "");
	this.ensureDefault("button_placeholder", null);
	this.ensureDefault("button_cursor", SWFUpload.CURSOR.ARROW);
	this.ensureDefault("button_window_mode", SWFUpload.WINDOW_MODE.WINDOW);
	
	// Debug Settings
	this.ensureDefault("debug", false);
	this.settings.debug_enabled = this.settings.debug;	// Here to maintain v2 API
	
	// Event Handlers
	this.settings.return_upload_start_handler = this.returnUploadStart;
	this.ensureDefault("swfupload_loaded_handler", null);
	this.ensureDefault("file_dialog_start_handler", null);
	this.ensureDefault("file_queued_handler", null);
	this.ensureDefault("file_queue_error_handler", null);
	this.ensureDefault("file_dialog_complete_handler", null);
	
	this.ensureDefault("upload_start_handler", null);
	this.ensureDefault("upload_progress_handler", null);
	this.ensureDefault("upload_error_handler", null);
	this.ensureDefault("upload_success_handler", null);
	this.ensureDefault("upload_complete_handler", null);
	
	this.ensureDefault("debug_handler", this.debugMessage);

	this.ensureDefault("custom_settings", {});

	// Other settings
	this.customSettings = this.settings.custom_settings;
	
	// Update the flash url if needed
	if (!!this.settings.prevent_swf_caching) {
		this.settings.flash_url = this.settings.flash_url + (this.settings.flash_url.indexOf("?") < 0 ? "?" : "&") + "preventswfcaching=" + new Date().getTime();
	}
	
	if (!this.settings.preserve_relative_urls) {
		//this.settings.flash_url = SWFUpload.completeURL(this.settings.flash_url);	// Don't need to do this one since flash doesn't look at it
		this.settings.upload_url = SWFUpload.completeURL(this.settings.upload_url);
		this.settings.button_image_url = SWFUpload.completeURL(this.settings.button_image_url);
	}
	
	delete this.ensureDefault;
};

// Private: loadFlash replaces the button_placeholder element with the flash movie.
SWFUpload.prototype.loadFlash = function () {
	var targetElement, tempParent;

	// Make sure an element with the ID we are going to use doesn't already exist
	if (document.getElementById(this.movieName) !== null) {
		throw "ID " + this.movieName + " is already in use. The Flash Object could not be added";
	}

	// Get the element where we will be placing the flash movie
	targetElement = document.getElementById(this.settings.button_placeholder_id) || this.settings.button_placeholder;

	if (targetElement == undefined) {
		throw "Could not find the placeholder element: " + this.settings.button_placeholder_id;
	}

	// Append the container and load the flash
	tempParent = document.createElement("div");
	tempParent.innerHTML = this.getFlashHTML();	// Using innerHTML is non-standard but the only sensible way to dynamically add Flash in IE (and maybe other browsers)
	targetElement.parentNode.replaceChild(tempParent.firstChild, targetElement);

	// Fix IE Flash/Form bug
	if (window[this.movieName] == undefined) {
		window[this.movieName] = this.getMovieElement();
	}
	
};

// Private: getFlashHTML generates the object tag needed to embed the flash in to the document
SWFUpload.prototype.getFlashHTML = function () {
	// Flash Satay object syntax: http://www.alistapart.com/articles/flashsatay
	return ['<object id="', this.movieName, '" type="application/x-shockwave-flash" data="', this.settings.flash_url, '" width="', this.settings.button_width, '" height="', this.settings.button_height, '" class="swfupload">',
				'<param name="wmode" value="', this.settings.button_window_mode, '" />',
				'<param name="movie" value="', this.settings.flash_url, '" />',
				'<param name="quality" value="high" />',
				'<param name="menu" value="false" />',
				'<param name="allowScriptAccess" value="always" />',
				'<param name="flashvars" value="' + this.getFlashVars() + '" />',
				'</object>'].join("");
};

// Private: getFlashVars builds the parameter string that will be passed
// to flash in the flashvars param.
SWFUpload.prototype.getFlashVars = function () {
	// Build a string from the post param object
	var paramString = this.buildParamString();
	var httpSuccessString = this.settings.http_success.join(",");
	
	// Build the parameter string
	return ["movieName=", encodeURIComponent(this.movieName),
			"&amp;uploadURL=", encodeURIComponent(this.settings.upload_url),
			"&amp;useQueryString=", encodeURIComponent(this.settings.use_query_string),
			"&amp;requeueOnError=", encodeURIComponent(this.settings.requeue_on_error),
			"&amp;httpSuccess=", encodeURIComponent(httpSuccessString),
			"&amp;assumeSuccessTimeout=", encodeURIComponent(this.settings.assume_success_timeout),
			"&amp;params=", encodeURIComponent(paramString),
			"&amp;filePostName=", encodeURIComponent(this.settings.file_post_name),
			"&amp;fileTypes=", encodeURIComponent(this.settings.file_types),
			"&amp;fileTypesDescription=", encodeURIComponent(this.settings.file_types_description),
			"&amp;fileSizeLimit=", encodeURIComponent(this.settings.file_size_limit),
			"&amp;fileUploadLimit=", encodeURIComponent(this.settings.file_upload_limit),
			"&amp;fileQueueLimit=", encodeURIComponent(this.settings.file_queue_limit),
			"&amp;debugEnabled=", encodeURIComponent(this.settings.debug_enabled),
			"&amp;buttonImageURL=", encodeURIComponent(this.settings.button_image_url),
			"&amp;buttonWidth=", encodeURIComponent(this.settings.button_width),
			"&amp;buttonHeight=", encodeURIComponent(this.settings.button_height),
			"&amp;buttonText=", encodeURIComponent(this.settings.button_text),
			"&amp;buttonTextTopPadding=", encodeURIComponent(this.settings.button_text_top_padding),
			"&amp;buttonTextLeftPadding=", encodeURIComponent(this.settings.button_text_left_padding),
			"&amp;buttonTextStyle=", encodeURIComponent(this.settings.button_text_style),
			"&amp;buttonAction=", encodeURIComponent(this.settings.button_action),
			"&amp;buttonDisabled=", encodeURIComponent(this.settings.button_disabled),
			"&amp;buttonCursor=", encodeURIComponent(this.settings.button_cursor)
		].join("");
};

// Public: getMovieElement retrieves the DOM reference to the Flash element added by SWFUpload
// The element is cached after the first lookup
SWFUpload.prototype.getMovieElement = function () {
	if (this.movieElement == undefined) {
		this.movieElement = document.getElementById(this.movieName);
	}

	if (this.movieElement === null) {
		throw "Could not find Flash element";
	}
	
	return this.movieElement;
};

// Private: buildParamString takes the name/value pairs in the post_params setting object
// and joins them up in to a string formatted "name=value&amp;name=value"
SWFUpload.prototype.buildParamString = function () {
	var postParams = this.settings.post_params; 
	var paramStringPairs = [];

	if (typeof(postParams) === "object") {
		for (var name in postParams) {
			if (postParams.hasOwnProperty(name)) {
				paramStringPairs.push(encodeURIComponent(name.toString()) + "=" + encodeURIComponent(postParams[name].toString()));
			}
		}
	}

	return paramStringPairs.join("&amp;");
};

// Public: Used to remove a SWFUpload instance from the page. This method strives to remove
// all references to the SWF, and other objects so memory is properly freed.
// Returns true if everything was destroyed. Returns a false if a failure occurs leaving SWFUpload in an inconsistant state.
// Credits: Major improvements provided by steffen
SWFUpload.prototype.destroy = function () {
	try {
		// Make sure Flash is done before we try to remove it
		this.cancelUpload(null, false);
		

		// Remove the SWFUpload DOM nodes
		var movieElement = null;
		movieElement = this.getMovieElement();
		
		if (movieElement && typeof(movieElement.CallFunction) === "unknown") { // We only want to do this in IE
			// Loop through all the movie's properties and remove all function references (DOM/JS IE 6/7 memory leak workaround)
			for (var i in movieElement) {
				try {
					if (typeof(movieElement[i]) === "function") {
						movieElement[i] = null;
					}
				} catch (ex1) {}
			}

			// Remove the Movie Element from the page
			try {
				movieElement.parentNode.removeChild(movieElement);
			} catch (ex) {}
		}
		
		// Remove IE form fix reference
		window[this.movieName] = null;

		// Destroy other references
		SWFUpload.instances[this.movieName] = null;
		delete SWFUpload.instances[this.movieName];

		this.movieElement = null;
		this.settings = null;
		this.customSettings = null;
		this.eventQueue = null;
		this.movieName = null;
		
		
		return true;
	} catch (ex2) {
		return false;
	}
};


// Public: displayDebugInfo prints out settings and configuration
// information about this SWFUpload instance.
// This function (and any references to it) can be deleted when placing
// SWFUpload in production.
SWFUpload.prototype.displayDebugInfo = function () {
	this.debug(
		[
			"---SWFUpload Instance Info---\n",
			"Version: ", SWFUpload.version, "\n",
			"Movie Name: ", this.movieName, "\n",
			"Settings:\n",
			"\t", "upload_url:               ", this.settings.upload_url, "\n",
			"\t", "flash_url:                ", this.settings.flash_url, "\n",
			"\t", "use_query_string:         ", this.settings.use_query_string.toString(), "\n",
			"\t", "requeue_on_error:         ", this.settings.requeue_on_error.toString(), "\n",
			"\t", "http_success:             ", this.settings.http_success.join(", "), "\n",
			"\t", "assume_success_timeout:   ", this.settings.assume_success_timeout, "\n",
			"\t", "file_post_name:           ", this.settings.file_post_name, "\n",
			"\t", "post_params:              ", this.settings.post_params.toString(), "\n",
			"\t", "file_types:               ", this.settings.file_types, "\n",
			"\t", "file_types_description:   ", this.settings.file_types_description, "\n",
			"\t", "file_size_limit:          ", this.settings.file_size_limit, "\n",
			"\t", "file_upload_limit:        ", this.settings.file_upload_limit, "\n",
			"\t", "file_queue_limit:         ", this.settings.file_queue_limit, "\n",
			"\t", "debug:                    ", this.settings.debug.toString(), "\n",

			"\t", "prevent_swf_caching:      ", this.settings.prevent_swf_caching.toString(), "\n",

			"\t", "button_placeholder_id:    ", this.settings.button_placeholder_id.toString(), "\n",
			"\t", "button_placeholder:       ", (this.settings.button_placeholder ? "Set" : "Not Set"), "\n",
			"\t", "button_image_url:         ", this.settings.button_image_url.toString(), "\n",
			"\t", "button_width:             ", this.settings.button_width.toString(), "\n",
			"\t", "button_height:            ", this.settings.button_height.toString(), "\n",
			"\t", "button_text:              ", this.settings.button_text.toString(), "\n",
			"\t", "button_text_style:        ", this.settings.button_text_style.toString(), "\n",
			"\t", "button_text_top_padding:  ", this.settings.button_text_top_padding.toString(), "\n",
			"\t", "button_text_left_padding: ", this.settings.button_text_left_padding.toString(), "\n",
			"\t", "button_action:            ", this.settings.button_action.toString(), "\n",
			"\t", "button_disabled:          ", this.settings.button_disabled.toString(), "\n",

			"\t", "custom_settings:          ", this.settings.custom_settings.toString(), "\n",
			"Event Handlers:\n",
			"\t", "swfupload_loaded_handler assigned:  ", (typeof this.settings.swfupload_loaded_handler === "function").toString(), "\n",
			"\t", "file_dialog_start_handler assigned: ", (typeof this.settings.file_dialog_start_handler === "function").toString(), "\n",
			"\t", "file_queued_handler assigned:       ", (typeof this.settings.file_queued_handler === "function").toString(), "\n",
			"\t", "file_queue_error_handler assigned:  ", (typeof this.settings.file_queue_error_handler === "function").toString(), "\n",
			"\t", "upload_start_handler assigned:      ", (typeof this.settings.upload_start_handler === "function").toString(), "\n",
			"\t", "upload_progress_handler assigned:   ", (typeof this.settings.upload_progress_handler === "function").toString(), "\n",
			"\t", "upload_error_handler assigned:      ", (typeof this.settings.upload_error_handler === "function").toString(), "\n",
			"\t", "upload_success_handler assigned:    ", (typeof this.settings.upload_success_handler === "function").toString(), "\n",
			"\t", "upload_complete_handler assigned:   ", (typeof this.settings.upload_complete_handler === "function").toString(), "\n",
			"\t", "debug_handler assigned:             ", (typeof this.settings.debug_handler === "function").toString(), "\n"
		].join("")
	);
};

/* Note: addSetting and getSetting are no longer used by SWFUpload but are included
	the maintain v2 API compatibility
*/
// Public: (Deprecated) addSetting adds a setting value. If the value given is undefined or null then the default_value is used.
SWFUpload.prototype.addSetting = function (name, value, default_value) {
    if (value == undefined) {
        return (this.settings[name] = default_value);
    } else {
        return (this.settings[name] = value);
	}
};

// Public: (Deprecated) getSetting gets a setting. Returns an empty string if the setting was not found.
SWFUpload.prototype.getSetting = function (name) {
    if (this.settings[name] != undefined) {
        return this.settings[name];
	}

    return "";
};



// Private: callFlash handles function calls made to the Flash element.
// Calls are made with a setTimeout for some functions to work around
// bugs in the ExternalInterface library.
SWFUpload.prototype.callFlash = function (functionName, argumentArray) {
	argumentArray = argumentArray || [];
	
	var movieElement = this.getMovieElement();
	var returnValue, returnString;

	// Flash's method if calling ExternalInterface methods (code adapted from MooTools).
	try {
		returnString = movieElement.CallFunction('<invoke name="' + functionName + '" returntype="javascript">' + __flash__argumentsToXML(argumentArray, 0) + '</invoke>');
		returnValue = eval(returnString);
	} catch (ex) {
		throw "Call to " + functionName + " failed";
	}
	
	// Unescape file post param values
	if (returnValue != undefined && typeof returnValue.post === "object") {
		returnValue = this.unescapeFilePostParams(returnValue);
	}

	return returnValue;
};

/* *****************************
	-- Flash control methods --
	Your UI should use these
	to operate SWFUpload
   ***************************** */

// WARNING: this function does not work in Flash Player 10
// Public: selectFile causes a File Selection Dialog window to appear.  This
// dialog only allows 1 file to be selected.
SWFUpload.prototype.selectFile = function () {
	this.callFlash("SelectFile");
};

// WARNING: this function does not work in Flash Player 10
// Public: selectFiles causes a File Selection Dialog window to appear/ This
// dialog allows the user to select any number of files
// Flash Bug Warning: Flash limits the number of selectable files based on the combined length of the file names.
// If the selection name length is too long the dialog will fail in an unpredictable manner.  There is no work-around
// for this bug.
SWFUpload.prototype.selectFiles = function () {
	this.callFlash("SelectFiles");
};


// Public: startUpload starts uploading the first file in the queue unless
// the optional parameter 'fileID' specifies the ID 
SWFUpload.prototype.startUpload = function (fileID) {
	this.callFlash("StartUpload", [fileID]);
};

// Public: cancelUpload cancels any queued file.  The fileID parameter may be the file ID or index.
// If you do not specify a fileID the current uploading file or first file in the queue is cancelled.
// If you do not want the uploadError event to trigger you can specify false for the triggerErrorEvent parameter.
SWFUpload.prototype.cancelUpload = function (fileID, triggerErrorEvent) {
	if (triggerErrorEvent !== false) {
		triggerErrorEvent = true;
	}
	this.callFlash("CancelUpload", [fileID, triggerErrorEvent]);
};

// Public: stopUpload stops the current upload and requeues the file at the beginning of the queue.
// If nothing is currently uploading then nothing happens.
SWFUpload.prototype.stopUpload = function () {
	this.callFlash("StopUpload");
};

/* ************************
 * Settings methods
 *   These methods change the SWFUpload settings.
 *   SWFUpload settings should not be changed directly on the settings object
 *   since many of the settings need to be passed to Flash in order to take
 *   effect.
 * *********************** */

// Public: getStats gets the file statistics object.
SWFUpload.prototype.getStats = function () {
	return this.callFlash("GetStats");
};

// Public: setStats changes the SWFUpload statistics.  You shouldn't need to 
// change the statistics but you can.  Changing the statistics does not
// affect SWFUpload accept for the successful_uploads count which is used
// by the upload_limit setting to determine how many files the user may upload.
SWFUpload.prototype.setStats = function (statsObject) {
	this.callFlash("SetStats", [statsObject]);
};

// Public: getFile retrieves a File object by ID or Index.  If the file is
// not found then 'null' is returned.
SWFUpload.prototype.getFile = function (fileID) {
	if (typeof(fileID) === "number") {
		return this.callFlash("GetFileByIndex", [fileID]);
	} else {
		return this.callFlash("GetFile", [fileID]);
	}
};

// Public: addFileParam sets a name/value pair that will be posted with the
// file specified by the Files ID.  If the name already exists then the
// exiting value will be overwritten.
SWFUpload.prototype.addFileParam = function (fileID, name, value) {
	return this.callFlash("AddFileParam", [fileID, name, value]);
};

// Public: removeFileParam removes a previously set (by addFileParam) name/value
// pair from the specified file.
SWFUpload.prototype.removeFileParam = function (fileID, name) {
	this.callFlash("RemoveFileParam", [fileID, name]);
};

// Public: setUploadUrl changes the upload_url setting.
SWFUpload.prototype.setUploadURL = function (url) {
	this.settings.upload_url = url.toString();
	this.callFlash("SetUploadURL", [url]);
};

// Public: setPostParams changes the post_params setting
SWFUpload.prototype.setPostParams = function (paramsObject) {
	this.settings.post_params = paramsObject;
	this.callFlash("SetPostParams", [paramsObject]);
};

// Public: addPostParam adds post name/value pair.  Each name can have only one value.
SWFUpload.prototype.addPostParam = function (name, value) {
	this.settings.post_params[name] = value;
	this.callFlash("SetPostParams", [this.settings.post_params]);
};

// Public: removePostParam deletes post name/value pair.
SWFUpload.prototype.removePostParam = function (name) {
	delete this.settings.post_params[name];
	this.callFlash("SetPostParams", [this.settings.post_params]);
};

// Public: setFileTypes changes the file_types setting and the file_types_description setting
SWFUpload.prototype.setFileTypes = function (types, description) {
	this.settings.file_types = types;
	this.settings.file_types_description = description;
	this.callFlash("SetFileTypes", [types, description]);
};

// Public: setFileSizeLimit changes the file_size_limit setting
SWFUpload.prototype.setFileSizeLimit = function (fileSizeLimit) {
	this.settings.file_size_limit = fileSizeLimit;
	this.callFlash("SetFileSizeLimit", [fileSizeLimit]);
};

// Public: setFileUploadLimit changes the file_upload_limit setting
SWFUpload.prototype.setFileUploadLimit = function (fileUploadLimit) {
	this.settings.file_upload_limit = fileUploadLimit;
	this.callFlash("SetFileUploadLimit", [fileUploadLimit]);
};

// Public: setFileQueueLimit changes the file_queue_limit setting
SWFUpload.prototype.setFileQueueLimit = function (fileQueueLimit) {
	this.settings.file_queue_limit = fileQueueLimit;
	this.callFlash("SetFileQueueLimit", [fileQueueLimit]);
};

// Public: setFilePostName changes the file_post_name setting
SWFUpload.prototype.setFilePostName = function (filePostName) {
	this.settings.file_post_name = filePostName;
	this.callFlash("SetFilePostName", [filePostName]);
};

// Public: setUseQueryString changes the use_query_string setting
SWFUpload.prototype.setUseQueryString = function (useQueryString) {
	this.settings.use_query_string = useQueryString;
	this.callFlash("SetUseQueryString", [useQueryString]);
};

// Public: setRequeueOnError changes the requeue_on_error setting
SWFUpload.prototype.setRequeueOnError = function (requeueOnError) {
	this.settings.requeue_on_error = requeueOnError;
	this.callFlash("SetRequeueOnError", [requeueOnError]);
};

// Public: setHTTPSuccess changes the http_success setting
SWFUpload.prototype.setHTTPSuccess = function (http_status_codes) {
	if (typeof http_status_codes === "string") {
		http_status_codes = http_status_codes.replace(" ", "").split(",");
	}
	
	this.settings.http_success = http_status_codes;
	this.callFlash("SetHTTPSuccess", [http_status_codes]);
};

// Public: setHTTPSuccess changes the http_success setting
SWFUpload.prototype.setAssumeSuccessTimeout = function (timeout_seconds) {
	this.settings.assume_success_timeout = timeout_seconds;
	this.callFlash("SetAssumeSuccessTimeout", [timeout_seconds]);
};

// Public: setDebugEnabled changes the debug_enabled setting
SWFUpload.prototype.setDebugEnabled = function (debugEnabled) {
	this.settings.debug_enabled = debugEnabled;
	this.callFlash("SetDebugEnabled", [debugEnabled]);
};

// Public: setButtonImageURL loads a button image sprite
SWFUpload.prototype.setButtonImageURL = function (buttonImageURL) {
	if (buttonImageURL == undefined) {
		buttonImageURL = "";
	}
	
	this.settings.button_image_url = buttonImageURL;
	this.callFlash("SetButtonImageURL", [buttonImageURL]);
};

// Public: setButtonDimensions resizes the Flash Movie and button
SWFUpload.prototype.setButtonDimensions = function (width, height) {
	this.settings.button_width = width;
	this.settings.button_height = height;
	
	var movie = this.getMovieElement();
	if (movie != undefined) {
		movie.style.width = width + "px";
		movie.style.height = height + "px";
	}
	
	this.callFlash("SetButtonDimensions", [width, height]);
};
// Public: setButtonText Changes the text overlaid on the button
SWFUpload.prototype.setButtonText = function (html) {
	this.settings.button_text = html;
	this.callFlash("SetButtonText", [html]);
};
// Public: setButtonTextPadding changes the top and left padding of the text overlay
SWFUpload.prototype.setButtonTextPadding = function (left, top) {
	this.settings.button_text_top_padding = top;
	this.settings.button_text_left_padding = left;
	this.callFlash("SetButtonTextPadding", [left, top]);
};

// Public: setButtonTextStyle changes the CSS used to style the HTML/Text overlaid on the button
SWFUpload.prototype.setButtonTextStyle = function (css) {
	this.settings.button_text_style = css;
	this.callFlash("SetButtonTextStyle", [css]);
};
// Public: setButtonDisabled disables/enables the button
SWFUpload.prototype.setButtonDisabled = function (isDisabled) {
	this.settings.button_disabled = isDisabled;
	this.callFlash("SetButtonDisabled", [isDisabled]);
};
// Public: setButtonAction sets the action that occurs when the button is clicked
SWFUpload.prototype.setButtonAction = function (buttonAction) {
	this.settings.button_action = buttonAction;
	this.callFlash("SetButtonAction", [buttonAction]);
};

// Public: setButtonCursor changes the mouse cursor displayed when hovering over the button
SWFUpload.prototype.setButtonCursor = function (cursor) {
	this.settings.button_cursor = cursor;
	this.callFlash("SetButtonCursor", [cursor]);
};

/* *******************************
	Flash Event Interfaces
	These functions are used by Flash to trigger the various
	events.
	
	All these functions a Private.
	
	Because the ExternalInterface library is buggy the event calls
	are added to a queue and the queue then executed by a setTimeout.
	This ensures that events are executed in a determinate order and that
	the ExternalInterface bugs are avoided.
******************************* */

SWFUpload.prototype.queueEvent = function (handlerName, argumentArray) {
	// Warning: Don't call this.debug inside here or you'll create an infinite loop
	
	if (argumentArray == undefined) {
		argumentArray = [];
	} else if (!(argumentArray instanceof Array)) {
		argumentArray = [argumentArray];
	}
	
	var self = this;
	if (typeof this.settings[handlerName] === "function") {
		// Queue the event
		this.eventQueue.push(function () {
			this.settings[handlerName].apply(this, argumentArray);
		});
		
		// Execute the next queued event
		setTimeout(function () {
			self.executeNextEvent();
		}, 0);
		
	} else if (this.settings[handlerName] !== null) {
		throw "Event handler " + handlerName + " is unknown or is not a function";
	}
};

// Private: Causes the next event in the queue to be executed.  Since events are queued using a setTimeout
// we must queue them in order to garentee that they are executed in order.
SWFUpload.prototype.executeNextEvent = function () {
	// Warning: Don't call this.debug inside here or you'll create an infinite loop

	var  f = this.eventQueue ? this.eventQueue.shift() : null;
	if (typeof(f) === "function") {
		f.apply(this);
	}
};

// Private: unescapeFileParams is part of a workaround for a flash bug where objects passed through ExternalInterface cannot have
// properties that contain characters that are not valid for JavaScript identifiers. To work around this
// the Flash Component escapes the parameter names and we must unescape again before passing them along.
SWFUpload.prototype.unescapeFilePostParams = function (file) {
	var reg = /[$]([0-9a-f]{4})/i;
	var unescapedPost = {};
	var uk;

	if (file != undefined) {
		for (var k in file.post) {
			if (file.post.hasOwnProperty(k)) {
				uk = k;
				var match;
				while ((match = reg.exec(uk)) !== null) {
					uk = uk.replace(match[0], String.fromCharCode(parseInt("0x" + match[1], 16)));
				}
				unescapedPost[uk] = file.post[k];
			}
		}

		file.post = unescapedPost;
	}

	return file;
};

// Private: Called by Flash to see if JS can call in to Flash (test if External Interface is working)
SWFUpload.prototype.testExternalInterface = function () {
	try {
		return this.callFlash("TestExternalInterface");
	} catch (ex) {
		return false;
	}
};

// Private: This event is called by Flash when it has finished loading. Don't modify this.
// Use the swfupload_loaded_handler event setting to execute custom code when SWFUpload has loaded.
SWFUpload.prototype.flashReady = function () {
	// Check that the movie element is loaded correctly with its ExternalInterface methods defined
	var movieElement = this.getMovieElement();

	if (!movieElement) {
		this.debug("Flash called back ready but the flash movie can't be found.");
		return;
	}

	this.cleanUp(movieElement);
	
	this.queueEvent("swfupload_loaded_handler");
};

// Private: removes Flash added fuctions to the DOM node to prevent memory leaks in IE.
// This function is called by Flash each time the ExternalInterface functions are created.
SWFUpload.prototype.cleanUp = function (movieElement) {
	// Pro-actively unhook all the Flash functions
	try {
		if (movieElement && typeof(movieElement.CallFunction) === "unknown") { // We only want to do this in IE
			this.debug("Removing Flash functions hooks (this should only run in IE and should prevent memory leaks)");
			for (var key in movieElement) {
				try {
					if (typeof(movieElement[key]) === "function") {
						movieElement[key] = null;
					}
				} catch (ex) {
				}
			}
		}
	} catch (ex1) {
	
	}

	// Fix Flashes own cleanup code so if the SWFMovie was removed from the page
	// it doesn't display errors.
	window["__flash__removeCallback"] = function (instance, name) {
		try {
			if (instance) {
				instance[name] = null;
			}
		} catch (flashEx) {
		
		}
	};

};


/* This is a chance to do something before the browse window opens */
SWFUpload.prototype.fileDialogStart = function () {
	this.queueEvent("file_dialog_start_handler");
};


/* Called when a file is successfully added to the queue. */
SWFUpload.prototype.fileQueued = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("file_queued_handler", file);
};


/* Handle errors that occur when an attempt to queue a file fails. */
SWFUpload.prototype.fileQueueError = function (file, errorCode, message) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("file_queue_error_handler", [file, errorCode, message]);
};

/* Called after the file dialog has closed and the selected files have been queued.
	You could call startUpload here if you want the queued files to begin uploading immediately. */
SWFUpload.prototype.fileDialogComplete = function (numFilesSelected, numFilesQueued, numFilesInQueue) {
	this.queueEvent("file_dialog_complete_handler", [numFilesSelected, numFilesQueued, numFilesInQueue]);
};

SWFUpload.prototype.uploadStart = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("return_upload_start_handler", file);
};

SWFUpload.prototype.returnUploadStart = function (file) {
	var returnValue;
	if (typeof this.settings.upload_start_handler === "function") {
		file = this.unescapeFilePostParams(file);
		returnValue = this.settings.upload_start_handler.call(this, file);
	} else if (this.settings.upload_start_handler != undefined) {
		throw "upload_start_handler must be a function";
	}

	// Convert undefined to true so if nothing is returned from the upload_start_handler it is
	// interpretted as 'true'.
	if (returnValue === undefined) {
		returnValue = true;
	}
	
	returnValue = !!returnValue;
	
	this.callFlash("ReturnUploadStart", [returnValue]);
};



SWFUpload.prototype.uploadProgress = function (file, bytesComplete, bytesTotal) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_progress_handler", [file, bytesComplete, bytesTotal]);
};

SWFUpload.prototype.uploadError = function (file, errorCode, message) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_error_handler", [file, errorCode, message]);
};

SWFUpload.prototype.uploadSuccess = function (file, serverData, responseReceived) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_success_handler", [file, serverData, responseReceived]);
};

SWFUpload.prototype.uploadComplete = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_complete_handler", file);
};

/* Called by SWFUpload JavaScript and Flash functions when debug is enabled. By default it writes messages to the
   internal debug console.  You can override this event and have messages written where you want. */
SWFUpload.prototype.debug = function (message) {
	this.queueEvent("debug_handler", message);
};


/* **********************************
	Debug Console
	The debug console is a self contained, in page location
	for debug message to be sent.  The Debug Console adds
	itself to the body if necessary.

	The console is automatically scrolled as messages appear.
	
	If you are using your own debug handler or when you deploy to production and
	have debug disabled you can remove these functions to reduce the file size
	and complexity.
********************************** */
   
// Private: debugMessage is the default debug_handler.  If you want to print debug messages
// call the debug() function.  When overriding the function your own function should
// check to see if the debug setting is true before outputting debug information.
SWFUpload.prototype.debugMessage = function (message) {
	if (this.settings.debug) {
		var exceptionMessage, exceptionValues = [];

		// Check for an exception object and print it nicely
		if (typeof message === "object" && typeof message.name === "string" && typeof message.message === "string") {
			for (var key in message) {
				if (message.hasOwnProperty(key)) {
					exceptionValues.push(key + ": " + message[key]);
				}
			}
			exceptionMessage = exceptionValues.join("\n") || "";
			exceptionValues = exceptionMessage.split("\n");
			exceptionMessage = "EXCEPTION: " + exceptionValues.join("\nEXCEPTION: ");
			SWFUpload.Console.writeLine(exceptionMessage);
		} else {
			SWFUpload.Console.writeLine(message);
		}
	}
};

SWFUpload.Console = {};
SWFUpload.Console.writeLine = function (message) {
	var console, documentForm;

	try {
		console = document.getElementById("SWFUpload_Console");

		if (!console) {
			documentForm = document.createElement("form");
			document.getElementsByTagName("body")[0].appendChild(documentForm);

			console = document.createElement("textarea");
			console.id = "SWFUpload_Console";
			console.style.fontFamily = "monospace";
			console.setAttribute("wrap", "off");
			console.wrap = "off";
			console.style.overflow = "auto";
			console.style.width = "700px";
			console.style.height = "350px";
			console.style.margin = "5px";
			documentForm.appendChild(console);
		}

		console.value += message + "\n";

		console.scrollTop = console.scrollHeight - console.clientHeight;
	} catch (ex) {
		alert("Exception: " + ex.name + " Message: " + ex.message);
	}
};
var singleTestMode = false;
var swfFiles = []; // {name:"ccc", size:0099} 정보가 들어감
function cancelQueue(instance) {
	/* no action*/
};
function fileDialogStart() {
	/* no action*/
};
function fileQueued(file) {
	swfFiles[swfFiles.length] = {name: file.name, size: file.size};
	
	if (singleTestMode){
		alert("fileQueued: " + file.name);
		return;
	}

	var wControl = getControlById(this.linkName);
    if (this.multiFileGu){
        if (wControl.textFound(file.name)){
      	    wControl.updateItem(file.name, file.name);
    	} else {
      	    wControl.addItem(file.name, file.name);
    	}
    } else {
    	wControl.setValue(jUploadPrefix + file.name);
    }
	
    return;
};
function fileQueueError(file, errorCode, message) {
	try {
		if (errorCode === SWFUpload.QUEUE_ERROR.QUEUE_LIMIT_EXCEEDED) {
			alert("You have attempted to queue too many files.\n" + (message === 0 ? "You have reached the upload limit." : "You may select " + (message > 1 ? "up to " + message + " files." : "one file.")));
			return;
		}

		switch (errorCode) {
		case SWFUpload.QUEUE_ERROR.FILE_EXCEEDS_SIZE_LIMIT:
			alert("File is too big.");
			break;
		case SWFUpload.QUEUE_ERROR.ZERO_BYTE_FILE:
			alert("Cannot upload Zero Byte files.");
			break;
		case SWFUpload.QUEUE_ERROR.INVALID_FILETYPE:
			alert("Invalid File Type.");
			break;
		case SWFUpload.QUEUE_ERROR.QUEUE_LIMIT_EXCEEDED:
			alert("You have selected too many files.  " +  (message > 1 ? "You may only add " +  message + " more files" : "You cannot add any more files."));
			break;
		default:
			if (file !== null) { alert("Unhandled Error"); }
			break;
		}
	} catch (ex) { alert(ex); }
};

function getTimeFlag(){
	var now = new Date();
	var milliseconds = "" + now.getMilliseconds();
	if (milliseconds.length == 1){
		milliseconds= ["00", milliseconds].join("");
	} else if (milliseconds.length == 2){
		milliseconds= ["0", milliseconds].join("");
	} 
	return "_V" + DateString(now) + TimeString(now) + milliseconds
};


function fileDialogComplete(numFilesSelected, numFilesQueued) {
	try {
        var uploadSuffix = (USE_FILE_SUFFIX != undefined && USE_FILE_SUFFIX ? getTimeFlag() : "");
        		
        var func = self.parent[this.controlId + "_onselectcompleted"];
        if (typeof func != "undefined"){
        	var arrFileNames = []; var arrUploadFileNames = []; var arrFileSizes = []; var arrSvrFileNames = [];
        	
    		for (var i=0; i < swfFiles.length; i++){
    			var fileName = swfFiles[i].name;
    			
    			arrFileNames[i]       = fileName;
    			arrUploadFileNames[i] = jUploadPrefix + fileName;
    			arrFileSizes[i]       = swfFiles[i].size;
    			
    			if (USE_FILE_SUFFIX != undefined && USE_FILE_SUFFIX){
    				var dotIndex = fileName.lastIndexOf(".");
    				if (dotIndex < 0){
    					arrSvrFileNames[i] = fileName + uploadSuffix ;
    				} else {
    					arrSvrFileNames[i] = fileName.substring(0, dotIndex) + uploadSuffix + fileName.substring(dotIndex);
    				}
    			} else {
    				arrSvrFileNames[i] = jUploadPrefix + fileName;
    			}
   		    }
	        if (!func(arrFileNames, arrUploadFileNames, arrSvrFileNames, arrFileSizes, this.ftpDir)) {
	        	var uploadSWF = getControlById(this.controlId).uploadSWF;
	    		for (var i=swfFiles.length-1; i >= 0; i--){
	    			removeFile_SWF(uploadSWF, swfFiles[i].name);
	    			swfFiles.pop();
	    		}
	        	return false;
	        }
        }
		
		if (this.directUploadGu){
		    this.startUpload();
		}
	} catch (ex)  { alert(ex); }
};
function uploadStart(file) {
	showAjaxBox(file.name + " 파일을 업로드 중 입니다.");
	return true;
};
function uploadProgress(file, bytesLoaded, bytesTotal) {
};
function uploadSuccess(file, serverData) {
	if (singleTestMode){
		alert("uploadSuccess: " + file.name);
		return;
	}
	
    if (!this.multiFileGu){
    	if (this.pictureControlName != "") 
//    		controls[this.pictureControlName].setPicture("/FlexFrame/pages/groupware/download/" + this.ftpDir + "/" + jUploadPrefix + file.name); // ????
    		controls[this.pictureControlName].setPicture("/FlexFrame/download/" + this.ftpDir + "/" + jUploadPrefix + file.name); // ????
	    var checkEvent = false;
	   	try {
	       	if (eval(this.controlId + "_onuploadcompletedSWF")) checkEvent = true;
	    } catch(e){};
	   
	    if (checkEvent){
	      eval(this.controlId + "_onuploadcompletedSWF();");
	    };


    }
};
function uploadComplete(file) {
	try {
		/*  I want the next upload to continue automatically so I'll call startUpload here */
		if (this.getStats().files_queued != 0) {
			this.startUpload();
		}
		hideAjaxBox();
	} catch (ex) { }
};
function uploadError(file, errorCode, message) {
	
	try {
		hideAjaxBox();
		switch (errorCode) {
		case SWFUpload.UPLOAD_ERROR.HTTP_ERROR:
			alert("Upload Error: " + message + "\r\nError Code: HTTP Error, File name: " + file.name + ", Message: " + message);
			break;
		case SWFUpload.UPLOAD_ERROR.MISSING_UPLOAD_URL:
			alert("Configuration Error" + "\r\nError Code: No backend file, File name: " + file.name + ", Message: " + message);
			break;
		case SWFUpload.UPLOAD_ERROR.UPLOAD_FAILED:
			alert("Upload Failed." + "\r\nError Code: Upload Failed, File name: " + file.name + ", File size: " + file.size + ", Message: " + message);
			break;
		case SWFUpload.UPLOAD_ERROR.IO_ERROR:
			alert("Server (IO) Error" + "\r\nError Code: IO Error, File name: " + file.name + ", Message: " + message);
			break;
		case SWFUpload.UPLOAD_ERROR.SECURITY_ERROR:
			alert("Security Error" + "\r\nError Code: Security Error, File name: " + file.name + ", Message: " + message);
			break;
		case SWFUpload.UPLOAD_ERROR.UPLOAD_LIMIT_EXCEEDED:
			alert("Upload limit exceeded." + "\r\nError Code: Upload Limit Exceeded, File name: " + file.name + ", File size: " + file.size + ", Message: " + message);
			break;
		case SWFUpload.UPLOAD_ERROR.SPECIFIED_FILE_ID_NOT_FOUND:
			alert("File not found." + "\r\nError Code: The file was not found, File name: " + file.name + ", File size: " + file.size + ", Message: " + message);
			break;
		case SWFUpload.UPLOAD_ERROR.FILE_VALIDATION_FAILED:
			alert("Failed Validation.  Upload skipped." + "\r\nError Code: File Validation Failed, File name: " + file.name + ", File size: " + file.size + ", Message: " + message);
			break;
		case SWFUpload.UPLOAD_ERROR.FILE_CANCELLED:
			//alert("Cancelled");
			break;
		case SWFUpload.UPLOAD_ERROR.UPLOAD_STOPPED:
			alert("Stopped");
			break;
		default:
			alert("Unhandled Error \r\nError Code: " + errorCode + ", File name: " + file.name + ", File size: " + file.size + ", Message: " + message);
			break;
		}
	} catch (ex) {
        alert(ex);
    }
};

function getSWFUploadObject(parentNode, name, linkname, picname, ftpDir, noftp, nozip, directUploadGu, buttonControl, multiFileGu) {
	this.noftp = (noftp == undefined ? false : noftp);
	this.nozip = (nozip == undefined ? false : nozip);
	if (ftpDir.charAt(0) == "/") ftpDir = ftpDir.substring(1);
	
    // 사이즈확인
    var positionObject = getBoundsObject(buttonControl);
    var buttonTop = positionObject.top + "px";
    var buttonLeft = positionObject.left + "px";
    var buttonWidth = positionObject.width ;
    var buttonHeight = positionObject.height ;

    // zindex 주기
    var zi=0;
    for(var i=0; i< buttonControl.childNodes.length; i++) {
   	 if(buttonControl.childNodes[i].nodeType == 1) {  // 1: ELEMENT_NODE
	    	 var obj = buttonControl.childNodes[i];
	
	    	 var comp = obj.currentStyle ? obj.currentStyle : getComputedStyle(obj, null);
	         ziparsed = parseInt(comp.zIndex);
	         var ziparsed = isNaN(ziparsed) ? 0 : ziparsed;
	         zi = (zi < ziparsed + 1 ? ziparsed + 1 : zi);
   	 }
   }

	var doc = buttonControl.ownerDocument;
	
	var container = doc.createElement("div");

    //container.style.zIndex = zi;
    container.style.position = 'absolute';
    container.style.overflow = 'hidden';
    container.style.padding = 0;
    container.style.margin = 0;
    container.style.visiblity = 'hidden';
    container.style.top = '0px';
    container.style.left = '0px';
    container.style.width = buttonWidth + 'px';
    container.style.height = buttonHeight + 'px';

    buttonControl.appendChild(container);

    container.innerHTML = "<SPAN name='" + name + "' id='" + name + "' src='about:blank'></SPAN>";


    // SWF객체생성
    var settings_object = {
    		// Backend Settings
    		upload_url: "",
    		post_params: {},

    		// File Upload Settings
    		file_post_name  : "upload",
    		file_size_limit : "102400",	// 100MB
    		file_types : "*.*",
    		file_types_description : "All Files",
    		file_upload_limit : "1000",
    		file_queue_limit : "0",

    		// Event Handler Settings (all my handlers are in the Handler.js file)
    		file_dialog_start_handler : fileDialogStart,
    		file_queued_handler : fileQueued,
    		file_queue_error_handler : fileQueueError,
    		file_dialog_complete_handler : fileDialogComplete,
    		upload_start_handler : uploadStart,
    		upload_progress_handler : uploadProgress,
    		upload_error_handler : uploadError,
    		upload_success_handler : uploadSuccess,
    		upload_complete_handler : uploadComplete,

    		// Button Settings
    		button_image_url : "",
    		button_placeholder_id : "",
    		button_width: 0,
    		button_height: 0,
    		button_window_mode: SWFUpload.WINDOW_MODE.TRANSPARENT,
    		button_cursor: SWFUpload.CURSOR.HAND,
    		
    		// Flash Settings
    		flash_url : "/FlexFrame/winnersoft/_ScriptLibrary/swfupload/swfupload.swf",
    		

    		custom_settings : {},

    		wmode          : "transparent",
    		
    		// Debug Settings
    		debug: false
    };
    
    settings_object.upload_url 					= "/FlexFrame/fileUpload.do";
    //settings_object.upload_url 					= "fileUpload.action";
    settings_object.button_placeholder_id 		= name;

    settings_object.post_params.id 				= name;
    settings_object.post_params.uploadSubDir 	= ftpDir;
    settings_object.post_params.uploadPrefix 	= jUploadPrefix;
    settings_object.post_params.noftp 			= noftp;
    settings_object.post_params.nozip 			= nozip;

    settings_object.button_width 		        = buttonWidth;
    settings_object.button_height 		        = buttonHeight;
    if (!multiFileGu)
        settings_object.file_queue_limit            = "1";
    
    // 부가적인 정보메모
    var swfUpload = new SWFUpload(settings_object);
    swfUpload.linkName = linkname;
    swfUpload.multiFileGu = multiFileGu;
    swfUpload.directUploadGu = directUploadGu;
    swfUpload.pictureControlName = picname;
    swfUpload.ftpDir = ftpDir;
    swfUpload.controlId = buttonControl.id;
    
    // 이벤트용 메모리 초기화
    
	for (var i=swfFiles.length-1; i >= 0; i--){
		delete swfFiles[i].name;
		delete swfFiles[i].size
		swfFiles.pop();
	}

    return swfUpload;
};

function uploadFile_SWF(swfUpload){
	try {
		if(!swfUpload.directUploadGu) swfUpload.startUpload();
	} catch (ex)  { alert(ex); }
};
function removeFile_SWF(swfUpload, fileName){
	try {
		if(!swfUpload.directUploadGu) {
			var fileId = "";
			for (var i=0; i < 10000; i++){
			//for (var i=0; i< swfUpload.getStats().files_queued; i++){
				var file = swfUpload.getFile(i);
				if (file == null) break;
				
				if (file.name == fileName) {
					fileId = file.id;
					break;
				}
			}
			if (fileId.length != 0)
				swfUpload.cancelUpload(fileId);
		}
	} catch (ex)  { alert(ex); }
};
function setEnable_SWF(swfUpload, enbled){ // true or false
	try {
		var container = swfUpload.getMovieElement().parentNode;
		if (enbled){
		    container.style.width = swfUpload.settings.button_width + 'px';
		    container.style.height = swfUpload.settings.button_height + 'px';
		} else {
		    container.style.width = '0px';
		    container.style.height = '0px';
		}
	} catch (ex)  { alert(ex); }
};
/**
 *   @autor   winnersoft korea
 *   @version 5.0
 *   @see     winnersoft.co.kr
 *   
 * @description 
 *     EasyMaker Vertical Data Sheet For Big Data.
 * 
 * @constructor
 * 
 * @param {string} 	 controlId 	 - 콘트롤 고유 아이디 (영문)
 * @param {string} 	 controlName - 콘트롤 명 (사용자 고유 언어)
 * @param {HTMLNode} tagObject   - HTML 본문중의 매칭되는 HTML DOM Node. 
 * @return {Object} - 생성된 EasySheet 개체
 * @exception 널값 예외
 * 
 * @example 
 * var sheet = new EasySheet("Sheet_1", "sheet_1", document.getElementsByName("XX")[0]);
 */

var EasyMath = EasyMath || {};
    EasyMath.DBCS = EasyMath.DBCS || {};

    // 상대 좌표를 계산할떄 임시로 사용할 기준 칼럼의 좌표
    EasyMath.crit = {"rowNum": 0, "colNum": 0};

// BigNumber 연산을 위한 설정, BigNumber 로딩중 상황에 대비 하여 작업대기열로 이동
    /**
     * @description 미결
     * @return		{undefined}
     * @example		미결
     */
    function configBigNumber(){
    setTimeout(function(){
    	if (typeof BigNumber != "undefined"){
    		BigNumber.config({
    			DECIMAL_PLACES: 20,
    			ROUNDING_MODE: 4,
    			EXPONENTIAL_AT: 1E9,
    			RANGE: 1E9,
    			ERRORS: false,
    			CRYPTO: false,
    			POW_PRECISION: 100,
    			MODULO_MODE: 1
    		});
    	} else {
    		configBigNumber();
    	}
    }, 0);
};
configBigNumber();


/*******************************************************************************
 * 시트 함수의 동작에관한 부분이다
 ******************************************************************************/

function FormulaInfo(RC, formula, func){
	this.RC = RC;
	this.formula = formula;
	this.func = func;
	this.RCs =[];			// 이 산식에 영향을 주는 R C좌표들 ... 
	this.references =[];	// 이 산식에 영향을 주는 행열번호 좌표들 ... 
};

    
// 산식정보에 추가하기
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	rowNum
	*     @param		{number}	colNum
	*     @param		{string}	formula
	*     @return		{boolean}
	*     @example		미결
	*/
EasySheet.prototype._addToFormulaRefs = function(rowNum, colNum, formula) {
	// functionname : [EasySheet._addToFormulaRefs]

	var RC = this._parseRangeToRC(rowNum, colNum);
	
	// 따옴표 문자열 제거후 CELL 함수만 집중 수색
	// Cell은 모두 대문자로 바뀐다, "CELL (" -> "CELL("
	formula = formula.replace(/CELL/ig, "CELL")
	                 .replace(/CELL[ ]+[(]/ig, "CELL(")
	                 .replace(/CELL[(]\"(.+?)\"[)]/ig, "CELL($1)");
	
	var func = new Function("return function (sheet, rowNum, colNum) { return " + this._updateFormula(formula) + "; }")();
	
	var formulaInfo = new FormulaInfo(RC, formula, func);
	
	
	// RC 타입을 인수로 갖는 함수 
	var arrRegStr = [
	                 "COUNTIF\\s*[(](.*?),(.*?),(.+?)[)]",
	                 "COUNTBLANK\\s*[(](.*?),(.+?)[)]",
	                 "COUNTA\\s*[(](.*?),(.+?)[)]",
	                 "CELL[(].+?[)]"
	                 ];
	
	var strCatchReg = "R(\\[*\\-*\\d*\\]*)?C(\\[*\\-*\\d*\\]*)?:R(\\[*\\-*\\d*\\]*)?C(\\[*\\-*\\d*\\]*)?" + "|"
				    + "R\\[*\\-*\\d+\\]*:R\\[*\\-*\\d+\\]*" + "|"
				    + "C\\[*\\-*\\d+\\]*:C\\[*\\-*\\d+\\]*" + "|"
				    + "R(\\[*\\-*\\d*\\]*)?C(\\[*\\-*\\d*\\]*)?" + "|"
				    + "R\\[*\\-*\\d+\\]*" + "|"
				    + "C\\[*\\-*\\d+\\]*" ;	
	var regexCatch = new RegExp(strCatchReg, "ig");	
	
	// "R1:RC1" 와 같은 겅은  "R1", "RC1" 로 분해된다  논리적으로 맞지 않다. 
	var strVerifyReg = "^R(\\[*\\-*\\d*\\]*)?C(\\[*\\-*\\d*\\]*)?:R(\\[*\\-*\\d*\\]*)?$" + "|"
				     + "^R(\\[*\\-*\\d*\\]*)?C(\\[*\\-*\\d*\\]*)?:C(\\[*\\-*\\d*\\]*)?$" + "|"
				     + "^R(\\[*\\-*\\d*\\]*)?:R(\\[*\\-*\\d*\\]*)?C(\\[*\\-*\\d*\\]*)?$" + "|"
				     + "^C(\\[*\\-*\\d*\\]*)?:R(\\[*\\-*\\d*\\]*)?C(\\[*\\-*\\d*\\]*)?$" + "|"
				     + "^R(\\[*\\-*\\d*\\]*)?C(\\[*\\-*\\d*\\]*)?$" + "|"
				     + "^C(\\[*\\-*\\d*\\]*)?:R(\\[*\\-*\\d*\\]*)?$" ;
	
	var regexVerify = new RegExp(strVerifyReg, "ig");	
	
	var arr = [];
	for (var i = 0; i < arrRegStr.length; i++){
		var regex = new RegExp(arrRegStr[i], "ig");
		var arrFunctionTarget = formula.match(regex);
		
		if (arrFunctionTarget == null) continue;
		
		for (var j = 0; j < arrFunctionTarget.length; j++){
			var str = arrFunctionTarget[j];
			
			var arrRC = str.match(regexCatch);
			if (arrRC == null) continue;
			
			for (var k = 0; k < arrRC.length; k++){
				var strRC = arrRC[k];
				if (strRC.indexOf(":") > 0 && null != strRC.match(regexVerify)) continue;  // 검증조건에 걸리면 
				
				arr.push(strRC);
			}
		}
	}
	

	if (arr.length == 0) {
		this._formulaRefs[RC] = formulaInfo;
		return true;
	}
	
	
	var tmpStr = ";";
	for (var i = 0; i < arr.length; i++) {
		// 안에 좌표만 뽑는다
//		var cellString = arr[i].substring(5, arr[i].length - 1).trim().replace(/\"/g, "");
		var cellString = arr[i];

		var arrCellRanges = cellString.split(",");
		for (var j = 0; j < arrCellRanges.length; j++) {
			var cellRange = arrCellRanges[j].trim();
			var arrRange = this._parseRCToRange(cellRange, rowNum, colNum);
			
			if (arrRange === null) continue;
			var str_ = arrRange.join(":");
			if (tmpStr.indexOf(escapeRegExp(";" + str_ + ";")) >= 0){
				continue;
			}  
			tmpStr += str_ + ";";

			
			if (arrRange[0] < 0 || arrRange[1] < 0 || arrRange[2] < 0 || arrRange[3] < 0){
				var msg = getText("message_easymath_001", "{0}번줄 {1}번 칼럼에 '{2}' 주소를 참조할 수 없습니다.", [rowNum, colNum, cellRange]);
				alert(msg);
				return false;
			}
			if (arrRange[0] - this.startRowColNum >= this.maxRows || 
					arrRange[1] - this.startRowColNum >= this.maxCols || 
					arrRange[2] - this.startRowColNum >= this.maxRows || 
					arrRange[3] - this.startRowColNum >= this.maxCols){
				var msg = getText("message_easymath_001", "{0}번줄 {1}번 칼럼에 '{2}' 주소를 참조할 수 없습니다.", [rowNum, colNum, cellRange]);
				alert(msg);
				return false;
			}
			
			formulaInfo.references.push({
				rowNumFrom : arrRange[0],
				colNumFrom : arrRange[1],
				rowNumTo   : arrRange[2],
				colNumTo   : arrRange[3],
			});
			
			
		}
	}
	
	
	this._formulaRefs[RC] = formulaInfo;
	return true;
};

// 산식정보에서 삭제하기 colNum이 생략되면 줄단위로 지운다 
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	rowNumFrom
	*     @param		{number}	colNumFrom
	*     @param		{number}	rowNumTo
	*     @param		{number}	colNumTo
	*     @return		{void}
	*     @example		미결
	*/
EasySheet.prototype._removeFromFormulaRefs = function(rowNumFrom, colNumFrom, rowNumTo, colNumTo) {
	// functionname : [EasySheet._addToFormulaRefs]

	if (JSON.stringify(this._formulaRefs) === "{}") return;
	
	// 줄번호만 있으면 한줄 통채로 지운다 
	if (typeof colNumFrom != "undefined"){ 
		colNumFrom = 0; 
		colNumTo = this.maxCols - 1 + this.startRowColNum;
	} else if (typeof rowNumTo != "undefined")  { 
		rowNumTo = rowNumFrom; 
	} else if (typeof colNumTo != "undefined")  { 
		colNumTo = colNumFrom; 
	} 
	
	for (var RC in this._formulaRefs){
		var arrRange = this._parseRCToRange(RC, this.startRowColNum, this.startRowColNum);
		if (arrRange === null) continue;

		rowNum = arrRange[0];
		colNum = arrRange[1];
		if (rowNum >= rowNumFrom && rowNum <= rowNumTo  && colNum >= colNumFrom && colNum <= colNumTo){
			delete this._formulaRefs[RC];
		}
	}
	
	return;
	
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	rowNum
	*     @param		{number}	colNum
	*     @return		{boolean}
	*     @example		미결
	*/
EasySheet.prototype._removeFormula = function(rowNum, colNum) {
	// functionname : [EasySheet._addToFormulaRefs]

	// 한셀만 삭제 하는 경우 후속작업에 성공여부가 필요하다 
	var RC = this._parseRangeToRC(rowNum, colNum);
	
	if (RC in this._formulaRefs){
		delete this._formulaRefs[RC];
	} else {
		return false;
	}
	
	return true;
};

// 줄추가시 관련 산식 수정, rowNum 뒤로 줄이 추가된다.
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	rowNum
	*     @return		{void}
	*     @example		미결
	*/
EasySheet.prototype._updateFormulaWhenRowInsertAfter = function(rowNum) {
	var insertedRowNum = rowNum + 1;
	
	var updateFormula = function(sheet, formula, RCs, references, critRowNum, critColNum, insertedRowNum){
		if (formula.indexOf("#REF") >= 0) return formula;
		
		var newRCs = [];
		
		for (var i = 0; i < RCs.length; i++){
			var refRc = RCs[i];
			formula = formula.replace(new RegExp(escapeRegExp(refRc), "i"), ("STR_" + i));
		}
		for (var i = 0; i < references.length; i++){
			var refRc = RCs[i]; 
			
			var reference = references[i];
			
			if (insertedRowNum > reference.rowNumTo) {
				newRCs.push(refRc);
				
			} else if (insertedRowNum > reference.rowNumFrom && insertedRowNum <= reference.rowNumTo) {
				// 뒤엣 것만 갱신한다 
				var arr = refRc.split(":");
				arr[1] = sheet._AddRowToRC(arr[1], 1);
				
				var newRC = arr[1] !== "#REF" ? arr.join(":") : "#REF";
				newRCs.push(newRC);
				
			} else if (insertedRowNum <= reference.rowNumFrom) {
				// 둘 다 갱신한다 
				if (refRc.indexOf(":") < 0) {
					var newRC = sheet._AddRowToRC(refRc, 1);
					newRCs.push(newRC);
					
				} else {
					var arr = refRc.split(":");
					arr[0] = sheet._AddRowToRC(arr[0], 1);
					arr[1] = sheet._AddRowToRC(arr[1], 1);
					
					var newRC = arr[0] !== "#REF" && arr[1] !== "#REF" ? arr.join(":") : "#REF";
					newRCs.push(newRC);
				}
			}
			
		}
		for (var i = newRCs.length - 1; i >= 0; i--){
			formula = formula.replace(new RegExp("STR_" + i, "i"), newRCs[i]);
		}
		
		return formula;
	};
	
	for (var rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
	    var rowNum  = rowNum0 + this.startRowColNum;
		var row = this.rows(rowNum0);
		
		if (typeof row == "undefined") continue;
		
		// 줄단위 산식이 있는 경우
		if (typeof row.formula != "undefined" && row.formula.length != 0) {
			var formula = row.formula;
			var RCs = this._extractRCsFromFormula(formula);
			var references = this._extractReferencesFromFormula(RCs, rowNum, 0);
			if (references === null){
				continue; // 오류메시지는 _extractReferencesFromFormula 함수에서 이미 했다.
			}
			
			row.formula = updateFormula(this, formula, RCs, references, rowNum, colNum, insertedRowNum);
		}

		for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++) {
		    var colNum  = colNum0 + this.startRowColNum;
			var colId = this.columns[colNum0].colId;

			// 셀단위 산식이 있는 경우
			var cell = row.cells[colId];
			if (typeof cell == "undefined") continue;
			if (typeof cell.formula == "undefined") continue;

			var formula = cell.formula;
			var RCs = this._extractRCsFromFormula(formula);
			var references = this._extractReferencesFromFormula(RCs, rowNum, colNum);
			if (references === null){
				continue; // 오류메시지는 _extractReferencesFromFormula 함수에서 이미 했다.
			}
			
			cell.formula = updateFormula(this, formula, RCs, references, rowNum, colNum, insertedRowNum);
		}
	}

	return;
	
};

//줄삭제시 관련 산식 수정
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	rowNum
	*     @return		{void}
	*     @example		미결
	*/
EasySheet.prototype._updateFormulaWhenRowDeleteAt = function(rowNum) {
	
	var deletedRowNum = rowNum;
	
	var updateFormula = function(sheet, formula, RCs, references, critRowNum, critColNum, deletedRowNum){
		if (formula.indexOf("#REF") >= 0) return formula;
		
		var newRCs = [];
		
		for (var i = 0; i < RCs.length; i++){
			var refRc = RCs[i];
			formula = formula.replace(new RegExp(escapeRegExp(refRc), "i"), ("STR_" + i));
		}
		for (var i = 0; i < references.length; i++){
			var refRc = RCs[i]; 
			
			var reference = references[i];
			var arr = refRc.split(":");
			
			if (deletedRowNum == reference.rowNumTo && deletedRowNum == reference.rowNumFrom) {
				// 삭제된줄 한줄만 표시하면 "#REF"
				newRCs.push("#REF");
				
			} if (deletedRowNum > reference.rowNumTo) {
				// 범위 종료줄이 삭제된 줄보다 작으면 변경없다. 
				newRCs.push(refRc);
				
			} else {
				if (deletedRowNum < reference.rowNumFrom) {
					// 범위 시작줄이 작제된 줄 보다 큰 경우 하나씩 당긴다.
					// 삭제된줄 범위 시작이면 하나 내린후 다시 하나 당겨지므로 그대로 
					arr[0] = sheet._AddRowToRC(arr[0], -1);
				}
                if (deletedRowNum <= reference.rowNumTo) {
                	// 삭제된줄이 중간에 걸치건 뒤이면 끌줄번호 하나 당김
                	// 삭제된줄 범위 끝이면 끌줄번호 하나 당김
					if (arr.length > 1) {
						arr[1] = sheet._AddRowToRC(arr[1], -1);
					} 
				}
                
				var newRC = arr[0] !== "#REF" && arr[1] !== "#REF" ? arr.join(":") : "#REF";
				newRCs.push(newRC);
			}
			
		}
		for (var i = newRCs.length - 1; i >= 0; i--){
			formula = formula.replace(new RegExp("STR_" + i, "i"), newRCs[i]);
		}
		
		return formula;
	};
	
	for (var rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
	    var rowNum  = rowNum0 + this.startRowColNum;
		var row = this.rows(rowNum0);
		
		if (typeof row == "undefined") continue;
		
		// 줄단위 산식이 있는 경우
		if (typeof row.formula != "undefined" && row.formula.length != 0) {
			var formula = row.formula;
			var RCs = this._extractRCsFromFormula(formula);
			var references = this._extractReferencesFromFormula(RCs, rowNum, 0);
			if (references === null){
				continue; // 오류메시지는 _extractReferencesFromFormula 함수에서 이미 했다.
			}
			
			row.formula = updateFormula(this, formula, RCs, references, rowNum, colNum, deletedRowNum);
		}

		for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++) {
		    var colNum  = colNum0 + this.startRowColNum;
			var colId = this.columns[colNum0].colId;

			// 셀단위 산식이 있는 경우
			var cell = row.cells[colId];
			if (typeof cell == "undefined") continue;
			if (typeof cell.formula == "undefined") continue;

			var formula = cell.formula;
			var RCs = this._extractRCsFromFormula(formula);
			var references = this._extractReferencesFromFormula(RCs, rowNum, colNum);
			if (references === null){
				continue; // 오류메시지는 _extractReferencesFromFormula 함수에서 이미 했다.
			}
			
			cell.formula = updateFormula(this, formula, RCs, references, rowNum, colNum, deletedRowNum);
		}
	}

	return;
};

//줄업다운시 관련 산식 수정
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	rowNumFrom
	*     @param		{number}	rowNumTo
	*     @return		{void}
	*     @example		미결
	*/
EasySheet.prototype._updateFormulaWhenRowMove = function(rowNumFrom, rowNumTo) {
	
	var deletedRowNum = rowNum;
	
	var updateFormula = function(sheet, formula, RCs, references, critRowNum, critColNum, deletedRowNum){
		if (formula.indexOf("#REF") >= 0) return formula;
		
		var newRCs = [];
		
		for (var i = 0; i < RCs.length; i++){
			var refRc = RCs[i];
			formula = formula.replace(new RegExp(escapeRegExp(refRc), "i"), ("STR_" + i));
		}
		for (var i = 0; i < references.length; i++){
			var refRc = RCs[i]; 
			
			var reference = references[i];
			var arr = refRc.split(":");
			
			// 연달아 아래위로 붙어 있는 범위일 경우 산식은 변하지 않으면 된다
			if (rowNumFrom === reference.rowNumFrom && rowNumTo === reference.rowNumTo) {
				newRCs.push(refRc);
				continue;
			}
			
			if (rowNumFrom == reference.rowNumFrom) {
				arr[0] = sheet._AddRowToRC(arr[0], rowNumTo - rowNumFrom);
			}
			if (rowNumTo == reference.rowNumFrom) {
				arr[0] = sheet._AddRowToRC(arr[0], rowNumFrom - rowNumTo);
			}			
			
			if (arr.length > 1) {
				if (rowNumFrom == reference.rowNumTo) {
					arr[1] = sheet._AddRowToRC(arr[1], rowNumTo - rowNumFrom);
				}
				if (rowNumTo == reference.rowNumTo) {
					arr[1] = sheet._AddRowToRC(arr[1], rowNumFrom - rowNumTo);
				}			
			}
			
			var newRC = arr.join(":");
			newRCs.push(newRC);
			
		}
		for (var i = newRCs.length - 1; i >= 0; i--){
			formula = formula.replace(new RegExp("STR_" + i, "i"), newRCs[i]);
		}
		
		return formula;
	};
	
	for (var rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
	    var rowNum  = rowNum0 + this.startRowColNum;
		var row = this.rows(rowNum0);
		
		if (typeof row == "undefined") continue;
		
		// 줄단위 산식이 있는 경우
		if (typeof row.formula != "undefined" && row.formula.length != 0) {
			var formula = row.formula;
			var RCs = this._extractRCsFromFormula(formula);
			var references = this._extractReferencesFromFormula(RCs, rowNum, 0);
			if (references === null){
				continue; // 오류메시지는 _extractReferencesFromFormula 함수에서 이미 했다.
			}
			
			row.formula = updateFormula(this, formula, RCs, references, rowNum, colNum, deletedRowNum);
		}

		for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++) {
		    var colNum  = colNum0 + this.startRowColNum;
			var colId = this.columns[colNum0].colId;

			// 셀단위 산식이 있는 경우
			var cell = row.cells[colId];
			if (typeof cell == "undefined") continue;
			if (typeof cell.formula == "undefined") continue;

			var formula = cell.formula;
			var RCs = this._extractRCsFromFormula(formula);
			var references = this._extractReferencesFromFormula(RCs, rowNum, colNum);
			if (references === null){
				continue; // 오류메시지는 _extractReferencesFromFormula 함수에서 이미 했다.
			}
			
			cell.formula = updateFormula(this, formula, RCs, references, rowNum, colNum, deletedRowNum);
		}
	}

	return;	
	
};

//열추가시 관련 산식 수정
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	colNum
	*     @return		{void}
	*     @example		미결
	*/
EasySheet.prototype._updateFormulaWhenColInsertAfter = function(colNum) {
	var insertedColNum = colNum + 1;
	
	var updateFormula = function(sheet, formula, RCs, references, critRowNum, critColNum, insertedColNum){
		if (formula.indexOf("#REF") >= 0) return formula;
		
		var newRCs = [];
		
		for (var i = 0; i < RCs.length; i++){
			var refRc = RCs[i];
			formula = formula.replace(new RegExp(escapeRegExp(refRc), "i"), ("STR_" + i));
		}
		for (var i = 0; i < references.length; i++){
			var refRc = RCs[i]; 
			
			var reference = references[i];
			
			if (insertedColNum > reference.colNumTo) {
				newRCs.push(refRc);
				
			} else if (insertedColNum > reference.colNumFrom && insertedColNum <= reference.colNumTo) {
				// 뒤엣 것만 갱신한다 
				var arr = refRc.split(":");
				arr[1] = sheet._AddColToRC(arr[1], 1);
				
				var newRC = arr[1] !== "#REF" ? arr.join(":") : "#REF";
				newRCs.push(newRC);
				
			} else if (insertedColNum <= reference.colNumFrom) {
				// 둘 다 갱신한다 
				if (refRc.indexOf(":") < 0) {
					var newRC = sheet._AddColToRC(refRc, 1);
					newRCs.push(newRC);
					
				} else {
					var arr = refRc.split(":");
					arr[0] = sheet._AddColToRC(arr[0], 1);
					arr[1] = sheet._AddColToRC(arr[1], 1);
					
					var newRC = arr[0] !== "#REF" && arr[1] !== "#REF" ? arr.join(":") : "#REF";
					newRCs.push(newRC);
				}
			}
			
		}
		for (var i = newRCs.length - 1; i >= 0; i--){
			formula = formula.replace(new RegExp("STR_" + i, "i"), newRCs[i]);
		}
		
		return formula;
	};
	
	for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++) {
	    var colNum  = colNum0 + this.startRowColNum;
		var column = this.columns[colNum0];
		
		if (typeof column == "undefined") continue;
		
		// 줄단위 산식이 있는 경우
		if (typeof column.formula != "undefined" && column.formula.length != 0) {
			var formula = column.formula;
			var RCs = this._extractRCsFromFormula(formula);
			var references = this._extractReferencesFromFormula(RCs,0,  colNum);
			if (references === null){
				continue; // 오류메시지는 _extractReferencesFromFormula 함수에서 이미 했다.
			}
			
			column.formula = updateFormula(this, formula, RCs, references, rowNum, colNum, insertedColNum);
		}

		for (var rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
		    var rowNum  = rowNum0 + this.startRowColNum;
		    
			// 셀단위 산식이 있는 경우
			var formula = this.getCellAttribute(rowNum, column.colId, "formula");
			if (typeof formula === "undefined" || formula.length === 0) continue; 

			var RCs = this._extractRCsFromFormula(formula);
			var references = this._extractReferencesFromFormula(RCs, rowNum, colNum);
			if (references === null){
				continue; // 오류메시지는 _extractReferencesFromFormula 함수에서 이미 했다.
			}
			
			formula = updateFormula(this, formula, RCs, references, rowNum, colNum, insertedColNum);
			this.setCellAttribute(rowNum, column.colId, "formula", formula)
		}
	}

	return;
	

};

//열삭제시 관련 산식 수정
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	colNum
	*     @return		{void}
	*     @example		미결
	*/
EasySheet.prototype._updateFormulaWhenColDeleteAt = function(colNum) {
	var deletedColNum = colNum;
	
	var updateFormula = function(sheet, formula, RCs, references, critRowNum, critColNum, deletedColNum){
		if (formula.indexOf("#REF") >= 0) return formula;
		
		var newRCs = [];
		
		for (var i = 0; i < RCs.length; i++){
			var refRc = RCs[i];
			formula = formula.replace(new RegExp(escapeRegExp(refRc), "i"), ("STR_" + i));
		}
		for (var i = 0; i < references.length; i++){
			var refRc = RCs[i]; 
			
			var reference = references[i];
			var arr = refRc.split(":");
			
			if (deletedColNum == reference.colNumTo && deletedColNum == reference.colNumFrom) {
				// 삭제된줄 한줄만 표시하면 "#REF"
				newRCs.push("#REF");
				
			} if (deletedColNum > reference.colNumTo) {
				// 범위 종료줄이 삭제된 줄보다 작으면 변경없다. 
				newRCs.push(refRc);
				
			} else {
				if (deletedColNum < reference.colNumFrom) {
					// 범위 시작줄이 작제된 줄 보다 큰 경우 하나씩 당긴다.
					// 삭제된줄 범위 시작이면 하나 내린후 다시 하나 당겨지므로 그대로 
					arr[0] = sheet._AddColToRC(arr[0], -1);
				}
                if (deletedColNum <= reference.colNumTo) {
                	// 삭제된줄이 중간에 걸치건 뒤이면 끌줄번호 하나 당김
                	// 삭제된줄 범위 끝이면 끌줄번호 하나 당김
					if (arr.length > 1) {
						arr[1] = sheet._AddColToRC(arr[1], -1);
					} 
				}
                
				var newRC = arr[0] !== "#REF" && arr[1] !== "#REF" ? arr.join(":") : "#REF";
				newRCs.push(newRC);
			}
			
		}
		for (var i = newRCs.length - 1; i >= 0; i--){
			formula = formula.replace(new RegExp("STR_" + i, "i"), newRCs[i]);
		}
		
		return formula;
	};
	
	for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++) {
	    var colNum  = colNum0 + this.startRowColNum;
		var column = this.columns[colNum0];
		
		if (typeof column == "undefined") continue;
		
		// 줄단위 산식이 있는 경우
		if (typeof column.formula != "undefined" && column.formula.length != 0) {
			var formula = column.formula;
			var RCs = this._extractRCsFromFormula(formula);
			var references = this._extractReferencesFromFormula(RCs, 0, colNum);
			if (references === null){
				continue; // 오류메시지는 _extractReferencesFromFormula 함수에서 이미 했다.
			}
			
			column.formula = updateFormula(this, formula, RCs, references, rowNum, colNum, deletedColNum);
		}

		for (var rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
		    var rowNum  = rowNum0 + this.startRowColNum;
		    
			// 셀단위 산식이 있는 경우
			var formula = this.getCellAttribute(rowNum, column.colId, "formula");
			if (typeof formula === "undefined" || formula.length === 0) continue; 
			
			var RCs = this._extractRCsFromFormula(formula);
			var references = this._extractReferencesFromFormula(RCs, rowNum, colNum);
			if (references === null){
				continue; // 오류메시지는 _extractReferencesFromFormula 함수에서 이미 했다.
			}
			
			formula = updateFormula(this, formula, RCs, references, rowNum, colNum, deletedColNum);
			this.setCellAttribute(rowNum, column.colId, "formula", formula)
		}
	}

	return;

};

//줄업다운시 관련 산식 수정 
// arrChangedInfo = [{rowNumFrom: n, rowNumTo: n}, ... ]
if (typeof EasySheet == "function")
EasySheet.prototype._updateFormulaCollectively = function(arrChangedInfo) {
	
	var updateFormula = function(sheet, formula, RCs, references){
		if (formula.indexOf("#REF") >= 0) return formula;
		
		var newRCs = [];
		
		for (var i = 0; i < RCs.length; i++){
			var refRc = RCs[i];
			formula = formula.replace(new RegExp(escapeRegExp(refRc), "i"), ("STR_" + i));
		}
		for (var i = 0; i < references.length; i++){
			var refRc = RCs[i]; 
			
			var reference = references[i];
			var arr = refRc.split(":");
			
			for (var j = 0; j < arrChangedInfo.length;j++){
				var changedInfo = arrChangedInfo[j];
				var rowNumFrom = changedInfo.rowNumFrom;
				var rowNumTo = changedInfo.rowNumTo;
				
				// 연달아 아래위로 붙어 있는 범위일 경우 산식은 변하지 않으면 된다
				if (rowNumFrom === reference.rowNumFrom && rowNumTo === reference.rowNumTo) {
					newRCs.push(refRc);
					continue;
				}
				
				var needChange = rowNumFrom == reference.rowNumFrom ||
				                 rowNumTo == reference.rowNumFrom || 
				                 (arr.length > 1 && (rowNumFrom == reference.rowNumTo || 
				                		             rowNumTo == reference.rowNumTo))
				 
				if (!needChange) continue;
				
				if (rowNumFrom == reference.rowNumFrom) {
					arr[0] = sheet._AddRowToRC(arr[0], rowNumTo - rowNumFrom);
				}
				if (rowNumTo == reference.rowNumFrom) {
					arr[0] = sheet._AddRowToRC(arr[0], rowNumFrom - rowNumTo);
				}			
				
				if (arr.length > 1) {
					if (rowNumFrom == reference.rowNumTo) {
						arr[1] = sheet._AddRowToRC(arr[1], rowNumTo - rowNumFrom);
					}
					if (rowNumTo == reference.rowNumTo) {
						arr[1] = sheet._AddRowToRC(arr[1], rowNumFrom - rowNumTo);
					}			
				}
				
				// 바뀐게 또 바뀌면 안된다 
				break;
			}
			
			var newRC = arr.join(":");
			newRCs.push(newRC);
			
		}
		for (var i = newRCs.length - 1; i >= 0; i--){
			formula = formula.replace(new RegExp("STR_" + i, "i"), newRCs[i]);
		}
		
		return formula;
	};
	
	for (var rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
	    var rowNum  = rowNum0 + this.startRowColNum;
		var row = this.rows(rowNum0);
		
		if (typeof row == "undefined") continue;
		
		// 줄단위 산식이 있는 경우
		if (typeof row.formula != "undefined" && row.formula.length != 0) {
			var formula = row.formula;
			var RCs = this._extractRCsFromFormula(formula);
			var references = this._extractReferencesFromFormula(RCs, rowNum, 0);
			if (references === null){
				continue; // 오류메시지는 _extractReferencesFromFormula 함수에서 이미 했다.
			}
			
			row.formula = updateFormula(this, formula, RCs, references);
		}

		for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++) {
		    var colNum  = colNum0 + this.startRowColNum;
			var colId = this.columns[colNum0].colId;

			// 셀단위 산식이 있는 경우
			var cell = row.cells[colId];
			if (typeof cell == "undefined") continue;
			if (typeof cell.formula == "undefined") continue;

			var formula = cell.formula;
			var RCs = this._extractRCsFromFormula(formula);
			var references = this._extractReferencesFromFormula(RCs, rowNum, colNum);
			if (references === null){
				continue; // 오류메시지는 _extractReferencesFromFormula 함수에서 이미 했다.
			}
			
			cell.formula = updateFormula(this, formula, RCs, references);
		}
	}

	return;	
	
};

//산식에서 RC범위추출 
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{string}	formula
	*     @return		{string}
	*     @example		미결
	*/
EasySheet.prototype._extractRCsFromFormula = function(formula) {
	
	var RCs = [];
	var arr = formula.match(/CELL[(].+?[)]/ig);
	if (arr == null) return RCs;

	for (var i = 0; i < arr.length; i++) {
		// 안에 좌표만 뽑는다
		var cellString = arr[i].substring(5, arr[i].length - 1).trim().replace(/\"/g, "");

		var arrCellRanges = cellString.split(",");
		for (var j = 0; j < arrCellRanges.length; j++) {
			RCs.push(arrCellRanges[j].trim());
		}
	}
	
	return RCs;
};

//산식에서 범위추출 
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{string}	RCs
	*     @param		{number}	rowNum
	*     @param		{number}	colNum
	*     @return		{string}
	*     @example		미결
	*/
EasySheet.prototype._extractReferencesFromFormula = function(RCs, rowNum, colNum) {
	
	var references = [];
	
	for (var i = 0; i < RCs.length; i++) {
		var arrRange = this._parseRCToRange(RCs[i], rowNum, colNum);
		
		if (arrRange === null) continue;
		
		if (arrRange[0] < 0 || arrRange[1] < 0 || arrRange[2] < 0 || arrRange[3] < 0){
			var msg = getText("message_easymath_001", "{0}번줄 {1}번 칼럼에 '{2}' 주소를 참조할 수 없습니다.", [rowNum, colNum, RCs[i]]);
			alert(msg);
			return null;
		}
		if (arrRange[0] - this.startRowColNum >= this.maxRows || 
				arrRange[1] - this.startRowColNum >= this.maxCols || 
				arrRange[2] - this.startRowColNum >= this.maxRows || 
				arrRange[3] - this.startRowColNum >= this.maxCols){
			var msg = getText("message_easymath_001", "{0}번줄 {1}번 칼럼에 '{2}' 주소를 참조할 수 없습니다.", [rowNum, colNum, RCs[i]]);
			alert(msg);
			return null;
		}
		
		references.push({
			rowNumFrom : arrRange[0],
			colNumFrom : arrRange[1],
			rowNumTo   : arrRange[2],
			colNumTo   : arrRange[3],
		});
	}
	
	return references;
};

// ":" 없는 순수 RC만 받는다. 
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{string}	RC
	*     @param		{number}	rowCount
	*     @return		{string}
	*     @example		미결
	*/
EasySheet.prototype._AddRowToRC = function(RC, rowCount) { // "-" 는 감소 "+" 는 증가 
	var underOne = false;
	
	// "R[1]C".match( "R\\[([0-9]*)\\]C([0-9]*)")   // 0:"R[1]C", 1:"1", 2:""
	// "R[1]C[2]".match( "R\\[([0-9]*)\\]C(.*)$")   // 0:"R[1]C", 1:"1", 2:"[2]"
	var arr = RC.match( "R\\[([0-9]*)\\]C(.*)$");
	if (arr != null && RC == arr[0]){
		var rowNum = parseInt(arr[1]) + rowCount;
		return "R[" + rowNum + "]C" + arr[2];
	}
	
	// "R1C".match( "R([0-9]*)C(.*)")   // 0:"R1C", 1:"1", 2:""
	// "R1C2".match("R([0-9]*)C(.*)")   // 0:"R1C2", 1:"1", 2:"2"
	// "R1C[2]".match("R([0-9]*)C(.*)") // 0:"R1C[2]", 1:"1", 2:"[2]"
	arr = RC.match( "R([0-9]*)C(.*)$");
	if (arr != null && RC == arr[0]){
		var rowNum = parseInt(arr[1]) + rowCount;
		if (rowNum < 1){
			underOne = true;
		} else {
			return "R" + rowNum + "C" + arr[2];
		}
	}
	
	// "R[1]".match("R\\[([0-9]*)\\]$")     // 0:"R[1]",  1:"1"
	arr = RC.match( "R\\[([0-9]*)\\]$");
	if (arr != null && RC == arr[0]){
		var rowNum = parseInt(arr[1]) + rowCount;
		return "R[" + rowNum + "]";
	}
	
	
	// "R1".match("R([0-9]*)$")          // 0:"R1",    1:"1"
	arr = RC.match( "R([0-9]*)$");
	if (arr != null && RC == arr[0]){
		var rowNum = parseInt(arr[1]) + rowCount;
		
		if (rowNum < 1){
			underOne = true;
		} else {
			return "R" + rowNum;
		}
	}
	
	if (underOne){
		var msg = getText("message_EasySheet_054", 
			              "1 이하의 RC 주소를 설정할 수 없습니다.\n" + 
                          "sheet.{0}({1}, {2})", ["_AddRowToRC", RC, rowCount]);
		alert(msg); 
		console.warn(msg);
		
	} else {
		var msg = getText("message_EasySheet_055", 
				          "RC 주소를 설정할 수 없습니다.\n" + 
                          "sheet.{0}({1}, {2})", ["_AddRowToRC", RC, rowCount]);
		alert(msg); 
		console.warn(msg);
	}
	
	return "#REF";
};

//":" 없는 순수 RC만 받는다. 
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{string}	RC
	*     @param		{number}	colCount
	*     @return		{string}
	*     @example		미결
	*/
EasySheet.prototype._AddColToRC = function(RC, colCount) { // "-" 는 감소 "+" 는 증가 

	var underOne = false;
	
	// "RC[1]".match(    "R(.*)C\\[([0-9]*)\\]$")   // 0:"RC[1]", 1:"", 2:"1"
	// "R[1]C[2]".match( "R(.*)C\\[([0-9]*)\\]$")   // 0:"R[1]C", 1:"[1]", 2:"2"
	var arr = RC.match( "R(.*)C\\[([0-9]*)\\]$");
	if (arr != null && RC == arr[0]){
		var colNum = parseInt(arr[2]) + colCount;
		return "R" + arr[1] + "C[" + colNum + "]";
	}
	
	// "RC1".match( "R(.*)C([0-9]*)")   // 0:"R1C", 1:"",       2:"1"
	// "R1C2".match("R(.*)C([0-9]*)")   // 0:"R1C2", 1:"1",     2:"2"
	// "R[1]C2".match("R(.*)C([0-9]*)") // 0:"R[1]C2", 1:"[1]", 2:"2"
	arr = RC.match( "R(.*)C([0-9]*)");
	if (arr != null && RC == arr[0]){
		var colNum = parseInt(arr[2]) + colCount;
		if (colNum < 1){
			underOne = true;
		} else {
			return "R" + arr[1] + "C" + colNum;
		}
	}
	
	// "R[1]".match("C\\[([0-9]*)\\]$")     // 0:"C[1]",  1:"1"
	arr = RC.match( "C\\[([0-9]*)\\]$");
	if (arr != null && RC == arr[0]){
		var colNum = parseInt(arr[1]) + colCount;
		return "C[" + colNum + "]";
	}
	
	
	// "R1".match("C([0-9]*)$")          // 0:"C1",    1:"1"
	arr = RC.match( "C([0-9]*)$");
	if (arr != null && RC == arr[0]){
		var colNum = parseInt(arr[1]) + colCount;
		if (colNum < 1){
			underOne = true;
		} else {
			return "C" + colNum;
		}
	}
	
	if (underOne){
		var msg = getText("message_EasySheet_054", 
			              "1 이하의 RC 주소를 설정할 수 없습니다.\n" + 
                          "sheet.{0}({1}, {2})", ["_AddColToRC", RC, colCount]);
		alert(msg); 
		console.warn(msg);
		
	} else {
		var msg = getText("message_EasySheet_055", 
				          "RC 주소를 설정할 수 없습니다.\n" + 
                          "sheet.{0}({1}, {2})", ["_AddColToRC", RC, colCount]);
		alert(msg); 
		console.warn(msg);
	}

	return "#REF";
};



/*--------------------------------------------------------------------------
 RC스타일의 문법 (기본 R1C1:R2C3 상대좌표 R[1]C[1]:R[3]C[4] <-커런트 셀기준
 단일셀은 :이 없다 (R1C1  R[1]C[2])
 줄선택은 R1:R2와 같다 열선택은 C1:C2와 같이 표현한다
 인수중에 배열은 [Row, Col, Row2, Col2] 이다 결과를 리턴한다
 ----------------------------------------------------------------------------*/
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{string}	RC
	*     @param		{number}	currentRow
	*     @param		{number}	currentCol
	*     @return		{string}
	*     @example		미결
	*/
EasySheet.prototype._parseRCToRange = function(RC, currentRow, currentCol) {

	if (RC.indexOf("#REF") >= 0) return null;
	
	// 1. 콜론으로 범위값을 분리한다 없으면시작셀갑과 같은 값을 준다
	var arrRange = [ 0, 0, 0, 0 ];
	var arrRanges = RC.split(":");
	if (arrRanges.length == 1)
		arrRanges[1] = arrRanges[0];

	// 2. 시작셀을 파싱한다
	// 열번호가 없으면 전체열 선택이다 줄번호가 없으면 전체줄 선택이다 ???
	var range = arrRanges[0];
	if (range.indexOf("R") < 0) {
		range = "R1" + range;
	}
	if (range.indexOf("C") < 0) {
		range += "C1";
	}
	var rowString = range.split("C")[0].substring(1);
	var colString = range.split("C")[1];

	if (rowString.charAt(0) == "[") {
		arrRange[0] = parseInt(rowString.substring(1, rowString.length - 1), 10) + currentRow;
	} else if (rowString === "") {
		arrRange[0] = currentRow;
	} else {
		var rowNum1 = parseInt(rowString, 10);
		var rowNum = rowNum1 - 1 + this.startRowColNum;
		arrRange[0] = rowNum;
	}
	
	if (colString.charAt(0) == "[") {
		arrRange[1] = parseInt(colString.substring(1, colString.length - 1), 10) + currentCol;
	} else if (colString === "") {
		arrRange[1] = currentCol;
	} else {
		var colNum1 = parseInt(colString, 10);
	    var colNum = colNum1 - 1 + this.startRowColNum;
		arrRange[1] = colNum;
	}

	// 3. 종료셀을 파싱한다
	range = arrRanges[1];
	if (range.indexOf("R") < 0) {
		range = "R" + this.maxRows + range;
	}
	if (range.indexOf("C") < 0) {
		range += "C" + this.maxCols;
	}
	rowString = range.split("C")[0].substring(1);
	colString = range.split("C")[1];

	if (rowString.charAt(0) == "[") {
		arrRange[2] = parseInt(rowString.substring(1, rowString.length - 1), 10) + currentRow;
	} else if (rowString == "") {
		arrRange[2] = currentRow;
	} else {
		var rowNum1 = parseInt(rowString, 10);
		var rowNum = rowNum1 - 1 + this.startRowColNum;
		arrRange[2] = rowNum;
	}
	if (colString.charAt(0) == "[") {
		arrRange[3] = parseInt(colString.substring(1, colString.length - 1), 10) + currentCol;
	} else if (colString === "") {
		arrRange[3] = currentCol;
	} else {
		var colNum1 = parseInt(colString, 10);
	    var colNum = colNum1 - 1 + this.startRowColNum;
		arrRange[3] = colNum;
	}

	return arrRange;
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	rowNumFrom
	*     @param		{number}	colNumFrom
	*     @param		{number}	rowNumTo
	*     @param		{number}	colNumTo
	*     @return		{string}
	*     @example		미결
	*/
EasySheet.prototype._parseRangeToRC = function(rowNumFrom, colNumFrom, rowNumTo, colNumTo) {

	rowNumTo = rowNumTo || rowNumFrom;
	colNumTo = colNumTo || colNumFrom;
	
    var rowNumFrom1 = rowNumFrom - this.startRowColNum + 1;
    var colNumFrom1 = colNumFrom - this.startRowColNum + 1;
    var rowNumTo1 = rowNumTo - this.startRowColNum + 1;
    var colNumTo1 = colNumTo - this.startRowColNum + 1;
	
	var rtn = "R" + rowNumFrom1 + "C" + colNumFrom1;
	if (rowNumFrom != rowNumTo || colNumFrom != colNumTo) {
		rtn += ":R" + rowNumTo1 + "C" + colNumTo1;
	}
	return rtn;
};

// 전체산식을 리프레시한다 pRecaleGu를 주면 다시계산까지 수행한다
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @return		{void}
	*     @example		미결
	*/
EasySheet.prototype.refreshFormulaRefs = function() {
	// functionname : [EasySheet.refreshFormulaRefs]
	var isEmpty_formulaRefs = true;
	for (var RC in this._formulaRefs) {
		isEmpty_formulaRefs = false;
	}
	if (isEmpty_formulaRefs) return;

	for (var RC in this._formulaRefs) {
		this._formulaRefs[RC].references.clear();
		delete this._formulaRefs[RC];
	}
	
	for (var rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
	    var rowNum  = rowNum0 + this.startRowColNum;
		var row = this.rows(rowNum0);
		
		// 산식을 취합한다 한셀에 대하여 겹치는 경우 우선 순위는 줄단위 산식 < 열단위 산식 < 셀단위 산식
		for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++) {
		    var colNum  = colNum0 + this.startRowColNum;
			var colId = this.columns[colNum0].colId;
			// 줄단위 산식이 있는 경우
			if (typeof row != "undefined" && typeof row.formula != "undefined") {
				this._addToFormulaRefs(rowNum, colNum, row.formula);
			}

			// 열단위 산식이 있는 경우
			var columnFormula = this.columns[colNum0].formula;
			if (typeof columnFormula != "undefined"
					&& columnFormula.trim().length > 0) {
				this._addToFormulaRefs(rowNum, colNum, columnFormula);
			}

			// 셀단위 산식이 있는 경우
			if (typeof row != "undefined")
				continue;

			var cell = row.cells[colId];
			if (typeof cell == "undefined")
				continue;
			if (typeof cell.formula == "undefined")
				continue;

			this._addToFormulaRefs(rowNum, colNum, cell.formula);
		}
	}

	// 전체계산을 다시 수행한다.
	this.recalculate();

	return;
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @return		{void}
	*     @example		미결
	*/
EasySheet.prototype.recalculate = function() {
	// functionname : [EasySheet.recalculate]

	// 순환참조면 하위 루틴에서 메시지를 주었으므로 여기서는 스킵만 하면 된다.
	if (!this._checkLoopingRef())
		return;

	var autoCalcurate = this.autoCalc;
	this.autoCalc = true;

	for (var i = 0; i < this._calcOrders.length; i++) {
		var RC = this._calcOrders[i];
		this._calculateRC(RC);
	}
	this.autoCalc = autoCalcurate;
	return;
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @return		{string}
	*     @example		미결
	*/
EasySheet.prototype._checkLoopingRef = function() {
	// functionname : [EasySheet._checkLoopingRef]

	var calcOrders = this._calcOrders;
	calcOrders.clear();

	var isNormal = true;
	for (var RC in this._formulaRefs) {
		var RCs = [ RC ];

		if (RC in this._formulaRefs){
			isNormal = this._checkLinkedRefs(RC, RCs, calcOrders);
			if (calcOrders.indexOf(RC) < 0) {
				calcOrders.push(RC);
			}
		}
		RCs.clear();
		
	}

	return isNormal;
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	RC
	*     @param		{string}	RCs
	*     @param		{object}	calcOrders
	*     @return		{string}
	*     @example		미결
	*/
EasySheet.prototype._checkLinkedRefs = function(RC, RCs, calcOrders) {

	if (RC.indexOf("#REF") >= 0) return true;
	
	var isNormal = true;

	var formulaInfo = this._formulaRefs[RC];
	
	var references = formulaInfo.references;
	for (var j = 0; j < references.length; j++) {
		var reference = references[j];
		
		for (var rowNum = reference.rowNumFrom; rowNum <= reference.rowNumTo && isNormal; rowNum++) {
			var rowNum1 = rowNum - this.startRowColNum + 1;
			
			for (var colNum = reference.colNumFrom; colNum <= reference.colNumTo && isNormal; colNum++) {
				var colNum1 = colNum - this.startRowColNum + 1;
				
				var childRC = [ "R", rowNum1, "C", colNum1 ].join("");
				
				// 지그마지의 상위에 내가 있으면 순환참조이다.
				if (RCs.indexOf(childRC) >= 0) {
					// !!! 순환참조 메시지
					isNormal = false;
					break;
				}
				
				var childRCs = [ childRC ].concat(RCs);
				
				if (childRC in this._formulaRefs){
					isNormal = this._checkLinkedRefs(childRC, RCs, calcOrders);
					if (calcOrders.indexOf(RC) < 0) {
						calcOrders.push(RC);
					}
				}
			}
		}
	}

	return isNormal;
};

// 자기자신을 먼저 계산
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	rowNum
	*     @param		{number}	colNum
	*     @return		{void}
	*     @example		미결
	*/
EasySheet.prototype.calculateCell = function(rowNum, colNum) {
	// functionname : [EasySheet.calculateCell]

	if (this._isUnvalidRowNum(rowNum, "sheet.calculateCell")){ return; }
	if (this._isUnvalidColNum(colNum, "sheet.calculateCell")){ return;}

	var rowNum1 = rowNum - this.startRowColNum + 1;
    var colNum1 = colNum - this.startRowColNum + 1;
	var RC = [ "R", rowNum1, "C", colNum1 ].join("");
	
	if (RC in this._formulaRefs) {
		this._calculateRC(RC, rowNum, colNum);
	}
		
	return;
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{string}	RC
	*     @param		{number}	rowNum
	*     @param		{number}	colNum
	*     @return		{void}	
	*     @example		미결
	*/
EasySheet.prototype._calculateRC = function(RC, rowNum, colNum) {
	// functionname : [EasySheet._calculateRC]

	if (RC.indexOf("#REF") >= 0) return;
	
	if (typeof rowNum == "undefined") {
		var arrRange = this._parseRCToRange(RC, this.startRowColNum, this.startRowColNum);
		rowNum = arrRange[0];
		colNum = arrRange[1];
	}

	var formulaInfo = this._formulaRefs[RC];
	
	
	EasyMath.crit.rowNum = rowNum;
	EasyMath.crit.colNum = colNum;
	var value = formulaInfo.func(this, rowNum, colNum);
	
	var colNum0 = colNum - this.startRowColNum;
	var column = this.columns[colNum0];
	if (typeof value != "string" && column.colDataType == "string"){
		value = "" + value;
	}
	
	this.setValueToCell(value, rowNum, colNum);

	// 산식값 체크
	// console.log(RC + "\t" + value + "\t" + formulaInfo.formula);
	
	return;
};

// 자기자신을 먼저 계산후에 다른 참조셀을 바꾼다
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	rowNum
	*     @param		{number}	colNum
	*     @return		{void}
	*     @example		미결
	*/
EasySheet.prototype._calculateRelatedCell = function(rowNum, colNum) {
	// functionname : [EasySheet._calculateRelatedCell]

	// 자기를 참조하는 셀들을 루핑하며 재귀호출한다.
	for (var RC in this._formulaRefs) {
		var formulaInfo = this._formulaRefs[RC];
		var references = formulaInfo.references;

		for (var j = 0; j < references.length; j++) {
			var reference = references[j];

			if (reference.rowNumFrom <= rowNum && reference.rowNumTo >= rowNum
					&& reference.colNumFrom <= colNum && reference.colNumTo >= colNum) {
				
				this._calculateRC(formulaInfo.RC);
			}
		}
	}

	return;
};

// 줄추가시 또는 삭제시 관련된 산식만 다시 계산한다
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	rowNum
	*     @return		{void}
	*     @example		미결
	*/
EasySheet.prototype.recalcurateRow = function(rowNum) {
	// functionname : [EasySheet.recalcurateAddedRow]

	if (this._isUnvalidRowNum(rowNum, "sheet.recalcurateRow")){ return; }

	for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++) {
	    var colNum  = colNum0 + this.startRowColNum;
		this.calculateCell(rowNum, colNum);
	}
	for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++) {
	    var colNum  = colNum0 + this.startRowColNum;
		this._calculateRelatedCell(rowNum, colNum);
	}

	return;
};

// 열추가시 또는 삭제시 관련된 산식만 다시 계산한다
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	colNum
	*     @return		{void}
	*     @example		미결
	*/
EasySheet.prototype.recalcurateCol = function(colNum) {
	// functionname : [EasySheet.recalcurateAddedCol]
	
	if (this._isUnvalidColNum(colNum, "sheet.recalcurateCol")){ return;}

	for (var rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
	    var rowNum  = rowNum0 + this.startRowColNum;
		this.calculateCell(rowNum, colNum);
	}
	for (var rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
	    var rowNum  = rowNum0 + this.startRowColNum;
		this._calculateRelatedCell(rowNum, colNum);
	}
	return;
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param		{number}	rowNums
	*     @param		{number}	colNums
	*     @return		{void}
	*     @example		미결
	*/
EasySheet.prototype.recalcurateRange = function(rowNums, colNums) {
	// functionname : [EasySheet.recalcurateAddedCol]

	for (var i = 0; i < rowNums.length; i++) {
		var rowNum = rowNums[i];
		for (var j = 0; j < colNums.length; j++) {
			var colNum = colNums[j];
			
			this.calculateCell(rowNum, colNum);
		}
	}
	for (var i = 0; i < rowNums.length; i++) {
		var rowNum = rowNums[i];
		for (var j = 0; j < colNums.length; j++) {
			var colNum = colNums[j];
			this._calculateRelatedCell(rowNum, colNum);
		}
	}
	return;
};


///////////

// sheet.cell("R1C1", rowNum, colNum) // 예: 'R2C1' 'R1C1,R2C2:R3C3' 'R1C1,R2C2:R3C3'
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param	{string}	RC
	*     @param	{number}	critRowNum
	*     @param	{number}	critColNum
	*     @return	{string}
	*     @example	미결
	*/
EasySheet.prototype.cell = function(RC, critRowNum, critColNum) {
	// functionname : [EasySheet._replaceToEasyFormula]

	var values = [];
	var ranges = RC.split(",");
	for (var i = 0; i < ranges.length; i++) {
		var rc = ranges[i].trim();
		
		var arrRange = this._parseRCToRange(rc, critRowNum, critColNum);
		
		// RC식에 #REF가 있으면 null이 리턴된다 
		if (arrRange === null) continue;
		
		for (var rowNum = arrRange[0]; rowNum <= arrRange[2]; rowNum++) {
			// 논리열은 집계에서 제외한다 
			var rowNum0 = rowNum - this.startRowColNum;
			if (this.needGrouping && this.sumUp._isLogicalRow(rowNum0)) continue;

			for (var colNum = arrRange[1]; colNum <= arrRange[3]; colNum++) {
				var cellType = this.columns[colNum - this.startRowColNum].cellType;
				
				var value = ([CELLTYPE_INTEGER].indexOf(cellType) >= 0 ? 
						          1 * this.getValue(rowNum, colNum) : 
					         [CELLTYPE_NUMBER, CELLTYPE_CURRENCY, CELLTYPE_FLOAT].indexOf(cellType) >= 0 ? 
					              1.0 * this.getValue(rowNum, colNum) : 
						     this.getValue(rowNum, colNum));

            	values.push(value);
			}
		}
	}
	
	return values.length > 1 ? values : values[0];
};

if (typeof EasySheet == "function")
EasyMath.cell = function(sheetName, strRC) {
	return controls[sheetName].cell(strRC);
};

// 산식의 셀문자열에 셀값을 대치하여 준다 예: R1C1 -> "142"
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param	{number}	critRowNum
	*     @param	{number}	critColNum
	*     @param	{string}	formula
	*     @return	{string}
	*     @example	미결
	*/
EasySheet.prototype._replaceToEasyFormula = function(critRowNum, critColNum, formula) {
	// functionname : [EasySheet._replaceToEasyFormula]

	// Cell 함수를 루핑하면서 계속 찾는다
	var formula = formula || "";
	
	// 셀연산이 필요 없으면 빠진다 
	if (null == formula.match(/CELL[ ]*[(].+?[)]/ig)){
		return formula;
	}
	
	// --- 사전준비 기능-----------------------------------------------------
	// 문자열교체 "..." - > STR_n
	// 케리지리턴이나 탭등을 제거한다
	// 대문자로 변환
	var arrStringValues = formula.match(/["].+?["]/ig);
	if  (arrStringValues != null){
		for (var strNdx = 0; strNdx < arrStringValues.length; strNdx++) {
			formula = formula.trim()
							.replace(new RegExp(escapeRegExp(arrStringValues[strNdx]), "i"), ("STR_" + strNdx))
							.replace(/[\r\n\t]/g, " ")
							.toUpperCase();
		}
	}

	// --- 메인동작 기능-----------------------------------------------------
	var firstNum = this.startRowColNum;
	var arrRange = [ firstNum, firstNum, firstNum, firstNum ];
	var maxRows = this.maxRows;
	var maxCols = this.maxCols;
	
	formula = formula.replace(/CELL/ig, "CELL")
				     .replace(/Cell[ ]+[(]/ig, "CELL(")
				     .replace(/CELL[(]\"(.+?)\"[)]/ig, "CELL($1)");

	var arr = formula.match(/CELL[(].+?[)]/ig);    // "CELL('R1C1,R2C2:R3C3'),
														// CELL('R2C1'),CELL('R1C2')"
														// ->
														// ["CELL('R1C1,R2C2:R3C3')",
														// "CELL('R2C1')",
														// "CELL('R1C2')"]
	// 셀연산이 필요 없는지 재차확인 
	if (arr == null){
		for (var i = 0; arrStringValues != null && i < arrStringValues.length; i++) {
			formula = formula.replace(new RegExp("STR_" + i), arrStringValues[i]);
		}

		return formula;
		
	}
	
	for (var cellNdx = 0; cellNdx < arr.length; cellNdx++) {
		
		cellString = arr[cellNdx].slice(5, -1).trim();
		for (var strNdx = 0; arrStringValues != null && strNdx < arrStringValues.length; strNdx++) {
			cellString = cellString.replace(new RegExp("STR_" + strNdx), arrStringValues[strNdx]);
		}
		cellString = cellString.replace(/\"/g, "");
	
		var valueString = "";
		var arrCellRanges = cellString.split(",");
		for (var RangeNdx = 0; RangeNdx < arrCellRanges.length; RangeNdx++) {
			var cellRange = arrCellRanges[RangeNdx].trim();
			var arrRange = this._parseRCToRange(cellRange, critRowNum, critColNum);
			
			// RC식에 #REF가 있으면 null이 리턴된다 
			if (arrRange === null) continue;
			
			for (var rowNum = arrRange[0]; rowNum <= arrRange[2]; rowNum++) {
				for (var colNum = arrRange[1]; colNum <= arrRange[3]; colNum++) {
				    var colNum0 = colNum - this.startRowColNum;
				    
				    var value = this.getValue(rowNum, colNum);
				    
					var column = this.columns[colNum0];
					var isNumberCell = [CELLTYPE_NUMBER, CELLTYPE_PERCENT, CELLTYPE_INTEGER, CELLTYPE_BAR, 
						                CELLTYPE_CURRENCY, CELLTYPE_FLOAT, CELLTYPE_CHECKBOX].indexOf(column.cellType) >= 0;
				    
				    if (!isNumberCell){
				    	 value = "\"" + value + "\"";
				    }
					valueString += (valueString.length > 0 ? "," : "") + value;
				}
			}
		}
		formula = formula.replace(new RegExp(escapeRegExp(arr[cellNdx]), "i"), valueString);
	}
	
	// 문자열교체 STR_n - > "..."
	for (var i = 0; arrStringValues != null && i < arrStringValues.length; i++) {
		formula = formula.replace(new RegExp("STR_" + i), arrStringValues[i]);
	}

	return formula;
};

// RC값범위에 원하는 셀이 있는지 확인한다
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param	{string}	strRC
	*     @param	{number}	rowNum
	*     @param	{number}	colNum
	*     @param	{number}	critRowNum
	*     @param	{number}	critColNum
	*     @return	{string}
	*     @example	미결
	*/
EasySheet.prototype._checkRC = function(strRC, rowNum, colNum, critRowNum, critColNum) {
	// functionname : [EasySheet._checkRC]

	var found = false;
//	critColNum = critColNum != undefined ? critColNum : this.startRowColNum;
//	critRowNum = critRowNum != undefined ? critRowNum : this.startRowColNum;
	critColNum = critColNum != undefined ? critColNum : EasyMath.crit.colNum;
	critRowNum = critRowNum != undefined ? critRowNum : EasyMath.crit.rowNum;

	var arrCellRanges = strRC.split(",");
	for (var i = 0; i < arrCellRanges.length && !found; i++) {
		var arrRange = this._parseRCToRange(arrCellRanges[i], critRowNum, critColNum);
		// RC식에 #REF가 있으면 null이 리턴된다 
		if (arrRange === null){
			// found = false;
		} else {
			found = rowNum >= arrRange[0] && rowNum <= arrRange[2] && 
					colNum >= arrRange[1] && colNum <= arrRange[3];
		}
	}

	return found;
};


EasyMath.checkRC = function(sheetName, strRC, rowNum, colNum, critRowNum, critColNum) {
	return controls[sheetName]._checkRC(strRC, rowNum, colNum, critRowNum, critColNum);
};

// RC값범위의 셀들의 컬렉션을 리턴한다  // ??? 재구성할 것 
if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param	{string}	strRC
	*     @param	{number}	critRowNum
	*     @param	{number}	critColNum
	*     @return	{string}
	*     @example	미결
	*/
EasySheet.prototype._cellsOfRC = function(strRC, critRowNum, critColNum) {
	// functionname : [EasySheet._cellsOfRC]

	var rtnArray = [];
	critColNum = critColNum != undefined ? critColNum : EasyMath.crit.colNum;
	critRowNum = critRowNum != undefined ? critRowNum : EasyMath.crit.rowNum;

	var arrCellRanges = strRC.split(",");
	var index = 0;
	for (var i = 0; i < arrCellRanges.length; i++) {
		var cellRange = arrCellRanges[i];
		var arrRange = this._parseRCToRange(cellRange, critRowNum, critColNum);
		
		if (arrRange === null) continue;

		for (var rowNum = arrRange[0]; rowNum <= arrRange[2]; rowNum++) {
			// 논리열은 집계에서 제외한다 
			var rowNum0 = rowNum - this.startRowColNum;
			if (this.needGrouping && this.sumUp._isLogicalRow(rowNum0)) continue;

			for (var colNum = arrRange[1]; colNum <= arrRange[3]; colNum++) {
				rtnArray[index++] = this.getValue(rowNum, colNum);
			}
		}
	}

	return rtnArray;
};

EasyMath.cellsOfRC = function(sheetName, strRC, critRowNum, critColNum) {
	return controls[sheetName].cellsOfRC(strRC, critRowNum, critColNum);
};

// 열을 참조값으로 조건에 맞는 값 찾기
/**
 * @description	미결
 * @param		{String}	sheetName
 * @param		{String}	data
 * @param		{number}	colNum
 * @param		{number}	returnColNum
 * @return		{Object}
 * @example		미결
 */
function vLookUp(sheetName, data, colNum, returnColNum) {
	return controls[sheetName].vLookUp(data, colNum, returnColNum);
};

EasyMath.vLookUp = function(sheetName, data, colNum, returnColNum) {
	return controls[sheetName].vLookUp(data, colNum, returnColNum);
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param	{string}	data
	*     @param	{number}	colNum
	*     @param	{number}	returnColNum
	*     @return	{string}
	*     @example	미결
	*/
EasySheet.prototype.vLookUp = function(data, colNum, returnColNum) {
	// functionname : [EasySheet.vLookUp]

	if (this._isUnvalidColNum(colNum, "sheet.vLookUp")){ return "";}

	for (var rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
		// 논리열은 집계에서 제외한다 
		if (this.needGrouping && this.sumUp._isLogicalRow(rowNum0)) continue;
		
		var rowNum  = rowNum0 + this.startRowColNum;
		if (this.getValue(rowNum, colNum) === data) {
			return this.getValue(rowNum, returnColNum);
		}
	}

	return "";
};

/**
 * @description	미결
 * @param		{String}	sheetName
 * @param		{String}	data
 * @param		{number}	colNum
 * @param		{number}	returnColNum
 * @return		{Object}
 * @example		미결
 */
function vLookUpList(sheetName, data, colNum, returnColNum) {
	return controls[sheetName].vLookUpList(data, colNum, returnColNum);
};

EasyMath.vLookUpList = function(sheetName, data, colNum, returnColNum) {
	return controls[sheetName].vLookUpList(data, colNum, returnColNum);
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param	{string}	data
	*     @param	{number}	colNum
	*     @param	{number}	returnColNum
	*     @return	{string}
	*     @example	미결
	*/
EasySheet.prototype.vLookUpList = function(data, colNum, returnColNum) {
	// functionname : [EasySheet.vLookUpList]
	
	if (this._isUnvalidColNum(colNum, "sheet.vLookUpList")){ return "";}

	var strList = "";
	var colNum0 = colNum - this.startRowColNum;
	var returnColNum0 = returnColNum - this.startRowColNum;

	for (var rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
		// 논리열은 집계에서 제외한다 
		if (this.needGrouping && this.sumUp._isLogicalRow(rowNum0)) continue;

		var rowNum  = rowNum0 + this.startRowColNum;
		if (this.getValue(rowNum, colNum) !== data) continue;
		
		var value = this.getValue(rowNum, returnColNum);

		var column = this.columns[returnColNum0];
		var isNumberCell = [CELLTYPE_NUMBER, CELLTYPE_PERCENT, CELLTYPE_INTEGER, CELLTYPE_BAR, 
			                CELLTYPE_CURRENCY, CELLTYPE_FLOAT, CELLTYPE_CHECKBOX].indexOf(column.cellType) >= 0;

	    if (!isNumberCell){
	    	 value = "\"" + value + "\"";
	    }
	    strList += (strList.length > 0 ? "," : "") + value;
		
	}

	return strList;
};

// 행을 참조값으로 조건에 맞는 값 찾기
/**
 * @description	미결
 * @param		{String}	sheetName
 * @param		{String}	rowNum
 * @param		{number}	data
 * @param		{number}	returnRowNum
 * @return		{Object}
 * @example		미결
 */
function hLookUp(sheetName, data, rowNum, returnRowNum) {
	return controls[sheetName].hLookUp(data, rowNum, returnRowNum);
};
EasyMath.hLookUp = function(sheetName, data, rowNum, returnRowNum) {
	return controls[sheetName].hLookUp(data, rowNum, returnRowNum);
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param	{number}	rowNum
	*     @param	{string}	data
	*     @param	{number}	returnRowNum
	*     @return	{string}
	*     @example	미결
	*/
EasySheet.prototype.hLookUp = function(data, rowNum, returnRowNum) {
	// functionname : [EasySheet.hLookUp]

	if (this._isUnvalidRowNum(rowNum, "sheet.hLookUp")){ return ""; }

	for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++) {
		var colNum  = colNum0 + this.startRowColNum;

		if (this.getValue(rowNum, colNum) === data) {
			return this.getValue(returnRowNum, colNum);
		}
	}
	return "";
};

/**
 * @description	미결
 * @param		{String}	sheetName
 * @param		{String}	rowNum
 * @param		{number}	data
 * @param		{number}	returnRowNum
 * @return		{Object}
 * @example		미결
 */
function hLookUpList(sheetName, data, rowNum, returnRowNum) {
	return controls[sheetName].hLookUpList( data, rowNum,returnRowNum);
};
EasyMath.hLookUpList = function(sheetName, data, rowNum, returnRowNum) {
	return controls[sheetName].hLookUpList(data, rowNum, returnRowNum);
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param	{number}	rowNum
	*     @param	{string}	data
	*     @param	{number}	returnRowNum
	*     @return	{string}
	*     @example	미결
	*/
EasySheet.prototype.hLookUpList = function(data, rowNum, returnRowNum) {
	// functionname : [EasySheet.hLookUpList]

	if (this._isUnvalidRowNum(rowNum, "sheet.hLookUpList")){ return ""; }

	var strList = "";
	var rowNum0 = rowNum - this.startRowColNum;
	var returnRowNum0 = returnRowNum - this.startRowColNum;

	for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++) {
		var colNum  = colNum0 + this.startRowColNum;

		if (this.getValue(rowNum, colNum) !== data) continue;
		
		var value = this.getValue(returnRowNum, colNum);

		var column = this.columns[colNum0];
		var isNumberCell = [CELLTYPE_NUMBER, CELLTYPE_PERCENT, CELLTYPE_INTEGER, CELLTYPE_BAR, 
			                CELLTYPE_CURRENCY, CELLTYPE_FLOAT, CELLTYPE_CHECKBOX].indexOf(column.cellType) >= 0;

	    if (!isNumberCell){
	    	 value = "\"" + value + "\"";
	    }
	    strList += (strList.length > 0 ? "," : "") + value;
	}

	return strList;
};

// 열을 참조값으로 조건에 맞는 데이터 갯수 구하기
/**
 * @description	미결
 * @param		{String}	sheetName
 * @param		{String}	data
 * @param		{number}	colNum
 * @return		{Object}
 * @example		미결
 */
function vCountIf(sheetName, data, colNum) {
	return controls[sheetName].vCountIf(data, colNum);
};
EasyMath.vCountIf = function(sheetName, data, colNum) {
	return controls[sheetName].vCountIf(data, colNum);
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param	{string}	data
	*     @param	{number}	colNum
	*     @return	{number}
	*     @example	미결
	*/
EasySheet.prototype.vCountIf = function(data, colNum) {
	// functionname : [EasySheet.vCountIf]
	
	if (this._isUnvalidColNum(colNum, "sheet.vCountIf")){ return 0;}

	var count = 0;
	var colNum0 = colNum - this.startRowColNum;
	
	for (var rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
		// 논리열은 집계에서 제외한다 
		if (this.needGrouping && this.sumUp._isLogicalRow(rowNum0)) continue;
	    var rowNum  = rowNum0 + this.startRowColNum;

	    if (this.getValue(rowNum, colNum) === data) {
			count++;
		}
	}

	return count;
};

// 행을 참조값으로 조건에 맞는 데이터 갯수 구하기
/**
 * @description	미결
 * @param		{String}	sheetName
 * @param		{String}	data
 * @param		{number}	rowNum
 * @return		{Object}
 * @example		미결
 */
function hCountIf(sheetName, data, rowNum) {
	return controls[sheetName].hCountIf(data, rowNum);
};
EasyMath.hCountIf = function(sheetName, data, rowNum) {
	return controls[sheetName].hCountIf(data, rowNum);
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param	{string}	data
	*     @param	{number}	rowNum
	*     @return	{number}
	*     @example	미결
	*/
EasySheet.prototype.hCountIf = function(data, rowNum) {
	// functionname : [EasySheet.hCountIf]

	if (this._isUnvalidRowNum(rowNum, "sheet.hCountIf")){ return 0; }

	var count = 0;
	var rowNum0 = rowNum - this.startRowColNum;
	
	for (var colNum0 = 0; colNum0 < this.maxCols; colNum0++) {
		var colNum  = colNum0 + this.startRowColNum;
	    if (this.getValue(rowNum, colNum) === data) {
			count++;
		}
	}
	return count;
};

// RC RAnge를 참조값으로 조건에 맞는 데이터 갯수 구하기
/**
 * @description	미결
 * @param		{String}	sheetName
 * @param		{String}	data
 * @param		{Object}	strRC
 * @return		{Object}
 * @example		미결
 */
function countIf(sheetName, data, strRC) {
	return controls[sheetName].countIf(data, strRC);
};
EasyMath.countIf = function(sheetName, data, strRC) {
	return controls[sheetName].countIf(data, strRC);
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param	{string}	data
	*     @param	{string}	strRC
	*     @return	{number}
	*     @example	미결
	*/
EasySheet.prototype.countIf = function(data, strRC) {
	// functionname : [EasySheet.countIf]
	if( typeof strRC != "string" ) strRC = ("" + strRC);
	
	var count = 0;
	var arrayCells = this._cellsOfRC(strRC);

	for (var i = 0; i < arrayCells.length; i++) {
		if (arrayCells[i] === data) {
			count++;
		}
	}
	return count;
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param	{number}	colNumOrId
	*     @param	{string}	formula
	*     @return	{number}
	*     @example	미결
	*/
EasySheet.prototype.sumIf = function(colNumOrId, formula) {
	
	var colNum = typeof colNumOrId == "number" ? colNumOrId : this.getColNum(colNumOrId);
	if (this._isUnvalidColNum(colNum, "sheet.setCurrentCol")){ return 0;}

	var func = new Function("return function (sheet, rowNum, colNum) { return " + this._updateFormula(formula) + "; }")();

	var result = 0;
	for (var rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
		// 논리열은 집계에서 제외한다 
		if (this.needGrouping && this.sumUp._isLogicalRow(rowNum0)) continue;

		var rowNum  = rowNum0 + this.startRowColNum;
		
		var value = this.getValue(rowNum, colNum);
		var isNumber = /^[-+]?\d+(?:\.\d+)?$/.test(value);
		if (!isNumber) continue;

		if (func(this, rowNum, colNum) == true){
			result += this.getValue(rowNum, colNum);
		}
		
	}
	return result;
};

if (typeof EasySheet == "function")
	/**
	*     @description	미결
	*     @param	{number}	colNumOrId
	*     @param	{string}	data
	*     @return	{number}
	*     @example	미결
	*/
EasySheet.prototype.rank = function(colNumOrId, data) {
	// functionname : [EasyMath.vCountIf]
	
	var colNum = typeof colNumOrId == "number" ? colNumOrId : this.getColNum(colNumOrId);
	if (this._isUnvalidColNum(colNum, "sheet.setCurrentCol")){ return 0;}

	// 숫자 형태가 아닐 경우 리턴 false
	var isNumber = /^[-+]?\d+(?:\.\d+)?$/.test(data);
	if (!isNumber) return -1;

	// 시트의 줄수 만큼 돌며 data 보다 큰값이 나오면 wRank + 1
	var rank = 1;
	for (var rowNum0 = 0; rowNum0 < this.maxRows; rowNum0++) {
		// 논리열은 집계에서 제외한다 
		if (this.needGrouping && this.sumUp._isLogicalRow(rowNum0)) continue;

		var rowNum  = rowNum0 + this.startRowColNum;

	    var value = this.getValue(rowNum, colNum);
		var isNumber = /^[-+]?\d+(?:\.\d+)?$/.test(value);
		if (!isNumber) continue;
		
		if (value > data) {
			rank++;
		}
	}

	return rank;
};

// ///////////////////////////////////////////////////////////////////////////////////////////////

EasyMath.addNamespace = function(ns_string) {
	var parts = ns_string.split('.'), parent = EASYMATH, i;

	// 처음에 중복되는 전역 객체명은 제거한다.
	if (parts[0] === MYAPP) {
		parts = parts.slice(1);
	}
	for (i = 0; i < parts.length; i += 1) {
		// 프로퍼티가 존재하지 않는다면 생성한다.
		if (typeof parent[parts[i]] === 'undefined') {
			parent[parts[i]] = {};
		}
		parent = parent[parts[i]];
	}
	return parent;
};

EasyMath.parseBigNumber = function(value){
	return new BigNumber("" + value);
};

EasyMath.endOfBracket = function(statement, position) {
	if (statement.indexOf(")", position + 1) == -1)
		return -1;
	
	var level = 0;
	var len = statement.length;
	for (var pos=position + 1; pos < len; pos++){
		var c = statement.charAt(pos);
		if ("(" === c) {
			level++;
		} else if (")" === c) {
			if (level === 0) return pos;
			level--;
		} 
	}
	return -1;
};

EasyMath.decomment = function(formula) {
	if (formula.indexOf("//") != -1) {
		var added = false;
		if (!formula.endsWith("\n")){
			formula = formula + "\n";
			added = true;
			
		}
		formula = EasyMath.removeString(formula, "//", "\n");
		if (added && formula.endsWith("\n")){
			formula = formula.slice(0, -1);
		}
		
	}

	if (formula.indexOf("/*") != -1 && formula.indexOf("*/") != -1) {
		formula = EasyMath.removeString(formula, "/*", "*/");
	}

	return formula;
};

/* SORT ASC 에 관한 함수 모음 */
EasyMath.sort = function() {
	var args = Array.prototype.slice.call(arguments);
	var values =  Array.isArray(args[0]) ? args[0] : args;

	var hasString = false;
	for (var i = 0; i < values.length && !hasString; i++)
		hasString = (typeof values[i] == "string");

	return hasString ? sortStrings(values) : sortValues(values);
};

EasyMath.sortValues = function(values) {
	// 원본을 손상시키지 않기 위하여 복사
	var tempValues = values.slice();

	tempValues.sort(function(a, b) {
		return (a - b);
	});

	return tempValues;
};

EasyMath.sortStrings = function(values) {
	// 원본을 손상시키지 않기 위하여 복사
	var tempValues = values.slice();

	tempValues.sort(function(a, b) {
		return "" + a < "" + b ? -1 : "" + a == "" + b ? 0 : 1;
	});
	return tempValues;
};

EasyMath.sortASC_Str = function(values) {
	return EasyMath.sortStrings(values.slice()).join(",")
};

EasyMath.sortASC_Num = function(values) {
	return EasyMath.sortValues(values.slice()).join(",")
};

/* SORT DESC 에 관한 함수 모음 */
EasyMath.sortDesc = function() {
	var args = Array.prototype.slice.call(arguments);
	var values =  Array.isArray(args[0]) ? args[0] : args;

	var hasString = false;
	for (var i = 0; i < values.length && !hasString; i++)
		hasString = (typeof values[i] == "string");

	return hasString ? EasyMath.sortDescStrings(values) : EasyMath.sortDescValues(values);
};

EasyMath.sortDescValues = function(values) {
	// 원본을 손상시키지 않기 위하여 복사
	var tempValues = values.slice();

	tempValues.sort(function(a, b) { return (b - a); }); // DESC
	return tempValues;
};

EasyMath.reverseValues = function(values) {
	return EasyMath.sortDescValues(values);
};

EasyMath.sortDescStrings = function(values) {
	// 원본을 손상시키지 않기 위하여 복사
	var tempValues = values.slice();

	tempValues.sort(function(a, b) {
		return "" + a > "" + b ? -1 : "" + a == "" + b ? 0 : 1;
	}); // DESC
	
	return tempValues;
};

EasyMath.reverseStrings = function(values) {
	return EasyMath.sortDescStrings(values);
};

// 문자열 리턴 
EasyMath.sortDSC_Str = function(values) {
	return EasyMath.sortDescStrings(values.slice()).join(",")
};

//문자열 리턴 
EasyMath.sortDSC_Num = function(values) {
	return EasyMath.sortDescValues(values.slice()).join(",")
};

/* SORT TOP N 에 관한 함수 모음 */
EasyMath.topNOf = function() {
	var args = Array.prototype.slice.call(arguments);
	var count = args[0];

	args.splice(0, 1); // 앞하나 줄임
	
	var values =  Array.isArray(args[0]) ? args[0] : args;
	

	var hasString = false;
	for (var i = 0; i < values.length && !hasString; i++)
		hasString = (typeof values[i] == "string");

	return hasString ? EasyMath.topNStrings(count, values) : EasyMath.topNValues(count, values);

};

EasyMath.topNStrings = function(count, values) {
	// 원본을 손상시키지 않기 위하여 복사
	var tempValues = values.slice();

	tempValues.sort(function(a, b) {
		return "" + a > "" + b ? -1 : "" + a == "" + b ? 0 : 1;
	});
	return tempValues.slice(0, count); // n개를 잘라냄
};

EasyMath.topNValues = function(count, values) {
	// 원본을 손상시키지 않기 위하여 복사
	var tempValues = values.slice();
	
	tempValues.sort(function(a, b) {
		return (b - a);
	}); // 소트
	
	return tempValues.slice(0, count); // n개를 잘라냄
};

//문자열 리턴 
EasyMath.topN_Str = function(values, count) {

	// 원본을 손상시키지 않기 위하여 복사
	var tempValues = values.slice();

	if (typeof count == "undefined") {
		count = parseInt(tempValues[0], 10);
		tempValues.splice(0, 1); // 첫번쨰 요소 삭제
	}

	return EasyMath.topNStrings(count, tempValues).join(",");
};

//문자열 리턴 
EasyMath.topN_Num = function(values, count) {

	// 원본을 손상시키지 않기 위하여 복사
	var tempValues = values.slice();

	if (typeof count == "undefined") {
		count = parseInt(tempValues[0], 10);
		tempValues.splice(0, 1); // 첫번쨰 요소 삭제
	}

	return EasyMath.topNValues(count, tempValues).join(",");
};

/* SORT LOW N 에 관한 함수 모음 */
EasyMath.lowNOf = function() {
	var args = Array.prototype.slice.call(arguments);
	var count = args[0];

	args.splice(0, 1); // 앞하나 줄임
	var values =  Array.isArray(args[0]) ? args[0] : args;

	var hasString = false;
	for (var i = 0; i < values.length && !hasString; i++)
		hasString = (typeof values[i] == "string");

	return hasString ? EasyMath.lowNStrings(count, values) : EasyMath.lowNValues(count, values);
};

EasyMath.lowNValues = function(count, values) {
	// 원본을 손상시키지 않기 위하여 복사
	var tempValues = values.slice();

	tempValues.sort(function(a, b) {
		return (a - b);
	}); // 소트
	
	return tempValues.slice(0, count); // n개를 잘라냄
};

EasyMath.lowNStrings = function(count, values) {
	// 원본을 손상시키지 않기 위하여 복사
	var tempValues = values.slice();

	tempValues.sort(function(a, b) {
		return "" + a > "" + b ? 1 : "" + a == "" + b ? 0 : -1;
	});
	return tempValues.splice(0, count); // n개를 잘라냄
};

//문자열 리턴 
EasyMath.lowN_Str = function(values, count) {

	// 원본을 손상시키지 않기 위하여 복사
	var tempValues = values.slice();

	if (typeof count == "undefined") {
		count = parseInt(tempValues[0], 10);
		tempValues.splice(0, 1); // 첫번쨰 요소 삭제
	}

	return EasyMath.lowNStrings(count, tempValues).join(",");
};

//문자열 리턴 
EasyMath.lowN_Num = function(values, count) {

	// 원본을 손상시키지 않기 위하여 복사
	var tempValues = values.slice();

	if (typeof count == "undefined") {
		count = parseInt(tempValues[0], 10);
		tempValues.splice(0, 1); // 첫번쨰 요소 삭제
	}

	return EasyMath.lowNValues(count, tempValues).join(",");
};

EasyMath.repeatString = function(char, count) {
	if (char.repeat) {
		return char.repeat(count);
	}

	return new Array(count + 1).join(char);
};

EasyMath.clearFrontZero = function(strNum) {
	return strNum.replace(/^0+/,"");
};

EasyMath.clearBehindZero = function(strNum) {
	if (strNum.indexOf(".") == -1) return strNum;
	var arr = strNum.split(".");
	arr[1] = arr[1].replace(/0+$/,"");
	
	return arr[1].length > 0 ? arr.join(".") : arr[0];
};

EasyMath.larger = function(x, y) {EasyMath.greaterThan.apply(this, arguments);};
EasyMath.greaterThan = function(x, y) {
	
	if (x instanceof BigNumber || y instanceof BigNumber){
		var _x = x instanceof BigNumber ? x :  new BigNumber(x);
		return _x.gt(y);;
	}	
	
	if (typeof x == "number" && typeof y == "number"){
		return x > y;
	}
	
	return parseFloat(1.0 * x) > parseFloat(1.0 * y);
};

EasyMath.equal = function(x, y) {
	if (x instanceof BigNumber || y instanceof BigNumber){
		var _x = x instanceof BigNumber ? x :  new BigNumber(x);
		return _x.eq(y);;
	}	

	if (typeof x == "number" && typeof y == "number"){
		return x == y;
	}
	
	return parseFloat(1.0 * x) == parseFloat(1.0 * y);
};

EasyMath.smaller = function(x, y) {EasyMath.greaterThan.apply(this, arguments);};
EasyMath.lessThan = function(x, y) {
	
	if (x instanceof BigNumber || y instanceof BigNumber){
		var _x = x instanceof BigNumber ? x :  new BigNumber(x);
		return _x.lt(y);;
	}	
	
	if (typeof x == "number" && typeof y == "number"){
		return x < y;
	}
	
	return parseFloat(1.0 * x) < parseFloat(1.0 * y);
};

// 현재 열다섯자리이상은 안된다. 
EasyMath.multiply = function(x, y) {
	
	if (x instanceof BigNumber || y instanceof BigNumber){
		var _x = x instanceof BigNumber ? x :  new BigNumber(x);
		return _x.times(y);;
	}	

	
	// 둘 다 숫자이고, 결과가 지수범위 이내면 바로 결과 리턴 
	if (typeof x == "number" && typeof y == "number"){
		if (("" + (x * y)).indexOf('e') == -1) {return x * y;}
	}
	
	
	return EasyMath.clearBehindZero("" + (new BigNumber(x)).times(y));
	
	var strNumX = "" + x;
	var strNumY = "" + y;

	var rtn = "";
	
	var varX = new Array(5);
	var varY = new Array(5);
	var multiplyValue = 0;
	var addingNum = 0;
	var fixingNum = 0;

	var minusSign = ((strNumX.startsWith("-") && !strNumY.startsWith("-")) || (!strNumX .startsWith("-") && strNumY.startsWith("-")));
	if (strNumX.startsWith("-"))
		strNumX = strNumX.substring(1);
	if (strNumY.startsWith("-"))
		strNumY = strNumY.substring(1);

	var dotPosFromLeft = 0;
	var dotPosFromRight = 0;

	dotPosFromLeft = strNumX.indexOf('.');
	if (dotPosFromLeft != -1) {
		dotPosFromRight = strNumX.length - 1 - dotPosFromLeft;
		strNumX = strNumX.substring(0, dotPosFromLeft)
				+ strNumX.substring(dotPosFromLeft + 1);
	}

	dotPosFromLeft = strNumY.indexOf('.');
	if (dotPosFromLeft != -1) {
		dotPosFromRight = dotPosFromRight + strNumY.length - 1
				- dotPosFromLeft;
		strNumY = strNumY.substring(0, dotPosFromLeft)
				+ strNumY.substring(dotPosFromLeft + 1);
	}

	strNumX = EasyMath.repeatString('0', 15 - strNumX.length) + strNumX;
	strNumY = EasyMath.repeatString('0', 15 - strNumY.length) + strNumY;

	for (var i = 0; i < 5; i++) {
		varX[i] = parseInt(strNumX.substring(3 * i, (3 * i) + 3), 10);
		varY[i] = parseInt(strNumY.substring(3 * i, (3 * i) + 3), 10);
	}
	
	addingNum = 0;
	multiplyValue = 0;
	for (var i = 0; i < 10; i++) {
		if (i == 0) {
			multiplyValue = varX[4] * varY[4];
		} else if (i == 1) {
			multiplyValue = addingNum + (varX[3] * varY[4])
					+ (varX[4] * varY[3]);
		} else if (i == 2) {
			multiplyValue = addingNum + (varX[2] * varY[4])
					+ (varX[3] * varY[3]) + (varX[4] * varY[2]);
		} else if (i == 3) {
			multiplyValue = addingNum + (varX[1] * varY[4])
					+ (varX[2] * varY[3]) + (varX[3] * varY[2])
					+ (varX[4] * varY[1]);
		} else if (i == 4) {
			multiplyValue = addingNum + (varX[0] * varY[4])
					+ (varX[1] * varY[3]) + (varX[2] * varY[2])
					+ (varX[3] * varY[1]) + (varX[4] * varY[0]);
		} else if (i == 5) {
			multiplyValue = addingNum + (varX[0] * varY[3])
					+ (varX[1] * varY[2]) + (varX[2] * varY[1])
					+ (varX[3] * varY[0]);
		} else if (i == 6) {
			multiplyValue = addingNum + (varX[0] * varY[2])
					+ (varX[1] * varY[1]) + (varX[2] * varY[0]);
		} else if (i == 7) {
			multiplyValue = addingNum + (varX[0] * varY[1])
					+ (varX[1] * varY[0]);
		} else if (i == 8) {
			multiplyValue = addingNum + (varX[0] * varY[0]);
		} else if (i == 9) {
			multiplyValue = addingNum;
		}

		addingNum = parseInt(multiplyValue / 1000, 10);
		fixingNum = multiplyValue % 1000;
		rtn = ("000" + fixingNum).slice (-3) + rtn;      //EasyMath.numberFormat(("" + fixingNum), "000") + rtn;
	}

	if (dotPosFromRight > 0) {
		dotPosFromLeft = rtn.length - dotPosFromRight;
		rtn = rtn.substring(0, dotPosFromLeft) + "."
				+ rtn.substring(dotPosFromLeft);
	}
	if (rtn.startsWith("."))
		rtn = "0" + rtn;

	rtn = EasyMath.clearFrontZero(rtn);
	rtn = EasyMath.clearBehindZero(rtn);
	if (rtn.startsWith("."))
		rtn = "0" + rtn;
	if (rtn.endsWith("."))
		rtn = rtn.substring(0, rtn.length - 1);

	if (minusSign && rtn != "0")
		rtn = "-" + rtn;

	return rtn;
};

EasyMath.mod = function(x, y, toFixed) {
	if (x instanceof BigNumber || y instanceof BigNumber){
		var _x = x instanceof BigNumber ? x :  new BigNumber(x);
		return _x.mod(y).toFixed(toFixed, BigNumber.ROUND_HALF_UP);
	}	
	
	// 둘 다 숫자이고, 결과가 지수범위 이내면 바로 결과 리턴 
	if (typeof x == "number" && typeof y == "number"){
		var quotient = EasyMath.floor(x / y, toFixed);
		var multiplyRslt = quotient * y;
		var modRslt = x - multiplyRslt;
		
		if (("" + quotient).indexOf('e') == -1 && ("" +  multiplyRslt).indexOf('e') == -1) {
			return modRslt;
		}
	}
	
	// 문자이고 결과가 지수범위 이내면 바로 결과 리턴 
//	var _x = parseFloat(1.0 * x, 10);
//	var _y = parseFloat(1.0 * y, 10);
//	
//	var quotient = EasyMath.floor(_x / _y, toFixed);
//	var multiplyRslt = quotient * _y;
//	var modRslt = _x - multiplyRslt;
//	
//	if (("" + quotient).indexOf('e') == -1 && ("" +  multiplyRslt).indexOf('e') == -1) {
//		return "" + modRslt;
//	}


	return EasyMath.clearBehindZero("" + (new BigNumber(x)).mod(y).toFixed(toFixed, BigNumber.ROUND_HALF_UP));

	
	// !!! 15 자리 제약처리  필요
	
	var strNumX = "" + x;
	var strNumY = "" + y;
	
	// 지수형태인 경우 
	var rtn = "" + (parseFloat(1.0 * x, 10) % parseFloat(1.0 * y, 10));
	if (rtn.indexOf('e') == -1) {return rtn;}

	var rtn = "";
	
	if (typeof toFixed == "undefined") toFixed = 0;

	rtn = EasyMath.divide(strNumX, strNumY, toFixed, false);
	rtn = EasyMath.multiply(rtn, strNumY);
	rtn = EasyMath.minus(strNumX, rtn);

	return rtn;
};

EasyMath.divide = function(x, y, toFixed, roundUp) {
	if (typeof toFixed == "undefined") toFixed = 0;
	if (typeof roundUp == "undefined") roundUp = false;
	
	if (x instanceof BigNumber || y instanceof BigNumber){
		var _x = x instanceof BigNumber ? x :  new BigNumber(x);
		return _x.div(y).toFixed(toFixed, roundUp ? BigNumber.ROUND_HALF_UP : BigNumber.ROUND_FLOOR);
	}	
	
	// 둘 다 숫자이고, 결과가 지수범위 이내면 바로 결과 리턴 
	if (typeof x == "number" && typeof y == "number"){
		var quotient = roundUp? EasyMath.round(x / y, toFixed) : EasyMath.floor(x / y, toFixed);
		
		if (("" + quotient).indexOf('e') == -1) {
			return quotient;
		}
	}
	
	// 문자이고 결과가 지수범위 이내면 바로 결과 리턴 
//	var _x = parseFloat(1.0 * x, 10);
//	var _y = parseFloat(1.0 * y, 10);
//	
//	var quotient = roundUp? EasyMath.round(_x / _y, toFixed) : EasyMath.floor(_x / _y, toFixed);
//	if (("" + quotient).indexOf('e') == -1) {
//		return "" + quotient;
//	}
	
	return EasyMath.clearBehindZero("" + (new BigNumber(x)).div(y).toFixed(toFixed, roundUp ? BigNumber.ROUND_HALF_UP : BigNumber.ROUND_FLOOR));

	
	var strNumX = "" + x;
	var strNumY = "" + y;
	var rtn = "";
	
	var currentDigitPos = 0;
	var digitsGap = 0;
	strNumX = strNumX + "";
	strNumY = strNumY + "";

	var minusSign = ((strNumX.startsWith("-") && !strNumY.startsWith("-")) || (!strNumX
			.startsWith("-") && strNumY.startsWith("-")));
	if (strNumX.startsWith("-"))
		strNumX = strNumX.substring(1);
	if (strNumY.startsWith("-"))
		strNumY = strNumY.substring(1);

	var dotPosFromLeftX = strNumX.indexOf('.');
	var dotPosFromLeftY = strNumY.indexOf('.');
	var dotPosFromRightX = 0;
	var dotPosFromRightY = 0;

	if (dotPosFromLeftX >= 0)
		dotPosFromRightX = strNumX.length - dotPosFromLeftX - 1;
	if (dotPosFromLeftY >= 0)
		dotPosFromRightY = strNumY.length - dotPosFromLeftY - 1;
	if (dotPosFromRightY > dotPosFromRightX) {
		strNumX = strNumX
				+ EasyMath.repeatString('0', dotPosFromRightY
						- dotPosFromRightX);
	} else if (dotPosFromRightX > dotPosFromRightY) {
		strNumY = strNumY
				+ EasyMath.repeatString('0', dotPosFromRightX
						- dotPosFromRightY);
	}

	if (dotPosFromLeftX > 0)
		strNumX = strNumX.substring(0, dotPosFromLeftX)
				+ strNumX.substring(dotPosFromLeftX + 1);
	if (dotPosFromLeftY > 0)
		strNumY = strNumY.substring(0, dotPosFromLeftY)
				+ strNumY.substring(dotPosFromLeftY + 1);
	digitsGap = strNumX.length - strNumY.length;

	currentDigitPos = 0;
	if (digitsGap < 0) {
		strNumX = EasyMath.repeatString('0', (-1) * digitsGap) + strNumX;
	} else if (digitsGap > 0) {
		currentDigitPos = digitsGap;
	}
	digitsGap = strNumX.length - strNumY.length;

	var compared = new Array(10); // String
	for (var i = 0; i < 10; i++) {
		compared[i] = EasyMath.multiply(strNumY, i + "");
	}

	var value;
	var j = 0;
	var lenY = strNumY.length;

	strNumX = strNumX + "00000000000000000000000";
	var target = strNumX.substring(0, lenY);
	for (; currentDigitPos > ((-1) * toFixed - 2); currentDigitPos--) {
		j++;
		value = 9;
		for (i = 1; i <= 9; i++) {
			if (EasyMath.larger(compared[i], target)) {

				value = i - 1;
				break;
			}
		}
		var reminder = EasyMath.minus(target, compared[value]);
		if (reminder == "0") {
			target = strNumX.substring(lenY + j - 1, lenY + j);
		} else {
			target = reminder + strNumX.charAt(lenY + j - 1);
		}
		rtn += value + '';
	}

	if (toFixed >= 0) {
		dotPosFromLeftX = rtn.length - toFixed - 1;
		rtn = rtn.substring(0, dotPosFromLeftX) + "."
				+ rtn.substring(dotPosFromLeftX);
	} else if (toFixed < 0) {
		rtn = rtn + EasyMath.repeatString('0', (-1) * toFixed);
	}

	if (roundUp) {
		rtn = EasyMath.round(rtn, toFixed);
	} else {
		rtn = EasyMath.floor(rtn, toFixed);
	}
	rtn = EasyMath.clearFrontZero(rtn);
	rtn = EasyMath.clearBehindZero(rtn);
	if (rtn.startsWith("."))
		rtn = "0" + rtn;
	if (rtn.endsWith("."))
		rtn = rtn.substring(0, rtn.length - 1);

	if (minusSign && rtn != "0")
		rtn = "-" + rtn;

	return rtn;
};

EasyMath.plus = function(x, y) {
	
	if (x instanceof BigNumber || y instanceof BigNumber){
		var _x = x instanceof BigNumber ? x :  new BigNumber(x);
		return _x.plus(y);
	}	

	// 둘 다 숫자이고, 결과가 지수범위 이내면 바로 결과 리턴 
	if (typeof x == "number" && typeof y == "number"){
		var plusRslt = x + y;
		
		if (("" + plusRslt).indexOf('e') == -1) {
			return plusRslt;
		}
	}
	
	// 문자이고 결과가 지수범위 이내면 바로 결과 리턴 
//	var _x = parseFloat(1.0 * x, 10);
//	var _y = parseFloat(1.0 * y, 10);
//	
//	var plusRslt = _x + _y;
//	if (("" + plusRslt).indexOf('e') == -1) {
//		return "" + plusRslt;
//	}
	
	return EasyMath.clearBehindZero("" + (new BigNumber(x)).plus(y));

	var strNumX = "" + x;
	var strNumY = "" + y;
	
	var rtn = "";
	var minusSign = false;
	strNumX = strNumX + "";
	strNumY = strNumY + "";

	if (strNumX.substring(0, strNumX.indexOf(".")).length <= 13
			&& strNumY.substring(0, strNumY.indexOf(".")).length <= 13) {
		return "" + ((1 * strNumX) + (1 * strNumY));
	}

	if (!strNumX.startsWith("-") && strNumY.startsWith("-")) {
		strNumY = strNumY.substring(1);
		return EasyMath.minus(strNumX, strNumY);
	} else if (strNumX.startsWith("-") && !strNumY.startsWith("-")) {
		strNumX = strNumX.substring(1);
		return EasyMath.minus(strNumY, strNumX);
	} else if (strNumX.startsWith("-") && strNumY.startsWith("-")) {
		minusSign = true;
		strNumX = strNumX.substring(1);
		strNumY = strNumY.substring(1);
	}

	var digitsAfterDotX = 0;
	var digitsAfterDotY = 0;
	if (strNumX.indexOf('.') != -1)
		digitsAfterDotX = strNumX.length - strNumX.indexOf('.') - 1;
	if (strNumY.indexOf('.') != -1)
		digitsAfterDotY = strNumY.length - strNumY.indexOf('.') - 1;
	var digitsPosition = (digitsAfterDotX > digitsAfterDotY ? digitsAfterDotX
			: digitsAfterDotY);

	var digitsGap = digitsAfterDotX - digitsAfterDotY;
	if (digitsGap < 0) {
		strNumX = strNumX + EasyMath.repeatString('0', (-1) * digitsGap);
	} else if (digitsGap > 0) {
		strNumY = strNumY + EasyMath.repeatString('0', digitsGap);
	}

	var dotPosFromLeft = strNumX.indexOf('.');
	if (dotPosFromLeft != -1)
		strNumX = strNumX.substring(0, dotPosFromLeft)
				+ strNumX.substring(dotPosFromLeft + 1);
	dotPosFromLeft = strNumY.indexOf('.');
	if (dotPosFromLeft != -1)
		strNumY = strNumY.substring(0, dotPosFromLeft)
				+ strNumY.substring(dotPosFromLeft + 1);

	var varX = new Array(10);
	var varY = new Array(10);
	var plusValue = 0;
	var addingNum = 0;
	var fixingNum = 0;

	strNumX = EasyMath.repeatString('0', 30 - strNumX.length) + strNumX;
	strNumY = EasyMath.repeatString('0', 30 - strNumY.length) + strNumY;

	for (var i = 0; i < 10; i++) {
		varX[i] = parseInt(strNumX.substring(3 * i, (3 * i) + 3), 10);
		varY[i] = parseInt(strNumY.substring(3 * i, (3 * i) + 3), 10);
	}

	rtn = "";
	addingNum = 0;
	plusValue = 0;
	fixingNum = 0;
	for (var i = 9; i >= 0; i--) {
		plusValue = addingNum + varX[i] + varY[i];
		addingNum = parseInt(plusValue / 1000, 10);
		fixingNum = plusValue % 1000;
		rtn =  ("000" + fixingNum).slice (-3) + rtn;    // EasyMath.numberFormat(fixingNum + '', "000") + rtn;

	}
	if (addingNum > 0)
		rtn = addingNum + '' + rtn;

	if (digitsPosition > 0) {
		dotPosFromLeft = rtn.length - digitsPosition;
		rtn = rtn.substring(0, dotPosFromLeft) + "."
				+ rtn.substring(dotPosFromLeft);
	}
	if (rtn.startsWith("."))
		rtn = "0" + rtn;

	rtn = EasyMath.clearFrontZero(rtn);
	rtn = EasyMath.clearBehindZero(rtn);
	if (rtn.startsWith("."))
		rtn = "0" + rtn;
	if (rtn.endsWith("."))
		rtn = rtn.substring(0, rtn.length - 1);

	if (minusSign && rtn != "0")
		rtn = "-" + rtn;

	return rtn;
};

EasyMath.minus = function(x, y) {
	
	if (x instanceof BigNumber || y instanceof BigNumber){
		var _x = x instanceof BigNumber ? x :  new BigNumber(x);
		return _x.minus(y);;
	}	

	// 둘 다 숫자이고, 결과가 지수범위 이내면 바로 결과 리턴 
	if (typeof x == "number" && typeof y == "number"){
		var minusRslt = x - y;
		
		if (("" + minusRslt).indexOf('e') == -1) {
			return minusRslt;
		}
	}
	
	// 문자이고 결과가 지수범위 이내면 바로 결과 리턴 
//	var _x = parseFloat(1.0 * x, 10);
//	var _y = parseFloat(1.0 * y, 10);
//	
//	var minusRslt = _x - _y;
//	if (("" + minusRslt).indexOf('e') == -1) {
//		return "" + minusRslt;
//	}

	return EasyMath.clearBehindZero("" + (new BigNumber(x)).minus(y));
	
	var strNumX = "" + x;
	var strNumY = "" + y;
	
	var rtn = "";
	var minusSign = false;
	strNumX = strNumX + "";
	strNumY = strNumY + "";

	if (!strNumX.startsWith("-") && strNumY.startsWith("-")) {
		strNumY = strNumY.substring(1);
		return EasyMath.plus(strNumX, strNumY);
	} else if (strNumX.startsWith("-") && !strNumY.startsWith("-")) {
		strNumY = "-" + strNumY;
		return EasyMath.plus(strNumY, strNumX);
	} else if (strNumX.startsWith("-") && strNumY.startsWith("-")) {
		minusSign = true;
		strNumX = strNumX.substring(1);
		strNumY = strNumY.substring(1);
	}

	var digitsAfterDotX = 0;
	var digitsAfterDotY = 0;
	if (strNumX.indexOf('.') != -1)
		digitsAfterDotX = strNumX.length - strNumX.indexOf('.') - 1;
	if (strNumY.indexOf('.') != -1)
		digitsAfterDotY = strNumY.length - strNumY.indexOf('.') - 1;
	var digitsPosition = (digitsAfterDotX > digitsAfterDotY ? digitsAfterDotX
			: digitsAfterDotY);

	var digitsGap = digitsAfterDotX - digitsAfterDotY;
	var dotPosFromLeft = strNumX.indexOf('.');
	if (dotPosFromLeft != -1)
		strNumX = strNumX.substring(0, dotPosFromLeft)
				+ strNumX.substring(dotPosFromLeft + 1);
	dotPosFromLeft = strNumY.indexOf('.');
	if (dotPosFromLeft != -1)
		strNumY = strNumY.substring(0, dotPosFromLeft)
				+ strNumY.substring(dotPosFromLeft + 1);

	if (digitsGap < 0) {
		strNumX = strNumX + EasyMath.repeatString('0', (-1) * digitsGap);
	} else if (digitsGap > 0) {
		strNumY = strNumY + EasyMath.repeatString('0', digitsGap);
	}

	strNumX = EasyMath.repeatString('0', 30 - strNumX.length) + strNumX;
	strNumY = EasyMath.repeatString('0', 30 - strNumY.length) + strNumY;

	var strNum = "";
	if (strNumX < strNumY && !minusSign) {
		strNum = strNumX;
		strNumX = strNumY;
		strNumY = strNum;
		minusSign = true;
	} else if (strNumX > strNumY && !minusSign) {
		minusSign = false;
	} else if (strNumX < strNumY && minusSign) {
		strNum = strNumX;
		strNumX = strNumY;
		strNumY = strNum;
		minusSign = false;
	} else if (strNumX > strNumY && minusSign) {
		minusSign = true;
	}

	var varX = new Array(10);
	var varY = new Array(10);
	var minusValue = 0;
	var addingNum = 0;
	var fixingNum = 0;

	for (var i = 0; i < 10; i++) {
		varX[i] = parseInt(strNumX.substring(3 * i, (3 * i) + 3), 10);
		varY[i] = parseInt(strNumY.substring(3 * i, (3 * i) + 3), 10);
	}

	rtn = "";
	addingNum = 0;
	minusValue = 0;

	for (var i = 9; i >= 0; i--) {
		minusValue = addingNum + 1000 + varX[i] - varY[i];
		addingNum = parseInt(minusValue / 1000, 10) - 1;
		fixingNum = minusValue % 1000;
		rtn = ("000" + fixingNum).slice (-3) + rtn;;  // EasyMath.numberFormat(fixingNum + "", "000") + rtn;
	}

	if (digitsPosition > 0) {
		dotPosFromLeft = rtn.length - digitsPosition;
		rtn = rtn.substring(0, dotPosFromLeft) + "."
				+ rtn.substring(dotPosFromLeft);
	}
	if (rtn.startsWith("."))
		rtn = "0" + rtn;

	rtn = EasyMath.clearFrontZero(rtn);
	rtn = EasyMath.clearBehindZero(rtn);
	if (rtn.startsWith("."))
		rtn = "0" + rtn;
	if (rtn.endsWith("."))
		rtn = rtn.substring(0, rtn.length - 1);

	if (minusSign && rtn != "0")
		rtn = "-" + rtn;

	return rtn;
};

EasyMath.round = function(value, toFixed) {
	if (typeof toFixed == "undefined") toFixed = 0 ;

	if (value instanceof BigNumber){
		return value.toFixed(toFixed, BigNumber.ROUND_HALF_UP);
	}

	// 둘 다 숫자이고, 결과가 지수범위 이내면 바로 결과 리턴 
	if (typeof value == "number"){
		var powerRslt = Math.round(value * Math.pow(10, toFixed));
		var rtn = parseInt(powerRslt) / Math.pow(10, toFixed);
		if (("" + powerRslt).indexOf('e') == -1) {
			return rtn;
		}
	}
	
//	var _value = parseFloat(1.0 * value);
//	var powerRslt = Math.round(_value * Math.pow(10, toFixed));
//	var rtn = parseInt(powerRslt) / Math.pow(10, toFixed);
//	if (("" + powerRslt).indexOf('e') == -1) {
//		return "" + rtn;  // 인수가 문자이면 문자열 리턴
//	}

	if (toFixed >= 0) {
		return EasyMath.clearBehindZero("" + (new BigNumber(value)).toFixed(toFixed, BigNumber.ROUND_HALF_UP));
	} else {
		var _toFixed = (-1) * toFixed;
		var pows = Math.pow(10, _toFixed);
		var rslt = (new BigNumber(value)).div(pows).toFixed(0, BigNumber.ROUND_HALF_UP);
		return EasyMath.clearBehindZero("" + (new BigNumber(rslt)).times(pows));
	}
	
	var strNum = "" + value;

	var rtn = "0000000000" + strNum;
	if (rtn.indexOf('.') == -1)
		rtn += ".0000000000000";
	rtn += "0000000000000";

	var dotPos = rtn.indexOf('.');
	rtn = rtn.substring(0, dotPos) + rtn.substring(dotPos + 1);
	rtn = rtn.substring(0, dotPos + toFixed + 1);

	var charEnd = rtn.charAt(rtn.length - 1);
	rtn = rtn.substring(0, rtn.length - 1);
	if (charEnd >= '5') {
		var len1 = rtn.length;
		rtn = EasyMath.plus(rtn, "1");
		var len2 = rtn.length;

		if (len1 > len2)
			rtn = EasyMath.repeatString("0", len1 - len2) + rtn;
	}
	if (toFixed > 0) {
		dotPos = rtn.length - toFixed;
		rtn = rtn.substring(0, dotPos) + "."
				+ rtn.substring(dotPos);
	} else if (toFixed <= 0) {
		rtn = rtn + EasyMath.repeatString('0', (-1) * toFixed);
	}

	rtn = EasyMath.clearFrontZero(rtn);
	if (rtn.startsWith("."))
		rtn = "0" + rtn;
	if (rtn.endsWith("."))
		rtn = rtn.substring(0, rtn.length - 1);

	return rtn;
};

EasyMath.ceil = function(value, toFixed) {
	
	if (typeof toFixed == "undefined") toFixed = 0 ;
	
	if (value instanceof BigNumber){
		return value.toFixed(toFixed, BigNumber.ROUND_CEIL);
	}
	
	// 둘 다 숫자이고, 결과가 지수범위 이내면 바로 결과 리턴 
	if (typeof value == "number"){
		var powerRslt = Math.ceil(value * Math.pow(10, toFixed));
		var rtn = parseInt(powerRslt) / Math.pow(10, toFixed);
		if (("" + powerRslt).indexOf('e') == -1) {
			return rtn;
		}
	}
	
//	var _value = parseFloat(1.0 * value);
//	var powerRslt = Math.ceil(_value * Math.pow(10, toFixed));
//	var rtn = parseInt(powerRslt) / Math.pow(10, toFixed);
//	if (("" + powerRslt).indexOf('e') == -1) {
//		return "" + rtn;  // 인수가 문자이면 문자열 리턴
//	}
	
	if (toFixed >= 0) {
		return EasyMath.clearBehindZero((new BigNumber(value)).toFixed(toFixed, BigNumber.ROUND_CEIL));
	} else {
		var _toFixed = (-1) * toFixed;
		var pows = Math.pow(10, _toFixed);
		var rslt = (new BigNumber(value)).div(pows).toFixed(0, BigNumber.ROUND_CEIL);
		return EasyMath.clearBehindZero("" + (new BigNumber(rslt)).times(pows));
	}
	
	

	var strNum = "" + value;
	var rtn = "0000000000" + strNum;
	if (rtn.indexOf('.') == -1)
		rtn += ".0000000000000";
	rtn += "0000000000000";

	var dotPos = rtn.indexOf('.');
	rtn = rtn.substring(0, dotPos) + rtn.substring(dotPos + 1);

	rtn = rtn.substring(0, dotPos + toFixed);
	rtn = EasyMath.plus(rtn, "1");

	if (toFixed > 0) {
		dotPos = rtn.length - toFixed;
		rtn = rtn.substring(0, dotPos) + "."
				+ rtn.substring(dotPos);
	} else if (toFixed <= 0) {
		rtn = rtn + EasyMath.repeatString('0', (-1) * toFixed);
	}

	rtn = EasyMath.clearFrontZero(rtn);
	if (rtn.startsWith("."))
		rtn = "0" + rtn;
	if (rtn.endsWith("."))
		rtn = rtn.substring(0, rtn.length - 1);

	return rtn;
};

EasyMath.floor = function(value, toFixed) {
	if (typeof toFixed == "undefined") toFixed = 0 ;
	
	if (value instanceof BigNumber){
		return value.toFixed(toFixed, BigNumber.ROUND_FLOOR);
	}
	
	// 둘 다 숫자이고, 결과가 지수범위 이내면 바로 결과 리턴 
	if (typeof value == "number"){
		var powerRslt = Math.floor(value * Math.pow(10, toFixed));
		var rtn = parseInt(powerRslt) / Math.pow(10, toFixed);
		if (("" + powerRslt).indexOf('e') == -1) {
			return rtn;
		}
	}
	
//	var _value = parseFloat(1.0 * value);
//	var powerRslt = Math.floor(_value * Math.pow(10, toFixed));
//	var rtn = parseInt(powerRslt) / Math.pow(10, toFixed);
//	if (("" + powerRslt).indexOf('e') == -1) {
//		return "" + rtn;  // 인수가 문자이면 문자열 리턴
//	}
//		

	if (toFixed >= 0) {
		return EasyMath.clearBehindZero((new BigNumber(value)).toFixed(toFixed, BigNumber.ROUND_FLOOR));
	} else {
		var _toFixed = (-1) * toFixed;
		var pows = Math.pow(10, _toFixed);
		var rslt = (new BigNumber(value)).div(pows).toFixed(0, BigNumber.ROUND_FLOOR);
		return EasyMath.clearBehindZero("" + (new BigNumber(rslt)).times(pows));
	}
	
	
	var strNum = "" + value;
	var rtn = "0000000000" + strNum;
	if (rtn.indexOf('.') == -1)
		rtn += ".0000000000000";
	rtn += "0000000000000";

	var dotPos = rtn.indexOf('.');
	rtn = rtn.substring(0, dotPos) + rtn.substring(dotPos + 1);

	rtn = rtn.substring(0, dotPos + toFixed);

	if (toFixed > 0) {
		dotPos = rtn.length - toFixed;
		rtn = rtn.substring(0, dotPos) + "."
				+ rtn.substring(dotPos);
	} else if (toFixed <= 0) {
		rtn = rtn + EasyMath.repeatString('0', (-1) * toFixed);
	}

	rtn = EasyMath.clearFrontZero(rtn);
	rtn = EasyMath.clearBehindZero(rtn);

	if (rtn.startsWith("."))
		rtn = "0" + rtn;
	if (rtn.endsWith("."))
		rtn = rtn.substring(0, rtn.length - 1);
	if (rtn == "-0")
		rtn = "0";

	return rtn;
};

EasyMath.abs = function(value) {
	if (value instanceof BigNumber){
		return value.abs();
	}
	if (typeof value == "number"){
		return Math.abs(value);
	}
	return (value + '').replace(/^-/,"");
};


// position 은 1부터 시작 
EasyMath.isDBCSPoint = function(string, position) {
	
	if (position <= 0){
		// 오류처리 ???
		return 0;
	}
	
	var rtn = 0;
	var str = string;
	var pos = 0;
	for (var i = 0; i < str.length; i++) {
		var isDoubleByte = str.charCodeAt(i) > 128;
		pos += isDoubleByte ? 2 : 1;

		if (isDoubleByte && pos == position) {
			rtn = 2;
			break;
		} else if (isDoubleByte && pos > position) {
			rtn = 1;
			break;
		} else if (pos >= position) {
			break;
		}
	}
	return rtn;
};

EasyMath.toString = function(num) {
	return "" + num;
};

EasyMath.isNull = function(source) {
	return source == null;
};

EasyMath.len = function(source) {
	return ("" + source).length;
};

EasyMath.space = function(nCount) {
	var s = "                                                  ";
	var x = "";

	for (var i = 0; i <= Math.floor(nCount / 50); i++) {
		x += s;
	}

	return x.substring(0, nCount);
};

EasyMath.ucase = function(source) {
	return source.toUpperCase();
};

EasyMath.lcase = function(source) {
	return source.toLowerCase();
};

EasyMath.inStr = function(start, source, string) {
	return start + source.substring(start).indexOf(string);
};

EasyMath.replace = function(source, target, string) {
	return source.replace(new RegExp(escapeRegExp(target), "ig"), 	string);
};

EasyMath.replaceFirstOne = function(source, target, string) {
	return source.replace(new RegExp(escapeRegExp(target), "i"), string);
};

EasyMath.replaceNN = function(source, target, string, start, count, binarySearch) {
	var rtn = "";
	var foundCount = 0;
	var replaceCount = 0;
	var posNext = 0;
	var posBefore = 0;
	target = "" + target;
	
	if (!target) {
		return source;
	}
	
	var source1 = source;

	if (binarySearch) {
		source1 = source1.toUpperCase();
		target = target.toUpperCase();
	}
	var pos = source1.indexOf(target);

	while (pos != -1) {

		rtn += source1.substring(posBefore, pos);
		if (++foundCount >= start && replaceCount < count) {
			rtn += string;
			replaceCount++;
		} else {
			rtn += target;
		}

		posBefore = pos + target.length;
		pos = source1.indexOf(target, pos + 1);
	}
	rtn += source.substring(posBefore);

	return rtn;
};

EasyMath.countOfChar = function(source, char) {
	var count = 0;
	
	if (!char) {
		return count;
	}

	var pos = source.indexOf(char);
	while (pos != -1) {
		count++;
		pos = source.indexOf(char, ++pos);
	}
	return count;
};

EasyMath.countOf = function(source, target) {
	target = "" + target;
	var count = 0;
	
	if (!target) {
		return count;
	}
	
	var pos = source.indexOf(target);
	while (pos != -1) {
		count++;
		pos = source.indexOf(target, ++pos);
	}
	return count;
};

EasyMath.trim = function(source) {
	return source.replace(/(^\s*)/, "").replace(/(\s*$)/, "");
};

EasyMath.rTrim = function(source) {
	return source.replace(/(\s*$)/, "");
};

EasyMath.lTrim = function(source) {
	return source.replace(/(^\s*)/, "");
};

EasyMath.lPad = function(strString, strPadChar, nCount) {
	var len = (strString + "").length;
	var str = "";
	for (var i = len; i < nCount; i++)
		str += strPadChar;

	return str + strString;
};

EasyMath.rPad = function(strString, strPadChar, nCount) {
	var len = (strString +"").length;
	var str = "";
	for (var i = len; i < nCount; i++)
		str += strPadChar;

	return strString + str;
};



EasyMath.left = function(source, count) {
	return source.substring(0, count);
};

EasyMath.right = function(source, count) {
	return source.slice((-1)*count);
};

EasyMath.mid = function(source, start, count) {
	return source.substring(start - 1, count + start - 1);
};

EasyMath.isNumeric = function(value) {
	if (typeof value == "number")
		return true;
	if (value.length == 0)
		return false;
	if (EasyMath.countOfChar(value, '.') > 1)
		return false;

	var str = value;
	str = str.trim();

	var rtn = str.replace(/[^0-9.]/g, "") == str
			|| (str.charAt(0) == "-" && str.substring(1).replace(
					/[^0-9.]/g, "") == str.substring(1));
	return rtn;
};

//이 인수에 텍스트가 있으면 TRUE, 없으면 FALSE를 반환한다.
EasyMath.isText = function(value) {
	return !(typeof value == "number" || EasyMath.isNumeric(value));
};


EasyMath.isSign = function(string, position) {
	if (position == 0)
		return true;

	var result = true;
	var pos = position - 1;
	var char = " ";
	var str = "";
	while (0 <= pos) {
		char = string.charAt(pos);
		if (char == " ") {
			pos--;
			continue;
		}

		result = false;

		if (char == "*" || char == "/" || char == "\\" || char == "="
				|| char == ">" || char == "+" || char == "-" || char == "<"
				|| char == "(" || char == ",") {
			result = true;
		}
		if (1 <= pos) {
			str = string.substring(pos - 1, pos + 1).toUpperCase();
			if (str == "OR")
				result = true;
		}
		if (2 <= pos) {
			str = string.substring(pos - 2, pos + 1).toUpperCase();
			if (str == "AND" || str == "MOD" || str == "NOT")
				result = true;
		}
		break;
	}

	return result;
};

EasyMath.val = function(string) {
	return parseFloat(1.0 * string);
};

EasyMath.changeStrB2I = function(boolValue) {
	return (boolValue ? "-1" : "0");
};

EasyMath.checkLike = function(pattern, text) {
	var mask = pattern || "";
	var original = text || "";

	if (mask.indexOf("\\") >= 0)
		mask = mask.replace(/\\/g, "<XXXxxx>");
	if (mask.indexOf("+") >= 0)
		mask = mask.replace(/\+/g, "\\+");
	if (mask.indexOf("$") >= 0)
		mask = mask.replace(/\$/g, "\\$");
	if (mask.indexOf("^") >= 0)
		mask = mask.replace(/\^/g, "\\^");
	if (mask.indexOf(".") >= 0)
		mask = mask.replace(/\./g, "\\.");
	if (mask.indexOf("(") >= 0)
		mask = mask.replace(/\(/g, "\\(");
	if (mask.indexOf(")") >= 0)
		mask = mask.replace(/\)/g, "\\)");
	if (mask.indexOf("[") >= 0)
		mask = mask.replace(/\[/g, "\\[");
	if (mask.indexOf("]") >= 0)
		mask = mask.replace(/\]/g, "\\]");
	if (mask.indexOf("*") >= 0)
		mask = mask.replace(/\*/g, ".*");
	if (mask.indexOf("?") >= 0)
		mask = mask.replace(/\?/g, ".");
	if (mask.indexOf("<XXXxxx>") >= 0)
		mask = mask.replace(/<XXXxxx>/g, "\\\\");

	var re = new RegExp(mask, "g");
	var arrMatched = original.match(re);

	return arrMatched != null && arrMatched[0].length == original.length;

};

EasyMath.pressSpace = function(string) {
	return string.replace(/\s\s+/g, " ");
};

EasyMath.cutString = function(source, strFrom, strTo) {

	var arr = source.split(new RegExp(escapeRegExp(strFrom) + "(.*?)"
			+ escapeRegExp(strTo)));
	var arrReturn = [];
	for (var i = 1; i < arr.length; i += 2) { // 짝수항목
		arrReturn.push(arr[i]);
	}

	return arrReturn;

};

EasyMath.removeString = function(source, strFrom, strTo) {
	var arr = source.split(new RegExp(escapeRegExp(strFrom) + "(.*?)" + escapeRegExp(strTo)));
	var arrReturn = [];
	for (var i = 0; i < arr.length; i += 2) { // 홀수 항목
		arrReturn.push(arr[i]);
	}

	return arrReturn.join("");
};

EasyMath.format = function(target, format) {
	if (format.length == 0) return "";

	if (target instanceof Date){
		return EasyMath.dateFormat(target, format);
	}
	
	target = "" + target;
	if (("" + target).length == 0) return "";

	var rtn = target;
	var length = (format.length < target.length) ? target.length : format.length;
	var type = 0;

	if (format.indexOf('@') >= 0) {
		type = 1;
	} else if (format.indexOf('&') >= 0) {
		type = 1;
	} else if (format.indexOf("YY") != -1 || format.indexOf("MM") != -1
			|| format.indexOf("DD") != -1 || format.indexOf("Hh") != -1
			|| format.indexOf("Nn") != -1 || format.indexOf("Ss") != -1
			|| format.indexOf("mm") != -1 || format.indexOf("dd") != -1
			|| format.indexOf("hh") != -1 || format.indexOf("nn") != -1
			|| format.indexOf("ss") != -1 || format.indexOf("WK") != -1
			|| format.indexOf("wk") != -1) {
		type = 3;
	} else {
		type = 2;
	}

	var arrString = format.split(";");
	var formatCnt = arrString.length;

	if (type == 2) {
		if (target.length == 0) {
			if (formatCnt >= 4)
				rtn = arrString[3];

		} else {
			format = arrString[0];
			if (target == "0") {
				if (formatCnt >= 3)
					format = arrString[0];

			} else if (target.startsWith("-")) {
				if (formatCnt >= 2)
					format = arrString[1];
			}
			rtn = EasyMath.numberFormat(target, format);
		}

	} else if (type == 1) {
		if (target.length == 0) {
			if (formatCnt >= 1)
				rtn = arrString[1];

		} else {
			format = arrString[0];
			rtn = EasyMath.stringFormat(target, format);
		}

	} else if (type == 3) {
		format = arrString[0];
		rtn = EasyMath.dateFormat(target, format);
	}

	return rtn;
};

EasyMath.numberFormat = function(target, format) {
	var rtn = "";
	target = "" + target;
	var left = 0;
	var right = 0;
	var tLeft = 0;
	var tRight = 0;
	var inline = false;
	var negative = false;

	if (target.startsWith("-")) {
		target = target.substring(1);
		negative = true;
	}

	if (format.indexOf('%') >= 0)
		target = EasyMath.multiply(target, "100");

	var pos = format.indexOf('.');
	if (pos == -1) {
		left = format;
		right = "";
	} else {
		left = format.substring(0, pos);
		right = format.substring(pos + 1);
	}

	pos = target.indexOf('.');
	if (pos == -1) {
		tLeft = target;
		tRight = "";
	} else {
		tLeft = target.substring(0, pos);
		tRight = target.substring(pos + 1);
	}

	var count2 = EasyMath.countOfChar(right, '0')
			+ EasyMath.countOfChar(right, '#');
	// 2016-07-07(수정) : 반올림 로직 제외
	// if (count2 > 1){
	// tRight = tRight + "0000000000000";
	// var char = tRight.charAt(count2 - 1);
	// var charEnd = tRight.charAt(count2);
	// tRight = tRight.substring(0, count2 - 1);
	//        
	// if (charEnd >= '5'){
	// tRight = tRight + (++char);
	// } else {
	// tRight = tRight + char;
	// }
	// }

	var count1 = EasyMath.countOfChar(left, '0')
			+ EasyMath.countOfChar(left, '#');
	var length = tLeft.length;
	if (length < count1) {
		tLeft = EasyMath.repeatString('0', count1 - length) + tLeft;
		length = count1;
	} else if (length > count1) {
		pos = left.indexOf('0');
		var posSharp = left.indexOf('#');
		if (pos == -1) {
			pos = posSharp;
		} else if (posSharp > -1 && pos > posSharp) {
			pos = posSharp;
		}
		left = left.substring(0, pos)
				+ EasyMath.repeatString('#', length - count1)
				+ left.substring(pos);
	}
	count1 = left.length;

	var p1 = 0;
	var t1 = 0;
	var pChar = "";
	var tChar = "";
	while (p1 < count1 || t1 < length) {
		if (p1 < count1)
			pChar = left.charAt(p1);
		if (t1 < length)
			tChar = tLeft.charAt(t1);
		if (p1 >= count1) {
			rtn += tChar;
			t1++;

		} else if (pChar == '0') {
			if (tChar == '0') {
				rtn += '0';
			} else {
				rtn += tChar;
			}
			if (tChar != '0')
				inline = true;
			p1++;
			t1++;

		} else if (pChar == '#') {
			if (tChar != '0') {
				rtn += tChar;
			} else if (inline) {
				rtn += tChar;
			}
			if (tChar != '0')
				inline = true;
			p1++;
			t1++;

		} else if (pChar == ',') {
			if (inline)
				rtn += pChar;
			p1++;

		} else {
			rtn += pChar;
			p1++;
		}

	}

	if (count2 > 0)
		rtn += ".";

	count2 = right.length;
	length = tRight.length;
	var p2 = 0;
	var t2 = 0;

	while (p2 < count2) {
		if (p2 < count2)
			pChar = right.charAt(p2);
		if (t2 < length)
			tChar = tRight.charAt(t2);
		if (pChar == '0') {
			if (t2 >= length || tChar == '0') {
				rtn += '0';
			} else {
				rtn += tChar;
			}
			p2++;
			if (t2 < length)
				t2++;

		} else if (pChar == '#') {
			// if (t2 < length && tChar != '0'){ // ex) 1.016 값이 1.16으로 나옴
			if (t2 < length
					&& (tChar != '0' || (tChar == '0' && EasyMath.countOfChar(tRight.substring(t2 + 1), '0') != (length - (t2 + 1))))) {
				rtn += tChar;
			}
			p2++;
			if (t2 < length)
				t2++;
		} else {
			rtn += pChar;
			p2++;
		}
	}

	if (negative) {
		pos = left.indexOf('0');
		var posSharp = left.indexOf('#');
		if (pos == -1) {
			pos = posSharp;
		} else if (posSharp > -1 && pos > posSharp) {
			pos = posSharp;
		}
		rtn = rtn.substring(0, pos) + "-" + rtn.substring(pos);

	}
	if (rtn.endsWith(".")) {
		rtn = rtn.substring(0, rtn.length - 1);
	}

	return rtn;
};

EasyMath.stringFormat = function(target, format) {
	var rtn = "";
	target = "" + target;
	var b2Upper = false;
	var b2Lower = false;
	var b2LAlign = false;
	var inline = false;

	if (format.startsWith("!")) {
		b2LAlign = true;
		format = format.substring(1);
	}

	if (format.startsWith("<")) {
		b2Upper = true;
		format = format.substring(1);
	} else if (format.startsWith(">")) {
		b2Lower = true;
		format = format.substring(1);
	}

	if (format.startsWith("!")) {
		b2LAlign = true;
		format = format.substring(1);
	}

	var length = target.bytes();
	var count = EasyMath.countOfChar(format, '@')
			+ EasyMath.countOfChar(format, '&');
	if (count > length) {
		if (b2LAlign) {
			target = target + EasyMath.repeatString(' ', count - length);
		} else {
			target = EasyMath.repeatString(' ', count - length) + target;
		}
	} else {
		if (b2LAlign) {
			target = EasyMath.leftB(target, count);
		} else {
			target = EasyMath.rightB(target, count);
		}
	}

	var str = target;
	var count = 0;
	var pos = 0;
	var formatPos = 0;
	while (pos < target.length) {
		var char = target.charAt(pos);
		var charCode = target.charCodeAt(pos);

		if (format.charAt(formatPos) == "@") {
			rtn += char;
			pos++;
			formatPos++;
			if (charCode > 128)
				formatPos++;

		} else if (format.charAt(formatPos) == "&") {
			if (char != " ")
				rtn += char;
			pos++;
			formatPos++;
			if (charCode > 128)
				formatPos++;

		} else {
			rtn += format.charAt(formatPos);
			formatPos++;
		}
	}

	if (b2Upper) {
		rtn = rtn.toUpperCase();
	} else if (b2Lower) {
		rtn = rtn.toLowerCase();
	}

	return rtn;
};

EasyMath.dateFormat = function(dateTime, format) {
	var _date = EasyMath.parseDate(dateTime);
	
	// 정수형 일자정보
	var year = _date.getFullYear();
	var month = _date.getMonth() + 1;
	var dates = _date.getDate();
	var hours = _date.getHours();
	var minutes = _date.getMinutes();
	var seconds = _date.getSeconds();
	
	// 문자형 일자정보
	var startsWithMinus = year < 0;
	if (startsWithMinus){
		year = (-1) * year;
	}
	
	var yyyy = ("0000" + year).slice(-4);
	var yy = ("00" + year).slice(-2);
	if (startsWithMinus){
		year = (-1) * year;
		yyyy = "-" + yyyy;
		yy = "-" + yy;
	}
	var mm = ("00" + month).slice(-2);
	var dd = ("00" + dates).slice(-2);
	var hh = ("00" + hours).slice(-2);
	var mn = ("00" + minutes).slice(-2);
	var ss = ("00" + seconds).slice(-2);
	var apm = hours < 12 ? "AM" : "PM";

	var rtn = format;
	if (rtn.indexOf("YYYY") >= 0)
		rtn = rtn.replace(/YYYY/g, yyyy);
	if (rtn.indexOf("YY") >= 0)
		rtn = rtn.replace(/YY/g,   yy);
	if (rtn.indexOf("MM") >= 0)
		rtn = rtn.replace(/MM/g,   mm);
	if (rtn.indexOf("mm") >= 0)
		rtn = rtn.replace(/mm/g,   month);
	if (rtn.indexOf("DD") >= 0)
		rtn = rtn.replace(/DD/g,   dd);
	if (rtn.indexOf("dd") >= 0)
		rtn = rtn.replace("/dd/g", dates);
	if (rtn.indexOf("Hh") >= 0)
		rtn = rtn.replace(/Hh/g,   hh);
	if (rtn.indexOf("hh") >= 0)
		rtn = rtn.replace(/hh/g,   hours);
	if (rtn.indexOf("Nn") >= 0)
		rtn = rtn.replace(/Nn/g,   mn);
	if (rtn.indexOf("nn") >= 0)
		rtn = rtn.replace(/nn/g,   minutes);
	if (rtn.indexOf("Ss") >= 0)
		rtn = rtn.replace(/Ss/g,   ss);
	if (rtn.indexOf("ss") >= 0)
		rtn = rtn.replace(/ss/g,   seconds);
	if (rtn.indexOf("WK") >= 0)
		rtn = rtn.replace(/WK/g,   EasyMath.getWeekCharacter(_date, "L"));
	if (rtn.indexOf("wk") >= 0)
		rtn = rtn.replace(/wk/g,   EasyMath.getWeekCharacter(_date, "S"));
	if (rtn.indexOf("AM/PM") >= 0)
		rtn = rtn.replace(/AM\/PM/g, apm);
	

	return rtn;
};

EasyMath.getWeekCharacter = function (dateTime, isFull) {
	if (typeof isFull == "undefined") isFull = "L";
	
	var _date=  EasyMath.parseDate(dateTime);
	var strings = isFull == "S" ? getText("message_EasyMath_001") : getText("message_EasyMath_002") ;
	var arr = strings.split(",");

	return arr[_date.getDay()];
};


/*
 * =======================================================================
 * "YYYY-MM-DD Hh:Nn:Ss" "YYYY-MM-DD Hh:Nn" "YYYY-MM-DD AM/PM Hh:Nn:Ss"
 * "YYYYMMDD Hh:Nn:Ss" "YYYYMMDD Hh:Nn" "YYYYMMDD AM/PM Hh:Nn:Ss" "YYYY-MM-DD
 * AM/PM Hh:Nn" "YYYY-MM-DD" "YYYYMMDD", "YYMMDD" "Hh:Nn:Ss" "Hh:Nn" "AM/PM
 * Hh:Nn:Ss" "AM/PM Hh:Nn"
 * ========================================================================
 */
EasyMath.parseDate = function(dateTime) {
	if (dateTime instanceof Date){
		return new Date(dateTime);
	}
	
	var jsonDate = {};
	
	if (/\-?[0-9]+\-[0-9]{2}\-[0-9]{2}\sAM\s[0-9]{2}:[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "YYYY-MM-DD AM Hh:Nn:Ss"
		var arr = dateTime.match(/(\-?[0-9]+)\-([0-9]{2})\-([0-9]{2})\sAM\s([0-9]{2}):([0-9]{2}):([0-9]{2})/);
		jsonDate = {year: arr[1], month:arr[2], date:arr[3], hour:arr[4], minute:arr[5], second:arr[6], isAM: true};
	} else if (/\-?[0-9]+\-[0-9]{2}\-[0-9]{2}\sPM\s[0-9]{2}:[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "YYYY-MM-DD PM Hh:Nn:Ss"
		var arr = dateTime.match(/(\-?[0-9]+)\-([0-9]{2})\-([0-9]{2})\sPM\s([0-9]{2}):([0-9]{2}):([0-9]{2})/);
		jsonDate = {year: arr[1], month:arr[2], date:arr[3], hour:arr[4], minute:arr[5], second:arr[6], isAM: false};
	} else if (/\-?[0-9]+\-[0-9]{2}\-[0-9]{2}\s[0-9]{2}:[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "YYYY-MM-DD Hh:Nn:Ss"
		var arr = dateTime.match(/(\-?[0-9]+)\-([0-9]{2})\-([0-9]{2})\s([0-9]{2}):([0-9]{2}):([0-9]{2})/);
		jsonDate = {year: arr[1], month:arr[2], date:arr[3], hour:arr[4], minute:arr[5], second:arr[6], isAM: true};
	} else if (/\-?[0-9]+[0-9]{2}[0-9]{2}\sAM\s[0-9]{2}:[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "YYYYMMDD AM Hh:Nn:Ss"
		var arr = dateTime.match(/(\-?[0-9]+)([0-9]{2})([0-9]{2})\sAM\s([0-9]{2}):([0-9]{2}):([0-9]{2})/);
		jsonDate = {year: arr[1], month:arr[2], date:arr[3], hour:arr[4], minute:arr[5], second:arr[6], isAM: true};
	} else if (/\-?[0-9]+[0-9]{2}[0-9]{2}\sPM\s[0-9]{2}:[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "YYYYMMDD PM Hh:Nn:Ss"
		var arr = dateTime.match(/(\-?[0-9]+)([0-9]{2})([0-9]{2})\sPM\s([0-9]{2}):([0-9]{2}):([0-9]{2})/);
		jsonDate = {year: arr[1], month:arr[2], date:arr[3], hour:arr[4], minute:arr[5], second:arr[6], isAM: false};
	} else if (/\-?[0-9]+[0-9]{2}[0-9]{2}\s[0-9]{2}:[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "YYYYMMDD Hh:Nn:Ss"
		var arr = dateTime.match(/(\-?[0-9]+)([0-9]{2})([0-9]{2})\s([0-9]{2}):([0-9]{2}):([0-9]{2})/);
		jsonDate = {year: arr[1], month:arr[2], date:arr[3], hour:arr[4], minute:arr[5], second:arr[6], isAM: true};
	}
	
	else
	
	if (/\-?[0-9]+\-[0-9]{2}\-[0-9]{2}\sAM\s[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "YYYY-MM-DD AM Hh:Nn"
		var arr = dateTime.match(/(\-?[0-9]+)\-([0-9]{2})\-([0-9]{2})\sAM\s([0-9]{2}):([0-9]{2})/);
		jsonDate = {year: arr[1], month:arr[2], date:arr[3], hour:arr[4], minute:arr[5], isAM: true};
	} else if (/\-?[0-9]+\-[0-9]{2}\-[0-9]{2}\sPM\s[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "YYYY-MM-DD PM Hh:Nn"
		var arr = dateTime.match(/(\-?[0-9]+)\-([0-9]{2})\-([0-9]{2})\sPM\s([0-9]{2}):([0-9]{2})/);
		jsonDate = {year: arr[1], month:arr[2], date:arr[3], hour:arr[4], minute:arr[5], isAM: false};
	} else if (/\-?[0-9]+\-[0-9]{2}\-[0-9]{2}\s[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "YYYY-MM-DD Hh:Nn"
		var arr = dateTime.match(/(\-?[0-9]+)\-([0-9]{2})\-([0-9]{2})\s([0-9]{2}):([0-9]{2})/);
		jsonDate = {year: arr[1], month:arr[2], date:arr[3], hour:arr[4], minute:arr[5], isAM: true};
	} else if (/\-?[0-9]+[0-9]{2}[0-9]{2}\sAM\s[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "YYYYMMDD AM Hh:Nn"
		var arr = dateTime.match(/(\-?[0-9]+)([0-9]{2})([0-9]{2})\sAM\s([0-9]{2}):([0-9]{2})/);
		jsonDate = {year: arr[1], month:arr[2], date:arr[3], hour:arr[4], minute:arr[5], isAM: true};
	} else if (/\-?[0-9]+[0-9]{2}[0-9]{2}\sPM\s[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "YYYYMMDD PM Hh:Nn"
		var arr = dateTime.match(/(\-?[0-9]+)([0-9]{2})([0-9]{2})\sPM\s([0-9]{2}):([0-9]{2})/);
		jsonDate = {year: arr[1], month:arr[2], date:arr[3], hour:arr[4], minute:arr[5], isAM: false};
	} else if (/\-?[0-9]+[0-9]{2}[0-9]{2}\s[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "YYYYMMDD Hh:Nn"
		var arr = dateTime.match(/(\-?[0-9]+)([0-9]{2})([0-9]{2})\s([0-9]{2}):([0-9]{2})/);
		jsonDate = {year: arr[1], month:arr[2], date:arr[3], hour:arr[4], minute:arr[5], isAM: true};
	}	
	
	else
	
	if (/\-?[0-9]+\-[0-9]{2}\-[0-9]{2}$/.test(dateTime)){
		// "YYYY-MM-DD"
		var arr = dateTime.match(/(\-?[0-9]+)\-([0-9]{2})\-([0-9]{2})/);
		jsonDate = {year: arr[1], month:arr[2], date:arr[3], isAM: true};
	} else if (/\-?[0-9]+[0-9]{2}[0-9]{2}$/.test(dateTime)){
		// "YYYYMMDD"
		var arr = dateTime.match(/(\-?[0-9]+)([0-9]{2})([0-9]{2})/);
		jsonDate = {year: arr[1], month:arr[2], date:arr[3], isAM: true};
	} 
	
	else
	
	if (/\AM\s[0-9]{2}:[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "AM Hh:Nn:Ss"
		var arr = dateTime.match(/AM\s([0-9]{2}):([0-9]{2}):([0-9]{2})/);
		jsonDate = {hour:arr[1], minute:arr[2], second:arr[3], isAM: true};
	} else if (/\PM\s[0-9]{2}:[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "PM Hh:Nn:Ss"
		var arr = dateTime.match(/PM\s([0-9]{2}):([0-9]{2}):([0-9]{2})/);
		jsonDate = {hour:arr[1], minute:arr[2], second:arr[3], isAM: false};
	} else if (/[0-9]{2}:[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "Hh:Nn:Ss"
		var arr = dateTime.match(/([0-9]{2}):([0-9]{2}):([0-9]{2})/);
		jsonDate = {hour:arr[1], minute:arr[2], second:arr[3], isAM: true};
	}  
	
	else
	
	if (/\AM\s[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "AM Hh:Nn"
		var arr = dateTime.match(/AM\s([0-9]{2}):([0-9]{2})/);
		jsonDate = {hour:arr[1], minute:arr[2], isAM: true};
	} else if (/\PM\s[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "PM Hh:Nn"
		var arr = dateTime.match(/PM\s([0-9]{2}):([0-9]{2})/);
		jsonDate = {hour:arr[1], minute:arr[2], isAM: false};
	} else if (/[0-9]{2}:[0-9]{2}$/.test(dateTime)){
		// "Hh:Nn"
		var arr = dateTime.match(/([0-9]{2}):([0-9]{2})/);
		jsonDate = {hour:arr[1], minute:arr[2], isAM: true};
	}
	
	var today = new Date();
	
	var year  = (typeof jsonDate.year == "undefined") ? today.getFullYear() : parseInt(jsonDate.year, 10);
	var month = (typeof jsonDate.month == "undefined") ? today.getMonth() : parseInt(jsonDate.month, 10) - 1;
	var day   = (typeof jsonDate.date == "undefined") ? today.getDate() : parseInt(jsonDate.date, 10);

	var hour  = (typeof jsonDate.hour == "undefined") ? 0 : parseInt(jsonDate.hour, 10);
	var minute= (typeof jsonDate.minute == "undefined") ? 0 : parseInt(jsonDate.minute, 10);
	var second= (typeof jsonDate.second == "undefined") ? 0 : parseInt(jsonDate.second, 10);
	if (!jsonDate.isAM) hour+= 12;
	
	return new Date(year, month, day, hour, minute, second);
};

EasyMath.replace2DateTimeType = function(dateTime) {
	var _date = EasyMath.parseDate(dateTime);
	return dateFormat(_date, "YYYY-MM-DD Hh:Nn:Ss");
};

// point는 1부터 시작됨, DBCS는 2바이트 
EasyMath.findNext = function(statement, find, point) {
	if (statement.length <= point || find.length == 0) return -1;
	return statement.indexOf(find, point - 1) + 1; // point는 1부터 시작됨 
};

EasyMath.isLeapYear = function(year) {
	return (new Date(year, 2, 0)).getDate() == 29;
};

EasyMath.daysOfYear = function(year, month, day) {
	var lastYearLastDate = (year - 1) + "1231";
	var TargetDate = "" + year + (month < 10 ? "0" + month : month + '')
			+ (day < 10 ? "0" + day : day + '');

	return EasyMath.dayDiff(lastYearLastDate, TargetDate);
};

EasyMath.yearOf = function(date) {
	return EasyMath.parseDate(date).getFullYear();
};

EasyMath.monthOf = function(date) {
	return EasyMath.parseDate(date).getMonth() + 1;
};

EasyMath.dayOf = function(date) {
	return EasyMath.parseDate(date).getDate();
};


EasyMath.previousMonthYear = function(date) { return EasyMath.beforeYearOf(date);};
EasyMath.beforeYearOf = function(date) {
	var _date = EasyMath.parseDate(date);
	var month =  _date.getMonth() + 1;
	return _date.getFullYear() - (month == 1 ? 1 : 0);
};

EasyMath.previousMonth = function(date) { return EasyMath.beforeMonthOf(date);}
EasyMath.beforeMonthOf = function(date) {
	var _date = EasyMath.parseDate(date);
	var month =  _date.getMonth() + 1;
	return month == 1 ? 12 : month - 1;
};

EasyMath.dayDiff = function(dateFrom, dateTo) {

	var d1 = EasyMath.parseDate(dateFrom);
	var d2 = EasyMath.parseDate(dateTo); 
	
	return Math.round((d2.getTime() - d1.getTime()) / (24 * 60 * 60 * 1000));
};

EasyMath.dateDiff = function(dateFrom, dateTo) {
	return EasyMath.dayDiff(dateFrom, dateTo);
};

EasyMath.timeDiff = function(timeFrom, timeTo) {
	var t1 = EasyMath.parseDate(timeFrom);
	var t2 = EasyMath.parseDate(timeTo); 

//	return Math.round((t2.getTime() - t1.getTime()) / (60 * 60 * 1000));
	return ((t2.getTime() - t1.getTime()) / (60 * 60 * 1000));
};


EasyMath.daysOf = function() {

   	var args = Array.prototype.slice.call(arguments);
   	
   	var year = 0
    var month = 0;
   	if (args.length == 1) {
   		if (args[0] instanceof Date){
   			var date = args[0];
   			year = date.getFullYear();
   			month = date.getMonth() + 1;

   		} else {
   			var str = "" + args[0];
   			year = parseInt(str.substring(0, 4), 10);
   			month = parseInt(str.replace(/\-/g, "").substring(4, 6), 10);
   		}
	
   	} else {
   		year = args[0];
   		month = args[1];
   	}
   	
   	// 다름달로 월로 바꿈 
   	month++;
   	
   	// 다음달의 0일 은 전월의 말일이다 
   	return (new Date(year, month -1, 0)).getDate();
	

};

EasyMath.weekDay = function(date) { return EasyMath.weekDayOf(date); };
EasyMath.weekDayOf = function(date) {
	return EasyMath.parseDate(date).getDay() + 1;
};

/* see common.js */
/*
 * function dayAdd(dateFrom, addCount){}
 */
// 인자를 Date 타입으로 받았으면 Date 타입으로, 문자로 받았으면 문자로 리턴 
EasyMath.dayAdd = function(date, addCount) {
	var _date = EasyMath.parseDate(date);
	_date.setTime(_date.getTime() + (addCount * 1000 * 60 * 60 * 24));

	return date instanceof Date ? _date : _date.getFullYear() + ("00" + (_date.getMonth() + 1)).slice(-2) + ("00" + _date.getDate()).slice(-2);
};

EasyMath.now = function() {
	var dateTime = new Date();
	var target = "" + dateTime.getFullYear() + "-"
			        + ("00" + (dateTime.getMonth() + 1)).slice(-2) + "-"
			        + ("00" + dateTime.getDate()).slice(-2) + " "
			        + ("00" + dateTime.getHours()).slice(-2) + ":"
			        + ("00" + dateTime.getMinutes()).slice(-2) + ":"
			        + ("00" + dateTime.getSeconds()).slice(-2);

	return target;
};

EasyMath.sum = function() {
	var sum = 0;
	var args = Array.prototype.slice.call(arguments);
	
	for (var i = 0; i < args.length; i++){
		if (Array.isArray(args[i])){
			sum += EasyMath.sum.apply(this, args[i]);
		} else {
			var num = "" + args[i];
			if (!EasyMath.isNumeric(num)) return NaN;
			
			sum = EasyMath.plus(sum, num);
		}
	}
	
	sum = "" + (isNaN(sum) ? 0 : sum);
	
	return sum.indexOf('.') >= 0 ? parseFloat(sum, 10) : parseInt(sum, 10);
};

EasyMath.count = function() {
	var count = 0;
	var args = Array.prototype.slice.call(arguments);
	
	for (var i = 0; i < args.length; i++){
		if (Array.isArray(args[i])){
			count += EasyMath.count.apply(this, args[i]); // 수에 전달할 인수 집합 인데 배열로 전달한다. apply는 인수로 보내고 call은 배열로 보낸다.

		} else {
			count++;
		}
	}
	
	return count;
};

EasyMath.avg = function() {

	var args = Array.prototype.slice.call(arguments);
	var count = EasyMath.count(args);
	var sum = EasyMath.sum(args);
	
	if (isNaN(sum)) return NaN; 
	
	var avg = "" + EasyMath.divide(sum, count, 8, false);
	var numbr = avg.indexOf('.') >= 0 ? parseFloat(avg, 10) : parseInt(avg, 10);

	return numbr;
};

EasyMath.max = function() {
	
	var args = Array.prototype.slice.call(arguments);
	if (args.length == 0) return NaN;
	
	var max;
	for (var i = 0; i < args.length; i++){
		
		var num = "" +  (Array.isArray(args[i]) ? EasyMath.max.apply(this, args[i]) : args[i]);
		if (!EasyMath.isNumeric(num)) return NaN;

		var numbr = num.indexOf('.') >= 0 ? parseFloat(num, 10) : parseInt(num, 10);
		if (typeof max == "undefined"){
			max = numbr;
			continue;
		}

		max = (numbr > max) ? numbr :   max;
	}
	
	return max;
};

EasyMath.min = function() {
	
	var args = Array.prototype.slice.call(arguments);
	if (args.length == 0) return NaN;
	
	var min;
	for (var i = 0; i < args.length; i++){
		
		var num = "" +  (Array.isArray(args[i]) ? EasyMath.min.apply(this, args[i]) : args[i]);
		if (!EasyMath.isNumeric(num)) return NaN;

		var numbr = num.indexOf('.') >= 0 ? parseFloat(num, 10) : parseInt(num, 10);
		if (typeof min == "undefined"){
			min = numbr;
			continue;
		}

		min = (numbr < min) ? numbr :   min;
	}
	
	return min;
};


EasyMath.formulaA = function(formula) {
	return (new EXOCalculator()).CalcuratedResult(EasyMath.fillInfoToFormula(formula));
};

/*******************************************************************************
 * 숫자 목록 내에서 지정한 수의 크기 순위를 구한다.
 ******************************************************************************/
EasyMath.rank = function(sheetName, colNumOrId, data) {
	// functionname : [EasyMath.rank]
	
	return controls[sheetName].rank(colNumOrId, data);
};

/*******************************************************************************
 * 10진수 변환
 ******************************************************************************/
// 10진수를 16진수로 변환
EasyMath.dec2Hex = function(numData) {
	// 숫자 형태가 아닐 경우 리턴 false
	if (!/^[-+]?\d+(?:\.\d+)?$/.test(numData))
		return false;

	return (numData).toString(16);
};

// 10진수를 8진수로 변환
EasyMath.dec2Oct = function(numData) {
	// 숫자 형태가 아닐 경우 리턴 false
	if (!/^[-+]?\d+(?:\.\d+)?$/.test(numData))
		return false;

	return (numData).toString(8);
};

// 10진수를 2진수로 변환
EasyMath.dec2Bin = function(numData) {
	// 숫자 형태가 아닐 경우 리턴 false
	if (!/^[-+]?\d+(?:\.\d+)?$/.test(numData))
		return false;

	return (numData).toString(2);
};

/*******************************************************************************
 * 2진수 변환
 ******************************************************************************/
// 2진수를 16진수로 변환
EasyMath.bin2Hex = function(numData) {
	// 2진수 형태가 아닐 경우 리턴 false
	if (!/^[-+]?[01]*$/.test(numData))
		return false;

	// 10진수로 먼저 변환
	var Conver = parseInt((numData).toString(10), 2);
	return (Conver).toString(16);
};

// 2진수를 8진수로 변환
EasyMath.bin2Oct = function(numData) {
	// 2진수 형태가 아닐 경우 리턴 false
	if (!/^[-+]?[01]*$/.test(numData))
		return false;

	var Conver = parseInt((numData).toString(10), 2);
	return (Conver).toString(8);
};

// 2진수를 10진수로 변환
EasyMath.bin2Dec = function(numData) {
	// 2진수 형태가 아닐 경우 리턴 false
	if (!/^[-+]?[01]*$/.test(numData))
		return false;

	return parseInt(numData.toString(10), 2);
};

/*******************************************************************************
 * 16진수 변환
 ******************************************************************************/
// 16진수를 2진수로 변환
EasyMath.hex2Bin = function(numData) {
	return parseInt(numData, 16).toString(2);
};

// 16진수를 8진수로 변환
EasyMath.hex2Oct = function(numData) {
	return parseInt(numData, 16).toString(8);
};

// 16진수를 10진수로 변환
EasyMath.hex2Dec = function(numData) {
	return parseInt(numData, 16).toString(10);

};

/*******************************************************************************
 * 8진수 변환
 ******************************************************************************/
// 8진수를 2진수로 변환
EasyMath.oct2Bin = function(numData) {
	// 숫자 형태가 아닐 경우 리턴 false
	if (!/^[-+]?\d+(?:\.\d+)?$/.test(numData))
		return false;

	var Conver = parseInt((numData).toString(10), 8);
	return (Conver).toString(2);
};

// 8진수를 16진수로 변환
EasyMath.oct2Hex = function(numData) {
	// 숫자 형태가 아닐 경우 리턴 false
	if (!/^[-+]?\d+(?:\.\d+)?$/.test(numData))
		return false;

	var Conver = parseInt((numData).toString(10), 8);
	return (Conver).toString(16);
};

// 8진수를 10진수로 변환
EasyMath.oct2Dec = function(numData) {
	// 숫자 형태가 아닐 경우 리턴 false
	if (!/^[-+]?\d+(?:\.\d+)?$/.test(numData))
		return false;

	return parseInt((numData).toString(10), 8);
};

/*******************************************************************************
 * 문자 아스키코드 로 변환
 ******************************************************************************/
EasyMath.char = function(data) {
	return String.fromCharCode(data);
};

/*******************************************************************************
 * 문자 아스키코드 로 변환 (ex: "１２３４" -> "1234"
 ******************************************************************************/
EasyMath.asc = function(data) {
	var rex = new RegExp("[\uFF10-\uFF19]", "g");

	return data.replace(rex, function(ch) {
	    return String.fromCharCode(ch.charCodeAt(0) - 65248);
	  });
};

/*******************************************************************************
 * 수의 부호값을 반환(양수이면 1을, 0이면 0을, 음수이면 -1을 리턴 )
 ******************************************************************************/
EasyMath.sign = function(numData) {
	// 숫자 형태가 아닐 경우 리턴 false
	if (!/^[-+]?\d+(?:\.\d+)?$/.test(numData))
		return false;

	if (numData > 0)
		return 1;
	else if (numData == 0)
		return 0;
	else if (numData < 0)
		return -1;
};

/*******************************************************************************
 * 각 단어의 첫째 문자를 대문자로 변환하고 나머지 문자는 소문자로 변환
 ******************************************************************************/
EasyMath.proper = function(data) {
	return ("" + data).toLowerCase().replace(/^[a-z]/, function(char){return char.toUpperCase()});
};

/*******************************************************************************
 * 지정한 셀의 데이터가 숫자 값인지 체크 숫자면 true 숫자가 아니면 false 반환
 ******************************************************************************/
EasyMath.isNumber = function(data) {
	return EasyMath.isNumeric(data); //    /^[-+]?\d+(?:\.\d+)?$/.test(data);
};

/*******************************************************************************
 * 지정한 셀의 데이터가 빈 값인지 체크 빈값이면 true 공백문자라도 들어가 있으면 false
 ******************************************************************************/
EasyMath.isBlank = function(data) {
	return /^$/.test(data);
};

/*******************************************************************************
 * RC Range를 참조값으로 비어있는 데이터 갯수 구하기
 ******************************************************************************/
function countBlank(sheetName, strRC) {
	return controls[sheetName].countBlank(strRC);
};

EasyMath.countBlank = function(sheetName, strRC) {
	return controls[sheetName].countBlank(strRC);
};

if (typeof EasySheet == "function")
EasySheet.prototype.countBlank = function(strRC) {
	// functionname : [EasyMath.countBlank]
	var rtn = 0;

	var arrayCells = this._cellsOfRC(strRC);

	for (var i = 0; i < arrayCells.length; i++) {
		if (arrayCells[i] == "") {
			rtn++;
		}
	}
	return rtn;
};

/*******************************************************************************
 * RC Range를 참조값으로 비어있지 않은 데이터 갯수 구하기
 ******************************************************************************/
function countA(sheetName, strRC) {
	return controls[sheetName].countA(strRC);
};
EasyMath.countA = function(sheetName, strRC) {
	// functionname : [EasyMath.countA]
	return controls[sheetName].countA(strRC);
};

if (typeof EasySheet == "function")
EasySheet.prototype.countA = function(strRC) {
	var rtn = 0;

	var arrayCells = this._cellsOfRC(strRC);

	for (var i = 0; i < arrayCells.length; i++) {
		if (arrayCells[i] != "") {
			rtn++;
		}
	}
	return rtn;
};

/*******************************************************************************
 * 인수 값을 지정한 만큼 거듭제곱한 값을 돌려줍니다.   pow(밑, 지수)
 ******************************************************************************/
EasyMath.power = function(numData, numSquared) {

	return Math.pow(numData, numSquared);
/*	
    // bigNum 처리할 것 
	var xNum = numData; // 제곱근
	
	// 숫자 형태가 아닐 경우 리턴 false
	if (!/^[-+]?\d+(?:\.\d+)?$/.test(numData))
		return false;

	for (var i = 0; i < numSquared; i++) {
		numData = numData * xNum;
	}

	return numData;
*/	
};

/*******************************************************************************
 * 텍스트를 지정한 횟수 만큼 반복하여 반환 합니다.
 ******************************************************************************/
EasyMath.rept = function(data, numRepeat) {

	if (data.repeat) {
		return data.repeat(numRepeat);
	}

	return new Array(numRepeat + 1).join(data);

};

/*******************************************************************************
 * 0보다 크거나 같고 1보다 작은, 균등하게 분포된 난수값을 반환합니다.
 ******************************************************************************/
EasyMath.rand = function() {

	return Math.floor(Math.random() * 1000000000) / 1000000000;
};

/*******************************************************************************
 * 지정한 두수 사이의 난수를 정수로 반환합니다.
 ******************************************************************************/
EasyMath.randBetween = function(from, to) {
	return Math.floor((Math.random() * (to - from + 1)) + from);
};

/*******************************************************************************
 * 지정한 양수의 제곱근을 구하여 반환합니다.
 ******************************************************************************/
EasyMath.sqrt = function(numData) {
	// 양수 형태가 아닐 경우 리턴 false
	if (!/^[+]?\d+(?:\.\d+)?$/.test(numData))
		return false;

	return Math.sqrt(numData);
};

/*******************************************************************************
 * 인쇄할 수 없는 모든 문자들을 텍스트에서 제거합니다. ASCII 코드에서 0~31 번, 127, 129, 141, 143, 144, 157
 * 번
 ******************************************************************************/
EasyMath.clean = function(data) {
	return data
			.replace(
					/[\x00-\x1F\xA7\xB6\x203C\x2190\x2191\x2192\x2193\x2194\x2195\x21A8\x2302\x25B2\x25B6\x25BC\x25C0\x25C6\x25CB\x25CF\x25D8\x25D9\x263A\x263B\x263C\x2640\x2642\x2660\x2663\x2665\x266A\x266C\xFFE5]/g,
					"");
	/*
	 * // 아래코딩을 정규식으로 바꾼 것임 var str = data;
	 * 
	 * //문자열을 한단어씩 잘라서 아스키코드로 변환하여 검사 for (var i = 0; i < data.length; i++) { //
	 * 해당 되는 코드값이 있다면 제거 if (str.charCodeAt(i) == 167 || str.charCodeAt(i) ==
	 * 182 || str.charCodeAt(i) == 8252 || str.charCodeAt(i) == 8592 ||
	 * str.charCodeAt(i) == 8593 || str.charCodeAt(i) == 8594 ||
	 * str.charCodeAt(i) == 8595 || str.charCodeAt(i) == 8596 ||
	 * str.charCodeAt(i) == 8597 || str.charCodeAt(i) == 8616 ||
	 * str.charCodeAt(i) == 8962 || str.charCodeAt(i) == 9650 ||
	 * str.charCodeAt(i) == 9654 || str.charCodeAt(i) == 9660 ||
	 * str.charCodeAt(i) == 9664 || str.charCodeAt(i) == 9670 ||
	 * str.charCodeAt(i) == 9675 || str.charCodeAt(i) == 9679 ||
	 * str.charCodeAt(i) == 9688 || str.charCodeAt(i) == 9689 ||
	 * str.charCodeAt(i) == 9786 || str.charCodeAt(i) == 9787 ||
	 * str.charCodeAt(i) == 9788 || str.charCodeAt(i) == 9792 ||
	 * str.charCodeAt(i) == 9794 || str.charCodeAt(i) == 9824 ||
	 * str.charCodeAt(i) == 9827 || str.charCodeAt(i) == 9829
	 *  || str.charCodeAt(i) == 9834 || str.charCodeAt(i) == 9836 ||
	 * str.charCodeAt(i) == 65509) { str.replace(str[i], ""); } }
	 * 
	 * return str;
	 */
};

/*******************************************************************************
 * 주어진 수들의 중간 값을 구합니다. ' , ' 로 구분하여 숫자값을 넣습니다. 값 사이나 앞뒤 끝에 ',' 를 하나 이상 넣더라도 동작엔
 * 상관없습니다. 숫자가 아닌 문자가 들어갈 경우 문자는 무시합니다.
 ******************************************************************************/
EasyMath.median = function() {
	var arr;

	var args = Array.prototype.slice.call(arguments);
	if (args.length == 0) return NaN;
	if (args.length == 1) {
		var data = args[0];
		if (Array.isArray(data)){
			arr = data;
		} else if (typeof data == "Number"){
			return data;
		} else {
			arr = ("" + data).match(/[-+]?\d+(?:\.\d+)?/g); // 숫자값으로만 
			if (arr == null) arr = [];
		}
	} else {
		arr = args;
	}
	
	arr.sort(function(a, b) {
		return (a - b);
	});
	
	var count = arr.length;
	if (count == 0) return false; 
	if (count == 1) { 
		return arr[0] * 1; 
	} 
	
	var medianIndex = (count - (count % 2)) / 2 - 1;
	
	if (count % 2 == 1) {
		return arr[medianIndex + 1] * 1;
	} else {
		return ((arr[medianIndex] * 1) + (arr[medianIndex + 1] * 1)) / 2;
	}

	return null;
};

/*******************************************************************************
 * 주어진 조건에 의해 지정된 셀들의 합을 구합니다. (col번호,'>=data')
 ******************************************************************************/
EasyMath.sumIf = function(sheetName, colNumOrId, formula) {
	return controls[sheetName].sumIf(colNumOrId, formula);
};

/*******************************************************************************
 * 텍스트 형태의 날짜를 숫자 값으로 변환합니다. 1900-01-01 부터 9999-12-31 까지의 날짜를 숫자 값으로 변환합니다.
 * 1900-01-01 이 숫자값 '1', 9999-12-31 이 숫자값 '2958465' 입니다. yyyymmdd 또는 yyyy-mm-dd
 * 형식으로 넣어 줍니다.
 ******************************************************************************/
EasyMath.dateValue = function(date) {
	// 자바스크립트 dateValue 1970-01-01 부터 0 으로 시작
	// 엑셀 dateValue 1900-01-01 부터 1 로 시작
	// 70년 하고 하루가 차이난다.
	// 1970 에서 70년 하루 를 뺀 날짜를 기준으로 하여 70년 하루치를 더해준다.
	
	var firstDate = new Date(1899, 11,30); // 기준일
	var lastdate =  EasyMath.parseDate(date);

	return Math.floor((lastdate - firstDate) / (1000 * 60 * 60 * 24));
};

/*******************************************************************************
 * 지정한 셀의 데이터의 값에 에러가 발생했는지 체크 합니다.
 ******************************************************************************/
EasyMath.isError = function(data) { // 잘못 생각임 최종연산 상태를 기억하고 있어야 함, 시트함수이어야 함

	var rtn = "";
    if (data.toUpperCase() === "#REF" || data.toUpperCase() === "##NAN")  return true;
    if (isNaN(data)) return true;
	
	try {
		eval(data); // eval 메소드로 실행

	} catch (err) {

		rtn = err.emssage; // 에러 발생시 에러 메세지를 담는다.

	}

	return rtn;
};

/*******************************************************************************
 * 지정한 주가 일 년 중 몇째 주인지를 나타내는 숫자를 반환합니다. 첫번째 인수(data) 에 년월일 날짜를 두번째 인수(mode) 에 1
 * 또는 2의 숫자값을 넣습니다. 1은 한주의 시작을 일요일로 설정 2는 한주의 시작을 월요일로 설정 합니다.
 ******************************************************************************/
EasyMath.weekNum = function(date, mode) {
	var _date = EasyMath.parseDate(date);
	
	
	  var d = new Date(Date.UTC(_date.getFullYear(), _date.getMonth(), _date.getDate()));
	  var dayNum = d.getUTCDay() || 7;
	  d.setUTCDate(d.getUTCDate() + 4 - dayNum);
	  var yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
	  var weeks = Math.ceil((((d - yearStart) / 86400000) + 1)/7);
	  if (_date.getDay() == 0) weeks++;
	  
	  return weeks;	
};

/*******************************************************************************
 * 텍스트 형태의 시간을 Sheet 일련 번호로 표현한 시간으로 돌려 줍니다. 값은 0( 00:00:00 )부터 0.999988426(
 * 23:59:59 )입니다. 24시간을 1 로 설정합니다. 오전 12 시는 24시간의 절반 이므로 0.5의 값이 나옵니다. 인수는
 * '23:11:59' 또는 '231159' 로 넣습니다.
 ******************************************************************************/
EasyMath.timeValue = function(date) {
	var _date = EasyMath.parseDate(date);

	var hh = _date.getHours(); 	// 시
	var mm = _date.getMinutes(); // 분
	var ss = _date.getSeconds(); // 초

	var vTime = (hh * 60 * 60) + (mm * 60) + (ss * 1); // 전체 초

	return Math.round((vTime / 86400) * 1000000000) / 1000000000; // 24시간은 1을 기준으로 나누고 9번째까지 반올림
};

EasyMath.IIf = function(condition, trueStatement, falseStatement) {
	return condition ? trueStatement : falseStatement;
};

/*******************************************************************************
 * 다른 단위 체계의 숫자로 변환합니다. 첫번째 인수에는 변환할 값 두번째 인수에는 현재 단위 세번째 인수는 바꿀 단위 입니다. 두번째 와
 * 세번째 인수에 변환 할 수 없는 데이터 형이 들어올경우 false 를 반환 합니다. 대소문자 구분을 하지 않습니다.
 ******************************************************************************/
EasyMath.convert = function(numData, from, to) {
	from = from.toLowerCase();
	to = to.toLowerCase();

	var distanceNames = {
			"센티미터": 0, "cm": 0, 
			"미터": 1, "m": 1,
			"인치": 2, "inch": 2,
			"피트": 3, "feet": 3,
			"야드": 4, "yard": 4,
			"마일": 5, "mile": 5,
			"자": 6, "척":6, "尺":6,
			"간": 7, "間": 7, 
			"정": 8, "町": 8,
			"리": 9, "里":9
			};
	var distanceTable = [
						[1, 0.01, 0.393701, 0.032808, 0.010936, 0.0000062137, 0.033, 0.0055, 0.000092, 0.00025], 
						[100, 1, 39.370079, 3.28084, 1.093613, 0.000621, 3.3, 0.55, 0.009167, 0.002546], 
						[2.54, 0.0254, 1, 0.083333, 0.027778, 0.000016, 0.08382, 0.01397, 0.000233, 0.000065], 
						[30.48, 0.3048, 12, 1, 0.333333, 0.000189, 1.00584, 0.16764, 0.002794, 0.000776], 
						[91.44, 0.9144, 36, 3, 1, 0.000568, 3.01752, 0.50292, 0.008382, 0.002328], 
						[160934.4, 1609.344, 63360, 5280, 1760, 1, 5310.8352, 885.1392, 14.75232, 4.097867], 
						[30.30303, 0.30303, 11.930327, 0.994194, 0.331398, 0.000188, 1, 0.166667, 0.002778, 0.000772], 
						[181.818182, 1.818182, 71.581961, 5.965163, 1.988388, 0.00113, 6, 1, 0.016667, 0.00463], 
						[10909.0909, 109.090909, 4294.91768, 357.909807, 119.303269, 0.067786, 360, 60, 1, 0.277778], 
						[39272.7273, 392.727273, 15461.7037, 1288.4753, 429.491768, 0.244029, 1296, 216, 3.6, 1]
					];
	var areaNames = {
			"평방자":0, 
			"평": 1,
			"단보":2,
			"정보":3,
			"제곱미터": 4, "m2": 4,
			"아르": 5, "a": 5,
			"제곱피트":6, "ft2": 6,
			"제곱야드":7, "yd2": 7,
			"에이커": 8, "acre": 8
			};
	var areaTable = [
						[1, 0.027778, 0.000093, 0.0000092593, 0.091827, 0.000918, 0.988422, 0.109825, 0.000023],
						[36, 1, 0.003333, 0.000333, 3.305785, 0.033058, 35.583175, 3.953686, 0.000817],
						[10800, 300, 1, 0.1, 991.735537, 9.917355, 10674.9525, 1186.10583, 0.245063],
						[108000, 3000, 10, 1, 9917.35537, 99.173554, 106749.525, 11861.0583, 2.450632],
						[10.89, 0.3025, 0.001008, 0.000101, 1, 0.01, 10.76391, 1.19599, 0.000247],
						[1089, 30.25, 0.100833, 0.010083, 100, 1, 1076.39104, 119.599005, 0.024711],
						[1.011714, 0.28103, 0.000094, 0.0000093677, 0.092903, 0.000929, 1, 0.111111, 0.000023],
						[9.105427, 0.252929, 0.000843, 0.000084, 0.836127, 0.008361, 9, 1, 0.000207],
						[44070.2664, 1224.17407, 4.08058, 0.408058, 4046.85642, 40.468564, 43560, 4840, 1]
					];
	var volumeNames = {
						"홉": 0, "合":0,
						"되": 1, "升":1,
						"말": 2, "斗":2,
						"㎤": 3, "cm3": 3,"cc": 3, "㎖": 3, "ml": 3,
						"㎥": 4, "m3": 4,
						"리터": 5, "ℓ": 5,
						"세제곱인치": 6, "in3": 6,
						"세제곱피트": 7, "ft3": 7,
						"세제곱야드": 8, "yd3": 8,
						"갤런": 9, "ga": 9
					};
	var volumeTable = [
						[1 ,0.1 ,0.01 ,180.39 ,0.00018 ,0.18039 ,11.008073 ,0.00637 ,0.000236 ,0.047654],
						[10 ,1 ,0.1 ,1803.9 ,0.001804 ,1.8039 ,110.080732 ,0.063704 ,0.002359 ,0.47654],
						[100 ,10 ,1 ,18039 ,0.018039 ,18.039 ,1100.80732 ,0.637041 ,0.023594 ,4.7654],
						[0.005544 ,0.000554 ,0.000055 ,1 ,0.000001 ,0.001 ,0.061024 ,0.000035 ,0.000001308 ,0.000264],
						[5543.54454 ,554.354454 ,55.435445 ,1000000 ,1 ,1000 ,61023.7441 ,35.314667 ,1.307951 ,264.172052],
						[5.543545 ,0.554354 ,0.055435 ,1000 ,0.001 ,1 ,61.023744 ,0.035315 ,0.001308 ,0.264172],
						[0.090842 ,0.009084 ,0.000908 ,16.387064 ,0.000016 ,0.016387 ,1 ,0.000579 ,0.000021 ,0.004329],
						[156.9757 ,15.69757 ,1.569757 ,28316.8466 ,0.028317 ,28.316847 ,1728 ,1 ,0.037037 ,7.480519],
						[4238.34391 ,423.834391 ,42.383439 ,764554.858 ,0.764555 ,764.554858 ,46656 ,27 ,1 ,201.974026],
						[,20.984599 ,2.09846 ,0.209846 ,3785.41178 ,0.003785 ,3.785412 ,231 ,0.133681 ,0.004951 ,1]
					];
	var weightNames = {
						"그램": 0, "g": 0,
						"킬로그램": 1, "kg": 1,
						"톤": 2, "ton": 2,
						"그레인": 3, "gr": 3,
						"온스": 4, "oz": 4,
						"파운드": 5, "lb": 5,
						"돈": 6,
						"근": 7, "斤": 7,
						"관": 8, "貫": 8,
						"냥": 9, "兩": 9
					};
	var weightTable = [
						[1, 0.001, 0.000001, 15.432358, 0.035274, 0.002205, 0.266667, 0.001667, 0.000267, 0.026667],
						[1000, 1, 0.001, 15432.3584, 35.273962, 2.204623, 266.666667, 1.666667, 0.266667, 26.666667],
						[1000000, 1000, 1, 15432358.4, 35273.9619, 2204.62262, 266666.667, 1666.66667, 266.666667, 26666.6667],
						[0.064799, 0.000065, 0.000000064799, 1, 0.002286, 0.000143, 0.01728, 0.000108, 0.000017, 0.001728],
						[28.349523, 0.02835, 0.000028, 437.5, 1, 0.0625, 7.559873, 0.047249, 0.00756, 0.755987],
						[453.59237, 0.453592, 0.000454, 7000, 16, 1, 120.957965, 0.755987, 0.120958, 12.095797],
						[3.75, 0.00375, 0.00000375, 57.871344, 0.132277, 0.008267, 1, 0.00625, 0.001, 0.1],
						[600, 0.6, 0.0006, 9259.41501, 21.164377, 1.322774, 160, 1, 0.16, 16],
						[3750, 3.75, 0.00375, 57871.3438, 132.277357, 8.267335, 1000, 6.25, 1, 100],
						[37.5, 0.0375, 0.000038, 578.713438, 1.322774, 0.082673, 10, 0.0625, 0.01, 1]
					];
	
	var pressureNames = {
						"기압": 0, "atm": 0,
						"파스칼": 1, "pa": 1,
						"킬로파스칼": 2, "kpa": 2,
						"dyne/cm2": 3, 
						"바": 4, "bar": 4,
						"kgf/cm2": 5, 
						"프사이": 6, "psi": 6, 
						"mmhg": 7,
						"inchhg": 8,
						"mmh2o": 9
					};
	var pressureTable = [
						[1,101325, 101.325, 1013250, 1.01325, 1.033227, 14.696, 760, 29.92126, 10332.2676],
						[0.0000098692, 1,0.001, 10, 0.00001, 0.00001, 0.000145, 0.007501, 0.000295, 0.101972],
						[0.009869, 1000, 1,10000, 0.01, 0.010197, 0.145038, 7.500617, 0.2953, 101.971553],
						[0.000000986923, 0.1, 0.0001, 1, 0.000001, 0.0000010197, 0.000015, 0.00075, 0.00003, 0.010197],
						[0.986923, 100000, 100, 1000000, 1, 1.019716, 14.503824, 750.061683, 29.529988, 10197.1553],
						[0.967841, 98066.5, 98.0665, 980665, 0.980665, 1,14.223393, 735.55924, 28.959025, 9999.99326],
						[0.068046, 6894.73326, 6.894733, 68947.3326, 0.068947, 0.070307, 1,51.714752, 2.036014, 703.066655],
						[0.001316, 133.322368, 0.133322, 1333.22368, 0.001333, 0.00136, 0.019337, 1,0.03937, 13.5950889],
						[0.033421, 3386.38816, 3.386388, 33863.8816, 0.033864, 0.034532, 0.491156, 25.4, 1,345.315258],
						[0.000097, 9.806657, 0.009807, 98.066566, 0.000098, 0.0001, 0.001422, 0.073556, 0.002896, 1]
					];
	
	
	var speedNames = {
						"m/s": 0, 
						"m/h": 1,
						"km/s": 2,
						"km/h": 3,
						"ft/s": 4,
						"ft/h": 5,
						"mi/s": 6,
						"mi/h": 7,
						"노트": 8, "kn": 8,
						"마하": 9, "mach": 9
					};
	var speedTable = [
						[1 ,3600, 0.001, 3.6, 3.28084, 11811.0236, 0.000621, 2.236936, 1.943844, 0.002941],
						[0.000278, 1, 0.00000027778, 0.001, 0.000911, 3.28084, 0.0000001726, 0.000621, 0.00054, 0.00000081699],
						[1000, 3600000, 1, 3600, 3280.8399, 11811023.6, 0.621371, 2236.93629, 1943.84449, 2.941176],
						[0.277778, 1000, 0.000278, 1, 0.911344, 3280.8399, 0.000173, 0.621371, 0.539957, 0.000817],
						[0.3048, 1097.28, 0.000305, 1.09728, 1, 3600, 0.000189, 0.681818, 0.592484, 0.000896],
						[0.000085, 0.3048, 0.000000084667, 0.000305, 0.000278, 1, 0.000000052609, 0.000189, 0.000165, 0.00000024902],
						[1609.344, 5793638.4, 1.609344, 5793.6384, 5280, 19008000, 1, 3600, 3128.31447, 4.733365],
						[0.44704, 1609.344, 0.000447, 1.609344, 1.466667, 5280, 0.000278, 1, 0.868976, 0.001315],
						[0.514444, 1852, 0.000514, 1.852, 1.68781, 6076.11549, 0.00032, 1.150779, 1, 0.001513],
						[340, 1224000, 0.34, 1224, 1115.48556, 4015748.03, 0.211266, 760.558339, 660.907127, 1]
					];
	
	var dataUintNames = {
						"비트": 0, "bit": 0,
						"바이트": 1, "b": 1,
						"킬로바이트": 2, "kb": 2,
						"메가바이트": 3, "mb": 3,
						"기가바이트": 4, "gb": 4,
						"테라바이트": 5, "tb": 5
					};
	var dataUintTable = [
						[1, 0.125, 0.000122, 0.00000011921, 0.00000000001642, 0.00000000000011369],
						[8, 1, 0.000977, 0.00000095367, 0.00000000093132, 0.00000000000090949],
						[8192, 1024, 1, 0.000977, 0.00000095367, 0.00000000093132],
						[8388608, 1048576, 1024, 1, 0.000977, 0.00000095367],
						[8589900000, 1073700000, 1048576, 1024, 1, 0.000977],
						[8796100000000, 1099500000000, 1073700000, 1048576, 1024, 1]
					];


	var names =  (from in distanceNames && to in distanceNames) ? distanceNames : 
		         (from in areaNames && to in areaNames) ? areaNames : 
			     (from in volumeNames && to in volumeNames) ? volumeNames : 
				 (from in weightNames && to in weightNames) ? weightNames : 
				 (from in pressureNames && to in pressureNames) ? pressureNames : 
				 (from in speedNames && to in speedNames) ? speedNames : 
				 (from in dataUintNames && to in dataUintNames) ? dataUintNames : 
		        	 null;
	var table =  (from in distanceNames && to in distanceNames) ? distanceTable : 
		         (from in areaNames && to in areaNames) ? areaTable : 
			     (from in volumeNames && to in volumeNames) ? volumeTable : 
				 (from in weightNames && to in weightNames) ? weightTable : 
				 (from in pressureNames && to in pressureNames) ? pressureTable : 
				 (from in speedNames && to in speedNames) ? speedTable : 
				 (from in dataUintNames && to in dataUintNames) ? dataUintTable : 
		        	 null;
	
	if (names == null){
		return null;
	}

	var ndxFrom = names[from];
	var ndxTo = names[to];

	return parseFloat(1 * numData) * table[ndxFrom][ndxTo];
};


//===== double-byte character set =======

EasyMath.lenB = function(source) {
	return EasyMath.DBCS.len.apply(this, arguments);
};
EasyMath.leftB = function(source, count) {
	return EasyMath.DBCS.left.apply(this, arguments);
};
EasyMath.rightB = function(source, count) {
	return EasyMath.DBCS.right.apply(this, arguments);
};
EasyMath.midB = function(source, start, count) {
	return EasyMath.DBCS.mid.apply(this, arguments);
};
EasyMath.instrB = function(source, target, startPos, binarySearch) {
	return EasyMath.DBCS.instr.apply(this, arguments);
};
EasyMath.len = function(source) {
	return EasyMath.DBCS.len.apply(this, arguments);
};
EasyMath.findNextB = function(statement, find, point) {
	return EasyMath.DBCS.findNext.apply(this, arguments);
};




EasyMath.DBCS.len = function(source) { 
	return ("" + source).byteLength(); 
};

EasyMath.DBCS.left = function(source, count) {
	if (count <= 0){
		return "";
	}
	
	var rtn = source;
	var str = source;
	var cnt = 0;
	for (var i = 0; i < str.length; i++) {
		var isDoubleByte = str.charCodeAt(i) > 128;
		cnt += isDoubleByte ? 2 : 1;

		if (isDoubleByte && cnt > count) {
			rtn = str.substring(0, i) + " ";
			break;
		} else if (cnt >= count) {
			rtn = str.substring(0, i + 1);
			break;
		}
	}
	return rtn;
};

EasyMath.DBCS.right = function(source, count) {
	if (count <= 0){
		return "";
	}

	var rtn = source;
	var str = source;
	var cnt = 0;
	for (var i = str.length - 1; i > 0; i--) {
		var isDoubleByte = str.charCodeAt(i) > 128;
		cnt += isDoubleByte ? 2 : 1;

		if (isDoubleByte && cnt > count) {
			rtn = str.substring(i + 1);
			break;
		} else if (cnt >= count) {
			rtn = str.substring(i);
			break;
		}
	}
	return rtn;
};

EasyMath.DBCS.mid = function(source, start, count) {
	if (count <= 0){
		return "";
	}

	var rtn = "";
	var str = source;
	var cocntunt = 0;
	var startPoint = -1;
	var endPoint = source.length;

	var cnt = 0;
	for (var i = 0; i < str.length; i++) {
		var isDoubleByte = str.charCodeAt(i) > 128;
		cnt += isDoubleByte ? 2 : 1;

		if (cnt > start && startPoint == -1) {
			startPoint = i;
		}

		if (cnt >= start + count) {
			endPoint = i;
			break;
		}

	}
	rtn = str.slice(startPoint, endPoint);

	return rtn;
};

EasyMath.DBCS.instr = function(source, target, startPos, binarySearch) {
	var rtn = 0;
	var pos = 0;
	var startPoint = 0;
	var str = source;
	var count = 0;
	var target = "" + target;

	for (var i = 0; i < str.length; i++) {
		count += (str.charCodeAt(i) > 128) ? 2 : 1;

		if (count >= startPos) {
			startPoint = i;
			break;
		}
	}

	if (binarySearch) {
		pos = source.toUpperCase().indexOf(target.toUpperCase(), startPoint);
	} else {
		pos = source.indexOf(target, startPoint);
	}
	if (pos == -1) {
		rtn = 0;
	} else {
		for (var i = 0; i <= pos; i++)
			rtn += (str.charCodeAt(i) > 128) ? 2 : 1;
	}
	
	if (target.charCodeAt(0) > 128) rtn--;  // 2 BYTE중  앞위치

	return rtn;
};

EasyMath.DBCS.findNext = function(statement, find, point) {
	if (statement.length <= point || find.length == 0) return -1;
	
	point = EasyMath.leftB(statement, point).length;
	point = statement.indexOf(find, point);
	
	return EasyMath.lenB(statement.slice(0, point)) + 1; 
};




//===== 
EasyMath.fillInfoToFormula = function(formula){
	formula = formula
	            .replace(new RegExp(escapeRegExp("[" + getText("message_usr_personalid", "사용자.사번") + "]"), "ig"), 	USER_PERSONALID)
			    .replace(new RegExp(escapeRegExp("[" + getText("message_usr_personname", "사용자.성명") + "]"), "ig"), 	"\"" + USER_PERSONALNAME+ "\"")
			    .replace(new RegExp(escapeRegExp("[" + getText("message_usr_cogu", "사용자.회사") 		 + "]"), "ig"), USER_COGU)
			    .replace(new RegExp(escapeRegExp("[" + getText("message_usr_bon", "사용자.사업장") 		 + "]"), "ig"), USER_BON)
			    .replace(new RegExp(escapeRegExp("[" + getText("message_usr_part", "사용자.부서") 		 + "]"), "ig"), USER_PART)
			    .replace(new RegExp(escapeRegExp("[" + getText("message_usr_organ", "사용자.조직") 		 + "]"), "ig"), USER_ORGANIZATION)
			    .replace(new RegExp(escapeRegExp("[" + getText("message_usr_date", "사용자.일자") 		 + "]"), "ig"), "\"" + USER_DATE+ "\"")
			    .replace(new RegExp(escapeRegExp("[" + getText("message_usr_month", "사용자.년월") 		 + "]"), "ig"), USER_MONTH)
			    .replace(new RegExp(escapeRegExp("[" + getText("message_usr_year", "사용자.년도") 		 + "]"), "ig"), USER_YEAR)
			    .replace(new RegExp(escapeRegExp("[" + getText("message_usr_seq", "사용자.순번") 		 + "]"), "ig"), USER_SEQ)
			    .replace(new RegExp(escapeRegExp("[" + getText("message_usr_time", "사용자.시간") 		 + "]"), "ig"), "\"" + USER_TIME+ "\"")
			    .replace(new RegExp(escapeRegExp("[" + getText("message_usr_userId", "사용자.아이디") 	 + "]"), "ig"), "\"" + USER_USERID+ "\"")
			    .replace(new RegExp(escapeRegExp("[" + getText("message_usr_ipAddr", "사용자.아이피주소") + "]"), "ig"), "\"" + USER_USERIP+ "\"");
	
	for (var id in controls) {
		if (typeof controls[id] =="function") continue;
		
		var control = controls[id];
		var controlString = getText("message_str_control", "콘트롤");
		var controlName = control.controlName;
		
		if (control instanceof DataSheet || control instanceof EasySheet || control instanceof AUIDataSheet){
			for (var colNum0 = 0; colNum0 < control.maxCols; colNum0++){
				var colNum = colNum0 + this.startRowColNum;
				var colNum1 = colNum0 + 1;
				
				var column = control.columns[colNum0];
				cellType = control instanceof EasySheet ? column.cellType : column.defaultCellType;  // 셀타입 변수명 바뀜
				var isNumberCell = [CELLTYPE_NUMBER, CELLTYPE_PERCENT, CELLTYPE_INTEGER, CELLTYPE_BAR, CELLTYPE_CURRENCY, CELLTYPE_FLOAT, CELLTYPE_CHECKBOX].indexOf(cellType) >= 0;
				
				if (isNumberCell){
					formula = formula.replace(new RegExp(escapeRegExp("[" + controlString + "." + controlName + "." + colNum1 + "]"), "ig"), "" + control.getValue(colNum));
				} else {
					formula = formula.replace(new RegExp(escapeRegExp("[" + controlString + "." + controlName + "." + colNum1 + "]"), "ig"), "\"" + control.getValue(colNum) + "\"");
				}
			}
		} 
		if (control instanceof CheckBox || 
			control instanceof ComboBox || 
			control instanceof ListBox  || 
			control instanceof ListBoxW || 
			control instanceof Label    || 
			control instanceof TextBox  || 
			control instanceof OptionButton){
			
			var value = control.value;
			if (typeof value != "number") value = "\"" + value + "\"";
			
			formula = formula.replace(new RegExp(escapeRegExp("[" + controlString + "." + controlName + "]"), "ig"), value);
		} 
	}
	for (var id in parameters) {
		if (typeof(parameters[id])=="function") continue;
		
		var paramString = getText("message_str_parameter","파라메터");
		
		var value = parameters[id];
		if (typeof value != "number") value = "\"" + value + "\"";
		formula = formula.replace(new RegExp(escapeRegExp("[" + paramString + "." + id + "]"), "ig"), value);
		
	}
	for (var id in objects) {
		if (typeof(objects[id])=="function") continue;
		
		var object = objects[id];
		
		for (var ndx = 1; ndx <= object.propertyCount; ndx++){
			var propertyId = object.propertyInfos[ndx].id;
			var propertyName = object.propertyInfos[ndx].name;
			
			var value = object.propertyInfos[ndx].isNumericType ? object.getValue(propertyId) 
					                                            : "\"" + object.getValue(propertyId) + "\"";
			
			formula = formula.replace(new RegExp(escapeRegExp("[" + object.name + "." + propertyName + "]"), "ig"), value);
		}
	}
	return formula;
};
/**
 * @description	미결
 * @param		{String}	String
 * @return		{Object}
 * @example		미결
 */
function escapeRegExp(string) {
	return string.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1"); 

	// 사용방법
	// var s = '';
	// new RegExp(escapeRegExp(s));
};
/**
 * @description	미결
 * @param		{String}	String
 * @return		{Object}
 * @example		미결
 */
function escapeJSON(string) {
	return string.replace(/\'/g, "\"").replace(/[\u0000-\u0019]+/g,""); 

	// 사용방법
	// var s = '';
	// new JSON.parse(escapeJSON(s));
};

// EASYMATH의 모든 함수는 대문자로도 가능하도록 대문자 함수 변환
// 예를 들어 EasyMath.formulaA() -> EasyMath.FORMULAA()
for ( var functionName in EasyMath) {
	EasyMath[functionName.toUpperCase()] = EasyMath[functionName];
}

// 미결사항: easysheet와 DataSheet 동작구분 
// 긴 숫자의 문자열 리턴시 숫자 처리문제 
/**
 * 
 * jsonObject ={id:"aaa", datasettype="EasySumUp",
 *              colinfos:[{id:"code", size:"256", type:"STRING"}, {id:"name", size:"256", type:"STRING"}],
 *              datas:[{code:1, name:"코드"}, {code:2, name:"명"}] }
 */

function EasySumUp(sheet) // constructor
{
	this.sheet = sheet;   
	this.dataSet= sheet.dataSet;   

	this.colInfos = {};
	for (var i = 0; i < sheet.columns.length; i++){
		var column = sheet.columns[i];
		this.colInfos[column.colId] = column;
	}    
	
	this._groupKey= "";         // Dataset의 GroupKey
	this._jsonGroupKey = [];      // 사용예 "A:B,C,D" 인 경우   [["A","B"],"C","D"]
	this._needGroupKey = [];      // 사용예 2레벨을 출력 않는 경우  [true, false, true]

	this._suspand = false;
};

/** 
 * @description 
 *     셀에 입력된 산식을 건증할 기중을 등록한다 <br/>
 *     - 블럭을 지정해서 설정할 수도 잆고, 칼럼번호를 정해서 설정할 수 도 있다.<br/>  
 *     - 산식타입이 아닌 경우에도 체크산식과 메시지를 병행 할 수 있다 
 *     
 * @param {String}										sumMethod	        - 합계 필드 집계 방법 (SUM함수 + ":" + 집계할산식)<br/> "SUM", "AVG", "MIN", "COUNT", "MAX", "TEXT:소계"
 * @param {String|String[]|Number|Number[]|undefined}	[colRange=Block Rage]	- 체크조건을 부여할 셀영역이다. <br/>
 * 
 * @return {void} 	
 */
EasySumUp.prototype.setSumMethod = function(sumMethod, colRange){
    // functionname : [EasySheet.setRowFormula]
	
	//열 범위 구함
	var colRangeObj = this.sheet.getColRange(colRange, "setSumMethod");
	
	//열 범위를 못 구한 경우
	if (colRangeObj == null) return;
	
	var targetColNums = colRangeObj.targetColNums;
	var controlString = getText("message_str_control", "콘트롤");

	
	//컬럼정보 속성 적용
	for(i = 0; i < targetColNums.length; i++){
		var colNum = targetColNums[i];
		this.sheet.setColumnAttributes(colNum, "sumMethod", sumMethod);		
	}
	
    return;
};

EasySumUp.prototype._updateFormula = function(formula){
	if (formula.trim().length != 0) {
		return this.sheet._updateFormula(formula);
	}
	
	return formula;
};

EasySumUp.prototype.getRowLevel = function(nRow){	
	return this.rows(nRow)._rowLevel;
};
EasySumUp.prototype.getRangeStart = function(nRow){	
	return this.rows(nRow).rangeStart;
};
EasySumUp.prototype.getRangeCount = function(nRow){	
	return this.rows(nRow).rangeCount;
};


EasySumUp.prototype.getGroupKey = function(){ return this._groupKey;};
EasySumUp.prototype.setGroupKey = function(groupKey){
	
	this._groupKey = groupKey;
	if(groupKey.length == 0) {
		this.sheet.needGrouping = false;
		return;
	}
	
	var levelKeyArr = groupKey.split(",");
	var groupKeys = [];
	for (var i=0; i < levelKeyArr.length; i++){
		var levelKey = levelKeyArr[i];
		if (levelKey.length == 0) continue;
		
		if (levelKey.indexOf(":") >= 0){
			groupKeys[i] = levelKey.split(":");
		} else {
			groupKeys[i] = levelKey;
		}
	}

	this.resetGroupKeys(groupKeys);

	return;
};

EasySumUp.prototype.addGroupKey = function(groupKey, reset){
	this._jsonGroupKey.push(groupKey);
	
	if (reset) {
		this.resetGroupKeys();
	}
	return;
};

EasySumUp.prototype.resetGroupKeys = function(groupKeys){
	
	if (typeof groupKeys !== "undefined"){
		this._jsonGroupKey = groupKeys;
	}
	
	// sheet에 그루핑이 필요한 지 전달한다.
	this.sheet.needGrouping = this._jsonGroupKey.length == 0 ? false : true;

	for (var colId in this.colInfos){
		this.colInfos[colId]._isGroupKeyField = false;
	}
	for (var i=0; i < this._jsonGroupKey.length;i++){
		var varKeyName = this._jsonGroupKey[i];
		if (varKeyName instanceof Array) {
			for (var j=0; j < varKeyName.length;j++){
				var colId = varKeyName[j];
				this.colInfos[colId]._isGroupKeyField = true;
			}
			
		} else {
			var colId = this._jsonGroupKey[i];
			this.colInfos[colId]._isGroupKeyField = true;
		}
	}
	return;
};

EasySumUp.prototype.resetNeedGroup = function(){
	this._needGroupKey.clear();
};

// 로지컬 데이터를 다시 만든다 
EasySumUp.prototype.resetGroup = function(){
	
	// 1-1: 그룹키 집계기준을 메모한다
	for (var colId in this.colInfos) {
		var column = this.colInfos[colId];
		
		var sumMethod = column.sumMethod;
		
		var posOfColon = sumMethod.indexOf(":");
		if (posOfColon < 0) continue;
		
		// _sumFormula를 미리 만들었거나 없는 경우가 아니면 sumMethod를 둘로 분리한다
		column.sumMethod   = sumMethod.substring(0,posOfColon);
		column._sumFormula = "";
		column._sumField = "";
		column._sumText = "";

		var sumFormula = sumMethod.substring(posOfColon + 1).trim();
		
		if (sumFormula == colId) { 
			// 칼럼 아이디와 같으면 디폴트 상태 
		
		} else if (typeof this.colInfos[sumFormula] != "undefined") { 
			// 칼럼 아이디중의 하나인 경우 	
			column._sumField = sumFormula;
			
		} else if (sumFormula.indexOf("=") == 0) {
			// "=" 로 시작하면 산식임
			sumFormula = sumFormula.substring(sumFormula.indexOf("=") + 1);
			column._sumFormula = sumFormula;
			column._sumFunction = new Function("return " + "function (sheet, rowNum, rowLevel) { return " + this._updateFormula(sumFormula) + "; }")();  // !!! 시트와 통일 
		} else {
			// 나머지는 "text:캡션"인 경우임
			column._sumText = sumFormula;
		}
	}
	
	for (var i=0; i < this._jsonGroupKey.length;i++){
		var varKey = this._jsonGroupKey[i];
		
		var needed = false;
		

		// 디폴트로 colId, sumMethod를 채윤다
		var colId = (varKey instanceof Array ? varKey[0] : varKey); 
		var column = this.colInfos[colId]
		needed = (column._sumFormula.trim() + column._sumField.trim()  + column._sumText.trim()).length != 0;

		// 배열인 경우 하위키 루핑 돌며 sumMethod를 찾는다, gk위키중 맨 마지막의 sumMethod를 활용한다.
		if (varKey instanceof Array){
			// 하위키중 하나라도 sumMethod가 있으면 그메서드를 적용하고 
	        // 하위키 모두 있으면 나중에 나온것을 적용한다.
			for (var nSubIndex = 0; nSubIndex < varKey.length; nSubIndex++){
				var colId1 = varKey[nSubIndex];
				if (colId1 == "") continue;
				
				if (this.colInfos[colId1].sumMethod.trim().length != 0){
					column = this.colInfos[colId1]
					needed = (column._sumFormula.trim() + column._sumField.trim()  + column._sumText.trim()).length != 0;
					break;

				}
			}
		}

		// sumMethod 필드가 비었으면 집계내지 않는다.
		var nGroupNdx = i + 1; 
		
		this._needGroupKey[nGroupNdx] = needed;
	}

	// 1-3. 먼저 Logical rowType을 가진 데이터를 전부 지운다.
	//      그룹키가 없어도 있다 없어 지는 경우가 있으므로 두어야 한다 
	for (var rowNum0 = this.dataSet.data.length - 1; rowNum0 >= 0; rowNum0--){
		var row = this.rows(rowNum0);
		
		if (typeof row.rowType != "undefined" && row.rowType == "Logical"){
			this.dataSet.data.splice(rowNum0, 1);
		} else if (row.updateGu == "X" || row.updateGu == "N" || row.updateGu == "E"){
			this.dataSet.data.splice(rowNum0, 1);
		} else {
			var data = this.dataSet.data[rowNum0];
			row._jsonGroupKeyValue = this._makeGroupKey(data);
			
			// 산식 재계산을 위하여 원래 줄번호를  기억한다 
			row.rowNumOrg = rowNum0;
		}
	}
	
	// 1-4  data 배열 재구성 
	// 그룹키가 없으면 아래 로직들은 돌릴 필요가 없다.
	if (this._jsonGroupKey.length == 0){
		// datas 재구성 
		this._remakeDatas();
		return;
	}
	
	// 1-5 데이터 없는 경우  
	// 데이터가 없는 상태이면 아래 작업을 할 필요가 없다.
	if (this.dataSet.data.length == 0){
		// datas 재구성
		this.dataSet.insertData();
		return;
	}
	
	// STEP 2. 데이터 소팅
	// !!! 시트의 소팅 적용


	// 2-1 소팅된 버퍼데이터 배열로 datas 재구성 
	var _makeGroupDataSample = null;
	for (var rowNum0 = 0; rowNum0 < this.dataSet.data.length; rowNum0++){
		if (!this.sheet.rows(rowNum0).filterd){
			_makeGroupDataSample = this.dataSet.data[rowNum0];
			break;
		}
	}

	// STEP 3. 레벨별 데이터 소계 채우기 
	// 3-1.  루핑하면서 끝 그룹키이 바뀌면 1레벨합계  다음은 2레벨합계, ...
	var levelCount = this._jsonGroupKey.length;
	
	// 3-1-1.  레벨별 그룹데이터를 만들고 첫데이터를 기준으로키값을 세팅한다
	var levelDatas = [null];
    for (var nGroupLevel = 1; nGroupLevel <= levelCount; nGroupLevel++){
    	// 그룹합을 만들지 않는 레벨은 스킵한다
    	if (!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;
    	
    	var groupData = levelDatas[nGroupLevel] = this._makeGroupData();
    	var groupRow = this.rows(groupData);
    	groupRow._rowLevel = nGroupLevel;
    	
    	groupRow.rangeStart = 0;
    	groupRow._jsonGroupKeyValue = this._makeGroupLevelKey(this.rows(_makeGroupDataSample)._jsonGroupKeyValue, nGroupLevel); 
		// 키값을 그룹레코드에 복사
		for (var colId in this.colInfos){
			var column = this.colInfos[colId];
			if (column._isGroupKeyField){
				groupData[colId] = _makeGroupDataSample[colId];
			}
		}
    }
    
    // 3-1-2.  데이터를 처음부터 끝까지 돌리면서 레벨 정보를 집계한다
    var groupDatas = [];
    var _dataGroupKey = [];
    
    for(var rowNum0 = 0; rowNum0 < this.dataSet.data.length; rowNum0++){
		var data = this.dataSet.data[rowNum0];
		var row = this.rows(data);
		if (row.filterd) continue;
		
	    for (var nGroupLevel = 1; nGroupLevel <= levelCount; nGroupLevel++){
	    	// 그룹합을 만들지 않는 레벨은 스킵한다
	       	if( !this._needGroupKey[levelCount - nGroupLevel + 1] ) continue;
	    	
	    	// 그룹레코드 생성
	    	var groupData = levelDatas[nGroupLevel];
			var groupRow = this.rows(groupData);
	    	
	    	// 필터링 안된 첫데이터가 아니면서, 키가 바뀌었으면
	    	var keyChanged = ( this._checkIfGroupLevelKeyChanged(data, groupRow._jsonGroupKeyValue, nGroupLevel) ); 

	    	// 키가 변경되었으면 논리레코드를 추가하고 새로운 레코드를 만든다 
    		if (keyChanged){
    			groupDatas.push(groupData);
    			
    			// 레코드 초기화 
    			groupData = levelDatas[nGroupLevel] = this._makeGroupData();
    			
    			var groupRow = this.rows(groupData);
    			groupRow._rowLevel = nGroupLevel;
    			groupRow._jsonGroupKeyValue = this._makeGroupLevelKey(row._jsonGroupKeyValue, nGroupLevel); 
	    		// 키값을 그룹레코드에 복사
	    		for (var colId in this.colInfos){
	    			var column = this.colInfos[colId];
					if (column._isGroupKeyField){
						groupData[colId] = data[colId];
					}
	    		}
    		}
	    } // 그룹 레벨별 루프 종료 
	    
	} // this.dataSet.data 루프 종료 
		
    // 3-1-3.  마지막에 남은 집계레코드를 표에 추가한다.
    for (var nGroupLevel=1; nGroupLevel <= levelCount; nGroupLevel++ ){
    	// 그룹합을 만들지 않는 레벨은 스킵한다
       	if (!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;

    	groupDatas.push(levelDatas[nGroupLevel]);
    }
    
    // 3-1-4 buffer에 그룹핑 레코드 추가 후, buffer & groupDatas sorting
    this.dataSet.data = this.dataSet.data.concat(groupDatas);
    
    this.dataSet.data.sort(function(data1, data2){
    	return compareDataGroupKeyByData(data1, data2);
    });
    
    groupDatas.sort(function(data1, data2){
    	var groupkey1 = data1.__STATE__._jsonGroupKeyValue;
    	var groupkey2 = data2.__STATE__._jsonGroupKeyValue;
    	
		return compareDataGroupKeyByGroupKey(groupkey1, groupkey2);
	});
    
    // 3-1-6 그룹 레코드에 집계 메소드에 따른 값 및 rangeCount 계산
    for(var rowNum0 = 0; rowNum0 < this.dataSet.data.length; rowNum0++){
		var data = this.dataSet.data[rowNum0];
		var row = this.rows(data);
		
		if(row.filterd) continue;
		if (typeof row.rowType != "undefined" && row.rowType == "Logical") continue;
		
		for(var nGroupLevel=1; nGroupLevel <= levelCount; nGroupLevel++){
	    	// 그룹합을 만들지 않는 레벨은 스킵한다
	       	if(!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;
	       	
	       	var _dataGroupKey = this._makeGroupLevelKey(row._jsonGroupKeyValue, nGroupLevel);
	       	var rowIndex = binaryDataGroupSearch(groupDatas, _dataGroupKey, 0, groupDatas.length);
	       	var _groupData = groupDatas[rowIndex];
	    	var _groupRow = this.rows(_groupData);
	       	
	       	var _value 		= null;
	       	var _calcResult = null;
			var _sumMethod  = null;
			var _sumFormula = null;
			var _sumField   = null;
			var _sumText    = null;
	       	
	       	for(var colId in this.colInfos){
	       		var column = this.colInfos[colId];
				if( column._isGroupKeyField )		continue;
    			if( column.sumMethod.length == 0 )	continue;
    			
    			_value		= _groupData[colId];
    			_sumMethod  = column.sumMethod;
    			_sumFormula = column._sumFormula;
    			_sumField   = column._sumField;
    			_sumText    = column._sumText;
    			
    			if( _sumFormula.length > 0 )	_calcResult = column._sumFunction(this.sheet, rowNum0, _groupRow._rowLevel);
    			else if( _sumField.length > 0 )	_calcResult = data[_sumField];
    			else if( _sumText.length > 0 )	_calcResult = _sumText;
    			else							_calcResult = data[colId];
    			
    			
    			if( [CELLTYPE_NUMBER, CELLTYPE_PERCENT, CELLTYPE_INTEGER, CELLTYPE_BAR,
				     CELLTYPE_CURRENCY, CELLTYPE_FLOAT, CELLTYPE_CHECKBOX].indexOf(column.cellType) >= 0 )    			
    				_calcResult = (1 * _calcResult);
    			
    			if( _sumMethod == "TEXT" )		_value = _calcResult;
    			else if( _sumMethod == "SUM" ) 	_value += _calcResult; 
    			else if( _sumMethod == "AVG" )	_value += _calcResult; 
    			else if( _sumMethod == "MAX" )	_value = (_value > _calcResult ? _value : _calcResult);
    			else if( _sumMethod == "MIN" )	_value = (_value < _calcResult ? _value : _calcResult);
    			else if( _sumMethod == "COUNT" ) _value += 1;
     			
    			_groupData[colId] = _value;
	       	}
	       	
	       	_groupRow.rangeCount++;
		}
    }
    
    // 컬럼의 집계 함수가 AVG인 경우 AVG인 컬럼만 찾음
    var avgMethodColIDList = [];
    for(var colId in this.colInfos){
    	var column = this.colInfos[colId];
    	if( column.sumMethod.length == 0 )	continue;
    	if( column.sumMethod != "AVG" )	continue;
    	
    	avgMethodColIDList.push( colId );
    }
    // 컬럼의 집계 함수가 AVG인 열만 그룹 레코드의 평균 값을 구함
    if(avgMethodColIDList.length > 0){
    	for(var rowNum0 = 0; rowNum0 < groupDatas.length; rowNum0++){
    		var _groupData = groupDatas[rowNum0];
    		var _groupRow = this.rows(_groupData);
    		
    		for(var c = 0; c < avgMethodColIDList.length; c++){
    			var colId = avgMethodColIDList[c];
    			_groupData[colId] = _groupData[colId] / _groupRow.rangeCount;
    		}
    	}
    }
    
    // 3-1-7 레코드의 rangeStart를 구함
    var groupLevelKeys = [];
    for(var nGroupLevel=1; nGroupLevel <= levelCount; nGroupLevel++){
    	groupLevelKeys[nGroupLevel] = null;
    }
    // 데이터셋의 datas를 돌며 그룹 레코드의 그룹 레벨별 그룹키가 변할 경우 rangeStart를 기록한다 
    for(var nRow = 0, groupKeyStr = ""; nRow < this.dataSet.data.length; nRow++){
    	var row = this.rows(nRow);
    	if (typeof row.rowType != "undefined" && row.rowType == "Logical") continue;
		
		var _dataGroupKey = null;
		
		for(var nGroupLevel=1; nGroupLevel <= levelCount; nGroupLevel++){
	       	if(!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;
	       	
	       	_dataGroupKey = this._makeGroupLevelKey(row._jsonGroupKeyValue, nGroupLevel);
	       	groupKeyStr = JSON.stringify(_dataGroupKey);
	       		       	
	       	if( groupLevelKeys[nGroupLevel] != groupKeyStr ){
	       		groupLevelKeys[nGroupLevel] = groupKeyStr;
	    		var _groupData = groupDatas[binaryDataGroupSearch(groupDatas, _dataGroupKey, 0, groupDatas.length)];
	    		var _groupRow = this.rows(_groupData);
	       		
	    		_groupRow.rangeStart = nRow;
	       	}
	    }
    }
    
    // 3-1-8 메모리 초기화
    while(avgMethodColIDList.length > 0){
    	avgMethodColIDList.pop();	
    }
    while(groupDatas.length > 0){
    	groupDatas.pop();			
    }
    
    avgMethodColIDList = null;
    groupDatas = null;
    
    // 4 그룹캡션 조정 
	this._refreshGroupCation(true);
	
	this.sheet.maxRows = this.dataSet.data.length;
	
	// 산식에 줄번호 변경 반영
	this._resetFormula(nRow);
	
	// 행 번호 설정
	var record_count = this.dataSet.data.length;
	var record_state = null; var record_num = 0;
	for(var rowNum0 = 0, record_num = 1; rowNum0 < record_count; rowNum0++, record_state = null){
		record_state = this.dataSet.data[rowNum0].__STATE__;
		if( record_state.rowType === "Logical" ) continue;
		record_state["rowNum"] = record_num++;
	}
      
	return;
};

function binaryDataGroupSearch(groupDatas, groupKey, start, end){
	if( start > end ) return -1; //does not exist
	
	var middle = Math.floor((start + end) / 2);
	var groupKey1 = groupDatas[middle].__STATE__._jsonGroupKeyValue;
	
	var result = compareDataGroupKeyByGroupKey(groupKey1 , groupKey);
	if( result > 0 ){ 
		return binaryDataGroupSearch(groupDatas, groupKey, start, middle - 1); 
	}
	if( result < 0 ){ 
		return binaryDataGroupSearch(groupDatas, groupKey, middle + 1, end); 
	}
	
	return middle; //found!
};

function compareDataGroupKeyByGroupKey(groupKey1, groupKey2){
	var key1 = null;		var key2 = null;
	var subKey1 = null;		var subKey2 = null;
	
	for(var i = 0; i < groupKey1.length; i++){
		key1 = groupKey1[i];
		key2 = groupKey2[i];
		
		if (key1 instanceof Array) {
			for(var j = 0; j < key1.length; j++){
				subKey1 = key1[j];
				subKey2 = key2[j];
				
				if( subKey1 != null && subKey2 == null )		return -1;
				else if( subKey1 == null && subKey2 != null )	return 1;
				else if( subKey1 > subKey2 )					return 1;
				else if( subKey1 < subKey2 )					return -1;
			}
		}
		else{
			if( key1 != null && key2 == null )		return -1;
			else if( key1 == null && key2 != null )	return 1;
			else if( key1 > key2 )					return 1;
			else if( key1 < key2 )					return -1;
		}
	}
	
	if( groupKey1.length < groupKey2.length )		return -1;
	
	return 0;
};

function compareDataGroupKeyByData(data1, data2){
	var groupKey1 = null;	var groupKey2 = null;
	var key1 = null;		var key2 = null;
	var subKey1 = null;		var subKey2 = null;
	
	
	var row1 = data1.__STATE__;
	var row2 = data2.__STATE__;
	
	groupKey1 = row1._jsonGroupKeyValue;
	groupKey2 = row2._jsonGroupKeyValue;
	
	for(var i = 0; i < groupKey1.length; i++){
		key1 = groupKey1[i];
		key2 = groupKey2[i];
		
		if (key1 instanceof Array) {
			for(var j = 0; j < key1.length; j++){
				subKey1 = key1[j];
				subKey2 = key2[j];
				
				if( subKey1 != null && subKey2 == null )		return -1;
				else if( subKey1 == null && subKey2 != null )	return 1;
				else if( subKey1 > subKey2 )					return 1;
				else if( subKey1 < subKey2 )					return -1;
			}
		}
		else{
			if( key1 != null && key2 == null )		return -1;
			else if( key1 == null && key2 != null )	return 1;
			else if( key1 > key2 )					return 1;
			else if( key1 < key2 )					return -1;
		}
	}
	
	if( groupKey1.length < groupKey2.length )		return -1;
	
	if(row1.rowType == "Logical" && row2.rowType != "Logical") return 1;
	if(row1.rowType != "Logical" && row2.rowType == "Logical") return -1;
	
	return 0;
};


EasySumUp.prototype._RefreshGroupByOneData = function(nRow){
	// 전제: 해당 레코드가 이미 datas 에서 빠진 상태를 가정한다
	var data = this.sheet.rows(nRow);
	
	var arrGroupRows = this._FindGroupRows(nRow);
	
	var levelCount = this._jsonGroupKey.length;
    for (var nGroupLevel=1; nGroupLevel <= levelCount; nGroupLevel++ ){
    	// 그룹합을 만들지 않는 레벨은 스킵한다
    	if (!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;

    	var nGroupRow = arrGroupRows[nGroupLevel];
    	
    	for (var colId in this.colInfos){
    		var sumMethod = this.colInfos[colId].sumMethod;
    		if (sumMethod.length == 0) continue;

    		if (sumMethod == "COUNT"){
    			// 변화없음
    		} else {
    			this._UpdateGroupSum(colId, nGroupRow);
    		}
    	}
    }

	return;
};

// 칼럼값의 변경시 처리 
// 값을 이미 "수정"하고 그룹키가  아직 안 바뀌었다는 전제 
EasySumUp.prototype._UpdateColumnValueToGroup = function(nRow, colId, varFromValue, varToValue){
	
	// 산식을 수정하기 위한 메모 
	for (var rowNum0 = nRow; rowNum0 < this.dataSet.data.length; rowNum0++){
		var row = this.rows(rowNum0);
		if (typeof row.rowType == "undefined" || row.rowType != "Logical"){
			row.rowNumOrg = rowNum0;
		}
	}
	
	var data = this.dataSet.data[nRow];
	var row = this.rows(data);
	var sumMethod = this.colInfos[colId].sumMethod;

	var isKeyColumn = this._isKeyColumn(colId);
	
	// 레벨별 줄번호를 찾아낸다
	var arrGroupRows = this._FindGroupRows(nRow);
	
	// Case1: 그룹키가 아니면  합계를 갱신하고 빠진다 
	//        - 변경된 칼럼이 그룹키 항목이 아니고 집계가 필요한 필드이면 
	//        - 합계를 갱신하고 빠져 나간다
	if (!isKeyColumn){
		if (sumMethod.length == 0) return;
		
		// 레벨별로 루핑돌면서 집계값을 갱신한다
		var levelCount = this._jsonGroupKey.length;
	    for (var nGroupLevel=1; nGroupLevel <= levelCount; nGroupLevel++ ){
	    	// 그룹합을 만들지 않는 레벨은 스킵한다
	    	if (!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;

	    	var nGroupRow = arrGroupRows[nGroupLevel];
	    	var groupData = this.dataSet.data[nGroupRow];
	    	
	    	if (sumMethod == "SUM"){
	    		groupData[colId] += (1 * varToValue) - (1 * varFromValue);
	    	} else if (sumMethod == "COUNT"){
	    	} else {
	    		this._UpdateGroupSum(colId, nGroupRow, null, nRow);
	    	}
	    }
	    return;
	}
	
	// Case2: 그룹키이면  먼저 레코드를 이동한다
	//        - 데이터를 메모한 후 먼저 데이터를 제거하고 
	//        - 키에 해당하는 위치에 다시 넣는다.
	
	// 먼저 그룹들의 집계에서 뺀다 
	//   이때 하나도 없으면 그룹을 제거 한다  
    this._deleteFromGroup(arrGroupRows, data, nRow);
    
	//    이동할 위치로 레코드를 옮긴다.
	//       - 삭제
	this.dataSet.data.splice(nRow, 1);
	
	// rangeStart 한줄씩 앞으로 당기기
    this._updateRangeStartsAfter(nRow, -1);

    
	// 새로운 키값을 부여한다 
    row._jsonGroupKeyValue = this._makeGroupKey(data);

	
	//  이동할 위치를 찾는다
	lastGroupSearchIndex = -1;
	var searchedRow = binaryGroupSearch(this.dataSet.data, data, 0, this.dataSet.data.length - 1); 
	
	// 못 찾았으면  searchedRow = -1 이고 lastGroupSearchIndex 값에 가장 근사치 값이 들어간다.
	var rowFrom = (searchedRow != -1 ? searchedRow : (lastGroupSearchIndex != -1 ? lastGroupSearchIndex : this.dataSet.data.length));
	var rowTo = this.dataSet.data.length;
	for (var nRow1 = rowFrom; nRow1 < this.dataSet.data.length; nRow1++){
		var row1 = this.rows(nRow1);
				
		if (row1.rowType == "Logical"){ // 집계데이터가 아닌 경우
			// 집계 줄의 레벨 키까지만 같으면 그위치 앞에 차고 들어 간다 
			var same = true;
			var levelCount = this._jsonGroupKey.length;
			for (var i=0; i <= levelCount - row1._rowLevel ; i++){
				if (row1._jsonGroupKeyValue[i] != row._jsonGroupKeyValue[i]){
					same = false; 
					break;
				}
			}
			
			if (same){
				rowTo = nRow1; 
				break;
			}
			
		} else {                         // 잡계데이터인 경우 
			// 넣으려는 데이터 보다 값이 커서 그루핑 키값이 바뀌는 경우 이 앞에 넣는다 
			if (compareGroupKey(row1._jsonGroupKeyValue , row._jsonGroupKeyValue) > 0){ 
				rowTo = nRow1; 
				break;
			}
		}
	}
	
	//       - 추가
	if (rowTo == this.dataSet.data.length){
		this.dataSet.data.push(data);
		
	} else {
		this.dataSet.data.splice(rowTo, 0, data);
		
    	// rangeStart 한줄씩 뒤로 미루기
    	this._updateRangeStartsAfter(rowTo, 1);
	}
	

	// 새로운 그룹에 추가한다 
	// 이때 기존 그룹이 없으면 추가한다  (필터링 된 상태로 변경되었다면, 새로운 그룹은 갱신할 필요가 없다)
	if (!row.filterd){
		this._InsertToGroup(rowTo);
	    this._refreshGroupCation(true);
	}
	
	// 산식에 줄번호 변경 반영
	// 산식에 줄번호 변경 반영
	this._resetFormula(nRow);
	
	return;
};


EasySumUp.prototype._deleteFromGroup = function(arrGroupRows, data, nRow){
	// 전제: 해당 레코드가 datas 에서 아직 삭제되지 않은 상태를 가정한다

	
	// 산식을 수정하기 위한 메모 
	for (var rowNum0 = nRow; rowNum0 < this.dataSet.data.length; rowNum0++){
		var row = this.rows(rowNum0);
		if (typeof row.rowType == "undefined" || row.rowType != "Logical"){
			row.rowNumOrg = rowNum0;
		}
	}
	
	
	var levelCount = this._jsonGroupKey.length;
	var lastGroupRow = this.dataSet.data.length;
    for (var nGroupLevel=levelCount; nGroupLevel >= 1; nGroupLevel-- ){
    	// 그룹합을 만들지 않는 레벨은 스킵한다
    	if (!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;
    	
    	var nGroupRow = arrGroupRows[nGroupLevel];
    	if (nGroupRow < 0) continue;
    	
    	lastGroupRow = nGroupRow; // 최종 그룹핑줄번호를 기억해서 이후 그루핑 정보에서  하나씩 당긴다
    	var groupData = this.dataSet.data[nGroupRow];
    	var groupRow = this.rows(groupData);
    	
    	// 데이터가 한건도 없게되면 해당 소계를 삭제한다
    	if (groupRow.rangeCount == 1){
    		this.dataSet.data.splice(nGroupRow, 1);
    		
	    	// rangeStart 한줄씩 앞으로 당기기
    	    this._updateRangeStartsAfter(nGroupRow, -1);
    	        		
    	} else {
    		for (var colId in this.colInfos){
    			var column = this.colInfos[colId];
    			if (column._isGroupKeyField) continue;
    			
    			var sumMethod = column.sumMethod;
    			if (sumMethod.length == 0) continue;

    			
    			var calcResult = null;
    			var sumMethod  = column.sumMethod;
    			var sumFormula = column._sumFormula;
    			var sumField   = column._sumField;
    			var sumText    = column._sumText;
    			
    			if (sumFormula.length > 0){
    				var rowLevel = groupRow._rowLevel;
    				calcResult = column._sumFunction(this.sheet, nRow, rowLevel);
    			} else if (sumField.length > 0){
    				calcResult = data[sumField];
    			} else if (sumText.length > 0){
    				calcResult = sumText;
    			} else {
    				calcResult = data[colId];
    			}
    			
    			if (sumMethod == "SUM"){
    				groupData[colId] -= (1 * calcResult);
    			} else if (sumMethod == "COUNT"){
    				groupData[colId]--;
    			} else {
    				this._UpdateGroupSum(colId, nGroupRow, nRow); // 세번째 인수는 삭제할 레코드를 합계에서 제외하기 위해서
    			}
    		}

    		groupRow.rangeCount--;
    	}
    }
    
	this.sheet.maxRows = this.dataSet.data.length;
	
	// 산식에 줄번호 변경 반영
	this._resetFormula(nRow);
    
    // 이후의 데이터의  rangeStart 속성 정리 
	return data;
};

/**
 * @param nRow
 */
EasySumUp.prototype._resetFormula = function(nRow) {
	var arrChangedInfo = [];
	
	for (var rowNum0 = nRow; rowNum0 < this.dataSet.data.length; rowNum0++){
		var row = this.rows(rowNum0);
		
		if (typeof row.rowType != "undefined" && row.rowType == "Logical") continue;
		if (typeof row.rowNumOrg == "undefined") continue;
		if (row.rowNumOrg != rowNum0) {
			arrChangedInfo.push({rowNumFrom: row.rowNumOrg, rowNumTo: rowNum0});
		}
		
		// 임시변수 삭제
		delete row.rowNumOrg;
	}
	
	if (arrChangedInfo.length > 0){
		this.sheet._updateFormulaCollectively(arrChangedInfo);
		this.sheet.refreshFormulaRefs();
	}
	arrChangedInfo.clear();
	
	return;
};


EasySumUp.prototype._deleteOneRecord = function(nRow){
	var arrGroupRows = this._FindGroupRows(nRow);
	var data = this.dataSet.data[nRow];
	
	this._deleteFromGroup(arrGroupRows, data, nRow);

};


EasySumUp.prototype._InsertToGroup = function(nNewNum){
	
	// 산식을 수정하기 위한 메모 
	for (var rowNum0 = nNewNum; rowNum0 < this.dataSet.data.length; rowNum0++){
		var row = this.rows(rowNum0);
		if (typeof row.rowType == "undefined" || row.rowType != "Logical"){
			row.rowNumOrg = rowNum0;
		}
	}
	
	// 전제: 해당 레코드가 datas의 새로운 위치에 추가된 상태를 가정한다
	var data = this.dataSet.data[nNewNum];
	var row = this.rows(data);
	
	row._jsonGroupKeyValue = this._makeGroupKey(data);
	var arrGroupRows = this._FindGroupRows(nNewNum);
	
	var levelCount = this._jsonGroupKey.length;
	var lastGroupRow = this.dataSet.data.length;
    for (var nGroupLevel = 1 ; nGroupLevel <= levelCount; nGroupLevel++ ){
    	// 그룹합을 만들지 않는 레벨은 스킵한다
    	if (!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;

    	var nGroupRow = arrGroupRows[nGroupLevel];
    	lastGroupRow = nGroupRow; // 최종 그룹핑줄번호를 기억해서 이후 그루핑 정보에서  하나씩 밀친다다
    	if (nGroupRow == -1){
    		// 집계레코드가 없으면 추가
    		nGroupRow = this._findGroupInsertRowPosition(nNewNum, row._jsonGroupKeyValue);
    		
    		for (var tmpRowNum = nGroupRow; tmpRowNum < this.dataSet.data.length;  tmpRowNum++){
    			var tmpRow = this.rows(tmpRowNum);
    			if (typeof tmpRow.rowType != "undefined" && tmpRow.rowType == "Logical" && tmpRow._rowLevel < nGroupLevel){
    				nGroupRow++;
    			} else {
    				break;
    			}
    		}
    		
	    	var groupData = this._makeGroupData();
	    	var groupRow = this.rows(groupData);
	    	
	    	groupRow._rowLevel = nGroupLevel;
	    	groupRow.rangeStart = nNewNum;
	    	groupRow.rangeCount = 0;
	    	
			// 키값을 그룹레코드에 복사
			for (var colId in this.colInfos){
				var column = this.colInfos[colId];
				if (column._isGroupKeyField){
					groupData[colId] = data[colId];
				}
			}
			groupRow._jsonGroupKeyValue = this._makeGroupLevelKey(row._jsonGroupKeyValue, nGroupLevel); 

	    	
	    	this.dataSet.data.splice(nGroupRow, 0, groupData);
	    	// 줄추가에 영향 받은 합계줄번호 증가 
	    	for (var i = 1; i < arrGroupRows.length; i++){
	    		if (arrGroupRows[i] >= nGroupRow) arrGroupRows[i] = arrGroupRows[i] + 1;
	    	}
	    	
	    	// rangeStart 한줄씩 뒤로 미루기
	    	this._updateRangeStartsAfter(nGroupRow, 1);
	    	
    		for (var colId in this.colInfos){
    			var column = this.colInfos[colId]
				if (column._isGroupKeyField)       continue;
    			if (column.sumMethod.length == 0)  continue;

    			var sumMethod = column.sumMethod;
    			
    			var calcResult = null;
    			var sumMethod  = column.sumMethod;
    			var sumFormula = column._sumFormula;
    			var sumField   = column._sumField;
    			var sumText    = column._sumText;
    			
    			if (sumFormula.length > 0){
    				var rowLevel = groupRow._rowLevel;
    				calcResult = column._sumFunction(this.sheet, nNewNum, rowLevel);
    			} else if (sumField.length > 0){
    				calcResult = data[sumField];
    			} else if (sumText.length > 0){
    				calcResult = sumText;
    			} else {
    				calcResult = data[colId];
    			}
    			
    			
    			if( [CELLTYPE_NUMBER, CELLTYPE_PERCENT, CELLTYPE_INTEGER, CELLTYPE_BAR,
				     CELLTYPE_CURRENCY, CELLTYPE_FLOAT, CELLTYPE_CHECKBOX].indexOf(column.cellType) >= 0 )    			
    				calcResult = (1 * calcResult);
    			
    			var value = groupData[colId];
    			
    			if (sumMethod == "TEXT"){
    				value = calcResult;
    			} else if (column.sumMethod == "SUM"){ 
    				value += calcResult; 
    			} else if (column.sumMethod == "AVG"){ 
    				value += calcResult; 
    			} else if (column.sumMethod == "MAX"){
    				value = (value > calcResult ? value : calcResult);
    			} else if (column.sumMethod == "MIN"){
    				value = (value < calcResult ? value : calcResult);
    			} else if (column.sumMethod == "COUNT"){
    				value = 1;
    			}

				groupData[colId] = value;
    		}
    		
    	} else {
    		// 집계레코드가 있으면 합계값 갱신
    		var groupData = this.dataSet.data[nGroupRow];
    		var groupRow = this.rows(groupData);
    		
    		for (var colId in this.colInfos){
    			var column = this.colInfos[colId];
				if (column._isGroupKeyField)       continue;
    			if (column.sumMethod.length == 0)  continue;
    			
    			var sumMethod = column.sumMethod;

    			var calcResult = null;
    			var sumMethod  = column.sumMethod;
    			var sumFormula = column._sumFormula;
    			var sumField   = column._sumField;
    			var sumText    = column._sumText;
    			
    			if (sumFormula.length > 0){
    				var rowLevel = groupRow._rowLevel;
    				calcResult = column._sumFunction(this.sheet, nNewNum, rowLevel);
    			} else if (sumField.length > 0){
    				calcResult = data[sumField];
    			} else if (sumText.length > 0){
    				calcResult = sumText;
    			} else {
    				calcResult = data[colId];
    			}
    			
    			if (column.sumMethod == "SUM"){ 
    				groupData[colId] += (1 * calcResult);
    			} else if (column.sumMethod == "COUNT"){
    				groupData[colId]++;
    			} else {
    				this._UpdateGroupSum(colId, nGroupRow, null, nNewNum);
    			}
    		}
    	}
    	groupRow.rangeCount++;
    	
    }
    
	this.sheet.maxRows = this.dataSet.data.length;

	// 산식에 줄번호 변경 반영
	this._resetFormula(nNewNum);
	
	return data;
};

// 그룹줄번호를 하나주고 칼럼을 주어 칼럼값을 재계산한다 
// 변경된 키를 기준으로 리프래시한다 
// 세번째 인수는 제외할 레코드이다(삭제할 게 있는경우에만)
EasySumUp.prototype._UpdateGroupSum = function(colId, nGroupRow, rowNumToDel){
	var column = this.colInfos[colId];
	
	if (column.sumMethod.length == 0)    return;
	if (column._isGroupKeyField)         return;
	
    // 줄추가, 삭제시 항상 대중소계레코드를 동시에 만드므로 여기서는 논리데이터를 추가할 필요는 없다.
    var groupData = this.dataSet.data[nGroupRow];
	var groupRow = this.rows(groupData);
    
    groupData[colId] = 0;
    var value = typeof column.sumMethod === "undefined" ? 0 :
                column.sumMethod === "MAX" ? Number.MIN_VALUE :
                column.sumMethod === "MIN" ? Number.MAX_VALUE : 0 ;
    var cnt = 0;
    var rangeCount = groupRow.rangeCount;
    for (var nRow = groupRow.rangeStart; nRow < this.dataSet.data.length ; nRow++){
    	if (cnt >= rangeCount) break;
    	
    	var data0 = this.dataSet.data[nRow];
    	var row0 = this.rows(nRow);
    	
    	if (row0.filterd) continue;
    	if (row0.rowType == "Logical") continue;
    	if (rowNumToDel != undefined && rowNumToDel != null && nRow == rowNumToDel) {
    		rangeCount--; //삭제할 레코드가 있으므로 하나 줄여서 루핑을 한번 덜돌게 한다
    		continue;
    	}
    	
		var calcResult = null;
		var sumMethod  = column.sumMethod;
		var sumFormula = column._sumFormula;
		var sumField   = column._sumField;
		var sumText    = column._sumText;

		if (sumFormula.length > 0){
			var rowLevel = groupRow._rowLevel;
			calcResult = column._sumFunction(this.sheet, nRow, rowLevel);
		} else if (sumField.length > 0){
			calcResult = data0[sumField];
		} else if (sumText.length > 0){
			calcResult = sumText;
		} else {
			calcResult = data0[colId];
		}
		
		
		if( [CELLTYPE_NUMBER, CELLTYPE_PERCENT, CELLTYPE_INTEGER, CELLTYPE_BAR,
		     CELLTYPE_CURRENCY, CELLTYPE_FLOAT, CELLTYPE_CHECKBOX].indexOf(column.cellType) >= 0 )    			
			calcResult = (1 * calcResult);
		

		if (sumMethod == "TEXT"){
			value = calcResult;
		} else if (column.sumMethod == "SUM"){ 
			value += calcResult;
		} else if (column.sumMethod == "AVG"){ 
			value += calcResult;
		} else if (column.sumMethod == "MAX"){
			value = (value > calcResult ? value : calcResult);
		} else if (column.sumMethod == "MIN"){
			value = (value < calcResult ? value : calcResult);
		} else if (column.sumMethod == "COUNT"){
			value += 1;
		}
    	
    	cnt++;
    	
    }
    if (sumMethod == "AVG") {
    	value = value / cnt;
    }

    groupData[colId] = value;
    
};



// 데이터의 그룹키를 주면 레벨별 줄번호를 리턴한다 없으면 -1이다 리턴 예: [null, -1, 12,13,14]
EasySumUp.prototype._FindGroupRows = function(nRow){
 	var row = this.rows(nRow);

	var groupRowNums = [null];
    
    var nLastRow = nRow;
    
	var levelCount = this._jsonGroupKey.length;
    for (var nGroupLevel=1; nGroupLevel <= levelCount; nGroupLevel++ ){
    	// 그룹합을 만들지 않는 레벨은 스킵한다
    	if (!this._needGroupKey[levelCount - nGroupLevel + 1]) continue;
    	
    	// 레벨별 그룹 키를 구한다.
    	var jsonGroupKeyValue = [];
    	
    	for (var i = 0; i < row._jsonGroupKeyValue.length; i++){
    		
    		// 그룹레벨별 키 범위내의 데이터 복사 
    		var varKey = row._jsonGroupKeyValue[i];
    		
    		if (varKey instanceof Array) {
    			var varSubKey = [];
    			for (var j=0; j < varKey.length; j++) {
    				varSubKey[j] = varKey[j];
    			}
    			jsonGroupKeyValue[i] = varSubKey;
    		} else{
    			jsonGroupKeyValue[i] = varKey;
    		}
    		
    		// 결국은 i 가 levelCount - nGroupLevel 보다 크면 null;
    		if (i > levelCount - nGroupLevel) {
    			jsonGroupKeyValue[i] = null;
    			continue;
    		}
    	}
    	
    	// 
    	groupRowNums[nGroupLevel] = -1;
    	for (var nRow1 = nLastRow + 1; nRow1 < this.dataSet.data.length; nRow1++){
    		var row1 = this.rows(nRow1);
    		if (row1.rowType != "Logical") continue;
    		var rslt = compareGroupKey(row1._jsonGroupKeyValue, jsonGroupKeyValue);
    		if (rslt == 0){
    			groupRowNums[nGroupLevel] = nRow1;
    			nLastRow = nRow1;
    			break;
    		}
    	}
    }
	
	return groupRowNums;
};

// 그룹합을 넣을 위치를 찾아주는 함수, 못찾으면 마지막 레코드 번호 + 1 리턴
EasySumUp.prototype._findGroupInsertRowPosition = function(nRow, jsonGroupKeyValue){
	for (var nRow1 = nRow + 1; nRow1 < this.dataSet.data.length; nRow1++){
		var row1 = this.rows(nRow1);

		var jsonGroupKeyValue1 = row1._jsonGroupKeyValue;
		for (var i = 0; i < jsonGroupKeyValue.length && jsonGroupKeyValue[i] != null; i++){
			var varKey1 = jsonGroupKeyValue1[i];
			var varKey2 = jsonGroupKeyValue[i];
			if (varKey1 instanceof Array) {
				for (var j=0; j < varKey1.length ;j++) {
					if (varKey1[j] != varKey2[j]) return nRow1;
				}
			} else{
				if (varKey1 != varKey2) return nRow1;
			}
		}
	}
	return this.dataSet.data.length;
	
};

//최종적인 정살적인 데이터 줄을 찾아주는 메서드로 산식에서 참조할 줄번호를 도출하기 위해 사용한다
EasySumUp.prototype._findLastNormalRowPosition = function(nRow){
	for (var nRow1 = nRow; nRow1 >= 0; nRow1--){
		if (this.rows(nRow1).rowType != "Logical") return nRow1;
	}
	return -1;
};

// 줄추가시 포커스된 줄의 그룹키에 해당하는 값은 미리 채워줘야 중간에 들어갈 수 있다.
EasySumUp.prototype._copyGroupKeyValues = function(dataFrom, dataTo){
	for (var i=0; i < this._jsonGroupKey.length;i++){
		var varKeyName = this._jsonGroupKey[i];
		if (varKeyName instanceof Array) {
			for (var j=0; j < varKeyName.length;j++){
				var colId = varKeyName[j];
				dataTo[colId] = dataFrom[colId]
			}
			
		} else {
			var colId =this._jsonGroupKey[i];
			dataTo[colId] = dataFrom[colId]
		}
	}
};


EasySumUp.prototype._makeGroupKey = function(data){
	if (this._jsonGroupKey.length == 0) return [];

	var returnJson = [];
	for (var i=0; i < this._jsonGroupKey.length; i++){
		var levelKey = this._jsonGroupKey[i];
		if (levelKey instanceof Array) {
			var itemKeys = levelKey;
			var itemKeyValues = [];
			for (j = 0; j < itemKeys.length; j++){
				var itemKey = itemKeys[j];
				itemKeyValues[j] = data[itemKey];
			}
			returnJson[i] = itemKeyValues;
			
		} else {
			returnJson[i] = data[levelKey];
		}
	}
	
	return returnJson;
};

EasySumUp.prototype._makeGroupLevelKey = function(jsonGroupKeyValue, nGroupLevel){
	var groupLevelKey = [];
	var levelCount = this._jsonGroupKey.length;
	for (var i = 0; i < jsonGroupKeyValue.length; i++){
		// 레벨이 1이면 다 (levelCount 3가정)  levelCount - nRowLevel = 3 - 1 = 2 => i > 2 인건 없다.
		// 레벨이 2이면 끛에 하나는 null;        levelCount - nRowLevel = 3 - 2 = 1 => i > 1 인건 하나 
		// 레벨이 3이면 끝에 두개가 null;        levelCount - nRowLevel = 3 - 3 = 0 => i > 0 인건 두개 
		// 결국은 i 가 levelCount - nRowLevel 보다 크면 null;
		if (i > levelCount - nGroupLevel) {
			groupLevelKey[i] = null;
			continue;
		}
		
		// 그룹레벨별 키 범위내의 데이터 복사 
		var varKey = jsonGroupKeyValue[i];
		
		if (varKey instanceof Array) {
			var varSubKey = [];
			for (var j=0; j < varKey.length; j++) {
				varSubKey[j] = varKey[j];
			}
			groupLevelKey[i] = varSubKey;
		} else{
			groupLevelKey[i] = varKey;
		}
	}
	return groupLevelKey;
};

EasySumUp.prototype._makeGroupData = function(){
	var data = {};
	
	for (var colId in this.colInfos){
		var column = this.colInfos[colId];

		if (typeof column["colDataType"] != undefined) {
			if( column["colDataType"] == "boolean" ) {
				data[colId] = false;
			} else if( column["colDataType"] == "string" ) { //문자열
				if ( column.sumMethod === "COUNT" ) {
					data[colId] = 0;
				} else {
					data[colId] = "";
				}
			} else if( column["colDataType"] == "number" ) { //숫자
				data[colId] = typeof column.sumMethod === "undefined" ? 0 :
					          column.sumMethod === "MAX" ? Number.MIN_VALUE :
						      column.sumMethod === "MIN" ? Number.MAX_VALUE : 0 ;
			} else { //그 외
				data[colId] = null;
			} 
		} else {
			var isNumberCell = [CELLTYPE_NUMBER, CELLTYPE_PERCENT, CELLTYPE_INTEGER, CELLTYPE_BAR, CELLTYPE_CURRENCY, CELLTYPE_FLOAT, CELLTYPE_CHECKBOX].indexOf(column.cellType) >= 0;
			if (isNumberCell){
				data[colId] = 0;
			} else {
				data[colId] = "";
			}
		}
	}
	
	data.__STATE__ = {rowType: "Logical", rangeCount:0, rangeStart:0, _rowLevel: 0};
	
	return data;
};

// 줄번호 또는 데이터 객체를 인자로 받음 
EasySumUp.prototype.rows = function(numOrData){
	var data = (typeof numOrData == "number") ? this.dataSet.data[numOrData] : numOrData;
	
	var row = data.__STATE__;
	
	if (typeof row == "undefined") {
		row = data.__STATE__ = {cells:{}};
		
	} else if (typeof row["cells"] == "undefined") {
		row.cells = {};
	}
	return  row;
};

/*
 * 첫번쨰인수가 레코드 또는 배열이다
 * */
EasySumUp.prototype._checkIfGroupLevelKeyChanged = function(varObject, jsonGroupKeyValue, nGroupLevel){
	var keyChanged = false;
	
	var jsonKeyValue = [];
	var data = null;
	
	if (varObject instanceof Array){
		jsonKeyValue = varObject;
		
	} else if (typeof varObject === "object"){
		data = varObject;
		var row = this.rows(data);
		jsonKeyValue = row._jsonGroupKeyValue;
	} 
	
	for (var i = 0; i <= jsonGroupKeyValue.length - nGroupLevel; i++){
		// 그룹레벨별 키 범위내의 데이터 복사 
		var varKey1 = jsonKeyValue[i];
		var varKey2 = jsonGroupKeyValue[i]
		
		if (varKey1 instanceof Array) {
			for (var j=0; j < varKey1.length; j++) {
				if (varKey1[j] != varKey2[j]){
					keyChanged = true; break;
				}
			}
			} else{
			if (varKey1 != varKey2){
				keyChanged = true;
			}
		}
		if (keyChanged) break;
	} 
	
	return keyChanged;
};

EasySumUp.prototype._isKeyColumn = function(colId){
	
	for (var i = 0; i < this._jsonGroupKey.length; i++){
		var varKey = this._jsonGroupKey[i];
		
		if (varKey instanceof Array) {
			for (var j=0; j < varKey.length; j++) {
				if (varKey[j] == colId) return true;
			}
		} else{
			if (varKey == colId) return true;
		}
	} 
	
	return false;
	
};

EasySumUp.prototype._canAddRow = function(nRow){
	var row = this.rows(nRow);
	if (row.rowType != "Logical") return true;
	if (row._rowLevel == this._jsonGroupKey.length) return true;
	return false ;
};


EasySumUp.prototype._isLogicalRow = function(nRow){
	var row = this.rows(nRow);
	return (typeof row.rowType != "undefined" && row.rowType == "Logical") ;
};

/**
 * 그룹핑된 논리데이터의 시작값을 하나씩 미루거나 당긴다.
 * 
 * @param nRow           추가를 시작할 위치
 * @param addCount       추가할 줄수
 */
EasySumUp.prototype._updateRangeStartsAfter = function(nRow, addCount) {
	if (this._jsonGroupKey.length == 0) return;

	// 이후의 데이터의  rangeStart 속성 정리 
	for (var nRow1 = nRow; nRow1 < this.dataSet.data.length; nRow1++){
		var row = this.rows(nRow1);
		if (row.rowType != "Logical") continue;
		if (row.rangeStart > nRow) {
			row.rangeStart += addCount;
		}
	}
};

var lastGroupSearchIndex = -1;
function binaryGroupSearch(datas, data, start, end) {
	lastGroupSearchIndex = (end >= 0 &&  start > end ? end : start);
  
	if (start > end) { return -1; } //does not exist
	  
	var middle = Math.floor((start + end) / 2);
	var data1 = datas[middle];
	
	var row  = data.__STATE__;
	var row1 = data1.__STATE__;
	  
	  
	var compareResult = compareGroupKey(row1._jsonGroupKeyValue , row._jsonGroupKeyValue);
	
	if (compareResult > 0) {
		return binaryGroupSearch(datas, data, start, middle-1); 
	}
	if (compareResult < 0) { 
		return binaryGroupSearch(datas, data, middle+1, end); 
	}
	return middle; //found!
};


function compareGroupKey(jsonGroupKeyValue1, jsonGroupKeyValue2){
	for (var i = 0; i < jsonGroupKeyValue1.length; i++){
		var varKey1 = jsonGroupKeyValue1[i];
		var varKey2 = jsonGroupKeyValue2[i];
		
		if (varKey1 instanceof Array) {
			for (var j=0; j < varKey1.length ;j++) {
				var varSubKey1 = varKey1[j];
				var varSubKey2 = varKey2[j];
				if (varSubKey1 != null && varSubKey2 == null){
					return 1;
				} else if (varSubKey1 == null && varSubKey2 != null){
					return -1;
				} else  if (varSubKey1 > varSubKey2){
					return 1;
				} else if (varSubKey1 < varSubKey2){
					return -1;
				}
			}
		} else{
			if (varKey1 != null && varKey2 == null){
				return 1;
			} else if (varKey1 == null && varKey2 != null){
				return -1;
			} else  if (varKey1 > varKey2){
				return 1;
			} else if (varKey1 < varKey2){
				return -1;
			}
		}
	}
	// 마지막으로 jsonGroupKeyValue1까지는 같은데 jsonGroupKeyValue2가 뒤에 배열값이 더있는 경우
	// jsonGroupKeyValue2가 크다
	if (jsonGroupKeyValue1.length < jsonGroupKeyValue2.length){
		return -1;
	}
	
	return 0;
};

EasySumUp.prototype._refreshGroupCation = function(bUpdateGrid){
	var captions=[];
	
	// step1 -----------------------------------------------------------
	// level별 캡션을 메모한다. 
	var levelLength = this._jsonGroupKey.length;
	
	// step2 -----------------------------------------------------------
	// data 별로 루핑을 돌면서 켑션을 기억한다
	for (var nRow=0; nRow < this.dataSet.data.length; nRow++){
		var row = this.sheet.rows(nRow);
		if (typeof row._rowLevel == "undefined") row._rowLevel = 0;
		if (row._rowLevel <= 0) continue;
		
		var colId = "";
		var nGroupNdx  = row._rowLevel - 1;
    	var varKey = this._jsonGroupKey[levelLength - nGroupNdx - 1];
		if (varKey instanceof Array){
			// 하위키중 하나라도 sumMethod가 있으면 그메서드를 적용하고 
	        // 하위키 모두 있으면 나중에 나온것을 적용한다.
			for (var nGroupNdxSub = 0; nGroupNdxSub < varKey.length; nGroupNdxSub++){
				var colId0 = varKey[nGroupNdxSub];
				if (colId0 == "") continue;
				
    			if (this.colInfos[colId0].sumMethod == "TEXT") colId = colId0;
			}
			
		} else {
			if (varKey.length == 0) continue;
			if (this.colInfos[varKey].sumMethod == "TEXT") colId = varKey;
		}
		
		if (colId.length == 0) {
			row.caption = "";
			continue;
		}
		
		
		var column = this.colInfos[colId];
		var sumMethod  = column.sumMethod;
		var sumFormula = column._sumFormula;
		var sumField   = column._sumField;
		var sumText    = column._sumText;
		
		var nDataRow = this._findLastNormalRowPosition(nRow);
		var data = this.dataSet.data[nDataRow];
		
		var calcResult = null;
		if (sumFormula.length > 0){
			var rowLevel = row._rowLevel;
			calcResult = column._sumFunction(this.sheet, nDataRow, rowLevel);
		} else if (sumField.length > 0){
			calcResult = data[sumField];
		} else if (sumText.length > 0){
			calcResult = sumText;
		} else {
			calcResult = data[colId];
		}
		
		row.caption = calcResult;
	}
	
	
	// step3 -----------------------------------------------------------
	// 연결된 시트의 캡션을 갱신한다.
	
	var groupLevelLength = this._jsonGroupKey.length;
	
	for(var i = 0; i < this.dataSet.data.length; i++){
		var row = this.rows(i);
		if( row.rowType != "Logical") continue;
		
		var data = this.dataSet.data[i];
		
		for (var colId in this.colInfos){
			var column = this.colInfos[colId];
			
			if( row.rowType != "Logical" || !column._isGroupKeyField) continue;
			
			//그룹키 필드인 경우
			var levelofCol = 0;
			for(var groupKeyIdx = 0; groupKeyIdx < groupLevelLength; groupKeyIdx++){
				var groupKey = this._jsonGroupKey[groupKeyIdx];
				if( groupKey instanceof Array ){
					for(var arrayGroupKeyIdx = 0; arrayGroupKeyIdx < groupKey.length; arrayGroupKeyIdx++){
						if( colId == "" + groupKey[arrayGroupKeyIdx]){
							levelofCol = levelLength - groupKeyIdx;
							break;
						}
					}
				} else{
					if( colId == "" + groupKey){
						levelofCol = levelLength - groupKeyIdx;
						break;
					}
				}
			}
			
			var levelOfRow = 0;
			var groupCaption = "";
			if( levelofCol > row._rowLevel ){
				groupCaption = "";
			}
			else{
				groupCaption = (levelofCol == row._rowLevel ? row.caption : "");
				levelOfRow = row._rowLevel;
			}
			
			if(levelOfRow > 0){
				data[colId] = groupCaption;
			}
		}
	}
	return;
};
/**
 *  ( 
 *    colinfos:[
 *    		{colId:"code", size:"256", type:"STRING"}, 
 *    		{colId:"name", size:"256", type:"STRING"}],
 *    datas:[
 *    		{code:1, name:"코드"}, 
 *    		{code:2, name:"명"}]
 *  }
 */


// 특정 피벗 실행하기 위한 STATATIC METHOD 
var EASY_PIVOT_POOL = {};
var pivotAgent = pivotAgent || {};
pivotAgent.PoolIn = function(taskName, pivot){ EASY_PIVOT_POOL[taskName] = pivot; };
pivotAgent.PoolOut = function(taskName){ delete EASY_PIVOT_POOL[taskName]; };
pivotAgent.IsInPivotPool = function(taskName){ 
	var strTaskName = taskName.replace("fillJob_", "").replace("fillList_", "");
	return typeof EASY_PIVOT_POOL[strTaskName] != "undefined"; 
};
pivotAgent.RunPivot = function(taskName, dataSet){
	var strTaskName = taskName.replace("fillJob_", "").replace("fillList_", "");
	EASY_PIVOT_POOL[strTaskName].refreshPivot(dataSet);
};

function EasyPivot(sheet, jsonObject) // constructor
{
	this.sheet = sheet || "";   
	this.dataSet = new WsDataSet();  
	
	this.taskName = "";
	
	this.colInfos = {};
	this.footerInfos = [];
	
	this._groupKey= "";         // Dataset의 GroupKey
	this._jsonGroupKey = [];      // 사용예 "A:B,C,D" 인 경우   [["A","B"],"C","D"]  주의:키필드에 sumMethod가 있어야 한다.
	this._needGroupKey = [null];      // 사용예 2레벨을 출력 않는 경우  [true, false, true]

	this._pivotKey = "";          // Logical Dataset에 PivotTable을 구성하기 위한 PivotColumn
	this._jsonPivotKey = [];      // 사용예 "A:B,C,D" 인 경우   [["A","B"],"C","D"]
	this._needPivotKey = [null];      // 사용예 2레벨을 출력 않는 경우  [true, false, true]
	
	this._pivotCaptions = [];     // 피벗셍의 레벨별 타이틀, 켑션 또는 칼럼아니디, 또는 산식이 들어감
	this._groupCaptions = [];     // 그룹필드 상단에 보여질 칼럼타이틀
	
	// 합계열 추가정보 
	this._arrMoreSumInfos = [];    // 주가 합계열 정보 -형식: [{headerText:"XXX", colId:"XXX", sumMethod:"XXX", columnInfo:{AUI그리드의 포멧 }}, ...]  
	                               // -사용예: [{headerText:"전년합계", colId:"D1", sumMethod:"SUM"},{headerText:"전년평균", colId:"D1", sumMethod:"AVG"}]
	
	this._arrGroupKeys = [];     // 그룹 키 결과 배열 
	this._arrPivotKeys = [];     // 피벗 키 결과 배열 
	this._arrDatas     = [];     // 피벗 셀 데이터 배열
	this._arrSumDatas  = [];     // 평균계산을 위한 합계 데이터
	this._arrSheetColIds = [];    // 칼럼아이디 목록
	this._rowCount_NonGroup = 0; // 집계셀을 제외한 줄수. 계산시 분모로 사용됨

	this._arrMoreColumnDatas = []; // 추가합계가 채워진 결과 배열 - _arrMoreSumInfos의 숫자와 맞아야 함 
	
    this._arrFooterSums = [];      // footer 계산 정보 [{sum: 0, max: null, min: null, count: 0, value: undefined}, ...]
    
    this._arrPivotCaptions = [];
    this._arrGroupCaptions = [];
    
	this._pivotIndex = 0;        // Pivot Dataset에서 현재 선택된 PivotColumn의 Index
	this._pivotIndexCount = 0;   // Pivot Dataset의 Pivot된 갯수
	this._reverseSubsum = false; // Dataset의 GroupKey에 의한 SubSum을 역순으로 처리할지 지정하는 Property 

	// 시트와 순환 참조되는 부분에서 자체메서드 호출 차단시 사용
	this._skipFlag = false;
	
	if (jsonObject) {
		this.configure(jsonObject);
	}
	
	// 시트 컬럼 속성 적용을 위해 
	this._originSheetColumns = [];
	if ( this.sheet != "" ) {
		var column = null; var originColumn = null; var key = null;
		var columnCount = this.sheet.maxCols;
		var i = 0;
		
		for(i = 0; i < columnCount; i++, column = null, originColumn = null){
			column = this.sheet.columns[i];
			originColumn = this._originSheetColumns[i] = new EXOColumn();
			
			for(key in column){
				originColumn[key] = column[key];
				key = null;
		    }
		}
	}
	
	// 이벤트 추가 
	this.fncPivotChangeEvent = null;
    this.hasPivotChangeEvent = (typeof self[this.sheet.controlId + "_onPivotChanged"] != "undefined");
    if (this.hasPivotChangeEvent){
    	/**
    	 * 셀 내용 변경 (Change) 이벤트 .
    	 *
    	 * @event EasySheet#EasySheet_EasySheet_change
    	 * @type {Object}
         * @return {Boolean} - 동작 취소 여부(false: 후속 동작이 취소된다) 
    	 * @property {Number} rowNum   - 수정된 줄번호
    	 * @property {Number} colNum   - 수정된 열번호
    	 * @property {Number} value    - 수정 후 셀값
    	 * @property {Number} oldValue - 수정 전 셀값
    	 */
    	this.fncPivotChangeEvent = new Function("return function (rowNum, ColId, value, oldValue) { return " + this.sheet.controlId + "_onPivotChanged(rowNum, ColId, value, oldValue); }")();
    }
};

EasyPivot.prototype.configure = function(jsonObject){
	// 가져오기에서 호출할 수 있게 기억해줌
	this.taskName = jsonObject.taskName;
	pivotAgent.PoolIn(this.taskName, this);
	
	if (jsonObject.colInfos){
		var colInfos = jsonObject.colInfos;
		for (var i = 0; i < colInfos.length; i++){
			var colInfo = colInfos[i];
			
			if (typeof colInfo["sumMethod"] != "undefined"){
				colInfo.sumMethod = colInfo.sumMethod.replace(/TEXT:/i,"TEXT:")
				                                     .replace(/SUM:/i,"SUM:")
				                                     .replace(/AVG:/i,"AVG:")
				                                     .replace(/COUNT:/i,"COUNT:")
				                                     .replace(/MAX:/i,"MAX:")
				                                     .replace(/MIN:/i,"MIN:")
				                                     .replace(/^TEXT$/i,"TEXT")
				                                     .replace(/^SUM$/i,"SUM")
				                                     .replace(/^AVG$/i,"AVG")
				                                     .replace(/^COUNT$/i,"COUNT")
				                                     .replace(/^MAX$/i,"MAX")
				                                     .replace(/^MIN$/i,"MIN"); // 대소문자 통일
			}
			
			this.colInfos[colInfo.colId]= new EXOColumn(colInfo);
			var colDataType = typeof colInfo.colDataType != "undefined" ? colInfo.colDataType : String;
			if ( typeof colInfo.fieldtype != "undefined"){
				colDataType = colInfo.fieldtype == "Char" ? "string" :
  				  				colInfo.fieldtype == "Memo" ? "string" :  
  				  					colInfo.fieldtype == "SmallInt" ? "number" :
  				  						colInfo.fieldtype == "Integer" ? "number" :
  				  							colInfo.fieldtype == "Double" ? "number" :
  				  								colInfo.fieldtype == "Currency" ? "number" :"string";
			}
				              
			
			this.dataSet.addField({field: colInfo.colId, fieldName: colInfo.colId, dataType: colDataType});
		}
	}
	if (jsonObject.footerInfos){
		var footerInfos = jsonObject.footerInfos; 
		for (var i = 0; i < footerInfos.length; i++){
			var footerInfo = footerInfos[i];
			this.footerInfos[i]= new EXOColumn(footerInfo);
		}
	}
	if (jsonObject.groupKey){
		this.setGroupKey(jsonObject.groupKey);
	}
	if (jsonObject.pivotKey){
		this.setPivotKey(jsonObject.pivotKey);
	}
	if (jsonObject.pivotCaptions){
		this.setPivotCaptions(jsonObject.pivotCaptions);
	}
	if (jsonObject.groupCaptions){
		this.setGroupCaptions(jsonObject.groupCaptions);
	}
	// sheetHeader 는 시트헤더 정보를  pivotCaptions, groupCaptions로 전환한다 
	if (jsonObject.sheetHeaders){
		if (this.sheet != undefined && this.sheet != ""){
			for(i = 0; i < this._jsonGroupKey.length; i++){
				jsonObject.sheetHeaders[i].caption = this.sheet.getHeaderTitle(0, i);
			}
		}
		
		this.setSheetHeaders(jsonObject.sheetHeaders);
	}
	
	if (jsonObject.arrMoreSumInfos){
		this._arrMoreSumInfos= jsonObject.arrMoreSumInfos;
	}
	if (jsonObject.sheetColIds){
		this._arrSheetColIds= jsonObject.sheetColIds;
	}
	
	// 배열로 데이터를 받거나 데이터 셋을 받는다 
	if (jsonObject.arrData instanceof Array && 
			jsonObject.arrData.length > 0){
		this.dataSet.setDataArray(jsonObject.arrData);
		
	} else if (jsonObject.dataSet){
		this.dataSet.setDataSet(jsonObject.dataSet);
	} 
};

// 클리어시 동작 
EasyPivot.prototype.clear = function(){
	// 다음 항목은 설정항목으로 지워지면 안된다 
	/*
	    this.sheet
		this.colInfos
		this.footerInfos
		
		this._groupKey
		this._pivotKey
		this._pivotCaptions
		this._groupCaptions
		this._arrMoreSumInfos
		this._arrSheetColIds
		
		this._jsonGroupKey
		this._jsonPivotKey
		this._groupCaptions
		this._pivotCaptions
		
		this._reverseSubsum
	 * */
	
	
	this._needGroupKey = [null];      // 사용예 2레벨을 출력 않는 경우  [true, false, true]
	this._needPivotKey = [null];      // 사용예 2레벨을 출력 않는 경우  [true, false, true]
	
	this._arrGroupKeys.clear();     // 그룹 키 결과 배열 
	this._arrPivotKeys.clear();     // 피벗 키 결과 배열 
	this._arrDatas.clear();     	// 피벗 셀 데이터 배열
	this._arrSumDatas.clear();     	// 평균계산을 위한 합계 데이터
	this._rowCount_NonGroup = 0; 	// 집계셀을 제외한 줄수. 계산시 분모로 사용됨

	this._arrMoreColumnDatas.clear(); // 추가합계가 채워진 결과 배열 - _arrMoreSumInfos의 숫자와 맞아야 함 
	
    this._arrFooterSums.clear();      // footer 계산 정보 [{sum: 0, max: null, min: null, count: 0, value: undefined}, ...]
    
	this._pivotIndex = 0;        	// Pivot Dataset에서 현재 선택된 PivotColumn의 Index
	this._pivotIndexCount = 0;   	// Pivot Dataset의 Pivot된 갯수
	
	
	
	
};


// 줄번호 또는 데이터 객체를 인자로 받음 
EasyPivot.prototype.rows = function(numOrData){
	var data = (typeof numOrData == "number") ? this.dataSet.data[numOrData] : numOrData;

	return  data.__STATE__;
};

/**
 * Dataset이 Bind할 EasyPivot Object를 리턴하는 Proeprty 입니다.
 * 
 * @param addCount       추가할 줄수
 * @return               (EasyPivot) Binde된 EasyPivot
 */
EasyPivot.prototype.getDataSet = function(){ return this.dataSet;};

/**
 * Dataset이 Bind할 EasyPivot Object를 지정하는 Proeprty 입니다.
 * 
 * @param dataSet     (EasyPivot) Bind할 EasyPivot Object
 */
EasyPivot.prototype.setDataSet = function(dataSet){
	this.dataSet = dataSet;

	if (dataSet.datas.length == 0) return;
	return;
};


EasyPivot.prototype.setPivotCaptions = function(arrText){
	this._pivotCaptions = [null].concat(arrText);		
};

EasyPivot.prototype.setGroupCaptions = function(arrText){
	this._groupCaptions = [null].concat(arrText);		
};

// sheetHeader 예제
EasyPivot.prototype.setSheetHeaders = function(arrSheetHeaders){
	var groupCount = this._jsonGroupKey.length;
	
	for (var i=0; i < arrSheetHeaders.length; i++){
		var json = arrSheetHeaders[i];
		//  셀의 캡션은 row 속성을 주지 않았으므로 최대값 999 로 세팅한다  
		json.row = (typeof json.row == "undefined") ? 999 : json.row;
	}
	
	// row, col 순으로 sort
	arrSheetHeaders.sort(function(json1, json2){ 
		    return json1.row > json2.row ?  1 :
		    	   json1.row < json2.row ? -1 :
		    	   json1.col > json2.col ?  1 :
		    	   json1.col < json2.col ? -1 : 0;   
		});
	
	// _groupCaptions 작성
	var groupCaptions = [null];
	for(var i=0; i < groupCount;i++){
		var json = arrSheetHeaders[i];
		groupCaptions.push(json.caption);
	}
	this._groupCaptions = [].concat(groupCaptions);
	
	// _pivotCaptions 작성
	var pivotCaptionCol = groupCount + 1;
	var pivotCaptions = [null];
	for(var i=0; i < arrSheetHeaders.length; i++){
		var json = arrSheetHeaders[i];
		if (json.row == 999) break;
		if (json.row == 1 && json.col < pivotCaptionCol) continue;
		if (json.row > 1 && json.col + groupCount < pivotCaptionCol) continue; // 두번쨰 줄은 병합 상태를 반영해야 한다.
		
		pivotCaptions.push(json.caption);
	}
	this._pivotCaptions = [].concat(pivotCaptions);
	
	// 타이틀 캡션을  pivotCaptions 배열에 추가 
	var titles = [];
	for(var i=0; i < arrSheetHeaders.length; i++){
		var json = arrSheetHeaders[i];
		if (json.row != 999) continue;;
		if (json.col < pivotCaptionCol) continue;
		
		titles.push(json.caption);
	}
	this._pivotCaptions.push(titles);
	
	// 완성된 모습
	// groupCaptions:	["상품명", "분기"]
	// pivotCaptions:	["month + 111",["매출액", "매출원가"]]
};

EasyPivot.prototype.refreshPivot = function(dataSet){
	
	// 인수로 데이터셋을 받으면 넣어준다.
	if (typeof dataSet != "undefined"){
		this.dataSet.setDataSet(dataSet);
	}
	
	// STEP0 -----------------------------------------------------------------
	// 바인드된 시트객체를 를 찾고 데이터 필드를 메모한다

	// _jsonPivotKey가 생성되지 않았으면 생성한다.
	this._jsonPivotKey.clear();
	var levelKeyArr = this._pivotKey.split(",");
	for (var i=0; i < levelKeyArr.length; i++){
		var levelKey = levelKeyArr[i];
		if (levelKey.indexOf(":") >= 0){
			this._jsonPivotKey[i] = levelKey.split(":");
		} else {
			this._jsonPivotKey[i] = levelKey;
		}
	}

	// 피벗키 길이 
	var pivotKeyLength = this._jsonPivotKey.length;
	var groupKeyLength = this._jsonGroupKey.length;

	var arrSheetColIds = this._arrSheetColIds;
		
	var arrFormulaOfLevel =[];
    for (var nPivotLevel = 1; nPivotLevel <= pivotKeyLength; nPivotLevel++ ){
    	var formula = this._pivotCaptions[nPivotLevel];
    	if (formula.trim().length == 0){
    		arrFormulaOfLevel[nPivotLevel] = "";
    		continue;
    	} 
    	if (typeof this.colInfos[formula] != "undefined"){
    		arrFormulaOfLevel[nPivotLevel] = formula;
    		continue;
    	}
    	
    	// '='로 시작하지 않으면 그냥 캡션이므로 문자열 산식으로 바꾸어 준다. 
    	if (formula.trim().indexOf("=") == 0) {
    		formula = formula.substring(1);
    	} else {
    		formula = "\"" + formula + "\"";
    	}
    	
    	arrFormulaOfLevel[nPivotLevel] = "formula:" + formula;
    	    	
		for (var colId in this.colInfos){
			var regExp1 = new RegExp("([ {(\+\-\/\*])(" + colId + ")([ {(\+\-\/\*])", "g");
			var regExp2 = new RegExp("^(" + colId + ")([ {(\+\-\/\*])", "g");
			var regExp3 = new RegExp("([ {(\+\-\/\*])(" + colId + ")$", "g");
			var regExp4 = new RegExp("^" + colId + "$", "g");
			
			
			formula = formula.replace(regExp1, "$1_#" + colId + "_#$3" )
			                 .replace(regExp2, "_#" + colId + "_#$2" )
			                 .replace(regExp3, "$1_#" + colId + "_#" )
			                 .replace(regExp4, "_#" + colId + "_#" );
		}
		for (var colId in this.colInfos){
			var regExp = new RegExp(escapeRegExp("_#" + colId + "_#"), "g");
			formula = formula.replace(regExp, "data[\"" + colId + "\"]" );
		}
   	
        this["_pivotCaptionFormula_" + nPivotLevel] = new Function("return function (sheet, data) { return " + this.sheet._updateFormula(formula) + "; }")();
    }
    
    
	// 그룹키 산식  
    this.setGroupKey(this._groupKey);
	var arrFormulaOfGroupLevel =[];
    for (var nGroupLevel = 1; nGroupLevel <= groupKeyLength; nGroupLevel++ ){
    	var colId = this._jsonGroupKey[nGroupLevel - 1];
    	var formula = this.colInfos[colId].sumMethod.trim();
    	
    	if (formula.length == 0){
    		arrFormulaOfGroupLevel[nGroupLevel] = "";
    		continue;
    	} 
    	if (typeof this.colInfos[formula] != "undefined"){
    		arrFormulaOfGroupLevel[nGroupLevel] = formula;
    		continue;
    	}
    	
    	// "TEXT:" 문자열 제거 
		if (formula.substring(0,5).toUpperCase() == "TEXT:"){
			formula = formula.substring(5);
		}
    	
    	// '='로 시작하지 않으면 그냥 캡션이므로 문자열 산식으로 바꾸어 준다. 
    	if (formula.indexOf("=") == 0) {
    		formula = formula.substring(1);
    	} else {
    		formula = "\"" + formula + "\"";
    	}
    	
    	arrFormulaOfGroupLevel[nGroupLevel] = "formula:" + formula;
    	    	
		for (var colId in this.colInfos){
			var regExp1 = new RegExp("([ {(\+\-\/\*])(" + colId + ")([ {(\+\-\/\*])", "g");
			var regExp2 = new RegExp("^(" + colId + ")([ {(\+\-\/\*])", "g");
			var regExp3 = new RegExp("([ {(\+\-\/\*])(" + colId + ")$", "g");
			var regExp4 = new RegExp("^" + colId + "$", "g");
			
			
			formula = formula.replace(regExp1, "$1_#" + colId + "_#$3" )
			                 .replace(regExp2, "_#" + colId + "_#$2" )
			                 .replace(regExp3, "$1_#" + colId + "_#" )
			                 .replace(regExp4, "_#" + colId + "_#" );
		}
		for (var colId in this.colInfos){
			var regExp = new RegExp(escapeRegExp("_#" + colId + "_#"), "g");
			formula = formula.replace(regExp, "data[\"" + colId + "\"]" );
		}
   	
        this["_groupCaptionFormula_" + nGroupLevel] = new Function("return function (sheet, data) { return " + this.sheet._updateFormula(formula) + "; }")();
    }
    
    // 피벗키, 그룹키  생략정보 미리 파악
    for (var nPivotLevel = 1; nPivotLevel <= pivotKeyLength; nPivotLevel++ ){
    	var wKey = this._jsonPivotKey[nPivotLevel - 1];
    	if (wKey instanceof Array){
    		this._needPivotKey[nPivotLevel] = false;
    		
    		for (var nSubLevel = 0; nSubLevel < wKey.length; nSubLevel++ ){
    			var colId =  wKey[nSubLevel];
    			var sumMethod = this.colInfos[colId].sumMethod;
    			if (sumMethod.trim().length != 0){
    				this._needPivotKey[nPivotLevel] = true;
    				break;
    			}
    		}
    		
    	} else {
    		var colId = wKey;
    		var sumMethod = this.colInfos[colId].sumMethod;
    		this._needPivotKey[nPivotLevel] = (sumMethod.trim().length != 0);
    	}
    }
    
    for (var nGroupLevel = 1; nGroupLevel <= groupKeyLength; nGroupLevel++ ){
    	var wKey = this._jsonGroupKey[nGroupLevel - 1];
    	
    	if (wKey instanceof Array){
    		this._needGroupKey[nGroupLevel] = false;
    		
    		for (var nSubLevel = 0; nSubLevel < wKey.length; nSubLevel++ ){
    			var colId =  wKey[nSubLevel];
    			var sumMethod = this.colInfos[colId].sumMethod;
    			if (sumMethod.trim().length != 0){
    				this._needGroupKey[nGroupLevel] = true;
    				break;
    			}
    		}
    		
    	} else {
    		var colId = wKey;
    		var sumMethod = this.colInfos[colId].sumMethod;
    		this._needGroupKey[nGroupLevel] = (sumMethod.trim().length != 0);
    	}
    }
    
    // STEP1 -----------------------------------------------------------------
    // Pivot 키를 만들고 
    // 그룹키가 없어도 있다 없어지는 경우가 있으므로 두어야 한다 
    
    var arrPivotKeys = []; ndx = 0;
    var arrPivotCaptions = []; // 캡션이 들어가는 난
    
    for (var rowNum = 0; rowNum < this.dataSet.data.length; rowNum++){
    	var data = this.dataSet.data[rowNum];
    	if (data.rowType == "Logical") continue;
    	
    	arrPivotCaptions[ndx] = this._makePivotCaption(data, arrFormulaOfLevel, rowNum);
    	
    	data._jsonPivotKeyValue = this._makePivotKey(data);
    	arrPivotKeys[ndx] = this._clonePivotKey(data._jsonPivotKeyValue);
    	arrPivotKeys[ndx].ndx = ndx; // <-- 소팅후 arrPivotCaptions을 순서를 같게 만드는 작업을 위해서 기록
    	
    	ndx++;
    }
    
    var arrGroupCaptions = this._groupCaptions; // 그룹의 상단 캡션이 들어가는 난
    
    // GroupKey를 만들고 
    var arrGroupKeys = []; ndx = 0;
    for (var rowNum = 0; rowNum < this.dataSet.data.length; rowNum++){
    	var data = this.dataSet.data[rowNum];
    	if (data.rowType == "Logical") continue;
    	
    	data._jsonGroupKeyValue = this._makeGroupKey(data);
    	arrGroupKeys[ndx] = this._clonePivotKey(data._jsonGroupKeyValue);
    	arrGroupKeys[ndx].ndx = ndx; 
    	
    	
    	var arrLabel = new Array(groupKeyLength);
    	for (var i=0; i < groupKeyLength; i++){
    		var colId = arrSheetColIds[i];
    		arrLabel[i] = data[colId];
    	}
    	arrGroupKeys[ndx].arrLabel = arrLabel;
    	
    	ndx++;
    }
    
    // STEP2 -----------------------------------------------------------------
    // pivot Key Sort
    arrPivotKeys.sort(function(arrKey1, arrKey2){ return comparePivotKey(arrKey1, arrKey2);});
    
    // group Key Sort
    arrGroupKeys.sort(function(arrKey1, arrKey2){return comparePivotKey(arrKey1, arrKey2);});
    
    // STEP3 -----------------------------------------------------------------
    // pivot 키 중복 제거
    var belowKey = [];
    for (var i = arrPivotKeys.length - 1; i >= 0; i--){
    	if (belowKey.length != 0){
    		if (comparePivotKey(arrPivotKeys[i], belowKey) == 0){
    			arrPivotKeys.splice(i, 1);
    			continue;
    		}
    	}
    	belowKey = arrPivotKeys[i];
    }
    
    // group 키 중복 제거
    belowKey = [];
    for (var i = arrGroupKeys.length - 1; i >= 0; i--){
    	if (belowKey.length != 0){
    		if (comparePivotKey(arrGroupKeys[i], belowKey) == 0){
    			arrGroupKeys.splice(i, 1);
    			continue;
    		}
    	}
    	belowKey = arrGroupKeys[i];
    }
    belowKey = null;
    
    this._rowCount_NonGroup = arrGroupKeys.length;
    
    // arrPivotCaptions 순서 맞추기 
    var tmpArrPivotCaptions = [];
    for (var i = 0; i < arrPivotKeys.length; i++){
    	var ndx = arrPivotKeys[i].ndx;
    	tmpArrPivotCaptions[i] = arrPivotCaptions[ndx];
    	delete arrPivotKeys[i].ndx;
    }
    
    for (var i = arrPivotCaptions.length - 1; i >= 0; i--){
    	arrPivotCaptions.pop();
    }
    
    // ndx재부여
    for (var i = 0; i < arrPivotKeys.length; i++){
    	arrPivotKeys[i].ndx = i;
    }
    
    arrPivotCaptions = tmpArrPivotCaptions;
    tmpArrPivotCaptions = null;
    
    // STEP4 -----------------------------------------------------------------
    // pivot 집계키 만들기
    var pivotItemKey= [];
    var pivotLevelKeys= [null];
    var pivotLevelKey = [];
    
    var pivotItemCaption= [];
    var pivotLevelCaptions= [null];
    var pivotLevelCaption = [];
    var levelCount = this._jsonPivotKey.length;

    // 데이터를 처음부터 끝까지 돌리면서 레벨 정보를 집계한다
    // 사용변수    
    //           arrPivotKeys: 피벗키 목록, pivotItemKey: 피벗 목록중의 작업대상 하나,    
    //           arrPivotCaptions: 피벗 캡션 목록, pivotItemCaption: 피벗 캡션 목록중 하나의 피벗 캡션    
    //           pivotLevelKeys:  단계별 여러 집계데이터의 피벗 키 , pivotLevelKey: 집계데이터내의  하나의 피벗키
    //           pivotLevelCaptions:  단계별 여러 집계데이터의 피벗 캡션 , pivotLevelCaption: 집계데이터내의  하나의 캡션
    for (var nRow = 0; nRow < arrPivotKeys.length; nRow++){
    	pivotItemKey = arrPivotKeys[nRow];
    	pivotItemCaption = arrPivotCaptions[nRow];
    	
    	if (nRow == 0){
    		// 레벨별 그룹데이터를 만들고 첫데이터를 기준으로키값을 세팅한다
    		for (var nPivotLevel = 1; nPivotLevel <= levelCount; nPivotLevel++ ){
    			if (!this._needPivotKey[nPivotLevel]) continue;
    			pivotLevelKeys[nPivotLevel] = this._makePivotLevelKey(pivotItemKey, nPivotLevel);
    			pivotLevelCaptions[nPivotLevel] = this._makePivotLevelCaption(pivotItemCaption, nPivotLevel); 
    		}
    		continue;
    	}
    	
    	for (var nPivotLevel = levelCount;  nPivotLevel >= 1; nPivotLevel-- ){
    		if (!this._needPivotKey[nPivotLevel]) continue;
    		
    		pivotLevelKey = pivotLevelKeys[nPivotLevel];
    		pivotLevelCaption = pivotLevelCaptions[nPivotLevel];
    		
    		// 필터링 안된 첫데이터가 아니면서, 키가 바뀌었으면
    		var keyChanged = (nRow > 0 && _checkIfPivotLevelKeyChanged(pivotItemKey, pivotLevelKey, nPivotLevel));
    		
    		// 키가 변경되었으면 논리레코드를 추가하고 새로운 레코드를 만든다 
    		if (keyChanged){
    			// 레코드 추가 
    			arrPivotKeys.splice(nRow, 0, pivotLevelKey);
    			arrPivotCaptions.splice(nRow, 0, pivotLevelCaption);
    			
    			nRow++;
    			
    			// 레코드 초기화 
    			pivotLevelKeys[nPivotLevel] = this._makePivotLevelKey(pivotItemKey, nPivotLevel);
    			pivotLevelCaptions[nPivotLevel] = this._makePivotLevelCaption(pivotItemCaption, nPivotLevel);
    		}
    	} // 그룹 레벨별 루프 종료 
    	
    }
	
    for (var  nPivotLevel = levelCount;  nPivotLevel >= 1;nPivotLevel-- ){
    	if (!this._needPivotKey[nPivotLevel]) continue;
    	
    	arrPivotKeys.push(pivotLevelKeys[nPivotLevel]);
    	arrPivotCaptions.push(pivotLevelCaptions[nPivotLevel]);
    }
    
    // 그룹별 데이터 채우기 
    var groupItemKey= [];
    var groupItemKeyOld= [];
    var groupLevelKey = [];
    var arrGroupKeysTemp = [];    
    
    levelCount = this._jsonGroupKey.length;
    
    // 데이터를 처음부터 끝까지 돌리면서 레벨 정보를 집계한다
    for (var nRow = 0; nRow < arrGroupKeys.length; nRow++){
    	groupItemKey = arrGroupKeys[nRow];
    	
    	for (var nGroupLevel = levelCount;  nGroupLevel >= 1; nGroupLevel-- ){
    		if (nRow == 0) break;  // 첫줄은 집계 필요 없음 
    		if (!this._needGroupKey[nGroupLevel]) continue;
    		
    		groupLevelKey = this._makePivotLevelKey(groupItemKeyOld, nGroupLevel);
     		
    		// 필터링 안된 첫데이터가 아니면서, 키가 바뀌었으면
    		var keyChanged = (_checkIfPivotLevelKeyChanged(groupItemKey, groupItemKeyOld, nGroupLevel));
    		
    		// 키가 변경되었으면 논리레코드를 추가하고 새로운 레코드를 만든다 
    		if (keyChanged){
    	    	// 그룹캡션 정비 
    	    	var rowNum = groupItemKeyOld.ndx;
    	    	var data = this.dataSet.data[rowNum];
    	    	groupLevelKey.arrLabel = this._makeGroupCaption(data, arrFormulaOfGroupLevel, rowNum, nGroupLevel);
    	    	
    	    	// 레코드 추가 
    	    	arrGroupKeysTemp.push(groupLevelKey);
    		} else {
    			groupLevelKey.ndx = groupItemKey.ndx;
    		}
    	} // 그룹 레벨별 루프 종료
    	
    	// 직전 데이터 메모 
    	for (var i = 0; i < groupItemKey.length; i++ ){
    		groupItemKeyOld[i] = groupItemKey[i];
    	}
    	groupItemKeyOld.ndx = groupItemKey.ndx; 
    }
    
    for (var nGroupLevel = levelCount; nGroupLevel >= 1; nGroupLevel-- ){
    	if (this.dataSet.data.length == 0) break;
    	if (!this._needGroupKey[ nGroupLevel]) continue;
    	
    	var groupLevelKey = this._makePivotLevelKey(groupItemKeyOld, nGroupLevel);
    	groupLevelKey.ndx = groupItemKeyOld.ndx;
    	
    	// 그룹캡션 정비 
    	var rowNum = groupLevelKey.ndx;
    	var data = this.dataSet.data[rowNum];
    	groupLevelKey.arrLabel = this._makeGroupCaption(data, arrFormulaOfGroupLevel, rowNum, nGroupLevel);
    	
    	arrGroupKeysTemp.push(groupLevelKey);
    }
    
    // Temp에 만들어진 집계키를 그룹키 목록에 붓는다. 
    for (var i=0; i < arrGroupKeysTemp.length;i++){
    	arrGroupKeys.push(arrGroupKeysTemp[i]);
    }
    arrGroupKeys.sort(function(arrKey1, arrKey2){return comparePivotKey(arrKey1, arrKey2);});
    

    
    // STEP5-0 -----------------------------------------------------------------
    // 헤더의 자식 카운트수 집계  
    for (var pivotNdx=0; pivotNdx < arrPivotKeys.length; pivotNdx++){
    	if (arrPivotKeys[pivotNdx][pivotKeyLength - 1] == null) continue;
    	
    	var arrPivotKey = this._clonePivotKey(arrPivotKeys[pivotNdx]);
    	for (var ndx = pivotKeyLength - 1; ndx >= 0; ndx--){
    		arrPivotKey[ndx] = null;
    		if (!this._needPivotKey[ndx + 1]) continue;
    		
    		var colIndex = binaryPivotSearch(arrPivotKeys, arrPivotKey, 0, arrPivotKeys.length - 1);
    		if (colIndex == -1){
    			if(typeof console != "undefined" && typeof console.log == "function")	console.log("Pivot 위치를 찾지 못했습니다.");
    			continue;
    		}
    		if (typeof arrPivotKeys[colIndex].cnt == "undefined"){
    			arrPivotKeys[colIndex].cnt = 1;
    		} else {
    			arrPivotKeys[colIndex].cnt += 1;
    		}
    	}
    }
    for (var groupNdx=0; groupNdx < arrGroupKeys.length; groupNdx++){
    	if (arrGroupKeys[groupNdx][groupKeyLength - 1] == null) continue;
    	
    	var arrGroupKey = this._clonePivotKey(arrGroupKeys[groupNdx]);
    	for (var ndx = groupKeyLength - 1; ndx >= 0; ndx--){
    		arrGroupKey[ndx] = null;
    		
    		if (!this._needGroupKey[ndx + 1]) continue;
    		
    		var rowIndex = binaryPivotSearch(arrGroupKeys, arrGroupKey, 0, arrGroupKeys.length - 1);
    		if (rowIndex == -1){
    			if(typeof console != "undefined" && typeof console.log == "function")	console.log("Group 위치를 찾지 못했습니다.");
    			continue;
    		}
    		if (typeof arrGroupKeys[rowIndex].cnt == "undefined"){
    			arrGroupKeys[rowIndex].cnt = 1;
    		} else {
    			arrGroupKeys[rowIndex].cnt += 1;
    		}
    	}
    }
    
    // STEP5 -----------------------------------------------------------------
    // Pivot 데이터에 데이 칼럼명 추가
    // 피봇키가 아닌항목까지를 키에 추가한다  
    var arrResultPivotKeys = [];
    var arrResultPivotCaptions = [];
    var ndx = 0;
    for (var i = 0; i < arrPivotKeys.length; i++){
    	for (var j=groupKeyLength; j < arrSheetColIds.length; j++){
    		var k = j - groupKeyLength;
    		var tmpArrKey = this._clonePivotKey(arrPivotKeys[i]);
    		var tmpArrCaption = this._clonePivotKey(arrPivotCaptions[i]);
    		
    		var colId = arrSheetColIds[j];
    		tmpArrKey[pivotKeyLength] = colId; // 데이터 한칸 더추가
    		tmpArrCaption[pivotKeyLength] = this._pivotCaptions[pivotKeyLength +1][k]; // 데이터 한칸 더추가
    		
    		arrResultPivotKeys[ndx] = tmpArrKey;
    		arrResultPivotCaptions[ndx] = tmpArrCaption;
    		
    		if (typeof arrPivotKeys[i].ndx != "undefined") {
    			arrResultPivotKeys[ndx].ndx = arrPivotKeys[i].ndx;
    		}
    		if (typeof arrPivotKeys[i].cnt != "undefined") {
    			arrResultPivotKeys[ndx].cnt = arrPivotKeys[i].cnt;
    		}
    		ndx++;
    	}
    }
    
    // 배열
    for (var i = arrPivotKeys.length - 1; i >= 0; i--){
    	arrPivotKeys.pop();
    	arrPivotCaptions.pop();
    }
    
    arrPivotKeys = arrResultPivotKeys;
    arrResultPivotKeys = null;
    arrPivotCaptions = arrResultPivotCaptions;
    arrResultPivotCaptions = null;
    
    
    // footer 레코드 생성 
    var arrFooterSums = new Array(arrPivotKeys.length);
    for (var i = 0; i < arrPivotKeys.length; i++){
    	arrFooterSums[i] = {sum: 0, max: null, min: null, count: 0, value: undefined};
    }
    this._arrFooterSums = arrFooterSums;
    
	// STEP6 -----------------------------------------------------------------
    // 데이터 들어갈 배열 선언 
    var maxRows = arrGroupKeys.length;
    var maxCols = arrPivotKeys.length;
    var arrDatas = [];
    var arrSumDatas  = [];
    for (var nRow=0; nRow < maxRows; nRow++){
    	arrDatas[nRow] = new Array(maxCols);
    	arrSumDatas[nRow] = new Array(maxCols);
    }
	
	// 다음 동작을 위하여 메모 
	this._arrPivotKeys = arrPivotKeys;
	this._arrGroupKeys = arrGroupKeys;
	this._arrDatas     = arrDatas;
	this._arrSumDatas  = arrSumDatas;
	
	// colId가 알파벳순이 아니므로 바이너리 서치를 또하나의 서칭어래이 만들고 
	// 월래 칼럽인덱스를 기록한다 
	var arrPivotKeysForSearch = [];
	for (var i = 0; i < arrPivotKeys.length; i++){
		arrPivotKeysForSearch[i] = arrPivotKeys[i];
		arrPivotKeysForSearch[i].seq = i;
	}
	arrPivotKeysForSearch.sort(function(arrKey1, arrKey2){return comparePivotKey(arrKey1, arrKey2);});
	this._arrPivotKeysForSearch = arrPivotKeysForSearch;
	
    // 데이터 넣기
	for (var rowNum = 0; rowNum < this.dataSet.data.length; rowNum++){
		var data = this.dataSet.data[rowNum];

		
		for (var i = groupKeyLength; i < arrSheetColIds.length; i++){
			var colId = arrSheetColIds[i];
			var sumMethod = this.colInfos[colId].sumMethod;
			var value = data[colId];
			
			
			// 피벗 셀 갱신
			var arrPivotKey = this._clonePivotKey(data._jsonPivotKeyValue);
			var arrGroupKey = this._clonePivotKey(data._jsonGroupKeyValue);
			
			var jsonResult = this.setPivotCell(value, arrGroupKey, arrPivotKey, colId, pivotKeyLength, null, arrPivotKeysForSearch);
			// 반환형 jsonResult = {row: n, col: n, value: n}
			
			
			// 집계값 갱신 
			this._updatePivotSum(colId, sumMethod, value, arrPivotKey, arrGroupKey);
			
			// footer값 갱신 
			// jsonResult = {row: n, col: n, value: n}  // arrFooterSums[i] = {sum: 0, max: null, min: null, count: 0};
			var footerSum = arrFooterSums[jsonResult.col]; 
			footerSum.sum += value;
			footerSum.max = (footerSum.max == null ? value : (footerSum.max > value ? footerSum.max : value));
			footerSum.min = (footerSum.min == null ? value : (footerSum.max < value ? footerSum.max : value));
			footerSum.count++;
			footerSum.sumMethod = sumMethod.toUpperCase();
		}
		
	}

    // 별도의 열추가 시작  ===================
    if (this._arrMoreSumInfos.length > 0){    // 형식: [{headerText:"XXX", colId:"XXX", sumMethod:"XXX"}, ...]
    	this._arrMoreColumnDatas.clear();
    	for (var moreNdx = 0; moreNdx < this._arrMoreSumInfos.length; moreNdx++){
    		var moreSumInfo = this._arrMoreSumInfos[moreNdx];
 	        this._arrMoreColumnDatas[moreNdx] = this._addivotColumnToLast(moreSumInfo.colId, moreSumInfo.sumMethod, moreSumInfo);   		
    	}
    }
    // 별도의 열 추가 종료 ===================
    

    // 푸터데이터 작성 
	if (this.sheet.showFooter) {
		for (var i=0; i < this._arrFooterSums.length; i++){
			var jsonFooterSum = this._arrFooterSums[i];
			jsonFooterSum.value = ( jsonFooterSum.sumMethod == "SUM" ? jsonFooterSum.sum : 
				jsonFooterSum.sumMethod == "AVG" ? jsonFooterSum.sum / this._rowCount_NonGroup :
					jsonFooterSum.sumMethod == "MIN" ? jsonFooterSum.min :
						jsonFooterSum.sumMethod == "COUNT" ? jsonFooterSum.count :
							jsonFooterSum.sumMethod == "MAX" ? jsonFooterSum.max : 0);
			
		}
	}

	// 시트를 그린다
//    console.log("arrPivotCaptions");
//    console.table(arrPivotCaptions);
    
//    console.log("arrGroupCaptions");
//    console.table(arrGroupCaptions);

//    console.log("_arrDatas");
//    console.table(this._arrDatas);
    
    this._arrPivotCaptions = arrPivotCaptions;
    this._arrGroupCaptions = arrGroupCaptions;

	this.setPivotCaptionSettings();
    this.setPivotToSheet();

    return;
};

EasyPivot.prototype.setPivotToSheet = function(){
	
    var arrPivotCaptions = this._arrPivotCaptions;
    var arrGroupCaptions = this._arrGroupCaptions;
    
	var sheet = this.sheet;
	sheet.instantUpdateControl = false;
	sheet.hideRowHeader = true;
	
//	var columns = sheet.getColumns();
	var columns = JSON.parse(JSON.stringify(this._originSheetColumns));
	
	// STEP 1:  기초데이터 클리어 
	this._skipFlag = true;
	sheet.clear();
	this._skipFlag = false;
	
	sheet.dataSet.clear();
	sheet.columns.clear();
	//sheet.maxRows = 0; 

	
	// STEP 2:  칼럼타이틀을 만든다 
	
	// 2-1. this.columns <- 그룹항목의 좌상단 헤더 만들기
	for (var i = 0; i < this._jsonGroupKey.length; i++){
		var colNum0 = i;
		var colNum1 = colNum0 + 1;
		var colNum  = colNum0 + sheet.startRowColNum;
		
		//  해당 순서에 해당하는 원본 칼럼을 구한다 
		var colId0 = this._arrSheetColIds[i];
		
//		var column = this.colInfos[colId0];
		var colinfo = this.colInfos[colId0];
		var column = columns[i];
		column.colId = colinfo.colinfo;
		column.fieldtype = colinfo.fieldtype;
		column.sumMethod = colinfo.sumMethod;
		
		// 원본칼럼을 복사한다 
		var jsonInfo = JSON.parse(JSON.stringify(column));
		jsonInfo.sheetCol = colNum1;
		
		//JSON.parse 과 JSON.stringify 함수를 사용하는 복사 방법으로는 속성 값이 함수인 경우 복사가 되지 않아 함수만 따로 복사해줘야 한다
		var originColumn = this._originSheetColumns[i];
		var key = null; var val = null;
		for(key in originColumn){
			val = originColumn[key];
			if( typeof val == "function" ){
				jsonInfo[key] = val;
			}
			val = null;
			key = null;
		}
		originColumn = null;
		
		// 원본에서 추가로 수정될 내용을 정리한다 (칼럼아이디, 캡션)
		var varKey = this._jsonGroupKey[i];		
		var colId = (varKey instanceof Array ? varKey.join("_") : varKey);
		jsonInfo.colId = colId;
		
		jsonInfo.caption = arrGroupCaptions[i + 1];  // 1 부터 시작
		
		// 시트에 추가한다 
		sheet.addColumn(colNum1, jsonInfo);
	}
	
	// 2-2. this.columns <- 피벗 항목의 상단 헤더 만들기
	var levelCountOfPivot = this._jsonPivotKey.length;
	var levelCountOfGroup = this._jsonGroupKey.length;
	var countOfField      = this._arrSheetColIds.length - levelCountOfGroup;
	var columnCountOfPivot = this._arrPivotKeys.length;
	var additionalColumnCount = this._arrMoreSumInfos.length;
	var tempIndexOfSumColumn = 0;
	var columnsCount = columns.length;

    for (var i=0; i < columnCountOfPivot; i++){
     	
    	// 그룹 칼럼번호에 이어서 칼럼번호 부여
		var colNum0 = i + levelCountOfGroup;
		var colNum1 = colNum0 + 1;
		var colNum  = colNum0 + sheet.startRowColNum;
		
		//  해당 순서에 해당하는 원본 칼럼을 구한다 
		var ndx    = (i % countOfField) + levelCountOfGroup;
//		var ndx    = (i % (columnsCount - levelCountOfGroup)) + levelCountOfGroup;
		var colId0 = this._arrSheetColIds[ndx];
		
//		var column = this.colInfos[colId0];
		var colinfo = this.colInfos[colId0];
		var column = columns[ndx];
		column.colId = colinfo.colId;
		column.fieldtype = colinfo.fieldtype;
		column.sumMethod = colinfo.sumMethod;
		
		// 원본칼럼을 복사한다 
		var jsonInfo = JSON.parse(JSON.stringify(column));
		jsonInfo.sheetCol = colNum1;
		
		//JSON.parse 과 JSON.stringify 함수를 사용하는 복사 방법으로는 속성 값이 함수인 경우 복사가 되지 않아 함수만 따로 복사해줘야 한다
		var originColumn = this._originSheetColumns[ndx];
		var key = null; var val = null;
		for(key in originColumn){
			val = originColumn[key];
			if( typeof val == "function" ){
				jsonInfo[key] = val;
			}
			val = null;
			key = null;
		}
		originColumn = null;
		
		// 원본에서 추가로 수정될 내용을 정리한다 (칼럼아이디, 캡션)
    	var arrPivotKey = this._arrPivotKeys[i];
		var colId = arrPivotKey[levelCountOfPivot] + "_" + (typeof arrPivotKey.ndx == "undefined" ? "sum_" + (++tempIndexOfSumColumn) : arrPivotKey.ndx);		
		jsonInfo.colId = colId;
		
		jsonInfo.caption = Array.isArray(arrPivotCaptions[i]) ? arrPivotCaptions[i].join("_") : arrPivotCaptions[i];  // 배열값임에 주의 

		// 시트에 추가한다 
		sheet.addColumn(colNum1, jsonInfo);
		
    }
	
 	// 2-3. this.columns <- 별도의 열 추가  상단 헤더 만들기
    // 형식: [{headerText:"XXX", colId:"XXX", sumMethod:"XXX"}, ...]
    for (var i = 0; i < additionalColumnCount; i++){ 
    	var moreSumInfo = this._arrMoreSumInfos[i];
    	
    	var colNum0 = i + levelCountOfGroup + columnCountOfPivot;
    	var colNum1 = colNum0 + 1;
    	var colNum  = colNum0 + sheet.startRowColNum;
    	var colId = moreSumInfo.colId + "_" + moreSumInfo.sumMethod;
    	
    	var jsonInfo = {
    			colDataType: "number",
    			colId: colId,
    			sheetCol: colNum1,
    			caption: moreSumInfo.headerText
    	};
    	
    	// 시트에 추가한다 
    	sheet.addColumn(colNum1, jsonInfo);
    	
    }
    
	// console.table(sheet.columns);
    
    // STEP 3:  고정칼럼 카운트 지정
    // 좌: 그룹 칼럼 숫자만큼 
    this.sheet.sheetRenderer.leftFixColumnCount = levelCountOfGroup;
    // 우: 추가열수 
    this.sheet.sheetRenderer.rightFixColumnCount = additionalColumnCount;
    
    // STEP 4:  데이터 채우기
    for (var rowNum0=0, rowNum1=1; rowNum0 < this._arrDatas.length; rowNum0++){
    	var resultObject = sheet.dataSet.insertData(rowNum0);
    	var record = {};
    	
        // 4-1. 그룹키 레이블 계산 
        // this._arrGroupKeys
    	var arrGroupKey = this._arrGroupKeys[rowNum0];
    	var isLogical = false;
    	for(var colNum0 = arrGroupKey.length - 1; colNum0 >= 0; colNum0--){
    		if( arrGroupKey[colNum0] == null ){
    			isLogical = true; break;
    		}
    	}
    	if( !isLogical ) sheet.dataSet.data[rowNum0].__STATE__["rowNum"] = rowNum1++;
    	
    	var arrCaptions = arrGroupKey.arrLabel;
    	for (var colNum0 = 0; colNum0 < this._jsonGroupKey.length; colNum0++){
    		var colId = sheet.columns[colNum0].colId;
    		record[colId] = arrCaptions[colNum0];
    	}
    	
        // 4-2. 피벗 데이터 채우기
    	arrCaptions = this._arrDatas[rowNum0];
        for (var i=0; i < columnCountOfPivot; i++){
    		var colNum0 = i + levelCountOfGroup;
    		var colId = sheet.columns[colNum0].colId;
    		
    		record[colId] = arrCaptions[i];
        }    	
    	
        // 4-3. 추가열 데이터 채우기
        for (var i = 0; i < additionalColumnCount; i++){ 
        	var colNum0 = i + levelCountOfGroup + columnCountOfPivot;
    		var colId = sheet.columns[colNum0].colId;
        	
    		record[colId] = this._arrMoreColumnDatas[i][rowNum0];
        }
        
        sheet.dataSet.updateData(rowNum0, record);
        
    }
//    console.table(sheet.dataSet.data);
    
    
    // STEP 5: 풋터 채우기
    // !!! UpdataScreen에서 엎어치지 않게 할것 
    var maxFooterRow = 0;
//	for (var i = 0; i < this.footerInfos.length; i++){   // EXOColumn 객체로 구성됨
//		var column = this.footerInfos[i];
//		column.value = this._arrFooterSums[i].value;
//		maxFooterRow = (maxFooterRow >= column.sheetRow) ? maxFooterRow : column.sheetRow;
//	}
	
	// STEP 6: sheet.displayInfo 채우기 
	sheet.displayInfo.startRow = 0;
	sheet.displayInfo.endRow = sheet.displayInfo.dataCount - 1;
	sheet.displayInfo.topFrozens = 0;
	
	sheet.displayInfo.leftFrozens = levelCountOfGroup;
	sheet.displayInfo.rightFrozens = additionalColumnCount;
	sheet.displayInfo.bottomFrozens = maxFooterRow;
   
    
    // STEP 7:  Merge 필요정보 대입
	for (var colNum0=0; colNum0 < levelCountOfGroup; colNum0++){
		var colNum = colNum0 + sheet.startRowColNum;
		
		if (colNum0 == 0){
			sheet.setColumnAttribute(colNum, "cellMerge", SHEET_CELL_MERGE_ALWAYS);
		} else {
			sheet.setColumnAttribute(colNum, "cellMerge", SHEET_CELL_MERGE_RESTRICT);
		}
	}
	
	var dataRowCount = sheet.dataSet.data.length;
	if( dataRowCount <= 0 ){
		sheet.dataSet.insertData();
		dataRowCount++;
	}
	
	sheet.maxRows = dataRowCount;
	sheet.maxCols = this._arrGroupCaptions.length - 1 + this._arrPivotCaptions.length;
	
	// 차대리 확인사항 
	console.clear();
	console.log("%cEasyMaker", "color: orange; font-family: sans-serif; font-size: 7em; font-weight: bolder; text-shadow: #000 1px 1px;");
	console.log("========== 차대리 확인사항 ==================");
	console.log("sheet._pivotCaptionSettings  ==================");
	console.log(this.sheet._pivotCaptionSettings);
	console.log("this._arrPivotCaptions  ==================");
	console.log(this._arrPivotCaptions);
	console.log("this._arrGroupCaptions  ==================");
	console.log(this._arrGroupCaptions);
	console.log("sheet.dataSet.data      ==================");
	console.table(sheet.dataSet.data)	
	
	
	//메모리 해제
	columns.clear(); columns = null;
	
	// STEP 8: 시트갱신 
	sheet.instantUpdateControl = true;
//	sheet.updateScreen(SHEET_RESET_DESIGN);
	sheet.updateScreen(SHEET_RESET_DATA);
	
	// 편집모드 끝날때까지 임시로 막음 
	sheet.col = 1; sheet.col2 = sheet.maxCols;
	sheet.blockMode = true;
	sheet.setLockMode(true);
	sheet.blockMode = false;
}

EasyPivot.prototype.setPivotCaptionSettings = function(){
    var arrPivotCaptions = this._arrPivotCaptions;
    var arrGroupCaptions = this._arrGroupCaptions;
	var arrMoreSumInfos = this._arrMoreSumInfos;
	
	var pivotLevels = this._jsonPivotKey.length + 1;
	
	// 결과물 생성
	var arrResults = [];
	for (var level = 0; level < pivotLevels; level++) {
		var arrRowInfos = arrResults[level] = [];
		var nth = -1;
		
		// 그룹헤더 반영
		if (level == 0){
			for (var j = 1; j < arrGroupCaptions.length; j++){  // arrGroupCaptions의 첫데이터는 null로 비어 있슴 
				nth++;
				arrRowInfos[nth] = {caption:arrGroupCaptions[j], rowspan: pivotLevels, colspan: 1};
			}
		}
		
		// 칼럼헤더 반영
		var lastLinkedCaption = ""; 
		for (var j = 0; j < arrPivotCaptions.length; j++){  // arrPivotCaptions는 첫데이터부터 채워져 있슴 
			var linkedCaption = arrPivotCaptions[j].slice( 0, level + 1).join(":"); 
			var caption = arrPivotCaptions[j][level];
			
			if (linkedCaption !== lastLinkedCaption){
				nth++;
				arrRowInfos[nth] = {caption: caption, rowspan: 1, colspan: 1};  
				lastLinkedCaption = linkedCaption;
			} else {
				arrRowInfos[nth].colspan += 1;linkedCaption
			}
		}
		
		// 추가 집계칼럼 채우기 
		if (level == 0){
			for (var j = 1; j < arrMoreSumInfos.length; j++){  // arrGroupCaptions의 첫데이터는 null로 비어 있슴 
				nth++;
				arrRowInfos[nth] = {caption:arrMoreSumInfos[j].headerText, rowspan: pivotLevels, colspan: 1};
				  
			}
		}
		
	}
	
	this.sheet._pivotCaptionSettings = arrResults;
	
	return;
};


// 리턴값 [{row:줄번호, col:칼럼번호, value:변경값}, ... ]
EasyPivot.prototype._updatePivotSum = function(colId, sumMethod, value, arrPivotKey_p, arrGroupKey_p) {
	var arrPivotKeysForSearch = this._arrPivotKeysForSearch;
	var arrCellsToUpdate = [];
	var ndx = 0;
	
	var arrPivotKeys = this._arrPivotKeys;
	var arrGroupKeys = this._arrGroupKeys;
	var arrDatas     = this._arrDatas;
	var arrFooterSums = this._arrFooterSums;
	
	var pivotKeyLength = this._jsonPivotKey.length;
	var groupKeyLength = this._jsonGroupKey.length;

	// 피벗합계 갱신
	arrPivotKey = this._clonePivotKey(arrPivotKey_p);
	arrGroupKey = this._clonePivotKey(arrGroupKey_p);
	for (var pivotNdx = pivotKeyLength - 1; pivotNdx >= 0; pivotNdx--){
		arrPivotKey[pivotNdx] = null;
		
		if (!this._needPivotKey[pivotNdx + 1]) continue;
		var jsonResult = this.setPivotCell(value, arrGroupKey, arrPivotKey, colId, pivotKeyLength, sumMethod, arrPivotKeysForSearch);
		arrCellsToUpdate[ndx++] = jsonResult;

		// footer값 갱신 
		// jsonResult = {row: n, col: n, value: n}  // arrFooterSums[i] = {sum: 0, max: null, min: null, count: 0};
		var footerSum = arrFooterSums[jsonResult.col]; 
		footerSum.sum += value;
		footerSum.max = (footerSum.max == null ? value : (footerSum.max > value ? footerSum.max : value));
		footerSum.min = (footerSum.min == null ? value : (footerSum.max < value ? footerSum.max : value));
		footerSum.count++;
		footerSum.sumMethod = sumMethod.toUpperCase();
	
	}
	
	// 그룹피벗합계갱신
	arrPivotKey = this._clonePivotKey(arrPivotKey_p);
	arrGroupKey = this._clonePivotKey(arrGroupKey_p);
	for (var groupNdx = groupKeyLength - 1; groupNdx >= 0; groupNdx--){
		arrGroupKey[groupNdx] = null;

		if (!this._needGroupKey[groupNdx + 1]) continue;
		arrCellsToUpdate[ndx++] = this.setPivotCell(value, arrGroupKey, arrPivotKey, colId, pivotKeyLength, sumMethod, arrPivotKeysForSearch);
	}
	
	// 그룹&피벗 합계갱신 
	arrPivotKey = this._clonePivotKey(arrPivotKey_p);
	arrGroupKey = this._clonePivotKey(arrGroupKey_p);
	for (var groupNdx = groupKeyLength - 1; groupNdx >= 0; groupNdx--){
		arrGroupKey[groupNdx] = null;

		if (!this._needGroupKey[groupNdx + 1]) continue;

		arrPivotKey = this._clonePivotKey(arrPivotKey_p);
	    for (var pivotNdx = pivotKeyLength - 1; pivotNdx >= 0; pivotNdx--){
			arrPivotKey[pivotNdx] = null;

			if (!this._needPivotKey[pivotNdx + 1]) continue;
			arrCellsToUpdate[ndx++] = this.setPivotCell(value, arrGroupKey, arrPivotKey, colId, pivotKeyLength, sumMethod, arrPivotKeysForSearch);
	    }
	}
	
	return arrCellsToUpdate; 
};

EasyPivot.prototype._addivotColumnToLast = function(colId, summingMethod, moreSumInfo){
	var arrGroupKeys = this._arrGroupKeys;
	var data_new = new Array(arrGroupKeys.length);
	var data_cnt = new Array(arrGroupKeys.length);
	var data_sum = new Array(arrGroupKeys.length);

    // footerData
    var footer_cnt = 0;
    var footer_sum = 0;
    var footer_amt = 0;
   
	// 피벗키별로 데이터 집계 
    var datas = this.dataSet.data;
	for (var rowNum = 0; rowNum < datas.length; rowNum++){
		// 단위 데이터 처리 
		var data = datas[rowNum];
		if (data.rowType == "Logical") continue;

        var arrGroupKey = this._clonePivotKey(data._jsonGroupKeyValue);
		var value = data[colId];

		var rowIndex = binaryPivotSearch(arrGroupKeys, arrGroupKey, 0, arrGroupKeys.length - 1);
		if (typeof data_new[rowIndex] == "undefined"){
			data_new[rowIndex] = (summingMethod == "COUNT" ? 1 : value);

    		data_cnt[rowIndex] = 1;
    		data_sum[rowIndex] = value;

		} else {
		    data_sum[rowIndex] = data_sum[rowIndex] + value;
		    data_cnt[rowIndex] = data_cnt[rowIndex] + 1;

		    var cellValue = data_new[rowIndex];

	    	if (summingMethod == "SUM") data_new[rowIndex] = data_sum[rowIndex]; 
	    	if (summingMethod == "AVG") data_new[rowIndex] = data_sum[rowIndex] / data_cnt[rowIndex]; 
	    	if (summingMethod == "MIN") data_new[rowIndex] = (cellValue > value ? value : cellValue);
	    	if (summingMethod == "MAX") data_new[rowIndex] = (cellValue < value ? value : cellValue);
	    	if (summingMethod == "COUNT") data_new[rowIndex] = data_cnt[rowIndex];
		}

		// 그룹합 집계 처리 부분 
		for (var groupNdx = arrGroupKey.length - 1; groupNdx >= 0; groupNdx--){
			if (!this._needGroupKey[groupNdx + 1]) continue;

			arrGroupKey[groupNdx] = null;

			// 여기서 부터 위코드와 똑 같이 반복되는 부분  ================
			var rowIndex = binaryPivotSearch(arrGroupKeys, arrGroupKey, 0, arrGroupKeys.length - 1);
			if (typeof data_new[rowIndex] == "undefined"){
				data_new[rowIndex] = (summingMethod == "COUNT" ? 1 : value);

	    		data_cnt[rowIndex] = 1;
	    		data_sum[rowIndex] = value;

			} else {
			    data_sum[rowIndex] += value;
			    data_cnt[rowIndex]++;

			    var cellValue = data_new[rowIndex];

		    	if (summingMethod == "SUM") data_new[rowIndex] = data_sum[rowIndex]; 
		    	if (summingMethod == "AVG") data_new[rowIndex] = data_sum[rowIndex] / data_cnt[rowIndex]; 
		    	if (summingMethod == "MIN") data_new[rowIndex] = (cellValue > value ? value : cellValue);
		    	if (summingMethod == "MAX") data_new[rowIndex] = (cellValue < value ? value : cellValue);
		    	if (summingMethod == "COUNT") data_new[rowIndex] = data_cnt[rowIndex];
			}
			// 여기  까지 위코드와 똑 같이 반복되는 부분  ================
		}

		// footer Data 
	    footer_sum += value;
	    footer_cnt++;

    	if (summingMethod == "SUM") footer_amt = footer_sum; 
    	if (summingMethod == "AVG") footer_amt = footer_sum / footer_cnt; 
    	if (summingMethod == "MIN") footer_amt = (footer_amt > value ? value : footer_amt);
    	if (summingMethod == "MAX") footer_amt = (footer_amt < value ? value : footer_amt);
    	if (summingMethod == "COUNT") footer_amt = footer_cnt;
	}

	moreSumInfo.footerAmt = footer_amt;

	data_cnt.clear(); data_cnt = null;
	data_sum.clear(); data_sum = null;

	return data_new;
};

//리턴값 : {row:줄번호, col:칼럼번호, value:변경값} arrPivotKeysForSearch: arrPivotKeys를 검색용으로 소팅한 것 
EasyPivot.prototype.setPivotCell = function(value, arrGroupKey, arrPivotKey, colId, pivotKeyLength, sumMethod, arrPivotKeysForSearch) {

	var arrDatas     = this._arrDatas;
	var arrPivotKeys = this._arrPivotKeys;
	var arrGroupKeys = this._arrGroupKeys;
	var arrSumDatas  = this._arrSumDatas;
	
	// 셀위치 찾기
	arrPivotKey[pivotKeyLength] = colId; // 임시로 칼럼명을 키로 추가
    
	var rowIndex = binaryPivotSearch(arrGroupKeys, arrGroupKey, 0, arrGroupKeys.length - 1);
	if (rowIndex == -1){
		if(typeof console != "undefined" && typeof console.log == "function")	console.log("Group 위치를 찾지 못했습니다.");
		return null;
	} 
	
	var colIndex = -1;
	var colSearchIndex = binaryPivotSearch(arrPivotKeysForSearch, arrPivotKey, 0, arrPivotKeys.length - 1);
	if (colSearchIndex >= 0){
		colIndex = arrPivotKeysForSearch[colSearchIndex].seq;
	}
	
	if (colIndex == -1){
		if(typeof console != "undefined" && typeof console.log == "function")	console.log("Pivot 위치를 찾지 못했습니다.");
		return null;
	}
	arrPivotKey.pop(); // 임시칼럼키 삭제

	// 집계처리 
	var cellValue; var cnt = 0;
	if (sumMethod == "AVG"){
		// count 처리  [1번 레벨이 null 이면 집계데이터]
		var needPivotSum =  (arrPivotKey[pivotKeyLength - 1] == null);  
		var needGroupSum =  (arrGroupKey[arrGroupKey.length - 1] == null);
		
		if (needPivotSum && needGroupSum){
			cnt = arrPivotKeys[colIndex].cnt *  arrGroupKeys[rowIndex].cnt;
		} else if (needPivotSum){
			cnt = arrPivotKeys[colIndex].cnt;
		} else if (needGroupSum){
			cnt = arrGroupKeys[rowIndex].cnt;
		} 
		
		// Sum 처리
		if (typeof arrDatas[rowIndex][colIndex] == "undefined"){
			arrDatas[rowIndex][colIndex] = 0.0;    
			arrSumDatas[rowIndex][colIndex] = 0.0; // sum을 위해서 0 데이터를 만든다.
			cellValue = 0.0;
		} else if (typeof arrSumDatas[rowIndex][colIndex] == "undefined"){
			cellValue = 0.0;
		} else {
			cellValue = arrSumDatas[rowIndex][colIndex];
		}
	} else {
		cellValue = arrDatas[rowIndex][colIndex];
	}
	
	if (sumMethod == undefined || sumMethod == null){
		cellValue = value;
	} else if (typeof arrDatas[rowIndex][colIndex] == "undefined"){
		if (sumMethod == "COUNT"){
			cellValue = 1;
		} else {
			cellValue = value;
		}
	} else {
		if (sumMethod == "SUM"){
			cellValue += value;
		} else if (sumMethod == "MAX"){
			cellValue = (cellValue > value ? cellValue : value);
		} else if (sumMethod == "MIN"){
			cellValue = (cellValue < value ? cellValue : value);
		} else if (sumMethod == "AVG"){
			cellValue += value;
		} else if (sumMethod == "COUNT"){
			cellValue += 1;
		}
	}
	
	if (sumMethod == "AVG"){
		arrDatas[rowIndex][colIndex] = cellValue / cnt;
		arrSumDatas[rowIndex][colIndex] = cellValue;
	} else {
		arrDatas[rowIndex][colIndex] = cellValue;
	}
	
	return {row: rowIndex, col: colIndex, value: arrDatas[rowIndex][colIndex]};
	
}

function binaryPivotSearch(arrays, array, start, end) {
  if (start > end) { return -1; } //does not exist
  
  var middle = Math.floor((start + end) / 2);
  var array1 = arrays[middle];
  
  var compareResult = comparePivotKey(array1 , array);
  if (compareResult > 0) { 
	  return binaryPivotSearch(arrays, array, start, middle-1); 
  }
  if (compareResult < 0) { 
	  return binaryPivotSearch(arrays, array, middle+1, end); 
  }
  return middle; //found!
};

// null을 Max로 간주하는 비교 
function comparePivotKey(jsonGroupKeyValue1, jsonGroupKeyValue2){
	for (var i = 0; i < jsonGroupKeyValue1.length; i++){
		var varKey1 = jsonGroupKeyValue1[i];
		var varKey2 = jsonGroupKeyValue2[i];
		
		if (varKey1 != null && varKey2 == null){
			return -1;
		} else if (varKey1 == null && varKey2 != null){
			return 1;
		} else if (varKey1 instanceof Array) {
			for (var j=0; j < varKey1.length ;j++) {
				var varSubKey1 = varKey1[j];
				var varSubKey2 = varKey2[j];
				if (varSubKey1 != null && varSubKey2 == null){
					return -1;
				} else if (varSubKey1 == null && varSubKey2 != null){
					return 1;
				} else  if (varSubKey1 > varSubKey2){
					return 1;
				} else if (varSubKey1 < varSubKey2){
					return -1;
				} 
			}
		} else{
			if (varKey1 > varKey2){
				return 1;
			} else if (varKey1 < varKey2){
				return -1;
			} 
		}
	}
	// 마지막으로 jsonGroupKeyValue1까지는 같은데 jsonGroupKeyValue2가 뒤에 배열값이 더있는 경우
	// jsonGroupKeyValue2가 크다
	if (jsonGroupKeyValue1.length < jsonGroupKeyValue2.length){
		return -1;
	}
	
	return 0;
};

EasyPivot.prototype._makePivotCaption = function(data, arrFormulaOfLevel, rowNum){
	if (this._pivotKey.length == 0) return [];

	var returnJson = [];
	for (var nLevel=0; nLevel < this._jsonPivotKey.length; nLevel++){
		var levelKey = this._jsonPivotKey[nLevel];

		var formula = arrFormulaOfLevel[nLevel + 1];
		if (formula == ""){                                // 없으면 칼럼값
			if (levelKey instanceof Array){
				var value_ = "";
				for (var nSubLevel=0; nSubLevel <levelKey.length; levelKey++){
					var subKey = levelKey[nSubLevel];
					value_ += (nSubLevel > 0 ? " " : "") + data(subKey);
				}
				returnJson[nLevel] = value_;
			} else {
				returnJson[nLevel] = data[levelKey];
			}
		} else if (formula.substring(0, 8) != "formula:"){ // 필드명으로 찾아 값채움
			returnJson[nLevel] = data[formula];
		} else {
			returnJson[nLevel] = this["_pivotCaptionFormula_" + (nLevel + 1)](this.sheet, data);
		}
	}
	
	return returnJson;
};

EasyPivot.prototype._makeGroupCaption = function(data, arrFormulaOfLevel, rowNum, level){
	if (this._groupKey.length == 0) return [];

	var level0 = level - 1;
	var returnJson = [];
	for (var nLevel=0; nLevel < this._jsonGroupKey.length; nLevel++){
		var levelKey = this._jsonGroupKey[nLevel];

		var formula = arrFormulaOfLevel[nLevel + 1];
		if (nLevel > level0){
			returnJson[nLevel] = "";
		} else if (formula == "" || nLevel < level0){                                // 없으면 칼럼값
			if (levelKey instanceof Array){
				var value_ = "";
				for (var nSubLevel=0; nSubLevel <levelKey.length; levelKey++){
					var subKey = levelKey[nSubLevel];
					value_ += (nSubLevel > 0 ? " " : "") + data(subKey);
				}
				returnJson[nLevel] = value_;
			} else {
				returnJson[nLevel] = data[levelKey];
			}
		} else if (formula.substring(0, 8) != "formula:"){ // 필드명으로 찾아 값채움
			returnJson[nLevel] = data[formula];
		} else {
			returnJson[nLevel] = this["_groupCaptionFormula_" + (nLevel + 1)](this.sheet, data);
		}
	}
	
	return returnJson;
};

EasyPivot.prototype._makeGroupKey = function(data){
	if (this._jsonGroupKey.length == 0) return [];

	var returnJson = [];
	for (var i=0; i < this._jsonGroupKey.length; i++){
		var levelKey = this._jsonGroupKey[i];
		if (levelKey instanceof Array) {
			var itemKeys = levelKey;
			var itemKeyValues = [];
			for (j = 0; j < itemKeys.length; j++){
				var itemKey = itemKeys[j];
				itemKeyValues[j] = data[itemKey];
			}
			returnJson[i] = itemKeyValues;
			
		} else {
			returnJson[i] = data[levelKey];
		}
	}
	
	return returnJson;
};

EasyPivot.prototype._makePivotKey = function(data){
	if (this._pivotKey.length == 0) return [];

	var returnJson = [];
	for (var i=0; i < this._jsonPivotKey.length; i++){
		var levelKey = this._jsonPivotKey[i];
		if (levelKey instanceof Array) {
			var itemKeys = levelKey;
			var itemKeyValues = [];
			for (j = 0; j < itemKeys.length; j++){
				var itemKey = itemKeys[j];
				itemKeyValues[j] = data[itemKey];
			}
			returnJson[i] = itemKeyValues;
			
		} else {
			returnJson[i] = data[levelKey];
		}
	}
	
	return returnJson;
};

EasyPivot.prototype._clonePivotKey = function(pivotKey){ 
	return JSON.parse(JSON.stringify(pivotKey));
//	
//	var rtnPivotKey = [];
//	for (var i=0; i < pivotKey.length;i++){
//		
//		var varKey = pivotKey[i];
//		if (varKey instanceof Array) {
//			rtnPivotKey[i] = [];
//			for (var j=0; j < varKey.length;j++){
//				var subKey = varKey[j];
//				rtnPivotKey[i][j] = subKey;
//			}
//			
//		} else {
//			rtnPivotKey[i] = varKey;
//		}
//	}
//	
//	return rtnPivotKey;
};


EasyPivot.prototype._makePivotLevelKey = function(jsonPivotKeyValue, nRowLevel){
	var pivotLevelKey = [];
	var levelCount = jsonPivotKeyValue.length;
	
	for (var i = 0; i < jsonPivotKeyValue.length; i++){
		// 레벨이 1이면 다 
		if (i >= nRowLevel - 1) {
			pivotLevelKey[i] = null;
			continue;
		}
		
		// 그룹레벨별 키 범위내의 데이터 복사 
		var varKey = jsonPivotKeyValue[i];
		
		if (varKey instanceof Array) {
			var varSubKey = [];
			for (var j=0; j < varKey.length; j++) {
				varSubKey[j] = varKey[j];
			}
			pivotLevelKey[i] = varSubKey;
		} else{
			pivotLevelKey[i] = varKey;
		}
	}

	if (typeof jsonPivotKeyValue.arrLabel != "undefined"){
		pivotLevelKey.arrLabel = new Array(levelCount);
		for (var i = 0; i < jsonPivotKeyValue.length; i++){
			if (i == nRowLevel - 1) {
				var colId = this._jsonGroupKey[i];
				var sumMethod = this.colInfos[colId].sumMethod;
				if (sumMethod.substring(0,5).toUpperCase() == "TEXT:"){
					var sumString = sumMethod.substring(5);
					
				}
				pivotLevelKey.arrLabel[i] = sumString; //null;
				continue;
			} else if (i > nRowLevel - 1) {
				pivotLevelKey.arrLabel[i] = ""; //null;
				continue;
			}
			pivotLevelKey.arrLabel[i] = jsonPivotKeyValue.arrLabel[i];
		}
	}

	
	return pivotLevelKey;
};

EasyPivot.prototype._makePivotLevelCaption = function(jsonPivotCaption, nRowLevel){
	var pivotLevelCaption = [];
	var levelCount = jsonPivotCaption.length;
	for (var i = 0; i < jsonPivotCaption.length; i++){
		
		// 그룹레벨별 키 범위내의 원본 데이터 복사 
		pivotLevelCaption[i] = "";
		// 레벨이 1이면 다 

		if (i == nRowLevel - 1) {
			// 디폴트로 colId, sumMethod를 채윤다
			var varKey = this._jsonPivotKey[i];
			var colId = (varKey instanceof Array ? varKey[0] : varKey);
			var sumMethod = this.colInfos[colId].sumMethod;

			// 배열인 경우 하위키 루핑 돌며 sumMethod를 찾는다, gk위키중 맨 마지막의 sumMethod를 활용한다.
			if (varKey instanceof Array){
				// 하위키중 하나라도 sumMethod가 있으면 그메서드를 적용하고 
		        // 하위키 모두 있으면 나중에 나온것을 적용한다.
				for (var nSubIndex = 0; nSubIndex < varKey.length; nSubIndex++){
					var colId1 = varKey[nSubIndex];
					if (colId1 == "") continue;
					
					if (this.colInfos[colId1].sumMethod.trim().length != 0){
						colId = colId1;
						sumMethod = this.colInfos[colId1].sumMethod;
					}
				}
			}
			
			//var colId = this._jsonPivotKey[i];
			//var sumMethod = this.colInfos[colId].sumMethod;
			
			if (sumMethod.substring(0,5).toUpperCase() == "TEXT:"){
				var sumString = sumMethod.substring(5);
				
				for (var nPivotLevel1 = i; nPivotLevel1 < levelCount; nPivotLevel1++ ){
					if (nPivotLevel1 > 0 && pivotLevelCaption[nPivotLevel1 - 1] != sumString){
						pivotLevelCaption[nPivotLevel1] = pivotLevelCaption[nPivotLevel1 - 1] + " " + sumString;
					} else {
						pivotLevelCaption[nPivotLevel1] = sumString;
					}
				}
				break;
			}
			
		} else {
			pivotLevelCaption[i] = jsonPivotCaption[i];
		}
		
	}
	return pivotLevelCaption;
};


/*
 * 첫번쨰인수가 레코드 또는 배열이다
 * */
function _checkIfPivotLevelKeyChanged(jsonKeyValue, jsonPivotKeyValue, nRowLevel){
	var keyChanged = false;
	
	for (var i = 0; i < nRowLevel - 1; i++){
		
		// 그룹레벨별 키 범위내의 데이터 복사 
		var varKey1 = jsonKeyValue[i];
		var varKey2 = jsonPivotKeyValue[i]
		
		if (varKey1 instanceof Array) {
			for (var j=0; j < varKey1.length; j++) {
				if (varKey1[j] != varKey2[j]){
					keyChanged = true; break;
				}
			}
			} else{
			if (varKey1 != varKey2){
				keyChanged = true;
			}
		}
		if (keyChanged) break;
	} 
	
	return keyChanged;
};

EasyPivot.prototype.getGroupKey = function(){ return this._groupKey;};
EasyPivot.prototype.setGroupKey = function(groupKey){
	
	if(groupKey.length == 0) return;
	
	this._groupKey = groupKey;
	
	var levelKeyArr = groupKey.split(",");
	var groupKeys = [];
	for (var i=0; i < levelKeyArr.length; i++){
		var levelKey = levelKeyArr[i];
		if (levelKey.length == 0) continue;
		
		if (levelKey.indexOf(":") >= 0){
			groupKeys[i] = levelKey.split(":");
		} else {
			groupKeys[i] = levelKey;
		}
	}
	this._jsonGroupKey = groupKeys;

	return;
};

/**
 * Dataset에 PivotTable을 구성하기 위한 PivotColumn을 지정하는 Property
 * @return               (String) 피벗키를 나타내는 문자열
 * */
EasyPivot.prototype.getPivotKey = function(){ return this._pivotKey;};

/**
 * Dataset에 PivotTable을 구성하기 위한 PivotColumn을 지정하는 Property
 * @param pivotKey     (String) 피벗키를 나타내는 문자열
 * */
EasyPivot.prototype.setPivotKey = function(pivotKey){
	this._pivotKey = pivotKey;
	
	var levelKeyArr = this._pivotKey.split(",");
	for (var i=0; i < levelKeyArr.length; i++){
		var levelKey = levelKeyArr[i];
		if (levelKey.indexOf(":") >= 0){
			this._jsonPivotKey[i] = levelKey.split(":");
		} else {
			this._jsonPivotKey[i] = levelKey;
		}
	}
	
	return;
};



/**
 * @ignore
 * @description 
 *    시트의 rowNum 줄의 colId, colIndex로 데이터를 찾아 값을 대입한다  <br/>
 *    피벗에서는 같은 칼럼이 주기적으로 우측으로 가면서 발생 한다 
 *    그 중 몇번째인가가 nthPosition 이다 
 * 
 * @param  {number}			roNum		- 값을 채을 줄번호 
 * @param  {String|number}	colId		- Dataset의 colId 
 * @param  {String/number}	value		- 채울 대이터값
 * @param  {String}			nthPosition	- 칼럼데이터중 몇번째 것인지
 * 
 * @example
 *     pivot._setPivotColumn(0, "sales", 10, 1);     // 0번줄 두번째 'sales' 칼럼의 값을 10으로 채움 
 */
EasyPivot.prototype._setPivotColumn = function(rowNum, colId, varVal, nthPosition){
	var colNum = this._colNumOfPivotColumn(colId, nthPosition);
	if (colNum < 0) return;
	
	this.updatePivotCell(rowNum, colNum, varVal);
	return;

};

/**
 * @description 
 *    시트의 rowNum 줄의 columnIndex로 데이터를 찾아 값을 대입한다  <br/>
 *    시트에  해당셀은 이미 수정되었는 상황을 전제 
 *    oldValue는 생략 가능하다  
 * 
 * @param  {number}			rowIndex		- 값을 채을 줄번호 
 * @param  {number}	        columnIndex		- 시트의 칼럼번호
 * @param  {String/number}	value			- 채울 대이터값
 * @param  {String/number}	oldValue		- 변경전 데이터값
 * 
 * @example
 *     pivot.updatePivotCell(0, 2, 1, 9);     // 0번줄 세번째 칼럼의 값을 9에서 0으로 바꿈
 */
EasyPivot.prototype.updatePivotCell = function(rowIndex, columnIndex, value, oldValue){
	var arrPivotKeys = this._arrPivotKeys;
	var arrGroupKeys = this._arrGroupKeys;
	var arrDatas     = this._arrDatas;
	
	var jsonPivotKey = this._jsonPivotKey;
	var jsonGroupKey = this._jsonGroupKey;
	
	var pivotKeyLength = this._jsonPivotKey.length;
	var groupKeyLength = this._jsonGroupKey.length;
	
	// 오류체크 
	if (rowIndex >= arrDatas.length){
		var msg = getText("message_EasySheet_032", "현재의 줄 수 {0}보다 클 수는 없습니다.\n줄번호가 {1}입니다.\n{2}", [arrDatas.length, rowIndex, "sheet.updatePivotCell"]);
    	console.warn(msg);
    	return;
	}
	if (columnIndex >= arrDatas[rowIndex].length){
    	var msg = getText("message_EasySheet_037", "현재의 열 수 {0}보다 클 수는 없습니다.\n열번호가 {1}입니다.\n{2}", [arrDatas[rowIndex].length, columnIndex, "sheet.updatePivotCell"]);
    	console.warn(msg);
    	return;
	}
	
	// 0. 해당데이터 수정 
	if (typeof oldValue == "undefined"){
		oldValue = arrDatas[rowIndex][columnIndex - groupKeyLength];
	}
	arrDatas[rowIndex][columnIndex - groupKeyLength] = value;
	
	// 1. 칼럼번호로 피벗키를 찾는다 , 앞부분에 그룹키가 채워져 있으니 감안해 준다.
	var arrPivotKey = arrPivotKeys[columnIndex - groupKeyLength];
	var colId = arrPivotKey[pivotKeyLength]; // 추가된 마지막 레벨이 칼럼ID가 들어가 있다. 
	var sumMethod = this.colInfos[colId].sumMethod;
		
	// 2. 줄번호로   그룹키를 찾는다 
	var arrGroupKey = arrGroupKeys[rowIndex];
	
	// 3. 합계 업데이트 
	var arrCellsToUpdate = this._updatePivotSum(colId, sumMethod, value - oldValue, arrPivotKey, arrGroupKey);
	
	// 3. 그룹키 + 피봇키로 원본데이터셋에서 레코드를 찾는다 
	var arrDataKey = [];
	for (var nLevel=0; nLevel < this._jsonPivotKey.length; nLevel++){
		var fieldId = ""; var value_ = null;
		var levelKey = this._jsonPivotKey[nLevel];
		
		if (levelKey instanceof Array) {
			for (var nSubLevel=0; nSubLevel < levelKey.length; nSubLevel++){
				fieldId = levelKey[nSubLevel];				
				value_ = arrPivotKey[nLevel][nSubLevel];
				arrDataKey[fieldId] = value_;
			}
		} else {
			fieldId = levelKey;
			value_ = arrPivotKey[nLevel];
		    arrDataKey[fieldId] = value_;
		}
	}
	
	for (var nLevel=0; nLevel < this._jsonGroupKey.length; nLevel++){
		var fieldId = ""; var value_ = null;
		var levelKey = this._jsonGroupKey[nLevel];
		if (levelKey instanceof Array) {
			for (var nSubLevel=0; nSubLevel < levelKey.length; nSubLevel++){
				fieldId = levelKey[nSubLevel];				
				value_ = arrGroupKey[nLevel][nSubLevel];
				arrDataKey[fieldId] = value_;
			}
		} else {
			fieldId = levelKey;
			value_ = arrGroupKey[nLevel];
		    arrDataKey[fieldId] = value_;
		}
	}

	var found = false;
	for (var nRow = 0; nRow < this.dataSet.data.length; nRow++){
		var data = this.dataSet.data[nRow];
		
		found = true;
		for (var key in arrDataKey){
			if (typeof arrDataKey[key] == "function") continue;
			if (arrDataKey[key] != data[key]){
				found = false;
				break;
			}
		}
		if (found){
			//data[colId] = value;
			//data.rowType = "Update";
			var jsonToUpdate = {};
			jsonToUpdate[colId] = value;
			this.dataSet.updateData(nRow, jsonToUpdate);
			break;
		}
	}
	
	// 발견되지 않으면 레코드 추가
	if (!found){
		var resultJson = this.dataSet.insertData();
		var nRow = resultJson.recordIndex;

		var jsonToUpdate = {};
		jsonToUpdate[colId] = value;
		this.dataSet.updateData(nRow, jsonToUpdate);
	}
	
	if (this.sheet.FireEvent){
		if (this.hasPivotChangeEvent) {
			var wResult = this.fncPivotChangeEvent(rowIndex, colId, oldValue, value);
			if (typeof(wResult)=="boolean" && !wResult) {
				return ;
			}            
		}     
	}

	
	// 최종적으로 시트에 그린다 
	this.setPivotToSheet()	
	
	return;
};


/**
 * @ignore
 * @description 
 *    Dataset의 colId, colIndex로 열번호를 찾는다 <br/>
 *    RowHead 갯수는 포함이니 사용할 때 그냥 쓴다.
 *    피벗에서는 같은 칼럼이 주기적으로 우측으로 가면서 발생 한다 
 *    드줄 몇번째인가가 nPivotIndex 이다 
 * 
 * @param  {String}		colId		- Dataset의 colId <br/>
 * @param  {String}		nPivotIndex	- 칼럼데이터중 몇번째 것인지  <br/>
 * @return {Number}		결과시트의 열번호 
 * @example
 *     pivot._colNumOfPivotColumn("sales", 10);     // 열한번째 'sales' 칼럼의 값
 */
EasyPivot.prototype._colNumOfPivotColumn = function(colId, nPivotIndex){ 
	var colNum = -1;
	if (this._arrPivotKeys.length == 0) return colNum;
	
	var arrPivotKeys = this._arrPivotKeys;
	var arrGroupKeys = this._arrGroupKeys;
	var lastLevel = arrPivotKeys[0].length - 1;
	var groupKeyCount = arrGroupKeys[0].length;
	
	for (var i = 0; i < arrPivotKeys.length; i++){
		var arrPivotKey = arrPivotKeys[i];
		if (typeof arrPivotKey.ndx == "undefined") continue;
		if (arrPivotKey.ndx != nPivotIndex) continue;
		if (arrPivotKey[lastLevel] != colId) continue;
		
		colNum = i;
		break;
	}
	
	return (colNum < 0 ? -1 : colNum + groupKeyCount);
};

/**
 * @ignore
 * @description 
 *    결과시트의 시트의 열번호로 colId, colIndex를 찾는다. <br/>
 *    colNum에는 RowHead 갯수는 포함안됨. 0부터 시작
 * 
 * @param  {Number} 	colNum	- 결과시트의 시트의 눈에 보이는 열번호 <br/>
 * @return {json} 		Dataset의 colId와 colIndex로 구성 
 * @example
 *     pivot._pivotColumnOfColNum(20);  // 결과: {colId:"sales", colIndex:10} <--열한번째 'sales' 칼럼의 값
 */
EasyPivot.prototype._pivotColumnOfColNum = function(colNum){ 
	var rtnJson = {colId:"", colIndex:-1};
	
	if (colNum < this._jsonGroupKey.length) {
		return {colId:this._jsonGroupKey[colNum], colIndex:-1};
	}
	
	
	if (this._arrPivotKeys.length == 0) return rtnJson;
	var groupKeyCount = this._arrGroupKeys[0].length;

	// _arrPivotKeys 목록에서 해당 칼럼번호의 피벗키를 찾는다 
	var arrPivotKey = this._arrPivotKeys[colNum - groupKeyCount];
	
	// 피벗의 레벨이 몇레벨 깊이인지 파악 
	var lastLevel = this._arrPivotKeys[0].length - 1;
	
	// 최하위 레벨 의 피벗키와 인덱스 리턴
	rtnJson.colId = arrPivotKey[lastLevel]; 
	rtnJson.colIndex = arrPivotKey.ndx;
	
	return rtnJson;
};

/**
 * @ignore
 * @description 
 *    시트의 rowNum 줄의 colId, colIndex로 데이터를 찾는다 <br/>
 *    피벗에서는 같은 칼럼이 주기적으로 우측으로 가면서 발생 한다 
 *    그 중 몇번째인가가 nthPosition 이다 
 * 
 * @param  {number}			roNum		- 값을 찾을 줄번호 <br/>
 * @param  {String|number}	colId		- Dataset의 colId <br/>
 * @param  {String}			nthPosition	- 칼럼데이터중 몇번째 것인지<br/>
 * @return {String|number}				- 찾아진 데이터 값
 * @example
 *     pivot._colNumOfPivotColumn("sales", 10);     // 열한번째 'sales' 칼럼의 값
 */
EasyPivot.prototype._getPivotColumn = function(rowNum, colId, nthPosition){
	var colNum = this._colNumOfPivotColumn(colId, nthPosition);
	if (colNum < 0) return;
	 
	if (this._isPivotColumn(colId)){
		return this._getPivotPivotColumn(rowNum, colId, nthPosition);
	} else if (this._isGroupColumn(colId)){
		return this._getPivotGroupColumn(rowNum, colId);
	}
	
	var groupKeyLength = this._jsonGroupKey.length;
	return this._arrDatas[rowNum][colNum - groupKeyLength];
};

/**
 * @ignore
 * @description 
 *    시트의 둘번호, 열번호로 데이터를 찾는다 <br/>
 * 
 * @param  {number}			roNum		- 값을 찾을 줄번호 <br/>
 * @param  {number}	        colNum	    - 값을 찾을 시트상의 열번호 <br/>
 * @return {String|number}				- 찾아진 데이터 값
 * @example
 *     pivot._colNumOfPivotColumn("sales", 10);     // 열한번째 'sales' 칼럼의 값
 */
EasyPivot.prototype.getPivotValue = function(rowNum, colNum){
	var json = {};
	
	if (colNum < this._jsonGroupKey.length){
		json.colId = this.sheet.getColId(colNum); 
		json.colIndex = colNum; // 임시 
	} else {
		json = this._pivotColumnOfColNum(colNum);
	}
	
	var colId = json.colId;
    var nthPosition = json.colIndex;
	
	return this._getPivotColumn(rowNum, colId, nthPosition);
};


/**
 * @ignore
 * @description 
 *    시트의 현재 줄의 colId, colIndex로 데이터를 찾는다 <br/>
 *    피벗에서는 같은 칼럼이 주기적으로 우측으로 가면서 발생 한다 
 *    그 중 몇번째인가가 nthPosition 이다 
 * 
 * @param  {String|number}	colId			- Dataset의 colId <br/>
 * @param  {String}			nPivotIndex		- 칼럼데이터중 몇번째 것인지<br/>
 * @return {String|number}					- 찾아진 데이터 값
 * @example
 *     pivot._colNumOfPivotColumn("sales", 10);     // 열한번째 'sales' 칼럼의 값
 */
EasyPivot.prototype._getPivotCurrentColumn = function(colId, nPivotIndex){
	var colNum = this._colNumOfPivotColumn(colId, nPivotIndex);
	if (colNum < 0) return;
	
	var nRow = this.sheet.currentRow;
	var groupKeyLength = this._jsonGroupKey.length;
	return this._arrDatas[nRow][colNum - groupKeyLength];
};

/**
 * @ignore
 * @description 
 *    Dataset 줄번호로 colId, nthPosition로 데이터를 찾는다 <br/>
 *    이때 데이터가 그룹 칼럼인 경우 데이터값을 찾는 함수이다 
 * 
 * @param  {number}			roNum		- 값을 찾을 줄번호 <br/>
 * @param  {String|number}	strColId	- Dataset의 colId <br/>
 * @return {String|number}				- 찾아진 데이터 값
 * @example
 *     pivot._getPivotGroupColumn(1, "sales");     // 1번줄 열한번째 'sales' 칼럼의 값
 */
EasyPivot.prototype._getPivotGroupColumn = function(nRow, strColId){

	for (var i=0; i < this._jsonGroupKey.length;i++){
		var varKeyName = this._jsonGroupKey[i];
		if (varKeyName instanceof Array) {
			for (var j=0; j < varKeyName.length;j++){
				var colId = varKeyName[j];
				if (strColId === colId){
					return this._arrGroupKeys[nRow][i][j];
				}
			}
			
		} else {
			var colId = this._jsonGroupKey[i];
			if (strColId === colId){
				return this._arrGroupKeys[nRow][i];
			}
		}
	}
	return null;
};

/**
 * @ignore
 * @description 
 *    Dataset 줄번호로 colId, nthPosition로 데이터를 찾는다 <br/>
 *    이때 데이터가 상위 피벗 칼럼인 경우 데이터값을 찾는 함수이다 
 * 
 * @param  {number}			roNum		- 값을 찾을 줄번호 <br/>
 * @param  {String|number}	strColId	- Dataset의 colId <br/>
 * @param  {String}			nthPosition	- 칼럼데이터중 몇번째 것인지<br/>
 * @return {String|number}				- 찾아진 데이터 값
 * @example
 *     pivot._getPivotPivotColumn(1, "sales", 10);     // 1번줄 열한번째 'sales' 칼럼의 값
 */
EasyPivot.prototype._getPivotPivotColumn = function(nRowroNum, strColId, nthPosition){
	var groupKeyCount = this._arrGroupKeys[0].length;
	
	var lastIndex  = this._arrSheetColIds.length -1;
	var strColID = this._arrSheetColIds[lastIndex];
	var colNum = this._colNumOfPivotColumn(strColID, nthPosition) - groupKeyCount;

	if (colNum < 0) return;	
	
	for (var i=0; i < this._jsonPivotKey.length;i++){
		var varKeyName = this._jsonPivotKey[i];
		if (varKeyName instanceof Array) {
			for (var j=0; j < varKeyName.length;j++){
				var colId = varKeyName[j];
				if (strColId === colId){
					return this._arrPivotKeys[colNum][i][j];
				}
			}
			
		} else {
			var colId = this._jsonPivotKey[i];
			if (strColId === colId){
				return this._arrPivotKeys[colNum][i];
			}
		}
	}
	
	return null;
};


/**
 * @ignore
 * @description 
 *    주어진 칼럼명이 피벗키에 해당하는지 여부를 확인하는 함수 
 * 
 * @param  {String}		strColId	- Dataset의 colId <br/>
 * @return {Boolean}				    - 찾아진 데이터 값
 * @example
 *     pivot._isPivotColumn("sales");     // 'sales' 칼럼이 피벗키항목인가?
 */
EasyPivot.prototype._isPivotColumn = function(strColId){
	for (var i=0; i < this._jsonPivotKey.length;i++){
		var varKeyName = this._jsonPivotKey[i];
		if (varKeyName instanceof Array) {
			for (var j=0; j < varKeyName.length;j++){
				var colId = varKeyName[j];
				if (strColId === colId){
					return true;
				}
			}
			
		} else {
			var colId = this._jsonPivotKey[i];
			if (strColId === colId){
				return true;
			}
		}
	}
	return false;
};

/**
 * @ignore
 * @description 
 *    주어진 칼럼명이 피벗키에 해당하는지 여부를 확인하는 함수 
 * 
 * @param  {String}		strColId	- Dataset의 colId <br/>
 * @return {Boolean}				    - 찾아진 데이터 값
 * @example
 *     pivot._isPivotColumn("sales");     // 'sales' 칼럼이 피벗키항목인가?
 */
EasyPivot.prototype._isPivotColNum =  function(colNum){
	
	var json = this._pivotColumnOfColNum(colNum);
	var colId = json.colId;
	
	return this._isPivotColumn(colId);
};

/**
 * @ignore
 * @description 
 *    주어진 칼럼명이 그룹키에 해당하는지 여부를 확인하는 함수 
 * 
 * @param  {String}		strColId	- Dataset의 colId <br/>
 * @return {Boolean}				- 찾아진 데이터 값
 * @example
 *     pivot._isGroupColumn("sales");     // 'sales' 칼럼이 그룹키항목인가?
 */
EasyPivot.prototype._isGroupColumn = function(strColId){
	for (var i=0; i < this._jsonGroupKey.length;i++){
		var varKeyName = this._jsonGroupKey[i];
		if (varKeyName instanceof Array) {
			for (var j=0; j < varKeyName.length;j++){
				var colId = varKeyName[j];
				if (strColId === colId){
					return true;
				}
			}
			
		} else {
			var colId = this._jsonGroupKey[i];
			if (strColId === colId){
				return true;
			}
		}
	}
	return false;
};

/**
 * @ignore
 * @description 
 *    주어진 칼럼명이 그룹키에 해당하는지 여부를 확인하는 함수 
 * 
 * @param  {Number}		colNum	- Dataset의 colId <br/>
 * @return {Boolean}			- 찾아진 데이터 값
 * 
 * @example
 *     pivot._isGroupColNum(1);     // 2번 칼럼이 그룹키항목인가?
 */
EasyPivot.prototype._isGroupColNum = function(colNum){
	
	var json = this._pivotColumnOfColNum(colNum);
	var colId = json.colId;
	
	return this._isGroupColumn(colId);
};

/**
 * @ignore
 * @description 
 *    주어진 시트내 줄번호에 해당하는 데이터가 그룹 집계에 해당하는지 여부를 확인하는 함수 
 * 
 * @param  {Number}		rowNum	- 시트내에서의 줄번호 <br/>
 * @return {Boolean}			- 찾아진 데이터 값
 * 
 * @example
 *     pivot._isGroupRowNum(1);     // 2번 줄이 그룹별 집계열인가?
 */
EasyPivot.prototype._isGroupRowNum = function(rowNum){
	
	var arrGroupKey = this._arrGroupKeys[rowNum];
	for (var i = 0; i < arrGroupKey.length; i++){
		if (arrGroupKey[i] == null) {
			return true;
		}
	}
	
	return false;
};

EasyPivot.prototype._warnUnsupport = function(functionName){
	// 연속동작중 호출되었으면 메시지 생략
	if (this._skipFlag) return;
	
	var msg = getText("message_EasySheet_060", 
	                  "피벗이 적용된 시트에서는 'sheet.{0}'함수 적용이 되지 않습니다.\n", functionName);
    alert(msg); 
    console.warn(msg);
};


EasyPivot.prototype._checkIfValidColNum = function(colNum){
	if (this._isGroupColNum(colNum)){
		var msg = getText("message_EasySheet_061", 
                          "{0}번 칼럼은 그룹칼럼입니다. 셀을 선택할 수 없습니다.\n", colNum);
		alert(msg); 
		console.warn(msg);		
		return false;
	}
	
	if (this._isPivotColNum(colNum)){
		var msg = getText("message_EasySheet_062", 
                          "{0}번 칼럼은  피벗 칼럼입니다. 셀을 선택할 수 없습니다.\n", colNum);
		alert(msg); 
		console.warn(msg);		
		return false;
	}
	
	return true;

};

EasyPivot.prototype._checkIfValidRowNum = function(rowNum){
	if (this._isGroupRowNum(rowNum)){
		var msg = getText("message_EasySheet_063", 
                          "{0}번 줄은 그룹집계줄입니다. 셀을 선택할 수 없습니다.\n", rowNum);
		alert(msg); 
		console.warn(msg);		
		return false;
	}
	
	return true;

};



var contextMenuObj;
var MSIE = navigator.userAgent.indexOf('MSIE')?true:false;
var navigatorVersion = navigator.appVersion.replace(/.*?MSIE (\d\.\d).*/g,'$1')/1;  
var activeContextMenuItem = false;
var preoffsetHeight = 0;
var preoffsetWidth = 0;
var copyoffsetHeight = 0;
var copyoffsetWidth = 0;

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function highlightContextMenuItem() {
    this.className='contextMenuHighlighted';
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function deHighlightContextMenuItem() {
    this.className='';
};

/**
 * @description	미결
 * @name		context#showContextMenu
 * @event
 * @returns		{Boolean}
 */
function showContextMenu(e) {
    if(navigator.userAgent.indexOf('Firefox') >= 0){
        em = e.target;
        e.preventDefault();
    } else {
        em = e.srcElement;
        e.returnValue = false;
    }
    
	while (em.tagName != "TD" && em.tagName != "BODY") em = em.parentNode;
	if (em.tagName != "TD" || em.parentNode.getAttribute("id") != "Editor")	return false;

    contextMenuSource = this;
    if(activeContextMenuItem)activeContextMenuItem.className='';
    //if(document.all)e = event;
    var xPos = e.clientX;
    if(xPos + contextMenuObj.offsetWidth > (document.documentElement.offsetWidth-20)){
        xPos = xPos + (document.documentElement.offsetWidth - (xPos + contextMenuObj.offsetWidth)) - 20; 
    }
  
    var yPos = e.clientY;
    if(window.document.body.scrollTop > 0) {
        yPos = (window.screen.Height) ? e.clientY + window.document.body.scrollTop -20 : e.clientY -20;
    } else if (window.pageYOffset) {
        yPos = (window.pageYOffset > 0) ? e.clientY + window.pageYOffset -20 : e.clientY -20;
    } else { yPos = e.clientY -20; }
    
    var winH = 0;
    if (navigator.appName.indexOf("Microsoft")!=-1) {
        winH = window.offsetHeight;
    } else {
	    winH = window.innerHeight;
    }
    
    var offset = document.getElementsByName("Editer")[0];
	var offsetHeight = 0;
	var offsetWidth = 0;
	
	while (offset) {
		offsetHeight += offset.offsetTop;
		offsetWidth += offset.offsetLeft;
		offset = offset.offsetParent;
	}
	
    var windowH = parent.document.documentElement.clientHeight;
    //var windowH = document.getElementsByTagName("body")[0].clientHeight;
    var editorH = document.getElementsByName("Editer")[0].clientHeight;
    var focusH = e.clientY;
    var contextH = 251;
    
    if (copyoffsetHeight != offsetHeight) {
    	preoffsetHeight += (offsetHeight - copyoffsetHeight);
    }
    
    if (copyoffsetWidth != offsetWidth) {
    	preoffsetWidth += (offsetWidth - copyoffsetWidth);
    }
    
    //alert(focusH + " : " + editorH + " : " + windowH + " : " + offsetHeight + " : " + e.offsetY + " : " + yPos);
    //alert(offsetHeight + " : " + copyoffsetHeight + " : " + preoffsetHeight + " : " + offsetWidth + " : " + copyoffsetWidth + " : " + preoffsetWidth);
    if ((windowH-offsetHeight) < (focusH + contextH)) {
	    contextMenuObj.style.left = xPos + preoffsetWidth + 'px';
	    contextMenuObj.style.top = (yPos + 85 - contextH) + preoffsetHeight + 'px';
	    contextMenuObj.style.display='block';
    } else {
	    contextMenuObj.style.left = xPos + preoffsetWidth + 'px';
	    contextMenuObj.style.top = yPos + 65 + preoffsetHeight + 'px';
	    contextMenuObj.style.display='block';
    }
    
    copyoffsetHeight = offsetHeight;
    copyoffsetWidth = offsetWidth;
  
    return false; 
};

/**
 * @description	미결
 * @name		context#hideContextMenu
 * @event
 * @returns		{Undefined}
 */
function hideContextMenu(e) {
    //if(document.all) e = event;
    if(e.button==0 && !MSIE){
        
    }else{
        contextMenuObj.style.display='none';
    }
};

/**
 * @description	미결
 * @returns		{Undefined}
 * @example		미결
 */
function initContextMenu() {
    contextMenuObj = document.getElementById('contextMenu');
    contextMenuObj.style.display = 'block';
    var menuItems = contextMenuObj.getElementsByTagName('LI');
    for(var no=0;no<menuItems.length;no++){
        var aTag = menuItems[no].getElementsByTagName('A')[0];
        
        var img = menuItems[no].getElementsByTagName('IMG')[0];
        var hr = menuItems[no].getElementsByTagName('hr')[0];
        
        if (aTag) {
	        menuItems[no].onmouseover = highlightContextMenuItem;
	        menuItems[no].onmouseout = deHighlightContextMenuItem;
        }
        
        if(img){
            var div = document.createElement('DIV');
            div.className = 'imageBox';
            div.appendChild(img);
            
            if(MSIE && navigatorVersion<6){
                aTag.style.paddingLeft = '0px';
            }
            
            var divTxt = document.createElement('DIV'); 
            divTxt.className='itemTxt';
            divTxt.innerHTML = aTag.innerHTML;
            
            aTag.innerHTML = '';
            aTag.appendChild(div);
            aTag.appendChild(divTxt);
            if(MSIE && navigatorVersion<6){
                div.style.position = 'absolute';
                div.style.left = '2px';
                divTxt.style.paddingLeft = '15px';
            }
            
            if(!document.all){
                var clearDiv = document.createElement('DIV');
                clearDiv.style.clear = 'both';
                aTag.appendChild(clearDiv);     
            }
        } else if(hr) {
        	/*if(MSIE && navigatorVersion<6){
        		hr.style.paddingLeft = '15px';
        		hr.style.width = (hr.offsetWidth - 30) + 'px';
            }else{
            	hr.style.paddingLeft = '30px';
            	hr.style.width = (hr.offsetWidth) + 'px';
            }*/
        } else{
            if(MSIE && navigatorVersion<6){
                aTag.style.paddingLeft = '15px';
                aTag.style.width = (aTag.offsetWidth - 30) + 'px';
            }else{
                aTag.style.paddingLeft = '30px';
                aTag.style.width = (aTag.offsetWidth) + 'px';
            }
        }
    }

    contextMenuObj.style.display = 'none';      
};